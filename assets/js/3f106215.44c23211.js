"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[3805],{28453:(n,e,t)=>{t.d(e,{R:()=>a,x:()=>c});var s=t(96540);const i={},r=s.createContext(i);function a(n){const e=s.useContext(r);return s.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function c(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:a(n.components),s.createElement(r.Provider,{value:e},n.children)}},98274:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>r,metadata:()=>c,toc:()=>o});var s=t(74848),i=t(28453);const r={},a="Stack",c={id:"DSA/DSA with JavaScript/DSA Cheatsheets/Stack",title:"Stack",description:"A comprehensive guide to stack algorithms and techniques for Data Structures and Algorithms.",source:"@site/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Stack.mdx",sourceDirName:"DSA/DSA with JavaScript/DSA Cheatsheets",slug:"/DSA/DSA with JavaScript/DSA Cheatsheets/Stack",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Stack",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Stack.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Sorting Algorithms",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Sorting Algorithms"},next:{title:"Strings",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Strings"}},l={},o=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Introduction to Stacks",id:"introduction-to-stacks",level:2},{value:"Core Concepts",id:"core-concepts",level:3},{value:"Basic Template",id:"basic-template",level:3},{value:"Basic Stack Operations",id:"basic-stack-operations",level:2},{value:"1. Stack Using Array",id:"1-stack-using-array",level:3},{value:"2. Stack Using Linked List",id:"2-stack-using-linked-list",level:3},{value:"Basic Stack Problems",id:"basic-stack-problems",level:2},{value:"1. Reverse a String",id:"1-reverse-a-string",level:3},{value:"2. Check Palindrome",id:"2-check-palindrome",level:3},{value:"3. Next Greater Element",id:"3-next-greater-element",level:3},{value:"Expression Evaluation",id:"expression-evaluation",level:2},{value:"1. Infix to Postfix Conversion",id:"1-infix-to-postfix-conversion",level:3},{value:"2. Postfix Evaluation",id:"2-postfix-evaluation",level:3},{value:"3. Basic Calculator",id:"3-basic-calculator",level:3},{value:"Parentheses Problems",id:"parentheses-problems",level:2},{value:"1. Valid Parentheses",id:"1-valid-parentheses",level:3},{value:"2. Generate Parentheses",id:"2-generate-parentheses",level:3},{value:"3. Longest Valid Parentheses",id:"3-longest-valid-parentheses",level:3},{value:"4. Remove Invalid Parentheses",id:"4-remove-invalid-parentheses",level:3},{value:"Monotonic Stack",id:"monotonic-stack",level:2},{value:"1. Next Greater Element Pattern",id:"1-next-greater-element-pattern",level:3},{value:"2. Next Greater Element II (Circular Array)",id:"2-next-greater-element-ii-circular-array",level:3},{value:"3. Daily Temperatures",id:"3-daily-temperatures",level:3},{value:"4. Largest Rectangle in Histogram",id:"4-largest-rectangle-in-histogram",level:3},{value:"5. Maximal Rectangle",id:"5-maximal-rectangle",level:3},{value:"6. Trapping Rain Water",id:"6-trapping-rain-water",level:3},{value:"7. Sum of Subarray Minimums",id:"7-sum-of-subarray-minimums",level:3},{value:"Stack in Recursion",id:"stack-in-recursion",level:2},{value:"1. Binary Tree Traversal (Iterative)",id:"1-binary-tree-traversal-iterative",level:3},{value:"2. Flatten Binary Tree to Linked List",id:"2-flatten-binary-tree-to-linked-list",level:3},{value:"3. Path Sum II",id:"3-path-sum-ii",level:3},{value:"Two Stacks Problems",id:"two-stacks-problems",level:2},{value:"1. Implement Queue using Stacks",id:"1-implement-queue-using-stacks",level:3},{value:"2. Sort Stack",id:"2-sort-stack",level:3},{value:"Stack with Additional Operations",id:"stack-with-additional-operations",level:2},{value:"1. Min Stack",id:"1-min-stack",level:3},{value:"2. Max Stack",id:"2-max-stack",level:3},{value:"Advanced Stack Patterns",id:"advanced-stack-patterns",level:2},{value:"1. Asteroid Collision",id:"1-asteroid-collision",level:3},{value:"2. Decode String",id:"2-decode-string",level:3},{value:"3. Remove K Digits",id:"3-remove-k-digits",level:3},{value:"4. Valid Stack Sequences",id:"4-valid-stack-sequences",level:3},{value:"Stack in Graph Algorithms",id:"stack-in-graph-algorithms",level:2},{value:"1. Depth-First Search (DFS)",id:"1-depth-first-search-dfs",level:3},{value:"2. Topological Sort",id:"2-topological-sort",level:3},{value:"3. Find Strongly Connected Components",id:"3-find-strongly-connected-components",level:3},{value:"4. Detect Cycle in Directed Graph",id:"4-detect-cycle-in-directed-graph",level:3},{value:"Memory Management",id:"memory-management",level:2},{value:"1. Stack Overflow Prevention",id:"1-stack-overflow-prevention",level:3},{value:"2. Memory-Efficient Stack",id:"2-memory-efficient-stack",level:3},{value:"Common Optimization Tricks",id:"common-optimization-tricks",level:2},{value:"1. Stack with O(1) Min/Max Operations",id:"1-stack-with-o1-minmax-operations",level:3},{value:"2. Multiple Stacks in Single Array",id:"2-multiple-stacks-in-single-array",level:3},{value:"3. Stack with Increment Operation",id:"3-stack-with-increment-operation",level:3},{value:"4. Stack with getMiddle Operation",id:"4-stack-with-getmiddle-operation",level:3},{value:"Problem-Solving Patterns",id:"problem-solving-patterns",level:2},{value:"1. When to Use Stack",id:"1-when-to-use-stack",level:3},{value:"2. Stack Problem Templates",id:"2-stack-problem-templates",level:3},{value:"Template 1: Basic Stack Operations",id:"template-1-basic-stack-operations",level:4},{value:"Template 2: Monotonic Stack",id:"template-2-monotonic-stack",level:4},{value:"Template 3: Expression Parsing",id:"template-3-expression-parsing",level:4},{value:"Testing and Debugging",id:"testing-and-debugging",level:2},{value:"1. Stack Testing Framework",id:"1-stack-testing-framework",level:3},{value:"2. Stack Visualization",id:"2-stack-visualization",level:3},{value:"Performance Analysis",id:"performance-analysis",level:2},{value:"Time Complexity Summary",id:"time-complexity-summary",level:3},{value:"Space Complexity Considerations",id:"space-complexity-considerations",level:3},{value:"Real-World Applications",id:"real-world-applications",level:2},{value:"1. Browser History",id:"1-browser-history",level:3},{value:"2. Undo/Redo System",id:"2-undoredo-system",level:3},{value:"3. Function Call Stack Simulator",id:"3-function-call-stack-simulator",level:3},{value:"Conclusion",id:"conclusion",level:2},{value:"<strong>Essential Patterns:</strong>",id:"essential-patterns",level:3},{value:"<strong>When to Use Stacks:</strong>",id:"when-to-use-stacks",level:3},{value:"<strong>Optimization Techniques:</strong>",id:"optimization-techniques",level:3},{value:"<strong>Best Practices:</strong>",id:"best-practices",level:3}];function h(n){const e={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"stack",children:"Stack"})}),"\n",(0,s.jsx)(e.p,{children:"A comprehensive guide to stack algorithms and techniques for Data Structures and Algorithms."}),"\n",(0,s.jsx)(e.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#introduction-to-stacks",children:"Introduction to Stacks"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#basic-stack-operations",children:"Basic Stack Operations"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#stack-implementation",children:"Stack Implementation"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#basic-stack-problems",children:"Basic Stack Problems"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#expression-evaluation",children:"Expression Evaluation"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#parentheses-problems",children:"Parentheses Problems"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#monotonic-stack",children:"Monotonic Stack"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#stack-in-recursion",children:"Stack in Recursion"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#two-stacks-problems",children:"Two Stacks Problems"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#stack-with-additional-operations",children:"Stack with Additional Operations"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#advanced-stack-patterns",children:"Advanced Stack Patterns"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#stack-in-graph-algorithms",children:"Stack in Graph Algorithms"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#memory-management",children:"Memory Management"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#common-optimization-tricks",children:"Common Optimization Tricks"})}),"\n"]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"introduction-to-stacks",children:"Introduction to Stacks"}),"\n",(0,s.jsxs)(e.p,{children:["A ",(0,s.jsx)(e.strong,{children:"Stack"})," is a linear data structure that follows the ",(0,s.jsx)(e.strong,{children:"Last In First Out (LIFO)"}),' principle. Elements are added and removed from the same end, called the "top" of the stack.']}),"\n",(0,s.jsx)(e.h3,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"LIFO Principle:"})," The last element pushed onto the stack is the first one to be popped off."]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Main Operations:"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Push:"})," Add an element to the top"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Pop:"})," Remove the top element"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Peek/Top:"})," View the top element without removing it"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"isEmpty:"})," Check if stack is empty"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"basic-template",children:"Basic Template"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"class Stack {\n    constructor() {\n        this.items = [];\n    }\n\n    push(element) {\n        this.items.push(element);\n    }\n\n    pop() {\n        if (this.isEmpty()) return null;\n        return this.items.pop();\n    }\n\n    peek() {\n        if (this.isEmpty()) return null;\n        return this.items[this.items.length - 1];\n    }\n\n    isEmpty() {\n        return this.items.length === 0;\n    }\n\n    size() {\n        return this.items.length;\n    }\n}\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"basic-stack-operations",children:"Basic Stack Operations"}),"\n",(0,s.jsx)(e.h3,{id:"1-stack-using-array",children:"1. Stack Using Array"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:'class ArrayStack {\n    constructor(maxSize = 1000) {\n        this.items = new Array(maxSize);\n        this.top = -1;\n        this.maxSize = maxSize;\n    }\n\n    push(element) {\n        if (this.isFull()) {\n            throw new Error("Stack Overflow");\n        }\n        this.items[++this.top] = element;\n    }\n\n    pop() {\n        if (this.isEmpty()) {\n            throw new Error("Stack Underflow");\n        }\n        return this.items[this.top--];\n    }\n\n    peek() {\n        if (this.isEmpty()) return null;\n        return this.items[this.top];\n    }\n\n    isEmpty() {\n        return this.top === -1;\n    }\n\n    isFull() {\n        return this.top === this.maxSize - 1;\n    }\n\n    size() {\n        return this.top + 1;\n    }\n}\n'})}),"\n",(0,s.jsx)(e.h3,{id:"2-stack-using-linked-list",children:"2. Stack Using Linked List"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"class Node {\n    constructor(data) {\n        this.data = data;\n        this.next = null;\n    }\n}\n\nclass LinkedListStack {\n    constructor() {\n        this.head = null;\n        this.stackSize = 0;\n    }\n\n    push(element) {\n        const newNode = new Node(element);\n        newNode.next = this.head;\n        this.head = newNode;\n        this.stackSize++;\n    }\n\n    pop() {\n        if (this.isEmpty()) return null;\n\n        const poppedData = this.head.data;\n        this.head = this.head.next;\n        this.stackSize--;\n        return poppedData;\n    }\n\n    peek() {\n        return this.isEmpty() ? null : this.head.data;\n    }\n\n    isEmpty() {\n        return this.head === null;\n    }\n\n    size() {\n        return this.stackSize;\n    }\n}\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"basic-stack-problems",children:"Basic Stack Problems"}),"\n",(0,s.jsx)(e.h3,{id:"1-reverse-a-string",children:"1. Reverse a String"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:'function reverseString(str) {\n    const stack = new Stack();\n\n    // Push all characters\n    for (const char of str) {\n        stack.push(char);\n    }\n\n    // Pop all characters\n    let reversed = "";\n    while (!stack.isEmpty()) {\n        reversed += stack.pop();\n    }\n\n    return reversed;\n}\n'})}),"\n",(0,s.jsx)(e.h3,{id:"2-check-palindrome",children:"2. Check Palindrome"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function isPalindrome(str) {\n    const stack = new Stack();\n    const n = str.length;\n\n    // Push first half\n    for (let i = 0; i < Math.floor(n / 2); i++) {\n        stack.push(str[i]);\n    }\n\n    // Compare second half with stack\n    let start = n % 2 === 0 ? Math.floor(n / 2) : Math.floor(n / 2) + 1;\n\n    for (let i = start; i < n; i++) {\n        if (stack.pop() !== str[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"3-next-greater-element",children:"3. Next Greater Element"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function nextGreaterElement(arr) {\n    const result = new Array(arr.length).fill(-1);\n    const stack = new Stack();\n\n    for (let i = 0; i < arr.length; i++) {\n        while (!stack.isEmpty() && arr[stack.peek()] < arr[i]) {\n            const index = stack.pop();\n            result[index] = arr[i];\n        }\n        stack.push(i);\n    }\n\n    return result;\n}\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"expression-evaluation",children:"Expression Evaluation"}),"\n",(0,s.jsx)(e.h3,{id:"1-infix-to-postfix-conversion",children:"1. Infix to Postfix Conversion"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function infixToPostfix(infix) {\n    const stack = new Stack();\n    let postfix = \"\";\n\n    const precedence = {\n        '+': 1, '-': 1,\n        '*': 2, '/': 2,\n        '^': 3\n    };\n\n    const isOperator = (char) => precedence.hasOwnProperty(char);\n    const isOperand = (char) => /[a-zA-Z0-9]/.test(char);\n\n    for (const char of infix) {\n        if (isOperand(char)) {\n            postfix += char;\n        } else if (char === '(') {\n            stack.push(char);\n        } else if (char === ')') {\n            while (!stack.isEmpty() && stack.peek() !== '(') {\n                postfix += stack.pop();\n            }\n            stack.pop(); // Remove '('\n        } else if (isOperator(char)) {\n            while (!stack.isEmpty() &&\n                   stack.peek() !== '(' &&\n                   precedence[stack.peek()] >= precedence[char]) {\n                postfix += stack.pop();\n            }\n            stack.push(char);\n        }\n    }\n\n    while (!stack.isEmpty()) {\n        postfix += stack.pop();\n    }\n\n    return postfix;\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"2-postfix-evaluation",children:"2. Postfix Evaluation"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function evaluatePostfix(postfix) {\n    const stack = new Stack();\n\n    for (const char of postfix) {\n        if (/\\d/.test(char)) {\n            stack.push(parseInt(char));\n        } else {\n            const operand2 = stack.pop();\n            const operand1 = stack.pop();\n\n            let result;\n            switch (char) {\n                case '+': result = operand1 + operand2; break;\n                case '-': result = operand1 - operand2; break;\n                case '*': result = operand1 * operand2; break;\n                case '/': result = operand1 / operand2; break;\n                case '^': result = Math.pow(operand1, operand2); break;\n            }\n\n            stack.push(result);\n        }\n    }\n\n    return stack.pop();\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"3-basic-calculator",children:"3. Basic Calculator"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function calculate(s) {\n    const stack = new Stack();\n    let num = 0;\n    let sign = 1; // 1 for positive, -1 for negative\n    let result = 0;\n\n    for (let i = 0; i < s.length; i++) {\n        const char = s[i];\n\n        if (/\\d/.test(char)) {\n            num = num * 10 + parseInt(char);\n        } else if (char === '+' || char === '-') {\n            result += sign * num;\n            num = 0;\n            sign = char === '+' ? 1 : -1;\n        } else if (char === '(') {\n            // Save current result and sign\n            stack.push(result);\n            stack.push(sign);\n            result = 0;\n            sign = 1;\n        } else if (char === ')') {\n            result += sign * num;\n            num = 0;\n\n            // Restore previous sign and result\n            result *= stack.pop(); // Previous sign\n            result += stack.pop(); // Previous result\n        }\n    }\n\n    return result + sign * num;\n}\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"parentheses-problems",children:"Parentheses Problems"}),"\n",(0,s.jsx)(e.h3,{id:"1-valid-parentheses",children:"1. Valid Parentheses"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function isValid(s) {\n    const stack = new Stack();\n    const mapping = {\n        ')': '(',\n        '}': '{',\n        ']': '['\n    };\n\n    for (const char of s) {\n        if (char === '(' || char === '{' || char === '[') {\n            stack.push(char);\n        } else if (char === ')' || char === '}' || char === ']') {\n            if (stack.isEmpty() || stack.pop() !== mapping[char]) {\n                return false;\n            }\n        }\n    }\n\n    return stack.isEmpty();\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"2-generate-parentheses",children:"2. Generate Parentheses"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function generateParenthesis(n) {\n    const result = [];\n\n    function backtrack(current, open, close) {\n        if (current.length === 2 * n) {\n            result.push(current);\n            return;\n        }\n\n        if (open < n) {\n            backtrack(current + '(', open + 1, close);\n        }\n\n        if (close < open) {\n            backtrack(current + ')', open, close + 1);\n        }\n    }\n\n    backtrack('', 0, 0);\n    return result;\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"3-longest-valid-parentheses",children:"3. Longest Valid Parentheses"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function longestValidParentheses(s) {\n    const stack = new Stack();\n    stack.push(-1); // Base for calculating length\n    let maxLength = 0;\n\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] === '(') {\n            stack.push(i);\n        } else {\n            stack.pop();\n\n            if (stack.isEmpty()) {\n                stack.push(i);\n            } else {\n                maxLength = Math.max(maxLength, i - stack.peek());\n            }\n        }\n    }\n\n    return maxLength;\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"4-remove-invalid-parentheses",children:"4. Remove Invalid Parentheses"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function removeInvalidParentheses(s) {\n    // Count invalid parentheses\n    let leftRemove = 0, rightRemove = 0;\n\n    for (const char of s) {\n        if (char === '(') {\n            leftRemove++;\n        } else if (char === ')') {\n            if (leftRemove > 0) {\n                leftRemove--;\n            } else {\n                rightRemove++;\n            }\n        }\n    }\n\n    const result = new Set();\n\n    function dfs(index, leftCount, rightCount, leftRem, rightRem, current) {\n        if (index === s.length) {\n            if (leftRem === 0 && rightRem === 0) {\n                result.add(current);\n            }\n            return;\n        }\n\n        const char = s[index];\n\n        // Option 1: Remove current character\n        if ((char === '(' && leftRem > 0) || (char === ')' && rightRem > 0)) {\n            dfs(index + 1, leftCount, rightCount,\n                leftRem - (char === '(' ? 1 : 0),\n                rightRem - (char === ')' ? 1 : 0),\n                current);\n        }\n\n        // Option 2: Keep current character\n        if (char !== '(' && char !== ')') {\n            dfs(index + 1, leftCount, rightCount, leftRem, rightRem, current + char);\n        } else if (char === '(') {\n            dfs(index + 1, leftCount + 1, rightCount, leftRem, rightRem, current + char);\n        } else if (rightCount < leftCount) {\n            dfs(index + 1, leftCount, rightCount + 1, leftRem, rightRem, current + char);\n        }\n    }\n\n    dfs(0, 0, 0, leftRemove, rightRemove, '');\n    return Array.from(result);\n}\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"monotonic-stack",children:"Monotonic Stack"}),"\n",(0,s.jsxs)(e.p,{children:["A ",(0,s.jsx)(e.strong,{children:"monotonic stack"})," maintains elements in either increasing or decreasing order. It's extremely useful for finding next/previous greater/smaller elements."]}),"\n",(0,s.jsx)(e.h3,{id:"1-next-greater-element-pattern",children:"1. Next Greater Element Pattern"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"// Template for Next Greater Element problems\nfunction nextGreaterElements(arr) {\n    const result = new Array(arr.length).fill(-1);\n    const stack = []; // Monotonic decreasing stack\n\n    for (let i = 0; i < arr.length; i++) {\n        // Pop elements smaller than current\n        while (stack.length > 0 && arr[stack[stack.length - 1]] < arr[i]) {\n            const index = stack.pop();\n            result[index] = arr[i];\n        }\n        stack.push(i);\n    }\n\n    return result;\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"2-next-greater-element-ii-circular-array",children:"2. Next Greater Element II (Circular Array)"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function nextGreaterElementsII(nums) {\n    const n = nums.length;\n    const result = new Array(n).fill(-1);\n    const stack = [];\n\n    // Process array twice to handle circular nature\n    for (let i = 0; i < 2 * n; i++) {\n        const index = i % n;\n\n        while (stack.length > 0 && nums[stack[stack.length - 1]] < nums[index]) {\n            const idx = stack.pop();\n            result[idx] = nums[index];\n        }\n\n        if (i < n) {\n            stack.push(index);\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"3-daily-temperatures",children:"3. Daily Temperatures"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function dailyTemperatures(temperatures) {\n    const result = new Array(temperatures.length).fill(0);\n    const stack = []; // Store indices\n\n    for (let i = 0; i < temperatures.length; i++) {\n        while (stack.length > 0 && temperatures[stack[stack.length - 1]] < temperatures[i]) {\n            const index = stack.pop();\n            result[index] = i - index;\n        }\n        stack.push(i);\n    }\n\n    return result;\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"4-largest-rectangle-in-histogram",children:"4. Largest Rectangle in Histogram"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function largestRectangleArea(heights) {\n    const stack = []; // Monotonic increasing stack\n    let maxArea = 0;\n    let index = 0;\n\n    while (index < heights.length) {\n        if (stack.length === 0 || heights[index] >= heights[stack[stack.length - 1]]) {\n            stack.push(index++);\n        } else {\n            const top = stack.pop();\n            const width = stack.length === 0 ? index : index - stack[stack.length - 1] - 1;\n            const area = heights[top] * width;\n            maxArea = Math.max(maxArea, area);\n        }\n    }\n\n    while (stack.length > 0) {\n        const top = stack.pop();\n        const width = stack.length === 0 ? index : index - stack[stack.length - 1] - 1;\n        const area = heights[top] * width;\n        maxArea = Math.max(maxArea, area);\n    }\n\n    return maxArea;\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"5-maximal-rectangle",children:"5. Maximal Rectangle"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function maximalRectangle(matrix) {\n    if (!matrix || matrix.length === 0) return 0;\n\n    const rows = matrix.length;\n    const cols = matrix[0].length;\n    const heights = new Array(cols).fill(0);\n    let maxArea = 0;\n\n    for (let i = 0; i < rows; i++) {\n        // Update heights array\n        for (let j = 0; j < cols; j++) {\n            heights[j] = matrix[i][j] === '1' ? heights[j] + 1 : 0;\n        }\n\n        // Calculate max rectangle for current row\n        maxArea = Math.max(maxArea, largestRectangleArea(heights));\n    }\n\n    return maxArea;\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"6-trapping-rain-water",children:"6. Trapping Rain Water"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function trap(height) {\n    const stack = [];\n    let water = 0;\n\n    for (let i = 0; i < height.length; i++) {\n        while (stack.length > 0 && height[i] > height[stack[stack.length - 1]]) {\n            const bottom = stack.pop();\n\n            if (stack.length === 0) break;\n\n            const distance = i - stack[stack.length - 1] - 1;\n            const boundedHeight = Math.min(height[i], height[stack[stack.length - 1]]) - height[bottom];\n            water += distance * boundedHeight;\n        }\n        stack.push(i);\n    }\n\n    return water;\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"7-sum-of-subarray-minimums",children:"7. Sum of Subarray Minimums"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function sumSubarrayMins(arr) {\n    const MOD = 1000000007;\n    const n = arr.length;\n\n    // Find previous less element\n    const prevLess = new Array(n).fill(-1);\n    let stack = [];\n\n    for (let i = 0; i < n; i++) {\n        while (stack.length > 0 && arr[stack[stack.length - 1]] >= arr[i]) {\n            stack.pop();\n        }\n        if (stack.length > 0) {\n            prevLess[i] = stack[stack.length - 1];\n        }\n        stack.push(i);\n    }\n\n    // Find next less element\n    const nextLess = new Array(n).fill(n);\n    stack = [];\n\n    for (let i = n - 1; i >= 0; i--) {\n        while (stack.length > 0 && arr[stack[stack.length - 1]] > arr[i]) {\n            stack.pop();\n        }\n        if (stack.length > 0) {\n            nextLess[i] = stack[stack.length - 1];\n        }\n        stack.push(i);\n    }\n\n    // Calculate sum\n    let result = 0;\n    for (let i = 0; i < n; i++) {\n        const left = i - prevLess[i];\n        const right = nextLess[i] - i;\n        result = (result + (arr[i] * left * right) % MOD) % MOD;\n    }\n\n    return result;\n}\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"stack-in-recursion",children:"Stack in Recursion"}),"\n",(0,s.jsx)(e.h3,{id:"1-binary-tree-traversal-iterative",children:"1. Binary Tree Traversal (Iterative)"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"// Preorder Traversal\nfunction preorderTraversal(root) {\n    if (!root) return [];\n\n    const result = [];\n    const stack = [root];\n\n    while (stack.length > 0) {\n        const node = stack.pop();\n        result.push(node.val);\n\n        if (node.right) stack.push(node.right);\n        if (node.left) stack.push(node.left);\n    }\n\n    return result;\n}\n\n// Inorder Traversal\nfunction inorderTraversal(root) {\n    const result = [];\n    const stack = [];\n    let current = root;\n\n    while (current || stack.length > 0) {\n        while (current) {\n            stack.push(current);\n            current = current.left;\n        }\n\n        current = stack.pop();\n        result.push(current.val);\n        current = current.right;\n    }\n\n    return result;\n}\n\n// Postorder Traversal\nfunction postorderTraversal(root) {\n    if (!root) return [];\n\n    const result = [];\n    const stack = [];\n    let lastVisited = null;\n    let current = root;\n\n    while (current || stack.length > 0) {\n        if (current) {\n            stack.push(current);\n            current = current.left;\n        } else {\n            const peekNode = stack[stack.length - 1];\n            if (peekNode.right && lastVisited !== peekNode.right) {\n                current = peekNode.right;\n            } else {\n                result.push(peekNode.val);\n                lastVisited = stack.pop();\n            }\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"2-flatten-binary-tree-to-linked-list",children:"2. Flatten Binary Tree to Linked List"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function flatten(root) {\n    if (!root) return;\n\n    const stack = [root];\n\n    while (stack.length > 0) {\n        const node = stack.pop();\n\n        if (node.right) stack.push(node.right);\n        if (node.left) stack.push(node.left);\n\n        if (stack.length > 0) {\n            node.right = stack[stack.length - 1];\n        }\n        node.left = null;\n    }\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"3-path-sum-ii",children:"3. Path Sum II"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function pathSum(root, targetSum) {\n    if (!root) return [];\n\n    const result = [];\n    const stack = [[root, [root.val], root.val]];\n\n    while (stack.length > 0) {\n        const [node, path, sum] = stack.pop();\n\n        if (!node.left && !node.right && sum === targetSum) {\n            result.push([...path]);\n        }\n\n        if (node.right) {\n            stack.push([node.right, [...path, node.right.val], sum + node.right.val]);\n        }\n\n        if (node.left) {\n            stack.push([node.left, [...path, node.left.val], sum + node.left.val]);\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"two-stacks-problems",children:"Two Stacks Problems"}),"\n",(0,s.jsx)(e.h3,{id:"1-implement-queue-using-stacks",children:"1. Implement Queue using Stacks"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"class MyQueue {\n    constructor() {\n        this.stack1 = []; // For enqueue\n        this.stack2 = []; // For dequeue\n    }\n\n    push(x) {\n        this.stack1.push(x);\n    }\n\n    pop() {\n        this.moveStack1ToStack2();\n        return this.stack2.pop();\n    }\n\n    peek() {\n        this.moveStack1ToStack2();\n        return this.stack2[this.stack2.length - 1];\n    }\n\n    empty() {\n        return this.stack1.length === 0 && this.stack2.length === 0;\n    }\n\n    moveStack1ToStack2() {\n        if (this.stack2.length === 0) {\n            while (this.stack1.length > 0) {\n                this.stack2.push(this.stack1.pop());\n            }\n        }\n    }\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"2-sort-stack",children:"2. Sort Stack"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function sortStack(stack) {\n    const tempStack = [];\n\n    while (stack.length > 0) {\n        const temp = stack.pop();\n\n        while (tempStack.length > 0 && tempStack[tempStack.length - 1] > temp) {\n            stack.push(tempStack.pop());\n        }\n\n        tempStack.push(temp);\n    }\n\n    // Move back to original stack\n    while (tempStack.length > 0) {\n        stack.push(tempStack.pop());\n    }\n\n    return stack;\n}\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"stack-with-additional-operations",children:"Stack with Additional Operations"}),"\n",(0,s.jsx)(e.h3,{id:"1-min-stack",children:"1. Min Stack"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"class MinStack {\n    constructor() {\n        this.stack = [];\n        this.minStack = [];\n    }\n\n    push(val) {\n        this.stack.push(val);\n\n        if (this.minStack.length === 0 || val <= this.getMin()) {\n            this.minStack.push(val);\n        }\n    }\n\n    pop() {\n        const popped = this.stack.pop();\n\n        if (popped === this.getMin()) {\n            this.minStack.pop();\n        }\n\n        return popped;\n    }\n\n    top() {\n        return this.stack[this.stack.length - 1];\n    }\n\n    getMin() {\n        return this.minStack[this.minStack.length - 1];\n    }\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"2-max-stack",children:"2. Max Stack"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"class MaxStack {\n    constructor() {\n        this.stack = [];\n        this.maxStack = [];\n        this.id = 0;\n    }\n\n    push(x) {\n        const currentId = this.id++;\n        this.stack.push([x, currentId]);\n\n        if (this.maxStack.length === 0 || x >= this.maxStack[this.maxStack.length - 1][0]) {\n            this.maxStack.push([x, currentId]);\n        }\n    }\n\n    pop() {\n        const [val, id] = this.stack.pop();\n\n        if (this.maxStack.length > 0 && this.maxStack[this.maxStack.length - 1][1] === id) {\n            this.maxStack.pop();\n        }\n\n        return val;\n    }\n\n    top() {\n        return this.stack[this.stack.length - 1][0];\n    }\n\n    peekMax() {\n        return this.maxStack[this.maxStack.length - 1][0];\n    }\n\n    popMax() {\n        const [maxVal, maxId] = this.maxStack.pop();\n        const buffer = [];\n\n        // Remove elements until we find the max\n        while (this.stack[this.stack.length - 1][1] !== maxId) {\n            buffer.push(this.stack.pop());\n        }\n\n        this.stack.pop(); // Remove the max element\n\n        // Push back other elements\n        while (buffer.length > 0) {\n            const [val] = buffer.pop();\n            this.push(val);\n        }\n\n        return maxVal;\n    }\n}\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"advanced-stack-patterns",children:"Advanced Stack Patterns"}),"\n",(0,s.jsx)(e.h3,{id:"1-asteroid-collision",children:"1. Asteroid Collision"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function asteroidCollision(asteroids) {\n    const stack = [];\n\n    for (const asteroid of asteroids) {\n        let exploded = false;\n\n        while (stack.length > 0 && asteroid < 0 && stack[stack.length - 1] > 0) {\n            if (stack[stack.length - 1] < -asteroid) {\n                stack.pop();\n                continue;\n            } else if (stack[stack.length - 1] === -asteroid) {\n                stack.pop();\n            }\n            exploded = true;\n            break;\n        }\n\n        if (!exploded) {\n            stack.push(asteroid);\n        }\n    }\n\n    return stack;\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"2-decode-string",children:"2. Decode String"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function decodeString(s) {\n    const stack = [];\n    let currentString = '';\n    let currentNum = 0;\n\n    for (const char of s) {\n        if (/\\d/.test(char)) {\n            currentNum = currentNum * 10 + parseInt(char);\n        } else if (char === '[') {\n            stack.push([currentString, currentNum]);\n            currentString = '';\n            currentNum = 0;\n        } else if (char === ']') {\n            const [prevString, num] = stack.pop();\n            currentString = prevString + currentString.repeat(num);\n        } else {\n            currentString += char;\n        }\n    }\n\n    return currentString;\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"3-remove-k-digits",children:"3. Remove K Digits"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function removeKdigits(num, k) {\n    const stack = [];\n    let toRemove = k;\n\n    for (const digit of num) {\n        while (stack.length > 0 && stack[stack.length - 1] > digit && toRemove > 0) {\n            stack.pop();\n            toRemove--;\n        }\n        stack.push(digit);\n    }\n\n    // Remove remaining digits from the end\n    while (toRemove > 0) {\n        stack.pop();\n        toRemove--;\n    }\n\n    // Build result and handle leading zeros\n    const result = stack.join('').replace(/^0+/, '');\n    return result === '' ? '0' : result;\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"4-valid-stack-sequences",children:"4. Valid Stack Sequences"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function validateStackSequences(pushed, popped) {\n    const stack = [];\n    let popIndex = 0;\n\n    for (const num of pushed) {\n        stack.push(num);\n\n        while (stack.length > 0 && stack[stack.length - 1] === popped[popIndex]) {\n            stack.pop();\n            popIndex++;\n        }\n    }\n\n    return stack.length === 0;\n}\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"stack-in-graph-algorithms",children:"Stack in Graph Algorithms"}),"\n",(0,s.jsx)(e.h3,{id:"1-depth-first-search-dfs",children:"1. Depth-First Search (DFS)"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function dfsIterative(graph, start) {\n    const visited = new Set();\n    const stack = [start];\n    const result = [];\n\n    while (stack.length > 0) {\n        const vertex = stack.pop();\n\n        if (!visited.has(vertex)) {\n            visited.add(vertex);\n            result.push(vertex);\n\n            // Add neighbors to stack\n            for (const neighbor of graph[vertex]) {\n                if (!visited.has(neighbor)) {\n                    stack.push(neighbor);\n                }\n            }\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"2-topological-sort",children:"2. Topological Sort"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function topologicalSort(graph) {\n    const visited = new Set();\n    const stack = [];\n\n    function dfs(vertex) {\n        visited.add(vertex);\n\n        for (const neighbor of graph[vertex] || []) {\n            if (!visited.has(neighbor)) {\n                dfs(neighbor);\n            }\n        }\n\n        stack.push(vertex);\n    }\n\n    // Visit all vertices\n    for (const vertex in graph) {\n        if (!visited.has(vertex)) {\n            dfs(vertex);\n        }\n    }\n\n    return stack.reverse();\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"3-find-strongly-connected-components",children:"3. Find Strongly Connected Components"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function stronglyConnectedComponents(graph) {\n    const visited = new Set();\n    const finishOrder = [];\n\n    // First DFS to get finish order\n    function dfs1(vertex) {\n        visited.add(vertex);\n\n        for (const neighbor of graph[vertex] || []) {\n            if (!visited.has(neighbor)) {\n                dfs1(neighbor);\n            }\n        }\n        finishOrder.push(vertex);\n    }\n\n    // Get transpose graph\n    function getTranspose(graph) {\n        const transpose = {};\n        for (const vertex in graph) {\n            for (const neighbor of graph[vertex] || []) {\n                if (!transpose[neighbor]) transpose[neighbor] = [];\n                transpose[neighbor].push(vertex);\n            }\n        }\n        return transpose;\n    }\n\n    // First DFS on original graph\n    for (const vertex in graph) {\n        if (!visited.has(vertex)) {\n            dfs1(vertex);\n        }\n    }\n\n    // Second DFS on transpose graph in reverse finish order\n    const transpose = getTranspose(graph);\n    visited.clear();\n    const components = [];\n\n    function dfs2(vertex, component) {\n        visited.add(vertex);\n        component.push(vertex);\n\n        for (const neighbor of transpose[vertex] || []) {\n            if (!visited.has(neighbor)) {\n                dfs2(neighbor, component);\n            }\n        }\n    }\n\n    while (finishOrder.length > 0) {\n        const vertex = finishOrder.pop();\n        if (!visited.has(vertex)) {\n            const component = [];\n            dfs2(vertex, component);\n            components.push(component);\n        }\n    }\n\n    return components;\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"4-detect-cycle-in-directed-graph",children:"4. Detect Cycle in Directed Graph"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function hasCycle(graph) {\n    const WHITE = 0, GRAY = 1, BLACK = 2;\n    const colors = {};\n\n    // Initialize all vertices as WHITE\n    for (const vertex in graph) {\n        colors[vertex] = WHITE;\n    }\n\n    function dfs(vertex) {\n        colors[vertex] = GRAY;\n\n        for (const neighbor of graph[vertex] || []) {\n            if (colors[neighbor] === GRAY) {\n                return true; // Back edge found - cycle detected\n            }\n\n            if (colors[neighbor] === WHITE && dfs(neighbor)) {\n                return true;\n            }\n        }\n\n        colors[vertex] = BLACK;\n        return false;\n    }\n\n    for (const vertex in graph) {\n        if (colors[vertex] === WHITE && dfs(vertex)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"memory-management",children:"Memory Management"}),"\n",(0,s.jsx)(e.h3,{id:"1-stack-overflow-prevention",children:"1. Stack Overflow Prevention"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:'class SafeStack {\n    constructor(maxSize = 1000) {\n        this.items = [];\n        this.maxSize = maxSize;\n    }\n\n    push(element) {\n        if (this.items.length >= this.maxSize) {\n            throw new Error(`Stack overflow: Cannot exceed ${this.maxSize} elements`);\n        }\n        this.items.push(element);\n    }\n\n    pop() {\n        if (this.isEmpty()) {\n            throw new Error("Stack underflow: Cannot pop from empty stack");\n        }\n        return this.items.pop();\n    }\n\n    // Rest of the methods...\n    peek() { return this.items[this.items.length - 1]; }\n    isEmpty() { return this.items.length === 0; }\n    size() { return this.items.length; }\n    clear() { this.items = []; }\n}\n'})}),"\n",(0,s.jsx)(e.h3,{id:"2-memory-efficient-stack",children:"2. Memory-Efficient Stack"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"class MemoryEfficientStack {\n    constructor() {\n        this.head = null;\n        this.stackSize = 0;\n    }\n\n    push(data) {\n        const newNode = { data, next: this.head };\n        this.head = newNode;\n        this.stackSize++;\n    }\n\n    pop() {\n        if (!this.head) return null;\n\n        const data = this.head.data;\n        this.head = this.head.next;\n        this.stackSize--;\n        return data;\n    }\n\n    peek() {\n        return this.head ? this.head.data : null;\n    }\n\n    isEmpty() {\n        return this.head === null;\n    }\n\n    size() {\n        return this.stackSize;\n    }\n}\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"common-optimization-tricks",children:"Common Optimization Tricks"}),"\n",(0,s.jsx)(e.h3,{id:"1-stack-with-o1-minmax-operations",children:"1. Stack with O(1) Min/Max Operations"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"class OptimizedMinMaxStack {\n    constructor() {\n        this.stack = [];\n    }\n\n    push(val) {\n        if (this.stack.length === 0) {\n            this.stack.push({ val, min: val, max: val });\n        } else {\n            const top = this.stack[this.stack.length - 1];\n            this.stack.push({\n                val,\n                min: Math.min(val, top.min),\n                max: Math.max(val, top.max)\n            });\n        }\n    }\n\n    pop() {\n        return this.stack.pop();\n    }\n\n    top() {\n        return this.stack[this.stack.length - 1].val;\n    }\n\n    getMin() {\n        return this.stack[this.stack.length - 1].min;\n    }\n\n    getMax() {\n        return this.stack[this.stack.length - 1].max;\n    }\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"2-multiple-stacks-in-single-array",children:"2. Multiple Stacks in Single Array"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"class MultiStack {\n    constructor(stackCount, capacity) {\n        this.stackCount = stackCount;\n        this.capacity = capacity;\n        this.array = new Array(stackCount * capacity);\n        this.tops = new Array(stackCount).fill(-1);\n    }\n\n    push(stackNum, value) {\n        if (this.isFull(stackNum)) {\n            throw new Error(`Stack ${stackNum} is full`);\n        }\n\n        this.tops[stackNum]++;\n        const index = stackNum * this.capacity + this.tops[stackNum];\n        this.array[index] = value;\n    }\n\n    pop(stackNum) {\n        if (this.isEmpty(stackNum)) {\n            throw new Error(`Stack ${stackNum} is empty`);\n        }\n\n        const index = stackNum * this.capacity + this.tops[stackNum];\n        const value = this.array[index];\n        this.array[index] = null;\n        this.tops[stackNum]--;\n\n        return value;\n    }\n\n    peek(stackNum) {\n        if (this.isEmpty(stackNum)) return null;\n\n        const index = stackNum * this.capacity + this.tops[stackNum];\n        return this.array[index];\n    }\n\n    isEmpty(stackNum) {\n        return this.tops[stackNum] === -1;\n    }\n\n    isFull(stackNum) {\n        return this.tops[stackNum] === this.capacity - 1;\n    }\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"3-stack-with-increment-operation",children:"3. Stack with Increment Operation"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"class CustomStack {\n    constructor(maxSize) {\n        this.maxSize = maxSize;\n        this.stack = [];\n        this.increments = []; // Lazy propagation array\n    }\n\n    push(x) {\n        if (this.stack.length < this.maxSize) {\n            this.stack.push(x);\n            this.increments.push(0);\n        }\n    }\n\n    pop() {\n        if (this.stack.length === 0) return -1;\n\n        const index = this.stack.length - 1;\n\n        // Apply increment to previous element (lazy propagation)\n        if (index > 0) {\n            this.increments[index - 1] += this.increments[index];\n        }\n\n        const result = this.stack.pop() + this.increments.pop();\n        return result;\n    }\n\n    increment(k, val) {\n        const limit = Math.min(k, this.stack.length);\n        if (limit > 0) {\n            this.increments[limit - 1] += val;\n        }\n    }\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"4-stack-with-getmiddle-operation",children:"4. Stack with getMiddle Operation"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"class StackWithMiddle {\n    constructor() {\n        this.count = 0;\n        this.head = null;\n        this.mid = null;\n    }\n\n    push(data) {\n        const newNode = { data, next: null, prev: null };\n\n        if (this.count === 0) {\n            this.head = newNode;\n            this.mid = newNode;\n        } else {\n            newNode.next = this.head;\n            this.head.prev = newNode;\n            this.head = newNode;\n\n            if (this.count % 2 === 1) {\n                this.mid = this.mid.prev;\n            }\n        }\n\n        this.count++;\n    }\n\n    pop() {\n        if (this.count === 0) return null;\n\n        const data = this.head.data;\n        this.head = this.head.next;\n\n        if (this.head) {\n            this.head.prev = null;\n        }\n\n        this.count--;\n\n        if (this.count % 2 === 0 && this.count > 0) {\n            this.mid = this.mid.next;\n        }\n\n        return data;\n    }\n\n    findMiddle() {\n        return this.mid ? this.mid.data : null;\n    }\n\n    deleteMiddle() {\n        if (this.count === 0) return null;\n\n        const data = this.mid.data;\n\n        if (this.count === 1) {\n            this.head = null;\n            this.mid = null;\n        } else {\n            if (this.mid.prev) {\n                this.mid.prev.next = this.mid.next;\n            }\n            if (this.mid.next) {\n                this.mid.next.prev = this.mid.prev;\n            }\n\n            if (this.count % 2 === 1) {\n                this.mid = this.mid.next;\n            } else {\n                this.mid = this.mid.prev;\n            }\n        }\n\n        this.count--;\n        return data;\n    }\n}\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"problem-solving-patterns",children:"Problem-Solving Patterns"}),"\n",(0,s.jsx)(e.h3,{id:"1-when-to-use-stack",children:"1. When to Use Stack"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Stack is suitable for problems involving:"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"LIFO operations:"})," Last element processed first"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Matching/Pairing:"})," Parentheses, brackets, tags"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Undo operations:"})," Editor undo, browser back"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Expression evaluation:"})," Infix to postfix, calculator"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Recursion simulation:"})," Tree traversal, DFS"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Monotonic properties:"})," Next greater/smaller element"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"2-stack-problem-templates",children:"2. Stack Problem Templates"}),"\n",(0,s.jsx)(e.h4,{id:"template-1-basic-stack-operations",children:"Template 1: Basic Stack Operations"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function basicStackProblem(input) {\n    const stack = [];\n\n    for (const element of input) {\n        // Process element based on problem logic\n        if (conditionToPush(element)) {\n            stack.push(element);\n        }\n\n        while (stack.length > 0 && conditionToPop(stack[stack.length - 1], element)) {\n            const popped = stack.pop();\n            // Process popped element\n        }\n    }\n\n    // Process remaining elements in stack\n    while (stack.length > 0) {\n        processRemaining(stack.pop());\n    }\n\n    return result;\n}\n"})}),"\n",(0,s.jsx)(e.h4,{id:"template-2-monotonic-stack",children:"Template 2: Monotonic Stack"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function monotonicStackProblem(arr) {\n    const result = [];\n    const stack = []; // Stores indices or values\n\n    for (let i = 0; i < arr.length; i++) {\n        // Maintain monotonic property\n        while (stack.length > 0 &&\n               compareCondition(arr[stack[stack.length - 1]], arr[i])) {\n            const index = stack.pop();\n            // Process the relationship between index and i\n            result[index] = processRelation(index, i);\n        }\n\n        stack.push(i);\n    }\n\n    // Handle remaining elements\n    while (stack.length > 0) {\n        const index = stack.pop();\n        result[index] = defaultValue;\n    }\n\n    return result;\n}\n"})}),"\n",(0,s.jsx)(e.h4,{id:"template-3-expression-parsing",children:"Template 3: Expression Parsing"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function parseExpression(expression) {\n    const operators = [];\n    const operands = [];\n\n    for (const token of tokenize(expression)) {\n        if (isOperand(token)) {\n            operands.push(token);\n        } else if (isOperator(token)) {\n            while (operators.length > 0 &&\n                   precedence(operators[operators.length - 1]) >= precedence(token)) {\n                applyOperator(operands, operators.pop());\n            }\n            operators.push(token);\n        } else if (token === '(') {\n            operators.push(token);\n        } else if (token === ')') {\n            while (operators.length > 0 && operators[operators.length - 1] !== '(') {\n                applyOperator(operands, operators.pop());\n            }\n            operators.pop(); // Remove '('\n        }\n    }\n\n    while (operators.length > 0) {\n        applyOperator(operands, operators.pop());\n    }\n\n    return operands[0];\n}\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"testing-and-debugging",children:"Testing and Debugging"}),"\n",(0,s.jsx)(e.h3,{id:"1-stack-testing-framework",children:"1. Stack Testing Framework"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:'class StackTester {\n    static testStack(StackClass) {\n        const tests = [\n            {\n                name: "Basic Operations",\n                test: () => {\n                    const stack = new StackClass();\n                    stack.push(1);\n                    stack.push(2);\n                    stack.push(3);\n\n                    console.assert(stack.peek() === 3, "Peek should return 3");\n                    console.assert(stack.pop() === 3, "Pop should return 3");\n                    console.assert(stack.size() === 2, "Size should be 2");\n                    console.assert(!stack.isEmpty(), "Stack should not be empty");\n\n                    stack.pop();\n                    stack.pop();\n                    console.assert(stack.isEmpty(), "Stack should be empty");\n                }\n            },\n            {\n                name: "Edge Cases",\n                test: () => {\n                    const stack = new StackClass();\n                    console.assert(stack.isEmpty(), "New stack should be empty");\n                    console.assert(stack.peek() === null || stack.peek() === undefined,\n                                 "Peek on empty stack");\n                    console.assert(stack.pop() === null || stack.pop() === undefined,\n                                 "Pop on empty stack");\n                }\n            }\n        ];\n\n        tests.forEach(({ name, test }) => {\n            try {\n                test();\n                console.log(`\u2705 ${name} passed`);\n            } catch (error) {\n                console.log(`\u274c ${name} failed:`, error.message);\n            }\n        });\n    }\n}\n\n// Usage\nStackTester.testStack(Stack);\n'})}),"\n",(0,s.jsx)(e.h3,{id:"2-stack-visualization",children:"2. Stack Visualization"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:'class VisualStack extends Stack {\n    push(element) {\n        super.push(element);\n        this.visualize();\n    }\n\n    pop() {\n        const result = super.pop();\n        this.visualize();\n        return result;\n    }\n\n    visualize() {\n        console.log("Stack visualization:");\n        console.log("Top");\n        for (let i = this.items.length - 1; i >= 0; i--) {\n            console.log(`|  ${this.items[i]}  |`);\n        }\n        console.log("--------");\n        console.log("Bottom");\n        console.log(`Size: ${this.size()}\\n`);\n    }\n}\n'})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"performance-analysis",children:"Performance Analysis"}),"\n",(0,s.jsx)(e.h3,{id:"time-complexity-summary",children:"Time Complexity Summary"}),"\n",(0,s.jsxs)(e.table,{children:[(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"Operation"}),(0,s.jsx)(e.th,{children:"Array-based"}),(0,s.jsx)(e.th,{children:"Linked List-based"})]})}),(0,s.jsxs)(e.tbody,{children:[(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Push"}),(0,s.jsx)(e.td,{children:"O(1)*"}),(0,s.jsx)(e.td,{children:"O(1)"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Pop"}),(0,s.jsx)(e.td,{children:"O(1)"}),(0,s.jsx)(e.td,{children:"O(1)"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Peek"}),(0,s.jsx)(e.td,{children:"O(1)"}),(0,s.jsx)(e.td,{children:"O(1)"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Search"}),(0,s.jsx)(e.td,{children:"O(n)"}),(0,s.jsx)(e.td,{children:"O(n)"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Space"}),(0,s.jsx)(e.td,{children:"O(n)"}),(0,s.jsx)(e.td,{children:"O(n)"})]})]})]}),"\n",(0,s.jsx)(e.p,{children:"*Amortized O(1) for dynamic arrays"}),"\n",(0,s.jsx)(e.h3,{id:"space-complexity-considerations",children:"Space Complexity Considerations"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:'// Space-efficient stack for specific use cases\nclass CompactStack {\n    constructor() {\n        this.data = 0;\n        this.count = 0;\n    }\n\n    // Only works for small integers\n    push(val) {\n        if (val < 0 || val > 9) throw new Error("Value out of range");\n        this.data = this.data * 10 + val;\n        this.count++;\n    }\n\n    pop() {\n        if (this.count === 0) return null;\n        const result = this.data % 10;\n        this.data = Math.floor(this.data / 10);\n        this.count--;\n        return result;\n    }\n\n    peek() {\n        return this.count === 0 ? null : this.data % 10;\n    }\n\n    isEmpty() {\n        return this.count === 0;\n    }\n}\n'})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"real-world-applications",children:"Real-World Applications"}),"\n",(0,s.jsx)(e.h3,{id:"1-browser-history",children:"1. Browser History"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"class BrowserHistory {\n    constructor(homepage) {\n        this.history = [homepage];\n        this.currentIndex = 0;\n    }\n\n    visit(url) {\n        // Remove forward history\n        this.history = this.history.slice(0, this.currentIndex + 1);\n        this.history.push(url);\n        this.currentIndex++;\n    }\n\n    back(steps) {\n        this.currentIndex = Math.max(0, this.currentIndex - steps);\n        return this.history[this.currentIndex];\n    }\n\n    forward(steps) {\n        this.currentIndex = Math.min(this.history.length - 1, this.currentIndex + steps);\n        return this.history[this.currentIndex];\n    }\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"2-undoredo-system",children:"2. Undo/Redo System"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"class UndoRedoSystem {\n    constructor() {\n        this.undoStack = [];\n        this.redoStack = [];\n    }\n\n    executeCommand(command) {\n        command.execute();\n        this.undoStack.push(command);\n        this.redoStack = []; // Clear redo stack\n    }\n\n    undo() {\n        if (this.undoStack.length === 0) return false;\n\n        const command = this.undoStack.pop();\n        command.undo();\n        this.redoStack.push(command);\n        return true;\n    }\n\n    redo() {\n        if (this.redoStack.length === 0) return false;\n\n        const command = this.redoStack.pop();\n        command.execute();\n        this.undoStack.push(command);\n        return true;\n    }\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"3-function-call-stack-simulator",children:"3. Function Call Stack Simulator"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:'class CallStack {\n    constructor() {\n        this.stack = [];\n        this.maxSize = 1000;\n    }\n\n    call(functionName, parameters = {}) {\n        if (this.stack.length >= this.maxSize) {\n            throw new Error("Stack overflow: Maximum call stack size exceeded");\n        }\n\n        const frame = {\n            function: functionName,\n            parameters,\n            timestamp: Date.now(),\n            locals: {}\n        };\n\n        this.stack.push(frame);\n        console.log(`Calling: ${functionName}(${JSON.stringify(parameters)})`);\n    }\n\n    return(value) {\n        if (this.stack.length === 0) {\n            throw new Error("No function to return from");\n        }\n\n        const frame = this.stack.pop();\n        console.log(`Returning from: ${frame.function} with value: ${value}`);\n        return value;\n    }\n\n    getCurrentFrame() {\n        return this.stack.length > 0 ? this.stack[this.stack.length - 1] : null;\n    }\n\n    getStackTrace() {\n        return this.stack.map(frame => frame.function).reverse();\n    }\n}\n'})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsx)(e.p,{children:"Stacks are fundamental data structures with wide applications in computer science. Key takeaways:"}),"\n",(0,s.jsx)(e.h3,{id:"essential-patterns",children:(0,s.jsx)(e.strong,{children:"Essential Patterns:"})}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Basic Stack Operations"})," - LIFO principle, push/pop operations"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Monotonic Stack"})," - Maintaining order for next/previous greater/smaller problems"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Expression Evaluation"})," - Parsing and evaluating mathematical expressions"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Recursive Simulation"})," - Converting recursive algorithms to iterative using stacks"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"when-to-use-stacks",children:(0,s.jsx)(e.strong,{children:"When to Use Stacks:"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Matching problems"})," (parentheses, brackets)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Expression parsing"})," and evaluation"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Undo/Redo"})," functionality"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Function call"})," management"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Tree/Graph traversal"})," (DFS)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Monotonic relationships"})," in arrays"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"optimization-techniques",children:(0,s.jsx)(e.strong,{children:"Optimization Techniques:"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Space optimization"})," for specific constraints"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Lazy propagation"})," for bulk operations"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Multiple stacks"})," in single array"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Auxiliary stacks"})," for additional operations"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"best-practices",children:(0,s.jsx)(e.strong,{children:"Best Practices:"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["Always check for ",(0,s.jsx)(e.strong,{children:"empty stack"})," before pop/peek"]}),"\n",(0,s.jsxs)(e.li,{children:["Handle ",(0,s.jsx)(e.strong,{children:"stack overflow"})," in bounded implementations"]}),"\n",(0,s.jsxs)(e.li,{children:["Use ",(0,s.jsx)(e.strong,{children:"appropriate data structure"})," (array vs linked list)"]}),"\n",(0,s.jsxs)(e.li,{children:["Consider ",(0,s.jsx)(e.strong,{children:"space-time tradeoffs"})," for your use case"]}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"\ud83d\udca1 Pro Tip:"}),' When solving stack problems, think about what information needs to be "remembered" and accessed in LIFO order. Often, the stack stores indices rather than values to maintain relationships between elements.']}),"\n"]})]})}function d(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(h,{...n})}):h(n)}}}]);