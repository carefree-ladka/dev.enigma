"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[9259],{8645:(t,n,e)=>{e.r(n),e.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var s=e(4848),i=e(8453);const r={},a="Suffix Automaton",o={id:"DSA/SuffixAutomata",title:"Suffix Automaton",description:"A Suffix Automaton is a state machine that represents all substrings of a given string efficiently. It's used primarily in string processing problems, such as substring matching, pattern matching, and finding repeated substrings, among others. It builds a minimal deterministic finite automaton (DFA) to recognize all the suffixes of a string.",source:"@site/docs/DSA/SuffixAutomata.mdx",sourceDirName:"DSA",slug:"/DSA/SuffixAutomata",permalink:"/js.enigma/docs/DSA/SuffixAutomata",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/SuffixAutomata.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"String Matching",permalink:"/js.enigma/docs/DSA/StringMatching"},next:{title:"Topological Sort Tutorial",permalink:"/js.enigma/docs/DSA/TopologicalSort"}},l={},c=[{value:"Key Concepts",id:"key-concepts",level:2},{value:"Properties",id:"properties",level:2},{value:"Construction",id:"construction",level:2},{value:"Suffix Automaton Implementation",id:"suffix-automaton-implementation",level:2},{value:"Problems on Leetcode",id:"problems-on-leetcode",level:2}];function h(t){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...t.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"suffix-automaton",children:"Suffix Automaton"})}),"\n",(0,s.jsx)(n.p,{children:"A Suffix Automaton is a state machine that represents all substrings of a given string efficiently. It's used primarily in string processing problems, such as substring matching, pattern matching, and finding repeated substrings, among others. It builds a minimal deterministic finite automaton (DFA) to recognize all the suffixes of a string."}),"\n",(0,s.jsx)(n.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"1. State:"})," Each state in a suffix automaton represents a set of substrings that can be recognized from that state."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"2. Transition:"})," A transition between two states is labeled with a character, and it represents moving from one state to another when that character is read."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"3. Minimality:"})," The suffix automaton is built to minimize the number of states while still representing all suffixes of the string."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"4. Suffix Link:"}),' A suffix link is a special kind of transition that allows you to move from a state to another state that represents a "shorter" suffix of the string. This link plays a crucial role in efficiently constructing and using suffix automata.']}),"\n",(0,s.jsx)(n.h2,{id:"properties",children:"Properties"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Number of States:"})," For a string of length n, a suffix automaton has at most 2n - 1 states."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Time Complexity:"})," Constructing a suffix automaton takes O(n) time, where n is the length of the string."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Space Complexity:"})," The space complexity is O(n) in terms of the number of states and transitions."]}),"\n",(0,s.jsx)(n.h2,{id:"construction",children:"Construction"}),"\n",(0,s.jsx)(n.p,{children:"A suffix automaton can be constructed by iteratively adding characters from the string and adjusting the automaton as follows:"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Start State:"})," Initially, there\u2019s one state, representing the empty string."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Adding Characters:"})," For each character of the string, add a new state and connect it to the current state with a transition labeled by the character."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Suffix Links:"})," As new states are added, suffix links are used to connect states that represent similar suffixes."]}),"\n",(0,s.jsx)(n.h2,{id:"suffix-automaton-implementation",children:"Suffix Automaton Implementation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-JavaScript",children:'class State {\r\n  length = 0;  // Length of the longest string in this state\r\n  transitions = new Map();  // Transitions to other states\r\n  link = null;  // Suffix link\r\n  endpos = -1;  // Position where this state ends\r\n}\r\n\r\n\r\nclass SuffixAutomaton {\r\n  states = Array.of(new State());\r\n  last = 0;  // Index of last state\r\n  size = 1;  // Total number of states\r\n\r\n\r\n  // Add a character to the automaton\r\n  addChar(c) {\r\n    let curr = this.size++;\r\n    this.states[curr] = new State();\r\n    this.states[curr].length = this.states[this.last].length + 1;\r\n    this.states[curr].endpos = this.states[curr].length - 1;\r\n\r\n    // Add transitions from previous states\r\n    let p = this.last;\r\n    while (p !== null && !this.states[p].transitions.has(c)) {\r\n      this.states[p].transitions.set(c, curr);\r\n      p = this.states[p].link;\r\n    }\r\n\r\n    if (p === null) {\r\n      this.states[curr].link = 0;\r\n    } else {\r\n      let q = this.states[p].transitions.get(c);\r\n      if (this.states[p].length + 1 === this.states[q].length) {\r\n        this.states[curr].link = q;\r\n      } else {\r\n        // Clone state q\r\n        let clone = this.size++;\r\n        this.states[clone] = new State();\r\n        this.states[clone].length = this.states[p].length + 1;\r\n        this.states[clone].transitions = new Map(this.states[q].transitions);\r\n        this.states[clone].link = this.states[q].link;\r\n\r\n        while (p !== null && this.states[p].transitions.get(c) === q) {\r\n          this.states[p].transitions.set(c, clone);\r\n          p = this.states[p].link;\r\n        }\r\n\r\n        this.states[q].link = this.states[curr].link = clone;\r\n      }\r\n    }\r\n    this.last = curr;\r\n  }\r\n\r\n  // Build automaton from string\r\n  build(str) {\r\n    for (let char of str) {\r\n      this.addChar(char);\r\n    }\r\n  }\r\n\r\n  // Check if a string is a substring\r\n  contains(str) {\r\n    let state = 0;\r\n    for (let char of str) {\r\n      if (!this.states[state].transitions.has(char)) {\r\n        return false;\r\n      }\r\n      state = this.states[state].transitions.get(char);\r\n    }\r\n    return true;\r\n  }\r\n}\r\n\r\n\r\nconst sa = new SuffixAutomaton();\r\nsa.build("banana");\r\n\r\nconsole.log(sa.contains("ana")); // true\r\nconsole.log(sa.contains("nan")); // true\r\nconsole.log(sa.contains("ban")); // true\r\nconsole.log(sa.contains("xyz")); // false\r\nconsole.log(sa.contains("baa")); // false\n'})}),"\n",(0,s.jsx)(n.h2,{id:"problems-on-leetcode",children:"Problems on Leetcode"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"214 - Shortest Palindrome"}),"\n",(0,s.jsx)(n.li,{children:"459 - Repeated Substring Pattern"}),"\n",(0,s.jsx)(n.li,{children:"1316 - Distinct Echo Substrings"}),"\n",(0,s.jsx)(n.li,{children:"1698 - Number of Distinct Substrings"}),"\n",(0,s.jsx)(n.li,{children:"1044 - Longest Duplicate Substring"}),"\n",(0,s.jsx)(n.li,{children:"1181 - Before and After Puzzle"}),"\n"]})]})}function u(t={}){const{wrapper:n}={...(0,i.R)(),...t.components};return n?(0,s.jsx)(n,{...t,children:(0,s.jsx)(h,{...t})}):h(t)}},8453:(t,n,e)=>{e.d(n,{R:()=>a,x:()=>o});var s=e(6540);const i={},r=s.createContext(i);function a(t){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof t?t(n):{...n,...t}}),[n,t])}function o(t){let n;return n=t.disableParentContext?"function"==typeof t.components?t.components(i):t.components||i:a(t.components),s.createElement(r.Provider,{value:n},t.children)}}}]);