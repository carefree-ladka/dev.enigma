"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[7912],{28453:(e,n,a)=>{a.d(n,{R:()=>s,x:()=>c});var r=a(96540);const t={},o=r.createContext(t);function s(e){const n=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),r.createElement(o.Provider,{value:n},e.children)}},89392:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>c,toc:()=>i});var r=a(74848),t=a(28453);const o={},s="Garbage Collection",c={id:"WebDev/JavaScript/GarbageCollection",title:"Garbage Collection",description:"Core Concepts",source:"@site/docs/WebDev/JavaScript/GarbageCollection.mdx",sourceDirName:"WebDev/JavaScript",slug:"/WebDev/JavaScript/GarbageCollection",permalink:"/dev.enigma/docs/WebDev/JavaScript/GarbageCollection",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/WebDev/JavaScript/GarbageCollection.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Function Methods Polyfill",permalink:"/dev.enigma/docs/WebDev/JavaScript/FunctionsPolyfill"},next:{title:"HTTP Headers and Caching",permalink:"/dev.enigma/docs/WebDev/JavaScript/HTTPHeaders"}},l={},i=[{value:"Core Concepts",id:"core-concepts",level:2},{value:"1. What is Garbage Collection?",id:"1-what-is-garbage-collection",level:3},{value:"2. Memory Lifecycle",id:"2-memory-lifecycle",level:3},{value:"Garbage Collection Algorithms",id:"garbage-collection-algorithms",level:2},{value:"1. Reference Counting (Basic GC)",id:"1-reference-counting-basic-gc",level:3},{value:"Limitation: Circular References",id:"limitation-circular-references",level:4},{value:"2. Mark and Sweep Algorithm",id:"2-mark-and-sweep-algorithm",level:3},{value:"Memory Leaks",id:"memory-leaks",level:2},{value:"1. Global Variables",id:"1-global-variables",level:3},{value:"2. Forgotten Event Listeners",id:"2-forgotten-event-listeners",level:3},{value:"3. Closures Retaining References",id:"3-closures-retaining-references",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Nullifying References",id:"1-nullifying-references",level:3},{value:"2. Using WeakMap and WeakSet",id:"2-using-weakmap-and-weakset",level:3},{value:"3. Proper Event Listener Management",id:"3-proper-event-listener-management",level:3},{value:"Memory Analysis Tools",id:"memory-analysis-tools",level:2},{value:"1. Chrome DevTools",id:"1-chrome-devtools",level:3},{value:"2. Performance Monitoring",id:"2-performance-monitoring",level:3},{value:"Advanced Patterns",id:"advanced-patterns",level:2},{value:"1. Object Pools",id:"1-object-pools",level:3},{value:"2. Memory-Conscious Cache",id:"2-memory-conscious-cache",level:3},{value:"Common Debugging Patterns",id:"common-debugging-patterns",level:2},{value:"1. Memory Leak Detection",id:"1-memory-leak-detection",level:3},{value:"2. Reference Tracking",id:"2-reference-tracking",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"garbage-collection",children:"Garbage Collection"})}),"\n",(0,r.jsx)(n.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,r.jsx)(n.h3,{id:"1-what-is-garbage-collection",children:"1. What is Garbage Collection?"}),"\n",(0,r.jsx)(n.p,{children:"Garbage collection (GC) is an automatic memory management process in JavaScript that identifies and removes objects that are no longer reachable or usable by an application."}),"\n",(0,r.jsx)(n.h3,{id:"2-memory-lifecycle",children:"2. Memory Lifecycle"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'// 1. Memory Allocation\nlet user = {                    // Allocates memory for object\n    name: "John",\n    age: 30\n};\n\n// 2. Memory Use\nconsole.log(user.name);         // Uses allocated memory\n\n// 3. Memory Release\nuser = null;                    // Memory becomes eligible for GC\n'})}),"\n",(0,r.jsx)(n.h2,{id:"garbage-collection-algorithms",children:"Garbage Collection Algorithms"}),"\n",(0,r.jsx)(n.h3,{id:"1-reference-counting-basic-gc",children:"1. Reference Counting (Basic GC)"}),"\n",(0,r.jsx)(n.p,{children:"The basic concept of tracking how many references point to an object."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'let user = {                    // Reference count: 1\n    name: "John"\n};\n\nlet admin = user;               // Reference count: 2\nuser = null;                    // Reference count: 1\nadmin = null;                   // Reference count: 0 -> Eligible for GC\n'})}),"\n",(0,r.jsx)(n.h4,{id:"limitation-circular-references",children:"Limitation: Circular References"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function createCircularReference() {\n    let obj1 = {};\n    let obj2 = {};\n    \n    obj1.ref = obj2;           // obj2 reference count: 1\n    obj2.ref = obj1;           // obj1 reference count: 1\n    \n    return 'created';\n}\n\ncreateCircularReference();      // Objects still have reference count 1\n                               // but are unreachable -> Memory leak!\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-mark-and-sweep-algorithm",children:"2. Mark and Sweep Algorithm"}),"\n",(0,r.jsx)(n.p,{children:"Modern JavaScript engines use the Mark and Sweep algorithm:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Mark Phase: Starts from root objects (global object) and marks all reachable objects"}),"\n",(0,r.jsx)(n.li,{children:"Sweep Phase: Removes unmarked objects"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'// Root object\nwindow.globalUser = {\n    name: "John"\n};\n\nlet localUser = {\n    name: "Jane"\n};\n\n// After this function ends, localUser becomes unreachable\n// but globalUser remains reachable from root\n'})}),"\n",(0,r.jsx)(n.h2,{id:"memory-leaks",children:"Memory Leaks"}),"\n",(0,r.jsx)(n.h3,{id:"1-global-variables",children:"1. Global Variables"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function leakGlobal() {\n    user = { name: \"John\" };    // Missing 'let/const' -> Creates global\n}\n\n// Better version\nfunction noLeak() {\n    'use strict';              // Prevents accidental globals\n    let user = { name: \"John\" };\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-forgotten-event-listeners",children:"2. Forgotten Event Listeners"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function createButton() {\n    const button = document.createElement('button');\n    \n    // Memory leak: listener stays even if button is removed\n    button.addEventListener('click', function() {\n        // Large data structure referenced in closure\n        const data = new Array(10000).fill('data');\n        console.log(data.length);\n    });\n    \n    return button;\n}\n\n// Proper cleanup\nfunction createButtonWithCleanup() {\n    const button = document.createElement('button');\n    const handler = function() {\n        const data = new Array(10000).fill('data');\n        console.log(data.length);\n    };\n    \n    button.addEventListener('click', handler);\n    \n    return {\n        button,\n        cleanup: () => button.removeEventListener('click', handler)\n    };\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"3-closures-retaining-references",children:"3. Closures Retaining References"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function closure() {\n    const largeData = new Array(10000).fill('data');\n    \n    return function() {\n        // Keeps reference to largeData even if unused\n        console.log('Hello');\n    };\n}\n\n// Better version\nfunction noClosure() {\n    return function() {\n        console.log('Hello');\n    };\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsx)(n.h3,{id:"1-nullifying-references",children:"1. Nullifying References"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function processData() {\n    const hugeData = new Array(10000).fill('data');\n    \n    // Process data\n    const result = hugeData.map(item => item.toUpperCase());\n    \n    // Clear reference when done\n    hugeData = null;\n    \n    return result;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-using-weakmap-and-weakset",children:"2. Using WeakMap and WeakSet"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// Strong reference - prevents GC\nconst cache = new Map();\nlet user = { id: 1 };\ncache.set(user, 'userData');\nuser = null;                    // Object still in cache\n\n// Weak reference - allows GC\nconst weakCache = new WeakMap();\nlet user2 = { id: 2 };\nweakCache.set(user2, 'userData');\nuser2 = null;                   // Object can be garbage collected\n"})}),"\n",(0,r.jsx)(n.h3,{id:"3-proper-event-listener-management",children:"3. Proper Event Listener Management"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class ComponentWithEvents {\n    constructor() {\n        this.handleClick = this.handleClick.bind(this);\n        this.init();\n    }\n    \n    init() {\n        document.addEventListener('click', this.handleClick);\n    }\n    \n    handleClick() {\n        console.log('clicked');\n    }\n    \n    destroy() {\n        // Clean up listeners\n        document.removeEventListener('click', this.handleClick);\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"memory-analysis-tools",children:"Memory Analysis Tools"}),"\n",(0,r.jsx)(n.h3,{id:"1-chrome-devtools",children:"1. Chrome DevTools"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'// Taking heap snapshot\n// 1. Open Chrome DevTools\n// 2. Go to Memory tab\n// 3. Select "Take heap snapshot"\n// 4. Analyze objects and references\n\n// Memory recording\n// 1. Click "Record allocation timeline"\n// 2. Perform actions\n// 3. Stop recording\n// 4. Analyze memory allocation patterns\n'})}),"\n",(0,r.jsx)(n.h3,{id:"2-performance-monitoring",children:"2. Performance Monitoring"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// Monitor memory usage\nconst used = process.memoryUsage();\nconsole.log({\n    heapTotal: `${Math.round(used.heapTotal / 1024 / 1024 * 100) / 100} MB`,\n    heapUsed: `${Math.round(used.heapUsed / 1024 / 1024 * 100) / 100} MB`\n});\n"})}),"\n",(0,r.jsx)(n.h2,{id:"advanced-patterns",children:"Advanced Patterns"}),"\n",(0,r.jsx)(n.h3,{id:"1-object-pools",children:"1. Object Pools"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class ObjectPool {\n    constructor(createFn, maxSize = 1000) {\n        this.createFn = createFn;\n        this.maxSize = maxSize;\n        this.pool = [];\n    }\n    \n    acquire() {\n        return this.pool.pop() || this.createFn();\n    }\n    \n    release(obj) {\n        if (this.pool.length < this.maxSize) {\n            this.pool.push(obj);\n        }\n    }\n}\n\n// Usage\nconst pool = new ObjectPool(() => new Array(1000));\nconst arr = pool.acquire();\n// Use array...\npool.release(arr);             // Reuse instead of GC\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-memory-conscious-cache",children:"2. Memory-Conscious Cache"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class MemoryCache {\n    constructor(maxSize = 1000) {\n        this.maxSize = maxSize;\n        this.cache = new Map();\n    }\n    \n    set(key, value) {\n        if (this.cache.size >= this.maxSize) {\n            // Remove oldest entry\n            const firstKey = this.cache.keys().next().value;\n            this.cache.delete(firstKey);\n        }\n        this.cache.set(key, value);\n    }\n    \n    get(key) {\n        return this.cache.get(key);\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"common-debugging-patterns",children:"Common Debugging Patterns"}),"\n",(0,r.jsx)(n.h3,{id:"1-memory-leak-detection",children:"1. Memory Leak Detection"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"let memoryLeaks = [];\n\nfunction detectLeak() {\n    setInterval(() => {\n        const snapshot1 = performance.memory.usedJSHeapSize;\n        // Perform operations\n        const snapshot2 = performance.memory.usedJSHeapSize;\n        \n        if (snapshot2 - snapshot1 > 1000000) { // 1MB threshold\n            console.warn('Possible memory leak detected');\n            memoryLeaks.push({\n                time: Date.now(),\n                increase: snapshot2 - snapshot1\n            });\n        }\n    }, 1000);\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-reference-tracking",children:"2. Reference Tracking"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class ReferenceTracker {\n    static refs = new WeakMap();\n    \n    static track(obj) {\n        this.refs.set(obj, new Error().stack);\n    }\n    \n    static getCreationStack(obj) {\n        return this.refs.get(obj);\n    }\n}\n\n// Usage\nconst obj = { data: 'important' };\nReferenceTracker.track(obj);\nconsole.log(ReferenceTracker.getCreationStack(obj));\n"})}),"\n",(0,r.jsx)(n.p,{children:"Remember that garbage collection in JavaScript is automatic and optimized by the engine. These patterns and practices help you write memory-efficient code, but you should profile and measure before implementing complex memory management strategies."}),"\n",(0,r.jsx)(n.p,{children:"The key is to:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Avoid unnecessary object references"}),"\n",(0,r.jsx)(n.li,{children:"Clean up event listeners and timers"}),"\n",(0,r.jsx)(n.li,{children:"Use weak references when appropriate"}),"\n",(0,r.jsx)(n.li,{children:"Monitor memory usage in development"}),"\n",(0,r.jsx)(n.li,{children:"Test memory patterns with large datasets"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);