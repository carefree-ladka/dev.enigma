"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[7912],{9392:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>c,toc:()=>i});var a=r(4848),t=r(8453);const o={},s="Garbage Collection",c={id:"WebDev/JavaScript/GarbageCollection",title:"Garbage Collection",description:"Core Concepts",source:"@site/docs/WebDev/JavaScript/GarbageCollection.mdx",sourceDirName:"WebDev/JavaScript",slug:"/WebDev/JavaScript/GarbageCollection",permalink:"/js.enigma/docs/WebDev/JavaScript/GarbageCollection",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/WebDev/JavaScript/GarbageCollection.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Function Methods Polyfill",permalink:"/js.enigma/docs/WebDev/JavaScript/FunctionsPolyfill"},next:{title:"HTTP Headers and Caching",permalink:"/js.enigma/docs/WebDev/JavaScript/HTTPHeaders"}},l={},i=[{value:"Core Concepts",id:"core-concepts",level:2},{value:"1. What is Garbage Collection?",id:"1-what-is-garbage-collection",level:3},{value:"2. Memory Lifecycle",id:"2-memory-lifecycle",level:3},{value:"Garbage Collection Algorithms",id:"garbage-collection-algorithms",level:2},{value:"1. Reference Counting (Basic GC)",id:"1-reference-counting-basic-gc",level:3},{value:"Limitation: Circular References",id:"limitation-circular-references",level:4},{value:"2. Mark and Sweep Algorithm",id:"2-mark-and-sweep-algorithm",level:3},{value:"Memory Leaks",id:"memory-leaks",level:2},{value:"1. Global Variables",id:"1-global-variables",level:3},{value:"2. Forgotten Event Listeners",id:"2-forgotten-event-listeners",level:3},{value:"3. Closures Retaining References",id:"3-closures-retaining-references",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Nullifying References",id:"1-nullifying-references",level:3},{value:"2. Using WeakMap and WeakSet",id:"2-using-weakmap-and-weakset",level:3},{value:"3. Proper Event Listener Management",id:"3-proper-event-listener-management",level:3},{value:"Memory Analysis Tools",id:"memory-analysis-tools",level:2},{value:"1. Chrome DevTools",id:"1-chrome-devtools",level:3},{value:"2. Performance Monitoring",id:"2-performance-monitoring",level:3},{value:"Advanced Patterns",id:"advanced-patterns",level:2},{value:"1. Object Pools",id:"1-object-pools",level:3},{value:"2. Memory-Conscious Cache",id:"2-memory-conscious-cache",level:3},{value:"Common Debugging Patterns",id:"common-debugging-patterns",level:2},{value:"1. Memory Leak Detection",id:"1-memory-leak-detection",level:3},{value:"2. Reference Tracking",id:"2-reference-tracking",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"garbage-collection",children:"Garbage Collection"})}),"\n",(0,a.jsx)(n.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,a.jsx)(n.h3,{id:"1-what-is-garbage-collection",children:"1. What is Garbage Collection?"}),"\n",(0,a.jsx)(n.p,{children:"Garbage collection (GC) is an automatic memory management process in JavaScript that identifies and removes objects that are no longer reachable or usable by an application."}),"\n",(0,a.jsx)(n.h3,{id:"2-memory-lifecycle",children:"2. Memory Lifecycle"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'// 1. Memory Allocation\r\nlet user = {                    // Allocates memory for object\r\n    name: "John",\r\n    age: 30\r\n};\r\n\r\n// 2. Memory Use\r\nconsole.log(user.name);         // Uses allocated memory\r\n\r\n// 3. Memory Release\r\nuser = null;                    // Memory becomes eligible for GC\n'})}),"\n",(0,a.jsx)(n.h2,{id:"garbage-collection-algorithms",children:"Garbage Collection Algorithms"}),"\n",(0,a.jsx)(n.h3,{id:"1-reference-counting-basic-gc",children:"1. Reference Counting (Basic GC)"}),"\n",(0,a.jsx)(n.p,{children:"The basic concept of tracking how many references point to an object."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'let user = {                    // Reference count: 1\r\n    name: "John"\r\n};\r\n\r\nlet admin = user;               // Reference count: 2\r\nuser = null;                    // Reference count: 1\r\nadmin = null;                   // Reference count: 0 -> Eligible for GC\n'})}),"\n",(0,a.jsx)(n.h4,{id:"limitation-circular-references",children:"Limitation: Circular References"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"function createCircularReference() {\r\n    let obj1 = {};\r\n    let obj2 = {};\r\n    \r\n    obj1.ref = obj2;           // obj2 reference count: 1\r\n    obj2.ref = obj1;           // obj1 reference count: 1\r\n    \r\n    return 'created';\r\n}\r\n\r\ncreateCircularReference();      // Objects still have reference count 1\r\n                               // but are unreachable -> Memory leak!\n"})}),"\n",(0,a.jsx)(n.h3,{id:"2-mark-and-sweep-algorithm",children:"2. Mark and Sweep Algorithm"}),"\n",(0,a.jsx)(n.p,{children:"Modern JavaScript engines use the Mark and Sweep algorithm:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Mark Phase: Starts from root objects (global object) and marks all reachable objects"}),"\n",(0,a.jsx)(n.li,{children:"Sweep Phase: Removes unmarked objects"}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'// Root object\r\nwindow.globalUser = {\r\n    name: "John"\r\n};\r\n\r\nlet localUser = {\r\n    name: "Jane"\r\n};\r\n\r\n// After this function ends, localUser becomes unreachable\r\n// but globalUser remains reachable from root\n'})}),"\n",(0,a.jsx)(n.h2,{id:"memory-leaks",children:"Memory Leaks"}),"\n",(0,a.jsx)(n.h3,{id:"1-global-variables",children:"1. Global Variables"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"function leakGlobal() {\r\n    user = { name: \"John\" };    // Missing 'let/const' -> Creates global\r\n}\r\n\r\n// Better version\r\nfunction noLeak() {\r\n    'use strict';              // Prevents accidental globals\r\n    let user = { name: \"John\" };\r\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"2-forgotten-event-listeners",children:"2. Forgotten Event Listeners"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"function createButton() {\r\n    const button = document.createElement('button');\r\n    \r\n    // Memory leak: listener stays even if button is removed\r\n    button.addEventListener('click', function() {\r\n        // Large data structure referenced in closure\r\n        const data = new Array(10000).fill('data');\r\n        console.log(data.length);\r\n    });\r\n    \r\n    return button;\r\n}\r\n\r\n// Proper cleanup\r\nfunction createButtonWithCleanup() {\r\n    const button = document.createElement('button');\r\n    const handler = function() {\r\n        const data = new Array(10000).fill('data');\r\n        console.log(data.length);\r\n    };\r\n    \r\n    button.addEventListener('click', handler);\r\n    \r\n    return {\r\n        button,\r\n        cleanup: () => button.removeEventListener('click', handler)\r\n    };\r\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"3-closures-retaining-references",children:"3. Closures Retaining References"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"function closure() {\r\n    const largeData = new Array(10000).fill('data');\r\n    \r\n    return function() {\r\n        // Keeps reference to largeData even if unused\r\n        console.log('Hello');\r\n    };\r\n}\r\n\r\n// Better version\r\nfunction noClosure() {\r\n    return function() {\r\n        console.log('Hello');\r\n    };\r\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsx)(n.h3,{id:"1-nullifying-references",children:"1. Nullifying References"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"function processData() {\r\n    const hugeData = new Array(10000).fill('data');\r\n    \r\n    // Process data\r\n    const result = hugeData.map(item => item.toUpperCase());\r\n    \r\n    // Clear reference when done\r\n    hugeData = null;\r\n    \r\n    return result;\r\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"2-using-weakmap-and-weakset",children:"2. Using WeakMap and WeakSet"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// Strong reference - prevents GC\r\nconst cache = new Map();\r\nlet user = { id: 1 };\r\ncache.set(user, 'userData');\r\nuser = null;                    // Object still in cache\r\n\r\n// Weak reference - allows GC\r\nconst weakCache = new WeakMap();\r\nlet user2 = { id: 2 };\r\nweakCache.set(user2, 'userData');\r\nuser2 = null;                   // Object can be garbage collected\n"})}),"\n",(0,a.jsx)(n.h3,{id:"3-proper-event-listener-management",children:"3. Proper Event Listener Management"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"class ComponentWithEvents {\r\n    constructor() {\r\n        this.handleClick = this.handleClick.bind(this);\r\n        this.init();\r\n    }\r\n    \r\n    init() {\r\n        document.addEventListener('click', this.handleClick);\r\n    }\r\n    \r\n    handleClick() {\r\n        console.log('clicked');\r\n    }\r\n    \r\n    destroy() {\r\n        // Clean up listeners\r\n        document.removeEventListener('click', this.handleClick);\r\n    }\r\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"memory-analysis-tools",children:"Memory Analysis Tools"}),"\n",(0,a.jsx)(n.h3,{id:"1-chrome-devtools",children:"1. Chrome DevTools"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'// Taking heap snapshot\r\n// 1. Open Chrome DevTools\r\n// 2. Go to Memory tab\r\n// 3. Select "Take heap snapshot"\r\n// 4. Analyze objects and references\r\n\r\n// Memory recording\r\n// 1. Click "Record allocation timeline"\r\n// 2. Perform actions\r\n// 3. Stop recording\r\n// 4. Analyze memory allocation patterns\n'})}),"\n",(0,a.jsx)(n.h3,{id:"2-performance-monitoring",children:"2. Performance Monitoring"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// Monitor memory usage\r\nconst used = process.memoryUsage();\r\nconsole.log({\r\n    heapTotal: `${Math.round(used.heapTotal / 1024 / 1024 * 100) / 100} MB`,\r\n    heapUsed: `${Math.round(used.heapUsed / 1024 / 1024 * 100) / 100} MB`\r\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"advanced-patterns",children:"Advanced Patterns"}),"\n",(0,a.jsx)(n.h3,{id:"1-object-pools",children:"1. Object Pools"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"class ObjectPool {\r\n    constructor(createFn, maxSize = 1000) {\r\n        this.createFn = createFn;\r\n        this.maxSize = maxSize;\r\n        this.pool = [];\r\n    }\r\n    \r\n    acquire() {\r\n        return this.pool.pop() || this.createFn();\r\n    }\r\n    \r\n    release(obj) {\r\n        if (this.pool.length < this.maxSize) {\r\n            this.pool.push(obj);\r\n        }\r\n    }\r\n}\r\n\r\n// Usage\r\nconst pool = new ObjectPool(() => new Array(1000));\r\nconst arr = pool.acquire();\r\n// Use array...\r\npool.release(arr);             // Reuse instead of GC\n"})}),"\n",(0,a.jsx)(n.h3,{id:"2-memory-conscious-cache",children:"2. Memory-Conscious Cache"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"class MemoryCache {\r\n    constructor(maxSize = 1000) {\r\n        this.maxSize = maxSize;\r\n        this.cache = new Map();\r\n    }\r\n    \r\n    set(key, value) {\r\n        if (this.cache.size >= this.maxSize) {\r\n            // Remove oldest entry\r\n            const firstKey = this.cache.keys().next().value;\r\n            this.cache.delete(firstKey);\r\n        }\r\n        this.cache.set(key, value);\r\n    }\r\n    \r\n    get(key) {\r\n        return this.cache.get(key);\r\n    }\r\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"common-debugging-patterns",children:"Common Debugging Patterns"}),"\n",(0,a.jsx)(n.h3,{id:"1-memory-leak-detection",children:"1. Memory Leak Detection"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"let memoryLeaks = [];\r\n\r\nfunction detectLeak() {\r\n    setInterval(() => {\r\n        const snapshot1 = performance.memory.usedJSHeapSize;\r\n        // Perform operations\r\n        const snapshot2 = performance.memory.usedJSHeapSize;\r\n        \r\n        if (snapshot2 - snapshot1 > 1000000) { // 1MB threshold\r\n            console.warn('Possible memory leak detected');\r\n            memoryLeaks.push({\r\n                time: Date.now(),\r\n                increase: snapshot2 - snapshot1\r\n            });\r\n        }\r\n    }, 1000);\r\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"2-reference-tracking",children:"2. Reference Tracking"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"class ReferenceTracker {\r\n    static refs = new WeakMap();\r\n    \r\n    static track(obj) {\r\n        this.refs.set(obj, new Error().stack);\r\n    }\r\n    \r\n    static getCreationStack(obj) {\r\n        return this.refs.get(obj);\r\n    }\r\n}\r\n\r\n// Usage\r\nconst obj = { data: 'important' };\r\nReferenceTracker.track(obj);\r\nconsole.log(ReferenceTracker.getCreationStack(obj));\n"})}),"\n",(0,a.jsx)(n.p,{children:"Remember that garbage collection in JavaScript is automatic and optimized by the engine. These patterns and practices help you write memory-efficient code, but you should profile and measure before implementing complex memory management strategies."}),"\n",(0,a.jsx)(n.p,{children:"The key is to:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Avoid unnecessary object references"}),"\n",(0,a.jsx)(n.li,{children:"Clean up event listeners and timers"}),"\n",(0,a.jsx)(n.li,{children:"Use weak references when appropriate"}),"\n",(0,a.jsx)(n.li,{children:"Monitor memory usage in development"}),"\n",(0,a.jsx)(n.li,{children:"Test memory patterns with large datasets"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>c});var a=r(6540);const t={},o=a.createContext(t);function s(e){const n=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),a.createElement(o.Provider,{value:n},e.children)}}}]);