"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[4367],{4978:(n,r,e)=>{e.r(r),e.d(r,{assets:()=>c,contentTitle:()=>s,default:()=>l,frontMatter:()=>i,metadata:()=>a,toc:()=>d});var o=e(4848),t=e(8453);const i={title:"Union-Find (Disjoint Set Union) Tutorial",description:"A comprehensive guide to Union-Find data structure with code examples in JavaScript."},s="Union-Find (Disjoint Set Union) Tutorial",a={id:"DSA/UnionFind",title:"Union-Find (Disjoint Set Union) Tutorial",description:"A comprehensive guide to Union-Find data structure with code examples in JavaScript.",source:"@site/docs/DSA/UnionFind.mdx",sourceDirName:"DSA",slug:"/DSA/UnionFind",permalink:"/js.enigma/docs/DSA/UnionFind",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/UnionFind.mdx",tags:[],version:"current",frontMatter:{title:"Union-Find (Disjoint Set Union) Tutorial",description:"A comprehensive guide to Union-Find data structure with code examples in JavaScript."},sidebar:"tutorialSidebar",previous:{title:"Two Pointers Technique",permalink:"/js.enigma/docs/DSA/TwoPointers"},next:{title:"Frontend System Design",permalink:"/js.enigma/docs/category/frontend-system-design"}},c={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Key Operations",id:"key-operations",level:2},{value:"Implementation",id:"implementation",level:2},{value:"Find all Connected Components in a Graph",id:"find-all-connected-components-in-a-graph",level:2},{value:"Find all Connected Components in a Graph: Using Union-Find",id:"find-all-connected-components-in-a-graph-using-union-find",level:2},{value:"Compute the size of Each Connected Component",id:"compute-the-size-of-each-connected-component",level:2},{value:"Find Maximum in Each Component",id:"find-maximum-in-each-component",level:2}];function p(n){const r={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,t.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(r.header,{children:(0,o.jsx)(r.h1,{id:"union-find-disjoint-set-union-tutorial",children:"Union-Find (Disjoint Set Union) Tutorial"})}),"\n",(0,o.jsx)(r.h2,{id:"introduction",children:"Introduction"}),"\n",(0,o.jsx)(r.p,{children:"The Union-Find data structure, also known as Disjoint Set Union (DSU), is a data structure that keeps track of a partition of a set into disjoint (non-overlapping) subsets. It supports two primary operations:"}),"\n",(0,o.jsxs)(r.ol,{children:["\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Union"}),": Merge two subsets into a single subset."]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Find"}),": Determine which subset a particular element is in."]}),"\n"]}),"\n",(0,o.jsx)(r.p,{children:"Union-Find is particularly useful in scenarios involving network connectivity, Kruskal's algorithm for finding the Minimum Spanning Tree, and various other graph-related problems."}),"\n",(0,o.jsx)(r.h2,{id:"key-operations",children:"Key Operations"}),"\n",(0,o.jsxs)(r.ol,{children:["\n",(0,o.jsxs)(r.li,{children:["\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Find"}),": This operation determines the representative or root of the set that contains the given element. Path compression is often used to speed up future queries."]}),"\n"]}),"\n",(0,o.jsxs)(r.li,{children:["\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Union"}),": This operation merges two subsets into a single subset. Union by rank (or size) is commonly used to keep the tree flat and efficient."]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(r.h2,{id:"implementation",children:"Implementation"}),"\n",(0,o.jsxs)(r.ol,{children:["\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Array"}),": Use when indices are small, dense, and within a fixed range."]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Map"}),": Use when indices are large, sparse, dynamic, non-numeric, or complex."]}),"\n"]}),"\n",(0,o.jsx)(r.p,{children:"Here\u2019s a basic implementation of the Union-Find data structure in JavaScript:"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-javascript",children:"class UnionFind {\r\n  constructor(size) {\r\n    this.parent = Array.from({ length: size }, (_, i) => i);\r\n    this.rank = Array(size).fill(0);\r\n  }\r\n\r\n  // Find the root of the set containing element x with path compression\r\n  find(x) {\r\n    if (this.parent[x] !== x) {\r\n      this.parent[x] = this.find(this.parent[x]); // Path compression\r\n    }\r\n    return this.parent[x];\r\n  }\r\n\r\n  // Union the sets containing elements x and y with union by rank\r\n  union(x, y) {\r\n    const rootX = this.find(x);\r\n    const rootY = this.find(y);\r\n\r\n    if (rootX !== rootY) {\r\n      // Union by rank\r\n      if (this.rank[rootX] > this.rank[rootY]) {\r\n        this.parent[rootY] = rootX;\r\n      } else if (this.rank[rootX] < this.rank[rootY]) {\r\n        this.parent[rootX] = rootY;\r\n      } else {\r\n        this.parent[rootY] = rootX;\r\n        this.rank[rootX] += 1;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// Example Usage\r\nconst uf = new UnionFind(10);\r\n\r\n// Union operations\r\nuf.union(1, 2);\r\nuf.union(2, 3);\r\nuf.union(4, 5);\r\n\r\n// Find operations\r\nconsole.log(uf.find(1)); // Output: 1 (root of the set containing 1)\r\nconsole.log(uf.find(3)); // Output: 1 (root of the set containing 3)\r\nconsole.log(uf.find(5)); // Output: 5 (root of the set containing 5)\n"})}),"\n",(0,o.jsx)(r.h1,{id:"using-map",children:"Using Map"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-JavaScript",children:"class DSU {\r\n  constructor() {\r\n    this.parent = new Map();\r\n    this.rank = new Map();\r\n  }\r\n\r\n  find(x) {\r\n    if (!this.parent.has(x)) {\r\n      this.parent.set(x, x); // Initialize parent to itself if not present\r\n    }\r\n    if (x !== this.parent.get(x)) {\r\n      this.parent.set(x, this.find(this.parent.get(x))); // Path compression\r\n    }\r\n    return this.parent.get(x); // Return the root parent\r\n  }\r\n\r\n  union(x, y) {\r\n    let rootX = this.find(x);\r\n    let rootY = this.find(y);\r\n\r\n    if (rootX !== rootY) {\r\n      let rankX = this.rank.get(rootX);\r\n      let rankY = this.rank.get(rootY);\r\n\r\n      if (rankX > rankY) {\r\n        this.parent.set(rootY, rootX);\r\n      } else if (rankX < rankY) {\r\n        this.parent.set(rootX, rootY);\r\n      } else {\r\n        this.parent.set(rootY, rootX);\r\n        this.rank.set(rootX, rankX + 1);\r\n      }\r\n    }\r\n  }\r\n}\n"})}),"\n",(0,o.jsx)(r.h2,{id:"find-all-connected-components-in-a-graph",children:"Find all Connected Components in a Graph"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-JavaScript",children:"/**\r\n * Finds all connected components in a graph using DFS.\r\n * @param {number} n - Number of nodes (0 to n-1).\r\n * @param {number[][]} edges - Edges of the graph [u, v].\r\n * @return {number[][]} - Array of connected components.\r\n */\r\nfunction findConnectedComponents(n, edges) {\r\n  // Build adjacency list\r\n  const graph = Array.from({ length: n }, () => []);\r\n  for (const [u, v] of edges) {\r\n    graph[u].push(v);\r\n    graph[v].push(u);\r\n  }\r\n\r\n  const visited = Array(n).fill(false); // Track visited nodes\r\n  const components = []; // List of connected components\r\n\r\n  // DFS function to collect nodes in a component\r\n  function dfs(node, component) {\r\n    visited[node] = true;\r\n    component.push(node);\r\n    for (const neighbor of graph[node]) {\r\n      if (!visited[neighbor]) {\r\n        dfs(neighbor, component);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Traverse all nodes\r\n  for (let i = 0; i < n; i++) {\r\n    if (!visited[i]) {\r\n      const component = [];\r\n      dfs(i, component); // Find all nodes in the current component\r\n      components.push(component); // Save the component\r\n    }\r\n  }\r\n\r\n  return components;\r\n}\r\n\r\n// Example usage\r\nconst n = 6;\r\nconst edges = [\r\n  [0, 1],\r\n  [1, 2],\r\n  [3, 4],\r\n];\r\nconst result = findConnectedComponents(n, edges);\r\nconsole.log(result); // Example output: [[0, 1, 2], [3, 4], [5]]\n"})}),"\n",(0,o.jsx)(r.h2,{id:"find-all-connected-components-in-a-graph-using-union-find",children:"Find all Connected Components in a Graph: Using Union-Find"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-JavaScript",children:"/**\r\n * Finds all connected components in a graph using Union-Find.\r\n * @param {number} n - Number of nodes (0 to n-1).\r\n * @param {number[][]} edges - Edges of the graph [u, v].\r\n * @return {number[][]} - Array of connected components.\r\n */\r\nfunction findConnectedComponents(n, edges) {\r\n  const parent = Array.from({ length: n }, (_, i) => i); // Parent array\r\n  const rank = Array(n).fill(0); // Rank array for optimization\r\n\r\n  // Find operation with path compression\r\n  function find(x) {\r\n    if (parent[x] !== x) {\r\n      parent[x] = find(parent[x]); // Path compression\r\n    }\r\n    return parent[x];\r\n  }\r\n\r\n  // Union operation with rank optimization\r\n  function union(x, y) {\r\n    const rootX = find(x);\r\n    const rootY = find(y);\r\n    if (rootX !== rootY) {\r\n      if (rank[rootX] > rank[rootY]) {\r\n        parent[rootY] = rootX;\r\n      } else if (rank[rootX] < rank[rootY]) {\r\n        parent[rootX] = rootY;\r\n      } else {\r\n        parent[rootY] = rootX;\r\n        rank[rootX]++;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Process all edges\r\n  for (const [u, v] of edges) {\r\n    union(u, v);\r\n  }\r\n\r\n  // Group nodes by their root\r\n  const componentsMap = new Map();\r\n  for (let i = 0; i < n; i++) {\r\n    const root = find(i);\r\n    if (!componentsMap.has(root)) {\r\n      componentsMap.set(root, []);\r\n    }\r\n    componentsMap.get(root).push(i);\r\n  }\r\n\r\n  // Convert map to an array of components\r\n  return Array.from(componentsMap.values());\r\n}\r\n\r\n// Example usage\r\nconst n = 6;\r\nconst edges = [\r\n  [0, 1],\r\n  [1, 2],\r\n  [3, 4],\r\n];\r\nconst result = findConnectedComponents(n, edges);\r\nconsole.log(result); // Example output: [[0, 1, 2], [3, 4], [5]]\r\n\r\n/*\r\nThis means:\r\n\r\nNodes [0, 1, 2] are connected.\r\nNodes [3, 4] are connected.\r\nNode [5] is isolated. \r\n */\n"})}),"\n",(0,o.jsx)(r.h2,{id:"compute-the-size-of-each-connected-component",children:"Compute the size of Each Connected Component"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-JavaScript",children:"class UnionFind {\r\n  constructor(n) {\r\n    this.parent = Array.from({ length: n }, (_, i) => i); // Each node is its own parent initially\r\n    this.size = Array(n).fill(1); // Each component initially has size 1\r\n  }\r\n\r\n  // Find operation with path compression\r\n  find(x) {\r\n    if (this.parent[x] !== x) {\r\n      this.parent[x] = this.find(this.parent[x]); // Path compression\r\n    }\r\n    return this.parent[x];\r\n  }\r\n\r\n  // Union operation with size tracking\r\n  union(x, y) {\r\n    const rootX = this.find(x);\r\n    const rootY = this.find(y);\r\n\r\n    if (rootX !== rootY) {\r\n      // Merge smaller tree into larger tree\r\n      if (this.size[rootX] > this.size[rootY]) {\r\n        this.parent[rootY] = rootX;\r\n        this.size[rootX] += this.size[rootY];\r\n      } else {\r\n        this.parent[rootX] = rootY;\r\n        this.size[rootY] += this.size[rootX];\r\n      }\r\n    }\r\n  }\r\n\r\n  // Get sizes of all components\r\n  getComponentSizes() {\r\n    const componentSizes = new Map();\r\n    for (let i = 0; i < this.parent.length; i++) {\r\n      const root = this.find(i);\r\n      if (!componentSizes.has(root)) {\r\n        componentSizes.set(root, this.size[root]);\r\n      }\r\n    }\r\n    return Array.from(componentSizes.values());\r\n  }\r\n}\r\n\r\n// Function to find the sizes of all connected components\r\nfunction connectedComponentSizes(n, edges) {\r\n  const uf = new UnionFind(n);\r\n\r\n  // Process all edges\r\n  for (const [u, v] of edges) {\r\n    uf.union(u, v);\r\n  }\r\n\r\n  // Get sizes of connected components\r\n  return uf.getComponentSizes();\r\n}\r\n\r\n// Example usage\r\nconst n = 6;\r\nconst edges = [\r\n  [0, 1],\r\n  [1, 2],\r\n  [3, 4],\r\n];\r\nconst result = connectedComponentSizes(n, edges);\r\nconsole.log(result); // Example output: [3, 2, 1]\r\n\r\n/* \r\nThis indicates:\r\n\r\nA component of size 3 (nodes [0, 1, 2]).\r\nA component of size 2 (nodes [3, 4]).\r\nA component of size 1 (node [5], isolated).\r\n*/\n"})}),"\n",(0,o.jsx)(r.h2,{id:"find-maximum-in-each-component",children:"Find Maximum in Each Component"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-JavaScript",children:"class UnionFind {\r\n  constructor(n) {\r\n    this.parent = Array.from({ length: n }, (_, i) => i); // Each node is its own parent initially\r\n    this.size = Array(n).fill(1); // Each component initially has size 1\r\n    this.max = Array.from({ length: n }, (_, i) => i); // Maximum value in each component\r\n  }\r\n\r\n  // Find operation with path compression\r\n  find(x) {\r\n    if (this.parent[x] !== x) {\r\n      this.parent[x] = this.find(this.parent[x]); // Path compression\r\n    }\r\n    return this.parent[x];\r\n  }\r\n\r\n  // Union operation with size and max tracking\r\n  union(x, y) {\r\n    const rootX = this.find(x);\r\n    const rootY = this.find(y);\r\n\r\n    if (rootX !== rootY) {\r\n      // Merge smaller tree into larger tree\r\n      if (this.size[rootX] > this.size[rootY]) {\r\n        this.parent[rootY] = rootX;\r\n        this.size[rootX] += this.size[rootY];\r\n        this.max[rootX] = Math.max(this.max[rootX], this.max[rootY]);\r\n      } else {\r\n        this.parent[rootX] = rootY;\r\n        this.size[rootY] += this.size[rootX];\r\n        this.max[rootY] = Math.max(this.max[rootX], this.max[rootY]);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Get maximum in each component\r\n  getComponentMax() {\r\n    const componentMax = new Map();\r\n    for (let i = 0; i < this.parent.length; i++) {\r\n      const root = this.find(i);\r\n      if (!componentMax.has(root)) {\r\n        componentMax.set(root, this.max[root]);\r\n      }\r\n    }\r\n    return Array.from(componentMax.values());\r\n  }\r\n}\r\n\r\n// Function to find the maximum in each connected component\r\nfunction maxInEachComponent(n, edges) {\r\n  const uf = new UnionFind(n);\r\n\r\n  // Process all edges\r\n  for (const [u, v] of edges) {\r\n    uf.union(u, v);\r\n  }\r\n\r\n  // Get maximum in each connected component\r\n  return uf.getComponentMax();\r\n}\r\n\r\n// Example usage\r\nconst n = 6;\r\nconst edges = [\r\n  [0, 1],\r\n  [1, 2],\r\n  [3, 4],\r\n];\r\nconst result = maxInEachComponent(n, edges);\r\nconsole.log(result); // Example output: [2, 4, 5]\r\n\r\n/* \r\nComponent {0, 1, 2}: Maximum is 2.\r\nComponent {3, 4}: Maximum is 4.\r\nComponent {5}: Maximum is 5.\r\n*/\n"})})]})}function l(n={}){const{wrapper:r}={...(0,t.R)(),...n.components};return r?(0,o.jsx)(r,{...n,children:(0,o.jsx)(p,{...n})}):p(n)}},8453:(n,r,e)=>{e.d(r,{R:()=>s,x:()=>a});var o=e(6540);const t={},i=o.createContext(t);function s(n){const r=o.useContext(i);return o.useMemo((function(){return"function"==typeof n?n(r):{...r,...n}}),[r,n])}function a(n){let r;return r=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:s(n.components),o.createElement(i.Provider,{value:r},n.children)}}}]);