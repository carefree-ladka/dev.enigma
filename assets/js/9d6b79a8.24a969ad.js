"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[207],{28453:(n,e,t)=>{t.d(e,{R:()=>a,x:()=>c});var r=t(96540);const i={},s=r.createContext(i);function a(n){const e=r.useContext(s);return r.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function c(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:a(n.components),r.createElement(s.Provider,{value:e},n.children)}},67154:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>o,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>c,toc:()=>l});var r=t(74848),i=t(28453);const s={},a="Backtracking",c={id:"DSA/DSA with JavaScript/DSA Cheatsheets/Backtracking",title:"Backtracking",description:"A comprehensive guide to backtracking algorithms and techniques for Data Structures and Algorithms.",source:"@site/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Backtracking.mdx",sourceDirName:"DSA/DSA with JavaScript/DSA Cheatsheets",slug:"/DSA/DSA with JavaScript/DSA Cheatsheets/Backtracking",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Backtracking",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Backtracking.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Array",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Array Techniques"},next:{title:"Binary Search",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Binary Search"}},o={},l=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Core Backtracking Concepts",id:"core-backtracking-concepts",level:2},{value:"Key Characteristics:",id:"key-characteristics",level:3},{value:"When to Use Backtracking:",id:"when-to-use-backtracking",level:3},{value:"The Backtracking Template",id:"the-backtracking-template",level:2},{value:"Generic Backtracking Framework",id:"generic-backtracking-framework",level:3},{value:"Subset Generation Patterns",id:"subset-generation-patterns",level:2},{value:"1. All Subsets (Power Set)",id:"1-all-subsets-power-set",level:3},{value:"2. Subsets with Target Sum",id:"2-subsets-with-target-sum",level:3},{value:"3. Subsets with Duplicates",id:"3-subsets-with-duplicates",level:3},{value:"Permutation Patterns",id:"permutation-patterns",level:2},{value:"1. All Permutations",id:"1-all-permutations",level:3},{value:"2. Permutations with Duplicates",id:"2-permutations-with-duplicates",level:3},{value:"3. Next Permutation",id:"3-next-permutation",level:3},{value:"Combination Patterns",id:"combination-patterns",level:2},{value:"1. Combinations of Size K",id:"1-combinations-of-size-k",level:3},{value:"2. Combination Sum",id:"2-combination-sum",level:3},{value:"3. Combination Sum II",id:"3-combination-sum-ii",level:3},{value:"Constraint Satisfaction Problems",id:"constraint-satisfaction-problems",level:2},{value:"1. N-Queens Problem",id:"1-n-queens-problem",level:3},{value:"2. Sudoku Solver",id:"2-sudoku-solver",level:3},{value:"Grid/Matrix Backtracking",id:"gridmatrix-backtracking",level:2},{value:"1. Word Search",id:"1-word-search",level:3},{value:"2. Number of Islands",id:"2-number-of-islands",level:3},{value:"3. Rat in Maze",id:"3-rat-in-maze",level:3},{value:"String Backtracking",id:"string-backtracking",level:2},{value:"1. Generate Parentheses",id:"1-generate-parentheses",level:3},{value:"2. Letter Combinations of Phone Number",id:"2-letter-combinations-of-phone-number",level:3},{value:"3. Palindrome Partitioning",id:"3-palindrome-partitioning",level:3},{value:"Tree Path Backtracking",id:"tree-path-backtracking",level:2},{value:"1. Binary Tree Paths",id:"1-binary-tree-paths",level:3},{value:"2. Path Sum II",id:"2-path-sum-ii",level:3},{value:"Game Theory Backtracking",id:"game-theory-backtracking",level:2},{value:"1. Tic-Tac-Toe Winner",id:"1-tic-tac-toe-winner",level:3},{value:"Optimization Techniques",id:"optimization-techniques",level:2},{value:"1. Memoization",id:"1-memoization",level:3},{value:"2. Early Termination",id:"2-early-termination",level:3},{value:"3. Pruning Strategies",id:"3-pruning-strategies",level:3},{value:"Common Pitfalls &amp; Best Practices",id:"common-pitfalls--best-practices",level:2},{value:"\u274c Common Mistakes",id:"-common-mistakes",level:3},{value:"\u2705 Best Practices",id:"-best-practices",level:3},{value:"Time Complexity Analysis",id:"time-complexity-analysis",level:3},{value:"Memory Optimization Tips",id:"memory-optimization-tips",level:3},{value:"Advanced Patterns &amp; Techniques",id:"advanced-patterns--techniques",level:2},{value:"1. Multi-Dimensional Backtracking",id:"1-multi-dimensional-backtracking",level:3},{value:"2. Backtracking with State Compression",id:"2-backtracking-with-state-compression",level:3},{value:"3. Iterative Backtracking",id:"3-iterative-backtracking",level:3},{value:"4. Parallel Backtracking Concepts",id:"4-parallel-backtracking-concepts",level:3},{value:"Problem-Specific Optimizations",id:"problem-specific-optimizations",level:2},{value:"1. Constraint-Specific Pruning",id:"1-constraint-specific-pruning",level:3},{value:"2. Dynamic Constraint Updates",id:"2-dynamic-constraint-updates",level:3},{value:"Testing &amp; Debugging Backtracking",id:"testing--debugging-backtracking",level:2},{value:"1. Debug Visualization",id:"1-debug-visualization",level:3},{value:"2. Performance Monitoring",id:"2-performance-monitoring",level:3},{value:"Real-World Applications",id:"real-world-applications",level:2},{value:"1. Schedule Optimization",id:"1-schedule-optimization",level:3},{value:"2. Configuration Management",id:"2-configuration-management",level:3},{value:"Quick Reference",id:"quick-reference",level:2},{value:"Common Backtracking Patterns",id:"common-backtracking-patterns",level:3},{value:"Optimization Checklist",id:"optimization-checklist",level:3},{value:"Time Complexity Quick Reference",id:"time-complexity-quick-reference",level:3}];function u(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"backtracking",children:"Backtracking"})}),"\n",(0,r.jsx)(e.p,{children:"A comprehensive guide to backtracking algorithms and techniques for Data Structures and Algorithms."}),"\n",(0,r.jsx)(e.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#core-backtracking-concepts",children:"Core Backtracking Concepts"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#the-backtracking-template",children:"The Backtracking Template"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#subset-generation-patterns",children:"Subset Generation Patterns"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#permutation-patterns",children:"Permutation Patterns"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#combination-patterns",children:"Combination Patterns"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#constraint-satisfaction-problems",children:"Constraint Satisfaction Problems"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#gridmatrix-backtracking",children:"Grid/Matrix Backtracking"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#string-backtracking",children:"String Backtracking"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#tree-path-backtracking",children:"Tree Path Backtracking"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#game-theory-backtracking",children:"Game Theory Backtracking"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#optimization-techniques",children:"Optimization Techniques"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#common-pitfalls--best-practices",children:"Common Pitfalls & Best Practices"})}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"core-backtracking-concepts",children:"Core Backtracking Concepts"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Backtracking"}),' is a systematic way to explore all possible solutions by incrementally building candidates and abandoning ("backtracking") candidates that cannot lead to valid solutions.']}),"\n",(0,r.jsx)(e.h3,{id:"key-characteristics",children:"Key Characteristics:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Recursive"}),": Explores solutions recursively"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Incremental"}),": Builds solution step by step"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Pruning"}),": Abandons invalid paths early"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Complete Search"}),": Explores all possibilities (if needed)"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"when-to-use-backtracking",children:"When to Use Backtracking:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Finding all possible solutions"}),"\n",(0,r.jsx)(e.li,{children:"Finding one valid solution"}),"\n",(0,r.jsx)(e.li,{children:"Optimization problems with constraints"}),"\n",(0,r.jsx)(e.li,{children:"Combinatorial problems (subsets, permutations, combinations)"}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"the-backtracking-template",children:"The Backtracking Template"}),"\n",(0,r.jsx)(e.p,{children:"This is the fundamental template that applies to most backtracking problems:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function backtrack(state, choices, constraints) {\n    // Base case: valid solution found\n    if (isValidSolution(state)) {\n        recordSolution(state);\n        return;\n    }\n\n    // Try all possible choices\n    for (let choice of getValidChoices(choices, state)) {\n        // Make choice\n        state.push(choice);\n\n        // Recurse with updated state\n        if (isValid(state, constraints)) {\n            backtrack(state, getNewChoices(choices, choice), constraints);\n        }\n\n        // Backtrack: undo choice\n        state.pop();\n    }\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"generic-backtracking-framework",children:"Generic Backtracking Framework"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"class BacktrackSolver {\n    constructor() {\n        this.solutions = [];\n    }\n\n    solve(problem) {\n        this.solutions = [];\n        this.backtrack([], problem.choices, problem.constraints);\n        return this.solutions;\n    }\n\n    backtrack(currentSolution, availableChoices, constraints) {\n        // Base case\n        if (this.isComplete(currentSolution, constraints)) {\n            this.solutions.push([...currentSolution]);\n            return;\n        }\n\n        // Try each valid choice\n        for (let choice of this.getValidChoices(availableChoices, currentSolution, constraints)) {\n            // Make choice\n            currentSolution.push(choice);\n\n            // Recurse if still valid\n            if (this.isValidPartial(currentSolution, constraints)) {\n                this.backtrack(\n                    currentSolution,\n                    this.updateChoices(availableChoices, choice),\n                    constraints\n                );\n            }\n\n            // Backtrack\n            currentSolution.pop();\n        }\n    }\n\n    isComplete(solution, constraints) { /* Override */ }\n    isValidPartial(solution, constraints) { /* Override */ }\n    getValidChoices(choices, solution, constraints) { /* Override */ }\n    updateChoices(choices, selectedChoice) { /* Override */ }\n}\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"subset-generation-patterns",children:"Subset Generation Patterns"}),"\n",(0,r.jsx)(e.h3,{id:"1-all-subsets-power-set",children:"1. All Subsets (Power Set)"}),"\n",(0,r.jsx)(e.p,{children:"Generate all possible subsets of a given set."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function subsets(nums) {\n    const result = [];\n\n    function backtrack(start, currentSubset) {\n        // Every recursive call represents a valid subset\n        result.push([...currentSubset]);\n\n        // Try adding each remaining element\n        for (let i = start; i < nums.length; i++) {\n            currentSubset.push(nums[i]);\n            backtrack(i + 1, currentSubset);\n            currentSubset.pop(); // Backtrack\n        }\n    }\n\n    backtrack(0, []);\n    return result;\n}\n\n// Example: [1,2,3] \u2192 [[], [1], [2], [3], [1,2], [1,3], [2,3], [1,2,3]]\n"})}),"\n",(0,r.jsx)(e.h3,{id:"2-subsets-with-target-sum",children:"2. Subsets with Target Sum"}),"\n",(0,r.jsx)(e.p,{children:"Find all subsets that sum to a target value."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function subsetsWithTargetSum(nums, target) {\n    const result = [];\n\n    function backtrack(start, currentSubset, currentSum) {\n        if (currentSum === target) {\n            result.push([...currentSubset]);\n            return;\n        }\n\n        if (currentSum > target) return; // Pruning\n\n        for (let i = start; i < nums.length; i++) {\n            currentSubset.push(nums[i]);\n            backtrack(i + 1, currentSubset, currentSum + nums[i]);\n            currentSubset.pop();\n        }\n    }\n\n    backtrack(0, [], 0);\n    return result;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"3-subsets-with-duplicates",children:"3. Subsets with Duplicates"}),"\n",(0,r.jsx)(e.p,{children:"Handle arrays with duplicate elements."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function subsetsWithDup(nums) {\n    nums.sort(); // Important: sort to handle duplicates\n    const result = [];\n\n    function backtrack(start, currentSubset) {\n        result.push([...currentSubset]);\n\n        for (let i = start; i < nums.length; i++) {\n            // Skip duplicates: only use first occurrence at each level\n            if (i > start && nums[i] === nums[i - 1]) continue;\n\n            currentSubset.push(nums[i]);\n            backtrack(i + 1, currentSubset);\n            currentSubset.pop();\n        }\n    }\n\n    backtrack(0, []);\n    return result;\n}\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"permutation-patterns",children:"Permutation Patterns"}),"\n",(0,r.jsx)(e.h3,{id:"1-all-permutations",children:"1. All Permutations"}),"\n",(0,r.jsx)(e.p,{children:"Generate all possible arrangements of elements."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function permute(nums) {\n    const result = [];\n\n    function backtrack(currentPermutation, used) {\n        if (currentPermutation.length === nums.length) {\n            result.push([...currentPermutation]);\n            return;\n        }\n\n        for (let i = 0; i < nums.length; i++) {\n            if (used[i]) continue; // Skip used elements\n\n            // Make choice\n            currentPermutation.push(nums[i]);\n            used[i] = true;\n\n            backtrack(currentPermutation, used);\n\n            // Backtrack\n            currentPermutation.pop();\n            used[i] = false;\n        }\n    }\n\n    backtrack([], new Array(nums.length).fill(false));\n    return result;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"2-permutations-with-duplicates",children:"2. Permutations with Duplicates"}),"\n",(0,r.jsx)(e.p,{children:"Handle arrays with duplicate elements."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function permuteUnique(nums) {\n    nums.sort(); // Sort to group duplicates\n    const result = [];\n    const used = new Array(nums.length).fill(false);\n\n    function backtrack(currentPermutation) {\n        if (currentPermutation.length === nums.length) {\n            result.push([...currentPermutation]);\n            return;\n        }\n\n        for (let i = 0; i < nums.length; i++) {\n            if (used[i]) continue;\n\n            // Skip duplicates: use duplicate only if previous same element is used\n            if (i > 0 && nums[i] === nums[i - 1] && !used[i - 1]) {\n                continue;\n            }\n\n            currentPermutation.push(nums[i]);\n            used[i] = true;\n\n            backtrack(currentPermutation);\n\n            currentPermutation.pop();\n            used[i] = false;\n        }\n    }\n\n    backtrack([]);\n    return result;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"3-next-permutation",children:"3. Next Permutation"}),"\n",(0,r.jsx)(e.p,{children:"Find lexicographically next permutation."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function nextPermutation(nums) {\n    // Step 1: Find the largest index i such that nums[i] < nums[i + 1]\n    let i = nums.length - 2;\n    while (i >= 0 && nums[i] >= nums[i + 1]) {\n        i--;\n    }\n\n    if (i >= 0) {\n        // Step 2: Find the largest index j such that nums[i] < nums[j]\n        let j = nums.length - 1;\n        while (nums[j] <= nums[i]) {\n            j--;\n        }\n        // Step 3: Swap nums[i] and nums[j]\n        [nums[i], nums[j]] = [nums[j], nums[i]];\n    }\n\n    // Step 4: Reverse the suffix starting at nums[i + 1]\n    reverse(nums, i + 1);\n\n    function reverse(arr, start) {\n        let left = start, right = arr.length - 1;\n        while (left < right) {\n            [arr[left], arr[right]] = [arr[right], arr[left]];\n            left++;\n            right--;\n        }\n    }\n}\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"combination-patterns",children:"Combination Patterns"}),"\n",(0,r.jsx)(e.h3,{id:"1-combinations-of-size-k",children:"1. Combinations of Size K"}),"\n",(0,r.jsx)(e.p,{children:"Generate all combinations of k elements."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function combine(n, k) {\n    const result = [];\n\n    function backtrack(start, currentCombination) {\n        if (currentCombination.length === k) {\n            result.push([...currentCombination]);\n            return;\n        }\n\n        // Optimization: only continue if we have enough elements left\n        for (let i = start; i <= n - (k - currentCombination.length) + 1; i++) {\n            currentCombination.push(i);\n            backtrack(i + 1, currentCombination);\n            currentCombination.pop();\n        }\n    }\n\n    backtrack(1, []);\n    return result;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"2-combination-sum",children:"2. Combination Sum"}),"\n",(0,r.jsx)(e.p,{children:"Find combinations that sum to target (elements can be reused)."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function combinationSum(candidates, target) {\n    const result = [];\n\n    function backtrack(start, currentCombination, currentSum) {\n        if (currentSum === target) {\n            result.push([...currentCombination]);\n            return;\n        }\n\n        if (currentSum > target) return; // Pruning\n\n        for (let i = start; i < candidates.length; i++) {\n            currentCombination.push(candidates[i]);\n            // Note: i (not i+1) because we can reuse the same element\n            backtrack(i, currentCombination, currentSum + candidates[i]);\n            currentCombination.pop();\n        }\n    }\n\n    backtrack(0, [], 0);\n    return result;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"3-combination-sum-ii",children:"3. Combination Sum II"}),"\n",(0,r.jsx)(e.p,{children:"Each element can only be used once, handle duplicates."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function combinationSum2(candidates, target) {\n    candidates.sort();\n    const result = [];\n\n    function backtrack(start, currentCombination, currentSum) {\n        if (currentSum === target) {\n            result.push([...currentCombination]);\n            return;\n        }\n\n        for (let i = start; i < candidates.length; i++) {\n            if (currentSum + candidates[i] > target) break; // Pruning\n\n            // Skip duplicates\n            if (i > start && candidates[i] === candidates[i - 1]) continue;\n\n            currentCombination.push(candidates[i]);\n            backtrack(i + 1, currentCombination, currentSum + candidates[i]);\n            currentCombination.pop();\n        }\n    }\n\n    backtrack(0, [], 0);\n    return result;\n}\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"constraint-satisfaction-problems",children:"Constraint Satisfaction Problems"}),"\n",(0,r.jsx)(e.h3,{id:"1-n-queens-problem",children:"1. N-Queens Problem"}),"\n",(0,r.jsx)(e.p,{children:"Place N queens on N\xd7N chessboard so none attack each other."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function solveNQueens(n) {\n    const result = [];\n    const board = Array(n).fill().map(() => Array(n).fill('.'));\n\n    function backtrack(row) {\n        if (row === n) {\n            result.push(board.map(row => row.join('')));\n            return;\n        }\n\n        for (let col = 0; col < n; col++) {\n            if (isValid(row, col)) {\n                board[row][col] = 'Q';\n                backtrack(row + 1);\n                board[row][col] = '.';\n            }\n        }\n    }\n\n    function isValid(row, col) {\n        // Check column\n        for (let i = 0; i < row; i++) {\n            if (board[i][col] === 'Q') return false;\n        }\n\n        // Check diagonal (top-left to bottom-right)\n        for (let i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\n            if (board[i][j] === 'Q') return false;\n        }\n\n        // Check diagonal (top-right to bottom-left)\n        for (let i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {\n            if (board[i][j] === 'Q') return false;\n        }\n\n        return true;\n    }\n\n    backtrack(0);\n    return result;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"2-sudoku-solver",children:"2. Sudoku Solver"}),"\n",(0,r.jsx)(e.p,{children:"Solve 9\xd79 Sudoku puzzle."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function solveSudoku(board) {\n    function backtrack() {\n        for (let row = 0; row < 9; row++) {\n            for (let col = 0; col < 9; col++) {\n                if (board[row][col] === '.') {\n                    for (let num = '1'; num <= '9'; num++) {\n                        if (isValid(board, row, col, num)) {\n                            board[row][col] = num;\n\n                            if (backtrack()) return true;\n\n                            board[row][col] = '.'; // Backtrack\n                        }\n                    }\n                    return false; // No valid number found\n                }\n            }\n        }\n        return true; // All cells filled\n    }\n\n    function isValid(board, row, col, num) {\n        // Check row\n        for (let j = 0; j < 9; j++) {\n            if (board[row][j] === num) return false;\n        }\n\n        // Check column\n        for (let i = 0; i < 9; i++) {\n            if (board[i][col] === num) return false;\n        }\n\n        // Check 3\xd73 box\n        const boxRow = Math.floor(row / 3) * 3;\n        const boxCol = Math.floor(col / 3) * 3;\n        for (let i = boxRow; i < boxRow + 3; i++) {\n            for (let j = boxCol; j < boxCol + 3; j++) {\n                if (board[i][j] === num) return false;\n            }\n        }\n\n        return true;\n    }\n\n    backtrack();\n}\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"gridmatrix-backtracking",children:"Grid/Matrix Backtracking"}),"\n",(0,r.jsx)(e.h3,{id:"1-word-search",children:"1. Word Search"}),"\n",(0,r.jsx)(e.p,{children:"Find if word exists in 2D grid."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function exist(board, word) {\n    const m = board.length;\n    const n = board[0].length;\n\n    function backtrack(row, col, index) {\n        if (index === word.length) return true;\n\n        if (row < 0 || row >= m || col < 0 || col >= n ||\n            board[row][col] !== word[index]) {\n            return false;\n        }\n\n        // Mark as visited\n        const temp = board[row][col];\n        board[row][col] = '#';\n\n        // Explore all 4 directions\n        const found = backtrack(row + 1, col, index + 1) ||\n                     backtrack(row - 1, col, index + 1) ||\n                     backtrack(row, col + 1, index + 1) ||\n                     backtrack(row, col - 1, index + 1);\n\n        // Backtrack: restore original value\n        board[row][col] = temp;\n\n        return found;\n    }\n\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (backtrack(i, j, 0)) return true;\n        }\n    }\n\n    return false;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"2-number-of-islands",children:"2. Number of Islands"}),"\n",(0,r.jsx)(e.p,{children:"Count connected components in grid."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function numIslands(grid) {\n    if (!grid || grid.length === 0) return 0;\n\n    const m = grid.length;\n    const n = grid[0].length;\n    let count = 0;\n\n    function dfs(i, j) {\n        if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] !== '1') {\n            return;\n        }\n\n        grid[i][j] = '0'; // Mark as visited\n\n        // Explore all 4 directions\n        dfs(i + 1, j);\n        dfs(i - 1, j);\n        dfs(i, j + 1);\n        dfs(i, j - 1);\n    }\n\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (grid[i][j] === '1') {\n                count++;\n                dfs(i, j);\n            }\n        }\n    }\n\n    return count;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"3-rat-in-maze",children:"3. Rat in Maze"}),"\n",(0,r.jsx)(e.p,{children:"Find path from source to destination."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function ratInMaze(maze) {\n    const n = maze.length;\n    const solution = Array(n).fill().map(() => Array(n).fill(0));\n\n    function isSafe(x, y) {\n        return x >= 0 && x < n && y >= 0 && y < n && maze[x][y] === 1;\n    }\n\n    function backtrack(x, y) {\n        // Base case: reached destination\n        if (x === n - 1 && y === n - 1 && maze[x][y] === 1) {\n            solution[x][y] = 1;\n            return true;\n        }\n\n        if (isSafe(x, y)) {\n            solution[x][y] = 1;\n\n            // Move right\n            if (backtrack(x, y + 1)) return true;\n\n            // Move down\n            if (backtrack(x + 1, y)) return true;\n\n            // Backtrack\n            solution[x][y] = 0;\n        }\n\n        return false;\n    }\n\n    if (backtrack(0, 0)) {\n        return solution;\n    }\n\n    return null; // No solution\n}\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"string-backtracking",children:"String Backtracking"}),"\n",(0,r.jsx)(e.h3,{id:"1-generate-parentheses",children:"1. Generate Parentheses"}),"\n",(0,r.jsx)(e.p,{children:"Generate all valid parentheses combinations."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function generateParenthesis(n) {\n    const result = [];\n\n    function backtrack(current, open, close) {\n        if (current.length === 2 * n) {\n            result.push(current);\n            return;\n        }\n\n        // Add opening parenthesis if we haven't used all\n        if (open < n) {\n            backtrack(current + '(', open + 1, close);\n        }\n\n        // Add closing parenthesis if it won't make invalid combination\n        if (close < open) {\n            backtrack(current + ')', open, close + 1);\n        }\n    }\n\n    backtrack('', 0, 0);\n    return result;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"2-letter-combinations-of-phone-number",children:"2. Letter Combinations of Phone Number"}),"\n",(0,r.jsx)(e.p,{children:"Map phone digits to letters."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function letterCombinations(digits) {\n    if (!digits) return [];\n\n    const digitMap = {\n        '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl',\n        '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'\n    };\n\n    const result = [];\n\n    function backtrack(index, current) {\n        if (index === digits.length) {\n            result.push(current);\n            return;\n        }\n\n        const letters = digitMap[digits[index]];\n        for (let letter of letters) {\n            backtrack(index + 1, current + letter);\n        }\n    }\n\n    backtrack(0, '');\n    return result;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"3-palindrome-partitioning",children:"3. Palindrome Partitioning"}),"\n",(0,r.jsx)(e.p,{children:"Partition string into palindromic substrings."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function partition(s) {\n    const result = [];\n\n    function isPalindrome(str, left, right) {\n        while (left < right) {\n            if (str[left] !== str[right]) return false;\n            left++;\n            right--;\n        }\n        return true;\n    }\n\n    function backtrack(start, currentPartition) {\n        if (start === s.length) {\n            result.push([...currentPartition]);\n            return;\n        }\n\n        for (let end = start; end < s.length; end++) {\n            if (isPalindrome(s, start, end)) {\n                currentPartition.push(s.substring(start, end + 1));\n                backtrack(end + 1, currentPartition);\n                currentPartition.pop();\n            }\n        }\n    }\n\n    backtrack(0, []);\n    return result;\n}\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"tree-path-backtracking",children:"Tree Path Backtracking"}),"\n",(0,r.jsx)(e.h3,{id:"1-binary-tree-paths",children:"1. Binary Tree Paths"}),"\n",(0,r.jsx)(e.p,{children:"Find all root-to-leaf paths."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function binaryTreePaths(root) {\n    const result = [];\n\n    function backtrack(node, currentPath) {\n        if (!node) return;\n\n        currentPath.push(node.val);\n\n        // If leaf node, add path to result\n        if (!node.left && !node.right) {\n            result.push(currentPath.join('->'));\n        } else {\n            backtrack(node.left, currentPath);\n            backtrack(node.right, currentPath);\n        }\n\n        currentPath.pop(); // Backtrack\n    }\n\n    backtrack(root, []);\n    return result;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"2-path-sum-ii",children:"2. Path Sum II"}),"\n",(0,r.jsx)(e.p,{children:"Find all paths with given sum."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function pathSum(root, targetSum) {\n    const result = [];\n\n    function backtrack(node, currentPath, currentSum) {\n        if (!node) return;\n\n        currentPath.push(node.val);\n        currentSum += node.val;\n\n        // If leaf and sum matches target\n        if (!node.left && !node.right && currentSum === targetSum) {\n            result.push([...currentPath]);\n        } else {\n            backtrack(node.left, currentPath, currentSum);\n            backtrack(node.right, currentPath, currentSum);\n        }\n\n        currentPath.pop(); // Backtrack\n    }\n\n    backtrack(root, [], 0);\n    return result;\n}\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"game-theory-backtracking",children:"Game Theory Backtracking"}),"\n",(0,r.jsx)(e.h3,{id:"1-tic-tac-toe-winner",children:"1. Tic-Tac-Toe Winner"}),"\n",(0,r.jsx)(e.p,{children:"Check if current player can win."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function canWin(board) {\n    function getValidMoves() {\n        const moves = [];\n        for (let i = 0; i < board.length; i++) {\n            if (board[i] === ' ') moves.push(i);\n        }\n        return moves;\n    }\n\n    function isWinning(board) {\n        const lines = [\n            [0,1,2], [3,4,5], [6,7,8], // rows\n            [0,3,6], [1,4,7], [2,5,8], // columns\n            [0,4,8], [2,4,6]           // diagonals\n        ];\n\n        for (let [a,b,c] of lines) {\n            if (board[a] === board[b] && board[b] === board[c] && board[a] !== ' ') {\n                return board[a];\n            }\n        }\n        return null;\n    }\n\n    function backtrack(isMaxPlayer) {\n        const winner = isWinning(board);\n        if (winner === 'X') return 1;   // Max player wins\n        if (winner === 'O') return -1;  // Min player wins\n\n        const validMoves = getValidMoves();\n        if (validMoves.length === 0) return 0; // Draw\n\n        if (isMaxPlayer) {\n            let maxScore = -Infinity;\n            for (let move of validMoves) {\n                board[move] = 'X';\n                const score = backtrack(false);\n                board[move] = ' ';\n                maxScore = Math.max(maxScore, score);\n            }\n            return maxScore;\n        } else {\n            let minScore = Infinity;\n            for (let move of validMoves) {\n                board[move] = 'O';\n                const score = backtrack(true);\n                board[move] = ' ';\n                minScore = Math.min(minScore, score);\n            }\n            return minScore;\n        }\n    }\n\n    return backtrack(true) > 0;\n}\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"optimization-techniques",children:"Optimization Techniques"}),"\n",(0,r.jsx)(e.h3,{id:"1-memoization",children:"1. Memoization"}),"\n",(0,r.jsx)(e.p,{children:"Cache results to avoid recomputation."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function uniquePathsWithMemo(m, n, obstacles) {\n    const memo = new Map();\n\n    function backtrack(row, col) {\n        if (row >= m || col >= n || obstacles[row][col] === 1) {\n            return 0;\n        }\n\n        if (row === m - 1 && col === n - 1) {\n            return 1;\n        }\n\n        const key = `${row},${col}`;\n        if (memo.has(key)) {\n            return memo.get(key);\n        }\n\n        const paths = backtrack(row + 1, col) + backtrack(row, col + 1);\n        memo.set(key, paths);\n\n        return paths;\n    }\n\n    return backtrack(0, 0);\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"2-early-termination",children:"2. Early Termination"}),"\n",(0,r.jsx)(e.p,{children:"Stop search when optimal solution found."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function findFirstSolution(candidates, target) {\n    function backtrack(start, current, sum) {\n        if (sum === target) {\n            return [...current]; // Return first valid solution\n        }\n\n        if (sum > target) return null;\n\n        for (let i = start; i < candidates.length; i++) {\n            current.push(candidates[i]);\n\n            const result = backtrack(i + 1, current, sum + candidates[i]);\n            if (result) return result; // Early termination\n\n            current.pop();\n        }\n\n        return null;\n    }\n\n    return backtrack(0, [], 0);\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"3-pruning-strategies",children:"3. Pruning Strategies"}),"\n",(0,r.jsx)(e.p,{children:"Eliminate invalid branches early."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function combinationSumOptimized(candidates, target) {\n    candidates.sort(); // Sort for pruning\n    const result = [];\n\n    function backtrack(start, current, sum) {\n        if (sum === target) {\n            result.push([...current]);\n            return;\n        }\n\n        for (let i = start; i < candidates.length; i++) {\n            // Pruning: if current candidate exceeds target, break\n            if (sum + candidates[i] > target) break;\n\n            current.push(candidates[i]);\n            backtrack(i, current, sum + candidates[i]);\n            current.pop();\n        }\n    }\n\n    backtrack(0, [], 0);\n    return result;\n}\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"common-pitfalls--best-practices",children:"Common Pitfalls & Best Practices"}),"\n",(0,r.jsx)(e.h3,{id:"-common-mistakes",children:"\u274c Common Mistakes"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"Forgetting to Backtrack"})}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"// Wrong: Missing backtrack\nfunction wrong(nums) {\n    const result = [];\n    const current = [];\n\n    function dfs(index) {\n        if (index === nums.length) {\n            result.push(current); // BUG: Reference to same array\n            return;\n        }\n\n        current.push(nums[index]);\n        dfs(index + 1);\n        // Missing: current.pop();\n    }\n}\n\n// Correct: Proper backtracking\nfunction correct(nums) {\n    const result = [];\n    const current = [];\n\n    function dfs(index) {\n        if (index === nums.length) {\n            result.push([...current]); // Create copy\n            return;\n        }\n\n        current.push(nums[index]);\n        dfs(index + 1);\n        current.pop(); // Backtrack\n    }\n}\n"})}),"\n",(0,r.jsxs)(e.ol,{start:"2",children:["\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"Infinite Recursion"})}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"// Wrong: No base case or improper progression\nfunction infiniteRecursion(nums) {\n    function backtrack(current) {\n        // Missing base case\n        for (let num of nums) {\n            current.push(num);\n            backtrack(current); // Same state, infinite loop\n            current.pop();\n        }\n    }\n}\n"})}),"\n",(0,r.jsxs)(e.ol,{start:"3",children:["\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"Not Handling Duplicates Properly"})}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"// Wrong: Doesn't skip duplicates\nfunction wrongDuplicates(nums) {\n    const result = [];\n\n    function backtrack(start, current) {\n        result.push([...current]);\n\n        for (let i = start; i < nums.length; i++) {\n            current.push(nums[i]);\n            backtrack(i + 1, current);\n            current.pop();\n        }\n    }\n\n    backtrack(0, []);\n    return result; // Will have duplicates\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"-best-practices",children:"\u2705 Best Practices"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"Always Make Copies When Storing Results"})}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"result.push([...currentSolution]); // Good\nresult.push(currentSolution);       // Bad - stores reference\n"})}),"\n",(0,r.jsxs)(e.ol,{start:"2",children:["\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"Use Early Pruning"})}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"if (currentSum > target) return; // Stop early if invalid\n"})}),"\n",(0,r.jsxs)(e.ol,{start:"3",children:["\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"Sort Arrays When Dealing with Duplicates"})}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"nums.sort(); // Helps group duplicates together\n"})}),"\n",(0,r.jsxs)(e.ol,{start:"4",children:["\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"Use Clear Variable Names"})}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function backtrack(startIndex, currentCombination, remainingSum) {\n    // Clear parameter names make code readable\n}\n"})}),"\n",(0,r.jsxs)(e.ol,{start:"5",children:["\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"Add Comments for Complex Logic"})}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"// Skip duplicates: only use first occurrence at each level\nif (i > start && nums[i] === nums[i - 1]) continue;\n"})}),"\n",(0,r.jsx)(e.h3,{id:"time-complexity-analysis",children:"Time Complexity Analysis"}),"\n",(0,r.jsxs)(e.table,{children:[(0,r.jsx)(e.thead,{children:(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.th,{children:"Problem Type"}),(0,r.jsx)(e.th,{children:"Time Complexity"}),(0,r.jsx)(e.th,{children:"Space Complexity"})]})}),(0,r.jsxs)(e.tbody,{children:[(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"All Subsets"}),(0,r.jsx)(e.td,{children:"O(2^n)"}),(0,r.jsx)(e.td,{children:"O(n)"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"All Permutations"}),(0,r.jsx)(e.td,{children:"O(n! \xd7 n)"}),(0,r.jsx)(e.td,{children:"O(n)"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Combinations"}),(0,r.jsx)(e.td,{children:"O(C(n,k))"}),(0,r.jsx)(e.td,{children:"O(k)"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"N-Queens"}),(0,r.jsx)(e.td,{children:"O(N!)"}),(0,r.jsx)(e.td,{children:"O(N)"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Sudoku"}),(0,r.jsx)(e.td,{children:"O(9^(n\xd7n))"}),(0,r.jsx)(e.td,{children:"O(n\xd7n)"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Word Search"}),(0,r.jsx)(e.td,{children:"O(4^L) where L is word length"}),(0,r.jsx)(e.td,{children:"O(L)"})]})]})]}),"\n",(0,r.jsx)(e.h3,{id:"memory-optimization-tips",children:"Memory Optimization Tips"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"Reuse Data Structures"})}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"const used = new Array(nums.length).fill(false);\n// Reuse same boolean array instead of creating new ones\n"})}),"\n",(0,r.jsxs)(e.ol,{start:"2",children:["\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"Use Bit Manipulation for States"})}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function backtrackWithBitmask(nums) {\n    function dfs(mask, current) {\n        if (mask === (1 << nums.length) - 1) {\n            // All elements used\n            return [...current];\n        }\n\n        for (let i = 0; i < nums.length; i++) {\n            if (mask & (1 << i)) continue; // Already used\n\n            current.push(nums[i]);\n            const result = dfs(mask | (1 << i), current);\n            if (result) return result;\n            current.pop();\n        }\n    }\n\n    return dfs(0, []);\n}\n"})}),"\n",(0,r.jsxs)(e.ol,{start:"3",children:["\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"In-Place Modifications"})}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function wordSearchOptimized(board, word) {\n    function dfs(i, j, k) {\n        if (k === word.length) return true;\n        if (i < 0 || i >= board.length || j < 0 || j >= board[0].length) return false;\n        if (board[i][j] !== word[k]) return false;\n\n        // In-place modification instead of separate visited array\n        const temp = board[i][j];\n        board[i][j] = '#';\n\n        const found = dfs(i+1,j,k+1) || dfs(i-1,j,k+1) || dfs(i,j+1,k+1) || dfs(i,j-1,k+1);\n\n        board[i][j] = temp; // Restore\n        return found;\n    }\n}\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"advanced-patterns--techniques",children:"Advanced Patterns & Techniques"}),"\n",(0,r.jsx)(e.h3,{id:"1-multi-dimensional-backtracking",children:"1. Multi-Dimensional Backtracking"}),"\n",(0,r.jsx)(e.p,{children:"Solve problems with multiple constraints simultaneously."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function wordBreakII(s, wordDict) {\n    const wordSet = new Set(wordDict);\n    const result = [];\n\n    function backtrack(start, currentSentence) {\n        if (start === s.length) {\n            result.push(currentSentence.join(' '));\n            return;\n        }\n\n        for (let end = start + 1; end <= s.length; end++) {\n            const word = s.slice(start, end);\n            if (wordSet.has(word)) {\n                currentSentence.push(word);\n                backtrack(end, currentSentence);\n                currentSentence.pop();\n            }\n        }\n    }\n\n    backtrack(0, []);\n    return result;\n}\n\n// Expression Add Operators\nfunction addOperators(num, target) {\n    const result = [];\n\n    function backtrack(index, expression, value, prev) {\n        if (index === num.length) {\n            if (value === target) {\n                result.push(expression);\n            }\n            return;\n        }\n\n        for (let i = index; i < num.length; i++) {\n            const currentStr = num.slice(index, i + 1);\n            const currentNum = parseInt(currentStr);\n\n            // Skip numbers with leading zeros (except single digit)\n            if (currentStr.length > 1 && currentStr[0] === '0') break;\n\n            if (index === 0) {\n                // First number\n                backtrack(i + 1, currentStr, currentNum, currentNum);\n            } else {\n                // Try addition\n                backtrack(i + 1, expression + '+' + currentStr, value + currentNum, currentNum);\n\n                // Try subtraction\n                backtrack(i + 1, expression + '-' + currentStr, value - currentNum, -currentNum);\n\n                // Try multiplication\n                backtrack(i + 1, expression + '*' + currentStr,\n                         value - prev + prev * currentNum, prev * currentNum);\n            }\n        }\n    }\n\n    backtrack(0, '', 0, 0);\n    return result;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"2-backtracking-with-state-compression",children:"2. Backtracking with State Compression"}),"\n",(0,r.jsx)(e.p,{children:"Use efficient state representation for complex problems."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function shortestPathVisitingAllNodes(graph) {\n    const n = graph.length;\n    const queue = [];\n    const visited = new Set();\n\n    // Initialize: start from each node\n    for (let i = 0; i < n; i++) {\n        const state = 1 << i; // Visited only node i\n        queue.push([i, state, 0]); // [node, visitedMask, distance]\n        visited.add(`${i},${state}`);\n    }\n\n    const targetMask = (1 << n) - 1; // All nodes visited\n\n    while (queue.length > 0) {\n        const [node, visitedMask, dist] = queue.shift();\n\n        if (visitedMask === targetMask) {\n            return dist;\n        }\n\n        for (let neighbor of graph[node]) {\n            const newMask = visitedMask | (1 << neighbor);\n            const stateKey = `${neighbor},${newMask}`;\n\n            if (!visited.has(stateKey)) {\n                visited.add(stateKey);\n                queue.push([neighbor, newMask, dist + 1]);\n            }\n        }\n    }\n\n    return -1;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"3-iterative-backtracking",children:"3. Iterative Backtracking"}),"\n",(0,r.jsx)(e.p,{children:"Convert recursive solutions to iterative for better space complexity."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function permutationsIterative(nums) {\n    const result = [];\n    const stack = [{ permutation: [], used: new Array(nums.length).fill(false) }];\n\n    while (stack.length > 0) {\n        const { permutation, used } = stack.pop();\n\n        if (permutation.length === nums.length) {\n            result.push([...permutation]);\n            continue;\n        }\n\n        for (let i = 0; i < nums.length; i++) {\n            if (used[i]) continue;\n\n            const newPermutation = [...permutation, nums[i]];\n            const newUsed = [...used];\n            newUsed[i] = true;\n\n            stack.push({ permutation: newPermutation, used: newUsed });\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"4-parallel-backtracking-concepts",children:"4. Parallel Backtracking Concepts"}),"\n",(0,r.jsx)(e.p,{children:"Understanding how backtracking can be parallelized."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function parallelSubsets(nums) {\n    // Conceptual: In practice, use Web Workers or similar\n    const workers = [];\n    const results = [];\n\n    // Divide work among workers based on first choice\n    for (let i = 0; i < nums.length; i++) {\n        workers.push({\n            startsWith: nums[i],\n            remainingNums: nums.slice(i + 1),\n            task: 'generateSubsetsStartingWith'\n        });\n    }\n\n    // Each worker processes subsets starting with specific element\n    function generateSubsetsStartingWith(startElement, remaining) {\n        const localResults = [[]]; // Empty subset\n\n        function backtrack(start, current) {\n            localResults.push([...current]);\n\n            for (let j = start; j < remaining.length; j++) {\n                current.push(remaining[j]);\n                backtrack(j + 1, current);\n                current.pop();\n            }\n        }\n\n        // Generate subsets starting with startElement\n        backtrack(0, [startElement]);\n        return localResults;\n    }\n\n    return results.flat();\n}\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"problem-specific-optimizations",children:"Problem-Specific Optimizations"}),"\n",(0,r.jsx)(e.h3,{id:"1-constraint-specific-pruning",children:"1. Constraint-Specific Pruning"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function combinationSumWithConstraints(candidates, target, maxCount) {\n    candidates.sort();\n    const result = [];\n\n    function backtrack(start, current, sum, count) {\n        if (sum === target && count <= maxCount) {\n            result.push([...current]);\n            return;\n        }\n\n        // Pruning conditions\n        if (sum > target || count > maxCount) return;\n\n        for (let i = start; i < candidates.length; i++) {\n            // Skip if remaining candidates can't reach target\n            if (sum + candidates[i] * (maxCount - count) < target) continue;\n\n            // Skip if single candidate exceeds remaining target\n            if (sum + candidates[i] > target) break;\n\n            current.push(candidates[i]);\n            backtrack(i, current, sum + candidates[i], count + 1);\n            current.pop();\n        }\n    }\n\n    backtrack(0, [], 0, 0);\n    return result;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"2-dynamic-constraint-updates",children:"2. Dynamic Constraint Updates"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function solveConstraintSatisfaction(variables, domains, constraints) {\n    function backtrack(assignment) {\n        if (Object.keys(assignment).length === variables.length) {\n            return assignment; // Solution found\n        }\n\n        const unassigned = variables.filter(v => !(v in assignment));\n        const variable = selectUnassignedVariable(unassigned, assignment);\n\n        for (let value of orderDomainValues(variable, assignment)) {\n            if (isConsistent(variable, value, assignment)) {\n                assignment[variable] = value;\n\n                // Update constraints dynamically\n                const inferences = inferenceStep(variable, value, assignment);\n                if (inferences !== null) {\n                    Object.assign(assignment, inferences);\n\n                    const result = backtrack(assignment);\n                    if (result) return result;\n\n                    // Remove inferences on backtrack\n                    for (let key of Object.keys(inferences)) {\n                        delete assignment[key];\n                    }\n                }\n\n                delete assignment[variable];\n            }\n        }\n\n        return null;\n    }\n\n    function selectUnassignedVariable(unassigned, assignment) {\n        // Most constrained variable heuristic\n        return unassigned.reduce((best, variable) => {\n            const currentDomain = getDomainSize(variable, assignment);\n            const bestDomain = getDomainSize(best, assignment);\n            return currentDomain < bestDomain ? variable : best;\n        });\n    }\n\n    function orderDomainValues(variable, assignment) {\n        // Least constraining value heuristic\n        return domains[variable].sort((a, b) => {\n            const aConstraints = countConstraints(variable, a, assignment);\n            const bConstraints = countConstraints(variable, b, assignment);\n            return aConstraints - bConstraints;\n        });\n    }\n\n    return backtrack({});\n}\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"testing--debugging-backtracking",children:"Testing & Debugging Backtracking"}),"\n",(0,r.jsx)(e.h3,{id:"1-debug-visualization",children:"1. Debug Visualization"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function debugBacktrack(nums) {\n    const result = [];\n    let callCount = 0;\n    let maxDepth = 0;\n\n    function backtrack(current, depth = 0) {\n        callCount++;\n        maxDepth = Math.max(maxDepth, depth);\n\n        console.log(`${'  '.repeat(depth)}Depth ${depth}: ${JSON.stringify(current)}`);\n\n        if (current.length === nums.length) {\n            console.log(`${'  '.repeat(depth)}\u2713 Solution found: ${JSON.stringify(current)}`);\n            result.push([...current]);\n            return;\n        }\n\n        for (let num of nums) {\n            if (current.includes(num)) continue;\n\n            console.log(`${'  '.repeat(depth)}\u2192 Trying: ${num}`);\n            current.push(num);\n            backtrack(current, depth + 1);\n            current.pop();\n            console.log(`${'  '.repeat(depth)}\u2190 Backtrack from: ${num}`);\n        }\n    }\n\n    backtrack([]);\n    console.log(`\\nTotal calls: ${callCount}, Max depth: ${maxDepth}`);\n    return result;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"2-performance-monitoring",children:"2. Performance Monitoring"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"class BacktrackProfiler {\n    constructor() {\n        this.stats = {\n            totalCalls: 0,\n            solutionsFound: 0,\n            pruningCount: 0,\n            maxDepth: 0,\n            startTime: null\n        };\n    }\n\n    start() {\n        this.stats.startTime = Date.now();\n    }\n\n    recordCall(depth) {\n        this.stats.totalCalls++;\n        this.stats.maxDepth = Math.max(this.stats.maxDepth, depth);\n    }\n\n    recordSolution() {\n        this.stats.solutionsFound++;\n    }\n\n    recordPruning() {\n        this.stats.pruningCount++;\n    }\n\n    getReport() {\n        const duration = Date.now() - this.stats.startTime;\n        return {\n            ...this.stats,\n            duration: `${duration}ms`,\n            callsPerMs: (this.stats.totalCalls / duration).toFixed(2),\n            pruningEfficiency: (this.stats.pruningCount / this.stats.totalCalls * 100).toFixed(1) + '%'\n        };\n    }\n}\n\n// Usage example\nfunction profiledBacktrack(nums) {\n    const profiler = new BacktrackProfiler();\n    const result = [];\n\n    profiler.start();\n\n    function backtrack(current, depth = 0) {\n        profiler.recordCall(depth);\n\n        if (current.length === nums.length) {\n            profiler.recordSolution();\n            result.push([...current]);\n            return;\n        }\n\n        for (let num of nums) {\n            if (current.includes(num)) {\n                profiler.recordPruning();\n                continue;\n            }\n\n            current.push(num);\n            backtrack(current, depth + 1);\n            current.pop();\n        }\n    }\n\n    backtrack([]);\n\n    console.log('Performance Report:', profiler.getReport());\n    return result;\n}\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"real-world-applications",children:"Real-World Applications"}),"\n",(0,r.jsx)(e.h3,{id:"1-schedule-optimization",children:"1. Schedule Optimization"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function scheduleOptimization(tasks, resources, constraints) {\n    const schedule = new Map();\n\n    function backtrack(taskIndex) {\n        if (taskIndex === tasks.length) {\n            return validateSchedule(schedule);\n        }\n\n        const task = tasks[taskIndex];\n\n        for (let resource of resources) {\n            for (let timeSlot of getAvailableSlots(resource, task.duration)) {\n                if (satisfiesConstraints(task, resource, timeSlot, constraints)) {\n                    schedule.set(task.id, { resource, timeSlot });\n\n                    if (backtrack(taskIndex + 1)) {\n                        return true;\n                    }\n\n                    schedule.delete(task.id);\n                }\n            }\n        }\n\n        return false;\n    }\n\n    return backtrack(0) ? schedule : null;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"2-configuration-management",children:"2. Configuration Management"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function generateConfigurations(components, dependencies, requirements) {\n    const validConfigs = [];\n\n    function backtrack(configIndex, currentConfig) {\n        if (configIndex === components.length) {\n            if (meetsAllRequirements(currentConfig, requirements)) {\n                validConfigs.push({ ...currentConfig });\n            }\n            return;\n        }\n\n        const component = components[configIndex];\n\n        for (let option of component.options) {\n            if (isCompatible(option, currentConfig, dependencies)) {\n                currentConfig[component.name] = option;\n                backtrack(configIndex + 1, currentConfig);\n                delete currentConfig[component.name];\n            }\n        }\n    }\n\n    backtrack(0, {});\n    return validConfigs;\n}\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"quick-reference",children:"Quick Reference"}),"\n",(0,r.jsx)(e.h3,{id:"common-backtracking-patterns",children:"Common Backtracking Patterns"}),"\n",(0,r.jsxs)(e.table,{children:[(0,r.jsx)(e.thead,{children:(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.th,{children:"Pattern"}),(0,r.jsx)(e.th,{children:"Template"}),(0,r.jsx)(e.th,{children:"Use Case"})]})}),(0,r.jsxs)(e.tbody,{children:[(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Subsets"})}),(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"for i in start..n"})}),(0,r.jsx)(e.td,{children:"Generate all subsets"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Permutations"})}),(0,r.jsxs)(e.td,{children:[(0,r.jsx)(e.code,{children:"for i in 0..n"})," with ",(0,r.jsx)(e.code,{children:"used[]"})]}),(0,r.jsx)(e.td,{children:"All arrangements"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Combinations"})}),(0,r.jsxs)(e.td,{children:[(0,r.jsx)(e.code,{children:"for i in start..n"})," with size limit"]}),(0,r.jsx)(e.td,{children:"Fixed-size selections"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Constraints"})}),(0,r.jsx)(e.td,{children:"Early termination on invalid"}),(0,r.jsx)(e.td,{children:"Sudoku, N-Queens"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Paths"})}),(0,r.jsx)(e.td,{children:"DFS with visited tracking"}),(0,r.jsx)(e.td,{children:"Tree/Graph paths"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Partitioning"})}),(0,r.jsx)(e.td,{children:"Try all valid cuts"}),(0,r.jsx)(e.td,{children:"String partitioning"})]})]})]}),"\n",(0,r.jsx)(e.h3,{id:"optimization-checklist",children:"Optimization Checklist"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\u2705 ",(0,r.jsx)(e.strong,{children:"Sort input"})," when dealing with duplicates"]}),"\n",(0,r.jsxs)(e.li,{children:["\u2705 ",(0,r.jsx)(e.strong,{children:"Early pruning"})," on constraint violations"]}),"\n",(0,r.jsxs)(e.li,{children:["\u2705 ",(0,r.jsx)(e.strong,{children:"Memoization"})," for overlapping subproblems"]}),"\n",(0,r.jsxs)(e.li,{children:["\u2705 ",(0,r.jsx)(e.strong,{children:"Bit manipulation"})," for state compression"]}),"\n",(0,r.jsxs)(e.li,{children:["\u2705 ",(0,r.jsx)(e.strong,{children:"In-place modifications"})," to save space"]}),"\n",(0,r.jsxs)(e.li,{children:["\u2705 ",(0,r.jsx)(e.strong,{children:"Iterative conversion"})," for deep recursion"]}),"\n",(0,r.jsxs)(e.li,{children:["\u2705 ",(0,r.jsx)(e.strong,{children:"Profile and measure"})," performance bottlenecks"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"time-complexity-quick-reference",children:"Time Complexity Quick Reference"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"Subsets:       O(2^n)        - Each element: include or exclude\nPermutations:  O(n!)         - n choices for first, (n-1) for second, etc.\nCombinations:  O(C(n,k))     - n choose k combinations\nN-Queens:      O(N!)         - Exponential with heavy pruning\nSudoku:        O(9^(empty))  - 9 choices per empty cell\n"})})]})}function d(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(u,{...n})}):u(n)}}}]);