"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[8302],{28453:(n,e,i)=>{i.d(e,{R:()=>a,x:()=>l});var r=i(96540);const t={},s=r.createContext(t);function a(n){const e=r.useContext(s);return r.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:a(n.components),r.createElement(s.Provider,{value:e},n.children)}},78862:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>l,toc:()=>d});var r=i(74848),t=i(28453);const s={},a="Java Data Structures and Algorithms",l={id:"Java/JavaWithDSA",title:"Java Data Structures and Algorithms",description:"Table of Contents",source:"@site/docs/Java/JavaWithDSA.mdx",sourceDirName:"Java",slug:"/Java/JavaWithDSA",permalink:"/dev.enigma/docs/Java/JavaWithDSA",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/Java/JavaWithDSA.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Java Stream API Cheatsheet",permalink:"/dev.enigma/docs/Java/JavaStreamAPICheatsheet"},next:{title:"Java Wrapper Classes, Lambda, Regex & Annotations",permalink:"/dev.enigma/docs/Java/JavaWrapperClassesLambdaRegex&Annotations"}},o={},d=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Arrays",id:"arrays",level:2},{value:"When to Use Arrays",id:"when-to-use-arrays",level:3},{value:"Key Characteristics",id:"key-characteristics",level:3},{value:"Common Use Cases",id:"common-use-cases",level:3},{value:"Best Practices",id:"best-practices",level:3},{value:"Strings",id:"strings",level:2},{value:"When to Use Strings",id:"when-to-use-strings",level:3},{value:"Key Characteristics",id:"key-characteristics-1",level:3},{value:"String vs StringBuilder vs StringBuffer",id:"string-vs-stringbuilder-vs-stringbuffer",level:3},{value:"Common String Algorithms",id:"common-string-algorithms",level:3},{value:"Linked Lists",id:"linked-lists",level:2},{value:"When to Use Linked Lists",id:"when-to-use-linked-lists",level:3},{value:"Types and Use Cases",id:"types-and-use-cases",level:3},{value:"Singly Linked List",id:"singly-linked-list",level:4},{value:"Doubly Linked List",id:"doubly-linked-list",level:4},{value:"Time Complexity",id:"time-complexity",level:3},{value:"Common Patterns",id:"common-patterns",level:3},{value:"Stacks",id:"stacks",level:2},{value:"When to Use Stacks",id:"when-to-use-stacks",level:3},{value:"Implementation Options",id:"implementation-options",level:3},{value:"Common Use Cases",id:"common-use-cases-1",level:3},{value:"Time Complexity",id:"time-complexity-1",level:3},{value:"Queues",id:"queues",level:2},{value:"When to Use Queues",id:"when-to-use-queues",level:3},{value:"Types and Implementations",id:"types-and-implementations",level:3},{value:"Regular Queue",id:"regular-queue",level:4},{value:"Priority Queue",id:"priority-queue",level:4},{value:"Deque (Double-ended Queue)",id:"deque-double-ended-queue",level:4},{value:"Common Patterns",id:"common-patterns-1",level:3},{value:"Trees",id:"trees",level:2},{value:"When to Use Trees",id:"when-to-use-trees",level:3},{value:"Types of Trees",id:"types-of-trees",level:3},{value:"Binary Tree",id:"binary-tree",level:4},{value:"Binary Search Tree (BST)",id:"binary-search-tree-bst",level:4},{value:"AVL Tree (Self-balancing BST)",id:"avl-tree-self-balancing-bst",level:4},{value:"Trie (Prefix Tree)",id:"trie-prefix-tree",level:4},{value:"Tree Traversals",id:"tree-traversals",level:3},{value:"Graphs",id:"graphs",level:2},{value:"When to Use Graphs",id:"when-to-use-graphs",level:3},{value:"Graph Representations",id:"graph-representations",level:3},{value:"Adjacency List",id:"adjacency-list",level:4},{value:"Adjacency Matrix",id:"adjacency-matrix",level:4},{value:"Graph Traversal Algorithms",id:"graph-traversal-algorithms",level:3},{value:"DFS (Depth-First Search)",id:"dfs-depth-first-search",level:4},{value:"BFS (Breadth-First Search)",id:"bfs-breadth-first-search",level:4},{value:"Shortest Path Algorithms",id:"shortest-path-algorithms",level:3},{value:"Dijkstra&#39;s Algorithm",id:"dijkstras-algorithm",level:4},{value:"Floyd-Warshall Algorithm",id:"floyd-warshall-algorithm",level:4},{value:"Topological Sorting",id:"topological-sorting",level:3},{value:"Hash Tables",id:"hash-tables",level:2},{value:"When to Use Hash Tables",id:"when-to-use-hash-tables",level:3},{value:"Java Hash Table Implementations",id:"java-hash-table-implementations",level:3},{value:"Common Patterns",id:"common-patterns-2",level:3},{value:"Hash Function Design Principles",id:"hash-function-design-principles",level:3},{value:"Heaps",id:"heaps",level:2},{value:"When to Use Heaps",id:"when-to-use-heaps",level:3},{value:"Types of Heaps",id:"types-of-heaps",level:3},{value:"Min Heap",id:"min-heap",level:4},{value:"Max Heap",id:"max-heap",level:4},{value:"Common Heap Patterns",id:"common-heap-patterns",level:3},{value:"Time Complexity",id:"time-complexity-2",level:3},{value:"Sorting Algorithms",id:"sorting-algorithms",level:2},{value:"When to Use Different Sorting Algorithms",id:"when-to-use-different-sorting-algorithms",level:3},{value:"Quick Sort",id:"quick-sort",level:4},{value:"Merge Sort",id:"merge-sort",level:4},{value:"Heap Sort",id:"heap-sort",level:4},{value:"Counting Sort",id:"counting-sort",level:4},{value:"Comparison of Sorting Algorithms",id:"comparison-of-sorting-algorithms",level:3},{value:"Searching Algorithms",id:"searching-algorithms",level:2},{value:"Binary Search",id:"binary-search",level:3},{value:"Linear Search",id:"linear-search",level:3},{value:"Ternary Search",id:"ternary-search",level:3},{value:"Dynamic Programming",id:"dynamic-programming",level:2},{value:"When to Use Dynamic Programming",id:"when-to-use-dynamic-programming",level:3},{value:"DP Approaches",id:"dp-approaches",level:3},{value:"Top-Down (Memoization)",id:"top-down-memoization",level:4},{value:"Bottom-Up (Tabulation)",id:"bottom-up-tabulation",level:4},{value:"Classic DP Problems",id:"classic-dp-problems",level:3},{value:"0/1 Knapsack",id:"01-knapsack",level:4},{value:"Longest Common Subsequence (LCS)",id:"longest-common-subsequence-lcs",level:4},{value:"Longest Increasing Subsequence (LIS)",id:"longest-increasing-subsequence-lis",level:4},{value:"Edit Distance (Levenshtein Distance)",id:"edit-distance-levenshtein-distance",level:4},{value:"Coin Change",id:"coin-change",level:4},{value:"House Robber",id:"house-robber",level:4},{value:"DP on Trees",id:"dp-on-trees",level:3},{value:"DP Optimization Techniques",id:"dp-optimization-techniques",level:3},{value:"Space Optimization",id:"space-optimization",level:4},{value:"Time Optimization",id:"time-optimization",level:4},{value:"Algorithm Design Patterns",id:"algorithm-design-patterns",level:2},{value:"Two Pointers",id:"two-pointers",level:3},{value:"Sliding Window",id:"sliding-window",level:3},{value:"Backtracking",id:"backtracking",level:3},{value:"Time and Space Complexity Analysis",id:"time-and-space-complexity-analysis",level:2},{value:"Big O Notation",id:"big-o-notation",level:3},{value:"Common Complexity Examples",id:"common-complexity-examples",level:3},{value:"Best Practices and Tips",id:"best-practices-and-tips",level:2},{value:"Code Organization",id:"code-organization",level:3},{value:"Error Handling",id:"error-handling",level:3},{value:"Performance Considerations",id:"performance-considerations",level:3},{value:"Interview Preparation Checklist",id:"interview-preparation-checklist",level:2},{value:"Must-Know Algorithms",id:"must-know-algorithms",level:3},{value:"Must-Know Data Structures",id:"must-know-data-structures",level:3},{value:"Problem-Solving Strategy",id:"problem-solving-strategy",level:3},{value:"Common Mistake Patterns to Avoid",id:"common-mistake-patterns-to-avoid",level:3}];function c(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"java-data-structures-and-algorithms",children:"Java Data Structures and Algorithms"})}),"\n",(0,r.jsx)(e.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#arrays",children:"Arrays"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#strings",children:"Strings"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#linked-lists",children:"Linked Lists"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#stacks",children:"Stacks"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#queues",children:"Queues"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#trees",children:"Trees"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#graphs",children:"Graphs"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#hash-tables",children:"Hash Tables"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#heaps",children:"Heaps"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#sorting-algorithms",children:"Sorting Algorithms"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#searching-algorithms",children:"Searching Algorithms"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#dynamic-programming",children:"Dynamic Programming"})}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"arrays",children:"Arrays"}),"\n",(0,r.jsx)(e.h3,{id:"when-to-use-arrays",children:"When to Use Arrays"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Fixed size data collection"})," where you know the maximum number of elements"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Random access"})," to elements by index (O(1) access time)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Memory efficiency"})," - elements stored in contiguous memory locations"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Mathematical computations"})," involving matrices or vectors"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"key-characteristics",children:"Key Characteristics"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Time Complexity:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Access: O(1)"}),"\n",(0,r.jsx)(e.li,{children:"Search: O(n)"}),"\n",(0,r.jsx)(e.li,{children:"Insertion: O(n) - worst case when inserting at beginning"}),"\n",(0,r.jsx)(e.li,{children:"Deletion: O(n) - worst case when deleting from beginning"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"common-use-cases",children:"Common Use Cases"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"// 1. Two Pointer Technique\nint[] arr = {1, 2, 3, 4, 5};\nint left = 0, right = arr.length - 1;\n\n// 2. Sliding Window\nint[] nums = {1, 2, 3, 4, 5, 6};\nint windowSize = 3;\n\n// 3. Prefix Sum Arrays\nint[] prefixSum = new int[arr.length + 1];\nfor (int i = 0; i < arr.length; i++) {\n    prefixSum[i + 1] = prefixSum[i] + arr[i];\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["Use ",(0,r.jsx)(e.code,{children:"ArrayList"})," when size is dynamic"]}),"\n",(0,r.jsx)(e.li,{children:"Use primitive arrays for better performance with large datasets"}),"\n",(0,r.jsxs)(e.li,{children:["Consider ",(0,r.jsx)(e.code,{children:"Arrays.sort()"})," for O(n log n) sorting"]}),"\n",(0,r.jsxs)(e.li,{children:["Use ",(0,r.jsx)(e.code,{children:"System.arraycopy()"})," for efficient array copying"]}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"strings",children:"Strings"}),"\n",(0,r.jsx)(e.h3,{id:"when-to-use-strings",children:"When to Use Strings"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Text processing"})," and manipulation"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Pattern matching"})," algorithms"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Parsing"})," and tokenization"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Input validation"})," and formatting"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"key-characteristics-1",children:"Key Characteristics"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Immutable"})," in Java - each modification creates a new object"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Time Complexity:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Access: O(1)"}),"\n",(0,r.jsx)(e.li,{children:"Concatenation: O(n) for String, O(1) amortized for StringBuilder"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"string-vs-stringbuilder-vs-stringbuffer",children:"String vs StringBuilder vs StringBuffer"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:'// Use String for: Immutable text, few modifications\nString str = "Hello";\n\n// Use StringBuilder for: Multiple modifications, single-threaded\nStringBuilder sb = new StringBuilder();\nsb.append("Hello").append(" World");\n\n// Use StringBuffer for: Multiple modifications, multi-threaded\nStringBuffer sbf = new StringBuffer();\nsbf.append("Thread-safe");\n'})}),"\n",(0,r.jsx)(e.h3,{id:"common-string-algorithms",children:"Common String Algorithms"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"// KMP Algorithm for pattern matching\npublic int[] computeLPS(String pattern) {\n    int[] lps = new int[pattern.length()];\n    int len = 0, i = 1;\n\n    while (i < pattern.length()) {\n        if (pattern.charAt(i) == pattern.charAt(len)) {\n            lps[i++] = ++len;\n        } else if (len != 0) {\n            len = lps[len - 1];\n        } else {\n            lps[i++] = 0;\n        }\n    }\n    return lps;\n}\n\n// Palindrome Check\npublic boolean isPalindrome(String s) {\n    int left = 0, right = s.length() - 1;\n    while (left < right) {\n        if (s.charAt(left++) != s.charAt(right--)) {\n            return false;\n        }\n    }\n    return true;\n}\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"linked-lists",children:"Linked Lists"}),"\n",(0,r.jsx)(e.h3,{id:"when-to-use-linked-lists",children:"When to Use Linked Lists"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Dynamic size"})," requirements"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Frequent insertions/deletions"})," at arbitrary positions"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Unknown data size"})," at compile time"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Implementing other data structures"})," (stacks, queues)"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"types-and-use-cases",children:"Types and Use Cases"}),"\n",(0,r.jsx)(e.h4,{id:"singly-linked-list",children:"Singly Linked List"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"class ListNode {\n    int val;\n    ListNode next;\n\n    ListNode(int val) {\n        this.val = val;\n    }\n}\n\n// Use for: Simple sequential access, memory efficiency\n"})}),"\n",(0,r.jsx)(e.h4,{id:"doubly-linked-list",children:"Doubly Linked List"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"class DoublyListNode {\n    int val;\n    DoublyListNode prev, next;\n\n    DoublyListNode(int val) {\n        this.val = val;\n    }\n}\n\n// Use for: Bidirectional traversal, LRU Cache implementation\n"})}),"\n",(0,r.jsx)(e.h3,{id:"time-complexity",children:"Time Complexity"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Access/Search:"})," O(n)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Insertion:"})," O(1) if position known, O(n) if searching first"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Deletion:"})," O(1) if node reference known, O(n) if searching first"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"common-patterns",children:"Common Patterns"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"// Fast and Slow Pointers (Floyd's Cycle Detection)\npublic boolean hasCycle(ListNode head) {\n    ListNode slow = head, fast = head;\n    while (fast != null && fast.next != null) {\n        slow = slow.next;\n        fast = fast.next.next;\n        if (slow == fast) return true;\n    }\n    return false;\n}\n\n// Reverse Linked List\npublic ListNode reverseList(ListNode head) {\n    ListNode prev = null, current = head;\n    while (current != null) {\n        ListNode next = current.next;\n        current.next = prev;\n        prev = current;\n        current = next;\n    }\n    return prev;\n}\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"stacks",children:"Stacks"}),"\n",(0,r.jsx)(e.h3,{id:"when-to-use-stacks",children:"When to Use Stacks"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"LIFO (Last In, First Out)"})," operations"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Recursion"})," simulation and backtracking"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Expression evaluation"})," and syntax parsing"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Undo operations"})," in applications"]}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"Function call management"})}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"implementation-options",children:"Implementation Options"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"// Using ArrayDeque (Recommended)\nDeque<Integer> stack = new ArrayDeque<>();\n\n// Using Stack class (Legacy, not recommended)\nStack<Integer> legacyStack = new Stack<>();\n\n// Using ArrayList\nList<Integer> listStack = new ArrayList<>();\n"})}),"\n",(0,r.jsx)(e.h3,{id:"common-use-cases-1",children:"Common Use Cases"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"// 1. Balanced Parentheses\npublic boolean isValid(String s) {\n    Deque<Character> stack = new ArrayDeque<>();\n    Map<Character, Character> map = Map.of(')', '(', '}', '{', ']', '[');\n\n    for (char c : s.toCharArray()) {\n        if (map.containsKey(c)) {\n            if (stack.isEmpty() || stack.pop() != map.get(c)) {\n                return false;\n            }\n        } else {\n            stack.push(c);\n        }\n    }\n    return stack.isEmpty();\n}\n\n// 2. Next Greater Element\npublic int[] nextGreaterElements(int[] nums) {\n    int n = nums.length;\n    int[] result = new int[n];\n    Deque<Integer> stack = new ArrayDeque<>();\n\n    for (int i = 2 * n - 1; i >= 0; i--) {\n        while (!stack.isEmpty() && stack.peek() <= nums[i % n]) {\n            stack.pop();\n        }\n        if (i < n) {\n            result[i] = stack.isEmpty() ? -1 : stack.peek();\n        }\n        stack.push(nums[i % n]);\n    }\n    return result;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"time-complexity-1",children:"Time Complexity"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Push:"})," O(1)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Pop:"})," O(1)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Peek:"})," O(1)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Search:"})," O(n)"]}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"queues",children:"Queues"}),"\n",(0,r.jsx)(e.h3,{id:"when-to-use-queues",children:"When to Use Queues"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"FIFO (First In, First Out)"})," operations"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"BFS (Breadth-First Search)"})," traversals"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Level-order processing"})," in trees"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Task scheduling"})," and buffering"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Handling requests"})," in web servers"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"types-and-implementations",children:"Types and Implementations"}),"\n",(0,r.jsx)(e.h4,{id:"regular-queue",children:"Regular Queue"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"// Using LinkedList\nQueue<Integer> queue = new LinkedList<>();\n\n// Using ArrayDeque (Better performance)\nQueue<Integer> queue = new ArrayDeque<>();\n"})}),"\n",(0,r.jsx)(e.h4,{id:"priority-queue",children:"Priority Queue"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"// Min Heap (default)\nPriorityQueue<Integer> minHeap = new PriorityQueue<>();\n\n// Max Heap\nPriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\n\n// Custom Comparator\nPriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);\n"})}),"\n",(0,r.jsx)(e.h4,{id:"deque-double-ended-queue",children:"Deque (Double-ended Queue)"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"Deque<Integer> deque = new ArrayDeque<>();\ndeque.addFirst(1);  // Add to front\ndeque.addLast(2);   // Add to rear\ndeque.removeFirst(); // Remove from front\ndeque.removeLast();  // Remove from rear\n"})}),"\n",(0,r.jsx)(e.h3,{id:"common-patterns-1",children:"Common Patterns"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"// BFS Template\npublic void bfs(TreeNode root) {\n    if (root == null) return;\n\n    Queue<TreeNode> queue = new ArrayDeque<>();\n    queue.offer(root);\n\n    while (!queue.isEmpty()) {\n        int size = queue.size();\n        for (int i = 0; i < size; i++) {\n            TreeNode node = queue.poll();\n            // Process current node\n\n            if (node.left != null) queue.offer(node.left);\n            if (node.right != null) queue.offer(node.right);\n        }\n    }\n}\n\n// Sliding Window Maximum using Deque\npublic int[] maxSlidingWindow(int[] nums, int k) {\n    Deque<Integer> deque = new ArrayDeque<>();\n    int[] result = new int[nums.length - k + 1];\n\n    for (int i = 0; i < nums.length; i++) {\n        // Remove indices outside window\n        while (!deque.isEmpty() && deque.peekFirst() < i - k + 1) {\n            deque.pollFirst();\n        }\n\n        // Remove smaller elements\n        while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {\n            deque.pollLast();\n        }\n\n        deque.offerLast(i);\n\n        if (i >= k - 1) {\n            result[i - k + 1] = nums[deque.peekFirst()];\n        }\n    }\n    return result;\n}\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"trees",children:"Trees"}),"\n",(0,r.jsx)(e.h3,{id:"when-to-use-trees",children:"When to Use Trees"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Hierarchical data"})," representation"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Efficient searching"})," with BST (O(log n))"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Expression parsing"})," with expression trees"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"File system"})," representation"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Decision making"})," with decision trees"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"types-of-trees",children:"Types of Trees"}),"\n",(0,r.jsx)(e.h4,{id:"binary-tree",children:"Binary Tree"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"class TreeNode {\n    int val;\n    TreeNode left, right;\n\n    TreeNode(int val) {\n        this.val = val;\n    }\n}\n"})}),"\n",(0,r.jsx)(e.h4,{id:"binary-search-tree-bst",children:"Binary Search Tree (BST)"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Left subtree"})," values < root value"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Right subtree"})," values > root value"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Inorder traversal"})," gives sorted sequence"]}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"// BST Operations\npublic TreeNode insert(TreeNode root, int val) {\n    if (root == null) return new TreeNode(val);\n\n    if (val < root.val) {\n        root.left = insert(root.left, val);\n    } else {\n        root.right = insert(root.right, val);\n    }\n    return root;\n}\n\npublic TreeNode search(TreeNode root, int val) {\n    if (root == null || root.val == val) return root;\n    return val < root.val ? search(root.left, val) : search(root.right, val);\n}\n"})}),"\n",(0,r.jsx)(e.h4,{id:"avl-tree-self-balancing-bst",children:"AVL Tree (Self-balancing BST)"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Height difference"})," between left and right subtrees \u2264 1"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Automatic rebalancing"})," through rotations"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Guaranteed O(log n)"})," operations"]}),"\n"]}),"\n",(0,r.jsx)(e.h4,{id:"trie-prefix-tree",children:"Trie (Prefix Tree)"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"class TrieNode {\n    TrieNode[] children = new TrieNode[26];\n    boolean isEnd = false;\n}\n\nclass Trie {\n    private TrieNode root = new TrieNode();\n\n    public void insert(String word) {\n        TrieNode node = root;\n        for (char c : word.toCharArray()) {\n            int index = c - 'a';\n            if (node.children[index] == null) {\n                node.children[index] = new TrieNode();\n            }\n            node = node.children[index];\n        }\n        node.isEnd = true;\n    }\n}\n\n// Use for: Auto-complete, spell checkers, IP routing\n"})}),"\n",(0,r.jsx)(e.h3,{id:"tree-traversals",children:"Tree Traversals"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:'// Inorder (Left, Root, Right) - gives sorted order for BST\npublic void inorder(TreeNode root) {\n    if (root != null) {\n        inorder(root.left);\n        System.out.print(root.val + " ");\n        inorder(root.right);\n    }\n}\n\n// Preorder (Root, Left, Right) - good for copying tree\npublic void preorder(TreeNode root) {\n    if (root != null) {\n        System.out.print(root.val + " ");\n        preorder(root.left);\n        preorder(root.right);\n    }\n}\n\n// Postorder (Left, Right, Root) - good for deletion\npublic void postorder(TreeNode root) {\n    if (root != null) {\n        postorder(root.left);\n        postorder(root.right);\n        System.out.print(root.val + " ");\n    }\n}\n\n// Level Order (BFS)\npublic List<List<Integer>> levelOrder(TreeNode root) {\n    List<List<Integer>> result = new ArrayList<>();\n    if (root == null) return result;\n\n    Queue<TreeNode> queue = new ArrayDeque<>();\n    queue.offer(root);\n\n    while (!queue.isEmpty()) {\n        int size = queue.size();\n        List<Integer> level = new ArrayList<>();\n\n        for (int i = 0; i < size; i++) {\n            TreeNode node = queue.poll();\n            level.add(node.val);\n\n            if (node.left != null) queue.offer(node.left);\n            if (node.right != null) queue.offer(node.right);\n        }\n        result.add(level);\n    }\n    return result;\n}\n'})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"graphs",children:"Graphs"}),"\n",(0,r.jsx)(e.h3,{id:"when-to-use-graphs",children:"When to Use Graphs"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Network modeling"})," (social networks, computer networks)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Path finding"})," algorithms"]}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"Dependency resolution"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"State space exploration"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"Relationship mapping"})}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"graph-representations",children:"Graph Representations"}),"\n",(0,r.jsx)(e.h4,{id:"adjacency-list",children:"Adjacency List"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"// Using ArrayList\nList<List<Integer>> adjList = new ArrayList<>();\n\n// Using HashMap for weighted graphs\nMap<Integer, List<int[]>> graph = new HashMap<>();\n\n// For undirected graph\npublic void addEdge(int u, int v) {\n    adjList.get(u).add(v);\n    adjList.get(v).add(u);  // Add both directions\n}\n"})}),"\n",(0,r.jsx)(e.h4,{id:"adjacency-matrix",children:"Adjacency Matrix"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"int[][] adjMatrix = new int[n][n];\n\n// For weighted graph\nadjMatrix[u][v] = weight;\n\n// Space: O(V\xb2), Good for dense graphs\n"})}),"\n",(0,r.jsx)(e.h3,{id:"graph-traversal-algorithms",children:"Graph Traversal Algorithms"}),"\n",(0,r.jsx)(e.h4,{id:"dfs-depth-first-search",children:"DFS (Depth-First Search)"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:'public void dfs(int node, List<List<Integer>> graph, boolean[] visited) {\n    visited[node] = true;\n    System.out.print(node + " ");\n\n    for (int neighbor : graph.get(node)) {\n        if (!visited[neighbor]) {\n            dfs(neighbor, graph, visited);\n        }\n    }\n}\n\n// Iterative DFS\npublic void dfsIterative(int start, List<List<Integer>> graph) {\n    boolean[] visited = new boolean[graph.size()];\n    Deque<Integer> stack = new ArrayDeque<>();\n\n    stack.push(start);\n\n    while (!stack.isEmpty()) {\n        int node = stack.pop();\n        if (!visited[node]) {\n            visited[node] = true;\n            System.out.print(node + " ");\n\n            for (int neighbor : graph.get(node)) {\n                if (!visited[neighbor]) {\n                    stack.push(neighbor);\n                }\n            }\n        }\n    }\n}\n'})}),"\n",(0,r.jsx)(e.h4,{id:"bfs-breadth-first-search",children:"BFS (Breadth-First Search)"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:'public void bfs(int start, List<List<Integer>> graph) {\n    boolean[] visited = new boolean[graph.size()];\n    Queue<Integer> queue = new ArrayDeque<>();\n\n    visited[start] = true;\n    queue.offer(start);\n\n    while (!queue.isEmpty()) {\n        int node = queue.poll();\n        System.out.print(node + " ");\n\n        for (int neighbor : graph.get(node)) {\n            if (!visited[neighbor]) {\n                visited[neighbor] = true;\n                queue.offer(neighbor);\n            }\n        }\n    }\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"shortest-path-algorithms",children:"Shortest Path Algorithms"}),"\n",(0,r.jsx)(e.h4,{id:"dijkstras-algorithm",children:"Dijkstra's Algorithm"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"public int[] dijkstra(int start, List<List<int[]>> graph) {\n    int n = graph.size();\n    int[] dist = new int[n];\n    Arrays.fill(dist, Integer.MAX_VALUE);\n    dist[start] = 0;\n\n    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\n    pq.offer(new int[]{start, 0});\n\n    while (!pq.isEmpty()) {\n        int[] current = pq.poll();\n        int node = current[0];\n        int distance = current[1];\n\n        if (distance > dist[node]) continue;\n\n        for (int[] edge : graph.get(node)) {\n            int neighbor = edge[0];\n            int weight = edge[1];\n            int newDist = dist[node] + weight;\n\n            if (newDist < dist[neighbor]) {\n                dist[neighbor] = newDist;\n                pq.offer(new int[]{neighbor, newDist});\n            }\n        }\n    }\n    return dist;\n}\n"})}),"\n",(0,r.jsx)(e.h4,{id:"floyd-warshall-algorithm",children:"Floyd-Warshall Algorithm"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"public int[][] floydWarshall(int[][] graph) {\n    int n = graph.length;\n    int[][] dist = new int[n][n];\n\n    // Initialize distance matrix\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            dist[i][j] = graph[i][j];\n        }\n    }\n\n    // Floyd-Warshall\n    for (int k = 0; k < n; k++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (dist[i][k] != Integer.MAX_VALUE &&\n                    dist[k][j] != Integer.MAX_VALUE &&\n                    dist[i][k] + dist[k][j] < dist[i][j]) {\n                    dist[i][j] = dist[i][k] + dist[k][j];\n                }\n            }\n        }\n    }\n    return dist;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"topological-sorting",children:"Topological Sorting"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"// Kahn's Algorithm (BFS-based)\npublic List<Integer> topologicalSort(int n, List<List<Integer>> graph) {\n    int[] indegree = new int[n];\n    for (int i = 0; i < n; i++) {\n        for (int neighbor : graph.get(i)) {\n            indegree[neighbor]++;\n        }\n    }\n\n    Queue<Integer> queue = new ArrayDeque<>();\n    for (int i = 0; i < n; i++) {\n        if (indegree[i] == 0) {\n            queue.offer(i);\n        }\n    }\n\n    List<Integer> result = new ArrayList<>();\n    while (!queue.isEmpty()) {\n        int node = queue.poll();\n        result.add(node);\n\n        for (int neighbor : graph.get(node)) {\n            indegree[neighbor]--;\n            if (indegree[neighbor] == 0) {\n                queue.offer(neighbor);\n            }\n        }\n    }\n\n    return result.size() == n ? result : new ArrayList<>(); // Cycle detection\n}\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"hash-tables",children:"Hash Tables"}),"\n",(0,r.jsx)(e.h3,{id:"when-to-use-hash-tables",children:"When to Use Hash Tables"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Fast lookups"})," - O(1) average case"]}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"Frequency counting"})}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Caching"})," and memoization"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Set operations"})," (union, intersection)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Grouping"})," related data"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"java-hash-table-implementations",children:"Java Hash Table Implementations"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"// HashMap - Not synchronized, allows null\nHashMap<String, Integer> hashMap = new HashMap<>();\n\n// LinkedHashMap - Maintains insertion order\nLinkedHashMap<String, Integer> linkedHashMap = new LinkedHashMap<>();\n\n// TreeMap - Sorted order, O(log n) operations\nTreeMap<String, Integer> treeMap = new TreeMap<>();\n\n// ConcurrentHashMap - Thread-safe\nConcurrentHashMap<String, Integer> concurrentHashMap = new ConcurrentHashMap<>();\n\n// HashSet for unique elements\nSet<Integer> hashSet = new HashSet<>();\n"})}),"\n",(0,r.jsx)(e.h3,{id:"common-patterns-2",children:"Common Patterns"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"// Frequency Map\npublic Map<Character, Integer> getFrequency(String s) {\n    Map<Character, Integer> freq = new HashMap<>();\n    for (char c : s.toCharArray()) {\n        freq.put(c, freq.getOrDefault(c, 0) + 1);\n    }\n    return freq;\n}\n\n// Two Sum using HashMap\npublic int[] twoSum(int[] nums, int target) {\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n        int complement = target - nums[i];\n        if (map.containsKey(complement)) {\n            return new int[]{map.get(complement), i};\n        }\n        map.put(nums[i], i);\n    }\n    return new int[0];\n}\n\n// Group Anagrams\npublic List<List<String>> groupAnagrams(String[] strs) {\n    Map<String, List<String>> map = new HashMap<>();\n\n    for (String str : strs) {\n        char[] chars = str.toCharArray();\n        Arrays.sort(chars);\n        String key = String.valueOf(chars);\n\n        map.computeIfAbsent(key, k -> new ArrayList<>()).add(str);\n    }\n\n    return new ArrayList<>(map.values());\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"hash-function-design-principles",children:"Hash Function Design Principles"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Uniform distribution"})," of hash codes"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Deterministic"})," - same input produces same hash"]}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"Fast computation"})}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Avalanche effect"})," - small input changes cause large hash changes"]}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"heaps",children:"Heaps"}),"\n",(0,r.jsx)(e.h3,{id:"when-to-use-heaps",children:"When to Use Heaps"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"Priority-based operations"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"Finding k-th largest/smallest elements"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"Median maintenance"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"Merging k sorted arrays"})}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Task scheduling"})," with priorities"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"types-of-heaps",children:"Types of Heaps"}),"\n",(0,r.jsx)(e.h4,{id:"min-heap",children:"Min Heap"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"PriorityQueue<Integer> minHeap = new PriorityQueue<>();\n\n// Custom objects\nPriorityQueue<int[]> minHeap = new PriorityQueue<>((a, b) -> a[0] - b[0]);\n"})}),"\n",(0,r.jsx)(e.h4,{id:"max-heap",children:"Max Heap"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\n\n// Or using lambda\nPriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a);\n"})}),"\n",(0,r.jsx)(e.h3,{id:"common-heap-patterns",children:"Common Heap Patterns"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"// K Largest Elements\npublic int[] findKLargest(int[] nums, int k) {\n    PriorityQueue<Integer> minHeap = new PriorityQueue<>();\n\n    for (int num : nums) {\n        minHeap.offer(num);\n        if (minHeap.size() > k) {\n            minHeap.poll();\n        }\n    }\n\n    int[] result = new int[k];\n    for (int i = k - 1; i >= 0; i--) {\n        result[i] = minHeap.poll();\n    }\n    return result;\n}\n\n// Median Finder\nclass MedianFinder {\n    PriorityQueue<Integer> maxHeap; // Left half\n    PriorityQueue<Integer> minHeap; // Right half\n\n    public MedianFinder() {\n        maxHeap = new PriorityQueue<>(Collections.reverseOrder());\n        minHeap = new PriorityQueue<>();\n    }\n\n    public void addNum(int num) {\n        if (maxHeap.isEmpty() || num <= maxHeap.peek()) {\n            maxHeap.offer(num);\n        } else {\n            minHeap.offer(num);\n        }\n\n        // Balance heaps\n        if (maxHeap.size() > minHeap.size() + 1) {\n            minHeap.offer(maxHeap.poll());\n        } else if (minHeap.size() > maxHeap.size() + 1) {\n            maxHeap.offer(minHeap.poll());\n        }\n    }\n\n    public double findMedian() {\n        if (maxHeap.size() == minHeap.size()) {\n            return (maxHeap.peek() + minHeap.peek()) / 2.0;\n        }\n        return maxHeap.size() > minHeap.size() ? maxHeap.peek() : minHeap.peek();\n    }\n}\n\n// Merge K Sorted Lists\npublic ListNode mergeKLists(ListNode[] lists) {\n    PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n\n    for (ListNode list : lists) {\n        if (list != null) {\n            pq.offer(list);\n        }\n    }\n\n    ListNode dummy = new ListNode(0);\n    ListNode current = dummy;\n\n    while (!pq.isEmpty()) {\n        ListNode node = pq.poll();\n        current.next = node;\n        current = current.next;\n\n        if (node.next != null) {\n            pq.offer(node.next);\n        }\n    }\n\n    return dummy.next;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"time-complexity-2",children:"Time Complexity"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Insert:"})," O(log n)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Delete Max/Min:"})," O(log n)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Peek Max/Min:"})," O(1)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Build Heap:"})," O(n)"]}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"sorting-algorithms",children:"Sorting Algorithms"}),"\n",(0,r.jsx)(e.h3,{id:"when-to-use-different-sorting-algorithms",children:"When to Use Different Sorting Algorithms"}),"\n",(0,r.jsx)(e.h4,{id:"quick-sort",children:"Quick Sort"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"public void quickSort(int[] arr, int low, int high) {\n    if (low < high) {\n        int pi = partition(arr, low, high);\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\n\nprivate int partition(int[] arr, int low, int high) {\n    int pivot = arr[high];\n    int i = low - 1;\n\n    for (int j = low; j < high; j++) {\n        if (arr[j] < pivot) {\n            i++;\n            swap(arr, i, j);\n        }\n    }\n    swap(arr, i + 1, high);\n    return i + 1;\n}\n\n// Use for: General purpose, average O(n log n), in-place\n// Avoid for: Already sorted data (worst case O(n\xb2))\n"})}),"\n",(0,r.jsx)(e.h4,{id:"merge-sort",children:"Merge Sort"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"public void mergeSort(int[] arr, int left, int right) {\n    if (left < right) {\n        int mid = left + (right - left) / 2;\n        mergeSort(arr, left, mid);\n        mergeSort(arr, mid + 1, right);\n        merge(arr, left, mid, right);\n    }\n}\n\nprivate void merge(int[] arr, int left, int mid, int right) {\n    int[] temp = new int[right - left + 1];\n    int i = left, j = mid + 1, k = 0;\n\n    while (i <= mid && j <= right) {\n        if (arr[i] <= arr[j]) {\n            temp[k++] = arr[i++];\n        } else {\n            temp[k++] = arr[j++];\n        }\n    }\n\n    while (i <= mid) temp[k++] = arr[i++];\n    while (j <= right) temp[k++] = arr[j++];\n\n    System.arraycopy(temp, 0, arr, left, temp.length);\n}\n\n// Use for: Stable sorting, guaranteed O(n log n), linked lists\n// Space: O(n)\n"})}),"\n",(0,r.jsx)(e.h4,{id:"heap-sort",children:"Heap Sort"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"public void heapSort(int[] arr) {\n    int n = arr.length;\n\n    // Build max heap\n    for (int i = n / 2 - 1; i >= 0; i--) {\n        heapify(arr, n, i);\n    }\n\n    // Extract elements\n    for (int i = n - 1; i > 0; i--) {\n        swap(arr, 0, i);\n        heapify(arr, i, 0);\n    }\n}\n\nprivate void heapify(int[] arr, int n, int i) {\n    int largest = i;\n    int left = 2 * i + 1;\n    int right = 2 * i + 2;\n\n    if (left < n && arr[left] > arr[largest]) largest = left;\n    if (right < n && arr[right] > arr[largest]) largest = right;\n\n    if (largest != i) {\n        swap(arr, i, largest);\n        heapify(arr, n, largest);\n    }\n}\n\n// Use for: Guaranteed O(n log n), in-place, not stable\n"})}),"\n",(0,r.jsx)(e.h4,{id:"counting-sort",children:"Counting Sort"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"public void countingSort(int[] arr, int max) {\n    int[] count = new int[max + 1];\n    int[] output = new int[arr.length];\n\n    // Count frequencies\n    for (int num : arr) {\n        count[num]++;\n    }\n\n    // Calculate positions\n    for (int i = 1; i <= max; i++) {\n        count[i] += count[i - 1];\n    }\n\n    // Build output array\n    for (int i = arr.length - 1; i >= 0; i--) {\n        output[count[arr[i]] - 1] = arr[i];\n        count[arr[i]]--;\n    }\n\n    System.arraycopy(output, 0, arr, 0, arr.length);\n}\n\n// Use for: Small range integers, O(n + k) time, stable\n"})}),"\n",(0,r.jsx)(e.h3,{id:"comparison-of-sorting-algorithms",children:"Comparison of Sorting Algorithms"}),"\n",(0,r.jsxs)(e.table,{children:[(0,r.jsx)(e.thead,{children:(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.th,{children:"Algorithm"}),(0,r.jsx)(e.th,{children:"Best Case"}),(0,r.jsx)(e.th,{children:"Average Case"}),(0,r.jsx)(e.th,{children:"Worst Case"}),(0,r.jsx)(e.th,{children:"Space"}),(0,r.jsx)(e.th,{children:"Stable"})]})}),(0,r.jsxs)(e.tbody,{children:[(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Quick Sort"}),(0,r.jsx)(e.td,{children:"O(n log n)"}),(0,r.jsx)(e.td,{children:"O(n log n)"}),(0,r.jsx)(e.td,{children:"O(n\xb2)"}),(0,r.jsx)(e.td,{children:"O(log n)"}),(0,r.jsx)(e.td,{children:"No"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Merge Sort"}),(0,r.jsx)(e.td,{children:"O(n log n)"}),(0,r.jsx)(e.td,{children:"O(n log n)"}),(0,r.jsx)(e.td,{children:"O(n log n)"}),(0,r.jsx)(e.td,{children:"O(n)"}),(0,r.jsx)(e.td,{children:"Yes"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Heap Sort"}),(0,r.jsx)(e.td,{children:"O(n log n)"}),(0,r.jsx)(e.td,{children:"O(n log n)"}),(0,r.jsx)(e.td,{children:"O(n log n)"}),(0,r.jsx)(e.td,{children:"O(1)"}),(0,r.jsx)(e.td,{children:"No"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Counting Sort"}),(0,r.jsx)(e.td,{children:"O(n + k)"}),(0,r.jsx)(e.td,{children:"O(n + k)"}),(0,r.jsx)(e.td,{children:"O(n + k)"}),(0,r.jsx)(e.td,{children:"O(k)"}),(0,r.jsx)(e.td,{children:"Yes"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Radix Sort"}),(0,r.jsx)(e.td,{children:"O(d(n + k))"}),(0,r.jsx)(e.td,{children:"O(d(n + k))"}),(0,r.jsx)(e.td,{children:"O(d(n + k))"}),(0,r.jsx)(e.td,{children:"O(n + k)"}),(0,r.jsx)(e.td,{children:"Yes"})]})]})]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"searching-algorithms",children:"Searching Algorithms"}),"\n",(0,r.jsx)(e.h3,{id:"binary-search",children:"Binary Search"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"// Iterative Binary Search\npublic int binarySearch(int[] arr, int target) {\n    int left = 0, right = arr.length - 1;\n\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n\n        if (arr[mid] == target) {\n            return mid;\n        } else if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return -1; // Not found\n}\n\n// Recursive Binary Search\npublic int binarySearchRecursive(int[] arr, int target, int left, int right) {\n    if (left > right) return -1;\n\n    int mid = left + (right - left) / 2;\n\n    if (arr[mid] == target) return mid;\n    if (arr[mid] < target) return binarySearchRecursive(arr, target, mid + 1, right);\n    return binarySearchRecursive(arr, target, left, mid - 1);\n}\n\n// Binary Search Variants\n// Find first occurrence\npublic int findFirst(int[] arr, int target) {\n    int left = 0, right = arr.length - 1, result = -1;\n\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n\n        if (arr[mid] == target) {\n            result = mid;\n            right = mid - 1; // Continue searching left\n        } else if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return result;\n}\n\n// Find last occurrence\npublic int findLast(int[] arr, int target) {\n    int left = 0, right = arr.length - 1, result = -1;\n\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n\n        if (arr[mid] == target) {\n            result = mid;\n            left = mid + 1; // Continue searching right\n        } else if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return result;\n}\n\n// Search in Rotated Sorted Array\npublic int searchRotated(int[] nums, int target) {\n    int left = 0, right = nums.length - 1;\n\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n\n        if (nums[mid] == target) return mid;\n\n        // Left half is sorted\n        if (nums[left] <= nums[mid]) {\n            if (target >= nums[left] && target < nums[mid]) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        // Right half is sorted\n        else {\n            if (target > nums[mid] && target <= nums[right]) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    return -1;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"linear-search",children:"Linear Search"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"public int linearSearch(int[] arr, int target) {\n    for (int i = 0; i < arr.length; i++) {\n        if (arr[i] == target) {\n            return i;\n        }\n    }\n    return -1;\n}\n\n// Use for: Unsorted arrays, small datasets, simple implementation\n// Time: O(n), Space: O(1)\n"})}),"\n",(0,r.jsx)(e.h3,{id:"ternary-search",children:"Ternary Search"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"public int ternarySearch(int[] arr, int target, int left, int right) {\n    if (right >= left) {\n        int mid1 = left + (right - left) / 3;\n        int mid2 = right - (right - left) / 3;\n\n        if (arr[mid1] == target) return mid1;\n        if (arr[mid2] == target) return mid2;\n\n        if (target < arr[mid1]) {\n            return ternarySearch(arr, target, left, mid1 - 1);\n        } else if (target > arr[mid2]) {\n            return ternarySearch(arr, target, mid2 + 1, right);\n        } else {\n            return ternarySearch(arr, target, mid1 + 1, mid2 - 1);\n        }\n    }\n    return -1;\n}\n\n// Use for: Finding maximum/minimum in unimodal functions\n// Time: O(log\u2083 n)\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"dynamic-programming",children:"Dynamic Programming"}),"\n",(0,r.jsx)(e.h3,{id:"when-to-use-dynamic-programming",children:"When to Use Dynamic Programming"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Overlapping subproblems"})," - same subproblems solved multiple times"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Optimal substructure"})," - optimal solution contains optimal solutions to subproblems"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Optimization problems"})," (min/max)"]}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"Counting problems"})}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"dp-approaches",children:"DP Approaches"}),"\n",(0,r.jsx)(e.h4,{id:"top-down-memoization",children:"Top-Down (Memoization)"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"// Fibonacci with Memoization\nMap<Integer, Integer> memo = new HashMap<>();\n\npublic int fibonacciMemo(int n) {\n    if (n <= 1) return n;\n\n    if (memo.containsKey(n)) {\n        return memo.get(n);\n    }\n\n    int result = fibonacciMemo(n - 1) + fibonacciMemo(n - 2);\n    memo.put(n, result);\n    return result;\n}\n"})}),"\n",(0,r.jsx)(e.h4,{id:"bottom-up-tabulation",children:"Bottom-Up (Tabulation)"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"// Fibonacci with Tabulation\npublic int fibonacciTab(int n) {\n    if (n <= 1) return n;\n\n    int[] dp = new int[n + 1];\n    dp[0] = 0;\n    dp[1] = 1;\n\n    for (int i = 2; i <= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2];\n    }\n\n    return dp[n];\n}\n\n// Space Optimized\npublic int fibonacciOptimized(int n) {\n    if (n <= 1) return n;\n\n    int prev2 = 0, prev1 = 1;\n\n    for (int i = 2; i <= n; i++) {\n        int current = prev1 + prev2;\n        prev2 = prev1;\n        prev1 = current;\n    }\n\n    return prev1;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"classic-dp-problems",children:"Classic DP Problems"}),"\n",(0,r.jsx)(e.h4,{id:"01-knapsack",children:"0/1 Knapsack"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"public int knapsack(int[] weights, int[] values, int capacity) {\n    int n = weights.length;\n    int[][] dp = new int[n + 1][capacity + 1];\n\n    for (int i = 1; i <= n; i++) {\n        for (int w = 1; w <= capacity; w++) {\n            if (weights[i - 1] <= w) {\n                dp[i][w] = Math.max(\n                    values[i - 1] + dp[i - 1][w - weights[i - 1]], // Take item\n                    dp[i - 1][w] // Don't take item\n                );\n            } else {\n                dp[i][w] = dp[i - 1][w];\n            }\n        }\n    }\n\n    return dp[n][capacity];\n}\n\n// Space Optimized O(capacity)\npublic int knapsackOptimized(int[] weights, int[] values, int capacity) {\n    int[] dp = new int[capacity + 1];\n\n    for (int i = 0; i < weights.length; i++) {\n        for (int w = capacity; w >= weights[i]; w--) {\n            dp[w] = Math.max(dp[w], values[i] + dp[w - weights[i]]);\n        }\n    }\n\n    return dp[capacity];\n}\n"})}),"\n",(0,r.jsx)(e.h4,{id:"longest-common-subsequence-lcs",children:"Longest Common Subsequence (LCS)"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"public int longestCommonSubsequence(String text1, String text2) {\n    int m = text1.length(), n = text2.length();\n    int[][] dp = new int[m + 1][n + 1];\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (text1.charAt(i - 1) == text2.charAt(j - 1)) {\n                dp[i][j] = 1 + dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n\n// Space Optimized O(min(m, n))\npublic int lcsOptimized(String text1, String text2) {\n    if (text1.length() < text2.length()) {\n        return lcsOptimized(text2, text1);\n    }\n\n    int n = text2.length();\n    int[] prev = new int[n + 1];\n    int[] curr = new int[n + 1];\n\n    for (int i = 1; i <= text1.length(); i++) {\n        for (int j = 1; j <= n; j++) {\n            if (text1.charAt(i - 1) == text2.charAt(j - 1)) {\n                curr[j] = 1 + prev[j - 1];\n            } else {\n                curr[j] = Math.max(prev[j], curr[j - 1]);\n            }\n        }\n        int[] temp = prev;\n        prev = curr;\n        curr = temp;\n    }\n\n    return prev[n];\n}\n"})}),"\n",(0,r.jsx)(e.h4,{id:"longest-increasing-subsequence-lis",children:"Longest Increasing Subsequence (LIS)"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"// O(n\xb2) DP Solution\npublic int lengthOfLIS(int[] nums) {\n    int n = nums.length;\n    int[] dp = new int[n];\n    Arrays.fill(dp, 1);\n\n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            if (nums[j] < nums[i]) {\n                dp[i] = Math.max(dp[i], dp[j] + 1);\n            }\n        }\n    }\n\n    return Arrays.stream(dp).max().orElse(0);\n}\n\n// O(n log n) Binary Search Solution\npublic int lengthOfLISOptimal(int[] nums) {\n    List<Integer> tails = new ArrayList<>();\n\n    for (int num : nums) {\n        int pos = Collections.binarySearch(tails, num);\n        if (pos < 0) {\n            pos = -(pos + 1);\n        }\n\n        if (pos == tails.size()) {\n            tails.add(num);\n        } else {\n            tails.set(pos, num);\n        }\n    }\n\n    return tails.size();\n}\n"})}),"\n",(0,r.jsx)(e.h4,{id:"edit-distance-levenshtein-distance",children:"Edit Distance (Levenshtein Distance)"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"public int minDistance(String word1, String word2) {\n    int m = word1.length(), n = word2.length();\n    int[][] dp = new int[m + 1][n + 1];\n\n    // Initialize base cases\n    for (int i = 0; i <= m; i++) dp[i][0] = i;\n    for (int j = 0; j <= n; j++) dp[0][j] = j;\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (word1.charAt(i - 1) == word2.charAt(j - 1)) {\n                dp[i][j] = dp[i - 1][j - 1]; // No operation needed\n            } else {\n                dp[i][j] = 1 + Math.min(\n                    Math.min(dp[i - 1][j], dp[i][j - 1]), // Delete or Insert\n                    dp[i - 1][j - 1] // Replace\n                );\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n"})}),"\n",(0,r.jsx)(e.h4,{id:"coin-change",children:"Coin Change"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"// Minimum coins needed\npublic int coinChange(int[] coins, int amount) {\n    int[] dp = new int[amount + 1];\n    Arrays.fill(dp, amount + 1);\n    dp[0] = 0;\n\n    for (int i = 1; i <= amount; i++) {\n        for (int coin : coins) {\n            if (coin <= i) {\n                dp[i] = Math.min(dp[i], dp[i - coin] + 1);\n            }\n        }\n    }\n\n    return dp[amount] > amount ? -1 : dp[amount];\n}\n\n// Number of ways to make amount\npublic int change(int amount, int[] coins) {\n    int[] dp = new int[amount + 1];\n    dp[0] = 1;\n\n    for (int coin : coins) {\n        for (int i = coin; i <= amount; i++) {\n            dp[i] += dp[i - coin];\n        }\n    }\n\n    return dp[amount];\n}\n"})}),"\n",(0,r.jsx)(e.h4,{id:"house-robber",children:"House Robber"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"public int rob(int[] nums) {\n    if (nums.length == 0) return 0;\n    if (nums.length == 1) return nums[0];\n\n    int prev2 = 0, prev1 = 0;\n\n    for (int num : nums) {\n        int current = Math.max(prev1, prev2 + num);\n        prev2 = prev1;\n        prev1 = current;\n    }\n\n    return prev1;\n}\n\n// House Robber II (Circular)\npublic int robCircular(int[] nums) {\n    if (nums.length == 1) return nums[0];\n\n    // Case 1: Rob houses 0 to n-2\n    int max1 = robLinear(nums, 0, nums.length - 2);\n\n    // Case 2: Rob houses 1 to n-1\n    int max2 = robLinear(nums, 1, nums.length - 1);\n\n    return Math.max(max1, max2);\n}\n\nprivate int robLinear(int[] nums, int start, int end) {\n    int prev2 = 0, prev1 = 0;\n\n    for (int i = start; i <= end; i++) {\n        int current = Math.max(prev1, prev2 + nums[i]);\n        prev2 = prev1;\n        prev1 = current;\n    }\n\n    return prev1;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"dp-on-trees",children:"DP on Trees"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"// House Robber III (Binary Tree)\npublic int robTree(TreeNode root) {\n    int[] result = robHelper(root);\n    return Math.max(result[0], result[1]);\n}\n\n// Returns [rob_root, not_rob_root]\nprivate int[] robHelper(TreeNode node) {\n    if (node == null) return new int[]{0, 0};\n\n    int[] left = robHelper(node.left);\n    int[] right = robHelper(node.right);\n\n    int robRoot = node.val + left[1] + right[1];\n    int notRobRoot = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);\n\n    return new int[]{robRoot, notRobRoot};\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"dp-optimization-techniques",children:"DP Optimization Techniques"}),"\n",(0,r.jsx)(e.h4,{id:"space-optimization",children:"Space Optimization"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Rolling Array"}),": Use only necessary rows/columns"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"State Compression"}),": Represent state more efficiently"]}),"\n"]}),"\n",(0,r.jsx)(e.h4,{id:"time-optimization",children:"Time Optimization"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Memoization"}),": Cache expensive computations"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Bottom-up"}),": Avoid recursion overhead"]}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"algorithm-design-patterns",children:"Algorithm Design Patterns"}),"\n",(0,r.jsx)(e.h3,{id:"two-pointers",children:"Two Pointers"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"// Valid Palindrome\npublic boolean isPalindrome(String s) {\n    int left = 0, right = s.length() - 1;\n\n    while (left < right) {\n        while (left < right && !Character.isAlphanumeric(s.charAt(left))) {\n            left++;\n        }\n        while (left < right && !Character.isAlphanumeric(s.charAt(right))) {\n            right--;\n        }\n\n        if (Character.toLowerCase(s.charAt(left)) !=\n            Character.toLowerCase(s.charAt(right))) {\n            return false;\n        }\n\n        left++;\n        right--;\n    }\n\n    return true;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"sliding-window",children:"Sliding Window"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:'// Longest Substring Without Repeating Characters\npublic int lengthOfLongestSubstring(String s) {\n    Set<Character> window = new HashSet<>();\n    int left = 0, maxLength = 0;\n\n    for (int right = 0; right < s.length(); right++) {\n        while (window.contains(s.charAt(right))) {\n            window.remove(s.charAt(left));\n            left++;\n        }\n\n        window.add(s.charAt(right));\n        maxLength = Math.max(maxLength, right - left + 1);\n    }\n\n    return maxLength;\n}\n\n// Minimum Window Substring\npublic String minWindow(String s, String t) {\n    Map<Character, Integer> need = new HashMap<>();\n    Map<Character, Integer> window = new HashMap<>();\n\n    for (char c : t.toCharArray()) {\n        need.put(c, need.getOrDefault(c, 0) + 1);\n    }\n\n    int left = 0, right = 0, valid = 0;\n    int start = 0, len = Integer.MAX_VALUE;\n\n    while (right < s.length()) {\n        char c = s.charAt(right);\n        right++;\n\n        if (need.containsKey(c)) {\n            window.put(c, window.getOrDefault(c, 0) + 1);\n            if (window.get(c).equals(need.get(c))) {\n                valid++;\n            }\n        }\n\n        while (valid == need.size()) {\n            if (right - left < len) {\n                start = left;\n                len = right - left;\n            }\n\n            char d = s.charAt(left);\n            left++;\n\n            if (need.containsKey(d)) {\n                if (window.get(d).equals(need.get(d))) {\n                    valid--;\n                }\n                window.put(d, window.get(d) - 1);\n            }\n        }\n    }\n\n    return len == Integer.MAX_VALUE ? "" : s.substring(start, start + len);\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"backtracking",children:"Backtracking"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"// Generate Parentheses\npublic List<String> generateParenthesis(int n) {\n    List<String> result = new ArrayList<>();\n    backtrack(result, \"\", 0, 0, n);\n    return result;\n}\n\nprivate void backtrack(List<String> result, String current,\n                      int open, int close, int max) {\n    if (current.length() == max * 2) {\n        result.add(current);\n        return;\n    }\n\n    if (open < max) {\n        backtrack(result, current + \"(\", open + 1, close, max);\n    }\n    if (close < open) {\n        backtrack(result, current + \")\", open, close + 1, max);\n    }\n}\n\n// N-Queens\npublic List<List<String>> solveNQueens(int n) {\n    List<List<String>> result = new ArrayList<>();\n    char[][] board = new char[n][n];\n\n    for (char[] row : board) {\n        Arrays.fill(row, '.');\n    }\n\n    backtrackQueens(result, board, 0);\n    return result;\n}\n\nprivate void backtrackQueens(List<List<String>> result, char[][] board, int row) {\n    if (row == board.length) {\n        result.add(construct(board));\n        return;\n    }\n\n    for (int col = 0; col < board.length; col++) {\n        if (isValidQueenPlacement(board, row, col)) {\n            board[row][col] = 'Q';\n            backtrackQueens(result, board, row + 1);\n            board[row][col] = '.';\n        }\n    }\n}\n\nprivate boolean isValidQueenPlacement(char[][] board, int row, int col) {\n    // Check column\n    for (int i = 0; i < row; i++) {\n        if (board[i][col] == 'Q') return false;\n    }\n\n    // Check diagonal\n    for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\n        if (board[i][j] == 'Q') return false;\n    }\n\n    // Check anti-diagonal\n    for (int i = row - 1, j = col + 1; i >= 0 && j < board.length; i--, j++) {\n        if (board[i][j] == 'Q') return false;\n    }\n\n    return true;\n}\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"time-and-space-complexity-analysis",children:"Time and Space Complexity Analysis"}),"\n",(0,r.jsx)(e.h3,{id:"big-o-notation",children:"Big O Notation"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"O(1)"})," - Constant time"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"O(log n)"})," - Logarithmic time"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"O(n)"})," - Linear time"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"O(n log n)"})," - Linearithmic time"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"O(n\xb2)"})," - Quadratic time"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"O(2\u207f)"})," - Exponential time"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"O(n!)"})," - Factorial time"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"common-complexity-examples",children:"Common Complexity Examples"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"// O(1) - Constant\npublic int getFirst(int[] arr) {\n    return arr[0]; // Single operation\n}\n\n// O(n) - Linear\npublic int findMax(int[] arr) {\n    int max = arr[0];\n    for (int i = 1; i < arr.length; i++) { // n iterations\n        if (arr[i] > max) {\n            max = arr[i];\n        }\n    }\n    return max;\n}\n\n// O(n\xb2) - Quadratic\npublic void bubbleSort(int[] arr) {\n    for (int i = 0; i < arr.length; i++) { // n iterations\n        for (int j = 0; j < arr.length - i - 1; j++) { // n iterations\n            if (arr[j] > arr[j + 1]) {\n                swap(arr, j, j + 1);\n            }\n        }\n    }\n}\n\n// O(log n) - Logarithmic\npublic int binarySearch(int[] arr, int target) {\n    int left = 0, right = arr.length - 1;\n    while (left <= right) { // log n iterations\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) return mid;\n        else if (arr[mid] < target) left = mid + 1;\n        else right = mid - 1;\n    }\n    return -1;\n}\n\n// O(n log n) - Merge Sort\npublic void mergeSort(int[] arr, int left, int right) {\n    if (left < right) {\n        int mid = left + (right - left) / 2;\n        mergeSort(arr, left, mid); // T(n/2)\n        mergeSort(arr, mid + 1, right); // T(n/2)\n        merge(arr, left, mid, right); // O(n)\n    }\n}\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"best-practices-and-tips",children:"Best Practices and Tips"}),"\n",(0,r.jsx)(e.h3,{id:"code-organization",children:"Code Organization"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"// Good: Clear method names and single responsibility\npublic class BinarySearchTree {\n    private TreeNode root;\n\n    public void insert(int val) { /* implementation */ }\n    public boolean search(int val) { /* implementation */ }\n    public void delete(int val) { /* implementation */ }\n    private TreeNode findMin(TreeNode node) { /* helper */ }\n}\n\n// Good: Use meaningful variable names\npublic int findSecondLargest(int[] nums) {\n    int largest = Integer.MIN_VALUE;\n    int secondLargest = Integer.MIN_VALUE;\n\n    for (int num : nums) {\n        if (num > largest) {\n            secondLargest = largest;\n            largest = num;\n        } else if (num > secondLargest && num != largest) {\n            secondLargest = num;\n        }\n    }\n\n    return secondLargest;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"error-handling",children:"Error Handling"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:'// Always validate inputs\npublic int binarySearch(int[] arr, int target) {\n    if (arr == null || arr.length == 0) {\n        throw new IllegalArgumentException("Array cannot be null or empty");\n    }\n\n    // Binary search implementation\n    return -1;\n}\n\n// Handle edge cases\npublic ListNode reverseList(ListNode head) {\n    if (head == null || head.next == null) {\n        return head; // Handle empty list or single node\n    }\n\n    // Reversal logic\n    return null;\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:'// Prefer primitive arrays for large datasets\nint[] primitiveArray = new int[1000000]; // Better performance\nInteger[] wrapperArray = new Integer[1000000]; // More memory overhead\n\n// Use StringBuilder for string concatenation\nStringBuilder sb = new StringBuilder();\nfor (int i = 0; i < 1000; i++) {\n    sb.append("value").append(i); // O(1) amortized\n}\nString result = sb.toString();\n\n// Avoid creating unnecessary objects in loops\n// Bad\nfor (int i = 0; i < n; i++) {\n    String temp = "prefix" + i; // Creates new String object each iteration\n}\n\n// Good\nStringBuilder sb = new StringBuilder("prefix");\nint originalLength = sb.length();\nfor (int i = 0; i < n; i++) {\n    sb.setLength(originalLength);\n    sb.append(i);\n    String temp = sb.toString();\n}\n'})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"interview-preparation-checklist",children:"Interview Preparation Checklist"}),"\n",(0,r.jsx)(e.h3,{id:"must-know-algorithms",children:"Must-Know Algorithms"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"\u2705 Binary Search and its variants"}),"\n",(0,r.jsx)(e.li,{children:"\u2705 DFS and BFS traversals"}),"\n",(0,r.jsx)(e.li,{children:"\u2705 Quick Sort and Merge Sort"}),"\n",(0,r.jsx)(e.li,{children:"\u2705 Dynamic Programming patterns"}),"\n",(0,r.jsx)(e.li,{children:"\u2705 Two Pointers and Sliding Window"}),"\n",(0,r.jsx)(e.li,{children:"\u2705 Backtracking template"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"must-know-data-structures",children:"Must-Know Data Structures"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"\u2705 Arrays and Strings manipulation"}),"\n",(0,r.jsx)(e.li,{children:"\u2705 Linked List operations"}),"\n",(0,r.jsx)(e.li,{children:"\u2705 Stack and Queue applications"}),"\n",(0,r.jsx)(e.li,{children:"\u2705 Binary Trees and BST"}),"\n",(0,r.jsx)(e.li,{children:"\u2705 Hash Tables for lookups"}),"\n",(0,r.jsx)(e.li,{children:"\u2705 Heaps for priority operations"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"problem-solving-strategy",children:"Problem-Solving Strategy"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Understand"})," the problem completely"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Ask clarifying"})," questions about constraints"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Think"})," of brute force solution first"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Optimize"})," using appropriate data structures/algorithms"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Code"})," with clean, readable implementation"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Test"})," with edge cases and examples"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Analyze"})," time and space complexity"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"common-mistake-patterns-to-avoid",children:"Common Mistake Patterns to Avoid"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Off-by-one errors in loops and array access"}),"\n",(0,r.jsx)(e.li,{children:"Not handling null/empty inputs"}),"\n",(0,r.jsx)(e.li,{children:"Integer overflow in calculations"}),"\n",(0,r.jsx)(e.li,{children:"Modifying collection while iterating"}),"\n",(0,r.jsx)(e.li,{children:"Incorrect loop termination conditions"}),"\n",(0,r.jsx)(e.li,{children:"Not considering edge cases (empty, single element)"}),"\n"]})]})}function h(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(c,{...n})}):c(n)}}}]);