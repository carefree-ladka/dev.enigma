"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[64750],{28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>d});var r=t(96540);const o={},s=r.createContext(o);function i(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),r.createElement(s.Provider,{value:n},e.children)}},80391:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>i,default:()=>h,frontMatter:()=>s,metadata:()=>d,toc:()=>c});var r=t(74848),o=t(28453);const s={title:"React Lifecycle Methods"},i=void 0,d={id:"WebDev/React/LifeCycleMethods",title:"React Lifecycle Methods",description:"In React, lifecycle methods are hooks available in class components that allow you to run code at specific points in a component's lifecycle. These methods provide hooks for managing side effects, initializing data, and cleaning up resources. Here\u2019s a summary of the key lifecycle methods:",source:"@site/docs/WebDev/React/LifeCycleMethods.mdx",sourceDirName:"WebDev/React",slug:"/WebDev/React/LifeCycleMethods",permalink:"/docs/WebDev/React/LifeCycleMethods",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/WebDev/React/LifeCycleMethods.mdx",tags:[],version:"current",frontMatter:{title:"React Lifecycle Methods"},sidebar:"tutorialSidebar",previous:{title:"React Hooks Polyfills",permalink:"/docs/WebDev/React/HooksPolyfills"},next:{title:"PropTypes Validation",permalink:"/docs/WebDev/React/PropTyped"}},a={},c=[{value:"1. Mounting:",id:"1-mounting",level:2},{value:"When a component is being created and inserted into the DOM.",id:"when-a-component-is-being-created-and-inserted-into-the-dom",level:3},{value:"2. Updating:",id:"2-updating",level:2},{value:"When a component is being re-rendered as a result of changes to either its props or state.",id:"when-a-component-is-being-re-rendered-as-a-result-of-changes-to-either-its-props-or-state",level:3},{value:"3. Unmounting:",id:"3-unmounting",level:2},{value:"When a component is being removed from the DOM.",id:"when-a-component-is-being-removed-from-the-dom",level:3},{value:"4. Error Handling:",id:"4-error-handling",level:2},{value:"When there\u2019s an error during rendering, in a lifecycle method, or in the constructor of any child component.",id:"when-theres-an-error-during-rendering-in-a-lifecycle-method-or-in-the-constructor-of-any-child-component",level:3}];function l(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"In React, lifecycle methods are hooks available in class components that allow you to run code at specific points in a component's lifecycle. These methods provide hooks for managing side effects, initializing data, and cleaning up resources. Here\u2019s a summary of the key lifecycle methods:"}),"\n",(0,r.jsx)(n.h2,{id:"1-mounting",children:"1. Mounting:"}),"\n",(0,r.jsx)(n.h3,{id:"when-a-component-is-being-created-and-inserted-into-the-dom",children:"When a component is being created and inserted into the DOM."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"constructor(props)"})}),": Initializes the component's state and binds methods. It's called before the component is mounted."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"static getDerivedStateFromProps(nextProps, prevState)"})}),": Invoked right before rendering, both on the initial mount and on subsequent updates. It can return an object to update the state or ",(0,r.jsx)(n.code,{children:"null"})," to do nothing."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"render()"})}),": The core method that returns the JSX to render. It should be a pure function, returning the same output for the same props and state."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"componentDidMount()"})}),": Invoked immediately after a component is mounted. Ideal for making network requests, initializing third-party libraries, or setting up subscriptions."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"2-updating",children:"2. Updating:"}),"\n",(0,r.jsx)(n.h3,{id:"when-a-component-is-being-re-rendered-as-a-result-of-changes-to-either-its-props-or-state",children:"When a component is being re-rendered as a result of changes to either its props or state."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"static getDerivedStateFromProps(nextProps, prevState)"})}),": (Already mentioned under Mounting)"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"shouldComponentUpdate(nextProps, nextState)"})}),": Determines if the component should re-render. By default, it returns ",(0,r.jsx)(n.code,{children:"true"}),". It\u2019s used for performance optimization."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"render()"})}),": (Already mentioned under Mounting)"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"getSnapshotBeforeUpdate(prevProps, prevState)"})}),": Invoked right before the most recently rendered output is committed to the DOM. It can capture information (e.g., scroll position) from the DOM before it is potentially changed."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"componentDidUpdate(prevProps, prevState, snapshot)"})}),": Invoked immediately after updating occurs. It can be used for operations like network requests in response to prop or state changes. The ",(0,r.jsx)(n.code,{children:"snapshot"})," argument comes from ",(0,r.jsx)(n.code,{children:"getSnapshotBeforeUpdate"}),"."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"3-unmounting",children:"3. Unmounting:"}),"\n",(0,r.jsx)(n.h3,{id:"when-a-component-is-being-removed-from-the-dom",children:"When a component is being removed from the DOM."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"componentWillUnmount()"})}),": Invoked immediately before a component is unmounted and destroyed. It\u2019s used for cleanup tasks like invalidating timers, cancelling network requests, or cleaning up subscriptions."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"4-error-handling",children:"4. Error Handling:"}),"\n",(0,r.jsx)(n.h3,{id:"when-theres-an-error-during-rendering-in-a-lifecycle-method-or-in-the-constructor-of-any-child-component",children:"When there\u2019s an error during rendering, in a lifecycle method, or in the constructor of any child component."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"static getDerivedStateFromError(error)"})}),": Invoked when an error is thrown during rendering. It allows you to update the state to display an error message."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"componentDidCatch(error, info)"})}),": Invoked when an error is thrown. It can be used to log error information or perform error handling."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-JavaScript",children:"import React from 'react';\n\nclass MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { data: null };\n  }\n\n  static getDerivedStateFromProps(nextProps, prevState) {\n    // Update state based on props\n    if (nextProps.someValue !== prevState.data) {\n      return { data: nextProps.someValue };\n    }\n    return null;\n  }\n\n  componentDidMount() {\n    // Fetch data or setup\n    fetchData().then(data => this.setState({ data }));\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    // Prevent re-render if data hasn't changed\n    return nextState.data !== this.state.data;\n  }\n\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    // Capture DOM info before the update\n    return null;\n  }\n\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    // Handle updates\n  }\n\n  componentWillUnmount() {\n    // Cleanup\n  }\n\n  render() {\n    return <div>{this.state.data}</div>;\n  }\n}\n\nexport default MyComponent;\n"})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}}}]);