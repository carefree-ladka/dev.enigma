"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[7610],{678:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>h,contentTitle:()=>o,default:()=>c,frontMatter:()=>r,metadata:()=>d,toc:()=>a});var s=t(4848),i=t(8453);const r={title:"0-1 BFS Algorithm"},o=void 0,d={id:"DSA/01BFS",title:"0-1 BFS Algorithm",description:"0-1 BFS Algorithm",source:"@site/docs/DSA/01BFS.mdx",sourceDirName:"DSA",slug:"/DSA/01BFS",permalink:"/js.enigma/docs/DSA/01BFS",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/01BFS.mdx",tags:[],version:"current",frontMatter:{title:"0-1 BFS Algorithm"},sidebar:"tutorialSidebar",previous:{title:"Two Pointer",permalink:"/js.enigma/docs/DSA/DSA Cheatsheets/Two Pointer"},next:{title:"2D Matrix Graph Algorithms",permalink:"/js.enigma/docs/DSA/2DGraphAlgorithms"}},h={},a=[{value:"0-1 BFS Algorithm",id:"0-1-bfs-algorithm",level:2},{value:"Concept",id:"concept",level:3},{value:"Algorithm Steps",id:"algorithm-steps",level:3},{value:"Code Example",id:"code-example",level:3},{value:"Problems:",id:"problems",level:2}];function l(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"0-1-bfs-algorithm",children:"0-1 BFS Algorithm"}),"\n",(0,s.jsx)(n.p,{children:"0-1 BFS is a specialized version of the Breadth-First Search (BFS) algorithm designed to handle graphs where edge weights are either 0 or 1. It efficiently finds the shortest path in such graphs by leveraging a double-ended queue (deque) to maintain a more nuanced approach to edge weights."}),"\n",(0,s.jsx)(n.h3,{id:"concept",children:"Concept"}),"\n",(0,s.jsx)(n.p,{children:"In 0-1 BFS:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Edge Weights"}),": The edge weights are either 0 or 1."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Data Structure"}),": A double-ended queue (deque) is used to optimize the traversal. Nodes connected by an edge with weight 0 are added to the front of the deque, and nodes connected by an edge with weight 1 are added to the back."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Objective"}),": To find the shortest path from a source node to all other nodes in the graph."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"algorithm-steps",children:"Algorithm Steps"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Initialize"}),": Start by initializing the distance for each node as infinity, except for the source node which is set to 0. Use a deque to manage the nodes to be processed."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Process Nodes"}),": Dequeue nodes and update their neighbors based on edge weights.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"For an edge with weight 0, update the neighbor\u2019s distance and add it to the front of the deque."}),"\n",(0,s.jsx)(n.li,{children:"For an edge with weight 1, update the neighbor\u2019s distance and add it to the back of the deque."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Continue"}),": Repeat the process until all nodes are processed."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"code-example",children:"Code Example"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"JavaScript Implementation"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const { Deque } = require('collections/deque');\n\n/**\n * Compute the shortest path distances from the source node using 0-1 BFS.\n * @param {number[][]} graph - Adjacency list representation of the graph with edge weights 0 or 1.\n * @param {number} source - The source node.\n * @return {number[]} - Array of shortest path distances from the source.\n */\nconst zeroOneBFS = (graph, source) => {\n  const n = graph.length;\n  const distances = Array(n).fill(Infinity);\n  const deque = new Deque();\n\n  distances[source] = 0;\n  deque.pushFront(source);\n\n  while (deque.length > 0) {\n    const node = deque.shift();\n    \n    for (const [neighbor, weight] of graph[node]) {\n      const newDist = distances[node] + weight;\n      if (newDist < distances[neighbor]) {\n        distances[neighbor] = newDist;\n        if (weight === 0) {\n          deque.pushFront(neighbor);\n        } else {\n          deque.pushBack(neighbor);\n        }\n      }\n    }\n  }\n\n  return distances;\n};\n"})}),"\n",(0,s.jsx)(n.h2,{id:"problems",children:"Problems:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/minimum-obstacle-removal-to-reach-corner",children:"https://leetcode.com/problems/minimum-obstacle-removal-to-reach-corner"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/",children:"https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/find-a-safe-walk-through-a-grid/description/",children:"https://leetcode.com/problems/find-a-safe-walk-through-a-grid/description/"})}),"\n"]})]})}function c(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>d});var s=t(6540);const i={},r=s.createContext(i);function o(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);