"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[4104],{3509:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>m,frontMatter:()=>i,metadata:()=>l,toc:()=>u});var r=t(4848),s=t(8453);const i={},o="Multiset in JavaScript",l={id:"DSA/MultiSet",title:"Multiset in JavaScript",description:"A Multiset (also known as a bag) is a data structure similar to a set, but it allows duplicate elements. In a multiset, each element can appear multiple times, and you can efficiently track the number of occurrences of each element.",source:"@site/docs/DSA/MultiSet.mdx",sourceDirName:"DSA",slug:"/DSA/MultiSet",permalink:"/js.enigma/docs/DSA/MultiSet",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/MultiSet.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Morris Traversal for Binary Trees",permalink:"/js.enigma/docs/DSA/MorrisTraversal"},next:{title:"Multi-source BFS Algorithm",permalink:"/js.enigma/docs/DSA/MultiSourceBFS"}},c={},u=[{value:"Implementation",id:"implementation",level:2}];function a(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"multiset-in-javascript",children:"Multiset in JavaScript"})}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.strong,{children:"Multiset"})," (also known as a ",(0,r.jsx)(n.strong,{children:"bag"}),") is a data structure similar to a set, but it allows duplicate elements. In a multiset, each element can appear multiple times, and you can efficiently track the number of occurrences of each element."]}),"\n",(0,r.jsxs)(n.p,{children:["This implementation of a multiset is built using a JavaScript ",(0,r.jsx)(n.code,{children:"Map"}),", where each element is stored as a key, and the number of times it appears is stored as the corresponding value."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"1. Efficient Storage:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Uses Map to store element-frequency pairs"}),"\n",(0,r.jsx)(n.li,{children:"O(1) lookup and modification operations"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"2. Complete Operations Set:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Basic:"})," add, remove, count, has"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Set operations:"})," union, intersection, difference"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Utility:"})," toArray, uniqueElements, toString"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"3. Performance:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"add/remove: O(1)"}),"\n",(0,r.jsx)(n.li,{children:"count/has: O(1)"}),"\n",(0,r.jsx)(n.li,{children:"union/intersection/difference: O(n)"}),"\n",(0,r.jsx)(n.li,{children:"toArray: O(n)"}),"\n",(0,r.jsx)(n.li,{children:"where n is number of unique elements"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"4. Memory Efficient:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Only stores unique elements with their counts"}),"\n",(0,r.jsx)(n.li,{children:"Automatically cleans up when count reaches 0"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"5. Iterator Support:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Can be used in for...of loops"}),"\n",(0,r.jsx)(n.li,{children:"Yields each element according to its multiplicity"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"6. Flexible API:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Supports multiple element addition/removal"}),"\n",(0,r.jsx)(n.li,{children:"Provides both multiset and set-like operations"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"implementation",children:"Implementation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-JavaScript",children:"class MultiSet {\r\n  constructor(iterable = []) {\r\n    // Using Map to store element frequencies\r\n    this.elements = new Map();\r\n    this.size = 0;\r\n\r\n    // Initialize with iterable if provided\r\n    for (const item of iterable) {\r\n      this.add(item);\r\n    }\r\n  }\r\n\r\n  // Add element to multiset\r\n  add(element, count = 1) {\r\n    if (count <= 0) return false;\r\n\r\n    const currentCount = this.elements.get(element) || 0;\r\n    this.elements.set(element, currentCount + count);\r\n    this.size += count;\r\n    return true;\r\n  }\r\n\r\n  // Remove element from multiset\r\n  remove(element, count = 1) {\r\n    if (count <= 0) return false;\r\n\r\n    const currentCount = this.elements.get(element) || 0;\r\n    if (currentCount === 0) return false;\r\n\r\n    const newCount = Math.max(0, currentCount - count);\r\n    if (newCount === 0) {\r\n      this.elements.delete(element);\r\n    } else {\r\n      this.elements.set(element, newCount);\r\n    }\r\n\r\n    this.size -= (currentCount - newCount);\r\n    return true;\r\n  }\r\n\r\n  // Remove all occurrences of an element\r\n  removeAll(element) {\r\n    const count = this.elements.get(element) || 0;\r\n    if (count > 0) {\r\n      this.size -= count;\r\n      this.elements.delete(element);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  // Get count of element\r\n  count(element) {\r\n    return this.elements.get(element) || 0;\r\n  }\r\n\r\n  // Check if element exists\r\n  has(element) {\r\n    return this.elements.has(element);\r\n  }\r\n\r\n  // Get total number of elements (including duplicates)\r\n  getSize() {\r\n    return this.size;\r\n  }\r\n\r\n  // Get number of unique elements\r\n  getUniqueSize() {\r\n    return this.elements.size;\r\n  }\r\n\r\n  // Clear the multiset\r\n  clear() {\r\n    this.elements.clear();\r\n    this.size = 0;\r\n  }\r\n\r\n  // Convert to array (with duplicates)\r\n  toArray() {\r\n    const result = [];\r\n    for (const [element, count] of this.elements) {\r\n      result.push(...Array(count).fill(element));\r\n    }\r\n    return result;\r\n  }\r\n\r\n  // Get array of unique elements\r\n  uniqueElements() {\r\n    return Array.from(this.elements.keys());\r\n  }\r\n\r\n  // Union with another multiset\r\n  union(other) {\r\n    const result = new MultiSet(this.toArray());\r\n    for (const [element, count] of other.elements) {\r\n      const currentCount = this.count(element);\r\n      if (count > currentCount) {\r\n        result.add(element, count - currentCount);\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  // Intersection with another multiset\r\n  intersection(other) {\r\n    const result = new MultiSet();\r\n    for (const [element, count] of this.elements) {\r\n      const otherCount = other.count(element);\r\n      if (otherCount > 0) {\r\n        result.add(element, Math.min(count, otherCount));\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  // Difference with another multiset\r\n  difference(other) {\r\n    const result = new MultiSet();\r\n    for (const [element, count] of this.elements) {\r\n      const otherCount = other.count(element);\r\n      const diffCount = count - otherCount;\r\n      if (diffCount > 0) {\r\n        result.add(element, diffCount);\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  // Check if this multiset is subset of another\r\n  isSubsetOf(other) {\r\n    for (const [element, count] of this.elements) {\r\n      if (other.count(element) < count) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  // Iterator implementation\r\n  *[Symbol.iterator]() {\r\n    for (const [element, count] of this.elements) {\r\n      for (let i = 0; i < count; i++) {\r\n        yield element;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Create string representation\r\n  toString() {\r\n    const elements = Array.from(this.elements.entries())\r\n      .map(([element, count]) => `${element}${count > 1 ? `(${count})` : ''}`)\r\n      .join(', ');\r\n    return `[${elements}]`;\r\n  }\r\n}\r\n\r\n// Create a new MultiSet\r\nconst ms = new MultiSet([1, 2, 2, 3, 3, 3]);\r\n\r\n// Basic operations\r\nconsole.log(ms.toString());        // [1(1), 2(2), 3(3)]\r\nconsole.log(ms.count(2));          // 2\r\nconsole.log(ms.getSize());         // 6\r\nconsole.log(ms.getUniqueSize());   // 3\r\n\r\n// Add and remove elements\r\nms.add(4, 2);                      // Add 2 occurrences of 4\r\nms.remove(2, 1);                   // Remove 1 occurrence of 2\r\nconsole.log(ms.toString());        // [1(1), 2(1), 3(3), 4(2)]\r\n\r\n// Set operations\r\nconst ms2 = new MultiSet([2, 2, 3, 4]);\r\nconst union = ms.union(ms2);\r\nconst intersection = ms.intersection(ms2);\r\nconst difference = ms.difference(ms2);\r\n\r\n// Iterate over elements (including duplicates)\r\nfor (const element of ms) {\r\n  console.log(element);\r\n}\n"})})]})}function m(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>l});var r=t(6540);const s={},i=r.createContext(s);function o(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);