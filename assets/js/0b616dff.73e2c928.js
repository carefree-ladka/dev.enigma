"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[968],{797:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>u,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>o,toc:()=>c});var t=n(4848),i=n(8453);const s={},a="Circular Buffer",o={id:"DSA/CircularBuffer",title:"Circular Buffer",description:"A circular buffer, also known as a ring buffer, is a fixed-size data structure that operates in a circular manner, meaning that once the buffer reaches the end, it wraps around to the beginning. It is commonly used in situations where data is produced and consumed at different rates, such as in streaming data or buffering in IO operations.",source:"@site/docs/DSA/CircularBuffer.mdx",sourceDirName:"DSA",slug:"/DSA/CircularBuffer",permalink:"/js.enigma/docs/DSA/CircularBuffer",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/CircularBuffer.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Bucket Sort",permalink:"/js.enigma/docs/DSA/BucketSort"},next:{title:"Counting Sort",permalink:"/js.enigma/docs/DSA/CountingSort"}},u={},c=[];function f(e){const r={code:"code",h1:"h1",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.header,{children:(0,t.jsx)(r.h1,{id:"circular-buffer",children:"Circular Buffer"})}),"\n",(0,t.jsx)(r.p,{children:"A circular buffer, also known as a ring buffer, is a fixed-size data structure that operates in a circular manner, meaning that once the buffer reaches the end, it wraps around to the beginning. It is commonly used in situations where data is produced and consumed at different rates, such as in streaming data or buffering in IO operations."}),"\n",(0,t.jsx)(r.h1,{id:"key-properties-of-a-circular-buffer",children:"Key Properties of a Circular Buffer"}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"1. Fixed Size"})," : The buffer has a maximum capacity, and once it is full, new data overwrites the oldest data if no other operation is performed."]}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"2. Wraparound Behavior"})," : When you reach the end of the buffer, it wraps around to the beginning (first position) to continue writing or reading data."]}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"3. Efficient Operations"})," : Access to the head and tail (read and write operations) is efficient, typically constant time O(1)."]}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"4. Two Pointers"}),"\r\nA circular buffer generally uses two pointers:"]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Head pointer"}),": Points to the position where data is to be read."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Tail pointer"}),": Points to the position where new data will be written."]}),"\n"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-JavaScript",children:"class CircularBuffer {\r\n  constructor(size) {\r\n    this.size = size;\r\n    this.buffer = new Array(size);\r\n    this.head = 0;\r\n    this.tail = 0;\r\n    this.count = 0;\r\n  }\r\n\r\n  // Write data to the buffer\r\n  write(data) {\r\n    if (this.count === this.size) {\r\n      console.log('Buffer is full, overwriting data');\r\n      this.head = (this.head + 1) % this.size; // Overwrite the oldest data\r\n    } else {\r\n      this.count++;\r\n    }\r\n    this.buffer[this.tail] = data;\r\n    this.tail = (this.tail + 1) % this.size;\r\n  }\r\n\r\n  // Read data from the buffer\r\n  read() {\r\n    if (this.count === 0) {\r\n      console.log('Buffer is empty');\r\n      return null;\r\n    }\r\n    const data = this.buffer[this.head];\r\n    this.head = (this.head + 1) % this.size;\r\n    this.count--;\r\n    return data;\r\n  }\r\n\r\n  // Check if the buffer is full\r\n  isFull() {\r\n    return this.count === this.size;\r\n  }\r\n\r\n  // Check if the buffer is empty\r\n  isEmpty() {\r\n    return this.count === 0;\r\n  }\r\n\r\n  // Peek at the data at the head of the buffer\r\n  peek() {\r\n    if (this.count === 0) {\r\n      console.log('Buffer is empty');\r\n      return null;\r\n    }\r\n    return this.buffer[this.head];\r\n  }\r\n}\r\n\r\n// Usage\r\nconst buffer = new CircularBuffer(3);\r\nbuffer.write(10);\r\nbuffer.write(20);\r\nbuffer.write(30);\r\nconsole.log(buffer.read()); // 10\r\nbuffer.write(40); // Overwrites 20\r\nconsole.log(buffer.read()); // 20 (overwritten)\r\nconsole.log(buffer.peek()); // 30\n"})})]})}function d(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(f,{...e})}):f(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>a,x:()=>o});var t=n(6540);const i={},s=t.createContext(i);function a(e){const r=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function o(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(s.Provider,{value:r},e.children)}}}]);