"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[9377],{6179:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>t,metadata:()=>a,toc:()=>c});var r=n(4848),o=n(8453);const t={title:"Operating Systems"},i=void 0,a={id:"College Revision/OperatingSystems",title:"Operating Systems",description:"1. Deadlock",source:"@site/docs/College Revision/OperatingSystems.mdx",sourceDirName:"College Revision",slug:"/College Revision/OperatingSystems",permalink:"/js.enigma/docs/College Revision/OperatingSystems",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/College Revision/OperatingSystems.mdx",tags:[],version:"current",frontMatter:{title:"Operating Systems"},sidebar:"tutorialSidebar",previous:{title:"Object-Oriented Programming (OOP)",permalink:"/js.enigma/docs/College Revision/OOPS"},next:{title:"Web Development",permalink:"/js.enigma/docs/category/web-development"}},l={},c=[{value:"1. Deadlock",id:"1-deadlock",level:2},{value:"2. Virtual Memory",id:"2-virtual-memory",level:2},{value:"Components:",id:"components",level:3},{value:"Page Replacement Algorithms:",id:"page-replacement-algorithms",level:3},{value:"Example:",id:"example",level:3},{value:"3. Semaphores",id:"3-semaphores",level:2},{value:"Types of Semaphores:",id:"types-of-semaphores",level:3},{value:"Operations:",id:"operations",level:3}];function d(e){const s={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.h2,{id:"1-deadlock",children:"1. Deadlock"}),"\n",(0,r.jsx)(s.p,{children:"Deadlock is a situation in operating systems where two or more processes are blocked forever because they are waiting for each other to release resources."}),"\n",(0,r.jsx)(s.p,{children:"Conditions for Deadlock:"}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"1. Mutual Exclusion:"})," At least one resource must be held in a non-shareable mode (i.e., only one process can use the resource at any given time)."]}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"2. Hold and Wait:"})," A process is holding at least one resource and is waiting to acquire additional resources that are currently being held by other processes."]}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"3. No Preemption:"})," Resources cannot be preempted (taken away) from processes; they must be released voluntarily."]}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"4. Circular Wait:"})," A set of processes exists such that each process is waiting for a resource held by the next process in the set."]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Deadlock Prevention:"})}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Avoiding Circular Wait:"})," One strategy is to impose a total order on all resources and require that processes request resources in an increasing order of enumeration."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Preemptive Resource Allocation:"})," If a process is holding resources and cannot proceed, the system can preempt its resources and give them to other processes."]}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"2-virtual-memory",children:"2. Virtual Memory"}),"\n",(0,r.jsx)(s.p,{children:"Virtual memory allows programs to execute without requiring all of their data to be loaded into physical memory at once. It uses a combination of physical memory (RAM) and disk storage to create the illusion of a large, contiguous block of memory."}),"\n",(0,r.jsx)(s.h3,{id:"components",children:"Components:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Page Table"}),": Maps virtual memory addresses to physical addresses."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Paging"}),": The memory is divided into fixed-size blocks called pages. When a process accesses a page not currently in memory, a page fault occurs, and the operating system must load the required page from disk."]}),"\n"]}),"\n",(0,r.jsx)(s.h3,{id:"page-replacement-algorithms",children:"Page Replacement Algorithms:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"LRU (Least Recently Used)"}),": Replaces the page that hasn\u2019t been used for the longest period."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"FIFO (First In, First Out)"}),": Replaces the oldest page in memory."]}),"\n"]}),"\n",(0,r.jsx)(s.h3,{id:"example",children:"Example:"}),"\n",(0,r.jsx)(s.p,{children:"If your program accesses memory addresses outside the current physical memory allocation, the OS will trigger a page fault and load the required pages into memory."}),"\n",(0,r.jsx)(s.h2,{id:"3-semaphores",children:"3. Semaphores"}),"\n",(0,r.jsx)(s.p,{children:"A semaphore is a synchronization tool used to manage access to shared resources in a concurrent system. It maintains a count that is used to signal whether a resource is available or not."}),"\n",(0,r.jsx)(s.h3,{id:"types-of-semaphores",children:"Types of Semaphores:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Binary Semaphore (Mutex)"}),":"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["It has two values: ",(0,r.jsx)(s.code,{children:"0"})," or ",(0,r.jsx)(s.code,{children:"1"}),"."]}),"\n",(0,r.jsx)(s.li,{children:"Often used for mutual exclusion to ensure that only one process can access a critical section at a time."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Counting Semaphore"}),":"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"It can take any non-negative integer value."}),"\n",(0,r.jsx)(s.li,{children:"It is useful for managing a set of resources, such as managing access to a pool of database connections."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(s.h3,{id:"operations",children:"Operations:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"P (Proberen)"}),": Decreases the semaphore's value. If the value is less than 0, the process will block until the value is greater than or equal to 0."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"V (Verhogen)"}),": Increases the semaphore\u2019s value. If there are processes waiting on the semaphore, one of them is unblocked."]}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example Code (Binary Semaphore):"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-JavaScript",children:'let semaphore = 1;  // Semaphore initialized to 1\r\n\r\nfunction P() {\r\n  if (semaphore > 0) {\r\n    semaphore--;  // Enter critical section\r\n  } else {\r\n    console.log("Waiting...");\r\n  }\r\n}\r\n\r\nfunction V() {\r\n  semaphore++;  // Exit critical section\r\n}\n'})})]})}function h(e={}){const{wrapper:s}={...(0,o.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>i,x:()=>a});var r=n(6540);const o={},t=r.createContext(o);function i(e){const s=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),r.createElement(t.Provider,{value:s},e.children)}}}]);