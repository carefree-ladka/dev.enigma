"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[8231],{521:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>i,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>c});var r=t(4848),o=t(8453);const s={title:"React Lifecycle Methods"},i=void 0,a={id:"tutorial-extras/ReactQuestions/LifeCycleMethods",title:"React Lifecycle Methods",description:"In React, lifecycle methods are hooks available in class components that allow you to run code at specific points in a component's lifecycle. These methods provide hooks for managing side effects, initializing data, and cleaning up resources. Here\u2019s a summary of the key lifecycle methods:",source:"@site/docs/tutorial-extras/ReactQuestions/LifeCycleMethods.mdx",sourceDirName:"tutorial-extras/ReactQuestions",slug:"/tutorial-extras/ReactQuestions/LifeCycleMethods",permalink:"/js.enigma/docs/tutorial-extras/ReactQuestions/LifeCycleMethods",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/tutorial-extras/ReactQuestions/LifeCycleMethods.mdx",tags:[],version:"current",frontMatter:{title:"React Lifecycle Methods"},sidebar:"tutorialSidebar",previous:{title:"Error Boundary",permalink:"/js.enigma/docs/tutorial-extras/ReactQuestions/ErrorBoundary"},next:{title:"Redux vs Context API",permalink:"/js.enigma/docs/tutorial-extras/ReactQuestions/ReduxVSContext"}},d={},c=[{value:"1. Mounting:",id:"1-mounting",level:2},{value:"When a component is being created and inserted into the DOM.",id:"when-a-component-is-being-created-and-inserted-into-the-dom",level:3},{value:"2. Updating:",id:"2-updating",level:2},{value:"When a component is being re-rendered as a result of changes to either its props or state.",id:"when-a-component-is-being-re-rendered-as-a-result-of-changes-to-either-its-props-or-state",level:3},{value:"3. Unmounting:",id:"3-unmounting",level:2},{value:"When a component is being removed from the DOM.",id:"when-a-component-is-being-removed-from-the-dom",level:3},{value:"4. Error Handling:",id:"4-error-handling",level:2},{value:"When there\u2019s an error during rendering, in a lifecycle method, or in the constructor of any child component.",id:"when-theres-an-error-during-rendering-in-a-lifecycle-method-or-in-the-constructor-of-any-child-component",level:3}];function l(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"In React, lifecycle methods are hooks available in class components that allow you to run code at specific points in a component's lifecycle. These methods provide hooks for managing side effects, initializing data, and cleaning up resources. Here\u2019s a summary of the key lifecycle methods:"}),"\n",(0,r.jsx)(n.h2,{id:"1-mounting",children:"1. Mounting:"}),"\n",(0,r.jsx)(n.h3,{id:"when-a-component-is-being-created-and-inserted-into-the-dom",children:"When a component is being created and inserted into the DOM."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"constructor(props)"})}),": Initializes the component's state and binds methods. It's called before the component is mounted."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"static getDerivedStateFromProps(nextProps, prevState)"})}),": Invoked right before rendering, both on the initial mount and on subsequent updates. It can return an object to update the state or ",(0,r.jsx)(n.code,{children:"null"})," to do nothing."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"render()"})}),": The core method that returns the JSX to render. It should be a pure function, returning the same output for the same props and state."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"componentDidMount()"})}),": Invoked immediately after a component is mounted. Ideal for making network requests, initializing third-party libraries, or setting up subscriptions."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"2-updating",children:"2. Updating:"}),"\n",(0,r.jsx)(n.h3,{id:"when-a-component-is-being-re-rendered-as-a-result-of-changes-to-either-its-props-or-state",children:"When a component is being re-rendered as a result of changes to either its props or state."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"static getDerivedStateFromProps(nextProps, prevState)"})}),": (Already mentioned under Mounting)"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"shouldComponentUpdate(nextProps, nextState)"})}),": Determines if the component should re-render. By default, it returns ",(0,r.jsx)(n.code,{children:"true"}),". It\u2019s used for performance optimization."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"render()"})}),": (Already mentioned under Mounting)"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"getSnapshotBeforeUpdate(prevProps, prevState)"})}),": Invoked right before the most recently rendered output is committed to the DOM. It can capture information (e.g., scroll position) from the DOM before it is potentially changed."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"componentDidUpdate(prevProps, prevState, snapshot)"})}),": Invoked immediately after updating occurs. It can be used for operations like network requests in response to prop or state changes. The ",(0,r.jsx)(n.code,{children:"snapshot"})," argument comes from ",(0,r.jsx)(n.code,{children:"getSnapshotBeforeUpdate"}),"."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"3-unmounting",children:"3. Unmounting:"}),"\n",(0,r.jsx)(n.h3,{id:"when-a-component-is-being-removed-from-the-dom",children:"When a component is being removed from the DOM."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"componentWillUnmount()"})}),": Invoked immediately before a component is unmounted and destroyed. It\u2019s used for cleanup tasks like invalidating timers, cancelling network requests, or cleaning up subscriptions."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"4-error-handling",children:"4. Error Handling:"}),"\n",(0,r.jsx)(n.h3,{id:"when-theres-an-error-during-rendering-in-a-lifecycle-method-or-in-the-constructor-of-any-child-component",children:"When there\u2019s an error during rendering, in a lifecycle method, or in the constructor of any child component."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"static getDerivedStateFromError(error)"})}),": Invoked when an error is thrown during rendering. It allows you to update the state to display an error message."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"componentDidCatch(error, info)"})}),": Invoked when an error is thrown. It can be used to log error information or perform error handling."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-JavaScript",children:"import React from 'react';\r\n\r\nclass MyComponent extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = { data: null };\r\n  }\r\n\r\n  static getDerivedStateFromProps(nextProps, prevState) {\r\n    // Update state based on props\r\n    if (nextProps.someValue !== prevState.data) {\r\n      return { data: nextProps.someValue };\r\n    }\r\n    return null;\r\n  }\r\n\r\n  componentDidMount() {\r\n    // Fetch data or setup\r\n    fetchData().then(data => this.setState({ data }));\r\n  }\r\n\r\n  shouldComponentUpdate(nextProps, nextState) {\r\n    // Prevent re-render if data hasn't changed\r\n    return nextState.data !== this.state.data;\r\n  }\r\n\r\n  getSnapshotBeforeUpdate(prevProps, prevState) {\r\n    // Capture DOM info before the update\r\n    return null;\r\n  }\r\n\r\n  componentDidUpdate(prevProps, prevState, snapshot) {\r\n    // Handle updates\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    // Cleanup\r\n  }\r\n\r\n  render() {\r\n    return <div>{this.state.data}</div>;\r\n  }\r\n}\r\n\r\nexport default MyComponent;\n"})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var r=t(6540);const o={},s=r.createContext(o);function i(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);