"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[8663],{7760:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>d,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>a});var t=r(4848),i=r(8453);const s={},d="Dequeue (Double-Ended Queue) Implementation Cheatsheet",o={id:"DSA/Dequeue",title:"Dequeue (Double-Ended Queue) Implementation Cheatsheet",description:"Basic Implementation",source:"@site/docs/DSA/Dequeue.mdx",sourceDirName:"DSA",slug:"/DSA/Dequeue",permalink:"/js.enigma/docs/DSA/Dequeue",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/Dequeue.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Depth-First Search (DFS) for Trees",permalink:"/js.enigma/docs/DSA/DFSTree"},next:{title:"Difference Array Technique",permalink:"/js.enigma/docs/DSA/DifferenceArray"}},l={},a=[{value:"Basic Implementation",id:"basic-implementation",level:2},{value:"Time Complexities",id:"time-complexities",level:2},{value:"Usage Examples",id:"usage-examples",level:2},{value:"Basic Operations",id:"basic-operations",level:3},{value:"Dequeue using DoublyLinkedList",id:"dequeue-using-doublylinkedlist",level:3},{value:"Common Applications",id:"common-applications",level:3},{value:"Sliding Window Maximum",id:"sliding-window-maximum",level:4},{value:"Palindrome Check",id:"palindrome-check",level:4},{value:"Best Practices",id:"best-practices",level:2},{value:"Memory-Efficient Version",id:"memory-efficient-version",level:2},{value:"Common Pitfalls",id:"common-pitfalls",level:2},{value:"Performance Tips",id:"performance-tips",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"dequeue-double-ended-queue-implementation-cheatsheet",children:"Dequeue (Double-Ended Queue) Implementation Cheatsheet"})}),"\n",(0,t.jsx)(n.h2,{id:"basic-implementation",children:"Basic Implementation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"class Deque {\r\n    constructor() {\r\n        this.items = {};\r\n        this.frontIndex = 0;\r\n        this.backIndex = 0;\r\n    }\r\n\r\n    addFront(item) {\r\n        this.frontIndex--;\r\n        this.items[this.frontIndex] = item;\r\n    }\r\n\r\n    addBack(item) {\r\n        this.items[this.backIndex] = item;\r\n        this.backIndex++;\r\n    }\r\n\r\n    removeFront() {\r\n        if (this.isEmpty()) return undefined;\r\n        const item = this.items[this.frontIndex];\r\n        delete this.items[this.frontIndex];\r\n        this.frontIndex++;\r\n        return item;\r\n    }\r\n\r\n    removeBack() {\r\n        if (this.isEmpty()) return undefined;\r\n        this.backIndex--;\r\n        const item = this.items[this.backIndex];\r\n        delete this.items[this.backIndex];\r\n        return item;\r\n    }\r\n\r\n    peekFront() {\r\n        if (this.isEmpty()) return undefined;\r\n        return this.items[this.frontIndex];\r\n    }\r\n\r\n    peekBack() {\r\n        if (this.isEmpty()) return undefined;\r\n        return this.items[this.backIndex - 1];\r\n    }\r\n\r\n    isEmpty() {\r\n        return this.backIndex - this.frontIndex === 0;\r\n    }\r\n\r\n    size() {\r\n        return this.backIndex - this.frontIndex;\r\n    }\r\n\r\n    clear() {\r\n        this.items = {};\r\n        this.frontIndex = 0;\r\n        this.backIndex = 0;\r\n    }\r\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"time-complexities",children:"Time Complexities"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Operation"}),(0,t.jsx)(n.th,{children:"Time Complexity"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"addFront"}),(0,t.jsx)(n.td,{children:"O(1)"}),(0,t.jsx)(n.td,{children:"Add item to front"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"addBack"}),(0,t.jsx)(n.td,{children:"O(1)"}),(0,t.jsx)(n.td,{children:"Add item to back"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"removeFront"}),(0,t.jsx)(n.td,{children:"O(1)"}),(0,t.jsx)(n.td,{children:"Remove and return front item"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"removeBack"}),(0,t.jsx)(n.td,{children:"O(1)"}),(0,t.jsx)(n.td,{children:"Remove and return back item"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"peekFront"}),(0,t.jsx)(n.td,{children:"O(1)"}),(0,t.jsx)(n.td,{children:"Return front item without removing"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"peekBack"}),(0,t.jsx)(n.td,{children:"O(1)"}),(0,t.jsx)(n.td,{children:"Return back item without removing"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"isEmpty"}),(0,t.jsx)(n.td,{children:"O(1)"}),(0,t.jsx)(n.td,{children:"Check if deque is empty"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"size"}),(0,t.jsx)(n.td,{children:"O(1)"}),(0,t.jsx)(n.td,{children:"Get number of items"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"clear"}),(0,t.jsx)(n.td,{children:"O(1)"}),(0,t.jsx)(n.td,{children:"Remove all items"})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,t.jsx)(n.h3,{id:"basic-operations",children:"Basic Operations"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const deque = new Deque();\r\n\r\n// Adding elements\r\ndeque.addFront(1);    // [1]\r\ndeque.addBack(2);     // [1, 2]\r\ndeque.addFront(0);    // [0, 1, 2]\r\n\r\n// Removing elements\r\ndeque.removeFront();  // returns 0, deque is [1, 2]\r\ndeque.removeBack();   // returns 2, deque is [1]\r\n\r\n// Peeking elements\r\ndeque.peekFront();    // returns 1\r\ndeque.peekBack();     // returns 1\n"})}),"\n",(0,t.jsx)(n.h3,{id:"dequeue-using-doublylinkedlist",children:"Dequeue using DoublyLinkedList"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-JavaScript",children:"class Node {\r\n  constructor(value) {\r\n    this.value = value;\r\n    this.prev = null; // Pointer to the previous node\r\n    this.next = null; // Pointer to the next node\r\n  }\r\n}\r\n\r\nclass Deque {\r\n  constructor() {\r\n    this.front = null; // Pointer to the front node\r\n    this.rear = null;  // Pointer to the rear node\r\n    this.size = 0;     // Size of the deque\r\n  }\r\n\r\n  // Add an item at the front\r\n  addFront(value) {\r\n    const newNode = new Node(value);\r\n    if (this.isEmpty()) {\r\n      this.front = this.rear = newNode;\r\n    } else {\r\n      newNode.next = this.front;\r\n      this.front.prev = newNode;\r\n      this.front = newNode;\r\n    }\r\n    this.size++;\r\n  }\r\n\r\n  // Add an item at the rear\r\n  addRear(value) {\r\n    const newNode = new Node(value);\r\n    if (this.isEmpty()) {\r\n      this.front = this.rear = newNode;\r\n    } else {\r\n      newNode.prev = this.rear;\r\n      this.rear.next = newNode;\r\n      this.rear = newNode;\r\n    }\r\n    this.size++;\r\n  }\r\n\r\n  // Remove an item from the front\r\n  removeFront() {\r\n    if (this.isEmpty()) return null;  \r\n    const removedValue = this.front.value;\r\n    this.front = this.front.next;\r\n    if (this.front) {\r\n      this.front.prev = null;\r\n    } else {\r\n      this.rear = null; // Deque is now empty\r\n    }\r\n    this.size--;\r\n    return removedValue;\r\n  }\r\n\r\n  // Remove an item from the rear\r\n  removeRear() {\r\n    if (this.size === 0) {\r\n      return null; // Deque is empty\r\n    }\r\n    const removedValue = this.rear.value;\r\n    this.rear = this.rear.prev;\r\n    if (this.rear) {\r\n      this.rear.next = null;\r\n    } else {\r\n      this.front = null; // Deque is now empty\r\n    }\r\n    this.size--;\r\n    return removedValue;\r\n  }\r\n\r\n  // Get the size of the deque\r\n  getSize = () => this.size;\r\n\r\n  // Check if the deque is empty\r\n  isEmpty = () => this.size === 0;\r\n\r\n  // Peek at the front item\r\n  peekFront = () => this.front ? this.front.value : null;\r\n\r\n  // Peek at the rear item\r\n  peekRear = () => this.rear ? this.rear.value : null;\r\n}\r\n\r\n// Example usage\r\nconst deque = new Deque();\r\ndeque.addFront(10);\r\ndeque.addRear(20);\r\nconsole.log(deque.peekFront()); // 10\r\nconsole.log(deque.peekRear());  // 20\r\nconsole.log(deque.removeFront()); // 10\r\nconsole.log(deque.removeRear());  // 20\r\nconsole.log(deque.isEmpty()); // true\n"})}),"\n",(0,t.jsx)(n.h3,{id:"common-applications",children:"Common Applications"}),"\n",(0,t.jsx)(n.h4,{id:"sliding-window-maximum",children:"Sliding Window Maximum"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function maxSlidingWindow(nums, k) {\r\n    const deque = new Deque();\r\n    const result = [];\r\n    \r\n    for (let i = 0; i < nums.length; i++) {\r\n        // Remove elements outside window\r\n        while (!deque.isEmpty() && deque.peekFront() < i - k + 1) {\r\n            deque.removeFront();\r\n        }\r\n        \r\n        // Remove smaller elements\r\n        while (!deque.isEmpty() && nums[deque.peekBack()] < nums[i]) {\r\n            deque.removeBack();\r\n        }\r\n        \r\n        deque.addBack(i);\r\n        \r\n        // Add to result if window has reached size k\r\n        if (i >= k - 1) {\r\n            result.push(nums[deque.peekFront()]);\r\n        }\r\n    }\r\n    \r\n    return result;\r\n}\n"})}),"\n",(0,t.jsx)(n.h4,{id:"palindrome-check",children:"Palindrome Check"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function isPalindrome(str) {\r\n    const deque = new Deque();\r\n    \r\n    // Add all characters to deque\r\n    for (let char of str) {\r\n        deque.addBack(char);\r\n    }\r\n    \r\n    // Compare characters from both ends\r\n    while (deque.size() > 1) {\r\n        if (deque.removeFront() !== deque.removeBack()) {\r\n            return false;\r\n        }\r\n    }\r\n    \r\n    return true;\r\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Use object-based implementation for O(1) operations"}),"\n",(0,t.jsx)(n.li,{children:"Maintain front and back indices for efficient operations"}),"\n",(0,t.jsx)(n.li,{children:"Handle edge cases (empty deque, single element)"}),"\n",(0,t.jsx)(n.li,{children:"Implement size tracking for quick length checks"}),"\n",(0,t.jsx)(n.li,{children:"Clear references to prevent memory leaks"}),"\n",(0,t.jsx)(n.li,{children:"Use type checking for robust implementation"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"memory-efficient-version",children:"Memory-Efficient Version"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"class CompactDeque {\r\n    constructor() {\r\n        this.items = new Array(16);  // Initial capacity\r\n        this.front = 8;              // Start in middle\r\n        this.back = 8;\r\n        this.capacity = 16;\r\n    }\r\n\r\n    resize(newCapacity) {\r\n        const newItems = new Array(newCapacity);\r\n        const size = this.size();\r\n        const newFront = Math.floor((newCapacity - size) / 2);\r\n        \r\n        for (let i = 0; i < size; i++) {\r\n            newItems[newFront + i] = this.items[(this.front + i) % this.capacity];\r\n        }\r\n        \r\n        this.items = newItems;\r\n        this.capacity = newCapacity;\r\n        this.front = newFront;\r\n        this.back = newFront + size;\r\n    }\r\n\r\n    addFront(item) {\r\n        if (this.front === 0) {\r\n            this.resize(this.capacity * 2);\r\n        }\r\n        this.front--;\r\n        this.items[this.front] = item;\r\n    }\r\n\r\n    addBack(item) {\r\n        if (this.back === this.capacity) {\r\n            this.resize(this.capacity * 2);\r\n        }\r\n        this.items[this.back] = item;\r\n        this.back++;\r\n    }\r\n\r\n    size() {\r\n        return this.back - this.front;\r\n    }\r\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"common-pitfalls",children:"Common Pitfalls"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"\u274c Using array shift/unshift operations (O(n) complexity)"}),"\n",(0,t.jsx)(n.li,{children:"\u274c Not handling empty deque cases"}),"\n",(0,t.jsx)(n.li,{children:"\u274c Forgetting to update indices after operations"}),"\n",(0,t.jsx)(n.li,{children:"\u274c Not cleaning up removed elements"}),"\n",(0,t.jsx)(n.li,{children:"\u274c Inefficient resizing strategies"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"performance-tips",children:"Performance Tips"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"\u2705 Use object/array implementation instead of linked list"}),"\n",(0,t.jsx)(n.li,{children:"\u2705 Implement lazy cleanup for removed elements"}),"\n",(0,t.jsx)(n.li,{children:"\u2705 Use power-of-two capacity for efficient resizing"}),"\n",(0,t.jsx)(n.li,{children:"\u2705 Maintain indices instead of restructuring data"}),"\n",(0,t.jsx)(n.li,{children:"\u2705 Batch operations when possible"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>d,x:()=>o});var t=r(6540);const i={},s=t.createContext(i);function d(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:d(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);