"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[6525],{13944:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>d});var i=s(74848),t=s(28453);const r={},a="System Design Fundamentals",l={id:"Frontend System Design/SystemDesignFundamentals",title:"System Design Fundamentals",description:"1. Key Characteristics of Distributed Systems",source:"@site/docs/Frontend System Design/SystemDesignFundamentals.mdx",sourceDirName:"Frontend System Design",slug:"/Frontend System Design/SystemDesignFundamentals",permalink:"/dev.enigma/docs/Frontend System Design/SystemDesignFundamentals",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/Frontend System Design/SystemDesignFundamentals.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Different Styling Techniques",permalink:"/dev.enigma/docs/Frontend System Design/StyleTechnoques"},next:{title:"Low Level Design",permalink:"/dev.enigma/docs/category/low-level-design"}},c={},d=[{value:"1. Key Characteristics of Distributed Systems",id:"1-key-characteristics-of-distributed-systems",level:2},{value:"Scalability",id:"scalability",level:3},{value:"Reliability",id:"reliability",level:3},{value:"2. Load Balancing",id:"2-load-balancing",level:2},{value:"Algorithms:",id:"algorithms",level:3},{value:"3. Caching",id:"3-caching",level:2},{value:"Caching Strategies:",id:"caching-strategies",level:3},{value:"4. Data Partitioning",id:"4-data-partitioning",level:2},{value:"Types:",id:"types",level:3},{value:"5. Indexes",id:"5-indexes",level:2},{value:"Types:",id:"types-1",level:3},{value:"6. Proxies",id:"6-proxies",level:2},{value:"Types:",id:"types-2",level:3},{value:"7. Redundancy and Replication",id:"7-redundancy-and-replication",level:2},{value:"Strategies:",id:"strategies",level:3},{value:"8. SQL vs. NoSQL",id:"8-sql-vs-nosql",level:2},{value:"SQL (Relational)",id:"sql-relational",level:3},{value:"NoSQL",id:"nosql",level:3},{value:"9. CAP Theorem",id:"9-cap-theorem",level:2},{value:"10. PACELC Theorem",id:"10-pacelc-theorem",level:2},{value:"11. Consistent Hashing",id:"11-consistent-hashing",level:2},{value:"12. Real-time Communication Protocols",id:"12-real-time-communication-protocols",level:2},{value:"Long-Polling",id:"long-polling",level:3},{value:"How It Works:",id:"how-it-works",level:3},{value:"Key Characteristics:",id:"key-characteristics",level:3},{value:"Advantages:",id:"advantages",level:3},{value:"Disadvantages:",id:"disadvantages",level:3},{value:"Common Use Cases:",id:"common-use-cases",level:3},{value:"WebSockets",id:"websockets",level:3},{value:"How It Works:",id:"how-it-works-1",level:3},{value:"Key Characteristics:",id:"key-characteristics-1",level:3},{value:"Advantages:",id:"advantages-1",level:3},{value:"Disadvantages:",id:"disadvantages-1",level:3},{value:"Common Use Cases:",id:"common-use-cases-1",level:3},{value:"Server-Sent Events",id:"server-sent-events",level:3},{value:"How It Works:",id:"how-it-works-2",level:3},{value:"Key Characteristics:",id:"key-characteristics-2",level:3},{value:"Advantages:",id:"advantages-2",level:3},{value:"Disadvantages:",id:"disadvantages-2",level:3},{value:"Common Use Cases:",id:"common-use-cases-2",level:3},{value:"Comparison Table",id:"comparison-table",level:2},{value:"13. Bloom Filters",id:"13-bloom-filters",level:2},{value:"14. Quorum",id:"14-quorum",level:2},{value:"15. Leader and Follower",id:"15-leader-and-follower",level:2},{value:"16. Heartbeat",id:"16-heartbeat",level:2},{value:"17. Checksum",id:"17-checksum",level:2}];function o(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"system-design-fundamentals",children:"System Design Fundamentals"})}),"\n",(0,i.jsx)(n.h2,{id:"1-key-characteristics-of-distributed-systems",children:"1. Key Characteristics of Distributed Systems"}),"\n",(0,i.jsx)(n.h3,{id:"scalability",children:"Scalability"}),"\n",(0,i.jsx)(n.p,{children:"The ability of a system to handle increased load by adding resources."}),"\n",(0,i.jsx)(n.p,{children:"Types:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Vertical Scaling (Scale Up)"}),": Adding more power to existing machines"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Horizontal Scaling (Scale Out)"}),": Adding more machines"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"class ScalableSystem {\n  private nodes: Node[] = [];\n\n  addNode(node: Node): void {\n    this.nodes.push(node);\n    this.rebalanceLoad();\n  }\n\n  removeNode(nodeId: string): void {\n    this.nodes = this.nodes.filter(node => node.id !== nodeId);\n    this.rebalanceLoad();\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"reliability",children:"Reliability"}),"\n",(0,i.jsx)(n.p,{children:"The probability that a system will fail in a given period."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"class ReliableSystem {\n  calculateReliability(components: Component[]): number {\n    // For components in series\n    return components.reduce((acc, component) => \n      acc * component.reliability, 1);\n  }\n\n  calculateParallelReliability(components: Component[]): number {\n    // For components in parallel\n    return 1 - components.reduce((acc, component) => \n      acc * (1 - component.reliability), 1);\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"2-load-balancing",children:"2. Load Balancing"}),"\n",(0,i.jsx)(n.p,{children:"Distributes incoming traffic across multiple servers."}),"\n",(0,i.jsx)(n.h3,{id:"algorithms",children:"Algorithms:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Round Robin"}),"\n",(0,i.jsx)(n.li,{children:"Least Connections"}),"\n",(0,i.jsx)(n.li,{children:"Least Response Time"}),"\n",(0,i.jsx)(n.li,{children:"Hash-based"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"interface LoadBalancer {\n  servers: Server[];\n  \n  roundRobin(): Server;\n  leastConnections(): Server;\n  hashBased(key: string): Server;\n}\n\nclass WeightedRoundRobin implements LoadBalancer {\n  private currentIndex = 0;\n  \n  roundRobin(): Server {\n    const server = this.servers[this.currentIndex];\n    this.currentIndex = (this.currentIndex + 1) % this.servers.length;\n    return server;\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"3-caching",children:"3. Caching"}),"\n",(0,i.jsx)(n.p,{children:"Temporary storage layer for faster data access."}),"\n",(0,i.jsx)(n.h3,{id:"caching-strategies",children:"Caching Strategies:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Cache-Aside"}),"\n",(0,i.jsx)(n.li,{children:"Write-Through"}),"\n",(0,i.jsx)(n.li,{children:"Write-Behind"}),"\n",(0,i.jsx)(n.li,{children:"Refresh-Ahead"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"class CacheManager {\n  private cache: Map<string, any>;\n  private db: Database;\n\n  async get(key: string): Promise<any> {\n    // Cache-aside implementation\n    let data = this.cache.get(key);\n    if (!data) {\n      data = await this.db.get(key);\n      this.cache.set(key, data);\n    }\n    return data;\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"4-data-partitioning",children:"4. Data Partitioning"}),"\n",(0,i.jsx)(n.p,{children:"Splitting data across multiple machines."}),"\n",(0,i.jsx)(n.h3,{id:"types",children:"Types:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Horizontal Partitioning (Sharding)"}),"\n",(0,i.jsx)(n.li,{children:"Vertical Partitioning"}),"\n",(0,i.jsx)(n.li,{children:"Directory-Based Partitioning"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"class DataPartitioner {\n  private shardCount: number;\n\n  constructor(shardCount: number) {\n    this.shardCount = shardCount;\n  }\n\n  getShardId(key: string): number {\n    const hash = this.hashFunction(key);\n    return hash % this.shardCount;\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"5-indexes",children:"5. Indexes"}),"\n",(0,i.jsx)(n.p,{children:"Data structures to improve data retrieval speed."}),"\n",(0,i.jsx)(n.h3,{id:"types-1",children:"Types:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Primary Index"}),"\n",(0,i.jsx)(n.li,{children:"Secondary Index"}),"\n",(0,i.jsx)(n.li,{children:"Composite Index"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"class DatabaseIndex {\n  private index: Map<string, number[]>;\n\n  addToIndex(key: string, documentId: number): void {\n    if (!this.index.has(key)) {\n      this.index.set(key, []);\n    }\n    this.index.get(key).push(documentId);\n  }\n\n  search(key: string): number[] {\n    return this.index.get(key) || [];\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"6-proxies",children:"6. Proxies"}),"\n",(0,i.jsx)(n.p,{children:"Intermediate servers between clients and backend servers."}),"\n",(0,i.jsx)(n.h3,{id:"types-2",children:"Types:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Forward Proxy"}),"\n",(0,i.jsx)(n.li,{children:"Reverse Proxy"}),"\n",(0,i.jsx)(n.li,{children:"Load Balancer Proxy"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"class ReverseProxy {\n  private backends: string[];\n  private loadBalancer: LoadBalancer;\n\n  async handleRequest(request: Request): Promise<Response> {\n    const backend = this.loadBalancer.getBackend();\n    return await this.forwardRequest(backend, request);\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"7-redundancy-and-replication",children:"7. Redundancy and Replication"}),"\n",(0,i.jsx)(n.p,{children:"Creating and maintaining multiple copies of data."}),"\n",(0,i.jsx)(n.h3,{id:"strategies",children:"Strategies:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Active-Passive"}),"\n",(0,i.jsx)(n.li,{children:"Active-Active"}),"\n",(0,i.jsx)(n.li,{children:"Multi-AZ Replication"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"class ReplicationManager {\n  private primary: Database;\n  private replicas: Database[];\n\n  async write(data: any): Promise<void> {\n    await this.primary.write(data);\n    await Promise.all(\n      this.replicas.map(replica => replica.replicate(data))\n    );\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"8-sql-vs-nosql",children:"8. SQL vs. NoSQL"}),"\n",(0,i.jsx)(n.h3,{id:"sql-relational",children:"SQL (Relational)"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Structured data"}),"\n",(0,i.jsx)(n.li,{children:"ACID properties"}),"\n",(0,i.jsx)(n.li,{children:"Fixed schema"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"nosql",children:"NoSQL"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Unstructured data"}),"\n",(0,i.jsx)(n.li,{children:"Eventual consistency"}),"\n",(0,i.jsx)(n.li,{children:"Dynamic schema"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"interface Database {\n  // SQL-like operations\n  query(sql: string): Promise<Result>;\n  \n  // NoSQL-like operations\n  get(key: string): Promise<Document>;\n  put(key: string, value: Document): Promise<void>;\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"9-cap-theorem",children:"9. CAP Theorem"}),"\n",(0,i.jsx)(n.p,{children:"A distributed system can only provide two of:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Consistency"}),"\n",(0,i.jsx)(n.li,{children:"Availability"}),"\n",(0,i.jsx)(n.li,{children:"Partition Tolerance"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"class DistributedSystem {\n  private type: 'CP' | 'AP' | 'CA';\n\n  handlePartition(): void {\n    switch(this.type) {\n      case 'CP':\n        this.sacrificeAvailability();\n        break;\n      case 'AP':\n        this.sacrificeConsistency();\n        break;\n    }\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"10-pacelc-theorem",children:"10. PACELC Theorem"}),"\n",(0,i.jsx)(n.p,{children:"Extension of CAP:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"During Partition (P): choose between Availability (A) and Consistency (C)"}),"\n",(0,i.jsx)(n.li,{children:"Else (E): choose between Latency (L) and Consistency (C)"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"class PACELCSystem {\n  handleNormalOperation(preference: 'latency' | 'consistency'): void {\n    if (preference === 'latency') {\n      this.optimizeForLatency();\n    } else {\n      this.enforceStrongConsistency();\n    }\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"11-consistent-hashing",children:"11. Consistent Hashing"}),"\n",(0,i.jsx)(n.p,{children:"Distributes data across nodes while minimizing reorganization when nodes are added/removed."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"class ConsistentHashing {\n  private ring: Map<number, Node>;\n  private replicaCount: number;\n\n  addNode(node: Node): void {\n    for (let i = 0; i < this.replicaCount; i++) {\n      const hash = this.hashFunction(`${node.id}-${i}`);\n      this.ring.set(hash, node);\n    }\n  }\n\n  getNode(key: string): Node {\n    const hash = this.hashFunction(key);\n    return this.findNextNode(hash);\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"12-real-time-communication-protocols",children:"12. Real-time Communication Protocols"}),"\n",(0,i.jsx)(n.h3,{id:"long-polling",children:"Long-Polling"}),"\n",(0,i.jsx)(n.h3,{id:"how-it-works",children:"How It Works:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The client makes an HTTP request to the server."}),"\n",(0,i.jsx)(n.li,{children:"The server keeps the request open until new data is available or a timeout occurs."}),"\n",(0,i.jsx)(n.li,{children:"Once the server responds, the client immediately sends a new request to maintain the connection."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"key-characteristics",children:"Key Characteristics:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Simulates real-time communication using HTTP."}),"\n",(0,i.jsx)(n.li,{children:"Creates multiple HTTP requests (one for each polling cycle)."}),"\n",(0,i.jsx)(n.li,{children:"Works over HTTP 1.1, so no persistent connection is required."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"advantages",children:"Advantages:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Works in environments where WebSockets or SSE may not be supported."}),"\n",(0,i.jsx)(n.li,{children:"Simple to implement."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"disadvantages",children:"Disadvantages:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Inefficient due to repeated HTTP requests and connection overhead."}),"\n",(0,i.jsx)(n.li,{children:"Higher latency compared to WebSockets and SSE."}),"\n",(0,i.jsx)(n.li,{children:"Puts additional load on servers."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"common-use-cases",children:"Common Use Cases:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Chat applications (legacy systems)."}),"\n",(0,i.jsx)(n.li,{children:"Scenarios where WebSocket support is not guaranteed."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"class LongPollingClient {\n  async poll(): Promise<Data> {\n    while (true) {\n      const response = await fetch('/api/updates');\n      if (response.status === 200) {\n        return response.json();\n      }\n      await new Promise(resolve => setTimeout(resolve, 1000));\n    }\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"websockets",children:"WebSockets"}),"\n",(0,i.jsx)(n.h3,{id:"how-it-works-1",children:"How It Works:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The client establishes a persistent, full-duplex connection with the server over a single TCP connection."}),"\n",(0,i.jsx)(n.li,{children:"Communication can flow in both directions (client-to-server and server-to-client)."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"key-characteristics-1",children:"Key Characteristics:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Uses the ",(0,i.jsx)(n.code,{children:"ws://"})," or ",(0,i.jsx)(n.code,{children:"wss://"})," protocol (secure WebSocket)."]}),"\n",(0,i.jsx)(n.li,{children:"After the initial handshake over HTTP/HTTPS, the connection upgrades to a WebSocket protocol."}),"\n",(0,i.jsx)(n.li,{children:"Efficient for high-frequency data exchange."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"advantages-1",children:"Advantages:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Full-duplex communication allows real-time interaction."}),"\n",(0,i.jsx)(n.li,{children:"Low overhead after the initial connection."}),"\n",(0,i.jsx)(n.li,{children:"Ideal for scenarios requiring frequent or bidirectional data exchange."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"disadvantages-1",children:"Disadvantages:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Requires WebSocket support on both client and server."}),"\n",(0,i.jsx)(n.li,{children:"May face challenges in environments with strict firewalls or proxies."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"common-use-cases-1",children:"Common Use Cases:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Online multiplayer games."}),"\n",(0,i.jsx)(n.li,{children:"Collaborative tools (e.g., Google Docs)."}),"\n",(0,i.jsx)(n.li,{children:"Real-time financial data (e.g., stock tickers)."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"class WebSocketHandler {\n  private ws: WebSocket;\n\n  connect(): void {\n    this.ws = new WebSocket('ws://server');\n    this.ws.onmessage = this.handleMessage;\n  }\n\n  send(data: any): void {\n    this.ws.send(JSON.stringify(data));\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"server-sent-events",children:"Server-Sent Events"}),"\n",(0,i.jsx)(n.h3,{id:"how-it-works-2",children:"How It Works:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The server pushes updates to the client over an HTTP connection."}),"\n",(0,i.jsx)(n.li,{children:"The client maintains an open connection and listens for events from the server."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"key-characteristics-2",children:"Key Characteristics:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Works only in one direction: server-to-client."}),"\n",(0,i.jsxs)(n.li,{children:["Uses the ",(0,i.jsx)(n.code,{children:"text/event-stream"})," MIME type."]}),"\n",(0,i.jsx)(n.li,{children:"Based on HTTP/1.1, leveraging persistent connections."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"advantages-2",children:"Advantages:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Simpler than WebSockets for one-way communication."}),"\n",(0,i.jsx)(n.li,{children:"Built-in reconnection mechanisms."}),"\n",(0,i.jsx)(n.li,{children:"Lightweight and efficient for server-to-client updates."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"disadvantages-2",children:"Disadvantages:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Unidirectional: no way for the client to send messages back over the same connection."}),"\n",(0,i.jsx)(n.li,{children:"Limited support in some environments (e.g., older browsers or clients)."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"common-use-cases-2",children:"Common Use Cases:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Real-time dashboards."}),"\n",(0,i.jsx)(n.li,{children:"Notifications."}),"\n",(0,i.jsx)(n.li,{children:"Social media feeds."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"class SSEClient {\n  private eventSource: EventSource;\n\n  connect(): void {\n    this.eventSource = new EventSource('/api/events');\n    this.eventSource.onmessage = this.handleMessage;\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"comparison-table",children:"Comparison Table"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:(0,i.jsx)(n.strong,{children:"Feature"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.strong,{children:"Long-Polling"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.strong,{children:"WebSockets"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.strong,{children:"Server-Sent Events (SSE)"})})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Communication"})}),(0,i.jsx)(n.td,{children:"Client-initiated, server responds"}),(0,i.jsx)(n.td,{children:"Full-duplex (bidirectional)"}),(0,i.jsx)(n.td,{children:"Unidirectional (server-to-client)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Efficiency"})}),(0,i.jsx)(n.td,{children:"Low (multiple requests)"}),(0,i.jsx)(n.td,{children:"High (persistent connection)"}),(0,i.jsx)(n.td,{children:"Medium (persistent connection)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Latency"})}),(0,i.jsx)(n.td,{children:"Medium to high"}),(0,i.jsx)(n.td,{children:"Low"}),(0,i.jsx)(n.td,{children:"Low"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Browser Support"})}),(0,i.jsx)(n.td,{children:"Universally supported"}),(0,i.jsx)(n.td,{children:"Modern browsers only"}),(0,i.jsx)(n.td,{children:"Most modern browsers"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Connection Protocol"})}),(0,i.jsx)(n.td,{children:"HTTP/HTTPS"}),(0,i.jsxs)(n.td,{children:["WebSocket protocol (",(0,i.jsx)(n.code,{children:"ws/wss"}),")"]}),(0,i.jsx)(n.td,{children:"HTTP/1.1"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Data Format"})}),(0,i.jsx)(n.td,{children:"Custom (e.g., JSON)"}),(0,i.jsx)(n.td,{children:"Binary or text"}),(0,i.jsxs)(n.td,{children:["Plain text (",(0,i.jsx)(n.code,{children:"event-stream"}),")"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Reconnection"})}),(0,i.jsx)(n.td,{children:"Client manually re-establishes"}),(0,i.jsx)(n.td,{children:"Handled automatically"}),(0,i.jsx)(n.td,{children:"Built-in reconnect support"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Use Case Examples"})}),(0,i.jsx)(n.td,{children:"Legacy systems, basic real-time"}),(0,i.jsx)(n.td,{children:"Games, chats, collaborative apps"}),(0,i.jsx)(n.td,{children:"Notifications, dashboards"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"13-bloom-filters",children:"13. Bloom Filters"}),"\n",(0,i.jsx)(n.p,{children:"Probabilistic data structure to test whether an element is a member of a set."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"class BloomFilter {\n  private bitArray: boolean[];\n  private hashFunctions: ((item: string) => number)[];\n\n  add(item: string): void {\n    this.hashFunctions.forEach(hash => {\n      const index = hash(item) % this.bitArray.length;\n      this.bitArray[index] = true;\n    });\n  }\n\n  mightContain(item: string): boolean {\n    return this.hashFunctions.every(hash => {\n      const index = hash(item) % this.bitArray.length;\n      return this.bitArray[index];\n    });\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"14-quorum",children:"14. Quorum"}),"\n",(0,i.jsx)(n.p,{children:"Number of nodes that must agree for a distributed operation to be considered successful."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"class QuorumSystem {\n  private nodes: number;\n  private readQuorum: number;\n  private writeQuorum: number;\n\n  constructor(n: number, r: number, w: number) {\n    this.nodes = n;\n    this.readQuorum = r;\n    this.writeQuorum = w;\n  }\n\n  isConsistent(): boolean {\n    return this.readQuorum + this.writeQuorum > this.nodes;\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"15-leader-and-follower",children:"15. Leader and Follower"}),"\n",(0,i.jsx)(n.p,{children:"Pattern for coordinating distributed systems."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"class LeaderElection {\n  private nodes: Node[];\n  private currentLeader: Node | null = null;\n\n  electLeader(): void {\n    this.nodes.sort((a, b) => b.priority - a.priority);\n    this.currentLeader = this.nodes[0];\n    this.notifyFollowers();\n  }\n\n  handleLeaderFailure(): void {\n    this.electLeader();\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"16-heartbeat",children:"16. Heartbeat"}),"\n",(0,i.jsx)(n.p,{children:"Mechanism to detect node failures in distributed systems."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"class HeartbeatMonitor {\n  private nodes: Map<string, Date>;\n  private timeout: number;\n\n  checkHeartbeats(): void {\n    const now = new Date();\n    for (const [nodeId, lastBeat] of this.nodes) {\n      if (now.getTime() - lastBeat.getTime() > this.timeout) {\n        this.handleNodeFailure(nodeId);\n      }\n    }\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"17-checksum",children:"17. Checksum"}),"\n",(0,i.jsx)(n.p,{children:"Detects errors in data transmission or storage."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"class Checksum {\n  calculate(data: string): number {\n    return data.split('')\n      .reduce((sum, char) => sum + char.charCodeAt(0), 0);\n  }\n\n  verify(data: string, checksum: number): boolean {\n    return this.calculate(data) === checksum;\n  }\n}\n"})})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>l});var i=s(96540);const t={},r=i.createContext(t);function a(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);