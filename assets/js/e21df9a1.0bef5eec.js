"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[9816],{5754:(n,r,e)=>{e.r(r),e.d(r,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>l});var t=e(4848),s=e(8453);const a={title:"Backtracking Algorithm"},i=void 0,o={id:"DSA/Backtracking",title:"Backtracking Algorithm",description:"Backtracking Algorithm",source:"@site/docs/DSA/Backtracking.mdx",sourceDirName:"DSA",slug:"/DSA/Backtracking",permalink:"/js.enigma/docs/DSA/Backtracking",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/Backtracking.mdx",tags:[],version:"current",frontMatter:{title:"Backtracking Algorithm"},sidebar:"tutorialSidebar",previous:{title:"Breadth-First Search (BFS) for Trees",permalink:"/js.enigma/docs/DSA/BFSTree"},next:{title:"Binary Heap",permalink:"/js.enigma/docs/DSA/BinaryHeap"}},c={},l=[{value:"Backtracking Algorithm",id:"backtracking-algorithm",level:2},{value:"Overview",id:"overview",level:3},{value:"Algorithm Steps",id:"algorithm-steps",level:3},{value:"Example Implementation",id:"example-implementation",level:3},{value:"Rat in a Maze",id:"rat-in-a-maze",level:2},{value:"Count the Number of Paths",id:"count-the-number-of-paths",level:2},{value:"N Queens",id:"n-queens",level:2},{value:"Permutation",id:"permutation",level:3},{value:"Permutation 2",id:"permutation-2",level:3},{value:"Combination",id:"combination",level:3},{value:"Combination Sum",id:"combination-sum",level:3},{value:"Combination 3",id:"combination-3",level:3},{value:"Subsets",id:"subsets",level:3},{value:"Subsets 2",id:"subsets-2",level:3}];function u(n){const r={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.h2,{id:"backtracking-algorithm",children:"Backtracking Algorithm"}),"\n",(0,t.jsx)(r.p,{children:"The Backtracking algorithm is a general technique used for solving problems by incrementally building solutions and abandoning those that fail to meet the criteria. It explores all possible solutions in a systematic manner and is particularly useful for constraint satisfaction and combinatorial problems."}),"\n",(0,t.jsx)(r.h3,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(r.p,{children:"Backtracking works by trying out all potential solutions and discarding those that do not meet the problem\u2019s constraints. It builds a solution step-by-step, and if at any step the current solution does not meet the constraints, it backtracks to the previous step and tries a different option."}),"\n",(0,t.jsx)(r.h3,{id:"algorithm-steps",children:"Algorithm Steps"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Choose"}),": Select an option from the available choices."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Explore"}),": Move to the next state or option based on the current choice."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Check"}),": Determine if the current state meets the constraints or criteria of the problem."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Backtrack"}),": If the current solution path does not meet the criteria, revert to the previous state and try the next option."]}),"\n"]}),"\n",(0,t.jsx)(r.h3,{id:"example-implementation",children:"Example Implementation"}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Code Example"}),":"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"/**\r\n * Solve [Problem Description] using Backtracking.\r\n * @param {Type} [parameterName] - [Description of the parameter]\r\n * @return {Type} - [Description of the return value]\r\n */\r\nconst [functionName] = ([parameters]) => {\r\n  const result = [];\r\n  \r\n  const backtrack = (currentState) => {\r\n    // Base case: Check if current state meets the criteria\r\n    if ([condition]) {\r\n      result.push([solution]);\r\n      return;\r\n    }\r\n    \r\n    // Iterate through options and recurse\r\n    for (const option of [options]) {\r\n      if ([isValid](option)) {\r\n        // Make a choice\r\n        [updateState](option);\r\n        \r\n        // Recur to explore the next step\r\n        backtrack([newState]);\r\n        \r\n        // Undo the choice (backtrack)\r\n        [revertState](option);\r\n      }\r\n    }\r\n  };\r\n\r\n  backtrack([initialState]);\r\n  return result;\r\n};\r\n\r\n// Example usage:\r\nconsole.log([functionName]([testParameters]));\r\n/* Output:\r\n[Expected output]\r\n*/\n"})}),"\n",(0,t.jsx)(r.h2,{id:"rat-in-a-maze",children:"Rat in a Maze"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-Javascript",children:'const ratInMaze = (maze) => {\r\n  const n = maze.length;\r\n  const paths = [];\r\n  const path = [];\r\n  const directions = [\r\n    [1, 0, "D"], // Down\r\n    [0, -1, "L"], // Left\r\n    [0, 1, "R"], // Right\r\n    [-1, 0, "U"] // Up\r\n  ];\r\n\r\n  const isSafe = (row, col, visited) => {\r\n    return (\r\n      row >= 0 && row < n &&\r\n      col >= 0 && col < n &&\r\n      maze[row][col] === 1 &&\r\n      !visited[row][col]\r\n    );\r\n  };\r\n\r\n  const backtrack = (row, col, visited) => {\r\n    if (row === n - 1 && col === n - 1) {\r\n      paths.push(path.join(""));\r\n      return;\r\n    }\r\n\r\n    visited[row][col] = true;\r\n\r\n    for (const [dx, dy, dir] of directions) {\r\n      const newRow = row + dx;\r\n      const newCol = col + dy;\r\n\r\n      if (isSafe(newRow, newCol, visited)) {\r\n        path.push(dir);\r\n        backtrack(newRow, newCol, visited);\r\n        path.pop(); // Backtrack\r\n      }\r\n    }\r\n\r\n    visited[row][col] = false;\r\n  };\r\n\r\n  if (maze[0][0] === 1) {\r\n    const visited = Array.from({ length: n }, () => Array(n).fill(false));\r\n    backtrack(0, 0, visited);\r\n  }\r\n\r\n  return paths;\r\n};\r\n\r\n// Example Usage\r\nconst maze = [\r\n  [1, 1, 1, 1],\r\n  [1, 1, 0, 1],\r\n  [0, 1, 0, 1],\r\n  [1, 1, 1, 1],\r\n];\r\n\r\nconst result = ratInMaze(maze);\r\nconsole.log(result);\r\n/* \r\n["DRDDRR", "DRURRDDD", "RDDDRR", "RRRDDD"]\r\n */\n'})}),"\n",(0,t.jsx)(r.h2,{id:"count-the-number-of-paths",children:"Count the Number of Paths"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"Instead of listing all paths, count how many distinct paths exist from the top-left to the bottom-right corner."}),"\n"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-Javascript",children:"const countPathsInMaze = (maze) => {\r\n  const n = maze.length;\r\n  let count = 0;\r\n\r\n  const isSafe = (row, col, visited) => {\r\n    return (\r\n      row >= 0 && row < n &&\r\n      col >= 0 && col < n &&\r\n      maze[row][col] === 1 &&\r\n      !visited[row][col]\r\n    );\r\n  };\r\n\r\n  const backtrack = (row, col, visited) => {\r\n    if (row === n - 1 && col === n - 1) {\r\n      count++;\r\n      return;\r\n    }\r\n\r\n    visited[row][col] = true;\r\n\r\n    const directions = [\r\n      [1, 0],  // Down\r\n      [0, -1], // Left\r\n      [0, 1],  // Right\r\n      [-1, 0], // Up\r\n    ];\r\n\r\n    for (const [dr, dc] of directions) {\r\n      const newRow = row + dr;\r\n      const newCol = col + dc;\r\n\r\n      if (isSafe(newRow, newCol, visited)) {\r\n        backtrack(newRow, newCol, visited);\r\n      }\r\n    }\r\n\r\n    visited[row][col] = false; // Backtrack\r\n  };\r\n\r\n  if (maze[0][0] === 1) {\r\n    const visited = Array.from({ length: n }, () => Array(n).fill(false));\r\n    backtrack(0, 0, visited);\r\n  }\r\n\r\n  return count;\r\n};\r\n\r\n// Test Usage\r\nconst maze = [\r\n  [1, 1, 0, 0],\r\n  [1, 1, 0, 1],\r\n  [0, 1, 0, 0],\r\n  [1, 1, 1, 1],\r\n];\r\n\r\nconsole.log(countPathsInMaze(maze)); // Output: 2\n"})}),"\n",(0,t.jsx)(r.h2,{id:"n-queens",children:"N Queens"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-Javascript",children:"/**\r\n * @param {number} n\r\n * @return {string[][]}\r\n */\r\nfunction solveNQueens(n) {\r\n  const solutions = [];\r\n\r\n  function solve(queens = [], row = 0) {\r\n    if (row === n) {\r\n      solutions.push(queens.map(col => '.'.repeat(col) + 'Q' + '.'.repeat(n - col - 1)));\r\n      return;\r\n    }\r\n\r\n    for (let col = 0; col < n; col++) {\r\n      if (queens.every((queenCol, queenRow) =>\r\n        queenCol !== col &&\r\n        Math.abs(queenCol - col) !== Math.abs(queenRow - row)\r\n      )) {\r\n        solve([...queens, col], row + 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  solve();\r\n  return solutions;\r\n}\n"})}),"\n",(0,t.jsx)(r.h3,{id:"permutation",children:"Permutation"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-Javascript",children:"const permute = (nums) => {\r\n  const result = [];\r\n  const backtrack = (path) => {\r\n    if (path.length === nums.length) {\r\n      result.push([...path]);\r\n      return;\r\n    }\r\n    for (let i = 0; i < nums.length; i++) {\r\n      if (path.includes(nums[i])) continue;\r\n      path.push(nums[i]);\r\n      backtrack(path);\r\n      path.pop();\r\n    }\r\n  };\r\n\r\n  backtrack([]);\r\n  return result;\r\n};\n"})}),"\n",(0,t.jsx)(r.h3,{id:"permutation-2",children:"Permutation 2"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-Javascript",children:"const permuteUnique = (nums) => {\r\n  const list = []\r\n  nums.sort((a, b) => a - b); // Sort the array to ensure duplicates are adjacent\r\n\r\n  const backtrack = (tempList, used) => {\r\n    if (tempList.length === nums.length) {\r\n      list.push([...tempList]);\r\n      return\r\n    }\r\n    for (let i = 0; i < nums.length; i++) {\r\n      // Skip the used elements or duplicates\r\n      if (used[i] || (i > 0 && nums[i] === nums[i - 1] && !used[i - 1])) continue;\r\n      used[i] = true;\r\n      tempList.push(nums[i]);\r\n      backtrack(tempList, used);\r\n      used[i] = false;\r\n      tempList.pop();\r\n    }\r\n  };\r\n\r\n  backtrack([], new Array(nums.length).fill(false));\r\n  return list;\r\n};\n"})}),"\n",(0,t.jsx)(r.h3,{id:"combination",children:"Combination"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-Javascript",children:"/**\r\n * @param {number} n\r\n * @param {number} k\r\n * @return {number[][]}\r\n */\r\nconst combine = (n, k) => {\r\n  const res = []\r\n\r\n  const backtrack = (index, comb) => {\r\n    if (comb.length === k) {\r\n      res.push([...comb])\r\n      return\r\n    }\r\n    for (let i = index; i < n + 1; i++) {\r\n      comb.push(i)\r\n      backtrack(i + 1, comb)\r\n      comb.pop()\r\n    }\r\n  }\r\n  backtrack(1, [])\r\n  return res\r\n};\n"})}),"\n",(0,t.jsx)(r.h3,{id:"combination-sum",children:"Combination Sum"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-Javascript",children:"/**\r\n * @param {number[]} candidates\r\n * @param {number} target\r\n * @return {number[][]}\r\n */\r\nconst combinationSum = (candidates, target) => {\r\n  const result = [];\r\n\r\n  const backtrack = (start, path, sum) => {\r\n    if (sum > target) return; // Exceeds the target, no need to continue\r\n    if (sum === target) { // Found a valid combination\r\n      result.push([...path]);\r\n      return;\r\n    }\r\n    for (let i = start; i < candidates.length; i++) {\r\n      path.push(candidates[i]); // Choose the candidate\r\n      backtrack(i, path, sum + candidates[i]); // Recur with the same candidate\r\n      path.pop(); // Backtrack, remove the last candidate\r\n    }\r\n  };\r\n\r\n  backtrack(0, [], 0); // Start with index 0, empty path, and sum 0\r\n  return result;\r\n};\n"})}),"\n",(0,t.jsx)(r.h3,{id:"combination-3",children:"Combination 3"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-Javascript",children:"/**\r\n * @param {number} k\r\n * @param {number} n\r\n * @return {number[][]}\r\n */\r\nconst combinationSum3 = (k, n) => {\r\n  const result = []\r\n\r\n  const backtrack = (start, path, sum) => {\r\n    if (path.length === k && sum === n) {\r\n      result.push([...path])\r\n      return\r\n    }\r\n\r\n    if (sum >= n && path.length >= k) return\r\n\r\n    for (let i = start; i <= 9; i++) {\r\n      path.push(i)\r\n      backtrack(i + 1, path, sum + i)\r\n      path.pop(i)\r\n    }\r\n  }\r\n\r\n  backtrack(1, [], 0)\r\n  return result\r\n};\n"})}),"\n",(0,t.jsx)(r.h3,{id:"subsets",children:"Subsets"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-Javascript",children:"/**\r\n * @param {number[]} nums\r\n * @return {number[][]}\r\n */\r\nconst subsets = (nums) => {\r\n  const result = []\r\n\r\n  const backtrack = (id, subs) => {\r\n    result.push([...subs])\r\n\r\n    for (let i = id; i < nums.length; i++) {\r\n      subs.push(nums[i])\r\n      backtrack(i + 1, subs)\r\n      subs.pop()\r\n    }\r\n  }\r\n  backtrack(0, [])\r\n  return result\r\n};\n"})}),"\n",(0,t.jsx)(r.h3,{id:"subsets-2",children:"Subsets 2"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-Javascript",children:"/**\r\n * @param {number[]} nums\r\n * @return {number[][]}\r\n */\r\nconst subsetsWithDup = (nums) => {\r\n  nums.sort((a, b) => a - b)\r\n  const result = []\r\n\r\n  const backtrack = (id, subs) => {\r\n    result.push([...subs])\r\n\r\n    for (let i = id; i < nums.length; i++) {\r\n      if (i > id && nums[i] === nums[i - 1]) continue\r\n      subs.push(nums[i])\r\n      backtrack(i + 1, subs)\r\n      subs.pop()\r\n    }\r\n  }\r\n  backtrack(0, [])\r\n  return result\r\n};\n"})})]})}function h(n={}){const{wrapper:r}={...(0,s.R)(),...n.components};return r?(0,t.jsx)(r,{...n,children:(0,t.jsx)(u,{...n})}):u(n)}},8453:(n,r,e)=>{e.d(r,{R:()=>i,x:()=>o});var t=e(6540);const s={},a=t.createContext(s);function i(n){const r=t.useContext(a);return t.useMemo((function(){return"function"==typeof n?n(r):{...r,...n}}),[r,n])}function o(n){let r;return r=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:i(n.components),t.createElement(a.Provider,{value:r},n.children)}}}]);