"use strict";(globalThis.webpackChunkdev_enigma=globalThis.webpackChunkdev_enigma||[]).push([[23748],{28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>l});var i=t(96540);const s={},r=i.createContext(s);function o(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:n},e.children)}},56828:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>m,frontMatter:()=>r,metadata:()=>l,toc:()=>u});var i=t(74848),s=t(28453);const r={},o="Multiset in JavaScript",l={id:"DSA/DSA/DSA with JavaScript/MultiSet",title:"Multiset in JavaScript",description:"A Multiset (also known as a bag) is a data structure similar to a set, but it allows duplicate elements. In a multiset, each element can appear multiple times, and you can efficiently track the number of occurrences of each element.",source:"@site/docs/05-DSA/DSA/DSA with JavaScript/MultiSet.mdx",sourceDirName:"05-DSA/DSA/DSA with JavaScript",slug:"/DSA/DSA/DSA with JavaScript/MultiSet",permalink:"/docs/DSA/DSA/DSA with JavaScript/MultiSet",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/05-DSA/DSA/DSA with JavaScript/MultiSet.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Morris Traversal for Binary Trees",permalink:"/docs/DSA/DSA/DSA with JavaScript/MorrisTraversal"},next:{title:"Multi-source BFS Algorithm",permalink:"/docs/DSA/DSA/DSA with JavaScript/MultiSourceBFS"}},c={},u=[{value:"Implementation",id:"implementation",level:2}];function a(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"multiset-in-javascript",children:"Multiset in JavaScript"})}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.strong,{children:"Multiset"})," (also known as a ",(0,i.jsx)(n.strong,{children:"bag"}),") is a data structure similar to a set, but it allows duplicate elements. In a multiset, each element can appear multiple times, and you can efficiently track the number of occurrences of each element."]}),"\n",(0,i.jsxs)(n.p,{children:["This implementation of a multiset is built using a JavaScript ",(0,i.jsx)(n.code,{children:"Map"}),", where each element is stored as a key, and the number of times it appears is stored as the corresponding value."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"1. Efficient Storage:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Uses Map to store element-frequency pairs"}),"\n",(0,i.jsx)(n.li,{children:"O(1) lookup and modification operations"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"2. Complete Operations Set:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Basic:"})," add, remove, count, has"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Set operations:"})," union, intersection, difference"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Utility:"})," toArray, uniqueElements, toString"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"3. Performance:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"add/remove: O(1)"}),"\n",(0,i.jsx)(n.li,{children:"count/has: O(1)"}),"\n",(0,i.jsx)(n.li,{children:"union/intersection/difference: O(n)"}),"\n",(0,i.jsx)(n.li,{children:"toArray: O(n)"}),"\n",(0,i.jsx)(n.li,{children:"where n is number of unique elements"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"4. Memory Efficient:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Only stores unique elements with their counts"}),"\n",(0,i.jsx)(n.li,{children:"Automatically cleans up when count reaches 0"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"5. Iterator Support:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Can be used in for...of loops"}),"\n",(0,i.jsx)(n.li,{children:"Yields each element according to its multiplicity"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"6. Flexible API:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Supports multiple element addition/removal"}),"\n",(0,i.jsx)(n.li,{children:"Provides both multiset and set-like operations"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"implementation",children:"Implementation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-JavaScript",children:"class MultiSet {\n  constructor(iterable = []) {\n    // Using Map to store element frequencies\n    this.elements = new Map();\n    this.size = 0;\n\n    // Initialize with iterable if provided\n    for (const item of iterable) {\n      this.add(item);\n    }\n  }\n\n  // Add element to multiset\n  add(element, count = 1) {\n    if (count <= 0) return false;\n\n    const currentCount = this.elements.get(element) || 0;\n    this.elements.set(element, currentCount + count);\n    this.size += count;\n    return true;\n  }\n\n  // Remove element from multiset\n  remove(element, count = 1) {\n    if (count <= 0) return false;\n\n    const currentCount = this.elements.get(element) || 0;\n    if (currentCount === 0) return false;\n\n    const newCount = Math.max(0, currentCount - count);\n    if (newCount === 0) {\n      this.elements.delete(element);\n    } else {\n      this.elements.set(element, newCount);\n    }\n\n    this.size -= (currentCount - newCount);\n    return true;\n  }\n\n  // Remove all occurrences of an element\n  removeAll(element) {\n    const count = this.elements.get(element) || 0;\n    if (count > 0) {\n      this.size -= count;\n      this.elements.delete(element);\n      return true;\n    }\n    return false;\n  }\n\n  // Get count of element\n  count(element) {\n    return this.elements.get(element) || 0;\n  }\n\n  // Check if element exists\n  has(element) {\n    return this.elements.has(element);\n  }\n\n  // Get total number of elements (including duplicates)\n  getSize() {\n    return this.size;\n  }\n\n  // Get number of unique elements\n  getUniqueSize() {\n    return this.elements.size;\n  }\n\n  // Clear the multiset\n  clear() {\n    this.elements.clear();\n    this.size = 0;\n  }\n\n  // Convert to array (with duplicates)\n  toArray() {\n    const result = [];\n    for (const [element, count] of this.elements) {\n      result.push(...Array(count).fill(element));\n    }\n    return result;\n  }\n\n  // Get array of unique elements\n  uniqueElements() {\n    return Array.from(this.elements.keys());\n  }\n\n  // Union with another multiset\n  union(other) {\n    const result = new MultiSet(this.toArray());\n    for (const [element, count] of other.elements) {\n      const currentCount = this.count(element);\n      if (count > currentCount) {\n        result.add(element, count - currentCount);\n      }\n    }\n    return result;\n  }\n\n  // Intersection with another multiset\n  intersection(other) {\n    const result = new MultiSet();\n    for (const [element, count] of this.elements) {\n      const otherCount = other.count(element);\n      if (otherCount > 0) {\n        result.add(element, Math.min(count, otherCount));\n      }\n    }\n    return result;\n  }\n\n  // Difference with another multiset\n  difference(other) {\n    const result = new MultiSet();\n    for (const [element, count] of this.elements) {\n      const otherCount = other.count(element);\n      const diffCount = count - otherCount;\n      if (diffCount > 0) {\n        result.add(element, diffCount);\n      }\n    }\n    return result;\n  }\n\n  // Check if this multiset is subset of another\n  isSubsetOf(other) {\n    for (const [element, count] of this.elements) {\n      if (other.count(element) < count) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // Iterator implementation\n  *[Symbol.iterator]() {\n    for (const [element, count] of this.elements) {\n      for (let i = 0; i < count; i++) {\n        yield element;\n      }\n    }\n  }\n\n  // Create string representation\n  toString() {\n    const elements = Array.from(this.elements.entries())\n      .map(([element, count]) => `${element}${count > 1 ? `(${count})` : ''}`)\n      .join(', ');\n    return `[${elements}]`;\n  }\n}\n\n// Create a new MultiSet\nconst ms = new MultiSet([1, 2, 2, 3, 3, 3]);\n\n// Basic operations\nconsole.log(ms.toString());        // [1(1), 2(2), 3(3)]\nconsole.log(ms.count(2));          // 2\nconsole.log(ms.getSize());         // 6\nconsole.log(ms.getUniqueSize());   // 3\n\n// Add and remove elements\nms.add(4, 2);                      // Add 2 occurrences of 4\nms.remove(2, 1);                   // Remove 1 occurrence of 2\nconsole.log(ms.toString());        // [1(1), 2(1), 3(3), 4(2)]\n\n// Set operations\nconst ms2 = new MultiSet([2, 2, 3, 4]);\nconst union = ms.union(ms2);\nconst intersection = ms.intersection(ms2);\nconst difference = ms.difference(ms2);\n\n// Iterate over elements (including duplicates)\nfor (const element of ms) {\n  console.log(element);\n}\n"})})]})}function m(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}}}]);