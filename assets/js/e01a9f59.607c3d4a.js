"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[4061],{28453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>o});var s=t(96540);const r={},i=s.createContext(r);function l(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),s.createElement(i.Provider,{value:n},e.children)}},55124:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var s=t(74848),r=t(28453);const i={title:"Line Sweep Algorithm"},l=void 0,o={id:"DSA/DSA with JavaScript/LineSweep",title:"Line Sweep Algorithm",description:'The Line Sweep algorithm is a computational geometry technique used to solve various problems involving intervals or segments. The basic idea is to "sweep" a line across the plane and process events as the line intersects with points of interest (typically the endpoints of segments).',source:"@site/docs/DSA/DSA with JavaScript/LineSweep.mdx",sourceDirName:"DSA/DSA with JavaScript",slug:"/DSA/DSA with JavaScript/LineSweep",permalink:"/docs/DSA/DSA with JavaScript/LineSweep",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with JavaScript/LineSweep.mdx",tags:[],version:"current",frontMatter:{title:"Line Sweep Algorithm"},sidebar:"tutorialSidebar",previous:{title:"LRU Cache Design",permalink:"/docs/DSA/DSA with JavaScript/LRUcache"},next:{title:"Linked List",permalink:"/docs/DSA/DSA with JavaScript/LinkedList"}},a={},c=[{value:"Steps of the Line Sweep Algorithm",id:"steps-of-the-line-sweep-algorithm",level:2},{value:"Example: Finding Intersections of Line Segments",id:"example-finding-intersections-of-line-segments",level:2},{value:"Step-by-Step Process",id:"step-by-step-process",level:3},{value:"Merge Intervals",id:"merge-intervals",level:3},{value:"Insert intervals",id:"insert-intervals",level:3},{value:"Meeting Rooms",id:"meeting-rooms",level:3},{value:"Meeting Rooms II",id:"meeting-rooms-ii",level:3},{value:"Employee Free time",id:"employee-free-time",level:3},{value:"Related LeetCode Problems",id:"related-leetcode-problems",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.strong,{children:"Line Sweep"}),' algorithm is a computational geometry technique used to solve various problems involving intervals or segments. The basic idea is to "sweep" a line across the plane and process events as the line intersects with points of interest (typically the endpoints of segments).']}),"\n",(0,s.jsx)(n.h2,{id:"steps-of-the-line-sweep-algorithm",children:"Steps of the Line Sweep Algorithm"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Event Creation"}),": Create a list of events from the segments or intervals. Each event represents a point where an interval starts or ends."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Sorting Events"}),": Sort the events primarily by the x-coordinate. If two events have the same x-coordinate, handle the starting events before ending events."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Sweeping the Line"}),": Initialize a data structure (like a balanced tree or a multiset) to keep track of active segments. As you process each event:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"For a starting event, add the segment to the active set."}),"\n",(0,s.jsx)(n.li,{children:"For an ending event, remove the segment from the active set."}),"\n",(0,s.jsx)(n.li,{children:"Optionally, during the sweep, check for intersections or perform other calculations based on the active segments."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Processing Events"}),": For each event, update the state of the active segments and collect any required information (like intersection points, area calculations, etc.)."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Must Read : ",(0,s.jsx)(n.a,{href:"https://leetcode.com/discuss/study-guide/2166045/line-sweep-algorithms",children:"Line Sweep"})]}),"\n",(0,s.jsx)(n.h2,{id:"example-finding-intersections-of-line-segments",children:"Example: Finding Intersections of Line Segments"}),"\n",(0,s.jsx)(n.p,{children:"Consider the following line segments:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Segment A: (1, 3)"}),"\n",(0,s.jsx)(n.li,{children:"Segment B: (2, 5)"}),"\n",(0,s.jsx)(n.li,{children:"Segment C: (4, 6)"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"step-by-step-process",children:"Step-by-Step Process"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Create Events"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Event A_start: (1, start, A)"}),"\n",(0,s.jsx)(n.li,{children:"Event A_end: (3, end, A)"}),"\n",(0,s.jsx)(n.li,{children:"Event B_start: (2, start, B)"}),"\n",(0,s.jsx)(n.li,{children:"Event B_end: (5, end, B)"}),"\n",(0,s.jsx)(n.li,{children:"Event C_start: (4, start, C)"}),"\n",(0,s.jsx)(n.li,{children:"Event C_end: (6, end, C)"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Sort Events"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"[(1, start, A), (2, start, B), (3, end, A), (4, start, C), (5, end, B), (6, end, C)]"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Sweep the Line"}),":"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Start with an empty active set."}),"\n",(0,s.jsxs)(n.li,{children:["Process Event A_start: Add Segment A \u2192 Active Set: ",(0,s.jsx)(n.code,{children:"{A}"})]}),"\n",(0,s.jsxs)(n.li,{children:["Process Event B_start: Add Segment B \u2192 Active Set: ",(0,s.jsx)(n.code,{children:"{A, B}"})]}),"\n",(0,s.jsxs)(n.li,{children:["Process Event A_end: Remove Segment A \u2192 Active Set: ",(0,s.jsx)(n.code,{children:"{B}"})]}),"\n",(0,s.jsxs)(n.li,{children:["Process Event C_start: Add Segment C \u2192 Active Set: ",(0,s.jsx)(n.code,{children:"{B, C}"})]}),"\n",(0,s.jsxs)(n.li,{children:["Process Event B_end: Remove Segment B \u2192 Active Set: ",(0,s.jsx)(n.code,{children:"{C}"})]}),"\n",(0,s.jsxs)(n.li,{children:["Process Event C_end: Remove Segment C \u2192 Active Set: ",(0,s.jsx)(n.code,{children:"{}"})]}),"\n"]}),"\n",(0,s.jsxs)(n.ol,{start:"4",children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Intersections Found"}),": In this case, Segment A intersects with Segment B at point (2,3)."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"merge-intervals",children:"Merge Intervals"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-JavaScript",children:"function merge(intervals) {\n  const events = intervals.flatMap(([s, e]) => [[s, 1], [e, -1]])  // Create Events\n\n  events.sort((a, b) => a[0] - b[0] || b[1] - a[1]) // Sort Events\n\n  const result = [];\n  let count = 0;\n  let start = null;\n\n  events.forEach(([pos, type]) => {\n    count += type;  // Add the type (1 for start, -1 for end)\n    if (count === 1 && type === 1) { // Start new interval\n      start = pos;\n    } else if (count === 0) { // End current interval\n      result.push([start, pos]);\n    }\n  })\n\n  return result;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["A little animation for above ",(0,s.jsx)(n.a,{href:"https://gqft7d.csb.app/",children:"https://gqft7d.csb.app/"})]}),"\n",(0,s.jsx)(n.h3,{id:"insert-intervals",children:"Insert intervals"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-JavaScript",children:"function insert(intervals, newInterval) {\n  // Convert intervals into events\n  const events = [\n    ...intervals.flatMap(([start, end]) => [[start, 1], [end, -1]]),\n    [newInterval[0], 1],\n    [newInterval[1], -1]\n  ];\n\n  // Sort events by position, and prioritize 'end' over 'start' when positions are the same\n  events.sort((a, b) => a[0] - b[0] || b[1] - a[1]);\n\n  const result = [];\n  let count = 0;\n  let start = null;\n\n  // Sweep through the events\n  for (const [pos, type] of events) {\n    count += type;\n\n    if (count === 1 && type === 1) {\n      start = pos;    // Start of a new interval\n    } else if (count === 0) {\n      result.push([start, pos]);  // End of the current interval\n    }\n  }\n\n  return result;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"meeting-rooms",children:"Meeting Rooms"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-JavaScript",children:"/**\n * @param {number[][]} intervals\n * @return {boolean}\n */\nvar canAttendMeetings = function (intervals) {\n  const events = intervals.flatMap(([s, e]) => [[s, 1], [e, -1]]); //Create events\n\n  events.sort((a, b) => a[0] - b[0] || a[1] - b[1]) //Sort events\n\n  let onGoing = 0\n  for (const [_, type] of events) {\n    onGoing += type\n    // If we start a meeting while another is ongoing, return false\n    if (onGoing > 1) return false\n  }\n  return true\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"meeting-rooms-ii",children:"Meeting Rooms II"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-JavaScript",children:"function minMeetingRooms(intervals) {\n  if (intervals.length === 0) return 0;\n\n  const events = [];\n\n  // Step 1: Convert intervals to events\n  intervals.forEach(([start, end]) => {\n    events.push([start, 1]);  // Start of a meeting\n    events.push([end, -1]);   // End of a meeting\n  });\n\n  // Step 2: Sort events\n  events.sort(([time1, type1], [time2, type2]) => {\n    if (time1 === time2) {\n      return type1 - type2; // End event (-1) before start event (+1)\n    }\n    return time1 - time2;   // Sort by time\n  });\n\n  // Step 3: Sweep through events to find max rooms required\n  let activeRooms = 0;\n  let maxRooms = 0;\n\n  events.forEach(([, type]) => {\n    activeRooms += type; // Increment or decrement active room count\n    maxRooms = Math.max(maxRooms, activeRooms); // Update maximum rooms needed\n  });\n\n  return maxRooms; // Return the maximum number of rooms needed\n}\n\n// Example usage:\nconst intervals = [\n  [0, 30],\n  [5, 10],\n  [15, 20]\n];\nconsole.log(minMeetingRooms(intervals)); // Output: 2\n"})}),"\n",(0,s.jsx)(n.h3,{id:"employee-free-time",children:"Employee Free time"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-JavaScript",children:"/**\n * // Definition for an Interval.\n * function Interval(start, end) {\n *    this.start = start;\n *    this.end = end;\n * };\n */\n\n/**\n * @param {Interval[][]} schedules\n * @return {Interval[]}\n */\nfunction employeeFreeTime(schedules) {\n  const events = [];\n\n  // Step 1: Create events from employee schedules\n  schedules.forEach(schedule => {\n    schedule.forEach(({ start, end }) => {\n      events.push([start, 'start']);\n      events.push([end, 'end']);\n    });\n  });\n\n  // Step 2: Sort events\n  events.sort(([time1, type1], [time2, type2]) => {\n    return time1 === time2 ? (type1 === 'end' ? -1 : 1) : time1 - time2;\n  });\n\n  // Step 3: Sweep through events to find free time\n  const freeTime = [];\n  let active = 0;\n  let lastEnd = null;\n\n  for (const [time, type] of events) {\n    if (type === 'start') {\n      if (active === 0 && lastEnd !== null) {\n        // Add the free time interval if there was a gap\n        if (lastEnd < time) { // Ensure that we only add intervals where there is a gap\n          freeTime.push(new Interval(lastEnd, time));\n        }\n      }\n      active++; // Increase active intervals\n    } else { // type === 'end'\n      active--; // Decrease active intervals\n      if (active === 0) {\n        lastEnd = time; // Mark the end of the last active interval\n      }\n    }\n  }\n\n  return freeTime; // Return an array of Interval objects\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"related-leetcode-problems",children:"Related LeetCode Problems"}),"\n",(0,s.jsx)(n.p,{children:"Here are some problems on LeetCode that can be solved using the Line Sweep algorithm:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/meeting-rooms-ii/",children:"Meeting Rooms II"})})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/insert-interval/",children:"Insert Interval"})})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/minimum-interval-to-include-each-query/",children:"Minimum Interval to Include Each Query"})})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/the-skyline-problem/",children:"Skyline Problem"})})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/merge-intervals/",children:"Overlapping Intervals"})})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/car-fleet/",children:"Car Fleet"})})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["More Problems: ",(0,s.jsx)(n.a,{href:"https://leetcode.com/problem-list/mzw3cyy6/",children:"https://leetcode.com/problem-list/mzw3cyy6/"})]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);