"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[5198],{28453:(t,n,e)=>{e.d(n,{R:()=>r,x:()=>o});var s=e(96540);const i={},a=s.createContext(i);function r(t){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof t?t(n):{...n,...t}},[n,t])}function o(t){let n;return n=t.disableParentContext?"function"==typeof t.components?t.components(i):t.components||i:r(t.components),s.createElement(a.Provider,{value:n},t.children)}},80621:(t,n,e)=>{e.r(n),e.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>a,metadata:()=>o,toc:()=>c});var s=e(74848),i=e(28453);const a={},r="Suffix Automaton",o={id:"DSA/DSA with JavaScript/SuffixAutomata",title:"Suffix Automaton",description:"A Suffix Automaton is a state machine that represents all substrings of a given string efficiently. It's used primarily in string processing problems, such as substring matching, pattern matching, and finding repeated substrings, among others. It builds a minimal deterministic finite automaton (DFA) to recognize all the suffixes of a string.",source:"@site/docs/DSA/DSA with JavaScript/SuffixAutomata.mdx",sourceDirName:"DSA/DSA with JavaScript",slug:"/DSA/DSA with JavaScript/SuffixAutomata",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/SuffixAutomata",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with JavaScript/SuffixAutomata.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"String Matching",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/StringMatching"},next:{title:"Topological Sort Tutorial",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/TopologicalSort"}},l={},c=[{value:"Key Concepts",id:"key-concepts",level:2},{value:"Properties",id:"properties",level:2},{value:"Construction",id:"construction",level:2},{value:"Suffix Automaton Implementation",id:"suffix-automaton-implementation",level:2},{value:"Problems on Leetcode",id:"problems-on-leetcode",level:2}];function h(t){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...t.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"suffix-automaton",children:"Suffix Automaton"})}),"\n",(0,s.jsx)(n.p,{children:"A Suffix Automaton is a state machine that represents all substrings of a given string efficiently. It's used primarily in string processing problems, such as substring matching, pattern matching, and finding repeated substrings, among others. It builds a minimal deterministic finite automaton (DFA) to recognize all the suffixes of a string."}),"\n",(0,s.jsx)(n.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"1. State:"})," Each state in a suffix automaton represents a set of substrings that can be recognized from that state."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"2. Transition:"})," A transition between two states is labeled with a character, and it represents moving from one state to another when that character is read."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"3. Minimality:"})," The suffix automaton is built to minimize the number of states while still representing all suffixes of the string."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"4. Suffix Link:"}),' A suffix link is a special kind of transition that allows you to move from a state to another state that represents a "shorter" suffix of the string. This link plays a crucial role in efficiently constructing and using suffix automata.']}),"\n",(0,s.jsx)(n.h2,{id:"properties",children:"Properties"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Number of States:"})," For a string of length n, a suffix automaton has at most 2n - 1 states."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Time Complexity:"})," Constructing a suffix automaton takes O(n) time, where n is the length of the string."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Space Complexity:"})," The space complexity is O(n) in terms of the number of states and transitions."]}),"\n",(0,s.jsx)(n.h2,{id:"construction",children:"Construction"}),"\n",(0,s.jsx)(n.p,{children:"A suffix automaton can be constructed by iteratively adding characters from the string and adjusting the automaton as follows:"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Start State:"})," Initially, there\u2019s one state, representing the empty string."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Adding Characters:"})," For each character of the string, add a new state and connect it to the current state with a transition labeled by the character."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Suffix Links:"})," As new states are added, suffix links are used to connect states that represent similar suffixes."]}),"\n",(0,s.jsx)(n.h2,{id:"suffix-automaton-implementation",children:"Suffix Automaton Implementation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-JavaScript",children:'class State {\n  length = 0;  // Length of the longest string in this state\n  transitions = new Map();  // Transitions to other states\n  link = null;  // Suffix link\n  endpos = -1;  // Position where this state ends\n}\n\n\nclass SuffixAutomaton {\n  states = Array.of(new State());\n  last = 0;  // Index of last state\n  size = 1;  // Total number of states\n\n\n  // Add a character to the automaton\n  addChar(c) {\n    let curr = this.size++;\n    this.states[curr] = new State();\n    this.states[curr].length = this.states[this.last].length + 1;\n    this.states[curr].endpos = this.states[curr].length - 1;\n\n    // Add transitions from previous states\n    let p = this.last;\n    while (p !== null && !this.states[p].transitions.has(c)) {\n      this.states[p].transitions.set(c, curr);\n      p = this.states[p].link;\n    }\n\n    if (p === null) {\n      this.states[curr].link = 0;\n    } else {\n      let q = this.states[p].transitions.get(c);\n      if (this.states[p].length + 1 === this.states[q].length) {\n        this.states[curr].link = q;\n      } else {\n        // Clone state q\n        let clone = this.size++;\n        this.states[clone] = new State();\n        this.states[clone].length = this.states[p].length + 1;\n        this.states[clone].transitions = new Map(this.states[q].transitions);\n        this.states[clone].link = this.states[q].link;\n\n        while (p !== null && this.states[p].transitions.get(c) === q) {\n          this.states[p].transitions.set(c, clone);\n          p = this.states[p].link;\n        }\n\n        this.states[q].link = this.states[curr].link = clone;\n      }\n    }\n    this.last = curr;\n  }\n\n  // Build automaton from string\n  build(str) {\n    for (let char of str) {\n      this.addChar(char);\n    }\n  }\n\n  // Check if a string is a substring\n  contains(str) {\n    let state = 0;\n    for (let char of str) {\n      if (!this.states[state].transitions.has(char)) {\n        return false;\n      }\n      state = this.states[state].transitions.get(char);\n    }\n    return true;\n  }\n}\n\n\nconst sa = new SuffixAutomaton();\nsa.build("banana");\n\nconsole.log(sa.contains("ana")); // true\nconsole.log(sa.contains("nan")); // true\nconsole.log(sa.contains("ban")); // true\nconsole.log(sa.contains("xyz")); // false\nconsole.log(sa.contains("baa")); // false\n'})}),"\n",(0,s.jsx)(n.h2,{id:"problems-on-leetcode",children:"Problems on Leetcode"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"214 - Shortest Palindrome"}),"\n",(0,s.jsx)(n.li,{children:"459 - Repeated Substring Pattern"}),"\n",(0,s.jsx)(n.li,{children:"1316 - Distinct Echo Substrings"}),"\n",(0,s.jsx)(n.li,{children:"1698 - Number of Distinct Substrings"}),"\n",(0,s.jsx)(n.li,{children:"1044 - Longest Duplicate Substring"}),"\n",(0,s.jsx)(n.li,{children:"1181 - Before and After Puzzle"}),"\n"]})]})}function u(t={}){const{wrapper:n}={...(0,i.R)(),...t.components};return n?(0,s.jsx)(n,{...t,children:(0,s.jsx)(h,{...t})}):h(t)}}}]);