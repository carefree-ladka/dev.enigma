"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[7292],{28453:(n,e,r)=>{r.d(e,{R:()=>a,x:()=>o});var t=r(96540);const i={},s=t.createContext(i);function a(n){const e=t.useContext(s);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:a(n.components),t.createElement(s.Provider,{value:e},n.children)}},97802:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>o,toc:()=>c});var t=r(74848),i=r(28453);const s={},a="Complete Recursion",o={id:"DSA/DSA with JavaScript/DSA Cheatsheets/Recursion",title:"Complete Recursion",description:"A comprehensive guide to recursion algorithms, patterns, and all types of recursive techniques for Data Structures and Algorithms.",source:"@site/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Recursion.mdx",sourceDirName:"DSA/DSA with JavaScript/DSA Cheatsheets",slug:"/DSA/DSA with JavaScript/DSA Cheatsheets/Recursion",permalink:"/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Recursion",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Recursion.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Queue",permalink:"/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Queue Techniques"},next:{title:"Sliding Window",permalink:"/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Sliding Window"}},l={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Core Recursion Concepts",id:"core-recursion-concepts",level:2},{value:"Essential Components:",id:"essential-components",level:3},{value:"When to Use Recursion:",id:"when-to-use-recursion",level:3},{value:"Types of Recursion",id:"types-of-recursion",level:2},{value:"1. <strong>Linear Recursion</strong>",id:"1-linear-recursion",level:3},{value:"2. <strong>Binary Recursion</strong>",id:"2-binary-recursion",level:3},{value:"3. <strong>Multiple Recursion</strong>",id:"3-multiple-recursion",level:3},{value:"4. <strong>Tail Recursion</strong>",id:"4-tail-recursion",level:3},{value:"5. <strong>Head Recursion</strong>",id:"5-head-recursion",level:3},{value:"6. <strong>Mutual Recursion</strong>",id:"6-mutual-recursion",level:3},{value:"7. <strong>Indirect Recursion</strong>",id:"7-indirect-recursion",level:3},{value:"8. <strong>Nested Recursion</strong>",id:"8-nested-recursion",level:3},{value:"The Recursion Template",id:"the-recursion-template",level:2},{value:"Basic Recursion Template",id:"basic-recursion-template",level:3},{value:"Generic Recursion Framework",id:"generic-recursion-framework",level:3},{value:"Linear Recursion Patterns",id:"linear-recursion-patterns",level:2},{value:"1. Simple Linear Recursion - Factorial",id:"1-simple-linear-recursion---factorial",level:3},{value:"2. Linear Search in Array",id:"2-linear-search-in-array",level:3},{value:"3. Sum of Array Elements",id:"3-sum-of-array-elements",level:3},{value:"4. Linked List Operations",id:"4-linked-list-operations",level:3},{value:"5. String Processing",id:"5-string-processing",level:3},{value:"Binary Recursion Patterns",id:"binary-recursion-patterns",level:2},{value:"1. Classic Binary Recursion - Fibonacci",id:"1-classic-binary-recursion---fibonacci",level:3},{value:"2. Binary Tree Operations",id:"2-binary-tree-operations",level:3},{value:"3. Binary Search",id:"3-binary-search",level:3},{value:"4. Merge Sort (Divide and Conquer)",id:"4-merge-sort-divide-and-conquer",level:3},{value:"Multiple Recursion Patterns",id:"multiple-recursion-patterns",level:2},{value:"1. Tree with Multiple Children",id:"1-tree-with-multiple-children",level:3},{value:"2. Maze Solving (4 Directions)",id:"2-maze-solving-4-directions",level:3},{value:"3. Generate All Subsets",id:"3-generate-all-subsets",level:3},{value:"4. Tower of Hanoi",id:"4-tower-of-hanoi",level:3},{value:"Tail Recursion Optimization",id:"tail-recursion-optimization",level:2},{value:"1. Tail Recursive Factorial",id:"1-tail-recursive-factorial",level:3},{value:"2. Tail Recursive Sum",id:"2-tail-recursive-sum",level:3},{value:"3. Tail Recursive Fibonacci",id:"3-tail-recursive-fibonacci",level:3},{value:"4. Converting to Iterative",id:"4-converting-to-iterative",level:3},{value:"Mutual Recursion Patterns",id:"mutual-recursion-patterns",level:2},{value:"1. Even/Odd Check",id:"1-evenodd-check",level:3},{value:"2. Expression Parsing",id:"2-expression-parsing",level:3},{value:"3. Grammar Parsing",id:"3-grammar-parsing",level:3},{value:"4. State Machine",id:"4-state-machine",level:3},{value:"Indirect Recursion",id:"indirect-recursion",level:2},{value:"1. Three-Function Chain",id:"1-three-function-chain",level:3},{value:"2. Complex Number Calculation",id:"2-complex-number-calculation",level:3},{value:"3. Document Processing Chain",id:"3-document-processing-chain",level:3},{value:"Nested Recursion",id:"nested-recursion",level:2},{value:"1. Ackermann Function",id:"1-ackermann-function",level:3},{value:"2. McCarthy&#39;s 91 Function",id:"2-mccarthys-91-function",level:3},{value:"3. Nested Tree Processing",id:"3-nested-tree-processing",level:3},{value:"4. Complex Mathematical Functions",id:"4-complex-mathematical-functions",level:3},{value:"Tree Recursion Patterns",id:"tree-recursion-patterns",level:2},{value:"1. Binary Tree Traversals",id:"1-binary-tree-traversals",level:3},{value:"2. Tree Validation",id:"2-tree-validation",level:3},{value:"Dynamic Programming with Recursion",id:"dynamic-programming-with-recursion",level:2},{value:"1. Classic DP Problems",id:"1-classic-dp-problems",level:3},{value:"2. Coin Change Problems",id:"2-coin-change-problems",level:3},{value:"3. Path Problems",id:"3-path-problems",level:3},{value:"Linear Recursion Patterns",id:"linear-recursion-patterns-1",level:2},{value:"1. Simple Linear Recursion - Factorial",id:"1-simple-linear-recursion---factorial-1",level:3},{value:"2. Linear Search in Array",id:"2-linear-search-in-array-1",level:3},{value:"3. Sum of Array Elements",id:"3-sum-of-array-elements-1",level:3},{value:"4. Linked List Operations",id:"4-linked-list-operations-1",level:3},{value:"5. String Processing",id:"5-string-processing-1",level:3},{value:"Binary Recursion Patterns",id:"binary-recursion-patterns-1",level:2},{value:"1. Classic Binary Recursion - Fibonacci",id:"1-classic-binary-recursion---fibonacci-1",level:3},{value:"2. Binary Tree Operations",id:"2-binary-tree-operations-1",level:3},{value:"3. Binary Search",id:"3-binary-search-1",level:3},{value:"4. Merge Sort (Divide and Conquer)",id:"4-merge-sort-divide-and-conquer-1",level:3},{value:"Multiple Recursion Patterns",id:"multiple-recursion-patterns-1",level:2},{value:"1. Tree with Multiple Children",id:"1-tree-with-multiple-children-1",level:3},{value:"2. Maze Solving (4 Directions)",id:"2-maze-solving-4-directions-1",level:3},{value:"3. Generate All Subsets",id:"3-generate-all-subsets-1",level:3},{value:"4. Tower of Hanoi",id:"4-tower-of-hanoi-1",level:3},{value:"Tail Recursion Optimization",id:"tail-recursion-optimization-1",level:2},{value:"1. Tail Recursive Factorial",id:"1-tail-recursive-factorial-1",level:3},{value:"2. Tail Recursive Sum",id:"2-tail-recursive-sum-1",level:3},{value:"3. Tail Recursive Fibonacci",id:"3-tail-recursive-fibonacci-1",level:3},{value:"4. Converting to Iterative",id:"4-converting-to-iterative-1",level:3},{value:"Mutual Recursion Patterns",id:"mutual-recursion-patterns-1",level:2},{value:"1. Even/Odd Check",id:"1-evenodd-check-1",level:3},{value:"2. Expression Parsing",id:"2-expression-parsing-1",level:3},{value:"3. Grammar Parsing",id:"3-grammar-parsing-1",level:3},{value:"4. State Machine",id:"4-state-machine-1",level:3},{value:"Indirect Recursion",id:"indirect-recursion-1",level:2},{value:"1. Three-Function Chain",id:"1-three-function-chain-1",level:3},{value:"2. Complex Number Calculation",id:"2-complex-number-calculation-1",level:3},{value:"3. Document Processing Chain",id:"3-document-processing-chain-1",level:3},{value:"Nested Recursion",id:"nested-recursion-1",level:2},{value:"1. Ackermann Function",id:"1-ackermann-function-1",level:3},{value:"2. McCarthy&#39;s 91 Function",id:"2-mccarthys-91-function-1",level:3},{value:"3. Nested Tree Processing",id:"3-nested-tree-processing-1",level:3},{value:"4. Complex Mathematical Functions",id:"4-complex-mathematical-functions-1",level:3},{value:"Tree Recursion Patterns",id:"tree-recursion-patterns-1",level:2},{value:"1. Binary Tree Traversals",id:"1-binary-tree-traversals-1",level:3},{value:"2. Tree Validation",id:"2-tree-validation-1",level:3},{value:"3. Path Finding in Trees",id:"3-path-finding-in-trees",level:3},{value:"4. Tree Construction",id:"4-tree-construction",level:3},{value:"Mathematical Recursion",id:"mathematical-recursion",level:2},{value:"1. Greatest Common Divisor (GCD)",id:"1-greatest-common-divisor-gcd",level:3},{value:"2. Power Function",id:"2-power-function",level:3},{value:"3. Combinatorics",id:"3-combinatorics",level:3},{value:"4. Number Theory",id:"4-number-theory",level:3},{value:"String Recursion Patterns",id:"string-recursion-patterns",level:2},{value:"1. String Manipulation",id:"1-string-manipulation",level:3},{value:"2. String Validation",id:"2-string-validation",level:3},{value:"3. Pattern Matching",id:"3-pattern-matching",level:3},{value:"4. String Generation",id:"4-string-generation",level:3},{value:"Array &amp; List Recursion",id:"array--list-recursion",level:2},{value:"1. Array Processing",id:"1-array-processing",level:3},{value:"2. Array Searching",id:"2-array-searching",level:3},{value:"3. Array Transformation",id:"3-array-transformation",level:3},{value:"4. Advanced Array Operations",id:"4-advanced-array-operations",level:3},{value:"Divide and Conquer",id:"divide-and-conquer",level:2},{value:"1. Classic Sorting Algorithms",id:"1-classic-sorting-algorithms",level:3},{value:"2. Maximum Subarray (Kadane&#39;s Algorithm - Divide &amp; Conquer)",id:"2-maximum-subarray-kadanes-algorithm---divide--conquer",level:3},{value:"3. Closest Pair of Points",id:"3-closest-pair-of-points",level:3},{value:"4. Matrix Multiplication (Strassen&#39;s Algorithm)",id:"4-matrix-multiplication-strassens-algorithm",level:3},{value:"Dynamic Programming with Recursion",id:"dynamic-programming-with-recursion-1",level:2},{value:"1. Classic DP Problems",id:"1-classic-dp-problems-1",level:3},{value:"2. Coin Change Problems",id:"2-coin-change-problems-1",level:3},{value:"3. Path Problems",id:"3-path-problems-1",level:3},{value:"4. Subsequence Problems",id:"4-subsequence-problems",level:3},{value:"Recursion Optimization Techniques",id:"recursion-optimization-techniques",level:2},{value:"1. Memoization",id:"1-memoization",level:3},{value:"2. Tail Call Optimization",id:"2-tail-call-optimization",level:3},{value:"3. Space Optimization",id:"3-space-optimization",level:3},{value:"4. Early Termination",id:"4-early-termination",level:3},{value:"Converting Recursion to Iteration",id:"converting-recursion-to-iteration",level:2},{value:"1. Using Explicit Stack",id:"1-using-explicit-stack",level:3},{value:"2. State Machine Approach",id:"2-state-machine-approach",level:3},{value:"3. Loop Transformation",id:"3-loop-transformation",level:3},{value:"Common Pitfalls &amp; Debugging",id:"common-pitfalls--debugging",level:2},{value:"1. Common Pitfalls",id:"1-common-pitfalls",level:3},{value:"2. Debugging Techniques",id:"2-debugging-techniques",level:3},{value:"3. Validation and Testing",id:"3-validation-and-testing",level:3},{value:"Real-World Applications",id:"real-world-applications",level:2},{value:"1. File System Operations",id:"1-file-system-operations",level:3},{value:"2. JSON/XML Processing",id:"2-jsonxml-processing",level:3},{value:"3. Algorithm Implementation",id:"3-algorithm-implementation",level:3},{value:"4. Data Structure Implementation",id:"4-data-structure-implementation",level:3},{value:"Conclusion",id:"conclusion",level:2},{value:"Best Practices:",id:"best-practices",level:3},{value:"When to Use Recursion:",id:"when-to-use-recursion-1",level:3},{value:"Alternatives to Consider:",id:"alternatives-to-consider",level:3},{value:"Table of Contents",id:"table-of-contents-1",level:2},{value:"Core Recursion Concepts",id:"core-recursion-concepts-1",level:2},{value:"Essential Components:",id:"essential-components-1",level:3},{value:"When to Use Recursion:",id:"when-to-use-recursion-2",level:3},{value:"Types of Recursion",id:"types-of-recursion-1",level:2},{value:"1. <strong>Linear Recursion</strong>",id:"1-linear-recursion-1",level:3},{value:"2. <strong>Binary Recursion</strong>",id:"2-binary-recursion-1",level:3},{value:"3. <strong>Multiple Recursion</strong>",id:"3-multiple-recursion-1",level:3},{value:"4. <strong>Tail Recursion</strong>",id:"4-tail-recursion-1",level:3},{value:"5. <strong>Head Recursion</strong>",id:"5-head-recursion-1",level:3},{value:"6. <strong>Mutual Recursion</strong>",id:"6-mutual-recursion-1",level:3},{value:"7. <strong>Indirect Recursion</strong>",id:"7-indirect-recursion-1",level:3},{value:"8. <strong>Nested Recursion</strong>",id:"8-nested-recursion-1",level:3},{value:"The Recursion Template",id:"the-recursion-template-1",level:2},{value:"Basic Recursion Template",id:"basic-recursion-template-1",level:3},{value:"Generic Recursion Framework",id:"generic-recursion-framework-1",level:3},{value:"Linear Recursion Patterns",id:"linear-recursion-patterns-2",level:2},{value:"1. Simple Linear Recursion - Factorial",id:"1-simple-linear-recursion---factorial-2",level:3},{value:"2. Linear Search in Array",id:"2-linear-search-in-array-2",level:3},{value:"3. Sum of Array Elements",id:"3-sum-of-array-elements-2",level:3},{value:"4. Linked List Operations",id:"4-linked-list-operations-2",level:3},{value:"5. String Processing",id:"5-string-processing-2",level:3},{value:"Binary Recursion Patterns",id:"binary-recursion-patterns-2",level:2},{value:"1. Classic Binary Recursion - Fibonacci",id:"1-classic-binary-recursion---fibonacci-2",level:3},{value:"2. Binary Tree Operations",id:"2-binary-tree-operations-2",level:3},{value:"3. Binary Search",id:"3-binary-search-2",level:3},{value:"4. Merge Sort (Divide and Conquer)",id:"4-merge-sort-divide-and-conquer-2",level:3},{value:"Multiple Recursion Patterns",id:"multiple-recursion-patterns-2",level:2},{value:"1. Tree with Multiple Children",id:"1-tree-with-multiple-children-2",level:3},{value:"2. Maze Solving (4 Directions)",id:"2-maze-solving-4-directions-2",level:3},{value:"3. Generate All Subsets",id:"3-generate-all-subsets-2",level:3},{value:"4. Tower of Hanoi",id:"4-tower-of-hanoi-2",level:3},{value:"Tail Recursion Optimization",id:"tail-recursion-optimization-2",level:2},{value:"1. Tail Recursive Factorial",id:"1-tail-recursive-factorial-2",level:3},{value:"2. Tail Recursive Sum",id:"2-tail-recursive-sum-2",level:3},{value:"3. Tail Recursive Fibonacci",id:"3-tail-recursive-fibonacci-2",level:3},{value:"4. Converting to Iterative",id:"4-converting-to-iterative-2",level:3},{value:"Mutual Recursion Patterns",id:"mutual-recursion-patterns-2",level:2},{value:"1. Even/Odd Check",id:"1-evenodd-check-2",level:3},{value:"2. Expression Parsing",id:"2-expression-parsing-2",level:3},{value:"3. Grammar Parsing",id:"3-grammar-parsing-2",level:3},{value:"4. State Machine",id:"4-state-machine-2",level:3},{value:"Indirect Recursion",id:"indirect-recursion-2",level:2},{value:"1. Three-Function Chain",id:"1-three-function-chain-2",level:3},{value:"2. Complex Number Calculation",id:"2-complex-number-calculation-2",level:3},{value:"3. Document Processing Chain",id:"3-document-processing-chain-2",level:3},{value:"Nested Recursion",id:"nested-recursion-2",level:2},{value:"1. Ackermann Function",id:"1-ackermann-function-2",level:3},{value:"2. McCarthy&#39;s 91 Function",id:"2-mccarthys-91-function-2",level:3},{value:"3. Nested Tree Processing",id:"3-nested-tree-processing-2",level:3},{value:"4. Complex Mathematical Functions",id:"4-complex-mathematical-functions-2",level:3},{value:"Tree Recursion Patterns",id:"tree-recursion-patterns-2",level:2},{value:"1. Binary Tree Traversals",id:"1-binary-tree-traversals-2",level:3},{value:"2. Tree Validation",id:"2-tree-validation-2",level:3},{value:"3. Path Finding in Trees",id:"3-path-finding-in-trees-1",level:3},{value:"4. Tree Construction",id:"4-tree-construction-1",level:3},{value:"Mathematical Recursion",id:"mathematical-recursion-1",level:2},{value:"1. Greatest Common Divisor (GCD)",id:"1-greatest-common-divisor-gcd-1",level:3},{value:"2. Power Function",id:"2-power-function-1",level:3},{value:"3. Combinatorics",id:"3-combinatorics-1",level:3},{value:"4. Number Theory",id:"4-number-theory-1",level:3},{value:"String Recursion Patterns",id:"string-recursion-patterns-1",level:2},{value:"1. String Manipulation",id:"1-string-manipulation-1",level:3},{value:"2. String Validation",id:"2-string-validation-1",level:3},{value:"3. Pattern Matching",id:"3-pattern-matching-1",level:3},{value:"4. String Generation",id:"4-string-generation-1",level:3},{value:"Array &amp; List Recursion",id:"array--list-recursion-1",level:2},{value:"1. Array Processing",id:"1-array-processing-1",level:3},{value:"2. Array Searching",id:"2-array-searching-1",level:3},{value:"3. Array Transformation",id:"3-array-transformation-1",level:3},{value:"4. Advanced Array Operations",id:"4-advanced-array-operations-1",level:3},{value:"Divide and Conquer",id:"divide-and-conquer-1",level:2},{value:"1. Classic Sorting Algorithms",id:"1-classic-sorting-algorithms-1",level:3},{value:"2. Maximum Subarray (Kadane&#39;s Algorithm - Divide &amp; Conquer)",id:"2-maximum-subarray-kadanes-algorithm---divide--conquer-1",level:3},{value:"3. Closest Pair of Points",id:"3-closest-pair-of-points-1",level:3},{value:"4. Matrix Multiplication (Strassen&#39;s Algorithm)",id:"4-matrix-multiplication-strassens-algorithm-1",level:3}];function u(n){const e={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"complete-recursion",children:"Complete Recursion"})}),"\n",(0,t.jsx)(e.p,{children:"A comprehensive guide to recursion algorithms, patterns, and all types of recursive techniques for Data Structures and Algorithms."}),"\n",(0,t.jsx)(e.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#core-recursion-concepts",children:"Core Recursion Concepts"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#types-of-recursion",children:"Types of Recursion"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#the-recursion-template",children:"The Recursion Template"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#linear-recursion-patterns",children:"Linear Recursion Patterns"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#binary-recursion-patterns",children:"Binary Recursion Patterns"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#multiple-recursion-patterns",children:"Multiple Recursion Patterns"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#tail-recursion-optimization",children:"Tail Recursion Optimization"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#mutual-recursion-patterns",children:"Mutual Recursion Patterns"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#indirect-recursion",children:"Indirect Recursion"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#nested-recursion",children:"Nested Recursion"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#tree-recursion-patterns",children:"Tree Recursion Patterns"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#mathematical-recursion",children:"Mathematical Recursion"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#string-recursion-patterns",children:"String Recursion Patterns"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#array--list-recursion",children:"Array & List Recursion"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#divide-and-conquer",children:"Divide and Conquer"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#dynamic-programming-with-recursion",children:"Dynamic Programming with Recursion"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#recursion-optimization-techniques",children:"Recursion Optimization Techniques"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#converting-recursion-to-iteration",children:"Converting Recursion to Iteration"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#common-pitfalls--debugging",children:"Common Pitfalls & Debugging"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#real-world-applications",children:"Real-World Applications"})}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"core-recursion-concepts",children:"Core Recursion Concepts"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Recursion"})," is a problem-solving technique where a function calls itself to solve smaller instances of the same problem."]}),"\n",(0,t.jsx)(e.h3,{id:"essential-components",children:"Essential Components:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Base Case"}),": Condition to stop recursion"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Recursive Case"}),": Function calls itself with modified parameters"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Progress"}),": Each call moves toward base case"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Return"}),": Combines results from recursive calls"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"when-to-use-recursion",children:"When to Use Recursion:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Problem can be broken into similar smaller subproblems"}),"\n",(0,t.jsx)(e.li,{children:"Natural recursive structure (trees, fractals)"}),"\n",(0,t.jsx)(e.li,{children:"Mathematical sequences and formulas"}),"\n",(0,t.jsx)(e.li,{children:"Divide and conquer algorithms"}),"\n",(0,t.jsx)(e.li,{children:"Exploring all possibilities (backtracking)"}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"types-of-recursion",children:"Types of Recursion"}),"\n",(0,t.jsxs)(e.h3,{id:"1-linear-recursion",children:["1. ",(0,t.jsx)(e.strong,{children:"Linear Recursion"})]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["Function makes ",(0,t.jsx)(e.strong,{children:"one recursive call"})," per execution"]}),"\n",(0,t.jsx)(e.li,{children:"Forms a linear chain of calls"}),"\n"]}),"\n",(0,t.jsxs)(e.h3,{id:"2-binary-recursion",children:["2. ",(0,t.jsx)(e.strong,{children:"Binary Recursion"})]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["Function makes ",(0,t.jsx)(e.strong,{children:"two recursive calls"})," per execution"]}),"\n",(0,t.jsx)(e.li,{children:"Common in binary trees and divide-and-conquer"}),"\n"]}),"\n",(0,t.jsxs)(e.h3,{id:"3-multiple-recursion",children:["3. ",(0,t.jsx)(e.strong,{children:"Multiple Recursion"})]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["Function makes ",(0,t.jsx)(e.strong,{children:"multiple recursive calls"})," (more than 2)"]}),"\n",(0,t.jsx)(e.li,{children:"Seen in tree traversals with multiple children"}),"\n"]}),"\n",(0,t.jsxs)(e.h3,{id:"4-tail-recursion",children:["4. ",(0,t.jsx)(e.strong,{children:"Tail Recursion"})]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["Recursive call is the ",(0,t.jsx)(e.strong,{children:"last operation"})," in function"]}),"\n",(0,t.jsx)(e.li,{children:"Can be optimized to iteration by compilers"}),"\n"]}),"\n",(0,t.jsxs)(e.h3,{id:"5-head-recursion",children:["5. ",(0,t.jsx)(e.strong,{children:"Head Recursion"})]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["Recursive call is ",(0,t.jsx)(e.strong,{children:"before"})," other operations"]}),"\n",(0,t.jsx)(e.li,{children:"Processing happens on the way back"}),"\n"]}),"\n",(0,t.jsxs)(e.h3,{id:"6-mutual-recursion",children:["6. ",(0,t.jsx)(e.strong,{children:"Mutual Recursion"})]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Two or more functions"})," call each other recursively"]}),"\n",(0,t.jsx)(e.li,{children:"Creates interdependent recursive relationships"}),"\n"]}),"\n",(0,t.jsxs)(e.h3,{id:"7-indirect-recursion",children:["7. ",(0,t.jsx)(e.strong,{children:"Indirect Recursion"})]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Function A calls function B, which eventually calls A"}),"\n",(0,t.jsx)(e.li,{children:"More complex call chain than direct recursion"}),"\n"]}),"\n",(0,t.jsxs)(e.h3,{id:"8-nested-recursion",children:["8. ",(0,t.jsx)(e.strong,{children:"Nested Recursion"})]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["Recursive call uses ",(0,t.jsx)(e.strong,{children:"another recursive call as parameter"})]}),"\n",(0,t.jsx)(e.li,{children:"Very complex, like Ackermann function"}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"the-recursion-template",children:"The Recursion Template"}),"\n",(0,t.jsx)(e.h3,{id:"basic-recursion-template",children:"Basic Recursion Template"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function recursiveFunction(parameters) {\n  // Base case(s) - Stop condition\n  if (baseCondition(parameters)) {\n    return baseValue;\n  }\n\n  // Recursive case - Self-call with modified parameters\n  return combineResults(\n    recursiveFunction(modifyParameters(parameters)),\n    // possibly more recursive calls\n    otherProcessing(parameters)\n  );\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"generic-recursion-framework",children:"Generic Recursion Framework"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"class RecursionSolver {\n  constructor() {\n    this.memo = new Map(); // For memoization\n    this.callStack = []; // For debugging\n  }\n\n  solve(problem, enableMemo = false) {\n    if (enableMemo) {\n      return this.solveWithMemo(problem);\n    }\n    return this.recursiveSolve(problem);\n  }\n\n  recursiveSolve(problem) {\n    // Add to call stack for debugging\n    this.callStack.push(problem);\n\n    // Base case check\n    if (this.isBaseCase(problem)) {\n      this.callStack.pop();\n      return this.getBaseValue(problem);\n    }\n\n    // Break into subproblems\n    const subproblems = this.decompose(problem);\n    const results = [];\n\n    // Solve each subproblem\n    for (let subproblem of subproblems) {\n      results.push(this.recursiveSolve(subproblem));\n    }\n\n    // Combine results\n    const finalResult = this.combine(results, problem);\n\n    this.callStack.pop();\n    return finalResult;\n  }\n\n  solveWithMemo(problem) {\n    const key = this.getKey(problem);\n    if (this.memo.has(key)) {\n      return this.memo.get(key);\n    }\n\n    const result = this.recursiveSolve(problem);\n    this.memo.set(key, result);\n    return result;\n  }\n\n  // Abstract methods to override\n  isBaseCase(problem) {\n    throw new Error('Override this method');\n  }\n  getBaseValue(problem) {\n    throw new Error('Override this method');\n  }\n  decompose(problem) {\n    throw new Error('Override this method');\n  }\n  combine(results, problem) {\n    throw new Error('Override this method');\n  }\n  getKey(problem) {\n    return JSON.stringify(problem);\n  }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"linear-recursion-patterns",children:"Linear Recursion Patterns"}),"\n",(0,t.jsxs)(e.p,{children:["Linear recursion makes exactly ",(0,t.jsx)(e.strong,{children:"one recursive call"})," per execution."]}),"\n",(0,t.jsx)(e.h3,{id:"1-simple-linear-recursion---factorial",children:"1. Simple Linear Recursion - Factorial"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function factorial(n) {\n  // Base case\n  if (n <= 1) return 1;\n\n  // Recursive case: one recursive call\n  return n * factorial(n - 1);\n}\n\n// Call trace for factorial(4):\n// factorial(4) = 4 * factorial(3)\n// factorial(3) = 3 * factorial(2)\n// factorial(2) = 2 * factorial(1)\n// factorial(1) = 1\n// Result: 4 * 3 * 2 * 1 = 24\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-linear-search-in-array",children:"2. Linear Search in Array"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function linearSearchRecursive(arr, target, index = 0) {\n  // Base case: not found\n  if (index >= arr.length) return -1;\n\n  // Base case: found\n  if (arr[index] === target) return index;\n\n  // Recursive case: search in rest of array\n  return linearSearchRecursive(arr, target, index + 1);\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-sum-of-array-elements",children:"3. Sum of Array Elements"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function arraySum(arr, index = 0) {\n  // Base case\n  if (index >= arr.length) return 0;\n\n  // Recursive case\n  return arr[index] + arraySum(arr, index + 1);\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"4-linked-list-operations",children:"4. Linked List Operations"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"class ListNode {\n  constructor(val, next = null) {\n    this.val = val;\n    this.next = next;\n  }\n}\n\nfunction linkedListLength(head) {\n  // Base case\n  if (!head) return 0;\n\n  // Recursive case\n  return 1 + linkedListLength(head.next);\n}\n\nfunction linkedListSearch(head, target) {\n  // Base case: not found\n  if (!head) return null;\n\n  // Base case: found\n  if (head.val === target) return head;\n\n  // Recursive case\n  return linkedListSearch(head.next, target);\n}\n\nfunction reverseLinkedList(head) {\n  // Base case\n  if (!head || !head.next) return head;\n\n  // Recursive case\n  const newHead = reverseLinkedList(head.next);\n  head.next.next = head;\n  head.next = null;\n\n  return newHead;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"5-string-processing",children:"5. String Processing"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function isPalindrome(str, left = 0, right = str.length - 1) {\n  // Base case\n  if (left >= right) return true;\n\n  // Check current characters and recurse\n  if (str[left] !== str[right]) return false;\n  return isPalindrome(str, left + 1, right - 1);\n}\n\nfunction reverseString(str) {\n  // Base case\n  if (str.length <= 1) return str;\n\n  // Recursive case\n  return str[str.length - 1] + reverseString(str.slice(0, -1));\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"binary-recursion-patterns",children:"Binary Recursion Patterns"}),"\n",(0,t.jsxs)(e.p,{children:["Binary recursion makes exactly ",(0,t.jsx)(e.strong,{children:"two recursive calls"})," per execution."]}),"\n",(0,t.jsx)(e.h3,{id:"1-classic-binary-recursion---fibonacci",children:"1. Classic Binary Recursion - Fibonacci"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function fibonacci(n) {\n  // Base cases\n  if (n <= 1) return n;\n\n  // Binary recursive case\n  return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\n// Optimized with memoization\nfunction fibonacciMemo(n, memo = {}) {\n  if (n in memo) return memo[n];\n  if (n <= 1) return n;\n\n  memo[n] = fibonacciMemo(n - 1, memo) + fibonacciMemo(n - 2, memo);\n  return memo[n];\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-binary-tree-operations",children:"2. Binary Tree Operations"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"class TreeNode {\n  constructor(val, left = null, right = null) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}\n\n// Tree height/depth\nfunction maxDepth(root) {\n  // Base case\n  if (!root) return 0;\n\n  // Binary recursive case\n  return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\n}\n\n// Count total nodes\nfunction countNodes(root) {\n  if (!root) return 0;\n  return 1 + countNodes(root.left) + countNodes(root.right);\n}\n\n// Check if tree is balanced\nfunction isBalanced(root) {\n  function checkHeight(node) {\n    if (!node) return 0;\n\n    const leftHeight = checkHeight(node.left);\n    if (leftHeight === -1) return -1;\n\n    const rightHeight = checkHeight(node.right);\n    if (rightHeight === -1) return -1;\n\n    if (Math.abs(leftHeight - rightHeight) > 1) return -1;\n\n    return 1 + Math.max(leftHeight, rightHeight);\n  }\n\n  return checkHeight(root) !== -1;\n}\n\n// Binary tree paths\nfunction binaryTreePaths(root, currentPath = '', paths = []) {\n  if (!root) return paths;\n\n  currentPath += root.val;\n\n  // Leaf node\n  if (!root.left && !root.right) {\n    paths.push(currentPath);\n  } else {\n    // Binary recursion\n    if (root.left) binaryTreePaths(root.left, currentPath + '->', paths);\n    if (root.right) binaryTreePaths(root.right, currentPath + '->', paths);\n  }\n\n  return paths;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-binary-search",children:"3. Binary Search"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function binarySearch(arr, target, left = 0, right = arr.length - 1) {\n  // Base case: not found\n  if (left > right) return -1;\n\n  const mid = Math.floor((left + right) / 2);\n\n  // Base case: found\n  if (arr[mid] === target) return mid;\n\n  // Binary recursive cases\n  if (target < arr[mid]) {\n    return binarySearch(arr, target, left, mid - 1);\n  } else {\n    return binarySearch(arr, target, mid + 1, right);\n  }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"4-merge-sort-divide-and-conquer",children:"4. Merge Sort (Divide and Conquer)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function mergeSort(arr) {\n  // Base case\n  if (arr.length <= 1) return arr;\n\n  // Divide\n  const mid = Math.floor(arr.length / 2);\n  const left = arr.slice(0, mid);\n  const right = arr.slice(mid);\n\n  // Binary recursive calls\n  const sortedLeft = mergeSort(left);\n  const sortedRight = mergeSort(right);\n\n  // Conquer\n  return merge(sortedLeft, sortedRight);\n}\n\nfunction merge(left, right) {\n  const result = [];\n  let i = 0,\n    j = 0;\n\n  while (i < left.length && j < right.length) {\n    if (left[i] <= right[j]) {\n      result.push(left[i++]);\n    } else {\n      result.push(right[j++]);\n    }\n  }\n\n  return result.concat(left.slice(i)).concat(right.slice(j));\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"multiple-recursion-patterns",children:"Multiple Recursion Patterns"}),"\n",(0,t.jsxs)(e.p,{children:["Multiple recursion makes ",(0,t.jsx)(e.strong,{children:"more than two recursive calls"})," per execution."]}),"\n",(0,t.jsx)(e.h3,{id:"1-tree-with-multiple-children",children:"1. Tree with Multiple Children"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"class TreeNode {\n  constructor(val, children = []) {\n    this.val = val;\n    this.children = children;\n  }\n}\n\nfunction maxDepthNary(root) {\n  if (!root) return 0;\n\n  let maxChildDepth = 0;\n  // Multiple recursive calls for each child\n  for (let child of root.children) {\n    maxChildDepth = Math.max(maxChildDepth, maxDepthNary(child));\n  }\n\n  return 1 + maxChildDepth;\n}\n\nfunction naryTreePaths(root, currentPath = [], allPaths = []) {\n  if (!root) return allPaths;\n\n  currentPath.push(root.val);\n\n  if (root.children.length === 0) {\n    // Leaf node\n    allPaths.push([...currentPath]);\n  } else {\n    // Multiple recursive calls\n    for (let child of root.children) {\n      naryTreePaths(child, currentPath, allPaths);\n    }\n  }\n\n  currentPath.pop(); // Backtrack\n  return allPaths;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-maze-solving-4-directions",children:"2. Maze Solving (4 Directions)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function solveMaze(maze, x = 0, y = 0, solution = null) {\n  const n = maze.length;\n  if (!solution) {\n    solution = Array(n)\n      .fill()\n      .map(() => Array(n).fill(0));\n  }\n\n  // Base case: reached destination\n  if (x === n - 1 && y === n - 1) {\n    solution[x][y] = 1;\n    return true;\n  }\n\n  // Check if current position is valid\n  if (x >= 0 && x < n && y >= 0 && y < n && maze[x][y] === 1) {\n    solution[x][y] = 1;\n\n    // Multiple recursive calls for 4 directions\n    if (\n      solveMaze(maze, x + 1, y, solution) || // Down\n      solveMaze(maze, x, y + 1, solution) || // Right\n      solveMaze(maze, x - 1, y, solution) || // Up\n      solveMaze(maze, x, y - 1, solution)\n    ) {\n      // Left\n      return true;\n    }\n\n    // Backtrack\n    solution[x][y] = 0;\n  }\n\n  return false;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-generate-all-subsets",children:"3. Generate All Subsets"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function generateSubsets(nums, index = 0, current = [], result = []) {\n  // Base case\n  if (index === nums.length) {\n    result.push([...current]);\n    return result;\n  }\n\n  // Two recursive calls: include or exclude current element\n  // Include current element\n  current.push(nums[index]);\n  generateSubsets(nums, index + 1, current, result);\n\n  // Exclude current element (backtrack)\n  current.pop();\n  generateSubsets(nums, index + 1, current, result);\n\n  return result;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"4-tower-of-hanoi",children:"4. Tower of Hanoi"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function towerOfHanoi(n, source, destination, auxiliary, moves = []) {\n  // Base case\n  if (n === 1) {\n    moves.push(`Move disk 1 from ${source} to ${destination}`);\n    return moves;\n  }\n\n  // Three recursive calls\n  // Move n-1 disks to auxiliary peg\n  towerOfHanoi(n - 1, source, auxiliary, destination, moves);\n\n  // Move the bottom disk to destination\n  moves.push(`Move disk ${n} from ${source} to ${destination}`);\n\n  // Move n-1 disks from auxiliary to destination\n  towerOfHanoi(n - 1, auxiliary, destination, source, moves);\n\n  return moves;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"tail-recursion-optimization",children:"Tail Recursion Optimization"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Tail recursion"})," occurs when the recursive call is the ",(0,t.jsx)(e.strong,{children:"last operation"})," in the function."]}),"\n",(0,t.jsx)(e.h3,{id:"1-tail-recursive-factorial",children:"1. Tail Recursive Factorial"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Non-tail recursive (traditional)\nfunction factorial(n) {\n  if (n <= 1) return 1;\n  return n * factorial(n - 1); // Multiplication after recursive call\n}\n\n// Tail recursive version\nfunction factorialTail(n, accumulator = 1) {\n  if (n <= 1) return accumulator;\n  return factorialTail(n - 1, n * accumulator); // Recursive call is last\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-tail-recursive-sum",children:"2. Tail Recursive Sum"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Non-tail recursive\nfunction sum(n) {\n  if (n <= 0) return 0;\n  return n + sum(n - 1); // Addition after recursive call\n}\n\n// Tail recursive version\nfunction sumTail(n, accumulator = 0) {\n  if (n <= 0) return accumulator;\n  return sumTail(n - 1, accumulator + n); // Recursive call is last\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-tail-recursive-fibonacci",children:"3. Tail Recursive Fibonacci"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function fibonacciTail(n, a = 0, b = 1) {\n  if (n === 0) return a;\n  if (n === 1) return b;\n  return fibonacciTail(n - 1, b, a + b); // Tail recursive\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"4-converting-to-iterative",children:"4. Converting to Iterative"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Tail recursion can be easily converted to iteration\nfunction factorialIterative(n) {\n  let accumulator = 1;\n  while (n > 1) {\n    accumulator *= n;\n    n--;\n  }\n  return accumulator;\n}\n\n// Generic tail recursion to iteration converter\nfunction tailRecursionToIteration(initialValue, condition, update, extract) {\n  let current = initialValue;\n\n  while (!condition(current)) {\n    current = update(current);\n  }\n\n  return extract(current);\n}\n\n// Usage example\nconst factorial_n = tailRecursionToIteration(\n  { n: 5, acc: 1 },\n  state => state.n <= 1,\n  state => ({ n: state.n - 1, acc: state.acc * state.n }),\n  state => state.acc\n);\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"mutual-recursion-patterns",children:"Mutual Recursion Patterns"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Mutual recursion"})," occurs when two or more functions call each other recursively."]}),"\n",(0,t.jsx)(e.h3,{id:"1-evenodd-check",children:"1. Even/Odd Check"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function isEven(n) {\n  if (n === 0) return true;\n  return isOdd(n - 1);\n}\n\nfunction isOdd(n) {\n  if (n === 0) return false;\n  return isEven(n - 1);\n}\n\n// Usage\nconsole.log(isEven(4)); // true\nconsole.log(isOdd(5)); // true\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-expression-parsing",children:"2. Expression Parsing"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function parseExpression(tokens, index) {\n  let result = parseTerm(tokens, index);\n\n  while (\n    index.value < tokens.length &&\n    (tokens[index.value] === '+' || tokens[index.value] === '-')\n  ) {\n    const operator = tokens[index.value++];\n    const term = parseTerm(tokens, index);\n    result = operator === '+' ? result + term : result - term;\n  }\n\n  return result;\n}\n\nfunction parseTerm(tokens, index) {\n  let result = parseFactor(tokens, index);\n\n  while (\n    index.value < tokens.length &&\n    (tokens[index.value] === '*' || tokens[index.value] === '/')\n  ) {\n    const operator = tokens[index.value++];\n    const factor = parseFactor(tokens, index);\n    result = operator === '*' ? result * factor : result / factor;\n  }\n\n  return result;\n}\n\nfunction parseFactor(tokens, index) {\n  if (tokens[index.value] === '(') {\n    index.value++; // Skip '('\n    const result = parseExpression(tokens, index); // Mutual recursion\n    index.value++; // Skip ')'\n    return result;\n  }\n\n  return parseInt(tokens[index.value++]);\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-grammar-parsing",children:"3. Grammar Parsing"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function parseStatement(code, pos) {\n  if (code[pos.index] === 'if') {\n    return parseIfStatement(code, pos);\n  } else if (code[pos.index] === 'while') {\n    return parseWhileStatement(code, pos);\n  } else {\n    return parseAssignment(code, pos);\n  }\n}\n\nfunction parseIfStatement(code, pos) {\n  pos.index++; // Skip 'if'\n  const condition = parseExpression(code, pos);\n  const thenStmt = parseStatement(code, pos); // Mutual recursion\n\n  let elseStmt = null;\n  if (pos.index < code.length && code[pos.index] === 'else') {\n    pos.index++; // Skip 'else'\n    elseStmt = parseStatement(code, pos); // Mutual recursion\n  }\n\n  return { type: 'if', condition, then: thenStmt, else: elseStmt };\n}\n\nfunction parseWhileStatement(code, pos) {\n  pos.index++; // Skip 'while'\n  const condition = parseExpression(code, pos);\n  const body = parseStatement(code, pos); // Mutual recursion\n\n  return { type: 'while', condition, body };\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"4-state-machine",children:"4. State Machine"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function stateA(input, index) {\n  if (index >= input.length) return true;\n\n  if (input[index] === '0') {\n    return stateB(input, index + 1); // Mutual recursion\n  } else if (input[index] === '1') {\n    return stateA(input, index + 1);\n  }\n\n  return false;\n}\n\nfunction stateB(input, index) {\n  if (index >= input.length) return false;\n\n  if (input[index] === '0') {\n    return stateA(input, index + 1); // Mutual recursion\n  } else if (input[index] === '1') {\n    return stateB(input, index + 1);\n  }\n\n  return false;\n}\n\n// Check if string is accepted by the state machine\nfunction isAccepted(input) {\n  return stateA(input, 0);\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"indirect-recursion",children:"Indirect Recursion"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Indirect recursion"})," involves a chain of function calls that eventually leads back to the original function."]}),"\n",(0,t.jsx)(e.h3,{id:"1-three-function-chain",children:"1. Three-Function Chain"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function functionA(n) {\n  console.log(`A: ${n}`);\n  if (n > 0) {\n    return functionB(n - 1);\n  }\n  return 0;\n}\n\nfunction functionB(n) {\n  console.log(`B: ${n}`);\n  if (n > 0) {\n    return functionC(n - 1);\n  }\n  return 1;\n}\n\nfunction functionC(n) {\n  console.log(`C: ${n}`);\n  if (n > 0) {\n    return functionA(n - 1); // Back to A\n  }\n  return 2;\n}\n\n// Call chain: A -> B -> C -> A -> B -> C -> ...\nfunctionA(5);\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-complex-number-calculation",children:"2. Complex Number Calculation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function calculateReal(complex, depth) {\n  if (depth === 0) return complex.real;\n\n  const imagResult = calculateImaginary(\n    { real: complex.real * 0.5, imaginary: complex.imaginary * 0.5 },\n    depth - 1\n  );\n\n  return complex.real + imagResult;\n}\n\nfunction calculateImaginary(complex, depth) {\n  if (depth === 0) return complex.imaginary;\n\n  const realResult = calculateReal(\n    { real: complex.imaginary * 0.3, imaginary: complex.real * 0.7 },\n    depth - 1\n  );\n\n  return complex.imaginary + realResult;\n}\n\nfunction processComplex(complex, depth) {\n  const realPart = calculateReal(complex, depth);\n  const imagPart = calculateImaginary(complex, depth);\n\n  if (depth > 1) {\n    return processComplex({ real: realPart, imaginary: imagPart }, depth - 1);\n  }\n\n  return { real: realPart, imaginary: imagPart };\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-document-processing-chain",children:"3. Document Processing Chain"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function processDocument(doc, stage) {\n  switch (stage) {\n    case 'parse':\n      return parseDocument(doc, 'validate');\n    case 'validate':\n      return validateDocument(doc, 'transform');\n    case 'transform':\n      return transformDocument(doc, 'output');\n    case 'output':\n      return doc;\n    default:\n      return null;\n  }\n}\n\nfunction parseDocument(doc, nextStage) {\n  const parsed = { ...doc, parsed: true };\n  if (parsed.needsValidation) {\n    return processDocument(parsed, nextStage);\n  }\n  return parsed;\n}\n\nfunction validateDocument(doc, nextStage) {\n  const validated = { ...doc, valid: doc.parsed };\n  if (validated.needsTransformation) {\n    return processDocument(validated, nextStage);\n  }\n  return validated;\n}\n\nfunction transformDocument(doc, nextStage) {\n  const transformed = { ...doc, transformed: doc.valid };\n  return processDocument(transformed, nextStage);\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"nested-recursion",children:"Nested Recursion"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Nested recursion"})," occurs when a recursive call uses another recursive call as its parameter."]}),"\n",(0,t.jsx)(e.h3,{id:"1-ackermann-function",children:"1. Ackermann Function"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function ackermann(m, n) {\n  if (m === 0) {\n    return n + 1;\n  } else if (m > 0 && n === 0) {\n    return ackermann(m - 1, 1);\n  } else if (m > 0 && n > 0) {\n    // Nested recursion: recursive call as parameter\n    return ackermann(m - 1, ackermann(m, n - 1));\n  }\n}\n\n// Extremely fast-growing function\nconsole.log(ackermann(3, 2)); // 29\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-mccarthys-91-function",children:"2. McCarthy's 91 Function"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function mcCarthy91(n) {\n  if (n > 100) {\n    return n - 10;\n  } else {\n    // Nested recursion\n    return mcCarthy91(mcCarthy91(n + 11));\n  }\n}\n\n// Always returns 91 for n <= 100\nconsole.log(mcCarthy91(50)); // 91\nconsole.log(mcCarthy91(99)); // 91\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-nested-tree-processing",children:"3. Nested Tree Processing"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function processNestedTree(node) {\n  if (!node) return null;\n\n  if (node.type === 'leaf') {\n    return node.value;\n  }\n\n  if (node.type === 'transform') {\n    // Nested recursion: recursive call as parameter to another recursive call\n    return applyTransform(\n      processNestedTree(node.input),\n      processNestedTree(node.transform)\n    );\n  }\n\n  return processChildren(node.children);\n}\n\nfunction applyTransform(data, transform) {\n  if (!transform) return data;\n\n  if (transform.type === 'nested') {\n    // Another level of nesting\n    return applyTransform(data, processNestedTree(transform.nestedTransform));\n  }\n\n  return transform.fn(data);\n}\n\nfunction processChildren(children) {\n  if (!children || children.length === 0) return [];\n\n  return children.map(child => processNestedTree(child));\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"4-complex-mathematical-functions",children:"4. Complex Mathematical Functions"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function nestedMath(x, depth) {\n  if (depth === 0) return x;\n\n  if (x < 0) {\n    return -nestedMath(-x, depth - 1);\n  }\n\n  // Nested recursion with complex parameter\n  return Math.sqrt(nestedMath(x * nestedMath(x / 2, depth - 1), depth - 1));\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"tree-recursion-patterns",children:"Tree Recursion Patterns"}),"\n",(0,t.jsx)(e.p,{children:"Tree recursion involves recursive calls that form a tree-like structure of execution."}),"\n",(0,t.jsx)(e.h3,{id:"1-binary-tree-traversals",children:"1. Binary Tree Traversals"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Preorder: Root -> Left -> Right\nfunction preorderTraversal(root, result = []) {\n  if (!root) return result;\n\n  result.push(root.val); // Process root\n  preorderTraversal(root.left, result); // Recurse left\n  preorderTraversal(root.right, result); // Recurse right\n\n  return result;\n}\n\n// Inorder: Left -> Root -> Right\nfunction inorderTraversal(root, result = []) {\n  if (!root) return result;\n\n  inorderTraversal(root.left, result); // Recurse left\n  result.push(root.val); // Process root\n  inorderTraversal(root.right, result); // Recurse right\n\n  return result;\n}\n\n// Postorder: Left -> Right -> Root\nfunction postorderTraversal(root, result = []) {\n  if (!root) return result;\n\n  postorderTraversal(root.left, result); // Recurse left\n  postorderTraversal(root.right, result); // Recurse right\n  result.push(root.val); // Process root\n\n  return result;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-tree-validation",children:"2. Tree Validation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function isValidBST(root, min = -Infinity, max = Infinity) {\n  if (!root) return true;\n\n  if (root.val <= min || root.val >= max) return false;\n\n  // Tree recursion with different constraints\n  return (\n    isValidBST(root.left, min, root.val) &&\n    isValidBST(root.right, root.val, max)\n  );\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"dynamic-programming-with-recursion",children:"Dynamic Programming with Recursion"}),"\n",(0,t.jsx)(e.p,{children:"Dynamic Programming combines recursion with memoization to solve optimization problems."}),"\n",(0,t.jsx)(e.h3,{id:"1-classic-dp-problems",children:"1. Classic DP Problems"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Longest Common Subsequence with Memoization\nfunction longestCommonSubsequenceMemo(str1, str2, i = 0, j = 0, memo = {}) {\n  const key = `${i},${j}`;\n  if (key in memo) return memo[key];\n\n  if (i === str1.length || j === str2.length) {\n    return (memo[key] = 0);\n  }\n\n  if (str1[i] === str2[j]) {\n    return (memo[key] =\n      1 + longestCommonSubsequenceMemo(str1, str2, i + 1, j + 1, memo));\n  } else {\n    return (memo[key] = Math.max(\n      longestCommonSubsequenceMemo(str1, str2, i + 1, j, memo),\n      longestCommonSubsequenceMemo(str1, str2, i, j + 1, memo)\n    ));\n  }\n}\n\n// Edit Distance (Levenshtein Distance)\nfunction editDistance(str1, str2, i = 0, j = 0, memo = {}) {\n  const key = `${i},${j}`;\n  if (key in memo) return memo[key];\n\n  if (i === str1.length) return (memo[key] = str2.length - j);\n  if (j === str2.length) return (memo[key] = str1.length - i);\n\n  if (str1[i] === str2[j]) {\n    return (memo[key] = editDistance(str1, str2, i + 1, j + 1, memo));\n  } else {\n    const insert = editDistance(str1, str2, i, j + 1, memo);\n    const delete_ = editDistance(str1, str2, i + 1, j, memo);\n    const replace = editDistance(str1, str2, i + 1, j + 1, memo);\n\n    return (memo[key] = 1 + Math.min(insert, delete_, replace));\n  }\n}\n\n// 0/1 Knapsack Problem\nfunction knapsack(weights, values, capacity, index = 0, memo = {}) {\n  const key = `${capacity},${index}`;\n  if (key in memo) return memo[key];\n\n  if (index === weights.length || capacity === 0) {\n    return (memo[key] = 0);\n  }\n\n  // Don't take current item\n  let maxValue = knapsack(weights, values, capacity, index + 1, memo);\n\n  // Take current item if it fits\n  if (weights[index] <= capacity) {\n    const valueWithCurrent =\n      values[index] +\n      knapsack(weights, values, capacity - weights[index], index + 1, memo);\n    maxValue = Math.max(maxValue, valueWithCurrent);\n  }\n\n  return (memo[key] = maxValue);\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-coin-change-problems",children:"2. Coin Change Problems"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Coin Change - Minimum coins\nfunction coinChangeMinCoins(coins, amount, memo = {}) {\n  if (amount in memo) return memo[amount];\n  if (amount === 0) return 0;\n  if (amount < 0) return Infinity;\n\n  let minCoins = Infinity;\n  for (let coin of coins) {\n    const result = coinChangeMinCoins(coins, amount - coin, memo);\n    if (result !== Infinity) {\n      minCoins = Math.min(minCoins, 1 + result);\n    }\n  }\n\n  return (memo[amount] = minCoins === Infinity ? -1 : minCoins);\n}\n\n// Coin Change - Number of ways\nfunction coinChangeWays(coins, amount, index = 0, memo = {}) {\n  const key = `${amount},${index}`;\n  if (key in memo) return memo[key];\n\n  if (amount === 0) return 1;\n  if (amount < 0 || index >= coins.length) return 0;\n\n  // Include current coin + exclude current coin\n  return (memo[key] =\n    coinChangeWays(coins, amount - coins[index], index, memo) +\n    coinChangeWays(coins, amount, index + 1, memo));\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-path-problems",children:"3. Path Problems"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Unique Paths in Grid\nfunction uniquePaths(m, n, i = 0, j = 0, memo = {}) {\n  const key = `${i},${j}`;\n  if (key in memo) return memo[key];\n\n  if (i === m - 1 && j === n - 1) return 1;\n  if (i >= m || j >= n) return 0;\n\n  return (memo[key] =\n    uniquePaths(m, n, i + 1, j, memo) + uniquePaths(m, n, i, j + 1, memo));\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"linear-recursion-patterns-1",children:"Linear Recursion Patterns"}),"\n",(0,t.jsxs)(e.p,{children:["Linear recursion makes exactly ",(0,t.jsx)(e.strong,{children:"one recursive call"})," per execution."]}),"\n",(0,t.jsx)(e.h3,{id:"1-simple-linear-recursion---factorial-1",children:"1. Simple Linear Recursion - Factorial"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function factorial(n) {\n  // Base case\n  if (n <= 1) return 1;\n\n  // Recursive case: one recursive call\n  return n * factorial(n - 1);\n}\n\n// Call trace for factorial(4):\n// factorial(4) = 4 * factorial(3)\n// factorial(3) = 3 * factorial(2)\n// factorial(2) = 2 * factorial(1)\n// factorial(1) = 1\n// Result: 4 * 3 * 2 * 1 = 24\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-linear-search-in-array-1",children:"2. Linear Search in Array"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function linearSearchRecursive(arr, target, index = 0) {\n  // Base case: not found\n  if (index >= arr.length) return -1;\n\n  // Base case: found\n  if (arr[index] === target) return index;\n\n  // Recursive case: search in rest of array\n  return linearSearchRecursive(arr, target, index + 1);\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-sum-of-array-elements-1",children:"3. Sum of Array Elements"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function arraySum(arr, index = 0) {\n  // Base case\n  if (index >= arr.length) return 0;\n\n  // Recursive case\n  return arr[index] + arraySum(arr, index + 1);\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"4-linked-list-operations-1",children:"4. Linked List Operations"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"class ListNode {\n  constructor(val, next = null) {\n    this.val = val;\n    this.next = next;\n  }\n}\n\nfunction linkedListLength(head) {\n  // Base case\n  if (!head) return 0;\n\n  // Recursive case\n  return 1 + linkedListLength(head.next);\n}\n\nfunction linkedListSearch(head, target) {\n  // Base case: not found\n  if (!head) return null;\n\n  // Base case: found\n  if (head.val === target) return head;\n\n  // Recursive case\n  return linkedListSearch(head.next, target);\n}\n\nfunction reverseLinkedList(head) {\n  // Base case\n  if (!head || !head.next) return head;\n\n  // Recursive case\n  const newHead = reverseLinkedList(head.next);\n  head.next.next = head;\n  head.next = null;\n\n  return newHead;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"5-string-processing-1",children:"5. String Processing"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function isPalindrome(str, left = 0, right = str.length - 1) {\n  // Base case\n  if (left >= right) return true;\n\n  // Check current characters and recurse\n  if (str[left] !== str[right]) return false;\n  return isPalindrome(str, left + 1, right - 1);\n}\n\nfunction reverseString(str) {\n  // Base case\n  if (str.length <= 1) return str;\n\n  // Recursive case\n  return str[str.length - 1] + reverseString(str.slice(0, -1));\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"binary-recursion-patterns-1",children:"Binary Recursion Patterns"}),"\n",(0,t.jsxs)(e.p,{children:["Binary recursion makes exactly ",(0,t.jsx)(e.strong,{children:"two recursive calls"})," per execution."]}),"\n",(0,t.jsx)(e.h3,{id:"1-classic-binary-recursion---fibonacci-1",children:"1. Classic Binary Recursion - Fibonacci"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function fibonacci(n) {\n  // Base cases\n  if (n <= 1) return n;\n\n  // Binary recursive case\n  return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\n// Optimized with memoization\nfunction fibonacciMemo(n, memo = {}) {\n  if (n in memo) return memo[n];\n  if (n <= 1) return n;\n\n  memo[n] = fibonacciMemo(n - 1, memo) + fibonacciMemo(n - 2, memo);\n  return memo[n];\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-binary-tree-operations-1",children:"2. Binary Tree Operations"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"class TreeNode {\n  constructor(val, left = null, right = null) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}\n\n// Tree height/depth\nfunction maxDepth(root) {\n  // Base case\n  if (!root) return 0;\n\n  // Binary recursive case\n  return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\n}\n\n// Count total nodes\nfunction countNodes(root) {\n  if (!root) return 0;\n  return 1 + countNodes(root.left) + countNodes(root.right);\n}\n\n// Check if tree is balanced\nfunction isBalanced(root) {\n  function checkHeight(node) {\n    if (!node) return 0;\n\n    const leftHeight = checkHeight(node.left);\n    if (leftHeight === -1) return -1;\n\n    const rightHeight = checkHeight(node.right);\n    if (rightHeight === -1) return -1;\n\n    if (Math.abs(leftHeight - rightHeight) > 1) return -1;\n\n    return 1 + Math.max(leftHeight, rightHeight);\n  }\n\n  return checkHeight(root) !== -1;\n}\n\n// Binary tree paths\nfunction binaryTreePaths(root, currentPath = '', paths = []) {\n  if (!root) return paths;\n\n  currentPath += root.val;\n\n  // Leaf node\n  if (!root.left && !root.right) {\n    paths.push(currentPath);\n  } else {\n    // Binary recursion\n    if (root.left) binaryTreePaths(root.left, currentPath + '->', paths);\n    if (root.right) binaryTreePaths(root.right, currentPath + '->', paths);\n  }\n\n  return paths;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-binary-search-1",children:"3. Binary Search"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function binarySearch(arr, target, left = 0, right = arr.length - 1) {\n  // Base case: not found\n  if (left > right) return -1;\n\n  const mid = Math.floor((left + right) / 2);\n\n  // Base case: found\n  if (arr[mid] === target) return mid;\n\n  // Binary recursive cases\n  if (target < arr[mid]) {\n    return binarySearch(arr, target, left, mid - 1);\n  } else {\n    return binarySearch(arr, target, mid + 1, right);\n  }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"4-merge-sort-divide-and-conquer-1",children:"4. Merge Sort (Divide and Conquer)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function mergeSort(arr) {\n  // Base case\n  if (arr.length <= 1) return arr;\n\n  // Divide\n  const mid = Math.floor(arr.length / 2);\n  const left = arr.slice(0, mid);\n  const right = arr.slice(mid);\n\n  // Binary recursive calls\n  const sortedLeft = mergeSort(left);\n  const sortedRight = mergeSort(right);\n\n  // Conquer\n  return merge(sortedLeft, sortedRight);\n}\n\nfunction merge(left, right) {\n  const result = [];\n  let i = 0,\n    j = 0;\n\n  while (i < left.length && j < right.length) {\n    if (left[i] <= right[j]) {\n      result.push(left[i++]);\n    } else {\n      result.push(right[j++]);\n    }\n  }\n\n  return result.concat(left.slice(i)).concat(right.slice(j));\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"multiple-recursion-patterns-1",children:"Multiple Recursion Patterns"}),"\n",(0,t.jsxs)(e.p,{children:["Multiple recursion makes ",(0,t.jsx)(e.strong,{children:"more than two recursive calls"})," per execution."]}),"\n",(0,t.jsx)(e.h3,{id:"1-tree-with-multiple-children-1",children:"1. Tree with Multiple Children"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"class TreeNode {\n  constructor(val, children = []) {\n    this.val = val;\n    this.children = children;\n  }\n}\n\nfunction maxDepthNary(root) {\n  if (!root) return 0;\n\n  let maxChildDepth = 0;\n  // Multiple recursive calls for each child\n  for (let child of root.children) {\n    maxChildDepth = Math.max(maxChildDepth, maxDepthNary(child));\n  }\n\n  return 1 + maxChildDepth;\n}\n\nfunction naryTreePaths(root, currentPath = [], allPaths = []) {\n  if (!root) return allPaths;\n\n  currentPath.push(root.val);\n\n  if (root.children.length === 0) {\n    // Leaf node\n    allPaths.push([...currentPath]);\n  } else {\n    // Multiple recursive calls\n    for (let child of root.children) {\n      naryTreePaths(child, currentPath, allPaths);\n    }\n  }\n\n  currentPath.pop(); // Backtrack\n  return allPaths;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-maze-solving-4-directions-1",children:"2. Maze Solving (4 Directions)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function solveMaze(maze, x = 0, y = 0, solution = null) {\n  const n = maze.length;\n  if (!solution) {\n    solution = Array(n)\n      .fill()\n      .map(() => Array(n).fill(0));\n  }\n\n  // Base case: reached destination\n  if (x === n - 1 && y === n - 1) {\n    solution[x][y] = 1;\n    return true;\n  }\n\n  // Check if current position is valid\n  if (x >= 0 && x < n && y >= 0 && y < n && maze[x][y] === 1) {\n    solution[x][y] = 1;\n\n    // Multiple recursive calls for 4 directions\n    if (\n      solveMaze(maze, x + 1, y, solution) || // Down\n      solveMaze(maze, x, y + 1, solution) || // Right\n      solveMaze(maze, x - 1, y, solution) || // Up\n      solveMaze(maze, x, y - 1, solution)\n    ) {\n      // Left\n      return true;\n    }\n\n    // Backtrack\n    solution[x][y] = 0;\n  }\n\n  return false;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-generate-all-subsets-1",children:"3. Generate All Subsets"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function generateSubsets(nums, index = 0, current = [], result = []) {\n  // Base case\n  if (index === nums.length) {\n    result.push([...current]);\n    return result;\n  }\n\n  // Two recursive calls: include or exclude current element\n  // Include current element\n  current.push(nums[index]);\n  generateSubsets(nums, index + 1, current, result);\n\n  // Exclude current element (backtrack)\n  current.pop();\n  generateSubsets(nums, index + 1, current, result);\n\n  return result;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"4-tower-of-hanoi-1",children:"4. Tower of Hanoi"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function towerOfHanoi(n, source, destination, auxiliary, moves = []) {\n  // Base case\n  if (n === 1) {\n    moves.push(`Move disk 1 from ${source} to ${destination}`);\n    return moves;\n  }\n\n  // Three recursive calls\n  // Move n-1 disks to auxiliary peg\n  towerOfHanoi(n - 1, source, auxiliary, destination, moves);\n\n  // Move the bottom disk to destination\n  moves.push(`Move disk ${n} from ${source} to ${destination}`);\n\n  // Move n-1 disks from auxiliary to destination\n  towerOfHanoi(n - 1, auxiliary, destination, source, moves);\n\n  return moves;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"tail-recursion-optimization-1",children:"Tail Recursion Optimization"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Tail recursion"})," occurs when the recursive call is the ",(0,t.jsx)(e.strong,{children:"last operation"})," in the function."]}),"\n",(0,t.jsx)(e.h3,{id:"1-tail-recursive-factorial-1",children:"1. Tail Recursive Factorial"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Non-tail recursive (traditional)\nfunction factorial(n) {\n  if (n <= 1) return 1;\n  return n * factorial(n - 1); // Multiplication after recursive call\n}\n\n// Tail recursive version\nfunction factorialTail(n, accumulator = 1) {\n  if (n <= 1) return accumulator;\n  return factorialTail(n - 1, n * accumulator); // Recursive call is last\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-tail-recursive-sum-1",children:"2. Tail Recursive Sum"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Non-tail recursive\nfunction sum(n) {\n  if (n <= 0) return 0;\n  return n + sum(n - 1); // Addition after recursive call\n}\n\n// Tail recursive version\nfunction sumTail(n, accumulator = 0) {\n  if (n <= 0) return accumulator;\n  return sumTail(n - 1, accumulator + n); // Recursive call is last\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-tail-recursive-fibonacci-1",children:"3. Tail Recursive Fibonacci"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function fibonacciTail(n, a = 0, b = 1) {\n  if (n === 0) return a;\n  if (n === 1) return b;\n  return fibonacciTail(n - 1, b, a + b); // Tail recursive\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"4-converting-to-iterative-1",children:"4. Converting to Iterative"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Tail recursion can be easily converted to iteration\nfunction factorialIterative(n) {\n  let accumulator = 1;\n  while (n > 1) {\n    accumulator *= n;\n    n--;\n  }\n  return accumulator;\n}\n\n// Generic tail recursion to iteration converter\nfunction tailRecursionToIteration(initialValue, condition, update, extract) {\n  let current = initialValue;\n\n  while (!condition(current)) {\n    current = update(current);\n  }\n\n  return extract(current);\n}\n\n// Usage example\nconst factorial_n = tailRecursionToIteration(\n  { n: 5, acc: 1 },\n  state => state.n <= 1,\n  state => ({ n: state.n - 1, acc: state.acc * state.n }),\n  state => state.acc\n);\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"mutual-recursion-patterns-1",children:"Mutual Recursion Patterns"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Mutual recursion"})," occurs when two or more functions call each other recursively."]}),"\n",(0,t.jsx)(e.h3,{id:"1-evenodd-check-1",children:"1. Even/Odd Check"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function isEven(n) {\n  if (n === 0) return true;\n  return isOdd(n - 1);\n}\n\nfunction isOdd(n) {\n  if (n === 0) return false;\n  return isEven(n - 1);\n}\n\n// Usage\nconsole.log(isEven(4)); // true\nconsole.log(isOdd(5)); // true\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-expression-parsing-1",children:"2. Expression Parsing"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function parseExpression(tokens, index) {\n  let result = parseTerm(tokens, index);\n\n  while (\n    index.value < tokens.length &&\n    (tokens[index.value] === '+' || tokens[index.value] === '-')\n  ) {\n    const operator = tokens[index.value++];\n    const term = parseTerm(tokens, index);\n    result = operator === '+' ? result + term : result - term;\n  }\n\n  return result;\n}\n\nfunction parseTerm(tokens, index) {\n  let result = parseFactor(tokens, index);\n\n  while (\n    index.value < tokens.length &&\n    (tokens[index.value] === '*' || tokens[index.value] === '/')\n  ) {\n    const operator = tokens[index.value++];\n    const factor = parseFactor(tokens, index);\n    result = operator === '*' ? result * factor : result / factor;\n  }\n\n  return result;\n}\n\nfunction parseFactor(tokens, index) {\n  if (tokens[index.value] === '(') {\n    index.value++; // Skip '('\n    const result = parseExpression(tokens, index); // Mutual recursion\n    index.value++; // Skip ')'\n    return result;\n  }\n\n  return parseInt(tokens[index.value++]);\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-grammar-parsing-1",children:"3. Grammar Parsing"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function parseStatement(code, pos) {\n  if (code[pos.index] === 'if') {\n    return parseIfStatement(code, pos);\n  } else if (code[pos.index] === 'while') {\n    return parseWhileStatement(code, pos);\n  } else {\n    return parseAssignment(code, pos);\n  }\n}\n\nfunction parseIfStatement(code, pos) {\n  pos.index++; // Skip 'if'\n  const condition = parseExpression(code, pos);\n  const thenStmt = parseStatement(code, pos); // Mutual recursion\n\n  let elseStmt = null;\n  if (pos.index < code.length && code[pos.index] === 'else') {\n    pos.index++; // Skip 'else'\n    elseStmt = parseStatement(code, pos); // Mutual recursion\n  }\n\n  return { type: 'if', condition, then: thenStmt, else: elseStmt };\n}\n\nfunction parseWhileStatement(code, pos) {\n  pos.index++; // Skip 'while'\n  const condition = parseExpression(code, pos);\n  const body = parseStatement(code, pos); // Mutual recursion\n\n  return { type: 'while', condition, body };\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"4-state-machine-1",children:"4. State Machine"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function stateA(input, index) {\n  if (index >= input.length) return true;\n\n  if (input[index] === '0') {\n    return stateB(input, index + 1); // Mutual recursion\n  } else if (input[index] === '1') {\n    return stateA(input, index + 1);\n  }\n\n  return false;\n}\n\nfunction stateB(input, index) {\n  if (index >= input.length) return false;\n\n  if (input[index] === '0') {\n    return stateA(input, index + 1); // Mutual recursion\n  } else if (input[index] === '1') {\n    return stateB(input, index + 1);\n  }\n\n  return false;\n}\n\n// Check if string is accepted by the state machine\nfunction isAccepted(input) {\n  return stateA(input, 0);\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"indirect-recursion-1",children:"Indirect Recursion"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Indirect recursion"})," involves a chain of function calls that eventually leads back to the original function."]}),"\n",(0,t.jsx)(e.h3,{id:"1-three-function-chain-1",children:"1. Three-Function Chain"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function functionA(n) {\n  console.log(`A: ${n}`);\n  if (n > 0) {\n    return functionB(n - 1);\n  }\n  return 0;\n}\n\nfunction functionB(n) {\n  console.log(`B: ${n}`);\n  if (n > 0) {\n    return functionC(n - 1);\n  }\n  return 1;\n}\n\nfunction functionC(n) {\n  console.log(`C: ${n}`);\n  if (n > 0) {\n    return functionA(n - 1); // Back to A\n  }\n  return 2;\n}\n\n// Call chain: A -> B -> C -> A -> B -> C -> ...\nfunctionA(5);\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-complex-number-calculation-1",children:"2. Complex Number Calculation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function calculateReal(complex, depth) {\n  if (depth === 0) return complex.real;\n\n  const imagResult = calculateImaginary(\n    { real: complex.real * 0.5, imaginary: complex.imaginary * 0.5 },\n    depth - 1\n  );\n\n  return complex.real + imagResult;\n}\n\nfunction calculateImaginary(complex, depth) {\n  if (depth === 0) return complex.imaginary;\n\n  const realResult = calculateReal(\n    { real: complex.imaginary * 0.3, imaginary: complex.real * 0.7 },\n    depth - 1\n  );\n\n  return complex.imaginary + realResult;\n}\n\nfunction processComplex(complex, depth) {\n  const realPart = calculateReal(complex, depth);\n  const imagPart = calculateImaginary(complex, depth);\n\n  if (depth > 1) {\n    return processComplex({ real: realPart, imaginary: imagPart }, depth - 1);\n  }\n\n  return { real: realPart, imaginary: imagPart };\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-document-processing-chain-1",children:"3. Document Processing Chain"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function processDocument(doc, stage) {\n  switch (stage) {\n    case 'parse':\n      return parseDocument(doc, 'validate');\n    case 'validate':\n      return validateDocument(doc, 'transform');\n    case 'transform':\n      return transformDocument(doc, 'output');\n    case 'output':\n      return doc;\n    default:\n      return null;\n  }\n}\n\nfunction parseDocument(doc, nextStage) {\n  const parsed = { ...doc, parsed: true };\n  if (parsed.needsValidation) {\n    return processDocument(parsed, nextStage);\n  }\n  return parsed;\n}\n\nfunction validateDocument(doc, nextStage) {\n  const validated = { ...doc, valid: doc.parsed };\n  if (validated.needsTransformation) {\n    return processDocument(validated, nextStage);\n  }\n  return validated;\n}\n\nfunction transformDocument(doc, nextStage) {\n  const transformed = { ...doc, transformed: doc.valid };\n  return processDocument(transformed, nextStage);\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"nested-recursion-1",children:"Nested Recursion"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Nested recursion"})," occurs when a recursive call uses another recursive call as its parameter."]}),"\n",(0,t.jsx)(e.h3,{id:"1-ackermann-function-1",children:"1. Ackermann Function"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function ackermann(m, n) {\n  if (m === 0) {\n    return n + 1;\n  } else if (m > 0 && n === 0) {\n    return ackermann(m - 1, 1);\n  } else if (m > 0 && n > 0) {\n    // Nested recursion: recursive call as parameter\n    return ackermann(m - 1, ackermann(m, n - 1));\n  }\n}\n\n// Extremely fast-growing function\nconsole.log(ackermann(3, 2)); // 29\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-mccarthys-91-function-1",children:"2. McCarthy's 91 Function"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function mcCarthy91(n) {\n  if (n > 100) {\n    return n - 10;\n  } else {\n    // Nested recursion\n    return mcCarthy91(mcCarthy91(n + 11));\n  }\n}\n\n// Always returns 91 for n <= 100\nconsole.log(mcCarthy91(50)); // 91\nconsole.log(mcCarthy91(99)); // 91\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-nested-tree-processing-1",children:"3. Nested Tree Processing"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function processNestedTree(node) {\n  if (!node) return null;\n\n  if (node.type === 'leaf') {\n    return node.value;\n  }\n\n  if (node.type === 'transform') {\n    // Nested recursion: recursive call as parameter to another recursive call\n    return applyTransform(\n      processNestedTree(node.input),\n      processNestedTree(node.transform)\n    );\n  }\n\n  return processChildren(node.children);\n}\n\nfunction applyTransform(data, transform) {\n  if (!transform) return data;\n\n  if (transform.type === 'nested') {\n    // Another level of nesting\n    return applyTransform(data, processNestedTree(transform.nestedTransform));\n  }\n\n  return transform.fn(data);\n}\n\nfunction processChildren(children) {\n  if (!children || children.length === 0) return [];\n\n  return children.map(child => processNestedTree(child));\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"4-complex-mathematical-functions-1",children:"4. Complex Mathematical Functions"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function nestedMath(x, depth) {\n  if (depth === 0) return x;\n\n  if (x < 0) {\n    return -nestedMath(-x, depth - 1);\n  }\n\n  // Nested recursion with complex parameter\n  return Math.sqrt(nestedMath(x * nestedMath(x / 2, depth - 1), depth - 1));\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"tree-recursion-patterns-1",children:"Tree Recursion Patterns"}),"\n",(0,t.jsx)(e.p,{children:"Tree recursion involves recursive calls that form a tree-like structure of execution."}),"\n",(0,t.jsx)(e.h3,{id:"1-binary-tree-traversals-1",children:"1. Binary Tree Traversals"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Preorder: Root -> Left -> Right\nfunction preorderTraversal(root, result = []) {\n  if (!root) return result;\n\n  result.push(root.val); // Process root\n  preorderTraversal(root.left, result); // Recurse left\n  preorderTraversal(root.right, result); // Recurse right\n\n  return result;\n}\n\n// Inorder: Left -> Root -> Right\nfunction inorderTraversal(root, result = []) {\n  if (!root) return result;\n\n  inorderTraversal(root.left, result); // Recurse left\n  result.push(root.val); // Process root\n  inorderTraversal(root.right, result); // Recurse right\n\n  return result;\n}\n\n// Postorder: Left -> Right -> Root\nfunction postorderTraversal(root, result = []) {\n  if (!root) return result;\n\n  postorderTraversal(root.left, result); // Recurse left\n  postorderTraversal(root.right, result); // Recurse right\n  result.push(root.val); // Process root\n\n  return result;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-tree-validation-1",children:"2. Tree Validation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function isValidBST(root, min = -Infinity, max = Infinity) {\n  if (!root) return true;\n\n  if (root.val <= min || root.val >= max) return false;\n\n  // Tree recursion with different constraints\n  return (\n    isValidBST(root.left, min, root.val) &&\n    isValidBST(root.right, root.val, max)\n  );\n}\n\nfunction isSameTree(p, q) {\n  // Both null\n  if (!p && !q) return true;\n\n  // One null, one not\n  if (!p || !q) return false;\n\n  // Different values\n  if (p.val !== q.val) return false;\n\n  // Tree recursion\n  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n}\n\nfunction isSymmetric(root) {\n  if (!root) return true;\n\n  function isMirror(left, right) {\n    if (!left && !right) return true;\n    if (!left || !right) return false;\n\n    return (\n      left.val === right.val &&\n      isMirror(left.left, right.right) &&\n      isMirror(left.right, right.left)\n    );\n  }\n\n  return isMirror(root.left, root.right);\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-path-finding-in-trees",children:"3. Path Finding in Trees"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function hasPathSum(root, targetSum) {\n  if (!root) return false;\n\n  // Leaf node\n  if (!root.left && !root.right) {\n    return root.val === targetSum;\n  }\n\n  // Tree recursion\n  return (\n    hasPathSum(root.left, targetSum - root.val) ||\n    hasPathSum(root.right, targetSum - root.val)\n  );\n}\n\nfunction pathSum(root, targetSum, currentPath = [], allPaths = []) {\n  if (!root) return allPaths;\n\n  currentPath.push(root.val);\n\n  // Leaf node with target sum\n  if (\n    !root.left &&\n    !root.right &&\n    currentPath.reduce((sum, val) => sum + val, 0) === targetSum\n  ) {\n    allPaths.push([...currentPath]);\n  }\n\n  // Tree recursion\n  pathSum(root.left, targetSum, currentPath, allPaths);\n  pathSum(root.right, targetSum, currentPath, allPaths);\n\n  currentPath.pop(); // Backtrack\n  return allPaths;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"4-tree-construction",children:"4. Tree Construction"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function buildTreeFromPreorderInorder(preorder, inorder) {\n  if (preorder.length === 0) return null;\n\n  const rootVal = preorder[0];\n  const root = new TreeNode(rootVal);\n\n  const rootIndex = inorder.indexOf(rootVal);\n\n  // Tree recursion to build left and right subtrees\n  root.left = buildTreeFromPreorderInorder(\n    preorder.slice(1, rootIndex + 1),\n    inorder.slice(0, rootIndex)\n  );\n\n  root.right = buildTreeFromPreorderInorder(\n    preorder.slice(rootIndex + 1),\n    inorder.slice(rootIndex + 1)\n  );\n\n  return root;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"mathematical-recursion",children:"Mathematical Recursion"}),"\n",(0,t.jsx)(e.p,{children:"Mathematical recursion deals with recursive mathematical formulas and sequences."}),"\n",(0,t.jsx)(e.h3,{id:"1-greatest-common-divisor-gcd",children:"1. Greatest Common Divisor (GCD)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function gcd(a, b) {\n  // Base case\n  if (b === 0) return a;\n\n  // Recursive case: Euclidean algorithm\n  return gcd(b, a % b);\n}\n\n// Extended Euclidean Algorithm\nfunction extendedGCD(a, b) {\n  if (b === 0) {\n    return { gcd: a, x: 1, y: 0 };\n  }\n\n  const result = extendedGCD(b, a % b);\n  const x = result.y;\n  const y = result.x - Math.floor(a / b) * result.y;\n\n  return { gcd: result.gcd, x, y };\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-power-function",children:"2. Power Function"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Naive recursive power\nfunction power(base, exponent) {\n  if (exponent === 0) return 1;\n  if (exponent === 1) return base;\n\n  return base * power(base, exponent - 1);\n}\n\n// Optimized power (fast exponentiation)\nfunction fastPower(base, exponent) {\n  if (exponent === 0) return 1;\n\n  if (exponent % 2 === 0) {\n    const halfPower = fastPower(base, exponent / 2);\n    return halfPower * halfPower;\n  } else {\n    return base * fastPower(base, exponent - 1);\n  }\n}\n\n// Power with modulo\nfunction powerMod(base, exponent, mod) {\n  if (exponent === 0) return 1;\n\n  if (exponent % 2 === 0) {\n    const halfPower = powerMod(base, exponent / 2, mod);\n    return (halfPower * halfPower) % mod;\n  } else {\n    return (base * powerMod(base, exponent - 1, mod)) % mod;\n  }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-combinatorics",children:"3. Combinatorics"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Combinations C(n, k)\nfunction combinations(n, k) {\n  // Base cases\n  if (k === 0 || k === n) return 1;\n  if (k > n) return 0;\n\n  // Recursive case: Pascal's triangle\n  return combinations(n - 1, k - 1) + combinations(n - 1, k);\n}\n\n// Permutations P(n, k)\nfunction permutations(n, k) {\n  if (k === 0) return 1;\n  if (k > n) return 0;\n\n  return n * permutations(n - 1, k - 1);\n}\n\n// Catalan Numbers\nfunction catalan(n) {\n  if (n <= 1) return 1;\n\n  let result = 0;\n  for (let i = 0; i < n; i++) {\n    result += catalan(i) * catalan(n - 1 - i);\n  }\n\n  return result;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"4-number-theory",children:"4. Number Theory"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Prime factorization\nfunction primeFactors(n, factor = 2, factors = []) {\n  if (n === 1) return factors;\n\n  if (n % factor === 0) {\n    factors.push(factor);\n    return primeFactors(n / factor, factor, factors);\n  }\n\n  return primeFactors(n, factor + 1, factors);\n}\n\n// Sum of digits\nfunction sumOfDigits(n) {\n  if (n === 0) return 0;\n  return (n % 10) + sumOfDigits(Math.floor(n / 10));\n}\n\n// Reverse number\nfunction reverseNumber(n, reversed = 0) {\n  if (n === 0) return reversed;\n  return reverseNumber(Math.floor(n / 10), reversed * 10 + (n % 10));\n}\n\n// Check if palindrome number\nfunction isPalindromeNumber(n) {\n  return n === reverseNumber(n);\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"string-recursion-patterns",children:"String Recursion Patterns"}),"\n",(0,t.jsx)(e.p,{children:"String recursion involves processing strings through recursive decomposition."}),"\n",(0,t.jsx)(e.h3,{id:"1-string-manipulation",children:"1. String Manipulation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Remove character from string\nfunction removeChar(str, char) {\n  if (str.length === 0) return '';\n\n  if (str[0] === char) {\n    return removeChar(str.slice(1), char);\n  } else {\n    return str[0] + removeChar(str.slice(1), char);\n  }\n}\n\n// Replace character in string\nfunction replaceChar(str, oldChar, newChar) {\n  if (str.length === 0) return '';\n\n  const firstChar = str[0] === oldChar ? newChar : str[0];\n  return firstChar + replaceChar(str.slice(1), oldChar, newChar);\n}\n\n// Count occurrences\nfunction countChar(str, char) {\n  if (str.length === 0) return 0;\n\n  const count = str[0] === char ? 1 : 0;\n  return count + countChar(str.slice(1), char);\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-string-validation",children:"2. String Validation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Check if string contains only digits\nfunction isDigitsOnly(str) {\n  if (str.length === 0) return true;\n\n  if (str[0] < '0' || str[0] > '9') return false;\n\n  return isDigitsOnly(str.slice(1));\n}\n\n// Check balanced parentheses\nfunction isBalanced(str, index = 0, count = 0) {\n  if (index === str.length) return count === 0;\n\n  if (str[index] === '(') {\n    return isBalanced(str, index + 1, count + 1);\n  } else if (str[index] === ')') {\n    if (count === 0) return false;\n    return isBalanced(str, index + 1, count - 1);\n  } else {\n    return isBalanced(str, index + 1, count);\n  }\n}\n\n// Check if anagram\nfunction isAnagram(str1, str2) {\n  if (str1.length !== str2.length) return false;\n  if (str1.length === 0) return true;\n\n  const char = str1[0];\n  const index = str2.indexOf(char);\n\n  if (index === -1) return false;\n\n  return isAnagram(str1.slice(1), str2.slice(0, index) + str2.slice(index + 1));\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-pattern-matching",children:"3. Pattern Matching"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Simple pattern matching with wildcards\nfunction patternMatch(str, pattern, sIndex = 0, pIndex = 0) {\n  // Base cases\n  if (pIndex === pattern.length) return sIndex === str.length;\n  if (sIndex === str.length)\n    return pattern\n      .slice(pIndex)\n      .split('')\n      .every(c => c === '*');\n\n  if (pattern[pIndex] === '*') {\n    // Try matching zero characters or one character\n    return (\n      patternMatch(str, pattern, sIndex, pIndex + 1) ||\n      patternMatch(str, pattern, sIndex + 1, pIndex)\n    );\n  } else if (pattern[pIndex] === '?' || pattern[pIndex] === str[sIndex]) {\n    return patternMatch(str, pattern, sIndex + 1, pIndex + 1);\n  }\n\n  return false;\n}\n\n// Longest common subsequence\nfunction longestCommonSubsequence(str1, str2, i = 0, j = 0) {\n  if (i === str1.length || j === str2.length) return 0;\n\n  if (str1[i] === str2[j]) {\n    return 1 + longestCommonSubsequence(str1, str2, i + 1, j + 1);\n  } else {\n    return Math.max(\n      longestCommonSubsequence(str1, str2, i + 1, j),\n      longestCommonSubsequence(str1, str2, i, j + 1)\n    );\n  }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"4-string-generation",children:"4. String Generation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Generate all permutations\nfunction stringPermutations(str, current = '', used = new Set(), result = []) {\n  if (current.length === str.length) {\n    result.push(current);\n    return result;\n  }\n\n  for (let i = 0; i < str.length; i++) {\n    if (!used.has(i)) {\n      used.add(i);\n      stringPermutations(str, current + str[i], used, result);\n      used.delete(i);\n    }\n  }\n\n  return result;\n}\n\n// Generate all subsequences\nfunction generateSubsequences(str, index = 0, current = '', result = []) {\n  if (index === str.length) {\n    result.push(current);\n    return result;\n  }\n\n  // Include current character\n  generateSubsequences(str, index + 1, current + str[index], result);\n\n  // Exclude current character\n  generateSubsequences(str, index + 1, current, result);\n\n  return result;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"array--list-recursion",children:"Array & List Recursion"}),"\n",(0,t.jsx)(e.p,{children:"Array and list recursion patterns for processing sequential data structures."}),"\n",(0,t.jsx)(e.h3,{id:"1-array-processing",children:"1. Array Processing"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Find maximum element\nfunction findMax(arr, index = 0) {\n  if (index === arr.length - 1) return arr[index];\n\n  const maxOfRest = findMax(arr, index + 1);\n  return Math.max(arr[index], maxOfRest);\n}\n\n// Find minimum element\nfunction findMin(arr, index = 0) {\n  if (index === arr.length - 1) return arr[index];\n\n  const minOfRest = findMin(arr, index + 1);\n  return Math.min(arr[index], minOfRest);\n}\n\n// Array sum\nfunction arraySum(arr, index = 0) {\n  if (index >= arr.length) return 0;\n  return arr[index] + arraySum(arr, index + 1);\n}\n\n// Array product\nfunction arrayProduct(arr, index = 0) {\n  if (index >= arr.length) return 1;\n  return arr[index] * arrayProduct(arr, index + 1);\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-array-searching",children:"2. Array Searching"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Binary search\nfunction binarySearchRecursive(arr, target, left = 0, right = arr.length - 1) {\n  if (left > right) return -1;\n\n  const mid = Math.floor((left + right) / 2);\n\n  if (arr[mid] === target) return mid;\n\n  if (target < arr[mid]) {\n    return binarySearchRecursive(arr, target, left, mid - 1);\n  } else {\n    return binarySearchRecursive(arr, target, mid + 1, right);\n  }\n}\n\n// Find all occurrences\nfunction findAllOccurrences(arr, target, index = 0, occurrences = []) {\n  if (index >= arr.length) return occurrences;\n\n  if (arr[index] === target) {\n    occurrences.push(index);\n  }\n\n  return findAllOccurrences(arr, target, index + 1, occurrences);\n}\n\n// Check if array is sorted\nfunction isSorted(arr, index = 0) {\n  if (index >= arr.length - 1) return true;\n\n  if (arr[index] > arr[index + 1]) return false;\n\n  return isSorted(arr, index + 1);\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-array-transformation",children:"3. Array Transformation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Reverse array\nfunction reverseArray(arr, start = 0, end = arr.length - 1) {\n  if (start >= end) return arr;\n\n  // Swap elements\n  [arr[start], arr[end]] = [arr[end], arr[start]];\n\n  return reverseArray(arr, start + 1, end - 1);\n}\n\n// Filter array\nfunction filterArray(arr, predicate, index = 0, result = []) {\n  if (index >= arr.length) return result;\n\n  if (predicate(arr[index])) {\n    result.push(arr[index]);\n  }\n\n  return filterArray(arr, predicate, index + 1, result);\n}\n\n// Map array\nfunction mapArray(arr, transform, index = 0, result = []) {\n  if (index >= arr.length) return result;\n\n  result.push(transform(arr[index]));\n\n  return mapArray(arr, transform, index + 1, result);\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"4-advanced-array-operations",children:"4. Advanced Array Operations"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Merge two sorted arrays\nfunction mergeSortedArrays(arr1, arr2, i = 0, j = 0, result = []) {\n  if (i >= arr1.length && j >= arr2.length) return result;\n\n  if (i >= arr1.length) {\n    result.push(arr2[j]);\n    return mergeSortedArrays(arr1, arr2, i, j + 1, result);\n  }\n\n  if (j >= arr2.length) {\n    result.push(arr1[i]);\n    return mergeSortedArrays(arr1, arr2, i + 1, j, result);\n  }\n\n  if (arr1[i] <= arr2[j]) {\n    result.push(arr1[i]);\n    return mergeSortedArrays(arr1, arr2, i + 1, j, result);\n  } else {\n    result.push(arr2[j]);\n    return mergeSortedArrays(arr1, arr2, i, j + 1, result);\n  }\n}\n\n// Quick select (find kth smallest)\nfunction quickSelect(arr, k, left = 0, right = arr.length - 1) {\n  if (left === right) return arr[left];\n\n  const pivotIndex = partition(arr, left, right);\n\n  if (k === pivotIndex) {\n    return arr[k];\n  } else if (k < pivotIndex) {\n    return quickSelect(arr, k, left, pivotIndex - 1);\n  } else {\n    return quickSelect(arr, k, pivotIndex + 1, right);\n  }\n}\n\nfunction partition(arr, left, right) {\n  const pivot = arr[right];\n  let i = left;\n\n  for (let j = left; j < right; j++) {\n    if (arr[j] <= pivot) {\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n      i++;\n    }\n  }\n\n  [arr[i], arr[right]] = [arr[right], arr[i]];\n  return i;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"divide-and-conquer",children:"Divide and Conquer"}),"\n",(0,t.jsx)(e.p,{children:"Divide and conquer is a recursive algorithm design paradigm."}),"\n",(0,t.jsx)(e.h3,{id:"1-classic-sorting-algorithms",children:"1. Classic Sorting Algorithms"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Quick Sort\nfunction quickSort(arr, left = 0, right = arr.length - 1) {\n  if (left < right) {\n    const pivotIndex = partition(arr, left, right);\n\n    // Divide and conquer\n    quickSort(arr, left, pivotIndex - 1);\n    quickSort(arr, pivotIndex + 1, right);\n  }\n\n  return arr;\n}\n\n// Merge Sort (already shown earlier)\nfunction mergeSort(arr) {\n  if (arr.length <= 1) return arr;\n\n  const mid = Math.floor(arr.length / 2);\n  const left = mergeSort(arr.slice(0, mid));\n  const right = mergeSort(arr.slice(mid));\n\n  return merge(left, right);\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-maximum-subarray-kadanes-algorithm---divide--conquer",children:"2. Maximum Subarray (Kadane's Algorithm - Divide & Conquer)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function maxSubarrayDivideConquer(arr, left = 0, right = arr.length - 1) {\n  if (left === right) return arr[left];\n\n  const mid = Math.floor((left + right) / 2);\n\n  // Divide\n  const leftMax = maxSubarrayDivideConquer(arr, left, mid);\n  const rightMax = maxSubarrayDivideConquer(arr, mid + 1, right);\n\n  // Conquer - find max crossing subarray\n  let leftSum = -Infinity;\n  let sum = 0;\n  for (let i = mid; i >= left; i--) {\n    sum += arr[i];\n    leftSum = Math.max(leftSum, sum);\n  }\n\n  let rightSum = -Infinity;\n  sum = 0;\n  for (let i = mid + 1; i <= right; i++) {\n    sum += arr[i];\n    rightSum = Math.max(rightSum, sum);\n  }\n\n  const crossSum = leftSum + rightSum;\n\n  // Return maximum of three\n  return Math.max(leftMax, rightMax, crossSum);\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-closest-pair-of-points",children:"3. Closest Pair of Points"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function closestPairDivideConquer(points) {\n  points.sort((a, b) => a.x - b.x);\n  return closestPairRec(points);\n}\n\nfunction closestPairRec(points) {\n  const n = points.length;\n\n  if (n <= 3) return bruteForceClosest(points);\n\n  const mid = Math.floor(n / 2);\n  const midPoint = points[mid];\n\n  const leftPoints = points.slice(0, mid);\n  const rightPoints = points.slice(mid);\n\n  // Divide\n  const leftMin = closestPairRec(leftPoints);\n  const rightMin = closestPairRec(rightPoints);\n\n  // Find minimum of two halves\n  const minDist = Math.min(leftMin, rightMin);\n\n  // Conquer - check points near dividing line\n  const strip = points.filter(\n    point => Math.abs(point.x - midPoint.x) < minDist\n  );\n\n  return Math.min(minDist, stripClosest(strip, minDist));\n}\n\nfunction distance(p1, p2) {\n  return Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);\n}\n\nfunction bruteForceClosest(points) {\n  let minDist = Infinity;\n  for (let i = 0; i < points.length; i++) {\n    for (let j = i + 1; j < points.length; j++) {\n      minDist = Math.min(minDist, distance(points[i], points[j]));\n    }\n  }\n  return minDist;\n}\n\nfunction stripClosest(strip, d) {\n  let minDist = d;\n  strip.sort((a, b) => a.y - b.y);\n\n  for (let i = 0; i < strip.length; i++) {\n    for (\n      let j = i + 1;\n      j < strip.length && strip[j].y - strip[i].y < minDist;\n      j++\n    ) {\n      minDist = Math.min(minDist, distance(strip[i], strip[j]));\n    }\n  }\n\n  return minDist;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"4-matrix-multiplication-strassens-algorithm",children:"4. Matrix Multiplication (Strassen's Algorithm)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function strassenMultiply(A, B) {\n  const n = A.length;\n\n  if (n === 1) {\n    return [[A[0][0] * B[0][0]]];\n  }\n\n  // Divide matrices into quadrants\n  const mid = Math.floor(n / 2);\n  const A11 = getSubMatrix(A, 0, 0, mid);\n  const A12 = getSubMatrix(A, 0, mid, mid);\n  const A21 = getSubMatrix(A, mid, 0, mid);\n  const A22 = getSubMatrix(A, mid, mid, mid);\n\n  const B11 = getSubMatrix(B, 0, 0, mid);\n  const B12 = getSubMatrix(B, 0, mid, mid);\n  const B21 = getSubMatrix(B, mid, 0, mid);\n  const B22 = getSubMatrix(B, mid, mid, mid);\n\n  // Strassen's 7 products\n  const M1 = strassenMultiply(addMatrices(A11, A22), addMatrices(B11, B22));\n  const M2 = strassenMultiply(addMatrices(A21, A22), B11);\n  const M3 = strassenMultiply(A11, subtractMatrices(B12, B22));\n  const M4 = strassenMultiply(A22, subtractMatrices(B21, B11));\n  const M5 = strassenMultiply(addMatrices(A11, A12), B22);\n  const M6 = strassenMultiply(\n    subtractMatrices(A21, A11),\n    addMatrices(B11, B12)\n  );\n  const M7 = strassenMultiply(\n    subtractMatrices(A12, A22),\n    addMatrices(B21, B22)\n  );\n\n  // Compute result quadrants\n  const C11 = addMatrices(subtractMatrices(addMatrices(M1, M4), M5), M7);\n  const C12 = addMatrices(M3, M5);\n  const C21 = addMatrices(M2, M4);\n  const C22 = addMatrices(subtractMatrices(addMatrices(M1, M3), M2), M6);\n\n  // Combine quadrants\n  return combineMatrices(C11, C12, C21, C22);\n}\n\nfunction getSubMatrix(matrix, startRow, startCol, size) {\n  const result = [];\n  for (let i = 0; i < size; i++) {\n    result[i] = [];\n    for (let j = 0; j < size; j++) {\n      result[i][j] = matrix[startRow + i][startCol + j];\n    }\n  }\n  return result;\n}\n\nfunction addMatrices(A, B) {\n  const n = A.length;\n  const result = [];\n  for (let i = 0; i < n; i++) {\n    result[i] = [];\n    for (let j = 0; j < n; j++) {\n      result[i][j] = A[i][j] + B[i][j];\n    }\n  }\n  return result;\n}\n\nfunction subtractMatrices(A, B) {\n  const n = A.length;\n  const result = [];\n  for (let i = 0; i < n; i++) {\n    result[i] = [];\n    for (let j = 0; j < n; j++) {\n      result[i][j] = A[i][j] - B[i][j];\n    }\n  }\n  return result;\n}\n\nfunction combineMatrices(C11, C12, C21, C22) {\n  const n = C11.length;\n  const result = Array(2 * n)\n    .fill()\n    .map(() => Array(2 * n).fill(0));\n\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      result[i][j] = C11[i][j];\n      result[i][j + n] = C12[i][j];\n      result[i + n][j] = C21[i][j];\n      result[i + n][j + n] = C22[i][j];\n    }\n  }\n\n  return result;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"dynamic-programming-with-recursion-1",children:"Dynamic Programming with Recursion"}),"\n",(0,t.jsx)(e.p,{children:"Dynamic Programming combines recursion with memoization to solve optimization problems."}),"\n",(0,t.jsx)(e.h3,{id:"1-classic-dp-problems-1",children:"1. Classic DP Problems"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Longest Common Subsequence with Memoization\nfunction longestCommonSubsequenceMemo(str1, str2, i = 0, j = 0, memo = {}) {\n  const key = `${i},${j}`;\n  if (key in memo) return memo[key];\n\n  if (i === str1.length || j === str2.length) {\n    return (memo[key] = 0);\n  }\n\n  if (str1[i] === str2[j]) {\n    return (memo[key] =\n      1 + longestCommonSubsequenceMemo(str1, str2, i + 1, j + 1, memo));\n  } else {\n    return (memo[key] = Math.max(\n      longestCommonSubsequenceMemo(str1, str2, i + 1, j, memo),\n      longestCommonSubsequenceMemo(str1, str2, i, j + 1, memo)\n    ));\n  }\n}\n\n// Edit Distance (Levenshtein Distance)\nfunction editDistance(str1, str2, i = 0, j = 0, memo = {}) {\n  const key = `${i},${j}`;\n  if (key in memo) return memo[key];\n\n  if (i === str1.length) return (memo[key] = str2.length - j);\n  if (j === str2.length) return (memo[key] = str1.length - i);\n\n  if (str1[i] === str2[j]) {\n    return (memo[key] = editDistance(str1, str2, i + 1, j + 1, memo));\n  } else {\n    const insert = editDistance(str1, str2, i, j + 1, memo);\n    const delete_ = editDistance(str1, str2, i + 1, j, memo);\n    const replace = editDistance(str1, str2, i + 1, j + 1, memo);\n\n    return (memo[key] = 1 + Math.min(insert, delete_, replace));\n  }\n}\n\n// 0/1 Knapsack Problem\nfunction knapsack(weights, values, capacity, index = 0, memo = {}) {\n  const key = `${capacity},${index}`;\n  if (key in memo) return memo[key];\n\n  if (index === weights.length || capacity === 0) {\n    return (memo[key] = 0);\n  }\n\n  // Don't take current item\n  let maxValue = knapsack(weights, values, capacity, index + 1, memo);\n\n  // Take current item if it fits\n  if (weights[index] <= capacity) {\n    const valueWithCurrent =\n      values[index] +\n      knapsack(weights, values, capacity - weights[index], index + 1, memo);\n    maxValue = Math.max(maxValue, valueWithCurrent);\n  }\n\n  return (memo[key] = maxValue);\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-coin-change-problems-1",children:"2. Coin Change Problems"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Coin Change - Minimum coins\nfunction coinChangeMinCoins(coins, amount, memo = {}) {\n  if (amount in memo) return memo[amount];\n  if (amount === 0) return 0;\n  if (amount < 0) return Infinity;\n\n  let minCoins = Infinity;\n  for (let coin of coins) {\n    const result = coinChangeMinCoins(coins, amount - coin, memo);\n    if (result !== Infinity) {\n      minCoins = Math.min(minCoins, 1 + result);\n    }\n  }\n\n  return (memo[amount] = minCoins === Infinity ? -1 : minCoins);\n}\n\n// Coin Change - Number of ways\nfunction coinChangeWays(coins, amount, index = 0, memo = {}) {\n  const key = `${amount},${index}`;\n  if (key in memo) return memo[key];\n\n  if (amount === 0) return 1;\n  if (amount < 0 || index >= coins.length) return 0;\n\n  // Include current coin + exclude current coin\n  return (memo[key] =\n    coinChangeWays(coins, amount - coins[index], index, memo) +\n    coinChangeWays(coins, amount, index + 1, memo));\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-path-problems-1",children:"3. Path Problems"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Unique Paths in Grid\nfunction uniquePaths(m, n, i = 0, j = 0, memo = {}) {\n  const key = `${i},${j}`;\n  if (key in memo) return memo[key];\n\n  if (i === m - 1 && j === n - 1) return 1;\n  if (i >= m || j >= n) return 0;\n\n  return (memo[key] =\n    uniquePaths(m, n, i + 1, j, memo) + uniquePaths(m, n, i, j + 1, memo));\n}\n\n// Minimum Path Sum in Grid\nfunction minPathSum(grid, i = 0, j = 0, memo = {}) {\n  const key = `${i},${j}`;\n  if (key in memo) return memo[key];\n\n  const m = grid.length,\n    n = grid[0].length;\n\n  if (i === m - 1 && j === n - 1) return grid[i][j];\n  if (i >= m || j >= n) return Infinity;\n\n  const down = minPathSum(grid, i + 1, j, memo);\n  const right = minPathSum(grid, i, j + 1, memo);\n\n  return (memo[key] = grid[i][j] + Math.min(down, right));\n}\n\n// Maximum Path Sum in Binary Tree\nfunction maxPathSumTree(root, memo = new Map()) {\n  if (memo.has(root)) return memo.get(root);\n  if (!root) return 0;\n\n  const leftMax = Math.max(0, maxPathSumTree(root.left, memo));\n  const rightMax = Math.max(0, maxPathSumTree(root.right, memo));\n\n  const result = root.val + leftMax + rightMax;\n  memo.set(root, result);\n\n  return result;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"4-subsequence-problems",children:"4. Subsequence Problems"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Longest Increasing Subsequence\nfunction longestIncreasingSubsequence(\n  nums,\n  index = 0,\n  prev = -Infinity,\n  memo = {}\n) {\n  const key = `${index},${prev}`;\n  if (key in memo) return memo[key];\n\n  if (index >= nums.length) return 0;\n\n  // Don't take current element\n  let maxLength = longestIncreasingSubsequence(nums, index + 1, prev, memo);\n\n  // Take current element if it's greater than previous\n  if (nums[index] > prev) {\n    const lengthWithCurrent =\n      1 + longestIncreasingSubsequence(nums, index + 1, nums[index], memo);\n    maxLength = Math.max(maxLength, lengthWithCurrent);\n  }\n\n  return (memo[key] = maxLength);\n}\n\n// Longest Palindromic Subsequence\nfunction longestPalindromicSubsequence(\n  str,\n  left = 0,\n  right = str.length - 1,\n  memo = {}\n) {\n  const key = `${left},${right}`;\n  if (key in memo) return memo[key];\n\n  if (left > right) return 0;\n  if (left === right) return 1;\n\n  if (str[left] === str[right]) {\n    return (memo[key] =\n      2 + longestPalindromicSubsequence(str, left + 1, right - 1, memo));\n  } else {\n    return (memo[key] = Math.max(\n      longestPalindromicSubsequence(str, left + 1, right, memo),\n      longestPalindromicSubsequence(str, left, right - 1, memo)\n    ));\n  }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"recursion-optimization-techniques",children:"Recursion Optimization Techniques"}),"\n",(0,t.jsx)(e.p,{children:"Techniques to optimize recursive solutions for better performance."}),"\n",(0,t.jsx)(e.h3,{id:"1-memoization",children:"1. Memoization"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Generic memoization decorator\nfunction memoize(fn) {\n  const cache = new Map();\n\n  return function (...args) {\n    const key = JSON.stringify(args);\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n\n    const result = fn.apply(this, args);\n    cache.set(key, result);\n    return result;\n  };\n}\n\n// Usage example\nconst fibMemoized = memoize(function fibonacci(n) {\n  if (n <= 1) return n;\n  return fibonacci(n - 1) + fibonacci(n - 2);\n});\n\n// Class-based memoization\nclass MemoizedRecursion {\n  constructor() {\n    this.cache = new Map();\n  }\n\n  memoizedCall(fn, ...args) {\n    const key = `${fn.name}_${JSON.stringify(args)}`;\n\n    if (this.cache.has(key)) {\n      return this.cache.get(key);\n    }\n\n    const result = fn.apply(this, args);\n    this.cache.set(key, result);\n    return result;\n  }\n\n  fibonacci(n) {\n    if (n <= 1) return n;\n    return (\n      this.memoizedCall(this.fibonacci, n - 1) +\n      this.memoizedCall(this.fibonacci, n - 2)\n    );\n  }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-tail-call-optimization",children:"2. Tail Call Optimization"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Trampoline technique for tail call optimization\nfunction trampoline(fn) {\n  return function (...args) {\n    let result = fn.apply(this, args);\n\n    while (typeof result === 'function') {\n      result = result();\n    }\n\n    return result;\n  };\n}\n\n// Tail recursive factorial using trampoline\nconst factorialTrampoline = trampoline(function factorial(n, acc = 1) {\n  if (n <= 1) return acc;\n  return () => factorial(n - 1, n * acc);\n});\n\n// Tail recursive sum using trampoline\nconst sumTrampoline = trampoline(function sum(n, acc = 0) {\n  if (n <= 0) return acc;\n  return () => sum(n - 1, acc + n);\n});\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-space-optimization",children:"3. Space Optimization"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Convert recursion to iteration to save stack space\nfunction recursionToIteration(\n  problem,\n  isBaseCase,\n  getBaseValue,\n  decompose,\n  combine\n) {\n  const stack = [problem];\n  const results = new Map();\n\n  while (stack.length > 0) {\n    const current = stack[stack.length - 1];\n\n    if (isBaseCase(current)) {\n      stack.pop();\n      results.set(JSON.stringify(current), getBaseValue(current));\n    } else {\n      const subproblems = decompose(current);\n      let allSubproblemsResolved = true;\n\n      for (let subproblem of subproblems) {\n        const key = JSON.stringify(subproblem);\n        if (!results.has(key)) {\n          stack.push(subproblem);\n          allSubproblemsResolved = false;\n        }\n      }\n\n      if (allSubproblemsResolved) {\n        stack.pop();\n        const subResults = subproblems.map(sub =>\n          results.get(JSON.stringify(sub))\n        );\n        results.set(JSON.stringify(current), combine(subResults, current));\n      }\n    }\n  }\n\n  return results.get(JSON.stringify(problem));\n}\n\n// Example: Fibonacci using iteration\nfunction fibonacciIterative(n) {\n  if (n <= 1) return n;\n\n  let a = 0,\n    b = 1;\n  for (let i = 2; i <= n; i++) {\n    [a, b] = [b, a + b];\n  }\n  return b;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"4-early-termination",children:"4. Early Termination"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Optimize search with early termination\nfunction optimizedSearch(arr, target, predicate) {\n  function search(index) {\n    if (index >= arr.length) return -1;\n\n    // Early termination based on predicate\n    if (!predicate(arr[index], index)) {\n      return -1;\n    }\n\n    if (arr[index] === target) return index;\n\n    return search(index + 1);\n  }\n\n  return search(0);\n}\n\n// Pruned tree traversal\nfunction prunedTreeTraversal(root, shouldPrune) {\n  if (!root) return null;\n\n  // Early termination - don't traverse subtree\n  if (shouldPrune(root)) {\n    return null;\n  }\n\n  const left = prunedTreeTraversal(root.left, shouldPrune);\n  const right = prunedTreeTraversal(root.right, shouldPrune);\n\n  return {\n    val: root.val,\n    left: left,\n    right: right,\n  };\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"converting-recursion-to-iteration",children:"Converting Recursion to Iteration"}),"\n",(0,t.jsx)(e.p,{children:"Systematic approaches to convert recursive algorithms to iterative ones."}),"\n",(0,t.jsx)(e.h3,{id:"1-using-explicit-stack",children:"1. Using Explicit Stack"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Convert tree traversal from recursion to iteration\nfunction iterativePreorder(root) {\n  if (!root) return [];\n\n  const result = [];\n  const stack = [root];\n\n  while (stack.length > 0) {\n    const node = stack.pop();\n    result.push(node.val);\n\n    // Push right first, then left (stack is LIFO)\n    if (node.right) stack.push(node.right);\n    if (node.left) stack.push(node.left);\n  }\n\n  return result;\n}\n\nfunction iterativeInorder(root) {\n  const result = [];\n  const stack = [];\n  let current = root;\n\n  while (current || stack.length > 0) {\n    // Go to leftmost node\n    while (current) {\n      stack.push(current);\n      current = current.left;\n    }\n\n    // Process node\n    current = stack.pop();\n    result.push(current.val);\n\n    // Move to right subtree\n    current = current.right;\n  }\n\n  return result;\n}\n\nfunction iterativePostorder(root) {\n  if (!root) return [];\n\n  const result = [];\n  const stack = [root];\n  const visited = new Set();\n\n  while (stack.length > 0) {\n    const node = stack[stack.length - 1];\n\n    if (visited.has(node) || (!node.left && !node.right)) {\n      result.push(node.val);\n      stack.pop();\n      visited.add(node);\n    } else {\n      if (node.right) stack.push(node.right);\n      if (node.left) stack.push(node.left);\n    }\n  }\n\n  return result;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-state-machine-approach",children:"2. State Machine Approach"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Convert factorial to iteration using state\nfunction factorialIterativeState(n) {\n  let state = { n: n, result: 1, phase: 'multiply' };\n\n  while (state.phase !== 'done') {\n    switch (state.phase) {\n      case 'multiply':\n        if (state.n <= 1) {\n          state.phase = 'done';\n        } else {\n          state.result *= state.n;\n          state.n--;\n        }\n        break;\n    }\n  }\n\n  return state.result;\n}\n\n// Convert Fibonacci to iteration with state\nfunction fibonacciIterativeState(n) {\n  if (n <= 1) return n;\n\n  let state = {\n    target: n,\n    current: 2,\n    prev1: 1, // f(1)\n    prev2: 0, // f(0)\n    result: 0,\n  };\n\n  while (state.current <= state.target) {\n    state.result = state.prev1 + state.prev2;\n    state.prev2 = state.prev1;\n    state.prev1 = state.result;\n    state.current++;\n  }\n\n  return state.result;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-loop-transformation",children:"3. Loop Transformation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Generic recursion to iteration converter\nclass RecursionConverter {\n  static convertTailRecursion(\n    initialArgs,\n    baseCondition,\n    baseValue,\n    updateArgs\n  ) {\n    let args = initialArgs;\n\n    while (!baseCondition(args)) {\n      args = updateArgs(args);\n    }\n\n    return baseValue(args);\n  }\n\n  static convertLinearRecursion(\n    initialArgs,\n    baseCondition,\n    baseValue,\n    processStep,\n    combineResults\n  ) {\n    const stack = [];\n    let current = initialArgs;\n\n    // Forward pass - build stack\n    while (!baseCondition(current)) {\n      stack.push(current);\n      current = processStep(current);\n    }\n\n    let result = baseValue(current);\n\n    // Backward pass - combine results\n    while (stack.length > 0) {\n      const args = stack.pop();\n      result = combineResults(args, result);\n    }\n\n    return result;\n  }\n}\n\n// Usage examples\nconst iterativeFactorial = n =>\n  RecursionConverter.convertTailRecursion(\n    { n, acc: 1 },\n    args => args.n <= 1,\n    args => args.acc,\n    args => ({ n: args.n - 1, acc: args.acc * args.n })\n  );\n\nconst iterativeSum = n =>\n  RecursionConverter.convertLinearRecursion(\n    n,\n    n => n <= 0,\n    n => 0,\n    n => n - 1,\n    (n, result) => n + result\n  );\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"common-pitfalls--debugging",children:"Common Pitfalls & Debugging"}),"\n",(0,t.jsx)(e.p,{children:"Common mistakes in recursive programming and debugging techniques."}),"\n",(0,t.jsx)(e.h3,{id:"1-common-pitfalls",children:"1. Common Pitfalls"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// PITFALL 1: Missing or incorrect base case\n// Wrong:\nfunction infiniteRecursion(n) {\n  return n * infiniteRecursion(n - 1); // No base case!\n}\n\n// Correct:\nfunction factorial(n) {\n  if (n <= 1) return 1; // Base case\n  return n * factorial(n - 1);\n}\n\n// PITFALL 2: Not making progress toward base case\n// Wrong:\nfunction noProgress(n) {\n  if (n === 0) return 0;\n  return noProgress(n); // Same parameter!\n}\n\n// Correct:\nfunction countdown(n) {\n  if (n === 0) return 0;\n  return countdown(n - 1); // Making progress\n}\n\n// PITFALL 3: Stack overflow from deep recursion\n// Problematic for large inputs:\nfunction deepRecursion(n) {\n  if (n === 0) return 0;\n  return 1 + deepRecursion(n - 1);\n}\n\n// Better with tail recursion:\nfunction tailRecursion(n, acc = 0) {\n  if (n === 0) return acc;\n  return tailRecursion(n - 1, acc + 1);\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-debugging-techniques",children:"2. Debugging Techniques"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Debug wrapper for recursive functions\nfunction debugRecursion(fn, name) {\n  let depth = 0;\n  const maxDepth = 100; // Prevent infinite recursion during debugging\n\n  return function debugWrapper(...args) {\n    depth++;\n\n    if (depth > maxDepth) {\n      throw new Error(`Maximum recursion depth exceeded in ${name}`);\n    }\n\n    const indent = '  '.repeat(depth - 1);\n    console.log(`${indent}\u2192 ${name}(${args.join(', ')})`);\n\n    try {\n      const result = fn.apply(this, args);\n      console.log(`${indent}\u2190 ${name} returns: ${result}`);\n      depth--;\n      return result;\n    } catch (error) {\n      console.log(`${indent}\u2717 ${name} error: ${error.message}`);\n      depth--;\n      throw error;\n    }\n  };\n}\n\n// Usage\nconst debugFactorial = debugRecursion(function factorial(n) {\n  if (n <= 1) return 1;\n  return n * factorial(n - 1);\n}, 'factorial');\n\n// Call stack tracer\nclass CallStackTracer {\n  constructor() {\n    this.stack = [];\n    this.maxDepth = 0;\n  }\n\n  trace(fn, name) {\n    return (...args) => {\n      this.stack.push({ name, args, timestamp: Date.now() });\n      this.maxDepth = Math.max(this.maxDepth, this.stack.length);\n\n      try {\n        const result = fn.apply(this, args);\n        const call = this.stack.pop();\n        call.result = result;\n        call.duration = Date.now() - call.timestamp;\n        return result;\n      } catch (error) {\n        this.stack.pop();\n        throw error;\n      }\n    };\n  }\n\n  getStats() {\n    return {\n      maxDepth: this.maxDepth,\n      currentDepth: this.stack.length,\n      currentStack: [...this.stack],\n    };\n  }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-validation-and-testing",children:"3. Validation and Testing"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Recursive function validator\nclass RecursionValidator {\n  static validateBaseCase(fn, baseCaseInputs, expectedOutputs) {\n    for (let i = 0; i < baseCaseInputs.length; i++) {\n      const result = fn(baseCaseInputs[i]);\n      if (result !== expectedOutputs[i]) {\n        throw new Error(\n          `Base case failed: f(${baseCaseInputs[i]}) = ${result}, expected ${expectedOutputs[i]}`\n        );\n      }\n    }\n    return true;\n  }\n\n  static validateProgress(fn, input, maxDepth = 1000) {\n    const visited = new Set();\n    let depth = 0;\n\n    function checkProgress(args) {\n      const key = JSON.stringify(args);\n\n      if (visited.has(key)) {\n        throw new Error(`Infinite recursion detected: revisiting ${key}`);\n      }\n\n      if (depth > maxDepth) {\n        throw new Error(`Maximum depth exceeded: ${depth}`);\n      }\n\n      visited.add(key);\n      depth++;\n    }\n\n    // This is a simplified check - real implementation would need\n    // to intercept the recursive calls\n    return true;\n  }\n}\n\n// Property-based testing for recursive functions\nfunction testRecursiveProperty(fn, generator, property, numTests = 100) {\n  for (let i = 0; i < numTests; i++) {\n    const input = generator();\n    const result = fn(input);\n\n    if (!property(input, result)) {\n      throw new Error(\n        `Property failed for input: ${JSON.stringify(input)}, result: ${JSON.stringify(result)}`\n      );\n    }\n  }\n\n  return true;\n}\n\n// Example usage\ntestRecursiveProperty(\n  factorial,\n  () => Math.floor(Math.random() * 10), // Generate random input\n  (input, result) => {\n    // Property: factorial(n) should be greater than factorial(n-1) for n > 1\n    return input <= 1 || result > factorial(input - 1);\n  }\n);\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"real-world-applications",children:"Real-World Applications"}),"\n",(0,t.jsx)(e.p,{children:"Practical applications of recursion in software development."}),"\n",(0,t.jsx)(e.h3,{id:"1-file-system-operations",children:"1. File System Operations"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Recursively traverse directory structure\nasync function traverseDirectory(dirPath, callback, options = {}) {\n  const {\n    includeFiles = true,\n    includeDirs = true,\n    maxDepth = Infinity,\n    currentDepth = 0,\n  } = options;\n\n  if (currentDepth >= maxDepth) return;\n\n  try {\n    const entries = await fs.readdir(dirPath, { withFileTypes: true });\n\n    for (const entry of entries) {\n      const fullPath = path.join(dirPath, entry.name);\n\n      if (entry.isDirectory()) {\n        if (includeDirs) callback(fullPath, 'directory', currentDepth);\n\n        // Recursive call for subdirectory\n        await traverseDirectory(fullPath, callback, {\n          ...options,\n          currentDepth: currentDepth + 1,\n        });\n      } else if (entry.isFile() && includeFiles) {\n        callback(fullPath, 'file', currentDepth);\n      }\n    }\n  } catch (error) {\n    console.error(`Error reading directory ${dirPath}:`, error.message);\n  }\n}\n\n// Calculate total size of directory\nasync function calculateDirectorySize(dirPath) {\n  let totalSize = 0;\n\n  await traverseDirectory(dirPath, async (filePath, type) => {\n    if (type === 'file') {\n      try {\n        const stats = await fs.stat(filePath);\n        totalSize += stats.size;\n      } catch (error) {\n        console.error(`Error getting stats for ${filePath}:`, error.message);\n      }\n    }\n  });\n\n  return totalSize;\n}\n\n// Find files matching pattern\nasync function findFiles(dirPath, pattern, results = []) {\n  await traverseDirectory(dirPath, (filePath, type) => {\n    if (type === 'file' && pattern.test(path.basename(filePath))) {\n      results.push(filePath);\n    }\n  });\n\n  return results;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-jsonxml-processing",children:"2. JSON/XML Processing"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Recursively process JSON structure\nfunction processJSON(obj, processor, path = '') {\n  if (obj === null || typeof obj !== 'object') {\n    return processor(obj, path);\n  }\n\n  if (Array.isArray(obj)) {\n    return obj.map((item, index) =>\n      processJSON(item, processor, `${path}[${index}]`)\n    );\n  } else {\n    const result = {};\n    for (const [key, value] of Object.entries(obj)) {\n      const newPath = path ? `${path}.${key}` : key;\n      result[key] = processJSON(value, processor, newPath);\n    }\n    return result;\n  }\n}\n\n// Flatten nested JSON\nfunction flattenJSON(obj, separator = '.', prefix = '') {\n  const result = {};\n\n  function flatten(current, path) {\n    if (\n      current === null ||\n      typeof current !== 'object' ||\n      Array.isArray(current)\n    ) {\n      result[path] = current;\n      return;\n    }\n\n    for (const [key, value] of Object.entries(current)) {\n      const newPath = path ? `${path}${separator}${key}` : key;\n      flatten(value, newPath);\n    }\n  }\n\n  flatten(obj, prefix);\n  return result;\n}\n\n// Deep clone with custom handling\nfunction deepClone(obj, customCloners = {}, visited = new WeakMap()) {\n  // Handle primitives and null\n  if (obj === null || typeof obj !== 'object') {\n    return obj;\n  }\n\n  // Handle circular references\n  if (visited.has(obj)) {\n    return visited.get(obj);\n  }\n\n  // Handle custom types\n  for (const [type, cloner] of Object.entries(customCloners)) {\n    if (obj instanceof global[type]) {\n      const cloned = cloner(obj);\n      visited.set(obj, cloned);\n      return cloned;\n    }\n  }\n\n  // Handle arrays\n  if (Array.isArray(obj)) {\n    const cloned = [];\n    visited.set(obj, cloned);\n    for (let i = 0; i < obj.length; i++) {\n      cloned[i] = deepClone(obj[i], customCloners, visited);\n    }\n    return cloned;\n  }\n\n  // Handle objects\n  const cloned = {};\n  visited.set(obj, cloned);\n  for (const [key, value] of Object.entries(obj)) {\n    cloned[key] = deepClone(value, customCloners, visited);\n  }\n\n  return cloned;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-algorithm-implementation",children:"3. Algorithm Implementation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Recursive descent parser\nclass RecursiveDescentParser {\n  constructor(tokens) {\n    this.tokens = tokens;\n    this.position = 0;\n  }\n\n  parse() {\n    return this.parseExpression();\n  }\n\n  parseExpression() {\n    let left = this.parseTerm();\n\n    while (this.match('+', '-')) {\n      const operator = this.previous();\n      const right = this.parseTerm();\n      left = { type: 'binary', left, operator: operator.value, right };\n    }\n\n    return left;\n  }\n\n  parseTerm() {\n    let left = this.parseFactor();\n\n    while (this.match('*', '/')) {\n      const operator = this.previous();\n      const right = this.parseFactor();\n      left = { type: 'binary', left, operator: operator.value, right };\n    }\n\n    return left;\n  }\n\n  parseFactor() {\n    if (this.match('NUMBER')) {\n      return { type: 'literal', value: this.previous().value };\n    }\n\n    if (this.match('(')) {\n      const expr = this.parseExpression(); // Recursive call\n      this.consume(')', \"Expected ')' after expression\");\n      return expr;\n    }\n\n    throw new Error(`Unexpected token: ${this.peek().value}`);\n  }\n\n  match(...types) {\n    for (const type of types) {\n      if (this.check(type)) {\n        this.advance();\n        return true;\n      }\n    }\n    return false;\n  }\n\n  check(type) {\n    if (this.isAtEnd()) return false;\n    return this.peek().type === type;\n  }\n\n  advance() {\n    if (!this.isAtEnd()) this.position++;\n    return this.previous();\n  }\n\n  isAtEnd() {\n    return this.position >= this.tokens.length;\n  }\n\n  peek() {\n    return this.tokens[this.position];\n  }\n\n  previous() {\n    return this.tokens[this.position - 1];\n  }\n\n  consume(type, message) {\n    if (this.check(type)) return this.advance();\n    throw new Error(message);\n  }\n}\n\n// Backtracking algorithm for N-Queens\nfunction solveNQueens(n) {\n  const solutions = [];\n  const board = Array(n)\n    .fill()\n    .map(() => Array(n).fill('.'));\n\n  function isValid(row, col) {\n    // Check column\n    for (let i = 0; i < row; i++) {\n      if (board[i][col] === 'Q') return false;\n    }\n\n    // Check diagonal\n    for (let i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\n      if (board[i][j] === 'Q') return false;\n    }\n\n    // Check anti-diagonal\n    for (let i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {\n      if (board[i][j] === 'Q') return false;\n    }\n\n    return true;\n  }\n\n  function backtrack(row) {\n    if (row === n) {\n      solutions.push(board.map(row => row.join('')));\n      return;\n    }\n\n    for (let col = 0; col < n; col++) {\n      if (isValid(row, col)) {\n        board[row][col] = 'Q';\n        backtrack(row + 1); // Recursive call\n        board[row][col] = '.'; // Backtrack\n      }\n    }\n  }\n\n  backtrack(0);\n  return solutions;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"4-data-structure-implementation",children:"4. Data Structure Implementation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Recursive Binary Search Tree\nclass BinarySearchTree {\n  constructor() {\n    this.root = null;\n  }\n\n  insert(value) {\n    this.root = this.insertRec(this.root, value);\n  }\n\n  insertRec(node, value) {\n    if (!node) return { value, left: null, right: null };\n\n    if (value < node.value) {\n      node.left = this.insertRec(node.left, value);\n    } else if (value > node.value) {\n      node.right = this.insertRec(node.right, value);\n    }\n\n    return node;\n  }\n\n  search(value) {\n    return this.searchRec(this.root, value);\n  }\n\n  searchRec(node, value) {\n    if (!node || node.value === value) return node;\n\n    if (value < node.value) {\n      return this.searchRec(node.left, value);\n    } else {\n      return this.searchRec(node.right, value);\n    }\n  }\n\n  delete(value) {\n    this.root = this.deleteRec(this.root, value);\n  }\n\n  deleteRec(node, value) {\n    if (!node) return null;\n\n    if (value < node.value) {\n      node.left = this.deleteRec(node.left, value);\n    } else if (value > node.value) {\n      node.right = this.deleteRec(node.right, value);\n    } else {\n      // Node to delete found\n      if (!node.left) return node.right;\n      if (!node.right) return node.left;\n\n      // Node has two children\n      const minRight = this.findMin(node.right);\n      node.value = minRight.value;\n      node.right = this.deleteRec(node.right, minRight.value);\n    }\n\n    return node;\n  }\n\n  findMin(node) {\n    while (node.left) {\n      node = node.left;\n    }\n    return node;\n  }\n\n  inorderTraversal() {\n    const result = [];\n    this.inorderRec(this.root, result);\n    return result;\n  }\n\n  inorderRec(node, result) {\n    if (node) {\n      this.inorderRec(node.left, result);\n      result.push(node.value);\n      this.inorderRec(node.right, result);\n    }\n  }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsx)(e.p,{children:"Recursion is a powerful problem-solving technique that provides elegant solutions to complex problems. Key takeaways:"}),"\n",(0,t.jsx)(e.h3,{id:"best-practices",children:"Best Practices:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Always define clear base cases"})," to prevent infinite recursion"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Ensure progress toward base case"})," with each recursive call"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Consider space complexity"})," - deep recursion can cause stack overflow"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Use memoization"})," for overlapping subproblems"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Convert to iteration"})," when stack space is a concern"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Debug systematically"})," with proper tracing and validation"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"when-to-use-recursion-1",children:"When to Use Recursion:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.strong,{children:"Tree and graph algorithms"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.strong,{children:"Divide and conquer problems"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.strong,{children:"Mathematical computations with recursive definitions"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.strong,{children:"Backtracking algorithms"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.strong,{children:"Parsing and language processing"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.strong,{children:"Dynamic programming problems"})}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"alternatives-to-consider",children:"Alternatives to Consider:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Iteration with explicit stack"})," for space optimization"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Dynamic programming"})," for optimization problems"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Memoization"})," for expensive computations"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Tail recursion optimization"})," where supported"]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"Recursion is an essential tool in every programmer's toolkit. Master these patterns, understand the trade-offs, and apply them judiciously to write elegant and efficient code."}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.em,{children:"This comprehensive guide covers the fundamental patterns and techniques of recursion. Practice implementing these examples and experiment with variations to deepen your understanding of recursive problem-solving."}),"# Complete Recursion Patterns & Techniques"]}),"\n",(0,t.jsx)(e.p,{children:"A comprehensive guide to recursion algorithms, patterns, and all types of recursive techniques for Data Structures and Algorithms."}),"\n",(0,t.jsx)(e.h2,{id:"table-of-contents-1",children:"Table of Contents"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#core-recursion-concepts",children:"Core Recursion Concepts"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#types-of-recursion",children:"Types of Recursion"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#the-recursion-template",children:"The Recursion Template"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#linear-recursion-patterns",children:"Linear Recursion Patterns"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#binary-recursion-patterns",children:"Binary Recursion Patterns"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#multiple-recursion-patterns",children:"Multiple Recursion Patterns"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#tail-recursion-optimization",children:"Tail Recursion Optimization"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#mutual-recursion-patterns",children:"Mutual Recursion Patterns"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#indirect-recursion",children:"Indirect Recursion"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#nested-recursion",children:"Nested Recursion"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#tree-recursion-patterns",children:"Tree Recursion Patterns"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#mathematical-recursion",children:"Mathematical Recursion"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#string-recursion-patterns",children:"String Recursion Patterns"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#array--list-recursion",children:"Array & List Recursion"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#divide-and-conquer",children:"Divide and Conquer"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#dynamic-programming-with-recursion",children:"Dynamic Programming with Recursion"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#recursion-optimization-techniques",children:"Recursion Optimization Techniques"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#converting-recursion-to-iteration",children:"Converting Recursion to Iteration"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#common-pitfalls--debugging",children:"Common Pitfalls & Debugging"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#real-world-applications",children:"Real-World Applications"})}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"core-recursion-concepts-1",children:"Core Recursion Concepts"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Recursion"})," is a problem-solving technique where a function calls itself to solve smaller instances of the same problem."]}),"\n",(0,t.jsx)(e.h3,{id:"essential-components-1",children:"Essential Components:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Base Case"}),": Condition to stop recursion"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Recursive Case"}),": Function calls itself with modified parameters"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Progress"}),": Each call moves toward base case"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Return"}),": Combines results from recursive calls"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"when-to-use-recursion-2",children:"When to Use Recursion:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Problem can be broken into similar smaller subproblems"}),"\n",(0,t.jsx)(e.li,{children:"Natural recursive structure (trees, fractals)"}),"\n",(0,t.jsx)(e.li,{children:"Mathematical sequences and formulas"}),"\n",(0,t.jsx)(e.li,{children:"Divide and conquer algorithms"}),"\n",(0,t.jsx)(e.li,{children:"Exploring all possibilities (backtracking)"}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"types-of-recursion-1",children:"Types of Recursion"}),"\n",(0,t.jsxs)(e.h3,{id:"1-linear-recursion-1",children:["1. ",(0,t.jsx)(e.strong,{children:"Linear Recursion"})]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["Function makes ",(0,t.jsx)(e.strong,{children:"one recursive call"})," per execution"]}),"\n",(0,t.jsx)(e.li,{children:"Forms a linear chain of calls"}),"\n"]}),"\n",(0,t.jsxs)(e.h3,{id:"2-binary-recursion-1",children:["2. ",(0,t.jsx)(e.strong,{children:"Binary Recursion"})]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["Function makes ",(0,t.jsx)(e.strong,{children:"two recursive calls"})," per execution"]}),"\n",(0,t.jsx)(e.li,{children:"Common in binary trees and divide-and-conquer"}),"\n"]}),"\n",(0,t.jsxs)(e.h3,{id:"3-multiple-recursion-1",children:["3. ",(0,t.jsx)(e.strong,{children:"Multiple Recursion"})]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["Function makes ",(0,t.jsx)(e.strong,{children:"multiple recursive calls"})," (more than 2)"]}),"\n",(0,t.jsx)(e.li,{children:"Seen in tree traversals with multiple children"}),"\n"]}),"\n",(0,t.jsxs)(e.h3,{id:"4-tail-recursion-1",children:["4. ",(0,t.jsx)(e.strong,{children:"Tail Recursion"})]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["Recursive call is the ",(0,t.jsx)(e.strong,{children:"last operation"})," in function"]}),"\n",(0,t.jsx)(e.li,{children:"Can be optimized to iteration by compilers"}),"\n"]}),"\n",(0,t.jsxs)(e.h3,{id:"5-head-recursion-1",children:["5. ",(0,t.jsx)(e.strong,{children:"Head Recursion"})]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["Recursive call is ",(0,t.jsx)(e.strong,{children:"before"})," other operations"]}),"\n",(0,t.jsx)(e.li,{children:"Processing happens on the way back"}),"\n"]}),"\n",(0,t.jsxs)(e.h3,{id:"6-mutual-recursion-1",children:["6. ",(0,t.jsx)(e.strong,{children:"Mutual Recursion"})]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Two or more functions"})," call each other recursively"]}),"\n",(0,t.jsx)(e.li,{children:"Creates interdependent recursive relationships"}),"\n"]}),"\n",(0,t.jsxs)(e.h3,{id:"7-indirect-recursion-1",children:["7. ",(0,t.jsx)(e.strong,{children:"Indirect Recursion"})]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Function A calls function B, which eventually calls A"}),"\n",(0,t.jsx)(e.li,{children:"More complex call chain than direct recursion"}),"\n"]}),"\n",(0,t.jsxs)(e.h3,{id:"8-nested-recursion-1",children:["8. ",(0,t.jsx)(e.strong,{children:"Nested Recursion"})]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["Recursive call uses ",(0,t.jsx)(e.strong,{children:"another recursive call as parameter"})]}),"\n",(0,t.jsx)(e.li,{children:"Very complex, like Ackermann function"}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"the-recursion-template-1",children:"The Recursion Template"}),"\n",(0,t.jsx)(e.h3,{id:"basic-recursion-template-1",children:"Basic Recursion Template"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function recursiveFunction(parameters) {\n  // Base case(s) - Stop condition\n  if (baseCondition(parameters)) {\n    return baseValue;\n  }\n\n  // Recursive case - Self-call with modified parameters\n  return combineResults(\n    recursiveFunction(modifyParameters(parameters)),\n    // possibly more recursive calls\n    otherProcessing(parameters)\n  );\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"generic-recursion-framework-1",children:"Generic Recursion Framework"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"class RecursionSolver {\n  constructor() {\n    this.memo = new Map(); // For memoization\n    this.callStack = []; // For debugging\n  }\n\n  solve(problem, enableMemo = false) {\n    if (enableMemo) {\n      return this.solveWithMemo(problem);\n    }\n    return this.recursiveSolve(problem);\n  }\n\n  recursiveSolve(problem) {\n    // Add to call stack for debugging\n    this.callStack.push(problem);\n\n    // Base case check\n    if (this.isBaseCase(problem)) {\n      this.callStack.pop();\n      return this.getBaseValue(problem);\n    }\n\n    // Break into subproblems\n    const subproblems = this.decompose(problem);\n    const results = [];\n\n    // Solve each subproblem\n    for (let subproblem of subproblems) {\n      results.push(this.recursiveSolve(subproblem));\n    }\n\n    // Combine results\n    const finalResult = this.combine(results, problem);\n\n    this.callStack.pop();\n    return finalResult;\n  }\n\n  solveWithMemo(problem) {\n    const key = this.getKey(problem);\n    if (this.memo.has(key)) {\n      return this.memo.get(key);\n    }\n\n    const result = this.recursiveSolve(problem);\n    this.memo.set(key, result);\n    return result;\n  }\n\n  // Abstract methods to override\n  isBaseCase(problem) {\n    throw new Error('Override this method');\n  }\n  getBaseValue(problem) {\n    throw new Error('Override this method');\n  }\n  decompose(problem) {\n    throw new Error('Override this method');\n  }\n  combine(results, problem) {\n    throw new Error('Override this method');\n  }\n  getKey(problem) {\n    return JSON.stringify(problem);\n  }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"linear-recursion-patterns-2",children:"Linear Recursion Patterns"}),"\n",(0,t.jsxs)(e.p,{children:["Linear recursion makes exactly ",(0,t.jsx)(e.strong,{children:"one recursive call"})," per execution."]}),"\n",(0,t.jsx)(e.h3,{id:"1-simple-linear-recursion---factorial-2",children:"1. Simple Linear Recursion - Factorial"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function factorial(n) {\n  // Base case\n  if (n <= 1) return 1;\n\n  // Recursive case: one recursive call\n  return n * factorial(n - 1);\n}\n\n// Call trace for factorial(4):\n// factorial(4) = 4 * factorial(3)\n// factorial(3) = 3 * factorial(2)\n// factorial(2) = 2 * factorial(1)\n// factorial(1) = 1\n// Result: 4 * 3 * 2 * 1 = 24\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-linear-search-in-array-2",children:"2. Linear Search in Array"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function linearSearchRecursive(arr, target, index = 0) {\n  // Base case: not found\n  if (index >= arr.length) return -1;\n\n  // Base case: found\n  if (arr[index] === target) return index;\n\n  // Recursive case: search in rest of array\n  return linearSearchRecursive(arr, target, index + 1);\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-sum-of-array-elements-2",children:"3. Sum of Array Elements"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function arraySum(arr, index = 0) {\n  // Base case\n  if (index >= arr.length) return 0;\n\n  // Recursive case\n  return arr[index] + arraySum(arr, index + 1);\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"4-linked-list-operations-2",children:"4. Linked List Operations"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"class ListNode {\n  constructor(val, next = null) {\n    this.val = val;\n    this.next = next;\n  }\n}\n\nfunction linkedListLength(head) {\n  // Base case\n  if (!head) return 0;\n\n  // Recursive case\n  return 1 + linkedListLength(head.next);\n}\n\nfunction linkedListSearch(head, target) {\n  // Base case: not found\n  if (!head) return null;\n\n  // Base case: found\n  if (head.val === target) return head;\n\n  // Recursive case\n  return linkedListSearch(head.next, target);\n}\n\nfunction reverseLinkedList(head) {\n  // Base case\n  if (!head || !head.next) return head;\n\n  // Recursive case\n  const newHead = reverseLinkedList(head.next);\n  head.next.next = head;\n  head.next = null;\n\n  return newHead;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"5-string-processing-2",children:"5. String Processing"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function isPalindrome(str, left = 0, right = str.length - 1) {\n  // Base case\n  if (left >= right) return true;\n\n  // Check current characters and recurse\n  if (str[left] !== str[right]) return false;\n  return isPalindrome(str, left + 1, right - 1);\n}\n\nfunction reverseString(str) {\n  // Base case\n  if (str.length <= 1) return str;\n\n  // Recursive case\n  return str[str.length - 1] + reverseString(str.slice(0, -1));\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"binary-recursion-patterns-2",children:"Binary Recursion Patterns"}),"\n",(0,t.jsxs)(e.p,{children:["Binary recursion makes exactly ",(0,t.jsx)(e.strong,{children:"two recursive calls"})," per execution."]}),"\n",(0,t.jsx)(e.h3,{id:"1-classic-binary-recursion---fibonacci-2",children:"1. Classic Binary Recursion - Fibonacci"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function fibonacci(n) {\n  // Base cases\n  if (n <= 1) return n;\n\n  // Binary recursive case\n  return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\n// Optimized with memoization\nfunction fibonacciMemo(n, memo = {}) {\n  if (n in memo) return memo[n];\n  if (n <= 1) return n;\n\n  memo[n] = fibonacciMemo(n - 1, memo) + fibonacciMemo(n - 2, memo);\n  return memo[n];\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-binary-tree-operations-2",children:"2. Binary Tree Operations"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"class TreeNode {\n  constructor(val, left = null, right = null) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}\n\n// Tree height/depth\nfunction maxDepth(root) {\n  // Base case\n  if (!root) return 0;\n\n  // Binary recursive case\n  return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\n}\n\n// Count total nodes\nfunction countNodes(root) {\n  if (!root) return 0;\n  return 1 + countNodes(root.left) + countNodes(root.right);\n}\n\n// Check if tree is balanced\nfunction isBalanced(root) {\n  function checkHeight(node) {\n    if (!node) return 0;\n\n    const leftHeight = checkHeight(node.left);\n    if (leftHeight === -1) return -1;\n\n    const rightHeight = checkHeight(node.right);\n    if (rightHeight === -1) return -1;\n\n    if (Math.abs(leftHeight - rightHeight) > 1) return -1;\n\n    return 1 + Math.max(leftHeight, rightHeight);\n  }\n\n  return checkHeight(root) !== -1;\n}\n\n// Binary tree paths\nfunction binaryTreePaths(root, currentPath = '', paths = []) {\n  if (!root) return paths;\n\n  currentPath += root.val;\n\n  // Leaf node\n  if (!root.left && !root.right) {\n    paths.push(currentPath);\n  } else {\n    // Binary recursion\n    if (root.left) binaryTreePaths(root.left, currentPath + '->', paths);\n    if (root.right) binaryTreePaths(root.right, currentPath + '->', paths);\n  }\n\n  return paths;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-binary-search-2",children:"3. Binary Search"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function binarySearch(arr, target, left = 0, right = arr.length - 1) {\n  // Base case: not found\n  if (left > right) return -1;\n\n  const mid = Math.floor((left + right) / 2);\n\n  // Base case: found\n  if (arr[mid] === target) return mid;\n\n  // Binary recursive cases\n  if (target < arr[mid]) {\n    return binarySearch(arr, target, left, mid - 1);\n  } else {\n    return binarySearch(arr, target, mid + 1, right);\n  }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"4-merge-sort-divide-and-conquer-2",children:"4. Merge Sort (Divide and Conquer)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function mergeSort(arr) {\n  // Base case\n  if (arr.length <= 1) return arr;\n\n  // Divide\n  const mid = Math.floor(arr.length / 2);\n  const left = arr.slice(0, mid);\n  const right = arr.slice(mid);\n\n  // Binary recursive calls\n  const sortedLeft = mergeSort(left);\n  const sortedRight = mergeSort(right);\n\n  // Conquer\n  return merge(sortedLeft, sortedRight);\n}\n\nfunction merge(left, right) {\n  const result = [];\n  let i = 0,\n    j = 0;\n\n  while (i < left.length && j < right.length) {\n    if (left[i] <= right[j]) {\n      result.push(left[i++]);\n    } else {\n      result.push(right[j++]);\n    }\n  }\n\n  return result.concat(left.slice(i)).concat(right.slice(j));\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"multiple-recursion-patterns-2",children:"Multiple Recursion Patterns"}),"\n",(0,t.jsxs)(e.p,{children:["Multiple recursion makes ",(0,t.jsx)(e.strong,{children:"more than two recursive calls"})," per execution."]}),"\n",(0,t.jsx)(e.h3,{id:"1-tree-with-multiple-children-2",children:"1. Tree with Multiple Children"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"class TreeNode {\n  constructor(val, children = []) {\n    this.val = val;\n    this.children = children;\n  }\n}\n\nfunction maxDepthNary(root) {\n  if (!root) return 0;\n\n  let maxChildDepth = 0;\n  // Multiple recursive calls for each child\n  for (let child of root.children) {\n    maxChildDepth = Math.max(maxChildDepth, maxDepthNary(child));\n  }\n\n  return 1 + maxChildDepth;\n}\n\nfunction naryTreePaths(root, currentPath = [], allPaths = []) {\n  if (!root) return allPaths;\n\n  currentPath.push(root.val);\n\n  if (root.children.length === 0) {\n    // Leaf node\n    allPaths.push([...currentPath]);\n  } else {\n    // Multiple recursive calls\n    for (let child of root.children) {\n      naryTreePaths(child, currentPath, allPaths);\n    }\n  }\n\n  currentPath.pop(); // Backtrack\n  return allPaths;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-maze-solving-4-directions-2",children:"2. Maze Solving (4 Directions)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function solveMaze(maze, x = 0, y = 0, solution = null) {\n  const n = maze.length;\n  if (!solution) {\n    solution = Array(n)\n      .fill()\n      .map(() => Array(n).fill(0));\n  }\n\n  // Base case: reached destination\n  if (x === n - 1 && y === n - 1) {\n    solution[x][y] = 1;\n    return true;\n  }\n\n  // Check if current position is valid\n  if (x >= 0 && x < n && y >= 0 && y < n && maze[x][y] === 1) {\n    solution[x][y] = 1;\n\n    // Multiple recursive calls for 4 directions\n    if (\n      solveMaze(maze, x + 1, y, solution) || // Down\n      solveMaze(maze, x, y + 1, solution) || // Right\n      solveMaze(maze, x - 1, y, solution) || // Up\n      solveMaze(maze, x, y - 1, solution)\n    ) {\n      // Left\n      return true;\n    }\n\n    // Backtrack\n    solution[x][y] = 0;\n  }\n\n  return false;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-generate-all-subsets-2",children:"3. Generate All Subsets"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function generateSubsets(nums, index = 0, current = [], result = []) {\n  // Base case\n  if (index === nums.length) {\n    result.push([...current]);\n    return result;\n  }\n\n  // Two recursive calls: include or exclude current element\n  // Include current element\n  current.push(nums[index]);\n  generateSubsets(nums, index + 1, current, result);\n\n  // Exclude current element (backtrack)\n  current.pop();\n  generateSubsets(nums, index + 1, current, result);\n\n  return result;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"4-tower-of-hanoi-2",children:"4. Tower of Hanoi"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function towerOfHanoi(n, source, destination, auxiliary, moves = []) {\n  // Base case\n  if (n === 1) {\n    moves.push(`Move disk 1 from ${source} to ${destination}`);\n    return moves;\n  }\n\n  // Three recursive calls\n  // Move n-1 disks to auxiliary peg\n  towerOfHanoi(n - 1, source, auxiliary, destination, moves);\n\n  // Move the bottom disk to destination\n  moves.push(`Move disk ${n} from ${source} to ${destination}`);\n\n  // Move n-1 disks from auxiliary to destination\n  towerOfHanoi(n - 1, auxiliary, destination, source, moves);\n\n  return moves;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"tail-recursion-optimization-2",children:"Tail Recursion Optimization"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Tail recursion"})," occurs when the recursive call is the ",(0,t.jsx)(e.strong,{children:"last operation"})," in the function."]}),"\n",(0,t.jsx)(e.h3,{id:"1-tail-recursive-factorial-2",children:"1. Tail Recursive Factorial"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Non-tail recursive (traditional)\nfunction factorial(n) {\n  if (n <= 1) return 1;\n  return n * factorial(n - 1); // Multiplication after recursive call\n}\n\n// Tail recursive version\nfunction factorialTail(n, accumulator = 1) {\n  if (n <= 1) return accumulator;\n  return factorialTail(n - 1, n * accumulator); // Recursive call is last\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-tail-recursive-sum-2",children:"2. Tail Recursive Sum"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Non-tail recursive\nfunction sum(n) {\n  if (n <= 0) return 0;\n  return n + sum(n - 1); // Addition after recursive call\n}\n\n// Tail recursive version\nfunction sumTail(n, accumulator = 0) {\n  if (n <= 0) return accumulator;\n  return sumTail(n - 1, accumulator + n); // Recursive call is last\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-tail-recursive-fibonacci-2",children:"3. Tail Recursive Fibonacci"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function fibonacciTail(n, a = 0, b = 1) {\n  if (n === 0) return a;\n  if (n === 1) return b;\n  return fibonacciTail(n - 1, b, a + b); // Tail recursive\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"4-converting-to-iterative-2",children:"4. Converting to Iterative"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Tail recursion can be easily converted to iteration\nfunction factorialIterative(n) {\n  let accumulator = 1;\n  while (n > 1) {\n    accumulator *= n;\n    n--;\n  }\n  return accumulator;\n}\n\n// Generic tail recursion to iteration converter\nfunction tailRecursionToIteration(initialValue, condition, update, extract) {\n  let current = initialValue;\n\n  while (!condition(current)) {\n    current = update(current);\n  }\n\n  return extract(current);\n}\n\n// Usage example\nconst factorial_n = tailRecursionToIteration(\n  { n: 5, acc: 1 },\n  state => state.n <= 1,\n  state => ({ n: state.n - 1, acc: state.acc * state.n }),\n  state => state.acc\n);\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"mutual-recursion-patterns-2",children:"Mutual Recursion Patterns"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Mutual recursion"})," occurs when two or more functions call each other recursively."]}),"\n",(0,t.jsx)(e.h3,{id:"1-evenodd-check-2",children:"1. Even/Odd Check"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function isEven(n) {\n  if (n === 0) return true;\n  return isOdd(n - 1);\n}\n\nfunction isOdd(n) {\n  if (n === 0) return false;\n  return isEven(n - 1);\n}\n\n// Usage\nconsole.log(isEven(4)); // true\nconsole.log(isOdd(5)); // true\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-expression-parsing-2",children:"2. Expression Parsing"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function parseExpression(tokens, index) {\n  let result = parseTerm(tokens, index);\n\n  while (\n    index.value < tokens.length &&\n    (tokens[index.value] === '+' || tokens[index.value] === '-')\n  ) {\n    const operator = tokens[index.value++];\n    const term = parseTerm(tokens, index);\n    result = operator === '+' ? result + term : result - term;\n  }\n\n  return result;\n}\n\nfunction parseTerm(tokens, index) {\n  let result = parseFactor(tokens, index);\n\n  while (\n    index.value < tokens.length &&\n    (tokens[index.value] === '*' || tokens[index.value] === '/')\n  ) {\n    const operator = tokens[index.value++];\n    const factor = parseFactor(tokens, index);\n    result = operator === '*' ? result * factor : result / factor;\n  }\n\n  return result;\n}\n\nfunction parseFactor(tokens, index) {\n  if (tokens[index.value] === '(') {\n    index.value++; // Skip '('\n    const result = parseExpression(tokens, index); // Mutual recursion\n    index.value++; // Skip ')'\n    return result;\n  }\n\n  return parseInt(tokens[index.value++]);\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-grammar-parsing-2",children:"3. Grammar Parsing"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function parseStatement(code, pos) {\n  if (code[pos.index] === 'if') {\n    return parseIfStatement(code, pos);\n  } else if (code[pos.index] === 'while') {\n    return parseWhileStatement(code, pos);\n  } else {\n    return parseAssignment(code, pos);\n  }\n}\n\nfunction parseIfStatement(code, pos) {\n  pos.index++; // Skip 'if'\n  const condition = parseExpression(code, pos);\n  const thenStmt = parseStatement(code, pos); // Mutual recursion\n\n  let elseStmt = null;\n  if (pos.index < code.length && code[pos.index] === 'else') {\n    pos.index++; // Skip 'else'\n    elseStmt = parseStatement(code, pos); // Mutual recursion\n  }\n\n  return { type: 'if', condition, then: thenStmt, else: elseStmt };\n}\n\nfunction parseWhileStatement(code, pos) {\n  pos.index++; // Skip 'while'\n  const condition = parseExpression(code, pos);\n  const body = parseStatement(code, pos); // Mutual recursion\n\n  return { type: 'while', condition, body };\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"4-state-machine-2",children:"4. State Machine"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function stateA(input, index) {\n  if (index >= input.length) return true;\n\n  if (input[index] === '0') {\n    return stateB(input, index + 1); // Mutual recursion\n  } else if (input[index] === '1') {\n    return stateA(input, index + 1);\n  }\n\n  return false;\n}\n\nfunction stateB(input, index) {\n  if (index >= input.length) return false;\n\n  if (input[index] === '0') {\n    return stateA(input, index + 1); // Mutual recursion\n  } else if (input[index] === '1') {\n    return stateB(input, index + 1);\n  }\n\n  return false;\n}\n\n// Check if string is accepted by the state machine\nfunction isAccepted(input) {\n  return stateA(input, 0);\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"indirect-recursion-2",children:"Indirect Recursion"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Indirect recursion"})," involves a chain of function calls that eventually leads back to the original function."]}),"\n",(0,t.jsx)(e.h3,{id:"1-three-function-chain-2",children:"1. Three-Function Chain"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function functionA(n) {\n  console.log(`A: ${n}`);\n  if (n > 0) {\n    return functionB(n - 1);\n  }\n  return 0;\n}\n\nfunction functionB(n) {\n  console.log(`B: ${n}`);\n  if (n > 0) {\n    return functionC(n - 1);\n  }\n  return 1;\n}\n\nfunction functionC(n) {\n  console.log(`C: ${n}`);\n  if (n > 0) {\n    return functionA(n - 1); // Back to A\n  }\n  return 2;\n}\n\n// Call chain: A -> B -> C -> A -> B -> C -> ...\nfunctionA(5);\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-complex-number-calculation-2",children:"2. Complex Number Calculation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function calculateReal(complex, depth) {\n  if (depth === 0) return complex.real;\n\n  const imagResult = calculateImaginary(\n    { real: complex.real * 0.5, imaginary: complex.imaginary * 0.5 },\n    depth - 1\n  );\n\n  return complex.real + imagResult;\n}\n\nfunction calculateImaginary(complex, depth) {\n  if (depth === 0) return complex.imaginary;\n\n  const realResult = calculateReal(\n    { real: complex.imaginary * 0.3, imaginary: complex.real * 0.7 },\n    depth - 1\n  );\n\n  return complex.imaginary + realResult;\n}\n\nfunction processComplex(complex, depth) {\n  const realPart = calculateReal(complex, depth);\n  const imagPart = calculateImaginary(complex, depth);\n\n  if (depth > 1) {\n    return processComplex({ real: realPart, imaginary: imagPart }, depth - 1);\n  }\n\n  return { real: realPart, imaginary: imagPart };\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-document-processing-chain-2",children:"3. Document Processing Chain"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function processDocument(doc, stage) {\n  switch (stage) {\n    case 'parse':\n      return parseDocument(doc, 'validate');\n    case 'validate':\n      return validateDocument(doc, 'transform');\n    case 'transform':\n      return transformDocument(doc, 'output');\n    case 'output':\n      return doc;\n    default:\n      return null;\n  }\n}\n\nfunction parseDocument(doc, nextStage) {\n  const parsed = { ...doc, parsed: true };\n  if (parsed.needsValidation) {\n    return processDocument(parsed, nextStage);\n  }\n  return parsed;\n}\n\nfunction validateDocument(doc, nextStage) {\n  const validated = { ...doc, valid: doc.parsed };\n  if (validated.needsTransformation) {\n    return processDocument(validated, nextStage);\n  }\n  return validated;\n}\n\nfunction transformDocument(doc, nextStage) {\n  const transformed = { ...doc, transformed: doc.valid };\n  return processDocument(transformed, nextStage);\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"nested-recursion-2",children:"Nested Recursion"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Nested recursion"})," occurs when a recursive call uses another recursive call as its parameter."]}),"\n",(0,t.jsx)(e.h3,{id:"1-ackermann-function-2",children:"1. Ackermann Function"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function ackermann(m, n) {\n  if (m === 0) {\n    return n + 1;\n  } else if (m > 0 && n === 0) {\n    return ackermann(m - 1, 1);\n  } else if (m > 0 && n > 0) {\n    // Nested recursion: recursive call as parameter\n    return ackermann(m - 1, ackermann(m, n - 1));\n  }\n}\n\n// Extremely fast-growing function\nconsole.log(ackermann(3, 2)); // 29\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-mccarthys-91-function-2",children:"2. McCarthy's 91 Function"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function mcCarthy91(n) {\n  if (n > 100) {\n    return n - 10;\n  } else {\n    // Nested recursion\n    return mcCarthy91(mcCarthy91(n + 11));\n  }\n}\n\n// Always returns 91 for n <= 100\nconsole.log(mcCarthy91(50)); // 91\nconsole.log(mcCarthy91(99)); // 91\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-nested-tree-processing-2",children:"3. Nested Tree Processing"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function processNestedTree(node) {\n  if (!node) return null;\n\n  if (node.type === 'leaf') {\n    return node.value;\n  }\n\n  if (node.type === 'transform') {\n    // Nested recursion: recursive call as parameter to another recursive call\n    return applyTransform(\n      processNestedTree(node.input),\n      processNestedTree(node.transform)\n    );\n  }\n\n  return processChildren(node.children);\n}\n\nfunction applyTransform(data, transform) {\n  if (!transform) return data;\n\n  if (transform.type === 'nested') {\n    // Another level of nesting\n    return applyTransform(data, processNestedTree(transform.nestedTransform));\n  }\n\n  return transform.fn(data);\n}\n\nfunction processChildren(children) {\n  if (!children || children.length === 0) return [];\n\n  return children.map(child => processNestedTree(child));\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"4-complex-mathematical-functions-2",children:"4. Complex Mathematical Functions"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function nestedMath(x, depth) {\n  if (depth === 0) return x;\n\n  if (x < 0) {\n    return -nestedMath(-x, depth - 1);\n  }\n\n  // Nested recursion with complex parameter\n  return Math.sqrt(nestedMath(x * nestedMath(x / 2, depth - 1), depth - 1));\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"tree-recursion-patterns-2",children:"Tree Recursion Patterns"}),"\n",(0,t.jsx)(e.p,{children:"Tree recursion involves recursive calls that form a tree-like structure of execution."}),"\n",(0,t.jsx)(e.h3,{id:"1-binary-tree-traversals-2",children:"1. Binary Tree Traversals"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Preorder: Root -> Left -> Right\nfunction preorderTraversal(root, result = []) {\n  if (!root) return result;\n\n  result.push(root.val); // Process root\n  preorderTraversal(root.left, result); // Recurse left\n  preorderTraversal(root.right, result); // Recurse right\n\n  return result;\n}\n\n// Inorder: Left -> Root -> Right\nfunction inorderTraversal(root, result = []) {\n  if (!root) return result;\n\n  inorderTraversal(root.left, result); // Recurse left\n  result.push(root.val); // Process root\n  inorderTraversal(root.right, result); // Recurse right\n\n  return result;\n}\n\n// Postorder: Left -> Right -> Root\nfunction postorderTraversal(root, result = []) {\n  if (!root) return result;\n\n  postorderTraversal(root.left, result); // Recurse left\n  postorderTraversal(root.right, result); // Recurse right\n  result.push(root.val); // Process root\n\n  return result;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-tree-validation-2",children:"2. Tree Validation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function isValidBST(root, min = -Infinity, max = Infinity) {\n  if (!root) return true;\n\n  if (root.val <= min || root.val >= max) return false;\n\n  // Tree recursion with different constraints\n  return (\n    isValidBST(root.left, min, root.val) &&\n    isValidBST(root.right, root.val, max)\n  );\n}\n\nfunction isSameTree(p, q) {\n  // Both null\n  if (!p && !q) return true;\n\n  // One null, one not\n  if (!p || !q) return false;\n\n  // Different values\n  if (p.val !== q.val) return false;\n\n  // Tree recursion\n  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n}\n\nfunction isSymmetric(root) {\n  if (!root) return true;\n\n  function isMirror(left, right) {\n    if (!left && !right) return true;\n    if (!left || !right) return false;\n\n    return (\n      left.val === right.val &&\n      isMirror(left.left, right.right) &&\n      isMirror(left.right, right.left)\n    );\n  }\n\n  return isMirror(root.left, root.right);\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-path-finding-in-trees-1",children:"3. Path Finding in Trees"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function hasPathSum(root, targetSum) {\n  if (!root) return false;\n\n  // Leaf node\n  if (!root.left && !root.right) {\n    return root.val === targetSum;\n  }\n\n  // Tree recursion\n  return (\n    hasPathSum(root.left, targetSum - root.val) ||\n    hasPathSum(root.right, targetSum - root.val)\n  );\n}\n\nfunction pathSum(root, targetSum, currentPath = [], allPaths = []) {\n  if (!root) return allPaths;\n\n  currentPath.push(root.val);\n\n  // Leaf node with target sum\n  if (\n    !root.left &&\n    !root.right &&\n    currentPath.reduce((sum, val) => sum + val, 0) === targetSum\n  ) {\n    allPaths.push([...currentPath]);\n  }\n\n  // Tree recursion\n  pathSum(root.left, targetSum, currentPath, allPaths);\n  pathSum(root.right, targetSum, currentPath, allPaths);\n\n  currentPath.pop(); // Backtrack\n  return allPaths;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"4-tree-construction-1",children:"4. Tree Construction"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function buildTreeFromPreorderInorder(preorder, inorder) {\n  if (preorder.length === 0) return null;\n\n  const rootVal = preorder[0];\n  const root = new TreeNode(rootVal);\n\n  const rootIndex = inorder.indexOf(rootVal);\n\n  // Tree recursion to build left and right subtrees\n  root.left = buildTreeFromPreorderInorder(\n    preorder.slice(1, rootIndex + 1),\n    inorder.slice(0, rootIndex)\n  );\n\n  root.right = buildTreeFromPreorderInorder(\n    preorder.slice(rootIndex + 1),\n    inorder.slice(rootIndex + 1)\n  );\n\n  return root;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"mathematical-recursion-1",children:"Mathematical Recursion"}),"\n",(0,t.jsx)(e.p,{children:"Mathematical recursion deals with recursive mathematical formulas and sequences."}),"\n",(0,t.jsx)(e.h3,{id:"1-greatest-common-divisor-gcd-1",children:"1. Greatest Common Divisor (GCD)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function gcd(a, b) {\n  // Base case\n  if (b === 0) return a;\n\n  // Recursive case: Euclidean algorithm\n  return gcd(b, a % b);\n}\n\n// Extended Euclidean Algorithm\nfunction extendedGCD(a, b) {\n  if (b === 0) {\n    return { gcd: a, x: 1, y: 0 };\n  }\n\n  const result = extendedGCD(b, a % b);\n  const x = result.y;\n  const y = result.x - Math.floor(a / b) * result.y;\n\n  return { gcd: result.gcd, x, y };\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-power-function-1",children:"2. Power Function"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Naive recursive power\nfunction power(base, exponent) {\n  if (exponent === 0) return 1;\n  if (exponent === 1) return base;\n\n  return base * power(base, exponent - 1);\n}\n\n// Optimized power (fast exponentiation)\nfunction fastPower(base, exponent) {\n  if (exponent === 0) return 1;\n\n  if (exponent % 2 === 0) {\n    const halfPower = fastPower(base, exponent / 2);\n    return halfPower * halfPower;\n  } else {\n    return base * fastPower(base, exponent - 1);\n  }\n}\n\n// Power with modulo\nfunction powerMod(base, exponent, mod) {\n  if (exponent === 0) return 1;\n\n  if (exponent % 2 === 0) {\n    const halfPower = powerMod(base, exponent / 2, mod);\n    return (halfPower * halfPower) % mod;\n  } else {\n    return (base * powerMod(base, exponent - 1, mod)) % mod;\n  }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-combinatorics-1",children:"3. Combinatorics"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Combinations C(n, k)\nfunction combinations(n, k) {\n  // Base cases\n  if (k === 0 || k === n) return 1;\n  if (k > n) return 0;\n\n  // Recursive case: Pascal's triangle\n  return combinations(n - 1, k - 1) + combinations(n - 1, k);\n}\n\n// Permutations P(n, k)\nfunction permutations(n, k) {\n  if (k === 0) return 1;\n  if (k > n) return 0;\n\n  return n * permutations(n - 1, k - 1);\n}\n\n// Catalan Numbers\nfunction catalan(n) {\n  if (n <= 1) return 1;\n\n  let result = 0;\n  for (let i = 0; i < n; i++) {\n    result += catalan(i) * catalan(n - 1 - i);\n  }\n\n  return result;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"4-number-theory-1",children:"4. Number Theory"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Prime factorization\nfunction primeFactors(n, factor = 2, factors = []) {\n  if (n === 1) return factors;\n\n  if (n % factor === 0) {\n    factors.push(factor);\n    return primeFactors(n / factor, factor, factors);\n  }\n\n  return primeFactors(n, factor + 1, factors);\n}\n\n// Sum of digits\nfunction sumOfDigits(n) {\n  if (n === 0) return 0;\n  return (n % 10) + sumOfDigits(Math.floor(n / 10));\n}\n\n// Reverse number\nfunction reverseNumber(n, reversed = 0) {\n  if (n === 0) return reversed;\n  return reverseNumber(Math.floor(n / 10), reversed * 10 + (n % 10));\n}\n\n// Check if palindrome number\nfunction isPalindromeNumber(n) {\n  return n === reverseNumber(n);\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"string-recursion-patterns-1",children:"String Recursion Patterns"}),"\n",(0,t.jsx)(e.p,{children:"String recursion involves processing strings through recursive decomposition."}),"\n",(0,t.jsx)(e.h3,{id:"1-string-manipulation-1",children:"1. String Manipulation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Remove character from string\nfunction removeChar(str, char) {\n  if (str.length === 0) return '';\n\n  if (str[0] === char) {\n    return removeChar(str.slice(1), char);\n  } else {\n    return str[0] + removeChar(str.slice(1), char);\n  }\n}\n\n// Replace character in string\nfunction replaceChar(str, oldChar, newChar) {\n  if (str.length === 0) return '';\n\n  const firstChar = str[0] === oldChar ? newChar : str[0];\n  return firstChar + replaceChar(str.slice(1), oldChar, newChar);\n}\n\n// Count occurrences\nfunction countChar(str, char) {\n  if (str.length === 0) return 0;\n\n  const count = str[0] === char ? 1 : 0;\n  return count + countChar(str.slice(1), char);\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-string-validation-1",children:"2. String Validation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Check if string contains only digits\nfunction isDigitsOnly(str) {\n  if (str.length === 0) return true;\n\n  if (str[0] < '0' || str[0] > '9') return false;\n\n  return isDigitsOnly(str.slice(1));\n}\n\n// Check balanced parentheses\nfunction isBalanced(str, index = 0, count = 0) {\n  if (index === str.length) return count === 0;\n\n  if (str[index] === '(') {\n    return isBalanced(str, index + 1, count + 1);\n  } else if (str[index] === ')') {\n    if (count === 0) return false;\n    return isBalanced(str, index + 1, count - 1);\n  } else {\n    return isBalanced(str, index + 1, count);\n  }\n}\n\n// Check if anagram\nfunction isAnagram(str1, str2) {\n  if (str1.length !== str2.length) return false;\n  if (str1.length === 0) return true;\n\n  const char = str1[0];\n  const index = str2.indexOf(char);\n\n  if (index === -1) return false;\n\n  return isAnagram(str1.slice(1), str2.slice(0, index) + str2.slice(index + 1));\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-pattern-matching-1",children:"3. Pattern Matching"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Simple pattern matching with wildcards\nfunction patternMatch(str, pattern, sIndex = 0, pIndex = 0) {\n  // Base cases\n  if (pIndex === pattern.length) return sIndex === str.length;\n  if (sIndex === str.length)\n    return pattern\n      .slice(pIndex)\n      .split('')\n      .every(c => c === '*');\n\n  if (pattern[pIndex] === '*') {\n    // Try matching zero characters or one character\n    return (\n      patternMatch(str, pattern, sIndex, pIndex + 1) ||\n      patternMatch(str, pattern, sIndex + 1, pIndex)\n    );\n  } else if (pattern[pIndex] === '?' || pattern[pIndex] === str[sIndex]) {\n    return patternMatch(str, pattern, sIndex + 1, pIndex + 1);\n  }\n\n  return false;\n}\n\n// Longest common subsequence\nfunction longestCommonSubsequence(str1, str2, i = 0, j = 0) {\n  if (i === str1.length || j === str2.length) return 0;\n\n  if (str1[i] === str2[j]) {\n    return 1 + longestCommonSubsequence(str1, str2, i + 1, j + 1);\n  } else {\n    return Math.max(\n      longestCommonSubsequence(str1, str2, i + 1, j),\n      longestCommonSubsequence(str1, str2, i, j + 1)\n    );\n  }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"4-string-generation-1",children:"4. String Generation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Generate all permutations\nfunction stringPermutations(str, current = '', used = new Set(), result = []) {\n  if (current.length === str.length) {\n    result.push(current);\n    return result;\n  }\n\n  for (let i = 0; i < str.length; i++) {\n    if (!used.has(i)) {\n      used.add(i);\n      stringPermutations(str, current + str[i], used, result);\n      used.delete(i);\n    }\n  }\n\n  return result;\n}\n\n// Generate all subsequences\nfunction generateSubsequences(str, index = 0, current = '', result = []) {\n  if (index === str.length) {\n    result.push(current);\n    return result;\n  }\n\n  // Include current character\n  generateSubsequences(str, index + 1, current + str[index], result);\n\n  // Exclude current character\n  generateSubsequences(str, index + 1, current, result);\n\n  return result;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"array--list-recursion-1",children:"Array & List Recursion"}),"\n",(0,t.jsx)(e.p,{children:"Array and list recursion patterns for processing sequential data structures."}),"\n",(0,t.jsx)(e.h3,{id:"1-array-processing-1",children:"1. Array Processing"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Find maximum element\nfunction findMax(arr, index = 0) {\n  if (index === arr.length - 1) return arr[index];\n\n  const maxOfRest = findMax(arr, index + 1);\n  return Math.max(arr[index], maxOfRest);\n}\n\n// Find minimum element\nfunction findMin(arr, index = 0) {\n  if (index === arr.length - 1) return arr[index];\n\n  const minOfRest = findMin(arr, index + 1);\n  return Math.min(arr[index], minOfRest);\n}\n\n// Array sum\nfunction arraySum(arr, index = 0) {\n  if (index >= arr.length) return 0;\n  return arr[index] + arraySum(arr, index + 1);\n}\n\n// Array product\nfunction arrayProduct(arr, index = 0) {\n  if (index >= arr.length) return 1;\n  return arr[index] * arrayProduct(arr, index + 1);\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-array-searching-1",children:"2. Array Searching"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Binary search\nfunction binarySearchRecursive(arr, target, left = 0, right = arr.length - 1) {\n  if (left > right) return -1;\n\n  const mid = Math.floor((left + right) / 2);\n\n  if (arr[mid] === target) return mid;\n\n  if (target < arr[mid]) {\n    return binarySearchRecursive(arr, target, left, mid - 1);\n  } else {\n    return binarySearchRecursive(arr, target, mid + 1, right);\n  }\n}\n\n// Find all occurrences\nfunction findAllOccurrences(arr, target, index = 0, occurrences = []) {\n  if (index >= arr.length) return occurrences;\n\n  if (arr[index] === target) {\n    occurrences.push(index);\n  }\n\n  return findAllOccurrences(arr, target, index + 1, occurrences);\n}\n\n// Check if array is sorted\nfunction isSorted(arr, index = 0) {\n  if (index >= arr.length - 1) return true;\n\n  if (arr[index] > arr[index + 1]) return false;\n\n  return isSorted(arr, index + 1);\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-array-transformation-1",children:"3. Array Transformation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Reverse array\nfunction reverseArray(arr, start = 0, end = arr.length - 1) {\n  if (start >= end) return arr;\n\n  // Swap elements\n  [arr[start], arr[end]] = [arr[end], arr[start]];\n\n  return reverseArray(arr, start + 1, end - 1);\n}\n\n// Filter array\nfunction filterArray(arr, predicate, index = 0, result = []) {\n  if (index >= arr.length) return result;\n\n  if (predicate(arr[index])) {\n    result.push(arr[index]);\n  }\n\n  return filterArray(arr, predicate, index + 1, result);\n}\n\n// Map array\nfunction mapArray(arr, transform, index = 0, result = []) {\n  if (index >= arr.length) return result;\n\n  result.push(transform(arr[index]));\n\n  return mapArray(arr, transform, index + 1, result);\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"4-advanced-array-operations-1",children:"4. Advanced Array Operations"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Merge two sorted arrays\nfunction mergeSortedArrays(arr1, arr2, i = 0, j = 0, result = []) {\n  if (i >= arr1.length && j >= arr2.length) return result;\n\n  if (i >= arr1.length) {\n    result.push(arr2[j]);\n    return mergeSortedArrays(arr1, arr2, i, j + 1, result);\n  }\n\n  if (j >= arr2.length) {\n    result.push(arr1[i]);\n    return mergeSortedArrays(arr1, arr2, i + 1, j, result);\n  }\n\n  if (arr1[i] <= arr2[j]) {\n    result.push(arr1[i]);\n    return mergeSortedArrays(arr1, arr2, i + 1, j, result);\n  } else {\n    result.push(arr2[j]);\n    return mergeSortedArrays(arr1, arr2, i, j + 1, result);\n  }\n}\n\n// Quick select (find kth smallest)\nfunction quickSelect(arr, k, left = 0, right = arr.length - 1) {\n  if (left === right) return arr[left];\n\n  const pivotIndex = partition(arr, left, right);\n\n  if (k === pivotIndex) {\n    return arr[k];\n  } else if (k < pivotIndex) {\n    return quickSelect(arr, k, left, pivotIndex - 1);\n  } else {\n    return quickSelect(arr, k, pivotIndex + 1, right);\n  }\n}\n\nfunction partition(arr, left, right) {\n  const pivot = arr[right];\n  let i = left;\n\n  for (let j = left; j < right; j++) {\n    if (arr[j] <= pivot) {\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n      i++;\n    }\n  }\n\n  [arr[i], arr[right]] = [arr[right], arr[i]];\n  return i;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"divide-and-conquer-1",children:"Divide and Conquer"}),"\n",(0,t.jsx)(e.p,{children:"Divide and conquer is a recursive algorithm design paradigm."}),"\n",(0,t.jsx)(e.h3,{id:"1-classic-sorting-algorithms-1",children:"1. Classic Sorting Algorithms"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Quick Sort\nfunction quickSort(arr, left = 0, right = arr.length - 1) {\n  if (left < right) {\n    const pivotIndex = partition(arr, left, right);\n\n    // Divide and conquer\n    quickSort(arr, left, pivotIndex - 1);\n    quickSort(arr, pivotIndex + 1, right);\n  }\n\n  return arr;\n}\n\n// Merge Sort (already shown earlier)\nfunction mergeSort(arr) {\n  if (arr.length <= 1) return arr;\n\n  const mid = Math.floor(arr.length / 2);\n  const left = mergeSort(arr.slice(0, mid));\n  const right = mergeSort(arr.slice(mid));\n\n  return merge(left, right);\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-maximum-subarray-kadanes-algorithm---divide--conquer-1",children:"2. Maximum Subarray (Kadane's Algorithm - Divide & Conquer)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function maxSubarrayDivideConquer(arr, left = 0, right = arr.length - 1) {\n  if (left === right) return arr[left];\n\n  const mid = Math.floor((left + right) / 2);\n\n  // Divide\n  const leftMax = maxSubarrayDivideConquer(arr, left, mid);\n  const rightMax = maxSubarrayDivideConquer(arr, mid + 1, right);\n\n  // Conquer - find max crossing subarray\n  let leftSum = -Infinity;\n  let sum = 0;\n  for (let i = mid; i >= left; i--) {\n    sum += arr[i];\n    leftSum = Math.max(leftSum, sum);\n  }\n\n  let rightSum = -Infinity;\n  sum = 0;\n  for (let i = mid + 1; i <= right; i++) {\n    sum += arr[i];\n    rightSum = Math.max(rightSum, sum);\n  }\n\n  const crossSum = leftSum + rightSum;\n\n  // Return maximum of three\n  return Math.max(leftMax, rightMax, crossSum);\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-closest-pair-of-points-1",children:"3. Closest Pair of Points"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function closestPairDivideConquer(points) {\n  points.sort((a, b) => a.x - b.x);\n  return closestPairRec(points);\n}\n\nfunction closestPairRec(points) {\n  const n = points.length;\n\n  if (n <= 3) return bruteForceClosest(points);\n\n  const mid = Math.floor(n / 2);\n  const midPoint = points[mid];\n\n  const leftPoints = points.slice(0, mid);\n  const rightPoints = points.slice(mid);\n\n  // Divide\n  const leftMin = closestPairRec(leftPoints);\n  const rightMin = closestPairRec(rightPoints);\n\n  // Find minimum of two halves\n  const minDist = Math.min(leftMin, rightMin);\n\n  // Conquer - check points near dividing line\n  const strip = points.filter(\n    point => Math.abs(point.x - midPoint.x) < minDist\n  );\n\n  return Math.min(minDist, stripClosest(strip, minDist));\n}\n\nfunction distance(p1, p2) {\n  return Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);\n}\n\nfunction bruteForceClosest(points) {\n  let minDist = Infinity;\n  for (let i = 0; i < points.length; i++) {\n    for (let j = i + 1; j < points.length; j++) {\n      minDist = Math.min(minDist, distance(points[i], points[j]));\n    }\n  }\n  return minDist;\n}\n\nfunction stripClosest(strip, d) {\n  let minDist = d;\n  strip.sort((a, b) => a.y - b.y);\n\n  for (let i = 0; i < strip.length; i++) {\n    for (\n      let j = i + 1;\n      j < strip.length && strip[j].y - strip[i].y < minDist;\n      j++\n    ) {\n      minDist = Math.min(minDist, distance(strip[i], strip[j]));\n    }\n  }\n\n  return minDist;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"4-matrix-multiplication-strassens-algorithm-1",children:"4. Matrix Multiplication (Strassen's Algorithm)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function strassenMultiply(A, B) {\n  const n = A.length;\n\n  if (n === 1) {\n    return [[A[0][0] * B[0][0]]];\n  }\n\n  // Divide matrices into quadrants\n  const mid = Math.floor(n / 2);\n  const A11 = getSubMatrix(A, 0, 0, mid);\n  const A12 = getSubMatrix(A, 0, mid, mid);\n  const A21 = getSubMatrix(A, mid, 0, mid);\n  const A22 = getSubMatrix(A, mid, mid, mid);\n\n  const B11 = getSubMatrix(B, 0, 0, mid);\n  const B12 = getSubMatrix(B, 0, mid, mid);\n  const B21 = getSubMatrix(B, mid, 0, mid);\n  const B22 = getSubMatrix(B, mid, mid, mid);\n\n  // Strassen's 7 products\n  const M1 = strassenMultiply(addMatrices(A11, A22), addMatrices(B11, B22));\n  const M2 = strassenMultiply(addMatrices(A21, A22), B11);\n  const M3 = strassenMultiply(A11, subtractMatrices(B12, B22));\n  const M4 = strassenMultiply(A22, subtractMatrices(B21, B11));\n  const M5 = strassenMultiply(addMatrices(A11, A12), B22);\n  const M6 = strassenMultiply(\n    subtractMatrices(A21, A11),\n    addMatrices(B11, B12)\n  );\n  const M7 = strassenMultiply(\n    subtractMatrices(A12, A22),\n    addMatrices(B21, B22)\n  );\n\n  // Compute result quadrants\n  const C11 = addMatrices(subtractMatrices(addMatrices(M1, M4), M5), M7);\n  const C12 = addMatrices(M3, M5);\n  const C21 = addMatrices(M2, M4);\n  const C22 = addMatrices(subtractMatrices(addMatrices(M1, M3), M2), M6);\n\n  // Combine quadrants\n  return combineMatrices(C11, C12, C21, C22);\n}\n\nfunction getSubMatrix(matrix, startRow, startCol, size) {\n  const result = [];\n  for (let i = 0; i < size; i++) {\n    result[i] = [];\n    for (let j = 0; j < size; j++) {\n      result[i][j] = matrix[startRow + i][startCol + j];\n    }\n  }\n  return result;\n}\n\nfunction addMatrices(A, B) {\n  const n = A.length;\n  const result = [];\n  for (let i = 0; i < n; i++) {\n    result[i] = [];\n    for (let j = 0; j < n; j++) {\n      result[i][j] = A[i][j] + B[i][j];\n    }\n  }\n  return result;\n}\n\nfunction subtractMatrices(A, B) {\n  const n = A.length;\n  const result = [];\n  for (let i = 0; i < n; i++) {\n    result[i] = [];\n    for (let j = 0; j < n; j++) {\n      result[i][j] = A[i][j] - B[i][j];\n    }\n  }\n  return result;\n}\n\nfunction combineMatrices(C11, C12, C21, C22) {\n  const n = C11.length;\n  const result = Array(2 * n)\n    .fill()\n    .map(() => Array(2 * n).fill(0));\n\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      result[i][j] = C11[i][j];\n      result[i][j + n] = C12[i][j];\n      result[i + n][j] = C21[i][j];\n      result[i + n][j + n] = C22[i][j];\n    }\n  }\n\n  return result;\n}\n"})})]})}function d(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(u,{...n})}):u(n)}}}]);