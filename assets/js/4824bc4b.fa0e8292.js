"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[1650],{1022:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>c,toc:()=>o});var i=t(74848),l=t(28453);const s={title:"Floyd's Cycle Detection Algorithm"},r=void 0,c={id:"DSA/DSA with JavaScript/FlyodsCycleDetection",title:"Floyd's Cycle Detection Algorithm",description:"Normal Way of Detecting a cycle",source:"@site/docs/DSA/DSA with JavaScript/FlyodsCycleDetection.mdx",sourceDirName:"DSA/DSA with JavaScript",slug:"/DSA/DSA with JavaScript/FlyodsCycleDetection",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/FlyodsCycleDetection",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with JavaScript/FlyodsCycleDetection.mdx",tags:[],version:"current",frontMatter:{title:"Floyd's Cycle Detection Algorithm"},sidebar:"tutorialSidebar",previous:{title:"Floyd-Warshall Algorithm",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/Floyd-Warshall"},next:{title:"Frequency Counter Technique",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/FrequencyCounter"}},a={},o=[{value:"Normal Way of Detecting a cycle",id:"normal-way-of-detecting-a-cycle",level:3},{value:"Normal Way of Detecting the Node Where the cycle Begins",id:"normal-way-of-detecting-the-node-where-the-cycle-begins",level:3},{value:"Floyd&#39;s Cycle Detection Algorithm",id:"floyds-cycle-detection-algorithm",level:2},{value:"Overview",id:"overview",level:3},{value:"Algorithm Steps",id:"algorithm-steps",level:3},{value:"Example: Detecting a Cycle in a Linked List",id:"example-detecting-a-cycle-in-a-linked-list",level:3},{value:"Duplicate Element",id:"duplicate-element",level:3},{value:"Break a Cycle in Linkedlist",id:"break-a-cycle-in-linkedlist",level:2},{value:"Linkedlist Cycle length",id:"linkedlist-cycle-length",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h3,{id:"normal-way-of-detecting-a-cycle",children:"Normal Way of Detecting a cycle"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-JavaScript",children:"/**\n * @param {ListNode} head\n * @return {boolean}\n */\nvar hasCycle = function (head, visited = new Set()) {\n  if (!head) return false\n  if (visited.has(head)) return true\n  visited.add(head)\n  return hasCycle(head.next, visited)\n};\n"})}),"\n",(0,i.jsx)(n.h3,{id:"normal-way-of-detecting-the-node-where-the-cycle-begins",children:"Normal Way of Detecting the Node Where the cycle Begins"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-JavaScript",children:"/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar detectCycle = function (head, visited = new Set()) {\n  if (!head) return null\n  if (visited.has(head)) return head\n  visited.add(head)\n  return detectCycle(head.next, visited)\n};\n"})}),"\n",(0,i.jsx)(n.h2,{id:"floyds-cycle-detection-algorithm",children:"Floyd's Cycle Detection Algorithm"}),"\n",(0,i.jsx)(n.p,{children:"Floyd's Cycle Detection Algorithm, also known as the Tortoise and Hare algorithm, is a classic technique used to detect cycles in a sequence or linked list. It is an efficient algorithm with a time complexity of O(n) and space complexity of O(1), making it suitable for detecting cycles in data structures where additional space is limited."}),"\n",(0,i.jsx)(n.h3,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"The algorithm uses two pointers (often called the tortoise and the hare) that traverse the sequence at different speeds:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Tortoise"}),": Moves one step at a time."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Hare"}),": Moves two steps at a time."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["If there is a cycle in the sequence, the hare and the tortoise will eventually meet at some point within the cycle. If there is no cycle, the hare will reach the end of the sequence (e.g., ",(0,i.jsx)(n.code,{children:"null"})," in a linked list)."]}),"\n",(0,i.jsx)(n.h3,{id:"algorithm-steps",children:"Algorithm Steps"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Initialization"}),": Start both pointers at the beginning of the sequence."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Traversal"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Move the tortoise by one step."}),"\n",(0,i.jsx)(n.li,{children:"Move the hare by two steps."}),"\n",(0,i.jsx)(n.li,{children:"Continue until the hare either meets the tortoise (cycle detected) or reaches the end (no cycle)."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Detection"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"If the hare and tortoise meet, a cycle exists."}),"\n",(0,i.jsx)(n.li,{children:"If the hare reaches the end, there is no cycle."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"example-detecting-a-cycle-in-a-linked-list",children:"Example: Detecting a Cycle in a Linked List"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"JavaScript Implementation"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-JavaScript",children:"class ListNode {\n  constructor(value = 0, next = null) {\n    this.value = value;\n    this.next = next;\n  }\n}\n\n/**\n * Detect if a cycle exists in a linked list using Floyd's Cycle Detection Algorithm.\n * @param {ListNode} head - The head of the linked list.\n * @return {boolean} - True if a cycle is detected, false otherwise.\n */\nconst hasCycle = (head) => {\n  if (!head || !head.next) return false;\n\n  let tortoise = head;\n  let hare = head;\n\n  while (hare && hare.next) {\n    tortoise = tortoise.next;        // Move tortoise one step\n    hare = hare.next.next;           // Move hare two steps\n\n    if (tortoise === hare) return true; // Cycle detected\n  }\n\n  return false; // No cycle\n}\n\n// Example usage:\nconst node3 = new ListNode(3);\nconst node2 = new ListNode(2, node3);\nconst node1 = new ListNode(1, node2);\nnode3.next = node1; // Creates a cycle: 1 -> 2 -> 3 -> 1\n\nconsole.log(hasCycle(node1)); // Output: true\n"})}),"\n",(0,i.jsx)(n.h3,{id:"duplicate-element",children:"Duplicate Element"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/find-the-duplicate-numbe",children:"Find the Duplicate Number"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-JavaScript",children:"/**\n * @param {number[]} nums\n * @return {number}\n */\nconst findDuplicate = (nums) => {\n  // Step 1: Finding the intersection point\n  let tortoise = nums[0];\n  let hare = nums[0];\n\n  do {\n    tortoise = nums[tortoise]; // Move tortoise by one step\n    hare = nums[nums[hare]];    // Move hare by two steps\n  } while (tortoise !== hare);\n\n  // Step 2: Finding the entry point of the cycle\n  tortoise = nums[0];\n  while (tortoise !== hare) {\n    tortoise = nums[tortoise];\n    hare = nums[hare];\n  }\n\n  return tortoise; // This is the duplicate number\n};\nconst nums = [1,3,4,2,2]\nfindDuplicate(nums) //2\n"})}),"\n",(0,i.jsx)(n.h2,{id:"break-a-cycle-in-linkedlist",children:"Break a Cycle in Linkedlist"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-JavaScript",children:"function breakCycle(head) {\n  let s = head\n  let f = head\n\n  //Find Cycle\n  while (f && f.next) {\n    s = s.next\n    f = f.next.next\n    if (s === f) break\n  }\n\n  if (!f || !f.next) return\n\n  //Start Node\n  s = head\n  while (f !== s) {\n    s = s.next\n    f = f.next\n  }\n\n  //Prev node\n\n  while (f.next !== s) {\n    f = f.next\n  }\n\n  f.next = null\n\n  return head\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"linkedlist-cycle-length",children:"Linkedlist Cycle length"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-JavaScript",children:"function cycleLength(head) {\n  let slow = head, fast = head;\n\n  // Step 1: Detect Cycle\n  while (fast && fast.next) {\n    slow = slow.next;\n    fast = fast.next.next;\n\n    if (slow === fast) { // Cycle detected\n      let count = 1;\n      let current = slow.next;\n\n      // Step 2: Count the number of nodes in the cycle\n      while (current !== slow) {\n        count++;\n        current = current.next;\n      }\n\n      return count;\n    }\n  }\n\n  return 0; // No cycle\n}\n"})})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>c});var i=t(96540);const l={},s=i.createContext(l);function r(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:r(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);