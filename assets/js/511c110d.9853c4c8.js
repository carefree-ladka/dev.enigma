"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[2156],{28453:(n,e,t)=>{t.d(e,{R:()=>r,x:()=>l});var i=t(96540);const a={},s=i.createContext(a);function r(n){const e=i.useContext(s);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:r(n.components),i.createElement(s.Provider,{value:e},n.children)}},71664:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>r,default:()=>m,frontMatter:()=>s,metadata:()=>l,toc:()=>u});var i=t(74848),a=t(28453);const s={},r="Knapsack Problems",l={id:"DSA/DSA with Java/Knapsack Patterns",title:"Knapsack Problems",description:"Table of Contents",source:"@site/docs/DSA/DSA with Java/Knapsack Patterns.mdx",sourceDirName:"DSA/DSA with Java",slug:"/DSA/DSA with Java/Knapsack Patterns",permalink:"/dev.enigma/docs/DSA/DSA with Java/Knapsack Patterns",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with Java/Knapsack Patterns.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Java DSA Fundamentals",permalink:"/dev.enigma/docs/DSA/DSA with Java/Java DSA Fundamentals"},next:{title:"LinkedList",permalink:"/dev.enigma/docs/DSA/DSA with Java/LinkedList Patterns"}},c={},u=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Knapsack Fundamentals",id:"knapsack-fundamentals",level:2},{value:"Core Knapsack Concepts",id:"core-knapsack-concepts",level:3},{value:"Common Knapsack Templates",id:"common-knapsack-templates",level:3},{value:"Pattern 1: 0/1 Knapsack",id:"pattern-1-01-knapsack",level:2},{value:"1.1 Classic 0/1 Knapsack",id:"11-classic-01-knapsack",level:3},{value:"1.2 0/1 Knapsack Variations",id:"12-01-knapsack-variations",level:3},{value:"Pattern 2: Unbounded Knapsack",id:"pattern-2-unbounded-knapsack",level:2},{value:"2.1 Classic Unbounded Knapsack",id:"21-classic-unbounded-knapsack",level:3},{value:"2.2 Unbounded Knapsack Applications",id:"22-unbounded-knapsack-applications",level:3},{value:"Pattern 3: Bounded Knapsack",id:"pattern-3-bounded-knapsack",level:2},{value:"3.1 Bounded Knapsack Implementation",id:"31-bounded-knapsack-implementation",level:3},{value:"3.2 Multiple Knapsack Problem",id:"32-multiple-knapsack-problem",level:3},{value:"Pattern 4: Multi-Dimensional Knapsack",id:"pattern-4-multi-dimensional-knapsack",level:2},{value:"4.1 Two-Dimensional Knapsack",id:"41-two-dimensional-knapsack",level:3},{value:"4.2 Multi-Constraint Knapsack",id:"42-multi-constraint-knapsack",level:3},{value:"Pattern 5: Subset Sum Problems",id:"pattern-5-subset-sum-problems",level:2},{value:"5.1 Basic Subset Sum",id:"51-basic-subset-sum",level:3},{value:"5.2 Subset Sum Variations",id:"52-subset-sum-variations",level:3},{value:"Pattern 6: Partition Problems",id:"pattern-6-partition-problems",level:2},{value:"6.1 Equal Partition Problems",id:"61-equal-partition-problems",level:3},{value:"Pattern 7: Target Sum Problems",id:"pattern-7-target-sum-problems",level:2},{value:"7.1 Target Sum with +/- Operations",id:"71-target-sum-with---operations",level:3},{value:"Pattern 8: Coin Change Problems",id:"pattern-8-coin-change-problems",level:2},{value:"8.1 Classic Coin Change",id:"81-classic-coin-change",level:3},{value:"8.2 Advanced Coin Problems",id:"82-advanced-coin-problems",level:3},{value:"Pattern 9: Maximum/Minimum Knapsack",id:"pattern-9-maximumminimum-knapsack",level:2},{value:"9.1 Minimum Weight Knapsack",id:"91-minimum-weight-knapsack",level:3},{value:"Pattern 10: Fractional Knapsack",id:"pattern-10-fractional-knapsack",level:2},{value:"10.1 Fractional Knapsack (Greedy)",id:"101-fractional-knapsack-greedy",level:3},{value:"Pattern 11: Advanced Knapsack Variations",id:"pattern-11-advanced-knapsack-variations",level:2},{value:"11.1 Knapsack with Dependencies",id:"111-knapsack-with-dependencies",level:3},{value:"11.2 Stochastic Knapsack",id:"112-stochastic-knapsack",level:3},{value:"Pattern 12: Real-World Knapsack Applications",id:"pattern-12-real-world-knapsack-applications",level:2},{value:"12.1 Resource Allocation",id:"121-resource-allocation",level:3},{value:"12.2 Investment Portfolio",id:"122-investment-portfolio",level:3},{value:"Time &amp; Space Complexity Reference",id:"time--space-complexity-reference",level:2},{value:"Best Practices &amp; Optimization Tips",id:"best-practices--optimization-tips",level:2},{value:"Knapsack Algorithm Guidelines",id:"knapsack-algorithm-guidelines",level:3},{value:"Common Pitfalls to Avoid",id:"common-pitfalls-to-avoid",level:3},{value:"Interview Tips",id:"interview-tips",level:3}];function o(n){const e={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"knapsack-problems",children:"Knapsack Problems"})}),"\n",(0,i.jsx)(e.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#knapsack-fundamentals",children:"Knapsack Fundamentals"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#pattern-1-01-knapsack",children:"Pattern 1: 0/1 Knapsack"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#pattern-2-unbounded-knapsack",children:"Pattern 2: Unbounded Knapsack"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#pattern-3-bounded-knapsack",children:"Pattern 3: Bounded Knapsack"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#pattern-4-multi-dimensional-knapsack",children:"Pattern 4: Multi-Dimensional Knapsack"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#pattern-5-subset-sum-problems",children:"Pattern 5: Subset Sum Problems"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#pattern-6-partition-problems",children:"Pattern 6: Partition Problems"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#pattern-7-target-sum-problems",children:"Pattern 7: Target Sum Problems"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#pattern-8-coin-change-problems",children:"Pattern 8: Coin Change Problems"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#pattern-9-maximumminimum-knapsack",children:"Pattern 9: Maximum/Minimum Knapsack"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#pattern-10-fractional-knapsack",children:"Pattern 10: Fractional Knapsack"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#pattern-11-advanced-knapsack-variations",children:"Pattern 11: Advanced Knapsack Variations"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#pattern-12-real-world-knapsack-applications",children:"Pattern 12: Real-World Knapsack Applications"})}),"\n"]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"knapsack-fundamentals",children:"Knapsack Fundamentals"}),"\n",(0,i.jsx)(e.h3,{id:"core-knapsack-concepts",children:"Core Knapsack Concepts"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'// Basic Knapsack Problem Types\nenum KnapsackType {\n    ZERO_ONE,           // Each item can be taken at most once\n    UNBOUNDED,          // Unlimited quantity of each item\n    BOUNDED,            // Limited quantity of each item\n    FRACTIONAL,         // Items can be broken into fractions\n    MULTI_DIMENSIONAL   // Multiple constraints (weight, volume, etc.)\n}\n\n// Item representation for knapsack problems\nclass Item {\n    int weight;\n    int value;\n    int quantity; // For bounded knapsack\n    String name;  // Optional identifier\n\n    public Item(int weight, int value) {\n        this.weight = weight;\n        this.value = value;\n        this.quantity = 1; // Default for 0/1 knapsack\n    }\n\n    public Item(int weight, int value, int quantity) {\n        this.weight = weight;\n        this.value = value;\n        this.quantity = quantity;\n    }\n\n    public double getValueToWeightRatio() {\n        return (double) value / weight;\n    }\n\n    @Override\n    public String toString() {\n        return String.format("Item{weight=%d, value=%d, quantity=%d}",\n                           weight, value, quantity);\n    }\n}\n\n// Knapsack result with solution details\nclass KnapsackResult {\n    int maxValue;\n    int totalWeight;\n    List<Item> selectedItems;\n    boolean[][] dpTable; // For analysis\n\n    public KnapsackResult(int maxValue, int totalWeight) {\n        this.maxValue = maxValue;\n        this.totalWeight = totalWeight;\n        this.selectedItems = new ArrayList<>();\n    }\n\n    public void addItem(Item item) {\n        selectedItems.add(item);\n    }\n\n    @Override\n    public String toString() {\n        return String.format("KnapsackResult{maxValue=%d, totalWeight=%d, items=%d}",\n                           maxValue, totalWeight, selectedItems.size());\n    }\n}\n\n// Base Knapsack Solver Interface\ninterface KnapsackSolver {\n    KnapsackResult solve(List<Item> items, int capacity);\n    int getMaxValue(List<Item> items, int capacity);\n    List<Item> getOptimalItems(List<Item> items, int capacity);\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"common-knapsack-templates",children:"Common Knapsack Templates"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Template for DP-based Knapsack Solutions\nabstract class KnapsackDPTemplate implements KnapsackSolver {\n\n    // Template method for solving knapsack\n    public final KnapsackResult solve(List<Item> items, int capacity) {\n        if (items.isEmpty() || capacity <= 0) {\n            return new KnapsackResult(0, 0);\n        }\n\n        // Initialize DP table\n        int[][] dp = initializeDPTable(items.size(), capacity);\n\n        // Fill DP table using specific strategy\n        fillDPTable(items, dp, capacity);\n\n        // Extract solution\n        int maxValue = dp[items.size()][capacity];\n        List<Item> selectedItems = backtrackSolution(items, dp, capacity);\n\n        KnapsackResult result = new KnapsackResult(maxValue, calculateWeight(selectedItems));\n        selectedItems.forEach(result::addItem);\n        result.dpTable = dp;\n\n        return result;\n    }\n\n    // Abstract methods to be implemented by specific knapsack types\n    protected abstract int[][] initializeDPTable(int itemCount, int capacity);\n    protected abstract void fillDPTable(List<Item> items, int[][] dp, int capacity);\n    protected abstract List<Item> backtrackSolution(List<Item> items, int[][] dp, int capacity);\n\n    protected int calculateWeight(List<Item> items) {\n        return items.stream().mapToInt(item -> item.weight).sum();\n    }\n\n    @Override\n    public int getMaxValue(List<Item> items, int capacity) {\n        return solve(items, capacity).maxValue;\n    }\n\n    @Override\n    public List<Item> getOptimalItems(List<Item> items, int capacity) {\n        return solve(items, capacity).selectedItems;\n    }\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"pattern-1-01-knapsack",children:"Pattern 1: 0/1 Knapsack"}),"\n",(0,i.jsx)(e.h3,{id:"11-classic-01-knapsack",children:"1.1 Classic 0/1 Knapsack"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// 0/1 Knapsack - Each item can be taken at most once\npublic class ZeroOneKnapsack extends KnapsackDPTemplate {\n\n    // Recursive solution with memoization\n    public int knapsackRecursive(int[] weights, int[] values, int capacity) {\n        int n = weights.length;\n        Integer[][] memo = new Integer[n][capacity + 1];\n        return knapsackHelper(weights, values, n - 1, capacity, memo);\n    }\n\n    private int knapsackHelper(int[] weights, int[] values, int index, int capacity,\n                              Integer[][] memo) {\n        // Base case\n        if (index < 0 || capacity <= 0) return 0;\n\n        // Check memoization\n        if (memo[index][capacity] != null) {\n            return memo[index][capacity];\n        }\n\n        // If current item's weight is more than capacity, skip it\n        if (weights[index] > capacity) {\n            memo[index][capacity] = knapsackHelper(weights, values, index - 1, capacity, memo);\n        } else {\n            // Max of including or excluding current item\n            int include = values[index] + knapsackHelper(weights, values, index - 1,\n                                                        capacity - weights[index], memo);\n            int exclude = knapsackHelper(weights, values, index - 1, capacity, memo);\n            memo[index][capacity] = Math.max(include, exclude);\n        }\n\n        return memo[index][capacity];\n    }\n\n    // Bottom-up DP solution\n    public int knapsackDP(int[] weights, int[] values, int capacity) {\n        int n = weights.length;\n        int[][] dp = new int[n + 1][capacity + 1];\n\n        // Fill DP table\n        for (int i = 1; i <= n; i++) {\n            for (int w = 1; w <= capacity; w++) {\n                // Don't include current item\n                dp[i][w] = dp[i - 1][w];\n\n                // Include current item if it fits\n                if (weights[i - 1] <= w) {\n                    dp[i][w] = Math.max(dp[i][w],\n                                       dp[i - 1][w - weights[i - 1]] + values[i - 1]);\n                }\n            }\n        }\n\n        return dp[n][capacity];\n    }\n\n    // Space optimized version - O(capacity) space\n    public int knapsackOptimized(int[] weights, int[] values, int capacity) {\n        int[] dp = new int[capacity + 1];\n\n        for (int i = 0; i < weights.length; i++) {\n            // Traverse backwards to avoid using updated values\n            for (int w = capacity; w >= weights[i]; w--) {\n                dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]);\n            }\n        }\n\n        return dp[capacity];\n    }\n\n    // Get actual items selected\n    public List<Integer> getSelectedItems(int[] weights, int[] values, int capacity) {\n        int n = weights.length;\n        int[][] dp = new int[n + 1][capacity + 1];\n\n        // Fill DP table\n        for (int i = 1; i <= n; i++) {\n            for (int w = 1; w <= capacity; w++) {\n                dp[i][w] = dp[i - 1][w];\n                if (weights[i - 1] <= w) {\n                    dp[i][w] = Math.max(dp[i][w],\n                                       dp[i - 1][w - weights[i - 1]] + values[i - 1]);\n                }\n            }\n        }\n\n        // Backtrack to find selected items\n        List<Integer> selectedItems = new ArrayList<>();\n        int i = n, w = capacity;\n\n        while (i > 0 && w > 0) {\n            // If value comes from including current item\n            if (dp[i][w] != dp[i - 1][w]) {\n                selectedItems.add(i - 1); // Add item index\n                w -= weights[i - 1];\n            }\n            i--;\n        }\n\n        Collections.reverse(selectedItems);\n        return selectedItems;\n    }\n\n    @Override\n    protected int[][] initializeDPTable(int itemCount, int capacity) {\n        return new int[itemCount + 1][capacity + 1];\n    }\n\n    @Override\n    protected void fillDPTable(List<Item> items, int[][] dp, int capacity) {\n        int n = items.size();\n\n        for (int i = 1; i <= n; i++) {\n            Item item = items.get(i - 1);\n            for (int w = 1; w <= capacity; w++) {\n                dp[i][w] = dp[i - 1][w]; // Don't take item\n\n                if (item.weight <= w) {\n                    dp[i][w] = Math.max(dp[i][w],\n                                       dp[i - 1][w - item.weight] + item.value);\n                }\n            }\n        }\n    }\n\n    @Override\n    protected List<Item> backtrackSolution(List<Item> items, int[][] dp, int capacity) {\n        List<Item> selected = new ArrayList<>();\n        int i = items.size(), w = capacity;\n\n        while (i > 0 && w > 0) {\n            if (dp[i][w] != dp[i - 1][w]) {\n                selected.add(items.get(i - 1));\n                w -= items.get(i - 1).weight;\n            }\n            i--;\n        }\n\n        Collections.reverse(selected);\n        return selected;\n    }\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"12-01-knapsack-variations",children:"1.2 0/1 Knapsack Variations"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// 0/1 Knapsack with exact weight constraint\npublic int knapsackExactWeight(int[] weights, int[] values, int targetWeight) {\n    int n = weights.length;\n    int[][] dp = new int[n + 1][targetWeight + 1];\n\n    // Initialize: impossible to achieve positive weight with 0 items\n    for (int w = 1; w <= targetWeight; w++) {\n        dp[0][w] = Integer.MIN_VALUE;\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (int w = 1; w <= targetWeight; w++) {\n            dp[i][w] = dp[i - 1][w]; // Don't take item\n\n            if (weights[i - 1] <= w && dp[i - 1][w - weights[i - 1]] != Integer.MIN_VALUE) {\n                dp[i][w] = Math.max(dp[i][w],\n                                   dp[i - 1][w - weights[i - 1]] + values[i - 1]);\n            }\n        }\n    }\n\n    return dp[n][targetWeight] == Integer.MIN_VALUE ? -1 : dp[n][targetWeight];\n}\n\n// 0/1 Knapsack with minimum items constraint\npublic int knapsackMinItems(int[] weights, int[] values, int capacity, int minItems) {\n    int n = weights.length;\n    // dp[i][w][k] = max value using first i items, weight w, exactly k items\n    int[][][] dp = new int[n + 1][capacity + 1][minItems + 1];\n\n    // Initialize with negative infinity (impossible states)\n    for (int i = 0; i <= n; i++) {\n        for (int w = 0; w <= capacity; w++) {\n            for (int k = 1; k <= minItems; k++) {\n                dp[i][w][k] = Integer.MIN_VALUE;\n            }\n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (int w = 0; w <= capacity; w++) {\n            for (int k = 0; k <= minItems; k++) {\n                // Don't take current item\n                dp[i][w][k] = dp[i - 1][w][k];\n\n                // Take current item\n                if (weights[i - 1] <= w && k > 0 &&\n                    dp[i - 1][w - weights[i - 1]][k - 1] != Integer.MIN_VALUE) {\n                    dp[i][w][k] = Math.max(dp[i][w][k],\n                        dp[i - 1][w - weights[i - 1]][k - 1] + values[i - 1]);\n                }\n            }\n        }\n    }\n\n    int maxValue = Integer.MIN_VALUE;\n    for (int k = minItems; k <= Math.min(minItems, n); k++) {\n        maxValue = Math.max(maxValue, dp[n][capacity][k]);\n    }\n\n    return maxValue == Integer.MIN_VALUE ? -1 : maxValue;\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"pattern-2-unbounded-knapsack",children:"Pattern 2: Unbounded Knapsack"}),"\n",(0,i.jsx)(e.h3,{id:"21-classic-unbounded-knapsack",children:"2.1 Classic Unbounded Knapsack"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Unbounded Knapsack - Unlimited quantity of each item\npublic class UnboundedKnapsack implements KnapsackSolver {\n\n    // Basic unbounded knapsack\n    public int unboundedKnapsack(int[] weights, int[] values, int capacity) {\n        int[] dp = new int[capacity + 1];\n\n        // For each capacity\n        for (int w = 1; w <= capacity; w++) {\n            // Try each item\n            for (int i = 0; i < weights.length; i++) {\n                if (weights[i] <= w) {\n                    dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]);\n                }\n            }\n        }\n\n        return dp[capacity];\n    }\n\n    // Alternative approach - process items first\n    public int unboundedKnapsackAlt(int[] weights, int[] values, int capacity) {\n        int[] dp = new int[capacity + 1];\n\n        // For each item\n        for (int i = 0; i < weights.length; i++) {\n            // For each capacity where item can fit\n            for (int w = weights[i]; w <= capacity; w++) {\n                dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]);\n            }\n        }\n\n        return dp[capacity];\n    }\n\n    // Get items used in optimal solution\n    public List<Integer> getItemsUsed(int[] weights, int[] values, int capacity) {\n        int[] dp = new int[capacity + 1];\n        int[] lastItem = new int[capacity + 1]; // Track last item used\n\n        for (int w = 1; w <= capacity; w++) {\n            for (int i = 0; i < weights.length; i++) {\n                if (weights[i] <= w && dp[w - weights[i]] + values[i] > dp[w]) {\n                    dp[w] = dp[w - weights[i]] + values[i];\n                    lastItem[w] = i;\n                }\n            }\n        }\n\n        // Reconstruct solution\n        List<Integer> items = new ArrayList<>();\n        int remainingCapacity = capacity;\n\n        while (remainingCapacity > 0 && dp[remainingCapacity] > 0) {\n            int itemIndex = lastItem[remainingCapacity];\n            items.add(itemIndex);\n            remainingCapacity -= weights[itemIndex];\n        }\n\n        return items;\n    }\n\n    // Count number of ways to achieve exact capacity\n    public int countWays(int[] weights, int capacity) {\n        int[] dp = new int[capacity + 1];\n        dp[0] = 1; // One way to achieve 0 capacity\n\n        for (int weight : weights) {\n            for (int w = weight; w <= capacity; w++) {\n                dp[w] += dp[w - weight];\n            }\n        }\n\n        return dp[capacity];\n    }\n\n    @Override\n    public KnapsackResult solve(List<Item> items, int capacity) {\n        int[] weights = items.stream().mapToInt(item -> item.weight).toArray();\n        int[] values = items.stream().mapToInt(item -> item.value).toArray();\n\n        int maxValue = unboundedKnapsack(weights, values, capacity);\n        List<Integer> itemIndices = getItemsUsed(weights, values, capacity);\n\n        KnapsackResult result = new KnapsackResult(maxValue, 0);\n        for (int index : itemIndices) {\n            result.addItem(items.get(index));\n        }\n\n        return result;\n    }\n\n    @Override\n    public int getMaxValue(List<Item> items, int capacity) {\n        int[] weights = items.stream().mapToInt(item -> item.weight).toArray();\n        int[] values = items.stream().mapToInt(item -> item.value).toArray();\n        return unboundedKnapsack(weights, values, capacity);\n    }\n\n    @Override\n    public List<Item> getOptimalItems(List<Item> items, int capacity) {\n        return solve(items, capacity).selectedItems;\n    }\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"22-unbounded-knapsack-applications",children:"2.2 Unbounded Knapsack Applications"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Rod Cutting Problem (Special case of unbounded knapsack)\npublic int cutRod(int[] prices) {\n    int n = prices.length;\n    int[] dp = new int[n + 1];\n\n    for (int length = 1; length <= n; length++) {\n        for (int cut = 1; cut <= length; cut++) {\n            dp[length] = Math.max(dp[length], prices[cut - 1] + dp[length - cut]);\n        }\n    }\n\n    return dp[n];\n}\n\n// Rod Cutting with cuts information\npublic List<Integer> cutRodWithCuts(int[] prices) {\n    int n = prices.length;\n    int[] dp = new int[n + 1];\n    int[] cuts = new int[n + 1]; // Store first cut made\n\n    for (int length = 1; length <= n; length++) {\n        for (int cut = 1; cut <= length; cut++) {\n            if (prices[cut - 1] + dp[length - cut] > dp[length]) {\n                dp[length] = prices[cut - 1] + dp[length - cut];\n                cuts[length] = cut;\n            }\n        }\n    }\n\n    // Reconstruct cuts\n    List<Integer> result = new ArrayList<>();\n    int remainingLength = n;\n\n    while (remainingLength > 0) {\n        int cut = cuts[remainingLength];\n        result.add(cut);\n        remainingLength -= cut;\n    }\n\n    return result;\n}\n\n// Maximum Ribbon Cut Problem\npublic int maxRibbonCut(int n, int[] cuts) {\n    int[] dp = new int[n + 1];\n    Arrays.fill(dp, -1);\n    dp[0] = 0;\n\n    for (int length = 1; length <= n; length++) {\n        for (int cut : cuts) {\n            if (cut <= length && dp[length - cut] != -1) {\n                dp[length] = Math.max(dp[length], dp[length - cut] + 1);\n            }\n        }\n    }\n\n    return dp[n];\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"pattern-3-bounded-knapsack",children:"Pattern 3: Bounded Knapsack"}),"\n",(0,i.jsx)(e.h3,{id:"31-bounded-knapsack-implementation",children:"3.1 Bounded Knapsack Implementation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Bounded Knapsack - Limited quantity of each item\npublic class BoundedKnapsack implements KnapsackSolver {\n\n    // Basic bounded knapsack using 3D DP\n    public int boundedKnapsack(int[] weights, int[] values, int[] quantities, int capacity) {\n        int n = weights.length;\n        int[][][] dp = new int[n + 1][capacity + 1][getMaxQuantity(quantities) + 1];\n\n        for (int i = 1; i <= n; i++) {\n            for (int w = 1; w <= capacity; w++) {\n                for (int q = 0; q <= quantities[i - 1]; q++) {\n                    // Don't take any of current item\n                    dp[i][w][q] = dp[i - 1][w][0];\n\n                    // Take some quantity of current item\n                    for (int take = 1; take <= Math.min(q, w / weights[i - 1]); take++) {\n                        if (weights[i - 1] * take <= w) {\n                            dp[i][w][q] = Math.max(dp[i][w][q],\n                                dp[i - 1][w - weights[i - 1] * take][0] + values[i - 1] * take);\n                        }\n                    }\n                }\n            }\n        }\n\n        return dp[n][capacity][0];\n    }\n\n    // Optimized bounded knapsack - convert to 0/1 knapsack\n    public int boundedKnapsackOptimized(int[] weights, int[] values, int[] quantities, int capacity) {\n        List<Integer> expandedWeights = new ArrayList<>();\n        List<Integer> expandedValues = new ArrayList<>();\n\n        // Expand each item according to its quantity using binary representation\n        for (int i = 0; i < weights.length; i++) {\n            int remaining = quantities[i];\n            int multiplier = 1;\n\n            while (remaining > 0) {\n                int take = Math.min(remaining, multiplier);\n                expandedWeights.add(weights[i] * take);\n                expandedValues.add(values[i] * take);\n\n                remaining -= take;\n                multiplier *= 2;\n            }\n        }\n\n        // Apply 0/1 knapsack on expanded items\n        ZeroOneKnapsack solver = new ZeroOneKnapsack();\n        return solver.knapsackDP(\n            expandedWeights.stream().mapToInt(Integer::intValue).toArray(),\n            expandedValues.stream().mapToInt(Integer::intValue).toArray(),\n            capacity\n        );\n    }\n\n    // Space-optimized bounded knapsack\n    public int boundedKnapsackSpaceOptimized(int[] weights, int[] values, int[] quantities, int capacity) {\n        int[] dp = new int[capacity + 1];\n\n        for (int i = 0; i < weights.length; i++) {\n            // Process current item with its quantity limit\n            for (int q = 1; q <= quantities[i]; q++) {\n                for (int w = capacity; w >= weights[i]; w--) {\n                    dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]);\n                }\n            }\n        }\n\n        return dp[capacity];\n    }\n\n    private int getMaxQuantity(int[] quantities) {\n        return Arrays.stream(quantities).max().orElse(0);\n    }\n\n    @Override\n    public KnapsackResult solve(List<Item> items, int capacity) {\n        int[] weights = items.stream().mapToInt(item -> item.weight).toArray();\n        int[] values = items.stream().mapToInt(item -> item.value).toArray();\n        int[] quantities = items.stream().mapToInt(item -> item.quantity).toArray();\n\n        int maxValue = boundedKnapsackOptimized(weights, values, quantities, capacity);\n        return new KnapsackResult(maxValue, 0);\n    }\n\n    @Override\n    public int getMaxValue(List<Item> items, int capacity) {\n        return solve(items, capacity).maxValue;\n    }\n\n    @Override\n    public List<Item> getOptimalItems(List<Item> items, int capacity) {\n        return solve(items, capacity).selectedItems;\n    }\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"32-multiple-knapsack-problem",children:"3.2 Multiple Knapsack Problem"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Multiple Knapsack - Multiple knapsacks with different capacities\npublic class MultipleKnapsack {\n\n    public int multipleKnapsack(int[] weights, int[] values, int[] capacities) {\n        int n = weights.length;\n        int k = capacities.length;\n\n        // dp[i][mask] = maximum value using first i items with knapsack availability mask\n        int[][] dp = new int[n + 1][1 << k];\n        int[][] remainingCapacity = new int[1 << k][k];\n\n        // Initialize remaining capacities for each mask\n        for (int mask = 0; mask < (1 << k); mask++) {\n            for (int j = 0; j < k; j++) {\n                remainingCapacity[mask][j] = capacities[j];\n            }\n        }\n\n        for (int i = 1; i <= n; i++) {\n            for (int mask = 0; mask < (1 << k); mask++) {\n                // Don't take current item\n                dp[i][mask] = dp[i - 1][mask];\n\n                // Try placing current item in each available knapsack\n                for (int j = 0; j < k; j++) {\n                    if (weights[i - 1] <= remainingCapacity[mask][j]) {\n                        int newMask = updateMask(mask, j, weights[i - 1], remainingCapacity);\n                        dp[i][mask] = Math.max(dp[i][mask],\n                                              dp[i - 1][newMask] + values[i - 1]);\n                    }\n                }\n            }\n        }\n\n        return dp[n][(1 << k) - 1]; // All knapsacks used\n    }\n\n    private int updateMask(int mask, int knapsackIndex, int weight, int[][] remainingCapacity) {\n        // This is a simplified version - actual implementation would be more complex\n        return mask;\n    }\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"pattern-4-multi-dimensional-knapsack",children:"Pattern 4: Multi-Dimensional Knapsack"}),"\n",(0,i.jsx)(e.h3,{id:"41-two-dimensional-knapsack",children:"4.1 Two-Dimensional Knapsack"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Two-Dimensional Knapsack (Weight and Volume constraints)\npublic class TwoDimensionalKnapsack {\n\n    public int knapsack2D(int[] weights, int[] volumes, int[] values,\n                         int weightCapacity, int volumeCapacity) {\n        int n = weights.length;\n        int[][][] dp = new int[n + 1][weightCapacity + 1][volumeCapacity + 1];\n\n        for (int i = 1; i <= n; i++) {\n            for (int w = 1; w <= weightCapacity; w++) {\n                for (int v = 1; v <= volumeCapacity; v++) {\n                    // Don't take current item\n                    dp[i][w][v] = dp[i - 1][w][v];\n\n                    // Take current item if both constraints satisfied\n                    if (weights[i - 1] <= w && volumes[i - 1] <= v) {\n                        dp[i][w][v] = Math.max(dp[i][w][v],\n                            dp[i - 1][w - weights[i - 1]][v - volumes[i - 1]] + values[i - 1]);\n                    }\n                }\n            }\n        }\n\n        return dp[n][weightCapacity][volumeCapacity];\n    }\n\n    // Space-optimized version\n    public int knapsack2DOptimized(int[] weights, int[] volumes, int[] values,\n                                  int weightCapacity, int volumeCapacity) {\n        int[][] dp = new int[weightCapacity + 1][volumeCapacity + 1];\n\n        for (int i = 0; i < weights.length; i++) {\n            // Traverse backwards to avoid using updated values\n            for (int w = weightCapacity; w >= weights[i]; w--) {\n                for (int v = volumeCapacity; v >= volumes[i]; v--) {\n                    dp[w][v] = Math.max(dp[w][v], dp[w - weights[i]][v - volumes[i]] + values[i]);\n                }\n            }\n        }\n\n        return dp[weightCapacity][volumeCapacity];\n    }\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"42-multi-constraint-knapsack",children:"4.2 Multi-Constraint Knapsack"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'// General Multi-Dimensional Knapsack\npublic class MultiDimensionalKnapsack {\n\n    // Multi-dimensional item\n    static class MultiItem {\n        int value;\n        int[] constraints; // Multiple constraint values (weight, volume, cost, etc.)\n\n        MultiItem(int value, int[] constraints) {\n            this.value = value;\n            this.constraints = constraints.clone();\n        }\n    }\n\n    public int multiDimensionalKnapsack(List<MultiItem> items, int[] capacities) {\n        int n = items.size();\n        int dimensions = capacities.length;\n\n        // Use map to store DP states (too many dimensions for array)\n        Map<String, Integer> dp = new HashMap<>();\n\n        return solve(items, 0, capacities, dp);\n    }\n\n    private int solve(List<MultiItem> items, int index, int[] remainingCapacities,\n                     Map<String, Integer> dp) {\n        if (index >= items.size()) return 0;\n\n        String key = index + ":" + Arrays.toString(remainingCapacities);\n        if (dp.containsKey(key)) return dp.get(key);\n\n        // Don\'t take current item\n        int maxValue = solve(items, index + 1, remainingCapacities, dp);\n\n        // Take current item if all constraints satisfied\n        MultiItem item = items.get(index);\n        boolean canTake = true;\n\n        for (int i = 0; i < remainingCapacities.length; i++) {\n            if (item.constraints[i] > remainingCapacities[i]) {\n                canTake = false;\n                break;\n            }\n        }\n\n        if (canTake) {\n            int[] newCapacities = new int[remainingCapacities.length];\n            for (int i = 0; i < remainingCapacities.length; i++) {\n                newCapacities[i] = remainingCapacities[i] - item.constraints[i];\n            }\n\n            maxValue = Math.max(maxValue,\n                item.value + solve(items, index + 1, newCapacities, dp));\n        }\n\n        dp.put(key, maxValue);\n        return maxValue;\n    }\n}\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"pattern-5-subset-sum-problems",children:"Pattern 5: Subset Sum Problems"}),"\n",(0,i.jsx)(e.h3,{id:"51-basic-subset-sum",children:"5.1 Basic Subset Sum"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Subset Sum Problem - Check if subset with given sum exists\npublic class SubsetSum {\n\n    public boolean canPartition(int[] nums, int targetSum) {\n        boolean[] dp = new boolean[targetSum + 1];\n        dp[0] = true; // Empty subset has sum 0\n\n        for (int num : nums) {\n            // Traverse backwards to avoid using updated values\n            for (int sum = targetSum; sum >= num; sum--) {\n                dp[sum] = dp[sum] || dp[sum - num];\n            }\n        }\n\n        return dp[targetSum];\n    }\n\n    // Count number of subsets with given sum\n    public int countSubsets(int[] nums, int targetSum) {\n        int[] dp = new int[targetSum + 1];\n        dp[0] = 1; // One way to make sum 0 (empty subset)\n\n        for (int num : nums) {\n            for (int sum = targetSum; sum >= num; sum--) {\n                dp[sum] += dp[sum - num];\n            }\n        }\n\n        return dp[targetSum];\n    }\n\n    // Find one subset with target sum\n    public List<Integer> findSubset(int[] nums, int targetSum) {\n        boolean[][] dp = new boolean[nums.length + 1][targetSum + 1];\n\n        // Base case\n        for (int i = 0; i <= nums.length; i++) {\n            dp[i][0] = true;\n        }\n\n        // Fill DP table\n        for (int i = 1; i <= nums.length; i++) {\n            for (int sum = 1; sum <= targetSum; sum++) {\n                dp[i][sum] = dp[i - 1][sum]; // Don't include current number\n\n                if (nums[i - 1] <= sum) {\n                    dp[i][sum] = dp[i][sum] || dp[i - 1][sum - nums[i - 1]];\n                }\n            }\n        }\n\n        if (!dp[nums.length][targetSum]) {\n            return new ArrayList<>(); // No subset found\n        }\n\n        // Backtrack to find one subset\n        List<Integer> subset = new ArrayList<>();\n        int i = nums.length, sum = targetSum;\n\n        while (i > 0 && sum > 0) {\n            // If value came from including current element\n            if (dp[i][sum] && !dp[i - 1][sum]) {\n                subset.add(nums[i - 1]);\n                sum -= nums[i - 1];\n            }\n            i--;\n        }\n\n        return subset;\n    }\n\n    // Find all subsets with target sum\n    public List<List<Integer>> findAllSubsets(int[] nums, int targetSum) {\n        List<List<Integer>> result = new ArrayList<>();\n        List<Integer> currentSubset = new ArrayList<>();\n        findAllSubsetsHelper(nums, 0, targetSum, currentSubset, result);\n        return result;\n    }\n\n    private void findAllSubsetsHelper(int[] nums, int index, int remainingSum,\n                                     List<Integer> currentSubset, List<List<Integer>> result) {\n        if (remainingSum == 0) {\n            result.add(new ArrayList<>(currentSubset));\n            return;\n        }\n\n        if (index >= nums.length || remainingSum < 0) {\n            return;\n        }\n\n        // Include current number\n        currentSubset.add(nums[index]);\n        findAllSubsetsHelper(nums, index + 1, remainingSum - nums[index], currentSubset, result);\n        currentSubset.remove(currentSubset.size() - 1);\n\n        // Exclude current number\n        findAllSubsetsHelper(nums, index + 1, remainingSum, currentSubset, result);\n    }\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"52-subset-sum-variations",children:"5.2 Subset Sum Variations"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Minimum Subset Sum Difference\npublic int minimumSubsetSumDifference(int[] nums) {\n    int totalSum = Arrays.stream(nums).sum();\n    boolean[] dp = new boolean[totalSum / 2 + 1];\n    dp[0] = true;\n\n    for (int num : nums) {\n        for (int sum = totalSum / 2; sum >= num; sum--) {\n            dp[sum] = dp[sum] || dp[sum - num];\n        }\n    }\n\n    // Find the largest sum <= totalSum/2 that can be achieved\n    int sum1 = 0;\n    for (int i = totalSum / 2; i >= 0; i--) {\n        if (dp[i]) {\n            sum1 = i;\n            break;\n        }\n    }\n\n    int sum2 = totalSum - sum1;\n    return Math.abs(sum2 - sum1);\n}\n\n// Count Subsets with Given Difference\npublic int countSubsetsWithDifference(int[] nums, int diff) {\n    int totalSum = Arrays.stream(nums).sum();\n\n    // If (totalSum + diff) is odd or diff > totalSum, no solution\n    if ((totalSum + diff) % 2 != 0 || diff > totalSum) {\n        return 0;\n    }\n\n    int target = (totalSum + diff) / 2;\n    return countSubsets(nums, target);\n}\n\n// Perfect Sum Problem (with zeros)\npublic int perfectSum(int[] nums, int targetSum) {\n    int MOD = 1000000007;\n    int[] dp = new int[targetSum + 1];\n    dp[0] = 1;\n\n    for (int num : nums) {\n        for (int sum = targetSum; sum >= num; sum--) {\n            dp[sum] = (dp[sum] + dp[sum - num]) % MOD;\n        }\n    }\n\n    return dp[targetSum];\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"pattern-6-partition-problems",children:"Pattern 6: Partition Problems"}),"\n",(0,i.jsx)(e.h3,{id:"61-equal-partition-problems",children:"6.1 Equal Partition Problems"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Partition Equal Subset Sum\npublic boolean canPartition(int[] nums) {\n    int totalSum = Arrays.stream(nums).sum();\n\n    // If total sum is odd, can't partition into equal subsets\n    if (totalSum % 2 != 0) return false;\n\n    int target = totalSum / 2;\n    boolean[] dp = new boolean[target + 1];\n    dp[0] = true;\n\n    for (int num : nums) {\n        for (int sum = target; sum >= num; sum--) {\n            dp[sum] = dp[sum] || dp[sum - num];\n        }\n    }\n\n    return dp[target];\n}\n\n// Partition to K Equal Sum Subsets\npublic boolean canPartitionKSubsets(int[] nums, int k) {\n    int totalSum = Arrays.stream(nums).sum();\n\n    if (totalSum % k != 0) return false;\n\n    Arrays.sort(nums);\n    int target = totalSum / k;\n\n    // If largest number > target, impossible\n    if (nums[nums.length - 1] > target) return false;\n\n    boolean[] used = new boolean[nums.length];\n    return backtrack(nums, used, 0, k, 0, target);\n}\n\nprivate boolean backtrack(int[] nums, boolean[] used, int start, int k,\n                         int currentSum, int target) {\n    if (k == 1) return true; // Last subset automatically valid\n\n    if (currentSum == target) {\n        // Found one subset, look for next\n        return backtrack(nums, used, 0, k - 1, 0, target);\n    }\n\n    for (int i = start; i < nums.length; i++) {\n        if (!used[i] && currentSum + nums[i] <= target) {\n            used[i] = true;\n            if (backtrack(nums, used, i + 1, k, currentSum + nums[i], target)) {\n                return true;\n            }\n            used[i] = false;\n        }\n    }\n\n    return false;\n}\n\n// Partition Array into Two Arrays to Minimize Sum Difference\npublic int minimumDifference(int[] nums) {\n    int n = nums.length / 2;\n    int totalSum = Arrays.stream(nums).sum();\n\n    // Generate all possible sums for left and right halves\n    Set<Integer>[] leftSums = new Set[n + 1];\n    Set<Integer>[] rightSums = new Set[n + 1];\n\n    for (int i = 0; i <= n; i++) {\n        leftSums[i] = new HashSet<>();\n        rightSums[i] = new HashSet<>();\n    }\n\n    // Generate sums for left half\n    generateSums(Arrays.copyOfRange(nums, 0, n), 0, 0, 0, leftSums);\n\n    // Generate sums for right half\n    generateSums(Arrays.copyOfRange(nums, n, 2 * n), 0, 0, 0, rightSums);\n\n    int minDiff = Integer.MAX_VALUE;\n\n    // Try all combinations\n    for (int i = 0; i <= n; i++) {\n        for (int leftSum : leftSums[i]) {\n            for (int rightSum : rightSums[n - i]) {\n                int sum1 = leftSum + rightSum;\n                int sum2 = totalSum - sum1;\n                minDiff = Math.min(minDiff, Math.abs(sum1 - sum2));\n            }\n        }\n    }\n\n    return minDiff;\n}\n\nprivate void generateSums(int[] nums, int index, int count, int sum, Set<Integer>[] sums) {\n    if (index == nums.length) {\n        sums[count].add(sum);\n        return;\n    }\n\n    // Include current number\n    generateSums(nums, index + 1, count + 1, sum + nums[index], sums);\n\n    // Exclude current number\n    generateSums(nums, index + 1, count, sum, sums);\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"pattern-7-target-sum-problems",children:"Pattern 7: Target Sum Problems"}),"\n",(0,i.jsx)(e.h3,{id:"71-target-sum-with---operations",children:"7.1 Target Sum with +/- Operations"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'// Target Sum (Assign + or - to each number)\npublic int findTargetSumWays(int[] nums, int target) {\n    int totalSum = Arrays.stream(nums).sum();\n\n    // Check if target is achievable\n    if (target > totalSum || target < -totalSum || (totalSum + target) % 2 != 0) {\n        return 0;\n    }\n\n    // Convert to subset sum problem\n    // If P is positive subset and N is negative subset:\n    // P - N = target\n    // P + N = totalSum\n    // Therefore: P = (totalSum + target) / 2\n\n    int positiveSum = (totalSum + target) / 2;\n    return countSubsets(nums, positiveSum);\n}\n\nprivate int countSubsets(int[] nums, int targetSum) {\n    int[] dp = new int[targetSum + 1];\n    dp[0] = 1; // One way to make sum 0\n\n    for (int num : nums) {\n        for (int sum = targetSum; sum >= num; sum--) {\n            dp[sum] += dp[sum - num];\n        }\n    }\n\n    return dp[targetSum];\n}\n\n// Target Sum with specific operations allowed\npublic int targetSumWithOperations(int[] nums, int target, boolean canAdd,\n                                  boolean canSubtract, boolean canMultiply) {\n    Map<String, Integer> memo = new HashMap<>();\n    return targetSumHelper(nums, 0, target, memo, canAdd, canSubtract, canMultiply);\n}\n\nprivate int targetSumHelper(int[] nums, int index, int target, Map<String, Integer> memo,\n                           boolean canAdd, boolean canSubtract, boolean canMultiply) {\n    if (index == nums.length) {\n        return target == 0 ? 1 : 0;\n    }\n\n    String key = index + "," + target;\n    if (memo.containsKey(key)) {\n        return memo.get(key);\n    }\n\n    int ways = 0;\n\n    if (canAdd) {\n        ways += targetSumHelper(nums, index + 1, target - nums[index], memo,\n                               canAdd, canSubtract, canMultiply);\n    }\n\n    if (canSubtract) {\n        ways += targetSumHelper(nums, index + 1, target + nums[index], memo,\n                               canAdd, canSubtract, canMultiply);\n    }\n\n    if (canMultiply && target % nums[index] == 0) {\n        ways += targetSumHelper(nums, index + 1, target / nums[index], memo,\n                               canAdd, canSubtract, canMultiply);\n    }\n\n    memo.put(key, ways);\n    return ways;\n}\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"pattern-8-coin-change-problems",children:"Pattern 8: Coin Change Problems"}),"\n",(0,i.jsx)(e.h3,{id:"81-classic-coin-change",children:"8.1 Classic Coin Change"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Coin Change - Minimum coins needed\npublic int coinChange(int[] coins, int amount) {\n    int[] dp = new int[amount + 1];\n    Arrays.fill(dp, amount + 1); // Initialize with impossible value\n    dp[0] = 0; // 0 coins needed for amount 0\n\n    for (int i = 1; i <= amount; i++) {\n        for (int coin : coins) {\n            if (coin <= i) {\n                dp[i] = Math.min(dp[i], dp[i - coin] + 1);\n            }\n        }\n    }\n\n    return dp[amount] > amount ? -1 : dp[amount];\n}\n\n// Coin Change II - Number of ways to make amount\npublic int change(int amount, int[] coins) {\n    int[] dp = new int[amount + 1];\n    dp[0] = 1; // One way to make amount 0\n\n    // Process coins one by one to avoid duplicates\n    for (int coin : coins) {\n        for (int i = coin; i <= amount; i++) {\n            dp[i] += dp[i - coin];\n        }\n    }\n\n    return dp[amount];\n}\n\n// Coin Change with coin usage tracking\npublic List<Integer> coinChangeWithCoins(int[] coins, int amount) {\n    int[] dp = new int[amount + 1];\n    int[] coinUsed = new int[amount + 1]; // Track which coin was used\n\n    Arrays.fill(dp, amount + 1);\n    dp[0] = 0;\n\n    for (int i = 1; i <= amount; i++) {\n        for (int coin : coins) {\n            if (coin <= i && dp[i - coin] + 1 < dp[i]) {\n                dp[i] = dp[i - coin] + 1;\n                coinUsed[i] = coin;\n            }\n        }\n    }\n\n    if (dp[amount] > amount) {\n        return new ArrayList<>(); // No solution\n    }\n\n    // Reconstruct solution\n    List<Integer> result = new ArrayList<>();\n    int currentAmount = amount;\n\n    while (currentAmount > 0) {\n        int coin = coinUsed[currentAmount];\n        result.add(coin);\n        currentAmount -= coin;\n    }\n\n    return result;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"82-advanced-coin-problems",children:"8.2 Advanced Coin Problems"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Perfect Squares (Special case of coin change)\npublic int numSquares(int n) {\n    int[] dp = new int[n + 1];\n    Arrays.fill(dp, Integer.MAX_VALUE);\n    dp[0] = 0;\n\n    // Generate perfect squares up to n\n    List<Integer> squares = new ArrayList<>();\n    for (int i = 1; i * i <= n; i++) {\n        squares.add(i * i);\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (int square : squares) {\n            if (square <= i) {\n                dp[i] = Math.min(dp[i], dp[i - square] + 1);\n            }\n        }\n    }\n\n    return dp[n];\n}\n\n// Coin Change with limited coins\npublic int coinChangeWithLimit(int[] coins, int[] limits, int amount) {\n    int[] dp = new int[amount + 1];\n    Arrays.fill(dp, amount + 1);\n    dp[0] = 0;\n\n    for (int i = 0; i < coins.length; i++) {\n        int coin = coins[i];\n        int limit = limits[i];\n\n        // Use multiple knapsack approach for each coin type\n        for (int count = 1; count <= limit; count++) {\n            for (int j = amount; j >= coin; j--) {\n                dp[j] = Math.min(dp[j], dp[j - coin] + 1);\n            }\n        }\n    }\n\n    return dp[amount] > amount ? -1 : dp[amount];\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"pattern-9-maximumminimum-knapsack",children:"Pattern 9: Maximum/Minimum Knapsack"}),"\n",(0,i.jsx)(e.h3,{id:"91-minimum-weight-knapsack",children:"9.1 Minimum Weight Knapsack"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Minimum weight to achieve target value\npublic int minWeightKnapsack(int[] weights, int[] values, int targetValue) {\n    int[] dp = new int[targetValue + 1];\n    Arrays.fill(dp, Integer.MAX_VALUE);\n    dp[0] = 0; // 0 weight needed for 0 value\n\n    for (int i = 0; i < weights.length; i++) {\n        for (int v = targetValue; v >= values[i]; v--) {\n            if (dp[v - values[i]] != Integer.MAX_VALUE) {\n                dp[v] = Math.min(dp[v], dp[v - values[i]] + weights[i]);\n            }\n        }\n    }\n\n    return dp[targetValue] == Integer.MAX_VALUE ? -1 : dp[targetValue];\n}\n\n// Maximum value with weight constraint\npublic int maxValueWithMinWeight(int[] weights, int[] values, int maxWeight) {\n    int[] dp = new int[maxWeight + 1];\n\n    for (int i = 0; i < weights.length; i++) {\n        for (int w = maxWeight; w >= weights[i]; w--) {\n            dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]);\n        }\n    }\n\n    return dp[maxWeight];\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"pattern-10-fractional-knapsack",children:"Pattern 10: Fractional Knapsack"}),"\n",(0,i.jsx)(e.h3,{id:"101-fractional-knapsack-greedy",children:"10.1 Fractional Knapsack (Greedy)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'// Fractional Knapsack - Items can be broken\npublic class FractionalKnapsack {\n\n    static class FractionalItem {\n        int weight;\n        int value;\n        double ratio;\n\n        FractionalItem(int weight, int value) {\n            this.weight = weight;\n            this.value = value;\n            this.ratio = (double) value / weight;\n        }\n    }\n\n    public double fractionalKnapsack(int[] weights, int[] values, int capacity) {\n        List<FractionalItem> items = new ArrayList<>();\n\n        for (int i = 0; i < weights.length; i++) {\n            items.add(new FractionalItem(weights[i], values[i]));\n        }\n\n        // Sort by value-to-weight ratio in descending order\n        items.sort((a, b) -> Double.compare(b.ratio, a.ratio));\n\n        double totalValue = 0;\n        int remainingCapacity = capacity;\n\n        for (FractionalItem item : items) {\n            if (remainingCapacity >= item.weight) {\n                // Take the whole item\n                totalValue += item.value;\n                remainingCapacity -= item.weight;\n            } else {\n                // Take fraction of the item\n                double fraction = (double) remainingCapacity / item.weight;\n                totalValue += item.value * fraction;\n                break; // Knapsack is full\n            }\n        }\n\n        return totalValue;\n    }\n\n    // Get items with fractions\n    public List<String> fractionalKnapsackWithItems(int[] weights, int[] values, int capacity) {\n        List<FractionalItem> items = new ArrayList<>();\n\n        for (int i = 0; i < weights.length; i++) {\n            items.add(new FractionalItem(weights[i], values[i]));\n        }\n\n        items.sort((a, b) -> Double.compare(b.ratio, a.ratio));\n\n        List<String> result = new ArrayList<>();\n        int remainingCapacity = capacity;\n\n        for (int i = 0; i < items.size(); i++) {\n            FractionalItem item = items.get(i);\n\n            if (remainingCapacity >= item.weight) {\n                result.add(String.format("Item %d: Full (weight=%d, value=%d)",\n                                       i, item.weight, item.value));\n                remainingCapacity -= item.weight;\n            } else if (remainingCapacity > 0) {\n                double fraction = (double) remainingCapacity / item.weight;\n                result.add(String.format("Item %d: %.2f%% (weight=%d, value=%.2f)",\n                                       i, fraction * 100, remainingCapacity,\n                                       item.value * fraction));\n                break;\n            }\n        }\n\n        return result;\n    }\n}\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"pattern-11-advanced-knapsack-variations",children:"Pattern 11: Advanced Knapsack Variations"}),"\n",(0,i.jsx)(e.h3,{id:"111-knapsack-with-dependencies",children:"11.1 Knapsack with Dependencies"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Knapsack with item dependencies\npublic class DependentKnapsack {\n\n    static class DependentItem {\n        int weight;\n        int value;\n        List<Integer> dependencies; // Items that must be taken before this one\n\n        DependentItem(int weight, int value) {\n            this.weight = weight;\n            this.value = value;\n            this.dependencies = new ArrayList<>();\n        }\n\n        void addDependency(int itemIndex) {\n            dependencies.add(itemIndex);\n        }\n    }\n\n    public int knapsackWithDependencies(List<DependentItem> items, int capacity) {\n        int n = items.size();\n        // dp[mask] = maximum value achievable with items in mask\n        int[] dp = new int[1 << n];\n\n        for (int mask = 0; mask < (1 << n); mask++) {\n            int weight = 0, value = 0;\n            boolean valid = true;\n\n            // Calculate weight and value for current mask\n            for (int i = 0; i < n; i++) {\n                if ((mask & (1 << i)) != 0) {\n                    DependentItem item = items.get(i);\n                    weight += item.weight;\n                    value += item.value;\n\n                    // Check if all dependencies are satisfied\n                    for (int dep : item.dependencies) {\n                        if ((mask & (1 << dep)) == 0) {\n                            valid = false;\n                            break;\n                        }\n                    }\n\n                    if (!valid) break;\n                }\n            }\n\n            if (valid && weight <= capacity) {\n                dp[mask] = value;\n            }\n        }\n\n        return Arrays.stream(dp).max().orElse(0);\n    }\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"112-stochastic-knapsack",children:"11.2 Stochastic Knapsack"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Knapsack with probabilistic weights/values\npublic class StochasticKnapsack {\n\n    static class ProbabilisticItem {\n        int baseWeight;\n        int baseValue;\n        double successProbability;\n\n        ProbabilisticItem(int baseWeight, int baseValue, double successProbability) {\n            this.baseWeight = baseWeight;\n            this.baseValue = baseValue;\n            this.successProbability = successProbability;\n        }\n\n        double getExpectedValue() {\n            return baseValue * successProbability;\n        }\n\n        double getExpectedWeight() {\n            return baseWeight * successProbability;\n        }\n    }\n\n    // Simplified approach using expected values\n    public double expectedValueKnapsack(List<ProbabilisticItem> items, int capacity) {\n        // Convert to fractional knapsack using expected values\n        items.sort((a, b) -> Double.compare(\n            b.getExpectedValue() / b.getExpectedWeight(),\n            a.getExpectedValue() / a.getExpectedWeight()\n        ));\n\n        double totalExpectedValue = 0;\n        double remainingCapacity = capacity;\n\n        for (ProbabilisticItem item : items) {\n            double expectedWeight = item.getExpectedWeight();\n\n            if (remainingCapacity >= expectedWeight) {\n                totalExpectedValue += item.getExpectedValue();\n                remainingCapacity -= expectedWeight;\n            } else {\n                double fraction = remainingCapacity / expectedWeight;\n                totalExpectedValue += item.getExpectedValue() * fraction;\n                break;\n            }\n        }\n\n        return totalExpectedValue;\n    }\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"pattern-12-real-world-knapsack-applications",children:"Pattern 12: Real-World Knapsack Applications"}),"\n",(0,i.jsx)(e.h3,{id:"121-resource-allocation",children:"12.1 Resource Allocation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Project Selection Problem\npublic class ProjectSelection {\n\n    static class Project {\n        String name;\n        int cost;\n        int profit;\n        int duration;\n\n        Project(String name, int cost, int profit, int duration) {\n            this.name = name;\n            this.cost = cost;\n            this.profit = profit;\n            this.duration = duration;\n        }\n    }\n\n    public List<Project> selectProjects(List<Project> projects, int budget, int timeLimit) {\n        // Two-dimensional knapsack: cost and time constraints\n        int[][][] dp = new int[projects.size() + 1][budget + 1][timeLimit + 1];\n\n        for (int i = 1; i <= projects.size(); i++) {\n            Project project = projects.get(i - 1);\n\n            for (int b = 0; b <= budget; b++) {\n                for (int t = 0; t <= timeLimit; t++) {\n                    // Don't select current project\n                    dp[i][b][t] = dp[i - 1][b][t];\n\n                    // Select current project if constraints satisfied\n                    if (project.cost <= b && project.duration <= t) {\n                        dp[i][b][t] = Math.max(dp[i][b][t],\n                            dp[i - 1][b - project.cost][t - project.duration] + project.profit);\n                    }\n                }\n            }\n        }\n\n        // Backtrack to find selected projects\n        List<Project> selectedProjects = new ArrayList<>();\n        int i = projects.size(), b = budget, t = timeLimit;\n\n        while (i > 0 && dp[i][b][t] > 0) {\n            if (dp[i][b][t] != dp[i - 1][b][t]) {\n                Project project = projects.get(i - 1);\n                selectedProjects.add(project);\n                b -= project.cost;\n                t -= project.duration;\n            }\n            i--;\n        }\n\n        Collections.reverse(selectedProjects);\n        return selectedProjects;\n    }\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"122-investment-portfolio",children:"12.2 Investment Portfolio"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Investment Portfolio Optimization\npublic class PortfolioOptimization {\n\n    static class Investment {\n        String name;\n        double cost;\n        double expectedReturn;\n        double risk; // Standard deviation\n\n        Investment(String name, double cost, double expectedReturn, double risk) {\n            this.name = name;\n            this.cost = cost;\n            this.expectedReturn = expectedReturn;\n            this.risk = risk;\n        }\n\n        double getSharpeRatio() {\n            return expectedReturn / risk; // Simplified Sharpe ratio\n        }\n    }\n\n    public List<Investment> optimizePortfolio(List<Investment> investments,\n                                            double budget, double maxRisk) {\n        // Use greedy approach based on Sharpe ratio for simplicity\n        List<Investment> sortedInvestments = new ArrayList<>(investments);\n        sortedInvestments.sort((a, b) -> Double.compare(b.getSharpeRatio(), a.getSharpeRatio()));\n\n        List<Investment> portfolio = new ArrayList<>();\n        double remainingBudget = budget;\n        double currentRisk = 0;\n\n        for (Investment investment : sortedInvestments) {\n            if (investment.cost <= remainingBudget &&\n                currentRisk + investment.risk <= maxRisk) {\n                portfolio.add(investment);\n                remainingBudget -= investment.cost;\n                currentRisk += investment.risk;\n            }\n        }\n\n        return portfolio;\n    }\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"time--space-complexity-reference",children:"Time & Space Complexity Reference"}),"\n",(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{style:{textAlign:"left"},children:"Knapsack Type"}),(0,i.jsx)(e.th,{style:{textAlign:"left"},children:"Time Complexity"}),(0,i.jsx)(e.th,{style:{textAlign:"left"},children:"Space Complexity"}),(0,i.jsx)(e.th,{style:{textAlign:"left"},children:"Key Characteristics"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"0/1 Knapsack"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"O(nW)"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"O(nW) to O(W)"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"Each item used at most once"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"Unbounded"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"O(nW)"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"O(W)"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"Unlimited quantity of each item"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"Bounded"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"O(nW\u03a3k)"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"O(nW)"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"Limited quantity k of each item"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"Multi-dimensional"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"O(nW\u2081W\u2082...W\u2096)"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"O(W\u2081W\u2082...W\u2096)"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"Multiple constraints"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"Subset Sum"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"O(nS)"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"O(S)"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"Boolean satisfiability"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"Coin Change"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"O(nA)"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"O(A)"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"A = amount, special case of unbounded"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"Fractional"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"O(n log n)"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"O(1)"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"Greedy approach with sorting"})]})]})]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.em,{children:"Where n = number of items, W = capacity, S = target sum, A = amount"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"best-practices--optimization-tips",children:"Best Practices & Optimization Tips"}),"\n",(0,i.jsx)(e.h3,{id:"knapsack-algorithm-guidelines",children:"Knapsack Algorithm Guidelines"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'// 1. Choose appropriate knapsack type\npublic KnapsackSolver selectSolver(ProblemType type) {\n    switch (type) {\n        case EACH_ITEM_ONCE: return new ZeroOneKnapsack();\n        case UNLIMITED_ITEMS: return new UnboundedKnapsack();\n        case LIMITED_QUANTITY: return new BoundedKnapsack();\n        case FRACTIONAL_ALLOWED: return new FractionalKnapsack();\n        default: throw new IllegalArgumentException("Unknown type");\n    }\n}\n\n// 2. Space optimization techniques\npublic int optimizeSpace(int[] weights, int[] values, int capacity) {\n    // Use 1D array instead of 2D when possible\n    int[] dp = new int[capacity + 1];\n\n    for (int i = 0; i < weights.length; i++) {\n        // For 0/1: traverse backwards\n        for (int w = capacity; w >= weights[i]; w--) {\n            dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]);\n        }\n    }\n\n    return dp[capacity];\n}\n\n// 3. Early termination optimization\npublic boolean canAchieveValue(int[] weights, int[] values, int capacity, int targetValue) {\n    int maxPossibleValue = Arrays.stream(values).sum();\n    if (targetValue > maxPossibleValue) return false;\n\n    // Use knapsack DP with early termination\n    int[] dp = new int[capacity + 1];\n\n    for (int i = 0; i < weights.length; i++) {\n        for (int w = capacity; w >= weights[i]; w--) {\n            dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]);\n            if (dp[w] >= targetValue) return true; // Early termination\n        }\n    }\n\n    return false;\n}\n\n// 4. Handle large numbers with approximation\npublic int approximateKnapsack(int[] weights, int[] values, int capacity, double epsilon) {\n    // Scale down values for FPTAS (Fully Polynomial-Time Approximation Scheme)\n    int maxValue = Arrays.stream(values).max().orElse(1);\n    double scaleFactor = epsilon * maxValue / values.length;\n\n    int[] scaledValues = new int[values.length];\n    for (int i = 0; i < values.length; i++) {\n        scaledValues[i] = (int) (values[i] / scaleFactor);\n    }\n\n    // Solve with scaled values\n    ZeroOneKnapsack solver = new ZeroOneKnapsack();\n    return solver.knapsackDP(weights, scaledValues, capacity);\n}\n\nenum ProblemType {\n    EACH_ITEM_ONCE, UNLIMITED_ITEMS, LIMITED_QUANTITY, FRACTIONAL_ALLOWED\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"common-pitfalls-to-avoid",children:"Common Pitfalls to Avoid"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Integer Overflow"}),": Use ",(0,i.jsx)(e.code,{children:"long"})," for large sums"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Negative Weights/Values"}),": Handle edge cases appropriately"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Empty Input"}),": Check for null/empty arrays"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Memory Limits"}),": Use space optimization for large inputs"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Wrong Loop Direction"}),": Backwards for 0/1, forwards for unbounded"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"interview-tips",children:"Interview Tips"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Identify the knapsack variant"})," early: 0/1, unbounded, bounded, or fractional"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Start with recursive solution"})," then optimize with DP"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Consider space optimization"})," for large capacity values"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Practice backtracking"})," to find actual items selected"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Understand real-world applications"})," for better problem comprehension"]}),"\n"]})]})}function m(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(o,{...n})}):o(n)}}}]);