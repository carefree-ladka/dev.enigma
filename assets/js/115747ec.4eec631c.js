"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[2330],{28453:(n,e,i)=>{i.d(e,{R:()=>u,x:()=>s});var t=i(96540);const r={},a=t.createContext(r);function u(n){const e=t.useContext(a);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:u(n.components),t.createElement(a.Provider,{value:e},n.children)}},96393:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>m,contentTitle:()=>u,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>l});var t=i(74848),r=i(28453);const a={},u="Prefix Sum",s={id:"DSA/DSA with Java/Prefix Sum Patterns",title:"Prefix Sum",description:"Table of Contents",source:"@site/docs/DSA/DSA with Java/Prefix Sum Patterns.mdx",sourceDirName:"DSA/DSA with Java",slug:"/DSA/DSA with Java/Prefix Sum Patterns",permalink:"/docs/DSA/DSA with Java/Prefix Sum Patterns",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with Java/Prefix Sum Patterns.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"N-ary Tree",permalink:"/docs/DSA/DSA with Java/Nary Tree Patterns"},next:{title:"Queue",permalink:"/docs/DSA/DSA with Java/Queue Patterns"}},m={},l=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Prefix Sum Fundamentals",id:"prefix-sum-fundamentals",level:2},{value:"Core Concepts and Implementation",id:"core-concepts-and-implementation",level:3},{value:"Pattern 1: Basic Prefix Sum",id:"pattern-1-basic-prefix-sum",level:2},{value:"1.1 Running Sum and Cumulative Operations",id:"11-running-sum-and-cumulative-operations",level:3},{value:"1.2 Prefix Sum with Constraints",id:"12-prefix-sum-with-constraints",level:3},{value:"Pattern 2: Prefix Sum with HashMap",id:"pattern-2-prefix-sum-with-hashmap",level:2},{value:"2.1 Subarray Sum Equals K",id:"21-subarray-sum-equals-k",level:3},{value:"2.2 Advanced HashMap Techniques",id:"22-advanced-hashmap-techniques",level:3},{value:"Pattern 3: Subarray Sum Problems",id:"pattern-3-subarray-sum-problems",level:2},{value:"3.1 Various Sum Conditions",id:"31-various-sum-conditions",level:3},{value:"3.2 Complex Sum Conditions",id:"32-complex-sum-conditions",level:3},{value:"Pattern 4: Range Query Problems",id:"pattern-4-range-query-problems",level:2},{value:"4.1 Static Range Queries",id:"41-static-range-queries",level:3},{value:"4.2 Dynamic Range Queries",id:"42-dynamic-range-queries",level:3},{value:"Pattern 5: 2D Prefix Sum",id:"pattern-5-2d-prefix-sum",level:2},{value:"5.1 2D Range Sum Queries",id:"51-2d-range-sum-queries",level:3},{value:"5.2 Advanced 2D Problems",id:"52-advanced-2d-problems",level:3},{value:"Pattern 6: Prefix Sum with Modular Arithmetic",id:"pattern-6-prefix-sum-with-modular-arithmetic",level:2},{value:"6.1 Modular Sum Problems",id:"61-modular-sum-problems",level:3},{value:"6.2 Advanced Modular Applications",id:"62-advanced-modular-applications",level:3},{value:"Pattern 7: Difference Array Techniques",id:"pattern-7-difference-array-techniques",level:2},{value:"7.1 Range Update Operations",id:"71-range-update-operations",level:3},{value:"7.2 Advanced Difference Array Applications",id:"72-advanced-difference-array-applications",level:3},{value:"Pattern 8: Maximum/Minimum Subarray Problems",id:"pattern-8-maximumminimum-subarray-problems",level:2},{value:"8.1 Kadane&#39;s Algorithm Variants",id:"81-kadanes-algorithm-variants",level:3},{value:"8.2 Advanced Maximum Subarray Problems",id:"82-advanced-maximum-subarray-problems",level:3},{value:"Pattern 9: Binary Indexed Tree (Fenwick Tree)",id:"pattern-9-binary-indexed-tree-fenwick-tree",level:2},{value:"9.1 Basic BIT Implementation",id:"91-basic-bit-implementation",level:3},{value:"9.2 Advanced BIT Applications",id:"92-advanced-bit-applications",level:3},{value:"Pattern 10: Segment Tree for Range Queries",id:"pattern-10-segment-tree-for-range-queries",level:2},{value:"10.1 Basic Segment Tree",id:"101-basic-segment-tree",level:3},{value:"Pattern 11: Advanced Prefix Sum Applications",id:"pattern-11-advanced-prefix-sum-applications",level:2},{value:"11.1 Multi-dimensional Problems",id:"111-multi-dimensional-problems",level:3},{value:"Pattern 12: Optimization Techniques",id:"pattern-12-optimization-techniques",level:2},{value:"12.1 Space and Time Optimizations",id:"121-space-and-time-optimizations",level:3},{value:"Time &amp; Space Complexity Reference",id:"time--space-complexity-reference",level:2},{value:"Best Practices &amp; Interview Tips",id:"best-practices--interview-tips",level:2},{value:"Prefix Sum Guidelines",id:"prefix-sum-guidelines",level:3},{value:"Common Pitfalls to Avoid",id:"common-pitfalls-to-avoid",level:3},{value:"Interview Tips",id:"interview-tips",level:3}];function o(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"prefix-sum",children:"Prefix Sum"})}),"\n",(0,t.jsx)(e.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#prefix-sum-fundamentals",children:"Prefix Sum Fundamentals"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-1-basic-prefix-sum",children:"Pattern 1: Basic Prefix Sum"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-2-prefix-sum-with-hashmap",children:"Pattern 2: Prefix Sum with HashMap"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-3-subarray-sum-problems",children:"Pattern 3: Subarray Sum Problems"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-4-range-query-problems",children:"Pattern 4: Range Query Problems"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-5-2d-prefix-sum",children:"Pattern 5: 2D Prefix Sum"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-6-prefix-sum-with-modular-arithmetic",children:"Pattern 6: Prefix Sum with Modular Arithmetic"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-7-difference-array-techniques",children:"Pattern 7: Difference Array Techniques"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-8-maximumminimum-subarray-problems",children:"Pattern 8: Maximum/Minimum Subarray Problems"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-9-binary-indexed-tree-fenwick-tree",children:"Pattern 9: Binary Indexed Tree (Fenwick Tree)"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-10-segment-tree-for-range-queries",children:"Pattern 10: Segment Tree for Range Queries"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-11-advanced-prefix-sum-applications",children:"Pattern 11: Advanced Prefix Sum Applications"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-12-optimization-techniques",children:"Pattern 12: Optimization Techniques"})}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"prefix-sum-fundamentals",children:"Prefix Sum Fundamentals"}),"\n",(0,t.jsx)(e.h3,{id:"core-concepts-and-implementation",children:"Core Concepts and Implementation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Basic Prefix Sum Implementation\npublic class PrefixSumFundamentals {\n\n    // Simple prefix sum array construction\n    public static int[] buildPrefixSum(int[] arr) {\n        if (arr == null || arr.length == 0) return new int[0];\n\n        int n = arr.length;\n        int[] prefixSum = new int[n];\n        prefixSum[0] = arr[0];\n\n        for (int i = 1; i < n; i++) {\n            prefixSum[i] = prefixSum[i - 1] + arr[i];\n        }\n\n        return prefixSum;\n    }\n\n    // Alternative: prefix sum with 0-indexed base\n    public static int[] buildPrefixSumWithZero(int[] arr) {\n        if (arr == null || arr.length == 0) return new int[1];\n\n        int n = arr.length;\n        int[] prefixSum = new int[n + 1]; // Extra space for 0-index\n        prefixSum[0] = 0; // Base case\n\n        for (int i = 0; i < n; i++) {\n            prefixSum[i + 1] = prefixSum[i] + arr[i];\n        }\n\n        return prefixSum;\n    }\n\n    // Range sum query using prefix sum\n    public static int rangeSum(int[] prefixSum, int left, int right) {\n        // Assuming 0-indexed prefix sum with base\n        return prefixSum[right + 1] - prefixSum[left];\n    }\n\n    // Range sum query for 1-indexed prefix sum\n    public static int rangeSumSimple(int[] prefixSum, int left, int right) {\n        if (left == 0) return prefixSum[right];\n        return prefixSum[right] - prefixSum[left - 1];\n    }\n\n    // Running sum of 1D array (in-place)\n    public static int[] runningSum(int[] nums) {\n        for (int i = 1; i < nums.length; i++) {\n            nums[i] += nums[i - 1];\n        }\n        return nums;\n    }\n\n    // Utility class for range sum queries\n    public static class RangeSumQuery {\n        private int[] prefixSum;\n\n        public RangeSumQuery(int[] nums) {\n            if (nums == null || nums.length == 0) {\n                prefixSum = new int[1];\n                return;\n            }\n\n            prefixSum = new int[nums.length + 1];\n            for (int i = 0; i < nums.length; i++) {\n                prefixSum[i + 1] = prefixSum[i] + nums[i];\n            }\n        }\n\n        public int sumRange(int left, int right) {\n            return prefixSum[right + 1] - prefixSum[left];\n        }\n    }\n\n    // Advanced prefix sum with lazy propagation support\n    public static class AdvancedPrefixSum {\n        private long[] prefixSum;\n        private int[] original;\n\n        public AdvancedPrefixSum(int[] nums) {\n            if (nums == null || nums.length == 0) {\n                prefixSum = new long[1];\n                original = new int[0];\n                return;\n            }\n\n            original = nums.clone();\n            prefixSum = new long[nums.length + 1];\n            buildPrefixSum();\n        }\n\n        private void buildPrefixSum() {\n            for (int i = 0; i < original.length; i++) {\n                prefixSum[i + 1] = prefixSum[i] + original[i];\n            }\n        }\n\n        public long sumRange(int left, int right) {\n            return prefixSum[right + 1] - prefixSum[left];\n        }\n\n        public void update(int index, int val) {\n            int diff = val - original[index];\n            original[index] = val;\n\n            // Update prefix sum array\n            for (int i = index + 1; i < prefixSum.length; i++) {\n                prefixSum[i] += diff;\n            }\n        }\n\n        public double averageRange(int left, int right) {\n            long sum = sumRange(left, right);\n            return (double) sum / (right - left + 1);\n        }\n    }\n\n    // Prefix sum for different data types\n    public static class TypedPrefixSum {\n\n        // Long prefix sum for large numbers\n        public static long[] buildLongPrefixSum(long[] arr) {\n            if (arr == null || arr.length == 0) return new long[1];\n\n            long[] prefixSum = new long[arr.length + 1];\n            for (int i = 0; i < arr.length; i++) {\n                prefixSum[i + 1] = prefixSum[i] + arr[i];\n            }\n            return prefixSum;\n        }\n\n        // Double prefix sum for floating point numbers\n        public static double[] buildDoublePrefixSum(double[] arr) {\n            if (arr == null || arr.length == 0) return new double[1];\n\n            double[] prefixSum = new double[arr.length + 1];\n            for (int i = 0; i < arr.length; i++) {\n                prefixSum[i + 1] = prefixSum[i] + arr[i];\n            }\n            return prefixSum;\n        }\n\n        // Boolean prefix sum (count of true values)\n        public static int[] buildBooleanPrefixSum(boolean[] arr) {\n            if (arr == null || arr.length == 0) return new int[1];\n\n            int[] prefixSum = new int[arr.length + 1];\n            for (int i = 0; i < arr.length; i++) {\n                prefixSum[i + 1] = prefixSum[i] + (arr[i] ? 1 : 0);\n            }\n            return prefixSum;\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-1-basic-prefix-sum",children:"Pattern 1: Basic Prefix Sum"}),"\n",(0,t.jsx)(e.h3,{id:"11-running-sum-and-cumulative-operations",children:"1.1 Running Sum and Cumulative Operations"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Basic prefix sum operations and applications\npublic class BasicPrefixSumOperations {\n\n    // Running sum of 1D array\n    public int[] runningSum(int[] nums) {\n        int[] result = new int[nums.length];\n        result[0] = nums[0];\n\n        for (int i = 1; i < nums.length; i++) {\n            result[i] = result[i - 1] + nums[i];\n        }\n\n        return result;\n    }\n\n    // In-place running sum\n    public int[] runningSumInPlace(int[] nums) {\n        for (int i = 1; i < nums.length; i++) {\n            nums[i] += nums[i - 1];\n        }\n        return nums;\n    }\n\n    // Prefix sum with different operations\n    public static class OperationPrefixSum {\n\n        // Prefix product\n        public static long[] prefixProduct(int[] arr) {\n            if (arr.length == 0) return new long[0];\n\n            long[] result = new long[arr.length];\n            result[0] = arr[0];\n\n            for (int i = 1; i < arr.length; i++) {\n                result[i] = result[i - 1] * arr[i];\n            }\n\n            return result;\n        }\n\n        // Prefix XOR\n        public static int[] prefixXOR(int[] arr) {\n            if (arr.length == 0) return new int[0];\n\n            int[] result = new int[arr.length];\n            result[0] = arr[0];\n\n            for (int i = 1; i < arr.length; i++) {\n                result[i] = result[i - 1] ^ arr[i];\n            }\n\n            return result;\n        }\n\n        // Prefix max\n        public static int[] prefixMax(int[] arr) {\n            if (arr.length == 0) return new int[0];\n\n            int[] result = new int[arr.length];\n            result[0] = arr[0];\n\n            for (int i = 1; i < arr.length; i++) {\n                result[i] = Math.max(result[i - 1], arr[i]);\n            }\n\n            return result;\n        }\n\n        // Prefix min\n        public static int[] prefixMin(int[] arr) {\n            if (arr.length == 0) return new int[0];\n\n            int[] result = new int[arr.length];\n            result[0] = arr[0];\n\n            for (int i = 1; i < arr.length; i++) {\n                result[i] = Math.min(result[i - 1], arr[i]);\n            }\n\n            return result;\n        }\n    }\n\n    // Find pivot index using prefix sum\n    public int pivotIndex(int[] nums) {\n        int totalSum = 0;\n        for (int num : nums) {\n            totalSum += num;\n        }\n\n        int leftSum = 0;\n        for (int i = 0; i < nums.length; i++) {\n            int rightSum = totalSum - leftSum - nums[i];\n\n            if (leftSum == rightSum) {\n                return i;\n            }\n\n            leftSum += nums[i];\n        }\n\n        return -1;\n    }\n\n    // Range sum queries with immutable array\n    public static class NumArray {\n        private int[] prefixSum;\n\n        public NumArray(int[] nums) {\n            prefixSum = new int[nums.length + 1];\n            for (int i = 0; i < nums.length; i++) {\n                prefixSum[i + 1] = prefixSum[i] + nums[i];\n            }\n        }\n\n        public int sumRange(int left, int right) {\n            return prefixSum[right + 1] - prefixSum[left];\n        }\n    }\n\n    // Check if array can be split into three equal sum parts\n    public boolean canThreePartsEqualSum(int[] arr) {\n        int totalSum = 0;\n        for (int num : arr) {\n            totalSum += num;\n        }\n\n        if (totalSum % 3 != 0) return false;\n\n        int targetSum = totalSum / 3;\n        int count = 0;\n        int prefixSum = 0;\n\n        // Need at least 2 partition points (leaving 3 parts)\n        for (int i = 0; i < arr.length - 1; i++) {\n            prefixSum += arr[i];\n\n            if (prefixSum == targetSum * (count + 1)) {\n                count++;\n                if (count == 2) return true;\n            }\n        }\n\n        return false;\n    }\n\n    // Find equilibrium point in array\n    public int findEquilibriumPoint(int[] arr) {\n        int n = arr.length;\n        if (n == 1) return 0;\n\n        int totalSum = 0;\n        for (int num : arr) {\n            totalSum += num;\n        }\n\n        int leftSum = 0;\n        for (int i = 0; i < n; i++) {\n            int rightSum = totalSum - leftSum - arr[i];\n\n            if (leftSum == rightSum) {\n                return i;\n            }\n\n            leftSum += arr[i];\n        }\n\n        return -1;\n    }\n\n    // Maximum average subarray\n    public double findMaxAverage(int[] nums, int k) {\n        // Build prefix sum\n        int[] prefixSum = new int[nums.length + 1];\n        for (int i = 0; i < nums.length; i++) {\n            prefixSum[i + 1] = prefixSum[i] + nums[i];\n        }\n\n        double maxAverage = Double.NEGATIVE_INFINITY;\n\n        // Check all subarrays of length k\n        for (int i = 0; i <= nums.length - k; i++) {\n            int sum = prefixSum[i + k] - prefixSum[i];\n            double average = (double) sum / k;\n            maxAverage = Math.max(maxAverage, average);\n        }\n\n        return maxAverage;\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"12-prefix-sum-with-constraints",children:"1.2 Prefix Sum with Constraints"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Prefix sum problems with specific constraints\npublic class ConstrainedPrefixSum {\n\n    // Minimum size subarray sum >= target\n    public int minSubArrayLen(int target, int[] nums) {\n        int n = nums.length;\n        int[] prefixSum = new int[n + 1];\n\n        // Build prefix sum\n        for (int i = 0; i < n; i++) {\n            prefixSum[i + 1] = prefixSum[i] + nums[i];\n        }\n\n        int minLength = Integer.MAX_VALUE;\n\n        // Use two pointers\n        for (int i = 0; i < n; i++) {\n            for (int j = i; j < n; j++) {\n                int sum = prefixSum[j + 1] - prefixSum[i];\n                if (sum >= target) {\n                    minLength = Math.min(minLength, j - i + 1);\n                    break; // Found minimum for this starting point\n                }\n            }\n        }\n\n        return minLength == Integer.MAX_VALUE ? 0 : minLength;\n    }\n\n    // Optimized version using binary search\n    public int minSubArrayLenOptimized(int target, int[] nums) {\n        int n = nums.length;\n        int[] prefixSum = new int[n + 1];\n\n        for (int i = 0; i < n; i++) {\n            prefixSum[i + 1] = prefixSum[i] + nums[i];\n        }\n\n        int minLength = Integer.MAX_VALUE;\n\n        for (int i = 0; i < n; i++) {\n            int targetSum = prefixSum[i] + target;\n            int bound = binarySearch(prefixSum, targetSum);\n\n            if (bound != prefixSum.length) {\n                minLength = Math.min(minLength, bound - i);\n            }\n        }\n\n        return minLength == Integer.MAX_VALUE ? 0 : minLength;\n    }\n\n    private int binarySearch(int[] arr, int target) {\n        int left = 0, right = arr.length - 1;\n        int result = arr.length;\n\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n\n            if (arr[mid] >= target) {\n                result = mid;\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n\n        return result;\n    }\n\n    // Maximum sum circular subarray\n    public int maxSubarraySumCircular(int[] arr) {\n        int totalSum = 0;\n        for (int num : arr) {\n            totalSum += num;\n        }\n\n        // Case 1: Maximum subarray is non-circular\n        int maxKadane = kadaneMax(arr);\n\n        // Case 2: Maximum subarray is circular\n        // Find minimum subarray and subtract from total\n        int minKadane = kadaneMin(arr);\n        int maxCircular = totalSum - minKadane;\n\n        // If all elements are negative, maxCircular will be 0\n        if (maxCircular == 0) return maxKadane;\n\n        return Math.max(maxKadane, maxCircular);\n    }\n\n    private int kadaneMax(int[] arr) {\n        int maxSoFar = arr[0];\n        int maxEndingHere = arr[0];\n\n        for (int i = 1; i < arr.length; i++) {\n            maxEndingHere = Math.max(arr[i], maxEndingHere + arr[i]);\n            maxSoFar = Math.max(maxSoFar, maxEndingHere);\n        }\n\n        return maxSoFar;\n    }\n\n    private int kadaneMin(int[] arr) {\n        int minSoFar = arr[0];\n        int minEndingHere = arr[0];\n\n        for (int i = 1; i < arr.length; i++) {\n            minEndingHere = Math.min(arr[i], minEndingHere + arr[i]);\n            minSoFar = Math.min(minSoFar, minEndingHere);\n        }\n\n        return minSoFar;\n    }\n\n    // Maximum product subarray using prefix approach\n    public int maxProduct(int[] nums) {\n        int n = nums.length;\n        int[] maxProduct = new int[n];\n        int[] minProduct = new int[n];\n\n        maxProduct[0] = minProduct[0] = nums[0];\n        int result = nums[0];\n\n        for (int i = 1; i < n; i++) {\n            if (nums[i] >= 0) {\n                maxProduct[i] = Math.max(nums[i], maxProduct[i - 1] * nums[i]);\n                minProduct[i] = Math.min(nums[i], minProduct[i - 1] * nums[i]);\n            } else {\n                maxProduct[i] = Math.max(nums[i], minProduct[i - 1] * nums[i]);\n                minProduct[i] = Math.min(nums[i], maxProduct[i - 1] * nums[i]);\n            }\n\n            result = Math.max(result, maxProduct[i]);\n        }\n\n        return result;\n    }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-2-prefix-sum-with-hashmap",children:"Pattern 2: Prefix Sum with HashMap"}),"\n",(0,t.jsx)(e.h3,{id:"21-subarray-sum-equals-k",children:"2.1 Subarray Sum Equals K"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Prefix sum with HashMap for efficient lookups\npublic class PrefixSumHashMap {\n\n    // Subarray Sum Equals K - Core pattern\n    public int subarraySum(int[] nums, int k) {\n        Map<Integer, Integer> prefixSumCount = new HashMap<>();\n        prefixSumCount.put(0, 1); // Empty subarray has sum 0\n\n        int count = 0;\n        int prefixSum = 0;\n\n        for (int num : nums) {\n            prefixSum += num;\n\n            // Check if there exists a prefix sum such that\n            // current_prefix - previous_prefix = k\n            int target = prefixSum - k;\n            if (prefixSumCount.containsKey(target)) {\n                count += prefixSumCount.get(target);\n            }\n\n            // Add current prefix sum to map\n            prefixSumCount.put(prefixSum, prefixSumCount.getOrDefault(prefixSum, 0) + 1);\n        }\n\n        return count;\n    }\n\n    // Maximum size subarray sum equals k\n    public int maxSubArrayLen(int[] nums, int k) {\n        Map<Integer, Integer> prefixSumIndex = new HashMap<>();\n        prefixSumIndex.put(0, -1); // Empty subarray\n\n        int maxLength = 0;\n        int prefixSum = 0;\n\n        for (int i = 0; i < nums.length; i++) {\n            prefixSum += nums[i];\n\n            int target = prefixSum - k;\n            if (prefixSumIndex.containsKey(target)) {\n                maxLength = Math.max(maxLength, i - prefixSumIndex.get(target));\n            }\n\n            // Only store first occurrence to maximize length\n            if (!prefixSumIndex.containsKey(prefixSum)) {\n                prefixSumIndex.put(prefixSum, i);\n            }\n        }\n\n        return maxLength;\n    }\n\n    // Find if subarray with sum k exists\n    public boolean checkSubarraySum(int[] nums, int k) {\n        Map<Integer, Integer> prefixSumIndex = new HashMap<>();\n        prefixSumIndex.put(0, -1);\n\n        int prefixSum = 0;\n\n        for (int i = 0; i < nums.length; i++) {\n            prefixSum += nums[i];\n\n            if (prefixSumIndex.containsKey(prefixSum - k)) {\n                return true;\n            }\n\n            if (!prefixSumIndex.containsKey(prefixSum)) {\n                prefixSumIndex.put(prefixSum, i);\n            }\n        }\n\n        return false;\n    }\n\n    // Count subarrays with sum divisible by k\n    public int subarraysDivByK(int[] nums, int k) {\n        Map<Integer, Integer> remainderCount = new HashMap<>();\n        remainderCount.put(0, 1); // Empty subarray\n\n        int count = 0;\n        int prefixSum = 0;\n\n        for (int num : nums) {\n            prefixSum += num;\n\n            // Handle negative remainders\n            int remainder = ((prefixSum % k) + k) % k;\n\n            if (remainderCount.containsKey(remainder)) {\n                count += remainderCount.get(remainder);\n            }\n\n            remainderCount.put(remainder, remainderCount.getOrDefault(remainder, 0) + 1);\n        }\n\n        return count;\n    }\n\n    // Continuous subarray sum (multiple of k with length >= 2)\n    public boolean checkSubarraySumMultiple(int[] nums, int k) {\n        Map<Integer, Integer> remainderIndex = new HashMap<>();\n        remainderIndex.put(0, -1);\n\n        int prefixSum = 0;\n\n        for (int i = 0; i < nums.length; i++) {\n            prefixSum += nums[i];\n            int remainder = prefixSum % k;\n\n            if (remainderIndex.containsKey(remainder)) {\n                // Check if subarray length is at least 2\n                if (i - remainderIndex.get(remainder) > 1) {\n                    return true;\n                }\n            } else {\n                remainderIndex.put(remainder, i);\n            }\n        }\n\n        return false;\n    }\n\n    // Binary subarrays with sum\n    public int numSubarraysWithSum(int[] nums, int goal) {\n        Map<Integer, Integer> prefixSumCount = new HashMap<>();\n        prefixSumCount.put(0, 1);\n\n        int count = 0;\n        int prefixSum = 0;\n\n        for (int num : nums) {\n            prefixSum += num;\n\n            int target = prefixSum - goal;\n            if (prefixSumCount.containsKey(target)) {\n                count += prefixSumCount.get(target);\n            }\n\n            prefixSumCount.put(prefixSum, prefixSumCount.getOrDefault(prefixSum, 0) + 1);\n        }\n\n        return count;\n    }\n\n    // Subarray sums to zero\n    public boolean hasSubarrayWithZeroSum(int[] nums) {\n        Set<Integer> prefixSums = new HashSet<>();\n        prefixSums.add(0);\n\n        int prefixSum = 0;\n        for (int num : nums) {\n            prefixSum += num;\n\n            if (prefixSums.contains(prefixSum)) {\n                return true;\n            }\n\n            prefixSums.add(prefixSum);\n        }\n\n        return false;\n    }\n\n    // Generic template for prefix sum + HashMap problems\n    public static class PrefixSumTemplate {\n\n        // Count subarrays matching condition\n        public static int countSubarraysWithCondition(int[] nums,\n                                                     java.util.function.Predicate<Integer> condition) {\n            Map<Integer, Integer> prefixSumCount = new HashMap<>();\n            prefixSumCount.put(0, 1);\n\n            int count = 0;\n            int prefixSum = 0;\n\n            for (int num : nums) {\n                prefixSum += num;\n\n                // Check condition for different target values\n                for (Map.Entry<Integer, Integer> entry : prefixSumCount.entrySet()) {\n                    int previousSum = entry.getKey();\n                    int subarraySum = prefixSum - previousSum;\n\n                    if (condition.test(subarraySum)) {\n                        count += entry.getValue();\n                    }\n                }\n\n                prefixSumCount.put(prefixSum, prefixSumCount.getOrDefault(prefixSum, 0) + 1);\n            }\n\n            return count;\n        }\n\n        // Find max length subarray matching condition\n        public static int maxLengthSubarrayWithCondition(int[] nums,\n                                                        java.util.function.Predicate<Integer> condition) {\n            Map<Integer, Integer> prefixSumIndex = new HashMap<>();\n            prefixSumIndex.put(0, -1);\n\n            int maxLength = 0;\n            int prefixSum = 0;\n\n            for (int i = 0; i < nums.length; i++) {\n                prefixSum += nums[i];\n\n                for (Map.Entry<Integer, Integer> entry : prefixSumIndex.entrySet()) {\n                    int previousSum = entry.getKey();\n                    int subarraySum = prefixSum - previousSum;\n\n                    if (condition.test(subarraySum)) {\n                        maxLength = Math.max(maxLength, i - entry.getValue());\n                    }\n                }\n\n                if (!prefixSumIndex.containsKey(prefixSum)) {\n                    prefixSumIndex.put(prefixSum, i);\n                }\n            }\n\n            return maxLength;\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"22-advanced-hashmap-techniques",children:"2.2 Advanced HashMap Techniques"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Advanced prefix sum with HashMap patterns\npublic class AdvancedPrefixSumHashMap {\n\n    // Count equal 0s and 1s in binary array\n    public int findMaxLength(int[] nums) {\n        // Convert 0s to -1s, then find longest subarray with sum 0\n        Map<Integer, Integer> sumIndex = new HashMap<>();\n        sumIndex.put(0, -1);\n\n        int maxLength = 0;\n        int sum = 0;\n\n        for (int i = 0; i < nums.length; i++) {\n            sum += (nums[i] == 1) ? 1 : -1;\n\n            if (sumIndex.containsKey(sum)) {\n                maxLength = Math.max(maxLength, i - sumIndex.get(sum));\n            } else {\n                sumIndex.put(sum, i);\n            }\n        }\n\n        return maxLength;\n    }\n\n    // Contiguous array with equal number of 0s and 1s\n    public int findMaxLengthBinary(int[] nums) {\n        Map<Integer, Integer> diffIndex = new HashMap<>();\n        diffIndex.put(0, -1);\n\n        int maxLength = 0;\n        int count0 = 0, count1 = 0;\n\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] == 0) count0++;\n            else count1++;\n\n            int diff = count1 - count0;\n\n            if (diffIndex.containsKey(diff)) {\n                maxLength = Math.max(maxLength, i - diffIndex.get(diff));\n            } else {\n                diffIndex.put(diff, i);\n            }\n        }\n\n        return maxLength;\n    }\n\n    // Find all subarrays with equal number of 0s and 1s\n    public List<int[]> findAllEqualSubarrays(int[] nums) {\n        Map<Integer, List<Integer>> diffIndices = new HashMap<>();\n        diffIndices.put(0, new ArrayList<>(Arrays.asList(-1)));\n\n        List<int[]> result = new ArrayList<>();\n        int count0 = 0, count1 = 0;\n\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] == 0) count0++;\n            else count1++;\n\n            int diff = count1 - count0;\n\n            if (diffIndices.containsKey(diff)) {\n                for (int startIndex : diffIndices.get(diff)) {\n                    result.add(new int[]{startIndex + 1, i});\n                }\n            }\n\n            diffIndices.computeIfAbsent(diff, k -> new ArrayList<>()).add(i);\n        }\n\n        return result;\n    }\n\n    // Minimum operations to make array sum equal to target\n    public int minOperationsToTarget(int[] nums, int target) {\n        Map<Integer, Integer> prefixSumCount = new HashMap<>();\n        prefixSumCount.put(0, 1);\n\n        int operations = 0;\n        int prefixSum = 0;\n\n        for (int num : nums) {\n            prefixSum += num;\n\n            // If we can form target sum, no operations needed for this prefix\n            if (prefixSumCount.containsKey(prefixSum - target)) {\n                // Found a valid subarray\n                continue;\n            }\n\n            prefixSumCount.put(prefixSum, prefixSumCount.getOrDefault(prefixSum, 0) + 1);\n        }\n\n        // This is a simplified version - actual implementation would be more complex\n        return operations;\n    }\n\n    // Subarrays with k odd numbers\n    public int numberOfSubarraysWithKOdds(int[] nums, int k) {\n        // Convert to binary: odd = 1, even = 0\n        Map<Integer, Integer> prefixCount = new HashMap<>();\n        prefixCount.put(0, 1);\n\n        int count = 0;\n        int oddCount = 0;\n\n        for (int num : nums) {\n            if (num % 2 == 1) oddCount++;\n\n            int target = oddCount - k;\n            if (prefixCount.containsKey(target)) {\n                count += prefixCount.get(target);\n            }\n\n            prefixCount.put(oddCount, prefixCount.getOrDefault(oddCount, 0) + 1);\n        }\n\n        return count;\n    }\n\n    // Replace elements to make sum divisible by k\n    public int minReplacementsForDivisibility(int[] nums, int k) {\n        Map<Integer, Integer> remainderCount = new HashMap<>();\n        remainderCount.put(0, 1);\n\n        int prefixSum = 0;\n        int replacements = 0;\n\n        for (int num : nums) {\n            prefixSum += num;\n            int remainder = ((prefixSum % k) + k) % k;\n\n            if (remainderCount.containsKey(remainder)) {\n                // Found a subarray divisible by k, no replacement needed\n            } else {\n                // Need replacement to make divisible\n                remainderCount.put(remainder, remainderCount.getOrDefault(remainder, 0) + 1);\n            }\n        }\n\n        return replacements;\n    }\n\n    // Maximum length subarray with difference of k\n    public int maxSubarrayLengthWithDiff(int[] nums, int k) {\n        Map<Integer, Integer> firstOccurrence = new HashMap<>();\n        firstOccurrence.put(0, -1);\n\n        int maxLength = 0;\n        int sum = 0;\n\n        for (int i = 0; i < nums.length; i++) {\n            sum += nums[i];\n\n            // Check for both +k and -k differences\n            if (firstOccurrence.containsKey(sum - k)) {\n                maxLength = Math.max(maxLength, i - firstOccurrence.get(sum - k));\n            }\n            if (firstOccurrence.containsKey(sum + k)) {\n                maxLength = Math.max(maxLength, i - firstOccurrence.get(sum + k));\n            }\n\n            if (!firstOccurrence.containsKey(sum)) {\n                firstOccurrence.put(sum, i);\n            }\n        }\n\n        return maxLength;\n    }\n\n    // Find subarrays with sum in range [left, right]\n    public int numSubarraysInRange(int[] nums, int left, int right) {\n        return numSubarraysAtMost(nums, right) - numSubarraysAtMost(nums, left - 1);\n    }\n\n    private int numSubarraysAtMost(int[] nums, int target) {\n        Map<Integer, Integer> prefixSumCount = new HashMap<>();\n        prefixSumCount.put(0, 1);\n\n        int count = 0;\n        int prefixSum = 0;\n\n        for (int num : nums) {\n            prefixSum += num;\n\n            // Count all prefix sums such that current - previous <= target\n            for (Map.Entry<Integer, Integer> entry : prefixSumCount.entrySet()) {\n                if (prefixSum - entry.getKey() <= target) {\n                    count += entry.getValue();\n                }\n            }\n\n            prefixSumCount.put(prefixSum, prefixSumCount.getOrDefault(prefixSum, 0) + 1);\n        }\n\n        return count;\n    }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-3-subarray-sum-problems",children:"Pattern 3: Subarray Sum Problems"}),"\n",(0,t.jsx)(e.h3,{id:"31-various-sum-conditions",children:"3.1 Various Sum Conditions"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Comprehensive subarray sum problems\npublic class SubarraySumProblems {\n\n    // Maximum sum subarray (Kadane's algorithm with prefix sum insight)\n    public int maxSubArray(int[] nums) {\n        int maxSoFar = nums[0];\n        int maxEndingHere = nums[0];\n\n        for (int i = 1; i < nums.length; i++) {\n            maxEndingHere = Math.max(nums[i], maxEndingHere + nums[i]);\n            maxSoFar = Math.max(maxSoFar, maxEndingHere);\n        }\n\n        return maxSoFar;\n    }\n\n    // Maximum sum subarray with indices\n    public int[] maxSubArrayWithIndices(int[] nums) {\n        int maxSum = nums[0];\n        int currentSum = nums[0];\n        int start = 0, end = 0, tempStart = 0;\n\n        for (int i = 1; i < nums.length; i++) {\n            if (currentSum < 0) {\n                currentSum = nums[i];\n                tempStart = i;\n            } else {\n                currentSum += nums[i];\n            }\n\n            if (currentSum > maxSum) {\n                maxSum = currentSum;\n                start = tempStart;\n                end = i;\n            }\n        }\n\n        return new int[]{maxSum, start, end};\n    }\n\n    // Minimum sum subarray\n    public int minSubArray(int[] nums) {\n        int minSoFar = nums[0];\n        int minEndingHere = nums[0];\n\n        for (int i = 1; i < nums.length; i++) {\n            minEndingHere = Math.min(nums[i], minEndingHere + nums[i]);\n            minSoFar = Math.min(minSoFar, minEndingHere);\n        }\n\n        return minSoFar;\n    }\n\n    // Count of subarrays with sum less than k\n    public int numSubarraysWithSumLessThanK(int[] nums, int k) {\n        Map<Integer, Integer> prefixCount = new HashMap<>();\n        prefixCount.put(0, 1);\n\n        int count = 0;\n        int prefixSum = 0;\n\n        for (int num : nums) {\n            prefixSum += num;\n\n            // Count all previous prefix sums where current - previous < k\n            for (Map.Entry<Integer, Integer> entry : prefixCount.entrySet()) {\n                if (prefixSum - entry.getKey() < k) {\n                    count += entry.getValue();\n                }\n            }\n\n            prefixCount.put(prefixSum, prefixCount.getOrDefault(prefixSum, 0) + 1);\n        }\n\n        return count;\n    }\n\n    // Subarray with largest sum\n    public int[] subarrayWithLargestSum(int[] nums) {\n        int maxSum = Integer.MIN_VALUE;\n        int currentSum = 0;\n        int start = 0, end = 0, tempStart = 0;\n\n        for (int i = 0; i < nums.length; i++) {\n            currentSum += nums[i];\n\n            if (currentSum > maxSum) {\n                maxSum = currentSum;\n                start = tempStart;\n                end = i;\n            }\n\n            if (currentSum < 0) {\n                currentSum = 0;\n                tempStart = i + 1;\n            }\n        }\n\n        return Arrays.copyOfRange(nums, start, end + 1);\n    }\n\n    // Count subarrays with average >= threshold\n    public int numSubarraysWithAverage(int[] nums, double threshold) {\n        // Transform problem: subtract threshold from each element\n        // Then find subarrays with sum >= 0\n\n        int count = 0;\n        int n = nums.length;\n\n        for (int i = 0; i < n; i++) {\n            double sum = 0;\n            for (int j = i; j < n; j++) {\n                sum += nums[j];\n                double average = sum / (j - i + 1);\n\n                if (average >= threshold) {\n                    count++;\n                }\n            }\n        }\n\n        return count;\n    }\n\n    // Longest subarray with sum divisible by k\n    public int longestSubarrayDivisibleByK(int[] nums, int k) {\n        Map<Integer, Integer> remainderIndex = new HashMap<>();\n        remainderIndex.put(0, -1);\n\n        int maxLength = 0;\n        int prefixSum = 0;\n\n        for (int i = 0; i < nums.length; i++) {\n            prefixSum += nums[i];\n            int remainder = ((prefixSum % k) + k) % k;\n\n            if (remainderIndex.containsKey(remainder)) {\n                maxLength = Math.max(maxLength, i - remainderIndex.get(remainder));\n            } else {\n                remainderIndex.put(remainder, i);\n            }\n        }\n\n        return maxLength;\n    }\n\n    // Number of subarrays with sum exactly k (optimized)\n    public int subarraySum(int[] nums, int k) {\n        Map<Integer, Integer> prefixSumFreq = new HashMap<>();\n        prefixSumFreq.put(0, 1);\n\n        int count = 0;\n        int prefixSum = 0;\n\n        for (int num : nums) {\n            prefixSum += num;\n            count += prefixSumFreq.getOrDefault(prefixSum - k, 0);\n            prefixSumFreq.put(prefixSum, prefixSumFreq.getOrDefault(prefixSum, 0) + 1);\n        }\n\n        return count;\n    }\n\n    // Find all subarrays with sum k\n    public List<int[]> findAllSubarraysWithSumK(int[] nums, int k) {\n        Map<Integer, List<Integer>> prefixSumIndices = new HashMap<>();\n        prefixSumIndices.put(0, new ArrayList<>(Arrays.asList(-1)));\n\n        List<int[]> result = new ArrayList<>();\n        int prefixSum = 0;\n\n        for (int i = 0; i < nums.length; i++) {\n            prefixSum += nums[i];\n\n            int target = prefixSum - k;\n            if (prefixSumIndices.containsKey(target)) {\n                for (int startIndex : prefixSumIndices.get(target)) {\n                    result.add(new int[]{startIndex + 1, i});\n                }\n            }\n\n            prefixSumIndices.computeIfAbsent(prefixSum, key -> new ArrayList<>()).add(i);\n        }\n\n        return result;\n    }\n\n    // Maximum length subarray with positive sum\n    public int maxLengthPositiveSum(int[] nums) {\n        Map<Integer, Integer> prefixSumIndex = new HashMap<>();\n        prefixSumIndex.put(0, -1);\n\n        int maxLength = 0;\n        int prefixSum = 0;\n\n        for (int i = 0; i < nums.length; i++) {\n            prefixSum += nums[i];\n\n            if (prefixSum > 0) {\n                maxLength = Math.max(maxLength, i + 1);\n            }\n\n            // Look for smaller prefix sums to get positive subarray\n            for (Map.Entry<Integer, Integer> entry : prefixSumIndex.entrySet()) {\n                if (prefixSum > entry.getKey()) {\n                    maxLength = Math.max(maxLength, i - entry.getValue());\n                }\n            }\n\n            if (!prefixSumIndex.containsKey(prefixSum)) {\n                prefixSumIndex.put(prefixSum, i);\n            }\n        }\n\n        return maxLength;\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"32-complex-sum-conditions",children:"3.2 Complex Sum Conditions"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:'// Advanced subarray sum problems with complex conditions\npublic class ComplexSubarraySumProblems {\n\n    // Maximum sum of non-overlapping subarrays\n    public int maxSumTwoNoOverlap(int[] nums, int firstLen, int secondLen) {\n        int n = nums.length;\n        int[] prefixSum = new int[n + 1];\n\n        // Build prefix sum\n        for (int i = 0; i < n; i++) {\n            prefixSum[i + 1] = prefixSum[i] + nums[i];\n        }\n\n        return Math.max(\n            maxSumHelper(prefixSum, firstLen, secondLen),\n            maxSumHelper(prefixSum, secondLen, firstLen)\n        );\n    }\n\n    private int maxSumHelper(int[] prefixSum, int len1, int len2) {\n        int n = prefixSum.length - 1;\n        int maxSum = 0;\n\n        // Try all positions for first subarray\n        for (int i = 0; i <= n - len1; i++) {\n            int sum1 = prefixSum[i + len1] - prefixSum[i];\n\n            // Find max sum for second subarray before first\n            int maxBefore = 0;\n            for (int j = 0; j <= i - len2; j++) {\n                maxBefore = Math.max(maxBefore, prefixSum[j + len2] - prefixSum[j]);\n            }\n\n            // Find max sum for second subarray after first\n            int maxAfter = 0;\n            for (int j = i + len1; j <= n - len2; j++) {\n                maxAfter = Math.max(maxAfter, prefixSum[j + len2] - prefixSum[j]);\n            }\n\n            maxSum = Math.max(maxSum, sum1 + Math.max(maxBefore, maxAfter));\n        }\n\n        return maxSum;\n    }\n\n    // Count subarrays where sum of first half equals sum of second half\n    public int countEqualSumSubarrays(int[] nums) {\n        int count = 0;\n        int n = nums.length;\n\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j += 2) { // Only consider even-length subarrays\n                int len = j - i + 1;\n                if (len % 2 != 0) continue;\n\n                int mid = i + len / 2;\n                int leftSum = 0, rightSum = 0;\n\n                for (int k = i; k < mid; k++) {\n                    leftSum += nums[k];\n                }\n                for (int k = mid; k <= j; k++) {\n                    rightSum += nums[k];\n                }\n\n                if (leftSum == rightSum) {\n                    count++;\n                }\n            }\n        }\n\n        return count;\n    }\n\n    // Maximum sum subarray with at most k negations\n    public int maxSumWithKNegations(int[] nums, int k) {\n        // This is a more complex problem involving prefix sums and DP\n        int n = nums.length;\n        Map<String, Integer> memo = new HashMap<>();\n\n        return maxSumWithKNegationsHelper(nums, 0, k, memo);\n    }\n\n    private int maxSumWithKNegationsHelper(int[] nums, int index, int k, Map<String, Integer> memo) {\n        if (index >= nums.length) return 0;\n\n        String key = index + "," + k;\n        if (memo.containsKey(key)) return memo.get(key);\n\n        // Don\'t negate current element\n        int withoutNegate = nums[index] + maxSumWithKNegationsHelper(nums, index + 1, k, memo);\n\n        // Negate current element if we have negations left\n        int withNegate = Integer.MIN_VALUE;\n        if (k > 0) {\n            withNegate = -nums[index] + maxSumWithKNegationsHelper(nums, index + 1, k - 1, memo);\n        }\n\n        int result = Math.max(withoutNegate, withNegate);\n        memo.put(key, result);\n        return result;\n    }\n\n    // Subarray with sum closest to target\n    public int[] subarrayClosestToTarget(int[] nums, int target) {\n        int closestSum = Integer.MAX_VALUE;\n        int[] result = new int[2];\n        int n = nums.length;\n\n        int[] prefixSum = new int[n + 1];\n        for (int i = 0; i < n; i++) {\n            prefixSum[i + 1] = prefixSum[i] + nums[i];\n        }\n\n        for (int i = 0; i < n; i++) {\n            for (int j = i; j < n; j++) {\n                int sum = prefixSum[j + 1] - prefixSum[i];\n\n                if (Math.abs(sum - target) < Math.abs(closestSum - target)) {\n                    closestSum = sum;\n                    result[0] = i;\n                    result[1] = j;\n                }\n            }\n        }\n\n        return result;\n    }\n\n    // Count subarrays with sum in range [lower, upper]\n    public int countRangeSum(int[] nums, int lower, int upper) {\n        long[] prefixSums = new long[nums.length + 1];\n        for (int i = 0; i < nums.length; i++) {\n            prefixSums[i + 1] = prefixSums[i] + nums[i];\n        }\n\n        return mergeSortAndCount(prefixSums, 0, prefixSums.length - 1, lower, upper);\n    }\n\n    private int mergeSortAndCount(long[] sums, int start, int end, int lower, int upper) {\n        if (start >= end) return 0;\n\n        int mid = start + (end - start) / 2;\n        int count = mergeSortAndCount(sums, start, mid, lower, upper) +\n                   mergeSortAndCount(sums, mid + 1, end, lower, upper);\n\n        // Count pairs where i in [start, mid] and j in [mid+1, end]\n        int j = mid + 1, k = mid + 1;\n        for (int i = start; i <= mid; i++) {\n            while (j <= end && sums[j] - sums[i] < lower) j++;\n            while (k <= end && sums[k] - sums[i] <= upper) k++;\n            count += k - j;\n        }\n\n        // Merge\n        long[] temp = new long[end - start + 1];\n        int i = start, p = mid + 1, t = 0;\n\n        while (i <= mid && p <= end) {\n            if (sums[i] <= sums[p]) {\n                temp[t++] = sums[i++];\n            } else {\n                temp[t++] = sums[p++];\n            }\n        }\n\n        while (i <= mid) temp[t++] = sums[i++];\n        while (p <= end) temp[t++] = sums[p++];\n\n        System.arraycopy(temp, 0, sums, start, temp.length);\n\n        return count;\n    }\n\n    // Maximum sum of 3 non-overlapping subarrays\n    public int[] maxSumOfThreeSubarrays(int[] nums, int k) {\n        int n = nums.length;\n        int[] sums = new int[n - k + 1];\n\n        // Calculate sum of each k-length subarray\n        int sum = 0;\n        for (int i = 0; i < k; i++) {\n            sum += nums[i];\n        }\n        sums[0] = sum;\n\n        for (int i = 1; i < sums.length; i++) {\n            sum = sum - nums[i - 1] + nums[i + k - 1];\n            sums[i] = sum;\n        }\n\n        // Find best left and right subarrays for each middle position\n        int[] left = new int[sums.length];\n        int[] right = new int[sums.length];\n\n        int bestLeft = 0;\n        for (int i = 0; i < sums.length; i++) {\n            if (sums[i] > sums[bestLeft]) {\n                bestLeft = i;\n            }\n            left[i] = bestLeft;\n        }\n\n        int bestRight = sums.length - 1;\n        for (int i = sums.length - 1; i >= 0; i--) {\n            if (sums[i] >= sums[bestRight]) {\n                bestRight = i;\n            }\n            right[i] = bestRight;\n        }\n\n        // Find the best combination\n        int maxSum = 0;\n        int[] result = new int[3];\n\n        for (int mid = k; mid < sums.length - k; mid++) {\n            int l = left[mid - k];\n            int r = right[mid + k];\n            int totalSum = sums[l] + sums[mid] + sums[r];\n\n            if (totalSum > maxSum) {\n                maxSum = totalSum;\n                result[0] = l;\n                result[1] = mid;\n                result[2] = r;\n            }\n        }\n\n        return result;\n    }\n}\n'})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-4-range-query-problems",children:"Pattern 4: Range Query Problems"}),"\n",(0,t.jsx)(e.h3,{id:"41-static-range-queries",children:"4.1 Static Range Queries"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Range query problems using prefix sum\npublic class RangeQueryProblems {\n\n    // Basic range sum query - immutable\n    public static class NumArray {\n        private int[] prefixSum;\n\n        public NumArray(int[] nums) {\n            prefixSum = new int[nums.length + 1];\n            for (int i = 0; i < nums.length; i++) {\n                prefixSum[i + 1] = prefixSum[i] + nums[i];\n            }\n        }\n\n        public int sumRange(int left, int right) {\n            return prefixSum[right + 1] - prefixSum[left];\n        }\n\n        public double averageRange(int left, int right) {\n            int sum = sumRange(left, right);\n            return (double) sum / (right - left + 1);\n        }\n\n        public int maxInRange(int left, int right) {\n            // This would require additional preprocessing\n            // For now, we'll use a simple approach\n            int max = Integer.MIN_VALUE;\n            for (int i = left; i <= right; i++) {\n                int value = prefixSum[i + 1] - prefixSum[i];\n                max = Math.max(max, value);\n            }\n            return max;\n        }\n    }\n\n    // Range sum query with different data types\n    public static class TypedRangeQuery {\n        private long[] longPrefixSum;\n        private double[] doublePrefixSum;\n\n        public TypedRangeQuery(int[] nums) {\n            longPrefixSum = new long[nums.length + 1];\n            doublePrefixSum = new double[nums.length + 1];\n\n            for (int i = 0; i < nums.length; i++) {\n                longPrefixSum[i + 1] = longPrefixSum[i] + nums[i];\n                doublePrefixSum[i + 1] = doublePrefixSum[i] + nums[i];\n            }\n        }\n\n        public long longSumRange(int left, int right) {\n            return longPrefixSum[right + 1] - longPrefixSum[left];\n        }\n\n        public double doubleSumRange(int left, int right) {\n            return doublePrefixSum[right + 1] - doublePrefixSum[left];\n        }\n    }\n\n    // Range product query\n    public static class RangeProductQuery {\n        private long[] prefixProduct;\n        private boolean hasZero;\n        private int firstZeroIndex;\n\n        public RangeProductQuery(int[] nums) {\n            prefixProduct = new long[nums.length + 1];\n            prefixProduct[0] = 1;\n            hasZero = false;\n            firstZeroIndex = -1;\n\n            for (int i = 0; i < nums.length; i++) {\n                if (nums[i] == 0) {\n                    hasZero = true;\n                    firstZeroIndex = i;\n                    break;\n                }\n                prefixProduct[i + 1] = prefixProduct[i] * nums[i];\n            }\n        }\n\n        public long productRange(int left, int right) {\n            if (hasZero && firstZeroIndex >= left && firstZeroIndex <= right) {\n                return 0;\n            }\n\n            if (left == 0) {\n                return prefixProduct[right + 1];\n            }\n\n            return prefixProduct[right + 1] / prefixProduct[left];\n        }\n    }\n\n    // Range XOR query\n    public static class RangeXORQuery {\n        private int[] prefixXOR;\n\n        public RangeXORQuery(int[] nums) {\n            prefixXOR = new int[nums.length + 1];\n            for (int i = 0; i < nums.length; i++) {\n                prefixXOR[i + 1] = prefixXOR[i] ^ nums[i];\n            }\n        }\n\n        public int xorRange(int left, int right) {\n            return prefixXOR[right + 1] ^ prefixXOR[left];\n        }\n    }\n\n    // Range minimum/maximum query preprocessing\n    public static class RangeMinMaxQuery {\n        private int[][] minTable;\n        private int[][] maxTable;\n        private int[] log;\n\n        public RangeMinMaxQuery(int[] nums) {\n            int n = nums.length;\n            int logN = (int) (Math.log(n) / Math.log(2)) + 1;\n\n            minTable = new int[n][logN];\n            maxTable = new int[n][logN];\n            log = new int[n + 1];\n\n            // Precompute logarithms\n            for (int i = 2; i <= n; i++) {\n                log[i] = log[i / 2] + 1;\n            }\n\n            // Initialize for intervals of length 1\n            for (int i = 0; i < n; i++) {\n                minTable[i][0] = nums[i];\n                maxTable[i][0] = nums[i];\n            }\n\n            // Build sparse table\n            for (int j = 1; (1 << j) <= n; j++) {\n                for (int i = 0; i + (1 << j) - 1 < n; i++) {\n                    minTable[i][j] = Math.min(minTable[i][j - 1],\n                                            minTable[i + (1 << (j - 1))][j - 1]);\n                    maxTable[i][j] = Math.max(maxTable[i][j - 1],\n                                            maxTable[i + (1 << (j - 1))][j - 1]);\n                }\n            }\n        }\n\n        public int rangeMin(int left, int right) {\n            int j = log[right - left + 1];\n            return Math.min(minTable[left][j], minTable[right - (1 << j) + 1][j]);\n        }\n\n        public int rangeMax(int left, int right) {\n            int j = log[right - left + 1];\n            return Math.max(maxTable[left][j], maxTable[right - (1 << j) + 1][j]);\n        }\n    }\n\n    // Range frequency query\n    public static class RangeFrequencyQuery {\n        private Map<Integer, List<Integer>> valueIndices;\n\n        public RangeFrequencyQuery(int[] nums) {\n            valueIndices = new HashMap<>();\n            for (int i = 0; i < nums.length; i++) {\n                valueIndices.computeIfAbsent(nums[i], k -> new ArrayList<>()).add(i);\n            }\n        }\n\n        public int rangeFreqQuery(int left, int right, int value) {\n            if (!valueIndices.containsKey(value)) return 0;\n\n            List<Integer> indices = valueIndices.get(value);\n\n            // Binary search for left bound\n            int leftBound = Collections.binarySearch(indices, left);\n            if (leftBound < 0) leftBound = -leftBound - 1;\n\n            // Binary search for right bound\n            int rightBound = Collections.binarySearch(indices, right);\n            if (rightBound < 0) rightBound = -rightBound - 2;\n            else {\n                // Include the found index\n                while (rightBound + 1 < indices.size() && indices.get(rightBound + 1) == right) {\n                    rightBound++;\n                }\n            }\n\n            return Math.max(0, rightBound - leftBound + 1);\n        }\n    }\n\n    // Range count query (count elements in range [a, b])\n    public static class RangeCountQuery {\n        private int[] nums;\n        private int[] sorted;\n\n        public RangeCountQuery(int[] nums) {\n            this.nums = nums.clone();\n            this.sorted = nums.clone();\n            Arrays.sort(this.sorted);\n        }\n\n        public int rangeCount(int left, int right, int minVal, int maxVal) {\n            int count = 0;\n            for (int i = left; i <= right; i++) {\n                if (nums[i] >= minVal && nums[i] <= maxVal) {\n                    count++;\n                }\n            }\n            return count;\n        }\n\n        public int countInArray(int minVal, int maxVal) {\n            int leftBound = lowerBound(sorted, minVal);\n            int rightBound = upperBound(sorted, maxVal);\n            return rightBound - leftBound;\n        }\n\n        private int lowerBound(int[] arr, int target) {\n            int left = 0, right = arr.length;\n            while (left < right) {\n                int mid = left + (right - left) / 2;\n                if (arr[mid] < target) {\n                    left = mid + 1;\n                } else {\n                    right = mid;\n                }\n            }\n            return left;\n        }\n\n        private int upperBound(int[] arr, int target) {\n            int left = 0, right = arr.length;\n            while (left < right) {\n                int mid = left + (right - left) / 2;\n                if (arr[mid] <= target) {\n                    left = mid + 1;\n                } else {\n                    right = mid;\n                }\n            }\n            return left;\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"42-dynamic-range-queries",children:"4.2 Dynamic Range Queries"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Range queries with updates\npublic class DynamicRangeQueries {\n\n    // Range sum query - mutable\n    public static class NumArrayMutable {\n        private int[] nums;\n        private int[] prefixSum;\n\n        public NumArrayMutable(int[] nums) {\n            this.nums = nums.clone();\n            this.prefixSum = new int[nums.length + 1];\n            buildPrefixSum();\n        }\n\n        private void buildPrefixSum() {\n            for (int i = 0; i < nums.length; i++) {\n                prefixSum[i + 1] = prefixSum[i] + nums[i];\n            }\n        }\n\n        public void update(int index, int val) {\n            nums[index] = val;\n            buildPrefixSum(); // Rebuild - O(n) operation\n        }\n\n        public int sumRange(int left, int right) {\n            return prefixSum[right + 1] - prefixSum[left];\n        }\n    }\n\n    // Optimized mutable range sum using difference array for range updates\n    public static class OptimizedRangeSumUpdate {\n        private int[] diff;\n        private int[] original;\n\n        public OptimizedRangeSumUpdate(int[] nums) {\n            original = nums.clone();\n            diff = new int[nums.length + 1];\n\n            // Build difference array\n            for (int i = 0; i < nums.length; i++) {\n                diff[i] = nums[i] - (i > 0 ? nums[i - 1] : 0);\n            }\n        }\n\n        // Range update: add val to all elements in [left, right]\n        public void rangeUpdate(int left, int right, int val) {\n            diff[left] += val;\n            if (right + 1 < diff.length) {\n                diff[right + 1] -= val;\n            }\n        }\n\n        // Point query: get current value at index\n        public int pointQuery(int index) {\n            int sum = 0;\n            for (int i = 0; i <= index; i++) {\n                sum += diff[i];\n            }\n            return sum;\n        }\n\n        // Rebuild original array after all updates\n        public int[] getUpdatedArray() {\n            int[] result = new int[original.length];\n            int sum = 0;\n            for (int i = 0; i < result.length; i++) {\n                sum += diff[i];\n                result[i] = sum;\n            }\n            return result;\n        }\n\n        // Range sum query after all updates\n        public int sumRange(int left, int right) {\n            int[] updated = getUpdatedArray();\n            int sum = 0;\n            for (int i = left; i <= right; i++) {\n                sum += updated[i];\n            }\n            return sum;\n        }\n    }\n\n    // Square root decomposition for range queries\n    public static class SqrtDecomposition {\n        private int[] nums;\n        private int[] blocks;\n        private int blockSize;\n        private int blockCount;\n\n        public SqrtDecomposition(int[] nums) {\n            this.nums = nums.clone();\n            this.blockSize = (int) Math.ceil(Math.sqrt(nums.length));\n            this.blockCount = (int) Math.ceil((double) nums.length / blockSize);\n            this.blocks = new int[blockCount];\n\n            // Precompute block sums\n            for (int i = 0; i < nums.length; i++) {\n                blocks[i / blockSize] += nums[i];\n            }\n        }\n\n        public void update(int index, int val) {\n            int blockIndex = index / blockSize;\n            blocks[blockIndex] = blocks[blockIndex] - nums[index] + val;\n            nums[index] = val;\n        }\n\n        public int sumRange(int left, int right) {\n            int sum = 0;\n            int leftBlock = left / blockSize;\n            int rightBlock = right / blockSize;\n\n            if (leftBlock == rightBlock) {\n                // Both in same block\n                for (int i = left; i <= right; i++) {\n                    sum += nums[i];\n                }\n            } else {\n                // Sum partial left block\n                for (int i = left; i < (leftBlock + 1) * blockSize; i++) {\n                    sum += nums[i];\n                }\n\n                // Sum complete middle blocks\n                for (int i = leftBlock + 1; i < rightBlock; i++) {\n                    sum += blocks[i];\n                }\n\n                // Sum partial right block\n                for (int i = rightBlock * blockSize; i <= right; i++) {\n                    sum += nums[i];\n                }\n            }\n\n            return sum;\n        }\n    }\n\n    // Mo's algorithm for offline range queries\n    public static class MoAlgorithm {\n        private int[] nums;\n        private int blockSize;\n\n        static class Query {\n            int left, right, index;\n\n            Query(int left, int right, int index) {\n                this.left = left;\n                this.right = right;\n                this.index = index;\n            }\n        }\n\n        public MoAlgorithm(int[] nums) {\n            this.nums = nums;\n            this.blockSize = (int) Math.ceil(Math.sqrt(nums.length));\n        }\n\n        public int[] processQueries(int[][] queries) {\n            int n = queries.length;\n            Query[] queryList = new Query[n];\n\n            for (int i = 0; i < n; i++) {\n                queryList[i] = new Query(queries[i][0], queries[i][1], i);\n            }\n\n            // Sort queries by Mo's order\n            Arrays.sort(queryList, (a, b) -> {\n                int blockA = a.left / blockSize;\n                int blockB = b.left / blockSize;\n                if (blockA != blockB) {\n                    return Integer.compare(blockA, blockB);\n                }\n                return Integer.compare(a.right, b.right);\n            });\n\n            int[] answers = new int[n];\n            int currentLeft = 0, currentRight = -1;\n            int currentSum = 0;\n\n            for (Query query : queryList) {\n                // Extend or shrink current range to match query range\n                while (currentRight < query.right) {\n                    currentRight++;\n                    currentSum += nums[currentRight];\n                }\n\n                while (currentLeft > query.left) {\n                    currentLeft--;\n                    currentSum += nums[currentLeft];\n                }\n\n                while (currentRight > query.right) {\n                    currentSum -= nums[currentRight];\n                    currentRight--;\n                }\n\n                while (currentLeft < query.left) {\n                    currentSum -= nums[currentLeft];\n                    currentLeft++;\n                }\n\n                answers[query.index] = currentSum;\n            }\n\n            return answers;\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-5-2d-prefix-sum",children:"Pattern 5: 2D Prefix Sum"}),"\n",(0,t.jsx)(e.h3,{id:"51-2d-range-sum-queries",children:"5.1 2D Range Sum Queries"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// 2D prefix sum for matrix range queries\npublic class TwoDPrefixSum {\n\n    // Basic 2D range sum query - immutable\n    public static class NumMatrix {\n        private int[][] prefixSum;\n\n        public NumMatrix(int[][] matrix) {\n            if (matrix.length == 0 || matrix[0].length == 0) {\n                prefixSum = new int[1][1];\n                return;\n            }\n\n            int m = matrix.length, n = matrix[0].length;\n            prefixSum = new int[m + 1][n + 1];\n\n            // Build 2D prefix sum\n            for (int i = 1; i <= m; i++) {\n                for (int j = 1; j <= n; j++) {\n                    prefixSum[i][j] = matrix[i - 1][j - 1] +\n                                     prefixSum[i - 1][j] +\n                                     prefixSum[i][j - 1] -\n                                     prefixSum[i - 1][j - 1];\n                }\n            }\n        }\n\n        public int sumRegion(int row1, int col1, int row2, int col2) {\n            return prefixSum[row2 + 1][col2 + 1] -\n                   prefixSum[row1][col2 + 1] -\n                   prefixSum[row2 + 1][col1] +\n                   prefixSum[row1][col1];\n        }\n\n        public double averageRegion(int row1, int col1, int row2, int col2) {\n            int sum = sumRegion(row1, col1, row2, col2);\n            int area = (row2 - row1 + 1) * (col2 - col1 + 1);\n            return (double) sum / area;\n        }\n    }\n\n    // Count number of 1s in binary matrix regions\n    public static class BinaryMatrixRangeQuery {\n        private int[][] prefixCount;\n\n        public BinaryMatrixRangeQuery(int[][] matrix) {\n            int m = matrix.length, n = matrix[0].length;\n            prefixCount = new int[m + 1][n + 1];\n\n            for (int i = 1; i <= m; i++) {\n                for (int j = 1; j <= n; j++) {\n                    prefixCount[i][j] = matrix[i - 1][j - 1] +\n                                       prefixCount[i - 1][j] +\n                                       prefixCount[i][j - 1] -\n                                       prefixCount[i - 1][j - 1];\n                }\n            }\n        }\n\n        public int countOnes(int row1, int col1, int row2, int col2) {\n            return prefixCount[row2 + 1][col2 + 1] -\n                   prefixCount[row1][col2 + 1] -\n                   prefixCount[row2 + 1][col1] +\n                   prefixCount[row1][col1];\n        }\n\n        public int countZeros(int row1, int col1, int row2, int col2) {\n            int totalCells = (row2 - row1 + 1) * (col2 - col1 + 1);\n            return totalCells - countOnes(row1, col1, row2, col2);\n        }\n    }\n\n    // Find largest rectangle with all 1s\n    public int maximalRectangle(char[][] matrix) {\n        if (matrix.length == 0) return 0;\n\n        int m = matrix.length, n = matrix[0].length;\n        int[] heights = new int[n];\n        int maxArea = 0;\n\n        for (int i = 0; i < m; i++) {\n            // Update heights for current row\n            for (int j = 0; j < n; j++) {\n                heights[j] = matrix[i][j] == '1' ? heights[j] + 1 : 0;\n            }\n\n            // Find largest rectangle in histogram\n            maxArea = Math.max(maxArea, largestRectangleInHistogram(heights));\n        }\n\n        return maxArea;\n    }\n\n    private int largestRectangleInHistogram(int[] heights) {\n        Stack<Integer> stack = new Stack<>();\n        int maxArea = 0;\n\n        for (int i = 0; i <= heights.length; i++) {\n            int h = (i == heights.length) ? 0 : heights[i];\n\n            while (!stack.isEmpty() && heights[stack.peek()] > h) {\n                int height = heights[stack.pop()];\n                int width = stack.isEmpty() ? i : i - stack.peek() - 1;\n                maxArea = Math.max(maxArea, height * width);\n            }\n\n            stack.push(i);\n        }\n\n        return maxArea;\n    }\n\n    // Count square submatrices with all 1s\n    public int countSquares(int[][] matrix) {\n        int m = matrix.length, n = matrix[0].length;\n        int[][] dp = new int[m][n];\n        int count = 0;\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (matrix[i][j] == 1) {\n                    if (i == 0 || j == 0) {\n                        dp[i][j] = 1;\n                    } else {\n                        dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]),\n                                           dp[i - 1][j - 1]) + 1;\n                    }\n                    count += dp[i][j];\n                }\n            }\n        }\n\n        return count;\n    }\n\n    // Find submatrix with target sum\n    public boolean hasSubmatrixWithSum(int[][] matrix, int target) {\n        int m = matrix.length, n = matrix[0].length;\n\n        // For each pair of rows\n        for (int top = 0; top < m; top++) {\n            int[] temp = new int[n];\n\n            for (int bottom = top; bottom < m; bottom++) {\n                // Add current row to temp array\n                for (int k = 0; k < n; k++) {\n                    temp[k] += matrix[bottom][k];\n                }\n\n                // Check if any subarray in temp has sum equal to target\n                if (hasSubarrayWithSum(temp, target)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    private boolean hasSubarrayWithSum(int[] arr, int target) {\n        Set<Integer> prefixSums = new HashSet<>();\n        prefixSums.add(0);\n\n        int prefixSum = 0;\n        for (int num : arr) {\n            prefixSum += num;\n\n            if (prefixSums.contains(prefixSum - target)) {\n                return true;\n            }\n\n            prefixSums.add(prefixSum);\n        }\n\n        return false;\n    }\n\n    // 2D range sum with updates using 2D Binary Indexed Tree\n    public static class Matrix2DBIT {\n        private int[][] tree;\n        private int m, n;\n\n        public Matrix2DBIT(int[][] matrix) {\n            if (matrix.length == 0) return;\n\n            m = matrix.length;\n            n = matrix[0].length;\n            tree = new int[m + 1][n + 1];\n\n            for (int i = 0; i < m; i++) {\n                for (int j = 0; j < n; j++) {\n                    update(i, j, matrix[i][j]);\n                }\n            }\n        }\n\n        public void update(int row, int col, int val) {\n            for (int i = row + 1; i <= m; i += i & (-i)) {\n                for (int j = col + 1; j <= n; j += j & (-j)) {\n                    tree[i][j] += val;\n                }\n            }\n        }\n\n        public int query(int row, int col) {\n            int sum = 0;\n            for (int i = row + 1; i > 0; i -= i & (-i)) {\n                for (int j = col + 1; j > 0; j -= j & (-j)) {\n                    sum += tree[i][j];\n                }\n            }\n            return sum;\n        }\n\n        public int sumRegion(int row1, int col1, int row2, int col2) {\n            return query(row2, col2) - query(row1 - 1, col2) -\n                   query(row2, col1 - 1) + query(row1 - 1, col1 - 1);\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"52-advanced-2d-problems",children:"5.2 Advanced 2D Problems"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Advanced 2D prefix sum applications\npublic class Advanced2DPrefixSum {\n\n    // Largest plus sign of 1s in binary matrix\n    public int orderOfLargestPlusSign(int n, int[][] mines) {\n        int[][] grid = new int[n][n];\n\n        // Initialize grid with 1s\n        for (int i = 0; i < n; i++) {\n            Arrays.fill(grid[i], 1);\n        }\n\n        // Set mines to 0\n        for (int[] mine : mines) {\n            grid[mine[0]][mine[1]] = 0;\n        }\n\n        // DP arrays for four directions\n        int[][] left = new int[n][n];\n        int[][] right = new int[n][n];\n        int[][] up = new int[n][n];\n        int[][] down = new int[n][n];\n\n        // Fill left and up arrays\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) {\n                    left[i][j] = (j == 0) ? 1 : left[i][j - 1] + 1;\n                    up[i][j] = (i == 0) ? 1 : up[i - 1][j] + 1;\n                }\n            }\n        }\n\n        // Fill right and down arrays\n        for (int i = n - 1; i >= 0; i--) {\n            for (int j = n - 1; j >= 0; j--) {\n                if (grid[i][j] == 1) {\n                    right[i][j] = (j == n - 1) ? 1 : right[i][j + 1] + 1;\n                    down[i][j] = (i == n - 1) ? 1 : down[i + 1][j] + 1;\n                }\n            }\n        }\n\n        int maxOrder = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                int order = Math.min(Math.min(left[i][j], right[i][j]),\n                                   Math.min(up[i][j], down[i][j]));\n                maxOrder = Math.max(maxOrder, order);\n            }\n        }\n\n        return maxOrder;\n    }\n\n    // Count number of submatrices with sum in range [target1, target2]\n    public int numSubmatricesInRange(int[][] matrix, int target1, int target2) {\n        int m = matrix.length, n = matrix[0].length;\n        int count = 0;\n\n        for (int top = 0; top < m; top++) {\n            int[] colSum = new int[n];\n\n            for (int bottom = top; bottom < m; bottom++) {\n                // Add current row to column sums\n                for (int k = 0; k < n; k++) {\n                    colSum[k] += matrix[bottom][k];\n                }\n\n                // Count subarrays in colSum with sum in range\n                count += countSubarraysInRange(colSum, target1, target2);\n            }\n        }\n\n        return count;\n    }\n\n    private int countSubarraysInRange(int[] arr, int target1, int target2) {\n        return countSubarraysAtMost(arr, target2) - countSubarraysAtMost(arr, target1 - 1);\n    }\n\n    private int countSubarraysAtMost(int[] arr, int target) {\n        int count = 0;\n\n        for (int i = 0; i < arr.length; i++) {\n            int sum = 0;\n            for (int j = i; j < arr.length; j++) {\n                sum += arr[j];\n                if (sum <= target) {\n                    count++;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        return count;\n    }\n\n    // Maximum sum rectangle in matrix\n    public int maxSumRectangle(int[][] matrix) {\n        int m = matrix.length, n = matrix[0].length;\n        int maxSum = Integer.MIN_VALUE;\n\n        for (int top = 0; top < m; top++) {\n            int[] temp = new int[n];\n\n            for (int bottom = top; bottom < m; bottom++) {\n                // Add current row to temp\n                for (int k = 0; k < n; k++) {\n                    temp[k] += matrix[bottom][k];\n                }\n\n                // Find maximum subarray sum in temp\n                int currentMax = kadaneMaxSum(temp);\n                maxSum = Math.max(maxSum, currentMax);\n            }\n        }\n\n        return maxSum;\n    }\n\n    private int kadaneMaxSum(int[] arr) {\n        int maxSoFar = arr[0];\n        int maxEndingHere = arr[0];\n\n        for (int i = 1; i < arr.length; i++) {\n            maxEndingHere = Math.max(arr[i], maxEndingHere + arr[i]);\n            maxSoFar = Math.max(maxSoFar, maxEndingHere);\n        }\n\n        return maxSoFar;\n    }\n\n    // Count islands using 2D prefix sum approach\n    public int numIslands(char[][] grid) {\n        if (grid.length == 0) return 0;\n\n        int m = grid.length, n = grid[0].length;\n        boolean[][] visited = new boolean[m][n];\n        int count = 0;\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == '1' && !visited[i][j]) {\n                    dfs(grid, visited, i, j);\n                    count++;\n                }\n            }\n        }\n\n        return count;\n    }\n\n    private void dfs(char[][] grid, boolean[][] visited, int i, int j) {\n        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length ||\n            visited[i][j] || grid[i][j] == '0') {\n            return;\n        }\n\n        visited[i][j] = true;\n\n        dfs(grid, visited, i + 1, j);\n        dfs(grid, visited, i - 1, j);\n        dfs(grid, visited, i, j + 1);\n        dfs(grid, visited, i, j - 1);\n    }\n\n    // Find all rectangles with area k\n    public List<int[]> findRectanglesWithArea(int[][] matrix, int k) {\n        List<int[]> result = new ArrayList<>();\n        int m = matrix.length, n = matrix[0].length;\n\n        for (int r1 = 0; r1 < m; r1++) {\n            for (int c1 = 0; c1 < n; c1++) {\n                for (int r2 = r1; r2 < m; r2++) {\n                    for (int c2 = c1; c2 < n; c2++) {\n                        int area = (r2 - r1 + 1) * (c2 - c1 + 1);\n                        if (area == k) {\n                            result.add(new int[]{r1, c1, r2, c2});\n                        }\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-6-prefix-sum-with-modular-arithmetic",children:"Pattern 6: Prefix Sum with Modular Arithmetic"}),"\n",(0,t.jsx)(e.h3,{id:"61-modular-sum-problems",children:"6.1 Modular Sum Problems"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Prefix sum problems involving modular arithmetic\npublic class ModularPrefixSum {\n\n    // Continuous subarray sum (sum is multiple of k)\n    public boolean checkSubarraySum(int[] nums, int k) {\n        Map<Integer, Integer> remainderIndex = new HashMap<>();\n        remainderIndex.put(0, -1); // Handle edge case\n\n        int prefixSum = 0;\n\n        for (int i = 0; i < nums.length; i++) {\n            prefixSum += nums[i];\n            int remainder = prefixSum % k;\n\n            if (remainderIndex.containsKey(remainder)) {\n                // Check if subarray length is at least 2\n                if (i - remainderIndex.get(remainder) > 1) {\n                    return true;\n                }\n            } else {\n                remainderIndex.put(remainder, i);\n            }\n        }\n\n        return false;\n    }\n\n    // Count subarrays with sum divisible by k\n    public int subarraysDivByK(int[] nums, int k) {\n        Map<Integer, Integer> remainderCount = new HashMap<>();\n        remainderCount.put(0, 1); // Empty subarray\n\n        int count = 0;\n        int prefixSum = 0;\n\n        for (int num : nums) {\n            prefixSum += num;\n\n            // Handle negative remainders properly\n            int remainder = ((prefixSum % k) + k) % k;\n\n            count += remainderCount.getOrDefault(remainder, 0);\n            remainderCount.put(remainder, remainderCount.getOrDefault(remainder, 0) + 1);\n        }\n\n        return count;\n    }\n\n    // Make sum divisible by p by removing minimum subarray\n    public int minSubarray(int[] nums, int p) {\n        long totalSum = 0;\n        for (int num : nums) {\n            totalSum += num;\n        }\n\n        int targetRemainder = (int) (totalSum % p);\n        if (targetRemainder == 0) return 0; // Already divisible\n\n        Map<Integer, Integer> remainderIndex = new HashMap<>();\n        remainderIndex.put(0, -1);\n\n        int minLength = nums.length;\n        int prefixSum = 0;\n\n        for (int i = 0; i < nums.length; i++) {\n            prefixSum += nums[i];\n            int currentRemainder = prefixSum % p;\n\n            // We want to remove subarray with remainder = targetRemainder\n            int neededRemainder = (currentRemainder - targetRemainder + p) % p;\n\n            if (remainderIndex.containsKey(neededRemainder)) {\n                minLength = Math.min(minLength, i - remainderIndex.get(neededRemainder));\n            }\n\n            remainderIndex.put(currentRemainder, i);\n        }\n\n        return minLength == nums.length ? -1 : minLength;\n    }\n\n    // Count nice subarrays (exactly k odd numbers)\n    public int numberOfSubarrays(int[] nums, int k) {\n        // Convert to binary: odd = 1, even = 0\n        // Then find subarrays with sum = k\n\n        Map<Integer, Integer> prefixCount = new HashMap<>();\n        prefixCount.put(0, 1);\n\n        int count = 0;\n        int oddCount = 0;\n\n        for (int num : nums) {\n            if (num % 2 == 1) oddCount++;\n\n            count += prefixCount.getOrDefault(oddCount - k, 0);\n            prefixCount.put(oddCount, prefixCount.getOrDefault(oddCount, 0) + 1);\n        }\n\n        return count;\n    }\n\n    // Subarray sums divisible by k with constraints\n    public int subarraysDivByKWithConstraints(int[] nums, int k, int minLength) {\n        Map<Integer, List<Integer>> remainderIndices = new HashMap<>();\n        remainderIndices.put(0, new ArrayList<>(Arrays.asList(-1)));\n\n        int count = 0;\n        int prefixSum = 0;\n\n        for (int i = 0; i < nums.length; i++) {\n            prefixSum += nums[i];\n            int remainder = ((prefixSum % k) + k) % k;\n\n            if (remainderIndices.containsKey(remainder)) {\n                for (int prevIndex : remainderIndices.get(remainder)) {\n                    if (i - prevIndex >= minLength) {\n                        count++;\n                    }\n                }\n            }\n\n            remainderIndices.computeIfAbsent(remainder, key -> new ArrayList<>()).add(i);\n        }\n\n        return count;\n    }\n\n    // Maximum length subarray with sum divisible by k\n    public int maxLengthDivisibleByK(int[] nums, int k) {\n        Map<Integer, Integer> remainderFirstIndex = new HashMap<>();\n        remainderFirstIndex.put(0, -1);\n\n        int maxLength = 0;\n        int prefixSum = 0;\n\n        for (int i = 0; i < nums.length; i++) {\n            prefixSum += nums[i];\n            int remainder = ((prefixSum % k) + k) % k;\n\n            if (remainderFirstIndex.containsKey(remainder)) {\n                maxLength = Math.max(maxLength, i - remainderFirstIndex.get(remainder));\n            } else {\n                remainderFirstIndex.put(remainder, i);\n            }\n        }\n\n        return maxLength;\n    }\n\n    // Count subarrays where sum % k == target\n    public int countSubarraysWithModK(int[] nums, int k, int target) {\n        Map<Integer, Integer> remainderCount = new HashMap<>();\n        remainderCount.put(0, 1);\n\n        int count = 0;\n        int prefixSum = 0;\n\n        for (int num : nums) {\n            prefixSum += num;\n            int remainder = ((prefixSum % k) + k) % k;\n\n            int neededRemainder = ((remainder - target) % k + k) % k;\n            count += remainderCount.getOrDefault(neededRemainder, 0);\n\n            remainderCount.put(remainder, remainderCount.getOrDefault(remainder, 0) + 1);\n        }\n\n        return count;\n    }\n\n    // Subarray with sum congruent to target modulo m\n    public boolean hasSubarrayCongruent(int[] nums, int target, int m) {\n        Set<Integer> remainders = new HashSet<>();\n        remainders.add(0);\n\n        int prefixSum = 0;\n        for (int num : nums) {\n            prefixSum += num;\n            int remainder = ((prefixSum % m) + m) % m;\n            int neededRemainder = ((remainder - target) % m + m) % m;\n\n            if (remainders.contains(neededRemainder)) {\n                return true;\n            }\n\n            remainders.add(remainder);\n        }\n\n        return false;\n    }\n\n    // Find shortest subarray with sum divisible by k\n    public int shortestSubarrayDivisibleByK(int[] nums, int k) {\n        Map<Integer, Integer> remainderIndex = new HashMap<>();\n        remainderIndex.put(0, -1);\n\n        int minLength = Integer.MAX_VALUE;\n        int prefixSum = 0;\n\n        for (int i = 0; i < nums.length; i++) {\n            prefixSum += nums[i];\n            int remainder = ((prefixSum % k) + k) % k;\n\n            if (remainderIndex.containsKey(remainder)) {\n                minLength = Math.min(minLength, i - remainderIndex.get(remainder));\n                // Update with current index for potentially shorter subarrays\n                remainderIndex.put(remainder, i);\n            } else {\n                remainderIndex.put(remainder, i);\n            }\n        }\n\n        return minLength == Integer.MAX_VALUE ? -1 : minLength;\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"62-advanced-modular-applications",children:"6.2 Advanced Modular Applications"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Advanced modular arithmetic with prefix sums\npublic class AdvancedModularPrefixSum {\n\n    // Count pairs (i,j) where (prefix[j] - prefix[i]) % k == 0\n    public long countPairsModK(int[] nums, int k) {\n        Map<Integer, Long> remainderCount = new HashMap<>();\n        remainderCount.put(0, 1L);\n\n        long count = 0;\n        int prefixSum = 0;\n\n        for (int num : nums) {\n            prefixSum += num;\n            int remainder = ((prefixSum % k) + k) % k;\n\n            count += remainderCount.getOrDefault(remainder, 0L);\n            remainderCount.put(remainder, remainderCount.getOrDefault(remainder, 0L) + 1);\n        }\n\n        return count;\n    }\n\n    // Maximum sum subarray with sum divisible by k\n    public int maxSumDivisibleByK(int[] nums, int k) {\n        Map<Integer, Integer> remainderMinPrefix = new HashMap<>();\n        remainderMinPrefix.put(0, 0);\n\n        int maxSum = Integer.MIN_VALUE;\n        int prefixSum = 0;\n\n        for (int num : nums) {\n            prefixSum += num;\n            int remainder = ((prefixSum % k) + k) % k;\n\n            if (remainderMinPrefix.containsKey(remainder)) {\n                int subarraySum = prefixSum - remainderMinPrefix.get(remainder);\n                maxSum = Math.max(maxSum, subarraySum);\n            }\n\n            // Keep track of minimum prefix sum for each remainder\n            if (!remainderMinPrefix.containsKey(remainder) ||\n                prefixSum < remainderMinPrefix.get(remainder)) {\n                remainderMinPrefix.put(remainder, prefixSum);\n            }\n        }\n\n        return maxSum;\n    }\n\n    // Count triangular subarrays (sum = n*(n+1)/2 for some n)\n    public int countTriangularSubarrays(int[] nums) {\n        Map<Integer, Integer> prefixCount = new HashMap<>();\n        prefixCount.put(0, 1);\n\n        Set<Integer> triangularNumbers = generateTriangularNumbers(1000000);\n\n        int count = 0;\n        int prefixSum = 0;\n\n        for (int num : nums) {\n            prefixSum += num;\n\n            for (int triangular : triangularNumbers) {\n                if (triangular > prefixSum) break;\n\n                int target = prefixSum - triangular;\n                count += prefixCount.getOrDefault(target, 0);\n            }\n\n            prefixCount.put(prefixSum, prefixCount.getOrDefault(prefixSum, 0) + 1);\n        }\n\n        return count;\n    }\n\n    private Set<Integer> generateTriangularNumbers(int maxVal) {\n        Set<Integer> triangular = new HashSet<>();\n        int n = 1;\n\n        while (true) {\n            int value = n * (n + 1) / 2;\n            if (value > maxVal) break;\n\n            triangular.add(value);\n            n++;\n        }\n\n        return triangular;\n    }\n\n    // Subarray with GCD of prefix sums equal to k\n    public int countSubarraysWithGCD(int[] nums, int k) {\n        Map<Integer, Integer> prefixCount = new HashMap<>();\n        prefixCount.put(0, 1);\n\n        int count = 0;\n        int prefixSum = 0;\n\n        for (int num : nums) {\n            prefixSum += num;\n\n            // Check all previous prefix sums\n            for (Map.Entry<Integer, Integer> entry : prefixCount.entrySet()) {\n                int prevSum = entry.getKey();\n                if (gcd(Math.abs(prefixSum - prevSum), k) == k) {\n                    count += entry.getValue();\n                }\n            }\n\n            prefixCount.put(prefixSum, prefixCount.getOrDefault(prefixSum, 0) + 1);\n        }\n\n        return count;\n    }\n\n    private int gcd(int a, int b) {\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n\n    // Count subarrays with prime sum\n    public int countPrimeSumSubarrays(int[] nums) {\n        int maxSum = Arrays.stream(nums).sum();\n        boolean[] isPrime = sieveOfEratosthenes(maxSum);\n\n        Map<Integer, Integer> prefixCount = new HashMap<>();\n        prefixCount.put(0, 1);\n\n        int count = 0;\n        int prefixSum = 0;\n\n        for (int num : nums) {\n            prefixSum += num;\n\n            for (Map.Entry<Integer, Integer> entry : prefixCount.entrySet()) {\n                int subarraySum = prefixSum - entry.getKey();\n                if (subarraySum > 1 && subarraySum <= maxSum && isPrime[subarraySum]) {\n                    count += entry.getValue();\n                }\n            }\n\n            prefixCount.put(prefixSum, prefixCount.getOrDefault(prefixSum, 0) + 1);\n        }\n\n        return count;\n    }\n\n    private boolean[] sieveOfEratosthenes(int n) {\n        boolean[] isPrime = new boolean[n + 1];\n        Arrays.fill(isPrime, true);\n        isPrime[0] = isPrime[1] = false;\n\n        for (int i = 2; i * i <= n; i++) {\n            if (isPrime[i]) {\n                for (int j = i * i; j <= n; j += i) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n\n        return isPrime;\n    }\n\n    // Perfect square sum subarrays\n    public int countPerfectSquareSubarrays(int[] nums) {\n        Map<Integer, Integer> prefixCount = new HashMap<>();\n        prefixCount.put(0, 1);\n\n        int count = 0;\n        int prefixSum = 0;\n\n        for (int num : nums) {\n            prefixSum += num;\n\n            for (Map.Entry<Integer, Integer> entry : prefixCount.entrySet()) {\n                int subarraySum = prefixSum - entry.getKey();\n                if (isPerfectSquare(subarraySum)) {\n                    count += entry.getValue();\n                }\n            }\n\n            prefixCount.put(prefixSum, prefixCount.getOrDefault(prefixSum, 0) + 1);\n        }\n\n        return count;\n    }\n\n    private boolean isPerfectSquare(int n) {\n        if (n < 0) return false;\n        int sqrt = (int) Math.sqrt(n);\n        return sqrt * sqrt == n;\n    }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-7-difference-array-techniques",children:"Pattern 7: Difference Array Techniques"}),"\n",(0,t.jsx)(e.h3,{id:"71-range-update-operations",children:"7.1 Range Update Operations"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Difference array for efficient range updates\npublic class DifferenceArrayTechniques {\n\n    // Basic difference array implementation\n    public static class DifferenceArray {\n        private int[] diff;\n        private int[] original;\n\n        public DifferenceArray(int[] nums) {\n            original = nums.clone();\n            diff = new int[nums.length + 1];\n\n            // Build difference array\n            diff[0] = nums[0];\n            for (int i = 1; i < nums.length; i++) {\n                diff[i] = nums[i] - nums[i - 1];\n            }\n        }\n\n        // Range update: add val to all elements in [left, right]\n        public void rangeUpdate(int left, int right, int val) {\n            diff[left] += val;\n            if (right + 1 < diff.length) {\n                diff[right + 1] -= val;\n            }\n        }\n\n        // Get current array after all updates\n        public int[] getArray() {\n            int[] result = new int[original.length];\n            result[0] = diff[0];\n\n            for (int i = 1; i < result.length; i++) {\n                result[i] = result[i - 1] + diff[i];\n            }\n\n            return result;\n        }\n\n        // Point query: get value at specific index\n        public int pointQuery(int index) {\n            int value = 0;\n            for (int i = 0; i <= index; i++) {\n                value += diff[i];\n            }\n            return value;\n        }\n\n        // Range query: get sum in range [left, right]\n        public int rangeQuery(int left, int right) {\n            int[] arr = getArray();\n            int sum = 0;\n            for (int i = left; i <= right; i++) {\n                sum += arr[i];\n            }\n            return sum;\n        }\n    }\n\n    // Range addition problem\n    public int[] getModifiedArray(int length, int[][] updates) {\n        int[] diff = new int[length + 1];\n\n        // Apply all updates to difference array\n        for (int[] update : updates) {\n            int start = update[0];\n            int end = update[1];\n            int val = update[2];\n\n            diff[start] += val;\n            if (end + 1 < diff.length) {\n                diff[end + 1] -= val;\n            }\n        }\n\n        // Convert difference array back to original array\n        int[] result = new int[length];\n        result[0] = diff[0];\n\n        for (int i = 1; i < length; i++) {\n            result[i] = result[i - 1] + diff[i];\n        }\n\n        return result;\n    }\n\n    // Corporate flight bookings\n    public int[] corpFlightBookings(int[][] bookings, int n) {\n        int[] diff = new int[n + 1];\n\n        for (int[] booking : bookings) {\n            int first = booking[0] - 1; // Convert to 0-indexed\n            int last = booking[1] - 1;\n            int seats = booking[2];\n\n            diff[first] += seats;\n            if (last + 1 < diff.length) {\n                diff[last + 1] -= seats;\n            }\n        }\n\n        // Build result using prefix sum\n        int[] result = new int[n];\n        result[0] = diff[0];\n\n        for (int i = 1; i < n; i++) {\n            result[i] = result[i - 1] + diff[i];\n        }\n\n        return result;\n    }\n\n    // Car pooling problem\n    public boolean carPooling(int[][] trips, int capacity) {\n        int[] diff = new int[1001]; // Maximum possible location\n\n        for (int[] trip : trips) {\n            int passengers = trip[0];\n            int start = trip[1];\n            int end = trip[2];\n\n            diff[start] += passengers;\n            diff[end] -= passengers; // Passengers get off at end location\n        }\n\n        // Check if capacity is exceeded at any point\n        int currentPassengers = 0;\n        for (int passengers : diff) {\n            currentPassengers += passengers;\n            if (currentPassengers > capacity) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    // My calendar I (using difference array concept)\n    public static class MyCalendar {\n        private Map<Integer, Integer> events;\n\n        public MyCalendar() {\n            events = new TreeMap<>();\n        }\n\n        public boolean book(int start, int end) {\n            events.put(start, events.getOrDefault(start, 0) + 1);\n            events.put(end, events.getOrDefault(end, 0) - 1);\n\n            int active = 0;\n            for (Map.Entry<Integer, Integer> entry : events.entrySet()) {\n                active += entry.getValue();\n                if (active > 1) {\n                    // Revert the booking\n                    events.put(start, events.get(start) - 1);\n                    events.put(end, events.get(end) + 1);\n\n                    // Clean up zero entries\n                    if (events.get(start) == 0) events.remove(start);\n                    if (events.get(end) == 0) events.remove(end);\n\n                    return false;\n                }\n            }\n\n            return true;\n        }\n    }\n\n    // My calendar II (allow at most 2 overlaps)\n    public static class MyCalendarTwo {\n        private Map<Integer, Integer> events;\n\n        public MyCalendarTwo() {\n            events = new TreeMap<>();\n        }\n\n        public boolean book(int start, int end) {\n            events.put(start, events.getOrDefault(start, 0) + 1);\n            events.put(end, events.getOrDefault(end, 0) - 1);\n\n            int active = 0;\n            for (Map.Entry<Integer, Integer> entry : events.entrySet()) {\n                active += entry.getValue();\n                if (active > 2) {\n                    // Revert the booking\n                    events.put(start, events.get(start) - 1);\n                    events.put(end, events.get(end) + 1);\n\n                    if (events.get(start) == 0) events.remove(start);\n                    if (events.get(end) == 0) events.remove(end);\n\n                    return false;\n                }\n            }\n\n            return true;\n        }\n    }\n\n    // Range sum of sorted subarray sums\n    public int rangeSum(int[] nums, int n, int left, int right) {\n        List<Integer> subarraySums = new ArrayList<>();\n\n        // Generate all subarray sums\n        for (int i = 0; i < n; i++) {\n            int sum = 0;\n            for (int j = i; j < n; j++) {\n                sum += nums[j];\n                subarraySums.add(sum);\n            }\n        }\n\n        // Sort the sums\n        Collections.sort(subarraySums);\n\n        // Calculate range sum\n        int MOD = 1000000007;\n        long result = 0;\n\n        for (int i = left - 1; i < right; i++) {\n            result = (result + subarraySums.get(i)) % MOD;\n        }\n\n        return (int) result;\n    }\n\n    // Apply operations to make array elements equal\n    public int minOperationsToMakeEqual(int[] nums, int target) {\n        int[] diff = new int[nums.length + 1];\n\n        // Convert to difference array\n        diff[0] = nums[0];\n        for (int i = 1; i < nums.length; i++) {\n            diff[i] = nums[i] - nums[i - 1];\n        }\n\n        int operations = 0;\n\n        // Count operations needed for difference array\n        for (int d : diff) {\n            if (d > target) {\n                operations += d - target;\n            }\n        }\n\n        return operations;\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"72-advanced-difference-array-applications",children:"7.2 Advanced Difference Array Applications"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Advanced applications of difference arrays\npublic class AdvancedDifferenceArray {\n\n    // 2D difference array for 2D range updates\n    public static class Matrix2DDifferenceArray {\n        private int[][] diff;\n        private int m, n;\n\n        public Matrix2DDifferenceArray(int m, int n) {\n            this.m = m;\n            this.n = n;\n            this.diff = new int[m + 1][n + 1];\n        }\n\n        public Matrix2DDifferenceArray(int[][] matrix) {\n            this.m = matrix.length;\n            this.n = matrix[0].length;\n            this.diff = new int[m + 1][n + 1];\n\n            // Build 2D difference array\n            for (int i = 0; i < m; i++) {\n                for (int j = 0; j < n; j++) {\n                    rangeUpdate(i, j, i, j, matrix[i][j]);\n                }\n            }\n        }\n\n        // Range update: add val to rectangle [r1, c1] to [r2, c2]\n        public void rangeUpdate(int r1, int c1, int r2, int c2, int val) {\n            diff[r1][c1] += val;\n            diff[r1][c2 + 1] -= val;\n            diff[r2 + 1][c1] -= val;\n            diff[r2 + 1][c2 + 1] += val;\n        }\n\n        // Get the final matrix after all updates\n        public int[][] getMatrix() {\n            int[][] result = new int[m][n];\n\n            // Apply prefix sum to get original values\n            for (int i = 0; i < m; i++) {\n                for (int j = 0; j < n; j++) {\n                    result[i][j] = diff[i][j];\n\n                    if (i > 0) result[i][j] += result[i - 1][j];\n                    if (j > 0) result[i][j] += result[i][j - 1];\n                    if (i > 0 && j > 0) result[i][j] -= result[i - 1][j - 1];\n                }\n            }\n\n            return result;\n        }\n    }\n\n    // Range update with multiplication\n    public static class MultiplicativeDifferenceArray {\n        private double[] multipliers;\n        private int[] original;\n\n        public MultiplicativeDifferenceArray(int[] nums) {\n            original = nums.clone();\n            multipliers = new double[nums.length + 1];\n            Arrays.fill(multipliers, 1.0);\n        }\n\n        // Multiply all elements in [left, right] by factor\n        public void rangeMultiply(int left, int right, double factor) {\n            multipliers[left] *= factor;\n            if (right + 1 < multipliers.length) {\n                multipliers[right + 1] /= factor;\n            }\n        }\n\n        public double[] getArray() {\n            double[] result = new double[original.length];\n            double currentMultiplier = 1.0;\n\n            for (int i = 0; i < original.length; i++) {\n                currentMultiplier *= multipliers[i];\n                result[i] = original[i] * currentMultiplier;\n            }\n\n            return result;\n        }\n    }\n\n    // Minimum number of arrows to burst balloons\n    public int findMinArrowShots(int[][] points) {\n        if (points.length == 0) return 0;\n\n        // Sort by end point\n        Arrays.sort(points, (a, b) -> Integer.compare(a[1], b[1]));\n\n        int arrows = 1;\n        int end = points[0][1];\n\n        for (int i = 1; i < points.length; i++) {\n            if (points[i][0] > end) {\n                arrows++;\n                end = points[i][1];\n            }\n        }\n\n        return arrows;\n    }\n\n    // Meeting rooms II with difference array approach\n    public int minMeetingRooms(int[][] intervals) {\n        Map<Integer, Integer> events = new TreeMap<>();\n\n        for (int[] interval : intervals) {\n            events.put(interval[0], events.getOrDefault(interval[0], 0) + 1);\n            events.put(interval[1], events.getOrDefault(interval[1], 0) - 1);\n        }\n\n        int maxRooms = 0;\n        int currentRooms = 0;\n\n        for (int change : events.values()) {\n            currentRooms += change;\n            maxRooms = Math.max(maxRooms, currentRooms);\n        }\n\n        return maxRooms;\n    }\n\n    // Maximum height after queries\n    public int[] maximumHeight(int[][] queries) {\n        Map<Integer, Integer> changes = new TreeMap<>();\n\n        for (int[] query : queries) {\n            int left = query[0];\n            int right = query[1];\n            int height = query[2];\n\n            changes.put(left, changes.getOrDefault(left, 0) + height);\n            changes.put(right + 1, changes.getOrDefault(right + 1, 0) - height);\n        }\n\n        int maxHeight = 0;\n        int currentHeight = 0;\n\n        for (int change : changes.values()) {\n            currentHeight += change;\n            maxHeight = Math.max(maxHeight, currentHeight);\n        }\n\n        return new int[]{maxHeight};\n    }\n    public List<Integer> fallingSquares(int[][] positions) {\n        List<Integer> result = new ArrayList<>();\n        List<Interval> intervals = new ArrayList<>();\n\n        for (int[] pos : positions) {\n            int left = pos[0];\n            int right = pos[0] + pos[1] - 1;\n            int height = pos[1];\n\n            int maxHeight = 0;\n\n            // Find maximum height in the range\n            for (Interval interval : intervals) {\n                if (interval.left <= right && interval.right >= left) {\n                    maxHeight = Math.max(maxHeight, interval.height);\n                }\n            }\n\n            int newHeight = maxHeight + height;\n            intervals.add(new Interval(left, right, newHeight));\n\n            // Find global maximum height\n            int globalMax = 0;\n            for (Interval interval : intervals) {\n                globalMax = Math.max(globalMax, interval.height);\n            }\n\n            result.add(globalMax);\n        }\n\n        return result;\n    }\n\n    static class Interval {\n        int left, right, height;\n\n        Interval(int left, int right, int height) {\n            this.left = left;\n            this.right = right;\n            this.height = height;\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-8-maximumminimum-subarray-problems",children:"Pattern 8: Maximum/Minimum Subarray Problems"}),"\n",(0,t.jsx)(e.h3,{id:"81-kadanes-algorithm-variants",children:"8.1 Kadane's Algorithm Variants"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Maximum and minimum subarray problems using prefix sum insights\npublic class MaxMinSubarrayProblems {\n\n    // Maximum subarray sum (Kadane's Algorithm)\n    public int maxSubArray(int[] nums) {\n        int maxSoFar = nums[0];\n        int maxEndingHere = nums[0];\n\n        for (int i = 1; i < nums.length; i++) {\n            maxEndingHere = Math.max(nums[i], maxEndingHere + nums[i]);\n            maxSoFar = Math.max(maxSoFar, maxEndingHere);\n        }\n\n        return maxSoFar;\n    }\n\n    // Maximum subarray sum with at most k negations allowed\n    public int maxSubarrayWithKNegations(int[] nums, int k) {\n        int n = nums.length;\n        Integer[][] memo = new Integer[n][k + 1];\n        return maxSubarrayHelper(nums, 0, k, memo);\n    }\n\n    private int maxSubarrayHelper(int[] nums, int index, int k, Integer[][] memo) {\n        if (index >= nums.length) return 0;\n\n        if (memo[index][k] != null) return memo[index][k];\n\n        // Don't take current element\n        int skipCurrent = maxSubarrayHelper(nums, index + 1, k, memo);\n\n        // Take current element without negation\n        int takeCurrent = nums[index] + Math.max(0, maxSubarrayHelper(nums, index + 1, k, memo));\n\n        // Take current element with negation (if k > 0)\n        int takeNegated = Integer.MIN_VALUE;\n        if (k > 0) {\n            takeNegated = -nums[index] + Math.max(0, maxSubarrayHelper(nums, index + 1, k - 1, memo));\n        }\n\n        int result = Math.max(skipCurrent, Math.max(takeCurrent, takeNegated));\n        memo[index][k] = result;\n        return result;\n    }\n\n    // Maximum subarray product\n    public int maxProduct(int[] nums) {\n        int maxSoFar = nums[0];\n        int maxHere = nums[0];\n        int minHere = nums[0];\n\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i] < 0) {\n                int temp = maxHere;\n                maxHere = minHere;\n                minHere = temp;\n            }\n\n            maxHere = Math.max(nums[i], maxHere * nums[i]);\n            minHere = Math.min(nums[i], minHere * nums[i]);\n\n            maxSoFar = Math.max(maxSoFar, maxHere);\n        }\n\n        return maxSoFar;\n    }\n\n    // Maximum sum of non-adjacent elements\n    public int rob(int[] nums) {\n        if (nums.length == 0) return 0;\n        if (nums.length == 1) return nums[0];\n\n        int prev2 = nums[0];\n        int prev1 = Math.max(nums[0], nums[1]);\n\n        for (int i = 2; i < nums.length; i++) {\n            int current = Math.max(prev1, prev2 + nums[i]);\n            prev2 = prev1;\n            prev1 = current;\n        }\n\n        return prev1;\n    }\n\n    // Maximum sum circular subarray\n    public int maxSubarraySumCircular(int[] arr) {\n        int totalSum = Arrays.stream(arr).sum();\n\n        // Case 1: Maximum subarray is non-circular\n        int maxKadane = kadaneMax(arr);\n\n        // Case 2: Maximum subarray is circular (total - minimum subarray)\n        int minKadane = kadaneMin(arr);\n        int maxCircular = totalSum - minKadane;\n\n        // Handle edge case: all elements negative\n        return maxCircular == 0 ? maxKadane : Math.max(maxKadane, maxCircular);\n    }\n\n    private int kadaneMax(int[] arr) {\n        int max = arr[0], current = arr[0];\n        for (int i = 1; i < arr.length; i++) {\n            current = Math.max(arr[i], current + arr[i]);\n            max = Math.max(max, current);\n        }\n        return max;\n    }\n\n    private int kadaneMin(int[] arr) {\n        int min = arr[0], current = arr[0];\n        for (int i = 1; i < arr.length; i++) {\n            current = Math.min(arr[i], current + arr[i]);\n            min = Math.min(min, current);\n        }\n        return min;\n    }\n\n    // Maximum subarray sum after at most k operations (increment any element)\n    public int maxSubarrayAfterKOperations(int[] nums, int k) {\n        // Find minimum element and its count\n        int minVal = Arrays.stream(nums).min().orElse(0);\n        long minCount = Arrays.stream(nums).filter(x -> x == minVal).count();\n\n        // If we can make all negative elements zero\n        if (minVal < 0 && k >= -minVal * minCount) {\n            int remaining = (int)(k + minVal * minCount);\n\n            // After making negatives zero, add remaining operations to maximum element\n            int sum = Arrays.stream(nums).map(x -> Math.max(0, x)).sum();\n            int maxVal = Arrays.stream(nums).max().orElse(0);\n\n            return sum + remaining;\n        }\n\n        // Otherwise, use operations on the minimum elements\n        int[] modified = nums.clone();\n        for (int i = 0; i < modified.length && k > 0; i++) {\n            if (modified[i] == minVal) {\n                int increment = Math.min(k, -minVal);\n                modified[i] += increment;\n                k -= increment;\n            }\n        }\n\n        return kadaneMax(modified);\n    }\n\n    // Minimum subarray sum\n    public int minSubArray(int[] nums) {\n        int minSoFar = nums[0];\n        int minEndingHere = nums[0];\n\n        for (int i = 1; i < nums.length; i++) {\n            minEndingHere = Math.min(nums[i], minEndingHere + nums[i]);\n            minSoFar = Math.min(minSoFar, minEndingHere);\n        }\n\n        return minSoFar;\n    }\n\n    // Maximum sum subarray of size k\n    public int maxSumSubarrayOfSizeK(int[] nums, int k) {\n        if (nums.length < k) return Integer.MIN_VALUE;\n\n        // Calculate sum of first window\n        int windowSum = 0;\n        for (int i = 0; i < k; i++) {\n            windowSum += nums[i];\n        }\n\n        int maxSum = windowSum;\n\n        // Slide the window\n        for (int i = k; i < nums.length; i++) {\n            windowSum = windowSum - nums[i - k] + nums[i];\n            maxSum = Math.max(maxSum, windowSum);\n        }\n\n        return maxSum;\n    }\n\n    // Maximum average subarray of length k\n    public double findMaxAverage(int[] nums, int k) {\n        int sum = 0;\n        for (int i = 0; i < k; i++) {\n            sum += nums[i];\n        }\n\n        int maxSum = sum;\n        for (int i = k; i < nums.length; i++) {\n            sum = sum - nums[i - k] + nums[i];\n            maxSum = Math.max(maxSum, sum);\n        }\n\n        return (double) maxSum / k;\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"82-advanced-maximum-subarray-problems",children:"8.2 Advanced Maximum Subarray Problems"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Advanced maximum subarray variants\npublic class AdvancedMaxSubarray {\n\n    // Maximum sum of 3 non-overlapping subarrays\n    public int[] maxSumOfThreeSubarrays(int[] nums, int k) {\n        int n = nums.length;\n        int[] sums = new int[n - k + 1];\n\n        // Calculate sum of each k-length subarray\n        int sum = 0;\n        for (int i = 0; i < k; i++) {\n            sum += nums[i];\n        }\n        sums[0] = sum;\n\n        for (int i = 1; i < sums.length; i++) {\n            sum = sum - nums[i - 1] + nums[i + k - 1];\n            sums[i] = sum;\n        }\n\n        // Find best left subarray for each position\n        int[] left = new int[sums.length];\n        int bestLeft = 0;\n        for (int i = 0; i < sums.length; i++) {\n            if (sums[i] > sums[bestLeft]) {\n                bestLeft = i;\n            }\n            left[i] = bestLeft;\n        }\n\n        // Find best right subarray for each position\n        int[] right = new int[sums.length];\n        int bestRight = sums.length - 1;\n        for (int i = sums.length - 1; i >= 0; i--) {\n            if (sums[i] >= sums[bestRight]) {\n                bestRight = i;\n            }\n            right[i] = bestRight;\n        }\n\n        // Find the best combination\n        int maxSum = 0;\n        int[] result = new int[3];\n\n        for (int mid = k; mid < sums.length - k; mid++) {\n            int l = left[mid - k];\n            int r = right[mid + k];\n            int totalSum = sums[l] + sums[mid] + sums[r];\n\n            if (totalSum > maxSum) {\n                maxSum = totalSum;\n                result[0] = l;\n                result[1] = mid;\n                result[2] = r;\n            }\n        }\n\n        return result;\n    }\n\n    // Maximum subarray sum with length at least k\n    public int maxSubarrayLenAtLeastK(int[] nums, int k) {\n        int n = nums.length;\n        int[] prefixSum = new int[n + 1];\n\n        for (int i = 0; i < n; i++) {\n            prefixSum[i + 1] = prefixSum[i] + nums[i];\n        }\n\n        int maxSum = Integer.MIN_VALUE;\n\n        for (int i = 0; i <= n - k; i++) {\n            for (int j = i + k; j <= n; j++) {\n                maxSum = Math.max(maxSum, prefixSum[j] - prefixSum[i]);\n            }\n        }\n\n        return maxSum;\n    }\n\n    // Maximum subarray sum with length exactly k\n    public int maxSubarrayLenExactlyK(int[] nums, int k) {\n        if (nums.length < k) return Integer.MIN_VALUE;\n\n        int[] prefixSum = new int[nums.length + 1];\n        for (int i = 0; i < nums.length; i++) {\n            prefixSum[i + 1] = prefixSum[i] + nums[i];\n        }\n\n        int maxSum = Integer.MIN_VALUE;\n        for (int i = 0; i <= nums.length - k; i++) {\n            maxSum = Math.max(maxSum, prefixSum[i + k] - prefixSum[i]);\n        }\n\n        return maxSum;\n    }\n\n    // Maximum sum of two non-overlapping subarrays\n    public int maxSumTwoNoOverlap(int[] nums, int firstLen, int secondLen) {\n        return Math.max(\n            maxSum2Helper(nums, firstLen, secondLen),\n            maxSum2Helper(nums, secondLen, firstLen)\n        );\n    }\n\n    private int maxSum2Helper(int[] nums, int len1, int len2) {\n        int n = nums.length;\n        int[] prefixSum = new int[n + 1];\n\n        for (int i = 0; i < n; i++) {\n            prefixSum[i + 1] = prefixSum[i] + nums[i];\n        }\n\n        int maxSum = 0;\n\n        // Try all positions for first subarray\n        for (int i = 0; i <= n - len1; i++) {\n            int sum1 = prefixSum[i + len1] - prefixSum[i];\n\n            // Find best second subarray before first\n            int maxBefore = 0;\n            for (int j = 0; j <= i - len2; j++) {\n                maxBefore = Math.max(maxBefore, prefixSum[j + len2] - prefixSum[j]);\n            }\n\n            // Find best second subarray after first\n            int maxAfter = 0;\n            for (int j = i + len1; j <= n - len2; j++) {\n                maxAfter = Math.max(maxAfter, prefixSum[j + len2] - prefixSum[j]);\n            }\n\n            maxSum = Math.max(maxSum, sum1 + Math.max(maxBefore, maxAfter));\n        }\n\n        return maxSum;\n    }\n\n    // Maximum subarray sum after removing at most one element\n    public int maximumSum(int[] arr) {\n        int n = arr.length;\n        if (n == 1) return arr[0];\n\n        int[] maxEndingHere = new int[n]; // Without deletion\n        int[] maxEndingHereWithDel = new int[n]; // With one deletion\n\n        maxEndingHere[0] = arr[0];\n        maxEndingHereWithDel[0] = 0; // Can't delete from single element\n\n        int result = arr[0];\n\n        for (int i = 1; i < n; i++) {\n            maxEndingHere[i] = Math.max(arr[i], maxEndingHere[i - 1] + arr[i]);\n\n            // Either delete current element or extend previous deletion\n            maxEndingHereWithDel[i] = Math.max(\n                maxEndingHere[i - 1], // Delete current\n                maxEndingHereWithDel[i - 1] + arr[i] // Extend with current\n            );\n\n            result = Math.max(result, Math.max(maxEndingHere[i], maxEndingHereWithDel[i]));\n        }\n\n        return result;\n    }\n\n    // Constrained subset sum\n    public int constrainedSubsetSum(int[] nums, int k) {\n        Deque<Integer> deque = new ArrayDeque<>();\n        int[] dp = new int[nums.length];\n\n        for (int i = 0; i < nums.length; i++) {\n            // Remove elements outside window\n            while (!deque.isEmpty() && deque.peekFirst() < i - k) {\n                deque.pollFirst();\n            }\n\n            // Calculate dp[i]\n            dp[i] = nums[i];\n            if (!deque.isEmpty()) {\n                dp[i] = Math.max(dp[i], nums[i] + dp[deque.peekFirst()]);\n            }\n\n            // Maintain decreasing deque\n            while (!deque.isEmpty() && dp[deque.peekLast()] <= dp[i]) {\n                deque.pollLast();\n            }\n\n            if (dp[i] > 0) {\n                deque.offerLast(i);\n            }\n        }\n\n        return Arrays.stream(dp).max().orElse(0);\n    }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-9-binary-indexed-tree-fenwick-tree",children:"Pattern 9: Binary Indexed Tree (Fenwick Tree)"}),"\n",(0,t.jsx)(e.h3,{id:"91-basic-bit-implementation",children:"9.1 Basic BIT Implementation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Binary Indexed Tree for efficient prefix sum queries and updates\npublic class BinaryIndexedTree {\n\n    // Basic Binary Indexed Tree\n    public static class BIT {\n        private int[] tree;\n        private int n;\n\n        public BIT(int size) {\n            this.n = size;\n            this.tree = new int[n + 1];\n        }\n\n        public BIT(int[] nums) {\n            this.n = nums.length;\n            this.tree = new int[n + 1];\n\n            for (int i = 0; i < nums.length; i++) {\n                update(i, nums[i]);\n            }\n        }\n\n        // Update element at index i by adding delta\n        public void update(int i, int delta) {\n            i++; // Convert to 1-indexed\n            while (i <= n) {\n                tree[i] += delta;\n                i += i & (-i); // Add last set bit\n            }\n        }\n\n        // Get prefix sum from 0 to i (inclusive)\n        public int query(int i) {\n            i++; // Convert to 1-indexed\n            int sum = 0;\n            while (i > 0) {\n                sum += tree[i];\n                i -= i & (-i); // Remove last set bit\n            }\n            return sum;\n        }\n\n        // Get range sum from left to right (inclusive)\n        public int rangeQuery(int left, int right) {\n            return query(right) - (left > 0 ? query(left - 1) : 0);\n        }\n\n        // Set element at index i to value\n        public void set(int i, int value) {\n            int currentValue = rangeQuery(i, i);\n            update(i, value - currentValue);\n        }\n\n        // Get element at index i\n        public int get(int i) {\n            return rangeQuery(i, i);\n        }\n\n        // Find the kth smallest element (if tree contains frequencies)\n        public int kthElement(int k) {\n            int sum = 0;\n            int pos = 0;\n            int bitMask = Integer.highestOneBit(n);\n\n            while (bitMask != 0) {\n                int next = pos + bitMask;\n                if (next <= n && sum + tree[next] < k) {\n                    sum += tree[next];\n                    pos = next;\n                }\n                bitMask >>= 1;\n            }\n\n            return pos;\n        }\n    }\n\n    // Range sum query - mutable using BIT\n    public static class NumArrayBIT {\n        private BIT bit;\n        private int[] nums;\n\n        public NumArrayBIT(int[] nums) {\n            this.nums = nums.clone();\n            this.bit = new BIT(nums);\n        }\n\n        public void update(int index, int val) {\n            int delta = val - nums[index];\n            nums[index] = val;\n            bit.update(index, delta);\n        }\n\n        public int sumRange(int left, int right) {\n            return bit.rangeQuery(left, right);\n        }\n    }\n\n    // Count smaller numbers after self\n    public List<Integer> countSmaller(int[] nums) {\n        // Coordinate compression\n        Set<Integer> sorted = new TreeSet<>();\n        for (int num : nums) {\n            sorted.add(num);\n        }\n\n        Map<Integer, Integer> compressed = new HashMap<>();\n        int index = 0;\n        for (int num : sorted) {\n            compressed.put(num, index++);\n        }\n\n        BIT bit = new BIT(sorted.size());\n        List<Integer> result = new ArrayList<>();\n\n        // Process from right to left\n        for (int i = nums.length - 1; i >= 0; i--) {\n            int compressedValue = compressed.get(nums[i]);\n\n            // Count elements smaller than current\n            int count = compressedValue > 0 ? bit.query(compressedValue - 1) : 0;\n            result.add(count);\n\n            // Add current element to BIT\n            bit.update(compressedValue, 1);\n        }\n\n        Collections.reverse(result);\n        return result;\n    }\n\n    // Count of range sum\n    public int countRangeSum(int[] nums, int lower, int upper) {\n        long[] prefixSums = new long[nums.length + 1];\n        for (int i = 0; i < nums.length; i++) {\n            prefixSums[i + 1] = prefixSums[i] + nums[i];\n        }\n\n        // Coordinate compression\n        Set<Long> values = new TreeSet<>();\n        for (long sum : prefixSums) {\n            values.add(sum);\n            values.add(sum - lower);\n            values.add(sum - upper);\n        }\n\n        Map<Long, Integer> compressed = new HashMap<>();\n        int index = 0;\n        for (long value : values) {\n            compressed.put(value, index++);\n        }\n\n        BIT bit = new BIT(values.size());\n        int count = 0;\n\n        for (long sum : prefixSums) {\n            // Count valid ranges ending at current position\n            int lowerBound = compressed.get(sum - upper);\n            int upperBound = compressed.get(sum - lower);\n\n            count += bit.rangeQuery(lowerBound, upperBound);\n\n            // Add current prefix sum to BIT\n            bit.update(compressed.get(sum), 1);\n        }\n\n        return count;\n    }\n\n    // Reverse pairs\n    public int reversePairs(int[] nums) {\n        // Use merge sort approach with BIT for counting\n        return mergeSortAndCount(nums, 0, nums.length - 1);\n    }\n\n    private int mergeSortAndCount(int[] nums, int start, int end) {\n        if (start >= end) return 0;\n\n        int mid = start + (end - start) / 2;\n        int count = mergeSortAndCount(nums, start, mid) +\n                   mergeSortAndCount(nums, mid + 1, end);\n\n        // Count reverse pairs\n        int j = mid + 1;\n        for (int i = start; i <= mid; i++) {\n            while (j <= end && (long) nums[i] > 2L * nums[j]) {\n                j++;\n            }\n            count += j - (mid + 1);\n        }\n\n        // Merge\n        int[] temp = new int[end - start + 1];\n        int i = start, k = mid + 1, t = 0;\n\n        while (i <= mid && k <= end) {\n            if (nums[i] <= nums[k]) {\n                temp[t++] = nums[i++];\n            } else {\n                temp[t++] = nums[k++];\n            }\n        }\n\n        while (i <= mid) temp[t++] = nums[i++];\n        while (k <= end) temp[t++] = nums[k++];\n\n        System.arraycopy(temp, 0, nums, start, temp.length);\n\n        return count;\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"92-advanced-bit-applications",children:"9.2 Advanced BIT Applications"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Advanced Binary Indexed Tree applications\npublic class AdvancedBIT {\n\n    // 2D Binary Indexed Tree\n    public static class BIT2D {\n        private int[][] tree;\n        private int m, n;\n\n        public BIT2D(int rows, int cols) {\n            this.m = rows;\n            this.n = cols;\n            this.tree = new int[m + 1][n + 1];\n        }\n\n        public void update(int row, int col, int delta) {\n            for (int i = row + 1; i <= m; i += i & (-i)) {\n                for (int j = col + 1; j <= n; j += j & (-j)) {\n                    tree[i][j] += delta;\n                }\n            }\n        }\n\n        public int query(int row, int col) {\n            int sum = 0;\n            for (int i = row + 1; i > 0; i -= i & (-i)) {\n                for (int j = col + 1; j > 0; j -= j & (-j)) {\n                    sum += tree[i][j];\n                }\n            }\n            return sum;\n        }\n\n        public int rangeQuery(int row1, int col1, int row2, int col2) {\n            return query(row2, col2) - query(row1 - 1, col2) -\n                   query(row2, col1 - 1) + query(row1 - 1, col1 - 1);\n        }\n    }\n\n    // Range update BIT using difference array technique\n    public static class RangeUpdateBIT {\n        private BIT bit;\n\n        public RangeUpdateBIT(int size) {\n            this.bit = new BIT(size);\n        }\n\n        // Add delta to range [left, right]\n        public void rangeUpdate(int left, int right, int delta) {\n            bit.update(left, delta);\n            if (right + 1 < bit.n) {\n                bit.update(right + 1, -delta);\n            }\n        }\n\n        // Get value at index i\n        public int pointQuery(int i) {\n            return bit.query(i);\n        }\n    }\n\n    // Maximum frequency stack using BIT\n    public static class FreqStack {\n        private Map<Integer, Integer> freq;\n        private Map<Integer, Stack<Integer>> stacks;\n        private int maxFreq;\n\n        public FreqStack() {\n            freq = new HashMap<>();\n            stacks = new HashMap<>();\n            maxFreq = 0;\n        }\n\n        public void push(int val) {\n            int f = freq.getOrDefault(val, 0) + 1;\n            freq.put(val, f);\n\n            if (f > maxFreq) {\n                maxFreq = f;\n            }\n\n            stacks.computeIfAbsent(f, k -> new Stack<>()).push(val);\n        }\n\n        public int pop() {\n            Stack<Integer> stack = stacks.get(maxFreq);\n            int val = stack.pop();\n\n            freq.put(val, freq.get(val) - 1);\n\n            if (stack.isEmpty()) {\n                maxFreq--;\n            }\n\n            return val;\n        }\n    }\n\n    // Longest increasing subsequence with BIT\n    public int lengthOfLIS(int[] nums) {\n        // Coordinate compression\n        Set<Integer> sorted = new TreeSet<>();\n        for (int num : nums) {\n            sorted.add(num);\n        }\n\n        Map<Integer, Integer> compressed = new HashMap<>();\n        int index = 1;\n        for (int num : sorted) {\n            compressed.put(num, index++);\n        }\n\n        BIT bit = new BIT(sorted.size());\n\n        for (int num : nums) {\n            int compressedValue = compressed.get(num);\n\n            // Query maximum LIS length for values < current\n            int lisLength = compressedValue > 1 ? bit.query(compressedValue - 1) : 0;\n\n            // Update BIT with new LIS length ending at current value\n            int currentMax = bit.rangeQuery(compressedValue - 1, compressedValue - 1);\n            if (lisLength + 1 > currentMax) {\n                bit.update(compressedValue - 1, lisLength + 1 - currentMax);\n            }\n        }\n\n        return bit.query(sorted.size() - 1);\n    }\n\n    // Range minimum query using BIT (with coordinate compression)\n    public static class RMQWithBIT {\n        private BIT bit;\n        private Map<Integer, Integer> compressed;\n        private int[] values;\n\n        public RMQWithBIT(int[] nums) {\n            Set<Integer> unique = new TreeSet<>();\n            for (int num : nums) {\n                unique.add(num);\n            }\n\n            compressed = new HashMap<>();\n            values = new int[unique.size()];\n            int index = 0;\n\n            for (int num : unique) {\n                compressed.put(num, index);\n                values[index] = num;\n                index++;\n            }\n\n            bit = new BIT(unique.size());\n\n            for (int num : nums) {\n                bit.update(compressed.get(num), 1);\n            }\n        }\n\n        public int rangeMin(int left, int right, int[] originalArray) {\n            // This is a simplified version - actual RMQ with BIT is more complex\n            int min = Integer.MAX_VALUE;\n            for (int i = left; i <= right; i++) {\n                min = Math.min(min, originalArray[i]);\n            }\n            return min;\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-10-segment-tree-for-range-queries",children:"Pattern 10: Segment Tree for Range Queries"}),"\n",(0,t.jsx)(e.h3,{id:"101-basic-segment-tree",children:"10.1 Basic Segment Tree"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Segment Tree for range queries and updates\npublic class SegmentTree {\n\n    // Basic Segment Tree for range sum queries\n    public static class RangeSumSegmentTree {\n        private int[] tree;\n        private int n;\n\n        public RangeSumSegmentTree(int[] nums) {\n            n = nums.length;\n            tree = new int[4 * n];\n            build(nums, 0, 0, n - 1);\n        }\n\n        private void build(int[] nums, int node, int start, int end) {\n            if (start == end) {\n                tree[node] = nums[start];\n            } else {\n                int mid = (start + end) / 2;\n                build(nums, 2 * node + 1, start, mid);\n                build(nums, 2 * node + 2, mid + 1, end);\n                tree[node] = tree[2 * node + 1] + tree[2 * node + 2];\n            }\n        }\n\n        public void update(int index, int val) {\n            update(0, 0, n - 1, index, val);\n        }\n\n        private void update(int node, int start, int end, int index, int val) {\n            if (start == end) {\n                tree[node] = val;\n            } else {\n                int mid = (start + end) / 2;\n                if (index <= mid) {\n                    update(2 * node + 1, start, mid, index, val);\n                } else {\n                    update(2 * node + 2, mid + 1, end, index, val);\n                }\n                tree[node] = tree[2 * node + 1] + tree[2 * node + 2];\n            }\n        }\n\n        public int query(int left, int right) {\n            return query(0, 0, n - 1, left, right);\n        }\n\n        private int query(int node, int start, int end, int left, int right) {\n            if (right < start || end < left) {\n                return 0;\n            }\n            if (left <= start && end <= right) {\n                return tree[node];\n            }\n\n            int mid = (start + end) / 2;\n            int leftSum = query(2 * node + 1, start, mid, left, right);\n            int rightSum = query(2 * node + 2, mid + 1, end, left, right);\n            return leftSum + rightSum;\n        }\n    }\n\n    // Segment Tree with lazy propagation for range updates\n    public static class LazySegmentTree {\n        private long[] tree;\n        private long[] lazy;\n        private int n;\n\n        public LazySegmentTree(int size) {\n            n = size;\n            tree = new long[4 * n];\n            lazy = new long[4 * n];\n        }\n\n        private void push(int node, int start, int end) {\n            if (lazy[node] != 0) {\n                tree[node] += lazy[node] * (end - start + 1);\n\n                if (start != end) {\n                    lazy[2 * node + 1] += lazy[node];\n                    lazy[2 * node + 2] += lazy[node];\n                }\n\n                lazy[node] = 0;\n            }\n        }\n\n        public void rangeUpdate(int left, int right, int val) {\n            rangeUpdate(0, 0, n - 1, left, right, val);\n        }\n\n        private void rangeUpdate(int node, int start, int end, int left, int right, int val) {\n            push(node, start, end);\n\n            if (start > right || end < left) {\n                return;\n            }\n\n            if (left <= start && end <= right) {\n                lazy[node] += val;\n                push(node, start, end);\n                return;\n            }\n\n            int mid = (start + end) / 2;\n            rangeUpdate(2 * node + 1, start, mid, left, right, val);\n            rangeUpdate(2 * node + 2, mid + 1, end, left, right, val);\n\n            push(2 * node + 1, start, mid);\n            push(2 * node + 2, mid + 1, end);\n            tree[node] = tree[2 * node + 1] + tree[2 * node + 2];\n        }\n\n        public long query(int left, int right) {\n            return query(0, 0, n - 1, left, right);\n        }\n\n        private long query(int node, int start, int end, int left, int right) {\n            if (start > right || end < left) {\n                return 0;\n            }\n\n            push(node, start, end);\n\n            if (left <= start && end <= right) {\n                return tree[node];\n            }\n\n            int mid = (start + end) / 2;\n            long leftSum = query(2 * node + 1, start, mid, left, right);\n            long rightSum = query(2 * node + 2, mid + 1, end, left, right);\n            return leftSum + rightSum;\n        }\n    }\n\n    // Range minimum query segment tree\n    public static class RMQSegmentTree {\n        private int[] tree;\n        private int n;\n\n        public RMQSegmentTree(int[] nums) {\n            n = nums.length;\n            tree = new int[4 * n];\n            build(nums, 0, 0, n - 1);\n        }\n\n        private void build(int[] nums, int node, int start, int end) {\n            if (start == end) {\n                tree[node] = nums[start];\n            } else {\n                int mid = (start + end) / 2;\n                build(nums, 2 * node + 1, start, mid);\n                build(nums, 2 * node + 2, mid + 1, end);\n                tree[node] = Math.min(tree[2 * node + 1], tree[2 * node + 2]);\n            }\n        }\n\n        public void update(int index, int val) {\n            update(0, 0, n - 1, index, val);\n        }\n\n        private void update(int node, int start, int end, int index, int val) {\n            if (start == end) {\n                tree[node] = val;\n            } else {\n                int mid = (start + end) / 2;\n                if (index <= mid) {\n                    update(2 * node + 1, start, mid, index, val);\n                } else {\n                    update(2 * node + 2, mid + 1, end, index, val);\n                }\n                tree[node] = Math.min(tree[2 * node + 1], tree[2 * node + 2]);\n            }\n        }\n\n        public int query(int left, int right) {\n            return query(0, 0, n - 1, left, right);\n        }\n\n        private int query(int node, int start, int end, int left, int right) {\n            if (right < start || end < left) {\n                return Integer.MAX_VALUE;\n            }\n            if (left <= start && end <= right) {\n                return tree[node];\n            }\n\n            int mid = (start + end) / 2;\n            int leftMin = query(2 * node + 1, start, mid, left, right);\n            int rightMin = query(2 * node + 2, mid + 1, end, left, right);\n            return Math.min(leftMin, rightMin);\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-11-advanced-prefix-sum-applications",children:"Pattern 11: Advanced Prefix Sum Applications"}),"\n",(0,t.jsx)(e.h3,{id:"111-multi-dimensional-problems",children:"11.1 Multi-dimensional Problems"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:'// Advanced prefix sum applications\npublic class AdvancedPrefixSumApplications {\n\n    // Count number of nice subarrays\n    public int numberOfSubarrays(int[] nums, int k) {\n        return atMostK(nums, k) - atMostK(nums, k - 1);\n    }\n\n    private int atMostK(int[] nums, int k) {\n        int left = 0, count = 0, result = 0;\n\n        for (int right = 0; right < nums.length; right++) {\n            if (nums[right] % 2 == 1) {\n                count++;\n            }\n\n            while (count > k) {\n                if (nums[left] % 2 == 1) {\n                    count--;\n                }\n                left++;\n            }\n\n            result += right - left + 1;\n        }\n\n        return result;\n    }\n\n    // Subarrays with k different integers\n    public int subarraysWithKDistinct(int[] nums, int k) {\n        return atMostKDistinct(nums, k) - atMostKDistinct(nums, k - 1);\n    }\n\n    private int atMostKDistinct(int[] nums, int k) {\n        Map<Integer, Integer> count = new HashMap<>();\n        int left = 0, result = 0;\n\n        for (int right = 0; right < nums.length; right++) {\n            count.put(nums[right], count.getOrDefault(nums[right], 0) + 1);\n\n            while (count.size() > k) {\n                count.put(nums[left], count.get(nums[left]) - 1);\n                if (count.get(nums[left]) == 0) {\n                    count.remove(nums[left]);\n                }\n                left++;\n            }\n\n            result += right - left + 1;\n        }\n\n        return result;\n    }\n\n    // Shortest subarray with sum at least K\n    public int shortestSubarray(int[] nums, int k) {\n        int n = nums.length;\n        long[] prefixSum = new long[n + 1];\n\n        for (int i = 0; i < n; i++) {\n            prefixSum[i + 1] = prefixSum[i] + nums[i];\n        }\n\n        Deque<Integer> deque = new ArrayDeque<>();\n        int result = Integer.MAX_VALUE;\n\n        for (int i = 0; i <= n; i++) {\n            // Check if we can form a subarray with sum >= k\n            while (!deque.isEmpty() && prefixSum[i] - prefixSum[deque.peekFirst()] >= k) {\n                result = Math.min(result, i - deque.pollFirst());\n            }\n\n            // Maintain increasing order of prefix sums\n            while (!deque.isEmpty() && prefixSum[deque.peekLast()] >= prefixSum[i]) {\n                deque.pollLast();\n            }\n\n            deque.offerLast(i);\n        }\n\n        return result == Integer.MAX_VALUE ? -1 : result;\n    }\n\n    // Maximum size subarray sum equals k\n    public int maxSubArrayLen(int[] nums, int k) {\n        Map<Integer, Integer> sumToIndex = new HashMap<>();\n        sumToIndex.put(0, -1);\n\n        int maxLen = 0;\n        int sum = 0;\n\n        for (int i = 0; i < nums.length; i++) {\n            sum += nums[i];\n\n            if (sumToIndex.containsKey(sum - k)) {\n                maxLen = Math.max(maxLen, i - sumToIndex.get(sum - k));\n            }\n\n            sumToIndex.putIfAbsent(sum, i);\n        }\n\n        return maxLen;\n    }\n\n    // Contiguous array (equal 0s and 1s)\n    public int findMaxLength(int[] nums) {\n        Map<Integer, Integer> sumToIndex = new HashMap<>();\n        sumToIndex.put(0, -1);\n\n        int maxLen = 0;\n        int sum = 0;\n\n        for (int i = 0; i < nums.length; i++) {\n            sum += (nums[i] == 1) ? 1 : -1;\n\n            if (sumToIndex.containsKey(sum)) {\n                maxLen = Math.max(maxLen, i - sumToIndex.get(sum));\n            } else {\n                sumToIndex.put(sum, i);\n            }\n        }\n\n        return maxLen;\n    }\n\n    // Minimum window substring\n    public String minWindow(String s, String t) {\n        if (s.length() < t.length()) return "";\n\n        Map<Character, Integer> tCount = new HashMap<>();\n        for (char c : t.toCharArray()) {\n            tCount.put(c, tCount.getOrDefault(c, 0) + 1);\n        }\n\n        Map<Character, Integer> windowCount = new HashMap<>();\n        int left = 0, minLen = Integer.MAX_VALUE, minStart = 0;\n        int required = tCount.size(), formed = 0;\n\n        for (int right = 0; right < s.length(); right++) {\n            char c = s.charAt(right);\n            windowCount.put(c, windowCount.getOrDefault(c, 0) + 1);\n\n            if (tCount.containsKey(c) &&\n                windowCount.get(c).intValue() == tCount.get(c).intValue()) {\n                formed++;\n            }\n\n            while (left <= right && formed == required) {\n                if (right - left + 1 < minLen) {\n                    minLen = right - left + 1;\n                    minStart = left;\n                }\n\n                char leftChar = s.charAt(left);\n                windowCount.put(leftChar, windowCount.get(leftChar) - 1);\n\n                if (tCount.containsKey(leftChar) &&\n                    windowCount.get(leftChar) < tCount.get(leftChar)) {\n                    formed--;\n                }\n\n                left++;\n            }\n        }\n\n        return minLen == Integer.MAX_VALUE ? "" : s.substring(minStart, minStart + minLen);\n    }\n}\n'})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-12-optimization-techniques",children:"Pattern 12: Optimization Techniques"}),"\n",(0,t.jsx)(e.h3,{id:"121-space-and-time-optimizations",children:"12.1 Space and Time Optimizations"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Optimization techniques for prefix sum problems\npublic class PrefixSumOptimizations {\n\n    // Space-optimized prefix sum for very large arrays\n    public static class StreamingPrefixSum {\n        private long runningSum;\n        private int count;\n\n        public StreamingPrefixSum() {\n            runningSum = 0;\n            count = 0;\n        }\n\n        public void addNumber(int num) {\n            runningSum += num;\n            count++;\n        }\n\n        public double getAverage() {\n            return count == 0 ? 0 : (double) runningSum / count;\n        }\n\n        public long getSum() {\n            return runningSum;\n        }\n\n        public int getCount() {\n            return count;\n        }\n    }\n\n    // Compressed prefix sum for sparse arrays\n    public static class CompressedPrefixSum {\n        private Map<Integer, Long> prefixSums;\n        private List<Integer> indices;\n\n        public CompressedPrefixSum(Map<Integer, Integer> sparseArray) {\n            prefixSums = new HashMap<>();\n            indices = new ArrayList<>(sparseArray.keySet());\n            Collections.sort(indices);\n\n            long sum = 0;\n            for (int index : indices) {\n                sum += sparseArray.get(index);\n                prefixSums.put(index, sum);\n            }\n        }\n\n        public long rangeSum(int left, int right) {\n            Long rightSum = prefixSums.get(right);\n            Long leftSum = prefixSums.get(left - 1);\n\n            if (rightSum == null) rightSum = getPrefixSum(right);\n            if (leftSum == null) leftSum = getPrefixSum(left - 1);\n\n            return rightSum - leftSum;\n        }\n\n        private long getPrefixSum(int index) {\n            int pos = Collections.binarySearch(indices, index);\n            if (pos >= 0) {\n                return prefixSums.get(indices.get(pos));\n            } else {\n                int insertPos = -pos - 1;\n                if (insertPos == 0) return 0;\n                return prefixSums.get(indices.get(insertPos - 1));\n            }\n        }\n    }\n\n    // Parallel prefix sum computation\n    public static class ParallelPrefixSum {\n\n        public static int[] parallelPrefixSum(int[] nums) {\n            int n = nums.length;\n            int[] result = nums.clone();\n\n            // Use divide and conquer approach\n            computePrefixSum(result, 0, n - 1);\n            return result;\n        }\n\n        private static void computePrefixSum(int[] arr, int left, int right) {\n            if (left >= right) return;\n\n            int mid = left + (right - left) / 2;\n\n            // Recursively compute for both halves\n            computePrefixSum(arr, left, mid);\n            computePrefixSum(arr, mid + 1, right);\n\n            // Add the sum of left half to all elements in right half\n            int leftSum = 0;\n            for (int i = left; i <= mid; i++) {\n                leftSum += arr[i];\n            }\n\n            for (int i = mid + 1; i <= right; i++) {\n                arr[i] += leftSum;\n            }\n        }\n    }\n\n    // Memory-efficient rolling prefix sum\n    public static class RollingPrefixSum {\n        private long sum;\n        private Queue<Integer> window;\n        private int maxSize;\n\n        public RollingPrefixSum(int maxSize) {\n            this.maxSize = maxSize;\n            this.sum = 0;\n            this.window = new LinkedList<>();\n        }\n\n        public void add(int num) {\n            if (window.size() >= maxSize) {\n                sum -= window.poll();\n            }\n\n            window.offer(num);\n            sum += num;\n        }\n\n        public long getSum() {\n            return sum;\n        }\n\n        public double getAverage() {\n            return window.isEmpty() ? 0 : (double) sum / window.size();\n        }\n\n        public int getSize() {\n            return window.size();\n        }\n    }\n\n    // Prefix sum with coordinate compression\n    public static long[] compressedRangeSum(int[] nums, int[][] queries) {\n        Set<Integer> coordinates = new TreeSet<>();\n\n        // Collect all coordinates\n        for (int num : nums) {\n            coordinates.add(num);\n        }\n        for (int[] query : queries) {\n            coordinates.add(query[0]);\n            coordinates.add(query[1]);\n        }\n\n        // Create mapping\n        Map<Integer, Integer> compressed = new HashMap<>();\n        List<Integer> sorted = new ArrayList<>(coordinates);\n        for (int i = 0; i < sorted.size(); i++) {\n            compressed.put(sorted.get(i), i);\n        }\n\n        // Build compressed array\n        long[] compressedArray = new long[sorted.size()];\n        for (int num : nums) {\n            compressedArray[compressed.get(num)]++;\n        }\n\n        // Build prefix sum\n        for (int i = 1; i < compressedArray.length; i++) {\n            compressedArray[i] += compressedArray[i - 1];\n        }\n\n        // Answer queries\n        long[] answers = new long[queries.length];\n        for (int i = 0; i < queries.length; i++) {\n            int left = compressed.get(queries[i][0]);\n            int right = compressed.get(queries[i][1]);\n\n            answers[i] = compressedArray[right] - (left > 0 ? compressedArray[left - 1] : 0);\n        }\n\n        return answers;\n    }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"time--space-complexity-reference",children:"Time & Space Complexity Reference"}),"\n",(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{style:{textAlign:"left"},children:"Pattern"}),(0,t.jsx)(e.th,{style:{textAlign:"left"},children:"Time Complexity"}),(0,t.jsx)(e.th,{style:{textAlign:"left"},children:"Space Complexity"}),(0,t.jsx)(e.th,{style:{textAlign:"left"},children:"Key Use Cases"})]})}),(0,t.jsxs)(e.tbody,{children:[(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Basic Prefix Sum"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(n) build, O(1) query"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Range sum queries"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Prefix Sum + HashMap"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Subarray sum problems"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"2D Prefix Sum"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(mn) build, O(1) query"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(mn)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Matrix range queries"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Difference Array"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(1) range update, O(n) rebuild"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Range updates"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Binary Indexed Tree"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(log n) update/query"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Dynamic range queries"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Segment Tree"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(log n) update/query"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Complex range operations"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Mo's Algorithm"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(n\u221an)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(\u221an)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Offline range queries"})]})]})]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"best-practices--interview-tips",children:"Best Practices & Interview Tips"}),"\n",(0,t.jsx)(e.h3,{id:"prefix-sum-guidelines",children:"Prefix Sum Guidelines"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// 1. Choose the right approach\npublic class PrefixSumBestPractices {\n\n    // For static arrays with range sum queries\n    public void useBasicPrefixSum() {\n        int[] nums = {1, 2, 3, 4, 5};\n        int[] prefixSum = new int[nums.length + 1];\n\n        for (int i = 0; i < nums.length; i++) {\n            prefixSum[i + 1] = prefixSum[i] + nums[i];\n        }\n\n        // Range sum from i to j: prefixSum[j+1] - prefixSum[i]\n    }\n\n    // For subarray sum problems\n    public void usePrefixSumWithHashMap() {\n        Map<Integer, Integer> prefixSumCount = new HashMap<>();\n        prefixSumCount.put(0, 1); // Important: empty subarray\n\n        // Process array and use HashMap for O(1) lookups\n    }\n\n    // For range updates\n    public void useDifferenceArray() {\n        int[] diff = new int[n + 1];\n\n        // Range update [l, r] with value v:\n        // diff[l] += v;\n        // diff[r + 1] -= v;\n\n        // Then build final array with prefix sum\n    }\n\n    // 2. Handle edge cases\n    public boolean handleEdgeCases(int[] nums, int target) {\n        if (nums == null || nums.length == 0) return false;\n\n        Map<Integer, Integer> prefixSum = new HashMap<>();\n        prefixSum.put(0, -1); // Handle empty subarray case\n\n        int sum = 0;\n        for (int i = 0; i < nums.length; i++) {\n            sum += nums[i];\n\n            if (prefixSum.containsKey(sum - target)) {\n                return true;\n            }\n\n            // Only store first occurrence for maximum length problems\n            prefixSum.putIfAbsent(sum, i);\n        }\n\n        return false;\n    }\n\n    // 3. Optimization techniques\n    public void optimizationTips() {\n        // Use long for large sums to prevent overflow\n        long[] prefixSum = new long[n + 1];\n\n        // For modular arithmetic problems\n        Map<Integer, Integer> remainderCount = new HashMap<>();\n        remainderCount.put(0, 1);\n\n        int sum = 0;\n        for (int num : nums) {\n            sum += num;\n            int remainder = ((sum % k) + k) % k; // Handle negative numbers\n            // Process remainder...\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"common-pitfalls-to-avoid",children:"Common Pitfalls to Avoid"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Off-by-one errors"}),": Be careful with 0-indexed vs 1-indexed arrays"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Integer overflow"}),": Use ",(0,t.jsx)(e.code,{children:"long"})," for large sum calculations"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"HashMap initialization"}),": Remember to put ",(0,t.jsx)(e.code,{children:"(0, 1)"})," or ",(0,t.jsx)(e.code,{children:"(0, -1)"})," for empty subarray"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Negative modular"}),": Use ",(0,t.jsx)(e.code,{children:"((sum % k) + k) % k"})," for proper modular arithmetic"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Range update bounds"}),": Check array bounds when using difference arrays"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"interview-tips",children:"Interview Tips"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Identify the pattern"}),': Look for "subarray", "range", "sum" keywords']}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Start simple"}),": Begin with basic prefix sum, then optimize if needed"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Draw examples"}),": Visualize prefix sum arrays for better understanding"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Consider trade-offs"}),": Time vs space, static vs dynamic arrays"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Practice variations"}),": Subarray sum, 2D matrix, modular arithmetic"]}),"\n"]})]})}function d(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(o,{...n})}):o(n)}}}]);