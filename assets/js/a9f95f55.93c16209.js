"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[1461],{28453:(n,e,r)=>{r.d(e,{R:()=>s,x:()=>o});var t=r(96540);const i={},a=t.createContext(i);function s(n){const e=t.useContext(a);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:s(n.components),t.createElement(a.Provider,{value:e},n.children)}},64964:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>a,metadata:()=>o,toc:()=>d});var t=r(74848),i=r(28453);const a={},s="Backtracking",o={id:"DSA/DSA with Java/Backtracking Patterns",title:"Backtracking",description:"Table of Contents",source:"@site/docs/DSA/DSA with Java/Backtracking Patterns.mdx",sourceDirName:"DSA/DSA with Java",slug:"/DSA/DSA with Java/Backtracking Patterns",permalink:"/dev.enigma/docs/DSA/DSA with Java/Backtracking Patterns",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with Java/Backtracking Patterns.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Array",permalink:"/dev.enigma/docs/DSA/DSA with Java/Arrays Patterns"},next:{title:"Binary Heap",permalink:"/dev.enigma/docs/DSA/DSA with Java/Binary Heap Patterns"}},l={},d=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Backtracking Template",id:"backtracking-template",level:2},{value:"Core Template Structure",id:"core-template-structure",level:3},{value:"Key Components",id:"key-components",level:3},{value:"Pattern 1: Subset Generation",id:"pattern-1-subset-generation",level:2},{value:"1.1 Generate All Subsets",id:"11-generate-all-subsets",level:3},{value:"1.2 Subsets II (With Duplicates)",id:"12-subsets-ii-with-duplicates",level:3},{value:"1.3 Subset Sum Problem",id:"13-subset-sum-problem",level:3},{value:"1.4 Power Set (Iterative Approach)",id:"14-power-set-iterative-approach",level:3},{value:"1.5 Generate Subsets by Size",id:"15-generate-subsets-by-size",level:3},{value:"Pattern 2: Permutation Generation",id:"pattern-2-permutation-generation",level:2},{value:"2.1 Generate All Permutations",id:"21-generate-all-permutations",level:3},{value:"2.2 Permutations II (With Duplicates)",id:"22-permutations-ii-with-duplicates",level:3},{value:"2.3 Next Permutation",id:"23-next-permutation",level:3},{value:"2.4 Permutation Sequence (Kth Permutation)",id:"24-permutation-sequence-kth-permutation",level:3},{value:"2.5 String Permutations",id:"25-string-permutations",level:3},{value:"Pattern 3: Combination Problems",id:"pattern-3-combination-problems",level:2},{value:"3.1 Generate Combinations",id:"31-generate-combinations",level:3},{value:"3.2 Combination Sum",id:"32-combination-sum",level:3},{value:"3.3 Combination Sum II (No Reuse)",id:"33-combination-sum-ii-no-reuse",level:3},{value:"3.4 Letter Combinations of Phone Number",id:"34-letter-combinations-of-phone-number",level:3},{value:"3.5 Generate Parentheses",id:"35-generate-parentheses",level:3},{value:"Pattern 4: Partition Problems",id:"pattern-4-partition-problems",level:2},{value:"4.1 Palindrome Partitioning",id:"41-palindrome-partitioning",level:3},{value:"4.2 Word Break II",id:"42-word-break-ii",level:3},{value:"4.3 Restore IP Addresses",id:"43-restore-ip-addresses",level:3},{value:"4.4 Partition to K Equal Sum Subsets",id:"44-partition-to-k-equal-sum-subsets",level:3},{value:"Pattern 5: Grid/Matrix Traversal",id:"pattern-5-gridmatrix-traversal",level:2},{value:"5.1 Word Search in Grid",id:"51-word-search-in-grid",level:3},{value:"5.2 Number of Islands",id:"52-number-of-islands",level:3},{value:"5.3 Surrounded Regions",id:"53-surrounded-regions",level:3},{value:"5.4 Path with Maximum Gold",id:"54-path-with-maximum-gold",level:3},{value:"5.5 Unique Paths III",id:"55-unique-paths-iii",level:3},{value:"Pattern 6: N-Queens &amp; Placement Problems",id:"pattern-6-n-queens--placement-problems",level:2},{value:"6.1 N-Queens Problem",id:"61-n-queens-problem",level:3},{value:"6.2 N-Queens II (Count Solutions)",id:"62-n-queens-ii-count-solutions",level:3},{value:"6.3 Sudoku Solver",id:"63-sudoku-solver",level:3},{value:"6.4 Knight&#39;s Tour Problem",id:"64-knights-tour-problem",level:3},{value:"Pattern 7: Word Search &amp; Trie Problems",id:"pattern-7-word-search--trie-problems",level:2},{value:"7.1 Word Search II",id:"71-word-search-ii",level:3},{value:"7.2 Boggle Game",id:"72-boggle-game",level:3},{value:"Pattern 8: Expression &amp; Equation Problems",id:"pattern-8-expression--equation-problems",level:2},{value:"8.1 Expression Add Operators",id:"81-expression-add-operators",level:3},{value:"8.2 Different Ways to Add Parentheses",id:"82-different-ways-to-add-parentheses",level:3},{value:"8.3 24 Game",id:"83-24-game",level:3},{value:"Pattern 9: Game &amp; Puzzle Problems",id:"pattern-9-game--puzzle-problems",level:2},{value:"9.1 Tic-Tac-Toe AI (Minimax with Backtracking)",id:"91-tic-tac-toe-ai-minimax-with-backtracking",level:3},{value:"9.2 Word Ladder with Backtracking",id:"92-word-ladder-with-backtracking",level:3},{value:"Pattern 10: Tree Traversal Backtracking",id:"pattern-10-tree-traversal-backtracking",level:2},{value:"10.1 Binary Tree Paths",id:"101-binary-tree-paths",level:3},{value:"10.2 Path Sum II",id:"102-path-sum-ii",level:3},{value:"10.3 Sum Root to Leaf Numbers",id:"103-sum-root-to-leaf-numbers",level:3},{value:"Pattern 11: Advanced Constraint Problems",id:"pattern-11-advanced-constraint-problems",level:2},{value:"11.1 Graph Coloring",id:"111-graph-coloring",level:3},{value:"11.2 Hamiltonian Path",id:"112-hamiltonian-path",level:3},{value:"Pattern 12: Optimization Problems",id:"pattern-12-optimization-problems",level:2},{value:"12.1 Minimum Cost Path with Backtracking",id:"121-minimum-cost-path-with-backtracking",level:3},{value:"12.2 Maximum Path Sum with Constraints",id:"122-maximum-path-sum-with-constraints",level:3},{value:"Time Complexity Analysis",id:"time-complexity-analysis",level:2},{value:"Common Optimization Techniques",id:"common-optimization-techniques",level:2},{value:"Pruning Strategies",id:"pruning-strategies",level:3},{value:"Template Optimizations",id:"template-optimizations",level:3},{value:"Interview Tips &amp; Best Practices",id:"interview-tips--best-practices",level:2},{value:"Problem Recognition",id:"problem-recognition",level:3},{value:"Implementation Strategy",id:"implementation-strategy",level:3},{value:"Common Mistakes to Avoid",id:"common-mistakes-to-avoid",level:3}];function c(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"backtracking",children:"Backtracking"})}),"\n",(0,t.jsx)(e.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#backtracking-template",children:"Backtracking Template"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-1-subset-generation",children:"Pattern 1: Subset Generation"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-2-permutation-generation",children:"Pattern 2: Permutation Generation"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-3-combination-problems",children:"Pattern 3: Combination Problems"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-4-partition-problems",children:"Pattern 4: Partition Problems"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-5-gridmatrix-traversal",children:"Pattern 5: Grid/Matrix Traversal"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-6-n-queens--placement-problems",children:"Pattern 6: N-Queens & Placement Problems"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-7-word-search--trie-problems",children:"Pattern 7: Word Search & Trie Problems"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-8-expression--equation-problems",children:"Pattern 8: Expression & Equation Problems"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-9-game--puzzle-problems",children:"Pattern 9: Game & Puzzle Problems"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-10-tree-traversal-backtracking",children:"Pattern 10: Tree Traversal Backtracking"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-11-advanced-constraint-problems",children:"Pattern 11: Advanced Constraint Problems"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-12-optimization-problems",children:"Pattern 12: Optimization Problems"})}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"backtracking-template",children:"Backtracking Template"}),"\n",(0,t.jsx)(e.h3,{id:"core-template-structure",children:"Core Template Structure"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Universal Backtracking Template\nvoid backtrack(List<List<Integer>> result, List<Integer> current,\n               int[] nums, int start) {\n    // Base case: check if solution is complete\n    if (isComplete(current)) {\n        result.add(new ArrayList<>(current)); // Make copy\n        return;\n    }\n\n    // Iterate through all possible choices from current state\n    for (int i = start; i < nums.length; i++) {\n        // Skip invalid choices (pruning)\n        if (!isValid(current, nums[i])) continue;\n\n        // Make choice\n        current.add(nums[i]);\n\n        // Recurse with choice made\n        backtrack(result, current, nums, i + 1);\n\n        // Undo choice (backtrack)\n        current.remove(current.size() - 1);\n    }\n}\n\n// Helper methods\nboolean isComplete(List<Integer> current) {\n    // Define completion condition\n    return current.size() == targetSize;\n}\n\nboolean isValid(List<Integer> current, int candidate) {\n    // Define validity constraints\n    return true; // Implement specific logic\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"key-components",children:"Key Components"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"class BacktrackingFramework {\n    // 1. State representation\n    List<Integer> currentPath = new ArrayList<>();\n\n    // 2. Result collection\n    List<List<Integer>> allSolutions = new ArrayList<>();\n\n    // 3. Choice exploration\n    void explore(int[] choices, int index) {\n        // Base case\n        if (isGoalReached()) {\n            processSolution();\n            return;\n        }\n\n        // Try all valid choices\n        for (int i = index; i < choices.length; i++) {\n            if (isValidChoice(choices[i])) {\n                makeChoice(choices[i]);      // Choose\n                explore(choices, i + 1);     // Explore\n                undoChoice();                // Unchoose\n            }\n        }\n    }\n\n    boolean isGoalReached() { return /* condition */; }\n    boolean isValidChoice(int choice) { return /* validation */; }\n    void makeChoice(int choice) { currentPath.add(choice); }\n    void undoChoice() { currentPath.remove(currentPath.size() - 1); }\n    void processSolution() { allSolutions.add(new ArrayList<>(currentPath)); }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-1-subset-generation",children:"Pattern 1: Subset Generation"}),"\n",(0,t.jsx)(e.h3,{id:"11-generate-all-subsets",children:"1.1 Generate All Subsets"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"List<List<Integer>> subsets(int[] nums) {\n    List<List<Integer>> result = new ArrayList<>();\n    backtrackSubsets(result, new ArrayList<>(), nums, 0);\n    return result;\n}\n\nvoid backtrackSubsets(List<List<Integer>> result, List<Integer> current,\n                     int[] nums, int start) {\n    // Every recursive call represents a valid subset\n    result.add(new ArrayList<>(current));\n\n    for (int i = start; i < nums.length; i++) {\n        current.add(nums[i]);\n        backtrackSubsets(result, current, nums, i + 1);\n        current.remove(current.size() - 1);\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"12-subsets-ii-with-duplicates",children:"1.2 Subsets II (With Duplicates)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"List<List<Integer>> subsetsWithDup(int[] nums) {\n    Arrays.sort(nums); // Sort to handle duplicates\n    List<List<Integer>> result = new ArrayList<>();\n    backtrackSubsetsDup(result, new ArrayList<>(), nums, 0);\n    return result;\n}\n\nvoid backtrackSubsetsDup(List<List<Integer>> result, List<Integer> current,\n                        int[] nums, int start) {\n    result.add(new ArrayList<>(current));\n\n    for (int i = start; i < nums.length; i++) {\n        // Skip duplicates: only process first occurrence at each level\n        if (i > start && nums[i] == nums[i - 1]) continue;\n\n        current.add(nums[i]);\n        backtrackSubsetsDup(result, current, nums, i + 1);\n        current.remove(current.size() - 1);\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"13-subset-sum-problem",children:"1.3 Subset Sum Problem"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"List<List<Integer>> subsetSum(int[] nums, int target) {\n    List<List<Integer>> result = new ArrayList<>();\n    Arrays.sort(nums);\n    backtrackSum(result, new ArrayList<>(), nums, target, 0);\n    return result;\n}\n\nvoid backtrackSum(List<List<Integer>> result, List<Integer> current,\n                 int[] nums, int remaining, int start) {\n    if (remaining == 0) {\n        result.add(new ArrayList<>(current));\n        return;\n    }\n\n    for (int i = start; i < nums.length; i++) {\n        if (nums[i] > remaining) break; // Pruning: sorted array\n        if (i > start && nums[i] == nums[i - 1]) continue; // Skip duplicates\n\n        current.add(nums[i]);\n        backtrackSum(result, current, nums, remaining - nums[i], i + 1);\n        current.remove(current.size() - 1);\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"14-power-set-iterative-approach",children:"1.4 Power Set (Iterative Approach)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"List<List<Integer>> powerSet(int[] nums) {\n    List<List<Integer>> result = new ArrayList<>();\n    result.add(new ArrayList<>()); // Empty subset\n\n    for (int num : nums) {\n        int size = result.size();\n        for (int i = 0; i < size; i++) {\n            List<Integer> subset = new ArrayList<>(result.get(i));\n            subset.add(num);\n            result.add(subset);\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"15-generate-subsets-by-size",children:"1.5 Generate Subsets by Size"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"List<List<Integer>> subsetsBySize(int[] nums, int k) {\n    List<List<Integer>> result = new ArrayList<>();\n    backtrackBySize(result, new ArrayList<>(), nums, k, 0);\n    return result;\n}\n\nvoid backtrackBySize(List<List<Integer>> result, List<Integer> current,\n                    int[] nums, int k, int start) {\n    if (current.size() == k) {\n        result.add(new ArrayList<>(current));\n        return;\n    }\n\n    // Optimization: ensure enough elements remain\n    int needed = k - current.size();\n    int available = nums.length - start;\n    if (available < needed) return;\n\n    for (int i = start; i < nums.length; i++) {\n        current.add(nums[i]);\n        backtrackBySize(result, current, nums, k, i + 1);\n        current.remove(current.size() - 1);\n    }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-2-permutation-generation",children:"Pattern 2: Permutation Generation"}),"\n",(0,t.jsx)(e.h3,{id:"21-generate-all-permutations",children:"2.1 Generate All Permutations"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"List<List<Integer>> permute(int[] nums) {\n    List<List<Integer>> result = new ArrayList<>();\n    backtrackPermute(result, new ArrayList<>(), nums);\n    return result;\n}\n\nvoid backtrackPermute(List<List<Integer>> result, List<Integer> current, int[] nums) {\n    if (current.size() == nums.length) {\n        result.add(new ArrayList<>(current));\n        return;\n    }\n\n    for (int num : nums) {\n        if (current.contains(num)) continue; // Skip used elements\n\n        current.add(num);\n        backtrackPermute(result, current, nums);\n        current.remove(current.size() - 1);\n    }\n}\n\n// Optimized version using boolean array\nList<List<Integer>> permuteOptimized(int[] nums) {\n    List<List<Integer>> result = new ArrayList<>();\n    boolean[] used = new boolean[nums.length];\n    backtrackPermuteOpt(result, new ArrayList<>(), nums, used);\n    return result;\n}\n\nvoid backtrackPermuteOpt(List<List<Integer>> result, List<Integer> current,\n                        int[] nums, boolean[] used) {\n    if (current.size() == nums.length) {\n        result.add(new ArrayList<>(current));\n        return;\n    }\n\n    for (int i = 0; i < nums.length; i++) {\n        if (used[i]) continue;\n\n        used[i] = true;\n        current.add(nums[i]);\n        backtrackPermuteOpt(result, current, nums, used);\n        current.remove(current.size() - 1);\n        used[i] = false;\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"22-permutations-ii-with-duplicates",children:"2.2 Permutations II (With Duplicates)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"List<List<Integer>> permuteUnique(int[] nums) {\n    Arrays.sort(nums); // Sort to handle duplicates\n    List<List<Integer>> result = new ArrayList<>();\n    boolean[] used = new boolean[nums.length];\n    backtrackPermuteDup(result, new ArrayList<>(), nums, used);\n    return result;\n}\n\nvoid backtrackPermuteDup(List<List<Integer>> result, List<Integer> current,\n                        int[] nums, boolean[] used) {\n    if (current.size() == nums.length) {\n        result.add(new ArrayList<>(current));\n        return;\n    }\n\n    for (int i = 0; i < nums.length; i++) {\n        if (used[i]) continue;\n\n        // Skip duplicates: use first occurrence in sorted order\n        if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) continue;\n\n        used[i] = true;\n        current.add(nums[i]);\n        backtrackPermuteDup(result, current, nums, used);\n        current.remove(current.size() - 1);\n        used[i] = false;\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"23-next-permutation",children:"2.3 Next Permutation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"void nextPermutation(int[] nums) {\n    int i = nums.length - 2;\n\n    // Find first decreasing element from right\n    while (i >= 0 && nums[i] >= nums[i + 1]) {\n        i--;\n    }\n\n    if (i >= 0) {\n        int j = nums.length - 1;\n        // Find element just larger than nums[i]\n        while (nums[j] <= nums[i]) {\n            j--;\n        }\n        swap(nums, i, j);\n    }\n\n    // Reverse suffix\n    reverse(nums, i + 1);\n}\n\nvoid swap(int[] nums, int i, int j) {\n    int temp = nums[i];\n    nums[i] = nums[j];\n    nums[j] = temp;\n}\n\nvoid reverse(int[] nums, int start) {\n    int end = nums.length - 1;\n    while (start < end) {\n        swap(nums, start++, end--);\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"24-permutation-sequence-kth-permutation",children:"2.4 Permutation Sequence (Kth Permutation)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"String getPermutation(int n, int k) {\n    List<Integer> numbers = new ArrayList<>();\n    int[] factorial = new int[n + 1];\n\n    // Calculate factorials and build number list\n    factorial[^3_0] = 1;\n    for (int i = 1; i <= n; i++) {\n        factorial[i] = factorial[i - 1] * i;\n        numbers.add(i);\n    }\n\n    k--; // Convert to 0-based indexing\n    StringBuilder result = new StringBuilder();\n\n    for (int i = n; i > 0; i--) {\n        int index = k / factorial[i - 1];\n        result.append(numbers.get(index));\n        numbers.remove(index);\n        k %= factorial[i - 1];\n    }\n\n    return result.toString();\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"25-string-permutations",children:"2.5 String Permutations"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"List<String> stringPermutations(String s) {\n    List<String> result = new ArrayList<>();\n    char[] chars = s.toCharArray();\n    Arrays.sort(chars); // Handle duplicates\n    boolean[] used = new boolean[chars.length];\n    backtrackStringPerm(result, new StringBuilder(), chars, used);\n    return result;\n}\n\nvoid backtrackStringPerm(List<String> result, StringBuilder current,\n                        char[] chars, boolean[] used) {\n    if (current.length() == chars.length) {\n        result.add(current.toString());\n        return;\n    }\n\n    for (int i = 0; i < chars.length; i++) {\n        if (used[i]) continue;\n        if (i > 0 && chars[i] == chars[i - 1] && !used[i - 1]) continue;\n\n        used[i] = true;\n        current.append(chars[i]);\n        backtrackStringPerm(result, current, chars, used);\n        current.deleteCharAt(current.length() - 1);\n        used[i] = false;\n    }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-3-combination-problems",children:"Pattern 3: Combination Problems"}),"\n",(0,t.jsx)(e.h3,{id:"31-generate-combinations",children:"3.1 Generate Combinations"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"List<List<Integer>> combine(int n, int k) {\n    List<List<Integer>> result = new ArrayList<>();\n    backtrackCombine(result, new ArrayList<>(), 1, n, k);\n    return result;\n}\n\nvoid backtrackCombine(List<List<Integer>> result, List<Integer> current,\n                     int start, int n, int k) {\n    if (current.size() == k) {\n        result.add(new ArrayList<>(current));\n        return;\n    }\n\n    // Optimization: check if enough numbers remain\n    int needed = k - current.size();\n    int available = n - start + 1;\n    if (available < needed) return;\n\n    for (int i = start; i <= n; i++) {\n        current.add(i);\n        backtrackCombine(result, current, i + 1, n, k);\n        current.remove(current.size() - 1);\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"32-combination-sum",children:"3.2 Combination Sum"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"List<List<Integer>> combinationSum(int[] candidates, int target) {\n    List<List<Integer>> result = new ArrayList<>();\n    Arrays.sort(candidates);\n    backtrackCombSum(result, new ArrayList<>(), candidates, target, 0);\n    return result;\n}\n\nvoid backtrackCombSum(List<List<Integer>> result, List<Integer> current,\n                     int[] candidates, int remaining, int start) {\n    if (remaining == 0) {\n        result.add(new ArrayList<>(current));\n        return;\n    }\n\n    for (int i = start; i < candidates.length; i++) {\n        if (candidates[i] > remaining) break; // Pruning\n\n        current.add(candidates[i]);\n        // Allow reuse of same element: pass i instead of i+1\n        backtrackCombSum(result, current, candidates, remaining - candidates[i], i);\n        current.remove(current.size() - 1);\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"33-combination-sum-ii-no-reuse",children:"3.3 Combination Sum II (No Reuse)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"List<List<Integer>> combinationSum2(int[] candidates, int target) {\n    Arrays.sort(candidates);\n    List<List<Integer>> result = new ArrayList<>();\n    backtrackCombSum2(result, new ArrayList<>(), candidates, target, 0);\n    return result;\n}\n\nvoid backtrackCombSum2(List<List<Integer>> result, List<Integer> current,\n                      int[] candidates, int remaining, int start) {\n    if (remaining == 0) {\n        result.add(new ArrayList<>(current));\n        return;\n    }\n\n    for (int i = start; i < candidates.length; i++) {\n        if (candidates[i] > remaining) break;\n        if (i > start && candidates[i] == candidates[i - 1]) continue;\n\n        current.add(candidates[i]);\n        backtrackCombSum2(result, current, candidates, remaining - candidates[i], i + 1);\n        current.remove(current.size() - 1);\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"34-letter-combinations-of-phone-number",children:"3.4 Letter Combinations of Phone Number"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:'List<String> letterCombinations(String digits) {\n    if (digits.isEmpty()) return new ArrayList<>();\n\n    String[] mapping = {\n        "",     // 0\n        "",     // 1\n        "abc",  // 2\n        "def",  // 3\n        "ghi",  // 4\n        "jkl",  // 5\n        "mno",  // 6\n        "pqrs", // 7\n        "tuv",  // 8\n        "wxyz"  // 9\n    };\n\n    List<String> result = new ArrayList<>();\n    backtrackLetters(result, new StringBuilder(), digits, mapping, 0);\n    return result;\n}\n\nvoid backtrackLetters(List<String> result, StringBuilder current,\n                     String digits, String[] mapping, int index) {\n    if (index == digits.length()) {\n        result.add(current.toString());\n        return;\n    }\n\n    String letters = mapping[digits.charAt(index) - \'0\'];\n    for (char letter : letters.toCharArray()) {\n        current.append(letter);\n        backtrackLetters(result, current, digits, mapping, index + 1);\n        current.deleteCharAt(current.length() - 1);\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"35-generate-parentheses",children:"3.5 Generate Parentheses"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"List<String> generateParenthesis(int n) {\n    List<String> result = new ArrayList<>();\n    backtrackParentheses(result, new StringBuilder(), 0, 0, n);\n    return result;\n}\n\nvoid backtrackParentheses(List<String> result, StringBuilder current,\n                         int open, int close, int max) {\n    if (current.length() == max * 2) {\n        result.add(current.toString());\n        return;\n    }\n\n    if (open < max) {\n        current.append('(');\n        backtrackParentheses(result, current, open + 1, close, max);\n        current.deleteCharAt(current.length() - 1);\n    }\n\n    if (close < open) {\n        current.append(')');\n        backtrackParentheses(result, current, open, close + 1, max);\n        current.deleteCharAt(current.length() - 1);\n    }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-4-partition-problems",children:"Pattern 4: Partition Problems"}),"\n",(0,t.jsx)(e.h3,{id:"41-palindrome-partitioning",children:"4.1 Palindrome Partitioning"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"List<List<String>> partition(String s) {\n    List<List<String>> result = new ArrayList<>();\n    backtrackPartition(result, new ArrayList<>(), s, 0);\n    return result;\n}\n\nvoid backtrackPartition(List<List<String>> result, List<String> current,\n                       String s, int start) {\n    if (start == s.length()) {\n        result.add(new ArrayList<>(current));\n        return;\n    }\n\n    for (int end = start; end < s.length(); end++) {\n        if (isPalindrome(s, start, end)) {\n            current.add(s.substring(start, end + 1));\n            backtrackPartition(result, current, s, end + 1);\n            current.remove(current.size() - 1);\n        }\n    }\n}\n\nboolean isPalindrome(String s, int left, int right) {\n    while (left < right) {\n        if (s.charAt(left++) != s.charAt(right--)) {\n            return false;\n        }\n    }\n    return true;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"42-word-break-ii",children:"4.2 Word Break II"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:'List<String> wordBreak(String s, List<String> wordDict) {\n    Set<String> wordSet = new HashSet<>(wordDict);\n    List<String> result = new ArrayList<>();\n    backtrackWordBreak(result, new ArrayList<>(), s, wordSet, 0);\n    return result;\n}\n\nvoid backtrackWordBreak(List<String> result, List<String> current,\n                       String s, Set<String> wordSet, int start) {\n    if (start == s.length()) {\n        result.add(String.join(" ", current));\n        return;\n    }\n\n    for (int end = start + 1; end <= s.length(); end++) {\n        String word = s.substring(start, end);\n        if (wordSet.contains(word)) {\n            current.add(word);\n            backtrackWordBreak(result, current, s, wordSet, end);\n            current.remove(current.size() - 1);\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"43-restore-ip-addresses",children:"4.3 Restore IP Addresses"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"List<String> restoreIpAddresses(String s) {\n    List<String> result = new ArrayList<>();\n    backtrackIP(result, new ArrayList<>(), s, 0);\n    return result;\n}\n\nvoid backtrackIP(List<String> result, List<String> current,\n                String s, int start) {\n    if (current.size() == 4) {\n        if (start == s.length()) {\n            result.add(String.join(\".\", current));\n        }\n        return;\n    }\n\n    for (int len = 1; len <= 3 && start + len <= s.length(); len++) {\n        String segment = s.substring(start, start + len);\n        if (isValidIPSegment(segment)) {\n            current.add(segment);\n            backtrackIP(result, current, s, start + len);\n            current.remove(current.size() - 1);\n        }\n    }\n}\n\nboolean isValidIPSegment(String segment) {\n    if (segment.length() > 1 && segment.charAt(0) == '0') return false;\n    int num = Integer.parseInt(segment);\n    return num >= 0 && num <= 255;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"44-partition-to-k-equal-sum-subsets",children:"4.4 Partition to K Equal Sum Subsets"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"boolean canPartitionKSubsets(int[] nums, int k) {\n    int sum = Arrays.stream(nums).sum();\n    if (sum % k != 0) return false;\n\n    int target = sum / k;\n    Arrays.sort(nums);\n\n    // Start from largest number for better pruning\n    int left = 0, right = nums.length - 1;\n    while (left < right) {\n        int temp = nums[left];\n        nums[left] = nums[right];\n        nums[right] = temp;\n        left++;\n        right--;\n    }\n\n    return backtrackPartitionK(nums, new int[k], 0, target);\n}\n\nboolean backtrackPartitionK(int[] nums, int[] buckets, int index, int target) {\n    if (index == nums.length) {\n        for (int bucket : buckets) {\n            if (bucket != target) return false;\n        }\n        return true;\n    }\n\n    for (int i = 0; i < buckets.length; i++) {\n        if (buckets[i] + nums[index] <= target) {\n            buckets[i] += nums[index];\n            if (backtrackPartitionK(nums, buckets, index + 1, target)) {\n                return true;\n            }\n            buckets[i] -= nums[index];\n\n            // Pruning: if current bucket is empty, no need to try other empty buckets\n            if (buckets[i] == 0) break;\n        }\n    }\n\n    return false;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-5-gridmatrix-traversal",children:"Pattern 5: Grid/Matrix Traversal"}),"\n",(0,t.jsx)(e.h3,{id:"51-word-search-in-grid",children:"5.1 Word Search in Grid"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"boolean exist(char[][] board, String word) {\n    for (int i = 0; i < board.length; i++) {\n        for (int j = 0; j < board[^3_0].length; j++) {\n            if (dfsWordSearch(board, word, i, j, 0)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nboolean dfsWordSearch(char[][] board, String word, int i, int j, int index) {\n    if (index == word.length()) return true;\n\n    if (i < 0 || i >= board.length || j < 0 || j >= board[^3_0].length ||\n        board[i][j] != word.charAt(index)) {\n        return false;\n    }\n\n    char temp = board[i][j];\n    board[i][j] = '#'; // Mark as visited\n\n    boolean found = dfsWordSearch(board, word, i + 1, j, index + 1) ||\n                   dfsWordSearch(board, word, i - 1, j, index + 1) ||\n                   dfsWordSearch(board, word, i, j + 1, index + 1) ||\n                   dfsWordSearch(board, word, i, j - 1, index + 1);\n\n    board[i][j] = temp; // Backtrack\n    return found;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"52-number-of-islands",children:"5.2 Number of Islands"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"int numIslands(char[][] grid) {\n    if (grid == null || grid.length == 0) return 0;\n\n    int count = 0;\n    for (int i = 0; i < grid.length; i++) {\n        for (int j = 0; j < grid[^3_0].length; j++) {\n            if (grid[i][j] == '1') {\n                count++;\n                dfsIsland(grid, i, j);\n            }\n        }\n    }\n    return count;\n}\n\nvoid dfsIsland(char[][] grid, int i, int j) {\n    if (i < 0 || i >= grid.length || j < 0 || j >= grid[^3_0].length ||\n        grid[i][j] != '1') {\n        return;\n    }\n\n    grid[i][j] = '0'; // Mark as visited\n\n    dfsIsland(grid, i + 1, j);\n    dfsIsland(grid, i - 1, j);\n    dfsIsland(grid, i, j + 1);\n    dfsIsland(grid, i, j - 1);\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"53-surrounded-regions",children:"5.3 Surrounded Regions"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"void solve(char[][] board) {\n    if (board == null || board.length == 0) return;\n\n    int m = board.length, n = board[^3_0].length;\n\n    // Mark boundary-connected 'O's\n    for (int i = 0; i < m; i++) {\n        if (board[i][^3_0] == 'O') dfsFlip(board, i, 0);\n        if (board[i][n - 1] == 'O') dfsFlip(board, i, n - 1);\n    }\n\n    for (int j = 0; j < n; j++) {\n        if (board[^3_0][j] == 'O') dfsFlip(board, 0, j);\n        if (board[m - 1][j] == 'O') dfsFlip(board, m - 1, j);\n    }\n\n    // Flip remaining 'O's to 'X' and restore marked ones\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (board[i][j] == 'O') {\n                board[i][j] = 'X';\n            } else if (board[i][j] == '#') {\n                board[i][j] = 'O';\n            }\n        }\n    }\n}\n\nvoid dfsFlip(char[][] board, int i, int j) {\n    if (i < 0 || i >= board.length || j < 0 || j >= board[^3_0].length ||\n        board[i][j] != 'O') {\n        return;\n    }\n\n    board[i][j] = '#'; // Temporary mark\n\n    dfsFlip(board, i + 1, j);\n    dfsFlip(board, i - 1, j);\n    dfsFlip(board, i, j + 1);\n    dfsFlip(board, i, j - 1);\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"54-path-with-maximum-gold",children:"5.4 Path with Maximum Gold"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"int getMaximumGold(int[][] grid) {\n    int maxGold = 0;\n\n    for (int i = 0; i < grid.length; i++) {\n        for (int j = 0; j < grid[^3_0].length; j++) {\n            if (grid[i][j] != 0) {\n                maxGold = Math.max(maxGold, dfsGold(grid, i, j));\n            }\n        }\n    }\n\n    return maxGold;\n}\n\nint dfsGold(int[][] grid, int i, int j) {\n    if (i < 0 || i >= grid.length || j < 0 || j >= grid[^3_0].length ||\n        grid[i][j] == 0) {\n        return 0;\n    }\n\n    int gold = grid[i][j];\n    grid[i][j] = 0; // Mark as visited\n\n    int maxPath = Math.max(\n        Math.max(dfsGold(grid, i + 1, j), dfsGold(grid, i - 1, j)),\n        Math.max(dfsGold(grid, i, j + 1), dfsGold(grid, i, j - 1))\n    );\n\n    grid[i][j] = gold; // Backtrack\n    return gold + maxPath;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"55-unique-paths-iii",children:"5.5 Unique Paths III"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"int uniquePathsIII(int[][] grid) {\n    int startX = 0, startY = 0, empty = 1; // Count starting square as empty\n\n    for (int i = 0; i < grid.length; i++) {\n        for (int j = 0; j < grid[^3_0].length; j++) {\n            if (grid[i][j] == 1) {\n                startX = i;\n                startY = j;\n            } else if (grid[i][j] == 0) {\n                empty++;\n            }\n        }\n    }\n\n    return dfsUniquePaths(grid, startX, startY, empty);\n}\n\nint dfsUniquePaths(int[][] grid, int x, int y, int empty) {\n    if (x < 0 || x >= grid.length || y < 0 || y >= grid[^3_0].length ||\n        grid[x][y] == -1) {\n        return 0;\n    }\n\n    if (grid[x][y] == 2) {\n        return empty == 0 ? 1 : 0; // Reached end, check if all squares visited\n    }\n\n    grid[x][y] = -1; // Mark as visited\n    int paths = dfsUniquePaths(grid, x + 1, y, empty - 1) +\n               dfsUniquePaths(grid, x - 1, y, empty - 1) +\n               dfsUniquePaths(grid, x, y + 1, empty - 1) +\n               dfsUniquePaths(grid, x, y - 1, empty - 1);\n\n    grid[x][y] = 0; // Backtrack\n    return paths;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-6-n-queens--placement-problems",children:"Pattern 6: N-Queens & Placement Problems"}),"\n",(0,t.jsx)(e.h3,{id:"61-n-queens-problem",children:"6.1 N-Queens Problem"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"List<List<String>> solveNQueens(int n) {\n    List<List<String>> result = new ArrayList<>();\n    char[][] board = new char[n][n];\n\n    // Initialize board\n    for (int i = 0; i < n; i++) {\n        Arrays.fill(board[i], '.');\n    }\n\n    backtrackNQueens(result, board, 0);\n    return result;\n}\n\nvoid backtrackNQueens(List<List<String>> result, char[][] board, int row) {\n    if (row == board.length) {\n        result.add(constructBoard(board));\n        return;\n    }\n\n    for (int col = 0; col < board.length; col++) {\n        if (isValidPlacement(board, row, col)) {\n            board[row][col] = 'Q';\n            backtrackNQueens(result, board, row + 1);\n            board[row][col] = '.';\n        }\n    }\n}\n\nboolean isValidPlacement(char[][] board, int row, int col) {\n    int n = board.length;\n\n    // Check column\n    for (int i = 0; i < row; i++) {\n        if (board[i][col] == 'Q') return false;\n    }\n\n    // Check diagonal (top-left to bottom-right)\n    for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\n        if (board[i][j] == 'Q') return false;\n    }\n\n    // Check anti-diagonal (top-right to bottom-left)\n    for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {\n        if (board[i][j] == 'Q') return false;\n    }\n\n    return true;\n}\n\nList<String> constructBoard(char[][] board) {\n    List<String> result = new ArrayList<>();\n    for (char[] row : board) {\n        result.add(new String(row));\n    }\n    return result;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"62-n-queens-ii-count-solutions",children:"6.2 N-Queens II (Count Solutions)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"int totalNQueens(int n) {\n    return backtrackCountQueens(n, 0, new boolean[n], new boolean[2 * n], new boolean[2 * n]);\n}\n\nint backtrackCountQueens(int n, int row, boolean[] cols, boolean[] diag1, boolean[] diag2) {\n    if (row == n) return 1;\n\n    int count = 0;\n    for (int col = 0; col < n; col++) {\n        int d1 = row - col + n, d2 = row + col;\n\n        if (!cols[col] && !diag1[d1] && !diag2[d2]) {\n            cols[col] = diag1[d1] = diag2[d2] = true;\n            count += backtrackCountQueens(n, row + 1, cols, diag1, diag2);\n            cols[col] = diag1[d1] = diag2[d2] = false;\n        }\n    }\n\n    return count;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"63-sudoku-solver",children:"6.3 Sudoku Solver"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"void solveSudoku(char[][] board) {\n    backtrackSudoku(board);\n}\n\nboolean backtrackSudoku(char[][] board) {\n    for (int i = 0; i < 9; i++) {\n        for (int j = 0; j < 9; j++) {\n            if (board[i][j] == '.') {\n                for (char c = '1'; c <= '9'; c++) {\n                    if (isValidSudoku(board, i, j, c)) {\n                        board[i][j] = c;\n\n                        if (backtrackSudoku(board)) {\n                            return true;\n                        }\n\n                        board[i][j] = '.';\n                    }\n                }\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nboolean isValidSudoku(char[][] board, int row, int col, char c) {\n    for (int i = 0; i < 9; i++) {\n        // Check row\n        if (board[row][i] == c) return false;\n\n        // Check column\n        if (board[i][col] == c) return false;\n\n        // Check 3x3 box\n        if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c) {\n            return false;\n        }\n    }\n    return true;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"64-knights-tour-problem",children:"6.4 Knight's Tour Problem"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"boolean knightTour(int n) {\n    int[][] board = new int[n][n];\n    int[] xMoves = {2, 1, -1, -2, -2, -1, 1, 2};\n    int[] yMoves = {1, 2, 2, 1, -1, -2, -2, -1};\n\n    // Initialize all squares as unvisited\n    for (int i = 0; i < n; i++) {\n        Arrays.fill(board[i], -1);\n    }\n\n    board[^3_0][^3_0] = 0; // Starting position\n    return backtrackKnight(board, 0, 0, 1, xMoves, yMoves, n);\n}\n\nboolean backtrackKnight(int[][] board, int x, int y, int moveCount,\n                       int[] xMoves, int[] yMoves, int n) {\n    if (moveCount == n * n) return true;\n\n    for (int i = 0; i < 8; i++) {\n        int nextX = x + xMoves[i];\n        int nextY = y + yMoves[i];\n\n        if (isValidKnightMove(board, nextX, nextY, n)) {\n            board[nextX][nextY] = moveCount;\n\n            if (backtrackKnight(board, nextX, nextY, moveCount + 1, xMoves, yMoves, n)) {\n                return true;\n            }\n\n            board[nextX][nextY] = -1; // Backtrack\n        }\n    }\n\n    return false;\n}\n\nboolean isValidKnightMove(int[][] board, int x, int y, int n) {\n    return x >= 0 && x < n && y >= 0 && y < n && board[x][y] == -1;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-7-word-search--trie-problems",children:"Pattern 7: Word Search & Trie Problems"}),"\n",(0,t.jsx)(e.h3,{id:"71-word-search-ii",children:"7.1 Word Search II"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"class TrieNode {\n    TrieNode[] children = new TrieNode[^3_26];\n    String word;\n}\n\nList<String> findWords(char[][] board, String[] words) {\n    TrieNode root = buildTrie(words);\n    List<String> result = new ArrayList<>();\n\n    for (int i = 0; i < board.length; i++) {\n        for (int j = 0; j < board[^3_0].length; j++) {\n            dfsWordSearch(board, i, j, root, result);\n        }\n    }\n\n    return result;\n}\n\nTrieNode buildTrie(String[] words) {\n    TrieNode root = new TrieNode();\n    for (String word : words) {\n        TrieNode curr = root;\n        for (char c : word.toCharArray()) {\n            int index = c - 'a';\n            if (curr.children[index] == null) {\n                curr.children[index] = new TrieNode();\n            }\n            curr = curr.children[index];\n        }\n        curr.word = word;\n    }\n    return root;\n}\n\nvoid dfsWordSearch(char[][] board, int i, int j, TrieNode node, List<String> result) {\n    if (i < 0 || i >= board.length || j < 0 || j >= board[^3_0].length) return;\n\n    char c = board[i][j];\n    if (c == '#' || node.children[c - 'a'] == null) return;\n\n    node = node.children[c - 'a'];\n    if (node.word != null) {\n        result.add(node.word);\n        node.word = null; // Avoid duplicates\n    }\n\n    board[i][j] = '#'; // Mark as visited\n    dfsWordSearch(board, i + 1, j, node, result);\n    dfsWordSearch(board, i - 1, j, node, result);\n    dfsWordSearch(board, i, j + 1, node, result);\n    dfsWordSearch(board, i, j - 1, node, result);\n    board[i][j] = c; // Backtrack\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"72-boggle-game",children:"7.2 Boggle Game"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"List<String> findWordsInBoggle(char[][] board, String[] dictionary) {\n    TrieNode root = buildTrie(dictionary);\n    Set<String> result = new HashSet<>();\n    boolean[][] visited = new boolean[board.length][board[^3_0].length];\n\n    for (int i = 0; i < board.length; i++) {\n        for (int j = 0; j < board[^3_0].length; j++) {\n            dfsBoggle(board, i, j, root, \"\", visited, result);\n        }\n    }\n\n    return new ArrayList<>(result);\n}\n\nvoid dfsBoggle(char[][] board, int i, int j, TrieNode node, String word,\n              boolean[][] visited, Set<String> result) {\n    if (i < 0 || i >= board.length || j < 0 || j >= board[^3_0].length ||\n        visited[i][j]) {\n        return;\n    }\n\n    char c = board[i][j];\n    if (node.children[c - 'a'] == null) return;\n\n    word += c;\n    node = node.children[c - 'a'];\n\n    if (node.word != null) {\n        result.add(word);\n    }\n\n    visited[i][j] = true;\n\n    // Explore all 8 directions\n    int[][] directions = {{-1,-1}, {-1,0}, {-1,1}, {0,-1}, {0,1}, {1,-1}, {1,0}, {1,1}};\n    for (int[] dir : directions) {\n        dfsBoggle(board, i + dir[^3_0], j + dir[^3_1], node, word, visited, result);\n    }\n\n    visited[i][j] = false; // Backtrack\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-8-expression--equation-problems",children:"Pattern 8: Expression & Equation Problems"}),"\n",(0,t.jsx)(e.h3,{id:"81-expression-add-operators",children:"8.1 Expression Add Operators"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:'List<String> addOperators(String num, int target) {\n    List<String> result = new ArrayList<>();\n    backtrackOperators(result, "", num, target, 0, 0, 0);\n    return result;\n}\n\nvoid backtrackOperators(List<String> result, String expr, String num, int target,\n                       int index, long eval, long mult) {\n    if (index == num.length()) {\n        if (eval == target) {\n            result.add(expr);\n        }\n        return;\n    }\n\n    for (int i = index; i < num.length(); i++) {\n        String curr = num.substring(index, i + 1);\n\n        // Skip numbers with leading zeros (except single \'0\')\n        if (curr.length() > 1 && curr.charAt(0) == \'0\') break;\n\n        long currNum = Long.parseLong(curr);\n\n        if (index == 0) {\n            backtrackOperators(result, curr, num, target, i + 1, currNum, currNum);\n        } else {\n            // Addition\n            backtrackOperators(result, expr + "+" + curr, num, target,\n                             i + 1, eval + currNum, currNum);\n\n            // Subtraction\n            backtrackOperators(result, expr + "-" + curr, num, target,\n                             i + 1, eval - currNum, -currNum);\n\n            // Multiplication (handle precedence)\n            backtrackOperators(result, expr + "*" + curr, num, target,\n                             i + 1, eval - mult + mult * currNum, mult * currNum);\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"82-different-ways-to-add-parentheses",children:"8.2 Different Ways to Add Parentheses"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"List<Integer> diffWaysToCompute(String expression) {\n    List<Integer> result = new ArrayList<>();\n\n    for (int i = 0; i < expression.length(); i++) {\n        char c = expression.charAt(i);\n\n        if (c == '+' || c == '-' || c == '*') {\n            List<Integer> left = diffWaysToCompute(expression.substring(0, i));\n            List<Integer> right = diffWaysToCompute(expression.substring(i + 1));\n\n            for (int l : left) {\n                for (int r : right) {\n                    if (c == '+') {\n                        result.add(l + r);\n                    } else if (c == '-') {\n                        result.add(l - r);\n                    } else if (c == '*') {\n                        result.add(l * r);\n                    }\n                }\n            }\n        }\n    }\n\n    // Base case: single number\n    if (result.isEmpty()) {\n        result.add(Integer.parseInt(expression));\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"83-24-game",children:"8.3 24 Game"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"boolean judgePoint24(int[] nums) {\n    List<Double> list = new ArrayList<>();\n    for (int num : nums) {\n        list.add((double) num);\n    }\n    return backtrack24Game(list);\n}\n\nboolean backtrack24Game(List<Double> nums) {\n    if (nums.size() == 1) {\n        return Math.abs(nums.get(0) - 24.0) < 1e-6;\n    }\n\n    for (int i = 0; i < nums.size(); i++) {\n        for (int j = i + 1; j < nums.size(); j++) {\n            double a = nums.get(i);\n            double b = nums.get(j);\n\n            List<Double> next = new ArrayList<>();\n            for (int k = 0; k < nums.size(); k++) {\n                if (k != i && k != j) {\n                    next.add(nums.get(k));\n                }\n            }\n\n            // Try all operations\n            for (double c : compute(a, b)) {\n                next.add(c);\n                if (backtrack24Game(next)) {\n                    return true;\n                }\n                next.remove(next.size() - 1);\n            }\n        }\n    }\n\n    return false;\n}\n\nList<Double> compute(double a, double b) {\n    List<Double> results = new ArrayList<>();\n    results.add(a + b);\n    results.add(a - b);\n    results.add(b - a);\n    results.add(a * b);\n    if (Math.abs(b) > 1e-6) results.add(a / b);\n    if (Math.abs(a) > 1e-6) results.add(b / a);\n    return results;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-9-game--puzzle-problems",children:"Pattern 9: Game & Puzzle Problems"}),"\n",(0,t.jsx)(e.h3,{id:"91-tic-tac-toe-ai-minimax-with-backtracking",children:"9.1 Tic-Tac-Toe AI (Minimax with Backtracking)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"class TicTacToe {\n    char[][] board = new char[^3_3][^3_3];\n\n    int minimax(boolean isMaximizing) {\n        int score = evaluate();\n\n        if (score == 10) return score;  // X wins\n        if (score == -10) return score; // O wins\n        if (!isMovesLeft()) return 0;   // Tie\n\n        if (isMaximizing) {\n            int best = -1000;\n            for (int i = 0; i < 3; i++) {\n                for (int j = 0; j < 3; j++) {\n                    if (board[i][j] == ' ') {\n                        board[i][j] = 'X';\n                        best = Math.max(best, minimax(false));\n                        board[i][j] = ' '; // Backtrack\n                    }\n                }\n            }\n            return best;\n        } else {\n            int best = 1000;\n            for (int i = 0; i < 3; i++) {\n                for (int j = 0; j < 3; j++) {\n                    if (board[i][j] == ' ') {\n                        board[i][j] = 'O';\n                        best = Math.min(best, minimax(true));\n                        board[i][j] = ' '; // Backtrack\n                    }\n                }\n            }\n            return best;\n        }\n    }\n\n    int[] findBestMove() {\n        int bestVal = -1000;\n        int[] bestMove = {-1, -1};\n\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                if (board[i][j] == ' ') {\n                    board[i][j] = 'X';\n                    int moveVal = minimax(false);\n                    board[i][j] = ' '; // Backtrack\n\n                    if (moveVal > bestVal) {\n                        bestMove[^3_0] = i;\n                        bestMove[^3_1] = j;\n                        bestVal = moveVal;\n                    }\n                }\n            }\n        }\n\n        return bestMove;\n    }\n\n    int evaluate() {\n        // Check rows, columns, and diagonals\n        for (int row = 0; row < 3; row++) {\n            if (board[row][^3_0] == board[row][^3_1] && board[row][^3_1] == board[row][^3_2]) {\n                if (board[row][^3_0] == 'X') return 10;\n                else if (board[row][^3_0] == 'O') return -10;\n            }\n        }\n\n        for (int col = 0; col < 3; col++) {\n            if (board[^3_0][col] == board[^3_1][col] && board[^3_1][col] == board[^3_2][col]) {\n                if (board[^3_0][col] == 'X') return 10;\n                else if (board[^3_0][col] == 'O') return -10;\n            }\n        }\n\n        if (board[^3_0][^3_0] == board[^3_1][^3_1] && board[^3_1][^3_1] == board[^3_2][^3_2]) {\n            if (board[^3_0][^3_0] == 'X') return 10;\n            else if (board[^3_0][^3_0] == 'O') return -10;\n        }\n\n        if (board[^3_0][^3_2] == board[^3_1][^3_1] && board[^3_1][^3_1] == board[^3_2][^3_0]) {\n            if (board[^3_0][^3_2] == 'X') return 10;\n            else if (board[^3_0][^3_2] == 'O') return -10;\n        }\n\n        return 0;\n    }\n\n    boolean isMovesLeft() {\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                if (board[i][j] == ' ') return true;\n            }\n        }\n        return false;\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"92-word-ladder-with-backtracking",children:"9.2 Word Ladder with Backtracking"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n    Set<String> wordSet = new HashSet<>(wordList);\n    if (!wordSet.contains(endWord)) return new ArrayList<>();\n\n    Map<String, List<String>> neighbors = new HashMap<>();\n    Map<String, Integer> distance = new HashMap<>();\n\n    bfsWordLadder(beginWord, endWord, wordSet, neighbors, distance);\n\n    List<List<String>> result = new ArrayList<>();\n    List<String> path = new ArrayList<>();\n    path.add(beginWord);\n\n    dfsWordLadder(beginWord, endWord, neighbors, distance, path, result);\n    return result;\n}\n\nvoid bfsWordLadder(String beginWord, String endWord, Set<String> wordSet,\n                  Map<String, List<String>> neighbors, Map<String, Integer> distance) {\n    for (String word : wordSet) {\n        neighbors.put(word, new ArrayList<>());\n    }\n    neighbors.put(beginWord, new ArrayList<>());\n\n    Queue<String> queue = new LinkedList<>();\n    queue.offer(beginWord);\n    distance.put(beginWord, 0);\n\n    while (!queue.isEmpty()) {\n        boolean found = false;\n        int size = queue.size();\n\n        for (int i = 0; i < size; i++) {\n            String word = queue.poll();\n            int curDist = distance.get(word);\n\n            List<String> nextWords = getNextWords(word, wordSet);\n            for (String nextWord : nextWords) {\n                neighbors.get(word).add(nextWord);\n\n                if (!distance.containsKey(nextWord)) {\n                    distance.put(nextWord, curDist + 1);\n                    if (nextWord.equals(endWord)) {\n                        found = true;\n                    } else {\n                        queue.offer(nextWord);\n                    }\n                }\n            }\n        }\n\n        if (found) break;\n    }\n}\n\nvoid dfsWordLadder(String word, String endWord, Map<String, List<String>> neighbors,\n                  Map<String, Integer> distance, List<String> path, List<List<String>> result) {\n    if (word.equals(endWord)) {\n        result.add(new ArrayList<>(path));\n        return;\n    }\n\n    for (String neighbor : neighbors.get(word)) {\n        if (distance.get(neighbor) == distance.get(word) + 1) {\n            path.add(neighbor);\n            dfsWordLadder(neighbor, endWord, neighbors, distance, path, result);\n            path.remove(path.size() - 1);\n        }\n    }\n}\n\nList<String> getNextWords(String word, Set<String> wordSet) {\n    List<String> nextWords = new ArrayList<>();\n    char[] chars = word.toCharArray();\n\n    for (int i = 0; i < chars.length; i++) {\n        char temp = chars[i];\n        for (char c = 'a'; c <= 'z'; c++) {\n            chars[i] = c;\n            String newWord = new String(chars);\n            if (wordSet.contains(newWord) && !newWord.equals(word)) {\n                nextWords.add(newWord);\n            }\n        }\n        chars[i] = temp;\n    }\n\n    return nextWords;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-10-tree-traversal-backtracking",children:"Pattern 10: Tree Traversal Backtracking"}),"\n",(0,t.jsx)(e.h3,{id:"101-binary-tree-paths",children:"10.1 Binary Tree Paths"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:'List<String> binaryTreePaths(TreeNode root) {\n    List<String> result = new ArrayList<>();\n    if (root != null) {\n        backtrackTreePaths(root, "", result);\n    }\n    return result;\n}\n\nvoid backtrackTreePaths(TreeNode node, String path, List<String> result) {\n    if (node.left == null && node.right == null) {\n        result.add(path + node.val);\n        return;\n    }\n\n    if (node.left != null) {\n        backtrackTreePaths(node.left, path + node.val + "->", result);\n    }\n\n    if (node.right != null) {\n        backtrackTreePaths(node.right, path + node.val + "->", result);\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"102-path-sum-ii",children:"10.2 Path Sum II"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"List<List<Integer>> pathSum(TreeNode root, int targetSum) {\n    List<List<Integer>> result = new ArrayList<>();\n    backtrackPathSum(root, targetSum, new ArrayList<>(), result);\n    return result;\n}\n\nvoid backtrackPathSum(TreeNode node, int remaining, List<Integer> path, List<List<Integer>> result) {\n    if (node == null) return;\n\n    path.add(node.val);\n\n    if (node.left == null && node.right == null && remaining == node.val) {\n        result.add(new ArrayList<>(path));\n    } else {\n        backtrackPathSum(node.left, remaining - node.val, path, result);\n        backtrackPathSum(node.right, remaining - node.val, path, result);\n    }\n\n    path.remove(path.size() - 1); // Backtrack\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"103-sum-root-to-leaf-numbers",children:"10.3 Sum Root to Leaf Numbers"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"int sumNumbers(TreeNode root) {\n    return backtrackSumNumbers(root, 0);\n}\n\nint backtrackSumNumbers(TreeNode node, int currentSum) {\n    if (node == null) return 0;\n\n    currentSum = currentSum * 10 + node.val;\n\n    if (node.left == null && node.right == null) {\n        return currentSum;\n    }\n\n    return backtrackSumNumbers(node.left, currentSum) +\n           backtrackSumNumbers(node.right, currentSum);\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-11-advanced-constraint-problems",children:"Pattern 11: Advanced Constraint Problems"}),"\n",(0,t.jsx)(e.h3,{id:"111-graph-coloring",children:"11.1 Graph Coloring"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"boolean graphColoring(int[][] graph, int m) {\n    int n = graph.length;\n    int[] colors = new int[n];\n    return backtrackColoring(graph, colors, 0, m);\n}\n\nboolean backtrackColoring(int[][] graph, int[] colors, int vertex, int m) {\n    if (vertex == graph.length) return true;\n\n    for (int color = 1; color <= m; color++) {\n        if (isSafeColoring(graph, colors, vertex, color)) {\n            colors[vertex] = color;\n\n            if (backtrackColoring(graph, colors, vertex + 1, m)) {\n                return true;\n            }\n\n            colors[vertex] = 0; // Backtrack\n        }\n    }\n\n    return false;\n}\n\nboolean isSafeColoring(int[][] graph, int[] colors, int vertex, int color) {\n    for (int i = 0; i < graph.length; i++) {\n        if (graph[vertex][i] == 1 && colors[i] == color) {\n            return false;\n        }\n    }\n    return true;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"112-hamiltonian-path",children:"11.2 Hamiltonian Path"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"boolean hamiltonianPath(int[][] graph) {\n    int n = graph.length;\n    int[] path = new int[n];\n    Arrays.fill(path, -1);\n\n    // Try starting from each vertex\n    for (int start = 0; start < n; start++) {\n        path[^3_0] = start;\n        if (backtrackHamiltonian(graph, path, 1)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nboolean backtrackHamiltonian(int[][] graph, int[] path, int pos) {\n    if (pos == graph.length) return true;\n\n    for (int v = 0; v < graph.length; v++) {\n        if (isSafeHamiltonian(graph, path, pos, v)) {\n            path[pos] = v;\n\n            if (backtrackHamiltonian(graph, path, pos + 1)) {\n                return true;\n            }\n\n            path[pos] = -1; // Backtrack\n        }\n    }\n\n    return false;\n}\n\nboolean isSafeHamiltonian(int[][] graph, int[] path, int pos, int v) {\n    // Check if vertex is adjacent to previous vertex\n    if (graph[path[pos - 1]][v] == 0) return false;\n\n    // Check if vertex is already included in path\n    for (int i = 0; i < pos; i++) {\n        if (path[i] == v) return false;\n    }\n\n    return true;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-12-optimization-problems",children:"Pattern 12: Optimization Problems"}),"\n",(0,t.jsx)(e.h3,{id:"121-minimum-cost-path-with-backtracking",children:"12.1 Minimum Cost Path with Backtracking"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"int minCostPath(int[][] grid) {\n    int m = grid.length, n = grid[^3_0].length;\n    return backtrackMinCost(grid, 0, 0, m - 1, n - 1);\n}\n\nint backtrackMinCost(int[][] grid, int x, int y, int targetX, int targetY) {\n    if (x == targetX && y == targetY) {\n        return grid[x][y];\n    }\n\n    if (x > targetX || y > targetY) {\n        return Integer.MAX_VALUE;\n    }\n\n    int rightCost = backtrackMinCost(grid, x, y + 1, targetX, targetY);\n    int downCost = backtrackMinCost(grid, x + 1, y, targetX, targetY);\n\n    return grid[x][y] + Math.min(rightCost, downCost);\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"122-maximum-path-sum-with-constraints",children:"12.2 Maximum Path Sum with Constraints"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"int maxPathSum(int[][] grid, int maxSteps) {\n    boolean[][] visited = new boolean[grid.length][grid[^3_0].length];\n    return backtrackMaxPath(grid, 0, 0, visited, maxSteps);\n}\n\nint backtrackMaxPath(int[][] grid, int x, int y, boolean[][] visited, int stepsLeft) {\n    if (x < 0 || x >= grid.length || y < 0 || y >= grid[^3_0].length ||\n        visited[x][y] || stepsLeft < 0) {\n        return Integer.MIN_VALUE;\n    }\n\n    if (stepsLeft == 0) {\n        return grid[x][y];\n    }\n\n    visited[x][y] = true;\n\n    int maxSum = grid[x][y];\n    int[] dx = {-1, 1, 0, 0};\n    int[] dy = {0, 0, -1, 1};\n\n    int pathMax = Integer.MIN_VALUE;\n    for (int i = 0; i < 4; i++) {\n        int nextSum = backtrackMaxPath(grid, x + dx[i], y + dy[i], visited, stepsLeft - 1);\n        if (nextSum != Integer.MIN_VALUE) {\n            pathMax = Math.max(pathMax, nextSum);\n        }\n    }\n\n    visited[x][y] = false; // Backtrack\n\n    return pathMax == Integer.MIN_VALUE ? Integer.MIN_VALUE : maxSum + pathMax;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"time-complexity-analysis",children:"Time Complexity Analysis"}),"\n",(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{style:{textAlign:"left"},children:"Pattern"}),(0,t.jsx)(e.th,{style:{textAlign:"left"},children:"Time Complexity"}),(0,t.jsx)(e.th,{style:{textAlign:"left"},children:"Space Complexity"}),(0,t.jsx)(e.th,{style:{textAlign:"left"},children:"Use Cases"})]})}),(0,t.jsxs)(e.tbody,{children:[(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Subsets"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(2^n)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Power set generation"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Permutations"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(n!)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Arrangement problems"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Combinations"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(C(n,k))"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(k)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Selection problems"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"N-Queens"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(N!)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(N)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Constraint satisfaction"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Sudoku"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(9^(n*n))"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(n*n)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Puzzle solving"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Word Search"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(4^L)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(L)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Grid traversal"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Expression Parsing"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(4^n)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Math expressions"})]})]})]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"common-optimization-techniques",children:"Common Optimization Techniques"}),"\n",(0,t.jsx)(e.h3,{id:"pruning-strategies",children:"Pruning Strategies"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Early Termination"}),": Stop when constraints violated"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Bound Checking"}),": Use upper/lower bounds to prune"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Symmetry Breaking"}),": Avoid duplicate computations"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Constraint Propagation"}),": Forward checking validity"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Memoization"}),": Cache intermediate results when possible"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"template-optimizations",children:"Template Optimizations"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Optimized backtracking with pruning\nvoid optimizedBacktrack(int[] nums, List<Integer> current, int start, int target) {\n    // Early termination\n    if (getCurrentSum(current) > target) return;\n\n    // Bound checking\n    if (current.size() + (nums.length - start) < minRequiredSize) return;\n\n    // Goal check\n    if (isGoalReached(current, target)) {\n        processResult(current);\n        return;\n    }\n\n    for (int i = start; i < nums.length; i++) {\n        // Skip duplicates\n        if (i > start && nums[i] == nums[i-1]) continue;\n\n        // Validity check before recursion\n        if (isValidChoice(current, nums[i])) {\n            current.add(nums[i]);\n            optimizedBacktrack(nums, current, i + 1, target);\n            current.remove(current.size() - 1);\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"interview-tips--best-practices",children:"Interview Tips & Best Practices"}),"\n",(0,t.jsx)(e.h3,{id:"problem-recognition",children:"Problem Recognition"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Generate all possibilities"}),": Use backtracking"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Find one solution"}),": Often backtracking with early return"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Count solutions"}),": Backtracking with counter"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Optimize solution"}),": Add pruning and memoization"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"implementation-strategy",children:"Implementation Strategy"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Draw the decision tree"})," first[^3_2]"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Identify the choices"})," at each step"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Define base cases"})," clearly"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Implement choice, explore, unchoose"})," pattern"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Add pruning"})," for optimization"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"common-mistakes-to-avoid",children:"Common Mistakes to Avoid"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Forgetting to make a copy when adding to results"}),"\n",(0,t.jsx)(e.li,{children:"Not handling duplicates properly in sorted arrays"}),"\n",(0,t.jsx)(e.li,{children:"Missing backtracking (unchoose) step"}),"\n",(0,t.jsx)(e.li,{children:"Incorrect base case conditions"}),"\n",(0,t.jsx)(e.li,{children:"Not using visited arrays for grid problems"}),"\n"]})]})}function u(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(c,{...n})}):c(n)}}}]);