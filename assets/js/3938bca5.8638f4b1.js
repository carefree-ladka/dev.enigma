"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[86381],{28453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>u});var i=r(96540);const t={},s=i.createContext(t);function o(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function u(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),i.createElement(s.Provider,{value:n},e.children)}},40283:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>u,toc:()=>l});var i=r(74848),t=r(28453);const s={},o="Producer-Consumer Problem & Race Conditions",u={id:"Backend/Concurrency-Threading/Java Multithreading/Producer-Consumer Problem & Race Conditions",title:"Producer-Consumer Problem & Race Conditions",description:"Table of Contents",source:"@site/docs/02-Backend/Concurrency-Threading/Java Multithreading/Producer-Consumer Problem & Race Conditions.mdx",sourceDirName:"02-Backend/Concurrency-Threading/Java Multithreading",slug:"/Backend/Concurrency-Threading/Java Multithreading/Producer-Consumer Problem & Race Conditions",permalink:"/docs/Backend/Concurrency-Threading/Java Multithreading/Producer-Consumer Problem & Race Conditions",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/02-Backend/Concurrency-Threading/Java Multithreading/Producer-Consumer Problem & Race Conditions.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Java Threads & Concurrency: Understanding OS-Level Implementation",permalink:"/docs/Backend/Concurrency-Threading/Java Multithreading/Java Threads & Concurrency: Understanding OS-Level Implementation"},next:{title:"Thread Safety in System Design",permalink:"/docs/Backend/Concurrency-Threading/Java Multithreading/Thread Safety in System Design"}},a={},l=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Understanding the Problem",id:"understanding-the-problem",level:2},{value:"What is the Producer-Consumer Problem?",id:"what-is-the-producer-consumer-problem",level:3},{value:"Key Challenges",id:"key-challenges",level:3},{value:"Race Conditions Explained",id:"race-conditions-explained",level:2},{value:"What is a Race Condition?",id:"what-is-a-race-condition",level:3},{value:"Example: Simple Race Condition",id:"example-simple-race-condition",level:3},{value:"Why Race Conditions Happen",id:"why-race-conditions-happen",level:3},{value:"Solution Evolution",id:"solution-evolution",level:2},{value:"Version 1: Unsafe Producer-Consumer \u274c",id:"version-1-unsafe-producer-consumer-",level:3},{value:"Version 2: Synchronized with wait/notify \u2705",id:"version-2-synchronized-with-waitnotify-",level:3},{value:"Version 3: ReentrantLock with Conditions \u2705",id:"version-3-reentrantlock-with-conditions-",level:3},{value:"Version 4: BlockingQueue (Best Practice) \u2b50",id:"version-4-blockingqueue-best-practice-",level:3},{value:"Version 5: With Timeout and Graceful Shutdown \u2b50\u2b50",id:"version-5-with-timeout-and-graceful-shutdown-",level:3},{value:"Real-World Examples",id:"real-world-examples",level:2},{value:"Example 1: Log Processing System",id:"example-1-log-processing-system",level:3},{value:"Example 2: Image Processing Pipeline",id:"example-2-image-processing-pipeline",level:3},{value:"Advanced Patterns",id:"advanced-patterns",level:2},{value:"Pattern 1: Poison Pill for Shutdown",id:"pattern-1-poison-pill-for-shutdown",level:3},{value:"Pattern 2: Multiple Queues (Priority Processing)",id:"pattern-2-multiple-queues-priority-processing",level:3},{value:"Key Takeaways",id:"key-takeaways",level:2},{value:"Race Condition Prevention",id:"race-condition-prevention",level:3},{value:"Producer-Consumer Best Practices",id:"producer-consumer-best-practices",level:3},{value:"Solution Comparison",id:"solution-comparison",level:3},{value:"When to Use What",id:"when-to-use-what",level:3}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"producer-consumer-problem--race-conditions",children:"Producer-Consumer Problem & Race Conditions"})}),"\n",(0,i.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#understanding-the-problem",children:"Understanding the Producer-Consumer Problem"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#race-conditions-explained",children:"Race Conditions Explained"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#solution-evolution",children:"Solution Evolution"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#real-world-examples",children:"Real-World Examples"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#advanced-patterns",children:"Advanced Patterns"})}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"understanding-the-problem",children:"Understanding the Problem"}),"\n",(0,i.jsx)(n.h3,{id:"what-is-the-producer-consumer-problem",children:"What is the Producer-Consumer Problem?"}),"\n",(0,i.jsx)(n.p,{children:"The Producer-Consumer problem is a classic synchronization problem where:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Producers"})," generate data and put it into a buffer"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Consumers"})," take data from the buffer and process it"]}),"\n",(0,i.jsx)(n.li,{children:"Both operate concurrently"}),"\n",(0,i.jsx)(n.li,{children:"Buffer has limited capacity"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"key-challenges",children:"Key Challenges"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Race Conditions"})," - Multiple threads accessing shared buffer"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Buffer Overflow"})," - Producer tries to add when buffer is full"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Buffer Underflow"})," - Consumer tries to remove when buffer is empty"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Coordination"})," - Producers and consumers must wait for each other"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"race-conditions-explained",children:"Race Conditions Explained"}),"\n",(0,i.jsx)(n.h3,{id:"what-is-a-race-condition",children:"What is a Race Condition?"}),"\n",(0,i.jsx)(n.p,{children:"A race condition occurs when:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Multiple threads access shared data concurrently"}),"\n",(0,i.jsx)(n.li,{children:"At least one thread modifies the data"}),"\n",(0,i.jsx)(n.li,{children:"The outcome depends on the timing of thread execution"}),"\n",(0,i.jsx)(n.li,{children:"Results are unpredictable and incorrect"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"example-simple-race-condition",children:"Example: Simple Race Condition"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'class Counter {\n    private int count = 0;\n\n    public void increment() {\n        count++;  // NOT atomic! Three operations:\n                  // 1. Read count\n                  // 2. Add 1\n                  // 3. Write back\n    }\n\n    public int getCount() {\n        return count;\n    }\n}\n\n// Race condition in action\npublic class RaceConditionDemo {\n    public static void main(String[] args) throws InterruptedException {\n        Counter counter = new Counter();\n\n        // Create 1000 threads, each incrementing 1000 times\n        Thread[] threads = new Thread[1000];\n        for (int i = 0; i < threads.length; i++) {\n            threads[i] = new Thread(() -> {\n                for (int j = 0; j < 1000; j++) {\n                    counter.increment();\n                }\n            });\n            threads[i].start();\n        }\n\n        // Wait for all threads\n        for (Thread thread : threads) {\n            thread.join();\n        }\n\n        // Expected: 1,000,000\n        // Actual: Usually less (e.g., 987,432)\n        System.out.println("Count: " + counter.getCount());\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"why-race-conditions-happen",children:"Why Race Conditions Happen"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Thread 1              Thread 2\n--------              --------\nRead count (0)\n                      Read count (0)\nAdd 1 (result: 1)\n                      Add 1 (result: 1)\nWrite 1\n                      Write 1\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Result"}),": Both threads read 0, both write 1. One increment is lost!"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"solution-evolution",children:"Solution Evolution"}),"\n",(0,i.jsx)(n.h3,{id:"version-1-unsafe-producer-consumer-",children:"Version 1: Unsafe Producer-Consumer \u274c"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'import java.util.LinkedList;\nimport java.util.Queue;\n\nclass UnsafeBuffer {\n    private Queue<Integer> buffer = new LinkedList<>();\n    private int capacity = 10;\n\n    // RACE CONDITION: Multiple producers can add simultaneously\n    public void produce(Integer item) {\n        if (buffer.size() < capacity) {\n            buffer.add(item);\n            System.out.println("Produced: " + item);\n        } else {\n            System.out.println("Buffer full!");\n        }\n    }\n\n    // RACE CONDITION: Multiple consumers can remove simultaneously\n    public Integer consume() {\n        if (!buffer.isEmpty()) {\n            Integer item = buffer.poll();\n            System.out.println("Consumed: " + item);\n            return item;\n        } else {\n            System.out.println("Buffer empty!");\n            return null;\n        }\n    }\n}\n\n// Usage (UNSAFE)\nclass Producer implements Runnable {\n    private UnsafeBuffer buffer;\n    private int id;\n\n    public Producer(UnsafeBuffer buffer, int id) {\n        this.buffer = buffer;\n        this.id = id;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 10; i++) {\n            buffer.produce(id * 100 + i);\n            try { Thread.sleep(100); } catch (InterruptedException e) {}\n        }\n    }\n}\n\nclass Consumer implements Runnable {\n    private UnsafeBuffer buffer;\n\n    public Consumer(UnsafeBuffer buffer) {\n        this.buffer = buffer;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 10; i++) {\n            buffer.consume();\n            try { Thread.sleep(150); } catch (InterruptedException e) {}\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Problems:"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Check-then-act race condition in both methods"}),"\n",(0,i.jsx)(n.li,{children:"No coordination between producers and consumers"}),"\n",(0,i.jsx)(n.li,{children:"Busy waiting when buffer is full/empty"}),"\n",(0,i.jsx)(n.li,{children:"Data corruption possible"}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"version-2-synchronized-with-waitnotify-",children:"Version 2: Synchronized with wait/notify \u2705"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'import java.util.LinkedList;\nimport java.util.Queue;\n\nclass SynchronizedBuffer {\n    private Queue<Integer> buffer = new LinkedList<>();\n    private int capacity;\n\n    public SynchronizedBuffer(int capacity) {\n        this.capacity = capacity;\n    }\n\n    public synchronized void produce(Integer item) throws InterruptedException {\n        // Wait while buffer is full\n        while (buffer.size() == capacity) {\n            System.out.println("Buffer full, producer waiting...");\n            wait();  // Releases lock and waits\n        }\n\n        buffer.add(item);\n        System.out.println("Produced: " + item + " | Buffer size: " + buffer.size());\n\n        // Notify waiting consumers\n        notifyAll();\n    }\n\n    public synchronized Integer consume() throws InterruptedException {\n        // Wait while buffer is empty\n        while (buffer.isEmpty()) {\n            System.out.println("Buffer empty, consumer waiting...");\n            wait();  // Releases lock and waits\n        }\n\n        Integer item = buffer.poll();\n        System.out.println("Consumed: " + item + " | Buffer size: " + buffer.size());\n\n        // Notify waiting producers\n        notifyAll();\n\n        return item;\n    }\n\n    public synchronized int size() {\n        return buffer.size();\n    }\n}\n\n// Usage\nclass Producer implements Runnable {\n    private SynchronizedBuffer buffer;\n    private int id;\n\n    public Producer(SynchronizedBuffer buffer, int id) {\n        this.buffer = buffer;\n        this.id = id;\n    }\n\n    @Override\n    public void run() {\n        try {\n            for (int i = 0; i < 10; i++) {\n                buffer.produce(id * 100 + i);\n                Thread.sleep(100);\n            }\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}\n\nclass Consumer implements Runnable {\n    private SynchronizedBuffer buffer;\n    private int id;\n\n    public Consumer(SynchronizedBuffer buffer, int id) {\n        this.buffer = buffer;\n        this.id = id;\n    }\n\n    @Override\n    public void run() {\n        try {\n            for (int i = 0; i < 10; i++) {\n                Integer item = buffer.consume();\n                Thread.sleep(150);\n            }\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}\n\n// Test\npublic class ProducerConsumerTest {\n    public static void main(String[] args) {\n        SynchronizedBuffer buffer = new SynchronizedBuffer(5);\n\n        // Create multiple producers and consumers\n        Thread p1 = new Thread(new Producer(buffer, 1), "Producer-1");\n        Thread p2 = new Thread(new Producer(buffer, 2), "Producer-2");\n        Thread c1 = new Thread(new Consumer(buffer, 1), "Consumer-1");\n        Thread c2 = new Thread(new Consumer(buffer, 2), "Consumer-2");\n\n        p1.start();\n        p2.start();\n        c1.start();\n        c2.start();\n    }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Key Points:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"synchronized"})," ensures mutual exclusion"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"wait()"})," releases lock and suspends thread"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"notifyAll()"})," wakes up all waiting threads"]}),"\n",(0,i.jsxs)(n.li,{children:["Always use ",(0,i.jsx)(n.code,{children:"while"})," loop, not ",(0,i.jsx)(n.code,{children:"if"})," (spurious wakeups)"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["Important: Why ",(0,i.jsx)(n.code,{children:"while"})," not ",(0,i.jsx)(n.code,{children:"if"}),"?"]})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"// WRONG - can cause issues with multiple threads\nif (buffer.isEmpty()) {\n    wait();\n}\n\n// CORRECT - recheck condition after waking up\nwhile (buffer.isEmpty()) {\n    wait();\n}\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"version-3-reentrantlock-with-conditions-",children:"Version 3: ReentrantLock with Conditions \u2705"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\nclass LockBasedBuffer {\n    private Queue<Integer> buffer = new LinkedList<>();\n    private int capacity;\n    private Lock lock = new ReentrantLock();\n    private Condition notFull = lock.newCondition();\n    private Condition notEmpty = lock.newCondition();\n\n    public LockBasedBuffer(int capacity) {\n        this.capacity = capacity;\n    }\n\n    public void produce(Integer item) throws InterruptedException {\n        lock.lock();\n        try {\n            // Wait while buffer is full\n            while (buffer.size() == capacity) {\n                System.out.println(Thread.currentThread().getName() +\n                                   " - Buffer full, waiting...");\n                notFull.await();  // Wait on condition\n            }\n\n            buffer.add(item);\n            System.out.println(Thread.currentThread().getName() +\n                               " - Produced: " + item + " | Size: " + buffer.size());\n\n            notEmpty.signal();  // Signal consumers\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public Integer consume() throws InterruptedException {\n        lock.lock();\n        try {\n            // Wait while buffer is empty\n            while (buffer.isEmpty()) {\n                System.out.println(Thread.currentThread().getName() +\n                                   " - Buffer empty, waiting...");\n                notEmpty.await();  // Wait on condition\n            }\n\n            Integer item = buffer.poll();\n            System.out.println(Thread.currentThread().getName() +\n                               " - Consumed: " + item + " | Size: " + buffer.size());\n\n            notFull.signal();  // Signal producers\n\n            return item;\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Advantages over synchronized:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Separate conditions for producers and consumers"}),"\n",(0,i.jsx)(n.li,{children:"More explicit and readable"}),"\n",(0,i.jsxs)(n.li,{children:["Can use ",(0,i.jsx)(n.code,{children:"signal()"})," instead of ",(0,i.jsx)(n.code,{children:"signalAll()"})," for efficiency"]}),"\n",(0,i.jsx)(n.li,{children:"Fair lock option available"}),"\n",(0,i.jsx)(n.li,{children:"Interruptible lock acquisition"}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"version-4-blockingqueue-best-practice-",children:"Version 4: BlockingQueue (Best Practice) \u2b50"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'import java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.ArrayBlockingQueue;\n\nclass Producer implements Runnable {\n    private BlockingQueue<Integer> queue;\n    private int id;\n\n    public Producer(BlockingQueue<Integer> queue, int id) {\n        this.queue = queue;\n        this.id = id;\n    }\n\n    @Override\n    public void run() {\n        try {\n            for (int i = 0; i < 10; i++) {\n                int item = id * 100 + i;\n                queue.put(item);  // Blocks if queue is full\n                System.out.println(Thread.currentThread().getName() +\n                                   " produced: " + item);\n                Thread.sleep(100);\n            }\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}\n\nclass Consumer implements Runnable {\n    private BlockingQueue<Integer> queue;\n    private int id;\n\n    public Consumer(BlockingQueue<Integer> queue, int id) {\n        this.queue = queue;\n        this.id = id;\n    }\n\n    @Override\n    public void run() {\n        try {\n            for (int i = 0; i < 10; i++) {\n                Integer item = queue.take();  // Blocks if queue is empty\n                System.out.println(Thread.currentThread().getName() +\n                                   " consumed: " + item);\n                Thread.sleep(150);\n            }\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}\n\npublic class BlockingQueueExample {\n    public static void main(String[] args) {\n        // Bounded blocking queue with capacity 5\n        BlockingQueue<Integer> queue = new ArrayBlockingQueue<>(5);\n\n        // Create multiple producers and consumers\n        Thread p1 = new Thread(new Producer(queue, 1), "Producer-1");\n        Thread p2 = new Thread(new Producer(queue, 2), "Producer-2");\n        Thread c1 = new Thread(new Consumer(queue, 1), "Consumer-1");\n        Thread c2 = new Thread(new Consumer(queue, 2), "Consumer-2");\n        Thread c3 = new Thread(new Consumer(queue, 3), "Consumer-3");\n\n        p1.start();\n        p2.start();\n        c1.start();\n        c2.start();\n        c3.start();\n    }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Why BlockingQueue is Best:"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Thread-safe by design"}),"\n",(0,i.jsx)(n.li,{children:"No manual synchronization needed"}),"\n",(0,i.jsx)(n.li,{children:"Clean, readable code"}),"\n",(0,i.jsx)(n.li,{children:"Multiple implementations available"}),"\n",(0,i.jsx)(n.li,{children:"Built-in timeout support"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"BlockingQueue Implementations:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"// Fixed capacity, array-backed\nBlockingQueue<Integer> queue1 = new ArrayBlockingQueue<>(100);\n\n// Unbounded, linked nodes\nBlockingQueue<Integer> queue2 = new LinkedBlockingQueue<>();\n\n// Priority queue\nBlockingQueue<Integer> queue3 = new PriorityBlockingQueue<>();\n\n// No storage, direct handoff\nBlockingQueue<Integer> queue4 = new SynchronousQueue<>();\n\n// Delayed elements\nBlockingQueue<Delayed> queue5 = new DelayQueue<>();\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"version-5-with-timeout-and-graceful-shutdown-",children:"Version 5: With Timeout and Graceful Shutdown \u2b50\u2b50"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'import java.util.concurrent.*;\n\nclass ImprovedProducer implements Runnable {\n    private BlockingQueue<Integer> queue;\n    private int id;\n    private volatile boolean running = true;\n\n    public ImprovedProducer(BlockingQueue<Integer> queue, int id) {\n        this.queue = queue;\n        this.id = id;\n    }\n\n    public void shutdown() {\n        running = false;\n    }\n\n    @Override\n    public void run() {\n        try {\n            int count = 0;\n            while (running) {\n                int item = id * 1000 + count++;\n\n                // Try to add with timeout\n                boolean added = queue.offer(item, 1, TimeUnit.SECONDS);\n\n                if (added) {\n                    System.out.println(Thread.currentThread().getName() +\n                                       " produced: " + item);\n                } else {\n                    System.out.println(Thread.currentThread().getName() +\n                                       " timeout, queue full");\n                }\n\n                Thread.sleep(100);\n            }\n\n            System.out.println(Thread.currentThread().getName() + " shutting down");\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}\n\nclass ImprovedConsumer implements Runnable {\n    private BlockingQueue<Integer> queue;\n    private int id;\n    private volatile boolean running = true;\n\n    public ImprovedConsumer(BlockingQueue<Integer> queue, int id) {\n        this.queue = queue;\n        this.id = id;\n    }\n\n    public void shutdown() {\n        running = false;\n    }\n\n    @Override\n    public void run() {\n        try {\n            while (running) {\n                // Try to take with timeout\n                Integer item = queue.poll(1, TimeUnit.SECONDS);\n\n                if (item != null) {\n                    System.out.println(Thread.currentThread().getName() +\n                                       " consumed: " + item);\n                    // Process item\n                    Thread.sleep(150);\n                } else {\n                    System.out.println(Thread.currentThread().getName() +\n                                       " timeout, queue empty");\n                }\n            }\n\n            System.out.println(Thread.currentThread().getName() + " shutting down");\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}\n\npublic class GracefulShutdownExample {\n    public static void main(String[] args) throws InterruptedException {\n        BlockingQueue<Integer> queue = new ArrayBlockingQueue<>(5);\n\n        ImprovedProducer producer1 = new ImprovedProducer(queue, 1);\n        ImprovedProducer producer2 = new ImprovedProducer(queue, 2);\n        ImprovedConsumer consumer1 = new ImprovedConsumer(queue, 1);\n        ImprovedConsumer consumer2 = new ImprovedConsumer(queue, 2);\n\n        Thread p1 = new Thread(producer1, "Producer-1");\n        Thread p2 = new Thread(producer2, "Producer-2");\n        Thread c1 = new Thread(consumer1, "Consumer-1");\n        Thread c2 = new Thread(consumer2, "Consumer-2");\n\n        p1.start();\n        p2.start();\n        c1.start();\n        c2.start();\n\n        // Run for 5 seconds\n        Thread.sleep(5000);\n\n        // Graceful shutdown\n        System.out.println("\\n=== Initiating shutdown ===\\n");\n        producer1.shutdown();\n        producer2.shutdown();\n        consumer1.shutdown();\n        consumer2.shutdown();\n\n        // Wait for threads to finish\n        p1.join();\n        p2.join();\n        c1.join();\n        c2.join();\n\n        System.out.println("\\n=== All threads terminated ===");\n    }\n}\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"real-world-examples",children:"Real-World Examples"}),"\n",(0,i.jsx)(n.h3,{id:"example-1-log-processing-system",children:"Example 1: Log Processing System"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'import java.util.concurrent.*;\n\nclass LogEntry {\n    private String message;\n    private long timestamp;\n\n    public LogEntry(String message) {\n        this.message = message;\n        this.timestamp = System.currentTimeMillis();\n    }\n\n    public String getMessage() { return message; }\n    public long getTimestamp() { return timestamp; }\n\n    @Override\n    public String toString() {\n        return "[" + timestamp + "] " + message;\n    }\n}\n\nclass LogProducer implements Runnable {\n    private BlockingQueue<LogEntry> queue;\n    private String source;\n\n    public LogProducer(BlockingQueue<LogEntry> queue, String source) {\n        this.queue = queue;\n        this.source = source;\n    }\n\n    @Override\n    public void run() {\n        try {\n            for (int i = 0; i < 20; i++) {\n                LogEntry entry = new LogEntry(source + " - Event " + i);\n                queue.put(entry);\n                Thread.sleep(ThreadLocalRandom.current().nextInt(100, 300));\n            }\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}\n\nclass LogProcessor implements Runnable {\n    private BlockingQueue<LogEntry> queue;\n    private String name;\n\n    public LogProcessor(BlockingQueue<LogEntry> queue, String name) {\n        this.queue = queue;\n        this.name = name;\n    }\n\n    @Override\n    public void run() {\n        try {\n            while (!Thread.currentThread().isInterrupted()) {\n                LogEntry entry = queue.poll(1, TimeUnit.SECONDS);\n                if (entry != null) {\n                    processLog(entry);\n                }\n            }\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n\n    private void processLog(LogEntry entry) throws InterruptedException {\n        System.out.println(name + " processing: " + entry);\n        // Simulate processing\n        Thread.sleep(200);\n    }\n}\n\npublic class LogProcessingSystem {\n    public static void main(String[] args) throws InterruptedException {\n        BlockingQueue<LogEntry> queue = new LinkedBlockingQueue<>(50);\n\n        // Multiple log sources (producers)\n        ExecutorService producers = Executors.newFixedThreadPool(3);\n        producers.submit(new LogProducer(queue, "WebServer"));\n        producers.submit(new LogProducer(queue, "Database"));\n        producers.submit(new LogProducer(queue, "Cache"));\n\n        // Multiple log processors (consumers)\n        ExecutorService consumers = Executors.newFixedThreadPool(2);\n        consumers.submit(new LogProcessor(queue, "Processor-1"));\n        consumers.submit(new LogProcessor(queue, "Processor-2"));\n\n        // Shutdown after work is done\n        producers.shutdown();\n        producers.awaitTermination(1, TimeUnit.MINUTES);\n\n        Thread.sleep(5000); // Let consumers finish\n        consumers.shutdownNow();\n    }\n}\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"example-2-image-processing-pipeline",children:"Example 2: Image Processing Pipeline"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'import java.util.concurrent.*;\nimport java.util.List;\nimport java.util.ArrayList;\n\nclass Image {\n    private String filename;\n    private byte[] data;\n\n    public Image(String filename, byte[] data) {\n        this.filename = filename;\n        this.data = data;\n    }\n\n    public String getFilename() { return filename; }\n    public byte[] getData() { return data; }\n}\n\nclass ImageLoader implements Runnable {\n    private BlockingQueue<Image> queue;\n    private List<String> files;\n\n    public ImageLoader(BlockingQueue<Image> queue, List<String> files) {\n        this.queue = queue;\n        this.files = files;\n    }\n\n    @Override\n    public void run() {\n        try {\n            for (String file : files) {\n                // Simulate loading image\n                System.out.println("Loading: " + file);\n                Thread.sleep(100);\n                byte[] data = new byte[1024]; // Simulated image data\n                queue.put(new Image(file, data));\n            }\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}\n\nclass ImageProcessor implements Runnable {\n    private BlockingQueue<Image> inputQueue;\n    private BlockingQueue<Image> outputQueue;\n\n    public ImageProcessor(BlockingQueue<Image> input, BlockingQueue<Image> output) {\n        this.inputQueue = input;\n        this.outputQueue = output;\n    }\n\n    @Override\n    public void run() {\n        try {\n            while (!Thread.currentThread().isInterrupted()) {\n                Image img = inputQueue.poll(1, TimeUnit.SECONDS);\n                if (img != null) {\n                    // Process image\n                    System.out.println("Processing: " + img.getFilename());\n                    Thread.sleep(200);\n                    outputQueue.put(img);\n                }\n            }\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}\n\nclass ImageSaver implements Runnable {\n    private BlockingQueue<Image> queue;\n\n    public ImageSaver(BlockingQueue<Image> queue) {\n        this.queue = queue;\n    }\n\n    @Override\n    public void run() {\n        try {\n            while (!Thread.currentThread().isInterrupted()) {\n                Image img = queue.poll(1, TimeUnit.SECONDS);\n                if (img != null) {\n                    // Save image\n                    System.out.println("Saving: " + img.getFilename());\n                    Thread.sleep(150);\n                }\n            }\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}\n\npublic class ImageProcessingPipeline {\n    public static void main(String[] args) throws InterruptedException {\n        BlockingQueue<Image> loadQueue = new ArrayBlockingQueue<>(10);\n        BlockingQueue<Image> saveQueue = new ArrayBlockingQueue<>(10);\n\n        // Create file list\n        List<String> files = new ArrayList<>();\n        for (int i = 1; i <= 20; i++) {\n            files.add("image" + i + ".jpg");\n        }\n\n        // Create pipeline\n        Thread loader = new Thread(new ImageLoader(loadQueue, files));\n        Thread processor1 = new Thread(new ImageProcessor(loadQueue, saveQueue));\n        Thread processor2 = new Thread(new ImageProcessor(loadQueue, saveQueue));\n        Thread saver = new Thread(new ImageSaver(saveQueue));\n\n        loader.start();\n        processor1.start();\n        processor2.start();\n        saver.start();\n\n        loader.join();\n        Thread.sleep(10000); // Wait for processing\n        processor1.interrupt();\n        processor2.interrupt();\n        saver.interrupt();\n    }\n}\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"advanced-patterns",children:"Advanced Patterns"}),"\n",(0,i.jsx)(n.h3,{id:"pattern-1-poison-pill-for-shutdown",children:"Pattern 1: Poison Pill for Shutdown"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'class Task {\n    private String data;\n    public static final Task POISON_PILL = new Task(null);\n\n    public Task(String data) {\n        this.data = data;\n    }\n\n    public boolean isPoisonPill() {\n        return this == POISON_PILL;\n    }\n\n    public String getData() {\n        return data;\n    }\n}\n\nclass PoisonPillConsumer implements Runnable {\n    private BlockingQueue<Task> queue;\n\n    public PoisonPillConsumer(BlockingQueue<Task> queue) {\n        this.queue = queue;\n    }\n\n    @Override\n    public void run() {\n        try {\n            while (true) {\n                Task task = queue.take();\n\n                if (task.isPoisonPill()) {\n                    System.out.println("Received poison pill, shutting down");\n                    break;\n                }\n\n                // Process task\n                System.out.println("Processing: " + task.getData());\n                Thread.sleep(100);\n            }\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}\n\npublic class PoisonPillExample {\n    public static void main(String[] args) throws InterruptedException {\n        BlockingQueue<Task> queue = new ArrayBlockingQueue<>(10);\n\n        Thread consumer = new Thread(new PoisonPillConsumer(queue));\n        consumer.start();\n\n        // Producer adds tasks\n        for (int i = 0; i < 5; i++) {\n            queue.put(new Task("Task-" + i));\n        }\n\n        // Send poison pill to signal shutdown\n        queue.put(Task.POISON_PILL);\n\n        consumer.join();\n        System.out.println("Consumer terminated gracefully");\n    }\n}\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"pattern-2-multiple-queues-priority-processing",children:"Pattern 2: Multiple Queues (Priority Processing)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'class PriorityTask implements Comparable<PriorityTask> {\n    private String data;\n    private int priority;\n\n    public PriorityTask(String data, int priority) {\n        this.data = data;\n        this.priority = priority;\n    }\n\n    @Override\n    public int compareTo(PriorityTask other) {\n        return Integer.compare(other.priority, this.priority); // Higher priority first\n    }\n\n    public String getData() { return data; }\n    public int getPriority() { return priority; }\n}\n\npublic class PriorityProcessingExample {\n    public static void main(String[] args) throws InterruptedException {\n        BlockingQueue<PriorityTask> queue = new PriorityBlockingQueue<>();\n\n        // Consumer\n        Thread consumer = new Thread(() -> {\n            try {\n                while (!Thread.currentThread().isInterrupted()) {\n                    PriorityTask task = queue.poll(1, TimeUnit.SECONDS);\n                    if (task != null) {\n                        System.out.println("Processing (Priority " +\n                                           task.getPriority() + "): " +\n                                           task.getData());\n                        Thread.sleep(500);\n                    }\n                }\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n        });\n        consumer.start();\n\n        // Producer adds tasks with different priorities\n        queue.put(new PriorityTask("Low priority task", 1));\n        queue.put(new PriorityTask("High priority task", 10));\n        queue.put(new PriorityTask("Medium priority task", 5));\n        queue.put(new PriorityTask("Critical task", 20));\n\n        Thread.sleep(5000);\n        consumer.interrupt();\n    }\n}\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,i.jsx)(n.h3,{id:"race-condition-prevention",children:"Race Condition Prevention"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Use proper synchronization (synchronized, locks)"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Make operations atomic"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Use thread-safe data structures"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Minimize shared mutable state"}),"\n",(0,i.jsxs)(n.li,{children:["\u2705 Always use ",(0,i.jsx)(n.code,{children:"while"})," loops with wait conditions"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"producer-consumer-best-practices",children:"Producer-Consumer Best Practices"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\u2b50 ",(0,i.jsx)(n.strong,{children:"Use BlockingQueue"})," - Simple, safe, efficient"]}),"\n",(0,i.jsxs)(n.li,{children:["\u2b50 ",(0,i.jsx)(n.strong,{children:"Bounded buffers"})," - Prevent memory issues"]}),"\n",(0,i.jsxs)(n.li,{children:["\u2b50 ",(0,i.jsx)(n.strong,{children:"Graceful shutdown"})," - Use poison pills or volatile flags"]}),"\n",(0,i.jsxs)(n.li,{children:["\u2b50 ",(0,i.jsx)(n.strong,{children:"Handle interrupts"})," - Properly terminate threads"]}),"\n",(0,i.jsxs)(n.li,{children:["\u2b50 ",(0,i.jsx)(n.strong,{children:"Use thread pools"})," - Better resource management"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"solution-comparison",children:"Solution Comparison"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Approach"}),(0,i.jsx)(n.th,{children:"Complexity"}),(0,i.jsx)(n.th,{children:"Performance"}),(0,i.jsx)(n.th,{children:"Recommended"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Unsafe"}),(0,i.jsx)(n.td,{children:"Low"}),(0,i.jsx)(n.td,{children:"High"}),(0,i.jsx)(n.td,{children:"\u274c Never"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"synchronized + wait/notify"}),(0,i.jsx)(n.td,{children:"Medium"}),(0,i.jsx)(n.td,{children:"Medium"}),(0,i.jsx)(n.td,{children:"\u2705 Learning"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"ReentrantLock + Conditions"}),(0,i.jsx)(n.td,{children:"High"}),(0,i.jsx)(n.td,{children:"Medium"}),(0,i.jsx)(n.td,{children:"\u2705 Advanced control"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"BlockingQueue"}),(0,i.jsx)(n.td,{children:"Low"}),(0,i.jsx)(n.td,{children:"High"}),(0,i.jsx)(n.td,{children:"\u2b50 Production"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Atomic variables"}),(0,i.jsx)(n.td,{children:"Low"}),(0,i.jsx)(n.td,{children:"Very High"}),(0,i.jsx)(n.td,{children:"\u2b50 Simple counters"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"when-to-use-what",children:"When to Use What"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Simple producer-consumer"}),": ",(0,i.jsx)(n.code,{children:"BlockingQueue"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Complex coordination"}),": ",(0,i.jsx)(n.code,{children:"ReentrantLock"})," with multiple conditions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Legacy code"}),": ",(0,i.jsx)(n.code,{children:"synchronized"})," with wait/notify"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Priority processing"}),": ",(0,i.jsx)(n.code,{children:"PriorityBlockingQueue"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Direct handoff"}),": ",(0,i.jsx)(n.code,{children:"SynchronousQueue"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Delayed tasks"}),": ",(0,i.jsx)(n.code,{children:"DelayQueue"})]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Remember:"})," The best solution is the simplest one that meets your requirements!"]})]})}function d(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);