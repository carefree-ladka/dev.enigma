"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[265],{28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>c});var o=t(96540);const l={},r=o.createContext(l);function a(e){const n=o.useContext(r);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:a(e.components),o.createElement(r.Provider,{value:n},e.children)}},49012:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>a,default:()=>i,frontMatter:()=>r,metadata:()=>c,toc:()=>u});var o=t(74848),l=t(28453);const r={},a="Debounce and Throttle",c={id:"WebDev/React/DebounceThrottle",title:"Debounce and Throttle",description:"",source:"@site/docs/WebDev/React/DebounceThrottle.mdx",sourceDirName:"WebDev/React",slug:"/WebDev/React/DebounceThrottle",permalink:"/dev.enigma/docs/WebDev/React/DebounceThrottle",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/WebDev/React/DebounceThrottle.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Custom Events",permalink:"/dev.enigma/docs/WebDev/React/CustomEvents"},next:{title:"Error Boundary",permalink:"/dev.enigma/docs/WebDev/React/ErrorBoundary"}},s={},u=[];function d(e){const n={code:"code",h1:"h1",header:"header",pre:"pre",...(0,l.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"debounce-and-throttle",children:"Debounce and Throttle"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'// Custom hook for debouncing\nimport { useState, useEffect, useCallback } from \'react\';\n\nfunction useDebounce(value, delay) {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n\n  useEffect(() => {\n    const timer = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n\n    return () => {\n      clearTimeout(timer);\n    };\n  }, [value, delay]);\n\n  return debouncedValue;\n}\n\n// Custom hook for throttling\nfunction useThrottle(value, delay) {\n  const [throttledValue, setThrottledValue] = useState(value);\n  const [lastExecuted, setLastExecuted] = useState(Date.now());\n\n  useEffect(() => {\n    const now = Date.now();\n    const timeSinceLastExecution = now - lastExecuted;\n\n    if (timeSinceLastExecution >= delay) {\n      setThrottledValue(value);\n      setLastExecuted(now);\n    } else {\n      const timer = setTimeout(() => {\n        setThrottledValue(value);\n        setLastExecuted(Date.now());\n      }, delay - timeSinceLastExecution);\n\n      return () => clearTimeout(timer);\n    }\n  }, [value, delay, lastExecuted]);\n\n  return throttledValue;\n}\n\n// Example component using both debounce and throttle\nfunction SearchComponent() {\n  const [searchTerm, setSearchTerm] = useState(\'\');\n  const [scrollPosition, setScrollPosition] = useState(0);\n\n  // Debounced search term - only updates after user stops typing for 500ms\n  const debouncedSearchTerm = useDebounce(searchTerm, 500);\n\n  // Throttled scroll position - only updates once every 200ms maximum\n  const throttledScrollPosition = useThrottle(scrollPosition, 200);\n\n  // Simulated API call using debounced value\n  useEffect(() => {\n    if (debouncedSearchTerm) {\n      console.log(`Making API call with: ${debouncedSearchTerm}`);\n      // Actual API call would go here\n    }\n  }, [debouncedSearchTerm]);\n\n  // Scroll handler using throttled value\n  useEffect(() => {\n    const handleScroll = () => {\n      setScrollPosition(window.scrollY);\n    };\n\n    window.addEventListener(\'scroll\', handleScroll);\n    return () => window.removeEventListener(\'scroll\', handleScroll);\n  }, []);\n\n  return (\n    <div className="p-4">\n      <div className="mb-4">\n        <h3 className="text-lg font-bold mb-2">Debounced Search</h3>\n        <input\n          type="text"\n          value={searchTerm}\n          onChange={e => setSearchTerm(e.target.value)}\n          placeholder="Search..."\n          className="border p-2 rounded"\n        />\n        <p className="mt-2">\n          Immediate value: {searchTerm}\n          <br />\n          Debounced value: {debouncedSearchTerm}\n        </p>\n      </div>\n\n      <div>\n        <h3 className="text-lg font-bold mb-2">Throttled Scroll</h3>\n        <p>\n          Immediate scroll position: {scrollPosition}px\n          <br />\n          Throttled scroll position: {throttledScrollPosition}px\n        </p>\n      </div>\n    </div>\n  );\n}\n\n// Alternative implementation using pure functions\nconst debounce = (func, delay) => {\n  let timeoutId;\n\n  return (...args) => {\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n    }\n\n    timeoutId = setTimeout(() => {\n      func.apply(null, args);\n    }, delay);\n  };\n};\n\nconst throttle = (func, delay) => {\n  let lastExecuted = 0;\n  let timeoutId;\n\n  return (...args) => {\n    const now = Date.now();\n\n    if (now - lastExecuted >= delay) {\n      func.apply(null, args);\n      lastExecuted = now;\n    } else {\n      clearTimeout(timeoutId);\n      timeoutId = setTimeout(\n        () => {\n          func.apply(null, args);\n          lastExecuted = Date.now();\n        },\n        delay - (now - lastExecuted)\n      );\n    }\n  };\n};\n\n// Example usage of pure functions\nfunction EventHandlingComponent() {\n  const handleSearch = useCallback(\n    debounce(term => {\n      console.log(`Searching for: ${term}`);\n      // API call would go here\n    }, 500),\n    []\n  );\n\n  const handleScroll = useCallback(\n    throttle(position => {\n      console.log(`Scroll position: ${position}`);\n      // Handle scroll logic here\n    }, 200),\n    []\n  );\n\n  return (\n    <div>\n      <input\n        type="text"\n        onChange={e => handleSearch(e.target.value)}\n        placeholder="Search with debounce..."\n        className="border p-2 rounded"\n      />\n    </div>\n  );\n}\n\nexport {\n  useDebounce,\n  useThrottle,\n  SearchComponent,\n  EventHandlingComponent,\n  debounce,\n  throttle,\n};\n'})})]})}function i(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);