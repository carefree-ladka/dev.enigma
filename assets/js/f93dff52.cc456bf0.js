"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[4076],{1151:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>a,frontMatter:()=>o,metadata:()=>c,toc:()=>d});var i=t(74848),r=t(28453);const o={title:"Cycle Detection in Graphs"},s=void 0,c={id:"DSA/DSA with JavaScript/CycleDetectionGraph",title:"Cycle Detection in Graphs",description:"Cycle detection is an essential aspect of graph theory, used to identify whether a graph contains cycles. This document outlines methods for detecting cycles in both directed and undirected graphs.",source:"@site/docs/DSA/DSA with JavaScript/CycleDetectionGraph.mdx",sourceDirName:"DSA/DSA with JavaScript",slug:"/DSA/DSA with JavaScript/CycleDetectionGraph",permalink:"/dev.enigma/docs/DSA/DSA with JavaScript/CycleDetectionGraph",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with JavaScript/CycleDetectionGraph.mdx",tags:[],version:"current",frontMatter:{title:"Cycle Detection in Graphs"},sidebar:"tutorialSidebar",previous:{title:"Counting Sort",permalink:"/dev.enigma/docs/DSA/DSA with JavaScript/CountingSort"},next:{title:"Cyclic Sort Algorithm",permalink:"/dev.enigma/docs/DSA/DSA with JavaScript/CyclicSort"}},l={},d=[{value:"Cycle Detection in Directed Graphs",id:"cycle-detection-in-directed-graphs",level:3},{value:"Steps of Kahn&#39;s Algorithm",id:"steps-of-kahns-algorithm",level:2},{value:"Cycle Detection in Undirected Graphs",id:"cycle-detection-in-undirected-graphs",level:3},{value:"Union-Find (Disjoint Set) for Cycle Detection in Undirected Graphs",id:"union-find-disjoint-set-for-cycle-detection-in-undirected-graphs",level:3}];function h(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"Cycle detection is an essential aspect of graph theory, used to identify whether a graph contains cycles. This document outlines methods for detecting cycles in both directed and undirected graphs."}),"\n",(0,i.jsx)(n.h3,{id:"cycle-detection-in-directed-graphs",children:"Cycle Detection in Directed Graphs"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"DFS"}),"\n",(0,i.jsx)(n.li,{children:"BFS"}),"\n",(0,i.jsx)(n.li,{children:"Kahn's Algorithm (Topological Sorting)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Kahn's Algorithm is a method used to detect cycles in directed graphs by attempting to find a topological ordering. If a topological order exists, the graph is acyclic; otherwise, it contains at least one cycle."}),"\n",(0,i.jsx)(n.h2,{id:"steps-of-kahns-algorithm",children:"Steps of Kahn's Algorithm"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Compute In-Degree"}),": Calculate the in-degree (the number of incoming edges) for each vertex in the graph."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Initialize the Queue"}),": Enqueue all vertices with an in-degree of 0 (vertices with no incoming edges)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Process the Queue"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Dequeue a vertex and increment a counter for visited nodes."}),"\n",(0,i.jsx)(n.li,{children:"For each neighboring vertex, decrease its in-degree. If a neighbor\u2019s in-degree becomes 0, enqueue it."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Cycle Check"}),": After processing, if the count of visited nodes is not equal to the total number of vertices, a cycle exists."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-JavaScript",children:'function kahnCycleDetection(graph) {\n    // Step 1: Compute in-degrees of all vertices\n    const inDegree = new Array(graph.length).fill(0);\n    \n    for (let u = 0; u < graph.length; u++) {\n        for (const v of graph[u]) {\n            inDegree[v]++;\n        }\n    }\n\n    // Step 2: Initialize the queue with all vertices having in-degree 0\n    const queue = [];\n    for (let i = 0; i < inDegree.length; i++) {\n        if (inDegree[i] === 0) {\n            queue.push(i);\n        }\n    }\n\n    // Step 3: Count of visited nodes\n    let visitedCount = 0;\n\n    // Step 4: Process the queue\n    while (queue.length > 0) {\n        // Dequeue a vertex\n        const current = queue.shift();\n        visitedCount++; // Increment count of visited nodes\n\n        // Step 5: Decrease the in-degree of neighboring nodes\n        for (const neighbor of graph[current]) {\n            inDegree[neighbor]--;\n            // If in-degree becomes 0, add it to the queue\n            if (inDegree[neighbor] === 0) {\n                queue.push(neighbor);\n            }\n        }\n    }\n\n    // Step 6: If the visited count is not equal to the number of nodes, a cycle exists\n    return visitedCount !== graph.length; // Returns true if a cycle is detected\n}\n\n// Example usage:\nconst directedGraph = [\n    [1],    // 0 -> 1\n    [2],    // 1 -> 2\n    [0],    // 2 -> 0 (cycle)\n    []\n];\n\nconsole.log("Cycle Detected:", kahnCycleDetection(directedGraph));\n'})}),"\n",(0,i.jsx)(n.p,{children:"Kahn's Algorithm is an efficient method for detecting cycles in directed graphs, with a time complexity of O(V+E), where V is the number of vertices and E is the number of edges."}),"\n",(0,i.jsx)(n.h3,{id:"cycle-detection-in-undirected-graphs",children:"Cycle Detection in Undirected Graphs"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"DFS"}),"\n",(0,i.jsx)(n.li,{children:"BFS"}),"\n",(0,i.jsx)(n.li,{children:"Union Find (Disjoint Set)"}),"\n",(0,i.jsx)(n.li,{children:"Graph coloring"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"union-find-disjoint-set-for-cycle-detection-in-undirected-graphs",children:"Union-Find (Disjoint Set) for Cycle Detection in Undirected Graphs"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Initialize"}),": Create a Union-Find structure to keep track of the components."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Process Edges"}),": For each edge in the graph:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Use the ",(0,i.jsx)(n.strong,{children:"Find"})," operation to check if the two vertices of the edge belong to the same set."]}),"\n",(0,i.jsx)(n.li,{children:"If they do, a cycle exists."}),"\n",(0,i.jsxs)(n.li,{children:["If they don\u2019t, use the ",(0,i.jsx)(n.strong,{children:"Union"})," operation to merge their sets."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Conclusion"}),": If no cycles are detected during the process, the graph is acyclic."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-JavaScript",children:'class UnionFind {\n    constructor(size) {\n        this.parent = Array.from({ length: size }, (_, i) => i);\n        this.rank = Array(size).fill(1);\n    }\n\n    find(node) {\n        if (this.parent[node] !== node) {\n            // Path compression\n            this.parent[node] = this.find(this.parent[node]);\n        }\n        return this.parent[node];\n    }\n\n    union(node1, node2) {\n        const root1 = this.find(node1);\n        const root2 = this.find(node2);\n\n        if (root1 === root2) {\n            return false; // A cycle is detected\n        }\n\n        // Union by rank\n        if (this.rank[root1] > this.rank[root2]) {\n            this.parent[root2] = root1;\n        } else if (this.rank[root1] < this.rank[root2]) {\n            this.parent[root1] = root2;\n        } else {\n            this.parent[root2] = root1;\n            this.rank[root1]++;\n        }\n        return true; // No cycle detected\n    }\n}\n\nfunction hasCycle(graph) {\n    const uf = new UnionFind(graph.length);\n\n    for (const [u, v] of graph) {\n        if (!uf.union(u, v)) {\n            return true; // Cycle detected\n        }\n    }\n\n    return false; // No cycle detected\n}\n\n// Example usage:\nconst undirectedGraph = [\n    [0, 1],\n    [1, 2],\n    [2, 0], // This edge creates a cycle\n    [1, 3]\n];\n\nconsole.log("Cycle Detected:", hasCycle(undirectedGraph));\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"Time Complexity:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Find : O(\u03b1(n))"}),"\n",(0,i.jsx)(n.li,{children:"Union: O(\u03b1(n))"}),"\n",(0,i.jsxs)(n.li,{children:["Total for m operations",":O","(m\u22c5\u03b1(n))"]}),"\n",(0,i.jsx)(n.li,{children:"Here, \u03b1(n) is the inverse Ackermann function, which grows very slowly. For all practical purposes, it can be considered constant, making the Find operation nearly O(1)"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Space Complexity"})," : O(n)"]})]})}function a(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>c});var i=t(96540);const r={},o=i.createContext(r);function s(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);