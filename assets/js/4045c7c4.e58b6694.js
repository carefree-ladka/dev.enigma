"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[6477],{623:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>d,frontMatter:()=>h,metadata:()=>a,toc:()=>l});var i=t(4848),r=t(8453);const h={title:"Prim's Algorithm"},s=void 0,a={id:"DSA/DSA with JavaScript/Prim'sAlgorithm",title:"Prim's Algorithm",description:"Prim's algorithm is a greedy algorithm that finds a Minimum Spanning Tree (MST) for a connected, weighted, undirected graph. Unlike Kruskal's algorithm, which considers edges, Prim's algorithm grows the MST by adding vertices.",source:"@site/docs/DSA/DSA with JavaScript/Prim'sAlgorithm.mdx",sourceDirName:"DSA/DSA with JavaScript",slug:"/DSA/DSA with JavaScript/Prim'sAlgorithm",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/Prim'sAlgorithm",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with JavaScript/Prim'sAlgorithm.mdx",tags:[],version:"current",frontMatter:{title:"Prim's Algorithm"},sidebar:"tutorialSidebar",previous:{title:"Prefix Sum",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/PrefixSum"},next:{title:"Queue",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/Queue"}},o={},l=[{value:"Steps of Prim&#39;s Algorithm",id:"steps-of-prims-algorithm",level:2},{value:"Time Complexity",id:"time-complexity",level:2},{value:"JavaScript Implementation",id:"javascript-implementation",level:2}];function p(e){const n={code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["Prim's algorithm is a greedy algorithm that finds a ",(0,i.jsx)(n.strong,{children:"Minimum Spanning Tree (MST)"})," for a connected, weighted, undirected graph. Unlike Kruskal's algorithm, which considers edges, Prim's algorithm grows the MST by adding vertices."]}),"\n",(0,i.jsx)(n.h2,{id:"steps-of-prims-algorithm",children:"Steps of Prim's Algorithm"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Initialize"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Start with an arbitrary vertex and mark it as part of the MST."}),"\n",(0,i.jsx)(n.li,{children:"Use a priority queue (or min-heap) to keep track of the minimum weight edges that connect the MST to vertices outside the MST."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Grow the MST"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["While there are still vertices not included in the MST:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Extract the edge with the smallest weight from the priority queue."}),"\n",(0,i.jsx)(n.li,{children:"If the extracted edge connects a vertex not already in the MST, add it to the MST and mark the new vertex as part of the MST."}),"\n",(0,i.jsx)(n.li,{children:"Add all edges connected to the newly added vertex to the priority queue."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Repeat"})," until all vertices are included in the MST."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"time-complexity",children:"Time Complexity"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The time complexity of Prim's algorithm is O(ElogV), where E is the number of edges and V is the number of vertices, when using a priority queue implemented with a binary heap."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"javascript-implementation",children:"JavaScript Implementation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-JavaScript",children:"class MinMaxPriorityQueue {\n\n  #heap = []\n  #compare;\n\n  constructor(compare) {\n    this.#heap = [];\n    this.#compare = compare || ((a, b) => a - b) //By default, keep it MinHeap\n  }\n\n  // Add a new element to the priority queue\n  enqueue = (value) => {\n    this.#heap.push(value);\n    this.#heapifyUp(this.#heap.length - 1);\n  }\n\n  // Remove and return the element with the highest priority (smallest for min-heap, largest for max-heap)\n  dequeue = () => {\n    if (this.#heap.length === 0) return null;\n    const root = this.#heap[0];\n    const end = this.#heap.pop();\n    if (this.#heap.length > 0) {\n      this.#heap[0] = end;\n      this.#heapifyDown(0);\n    }\n    return root;\n  }\n\n  // Peek at the element with the highest priority without removing it\n  peek = () => {\n    return this.#heap.length > 0 ? this.#heap[0] : null;\n  }\n\n  // Check if the priority queue is empty\n  isEmpty = () => {\n    return this.#heap.length === 0;\n  }\n\n  // Get the size of the priority queue\n  size = () => {\n    return this.#heap.length;\n  }\n\n  // Get the heap\n  get heap() {\n    return this.#heap\n  }\n\n  // Maintain heap property by moving element up\n  #heapifyUp = (index) => {\n    let parent = Math.floor((index - 1) / 2);\n    while (index > 0 && this.#compare(this.#heap[index], this.#heap[parent]) < 0) {\n      this.#swap(index, parent)\n      index = parent;\n      parent = Math.floor((index - 1) / 2);\n    }\n  }\n\n  // Maintain heap property by moving element down\n  #heapifyDown = (index) => {\n    const length = this.#heap.length;\n    let left = 2 * index + 1;\n    let right = 2 * index + 2;\n    let extreme = index;\n\n    if (left < length && this.#compare(this.#heap[left], this.#heap[extreme]) < 0) {\n      extreme = left;\n    }\n\n    if (right < length && this.#compare(this.#heap[right], this.#heap[extreme]) < 0) {\n      extreme = right;\n    }\n\n    if (extreme !== index) {\n      this.#swap(index, extreme)\n      this.#heapifyDown(extreme);\n    }\n  }\n\n  #swap = (i, j) => {\n    [this.#heap[i], this.#heap[j]] = [this.#heap[j], this.#heap[i]]\n  }\n}\n\n//Prim's Algorithm\nfunction prim(n, edges) {\n  const graph = Array.from({ length: n }, () => []);\n  for (const [u, v, weight] of edges) {\n    graph[u].push([v, weight]);\n    graph[v].push([u, weight]);\n  }\n\n  const mst = [];\n  const visited = new Set();\n  const minHeap = new MinMaxPriorityQueue((a, b) => a[1] - b[1]); // MinHeap based on weight\n\n  visited.add(0);\n  for (const [neighbor, weight] of graph[0]) {\n    minHeap.enqueue([neighbor, weight]);\n  }\n\n  while (!minHeap.isEmpty()) {\n    const [u, weight] = minHeap.dequeue();\n    if (visited.has(u)) continue;\n    visited.add(u);\n    mst.push([u, weight]);\n\n    for (const [neighbor, edgeWeight] of graph[u]) {\n      if (!visited.has(neighbor)) {\n        minHeap.enqueue([neighbor, edgeWeight]);\n      }\n    }\n  }\n\n  return mst;\n}\n\n// Example usage\nconst n = 4; // Number of vertices\nconst edges = [\n  [0, 1, 10],\n  [0, 2, 6],\n  [0, 3, 5],\n  [1, 3, 15],\n  [2, 3, 4]\n];\n\nconsole.log(prim(n, edges)); // [ [ 3, 5 ], [ 2, 4 ], [ 1, 10 ] ]\n"})})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>a});var i=t(6540);const r={},h=i.createContext(r);function s(e){const n=i.useContext(h);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(h.Provider,{value:n},e.children)}}}]);