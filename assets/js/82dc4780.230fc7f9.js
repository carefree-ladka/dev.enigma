"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[1609],{17600:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>c});var t=r(74848),i=r(28453);const s={},l="LeetCode Problems Solutions - JavaScript",a={id:"Interview Prep 2026/LeetCode 75 Problems Solutions - JavaScript",title:"LeetCode Problems Solutions - JavaScript",description:"Table of Contents",source:"@site/docs/08-Interview Prep 2026/LeetCode 75 Problems Solutions - JavaScript.mdx",sourceDirName:"08-Interview Prep 2026",slug:"/Interview Prep 2026/LeetCode 75 Problems Solutions - JavaScript",permalink:"/docs/Interview Prep 2026/LeetCode 75 Problems Solutions - JavaScript",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/08-Interview Prep 2026/LeetCode 75 Problems Solutions - JavaScript.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Learn Web Performance",permalink:"/docs/Interview Prep 2026/Learn Web Performance"},next:{title:"Modern CSS Guide 2026",permalink:"/docs/Interview Prep 2026/Modern CSS Guide 2026"}},o={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Array",id:"array",level:3},{value:"Binary",id:"binary",level:3},{value:"Dynamic Programming",id:"dynamic-programming",level:3},{value:"Graph",id:"graph",level:3},{value:"Interval",id:"interval",level:3},{value:"Linked List",id:"linked-list",level:3},{value:"Matrix",id:"matrix",level:3},{value:"String",id:"string",level:3},{value:"Tree",id:"tree",level:3},{value:"Heap",id:"heap",level:3},{value:"Array",id:"array-1",level:2},{value:"Two Sum",id:"two-sum",level:3},{value:"Best Time to Buy and Sell Stock",id:"best-time-to-buy-and-sell-stock",level:3},{value:"Contains Duplicate",id:"contains-duplicate",level:3},{value:"Product of Array Except Self",id:"product-of-array-except-self",level:3},{value:"Maximum Subarray",id:"maximum-subarray",level:3},{value:"Maximum Product Subarray",id:"maximum-product-subarray",level:3},{value:"Find Minimum in Rotated Sorted Array",id:"find-minimum-in-rotated-sorted-array",level:3},{value:"Search in Rotated Sorted Array",id:"search-in-rotated-sorted-array",level:3},{value:"3 Sum",id:"3-sum",level:3},{value:"Container With Most Water",id:"container-with-most-water",level:3},{value:"Binary",id:"binary-1",level:2},{value:"Sum of Two Integers",id:"sum-of-two-integers",level:3},{value:"Number of 1 Bits",id:"number-of-1-bits",level:3},{value:"Encode and Decode Strings",id:"encode-and-decode-strings",level:3},{value:"Tree",id:"tree-1",level:2},{value:"Maximum Depth of Binary Tree",id:"maximum-depth-of-binary-tree",level:3},{value:"Same Tree",id:"same-tree",level:3},{value:"Invert/Flip Binary Tree",id:"invertflip-binary-tree",level:3},{value:"Binary Tree Maximum Path Sum",id:"binary-tree-maximum-path-sum",level:3},{value:"Binary Tree Level Order Traversal",id:"binary-tree-level-order-traversal",level:3},{value:"Serialize and Deserialize Binary Tree",id:"serialize-and-deserialize-binary-tree",level:3},{value:"Subtree of Another Tree",id:"subtree-of-another-tree",level:3},{value:"Construct Binary Tree from Preorder and Inorder Traversal",id:"construct-binary-tree-from-preorder-and-inorder-traversal",level:3},{value:"Validate Binary Search Tree",id:"validate-binary-search-tree",level:3},{value:"Kth Smallest Element in a BST",id:"kth-smallest-element-in-a-bst",level:3},{value:"Lowest Common Ancestor of BST",id:"lowest-common-ancestor-of-bst",level:3},{value:"Implement Trie (Prefix Tree)",id:"implement-trie-prefix-tree",level:3},{value:"Add and Search Word",id:"add-and-search-word",level:3},{value:"Word Search II",id:"word-search-ii",level:3},{value:"Heap",id:"heap-1",level:2},{value:"Top K Frequent Elements",id:"top-k-frequent-elements",level:3},{value:"Find Median from Data Stream",id:"find-median-from-data-stream",level:3},{value:"Summary",id:"summary",level:2},{value:"Counting Bits",id:"counting-bits",level:3},{value:"Missing Number",id:"missing-number",level:3},{value:"Reverse Bits",id:"reverse-bits",level:3},{value:"Dynamic Programming",id:"dynamic-programming-1",level:2},{value:"Climbing Stairs",id:"climbing-stairs",level:3},{value:"Coin Change",id:"coin-change",level:3},{value:"Longest Increasing Subsequence",id:"longest-increasing-subsequence",level:3},{value:"Longest Common Subsequence",id:"longest-common-subsequence",level:3},{value:"Word Break Problem",id:"word-break-problem",level:3},{value:"Combination Sum",id:"combination-sum",level:3},{value:"House Robber",id:"house-robber",level:3},{value:"House Robber II",id:"house-robber-ii",level:3},{value:"Decode Ways",id:"decode-ways",level:3},{value:"Unique Paths",id:"unique-paths",level:3},{value:"Jump Game",id:"jump-game",level:3},{value:"Graph",id:"graph-1",level:2},{value:"Clone Graph",id:"clone-graph",level:3},{value:"Course Schedule",id:"course-schedule",level:3},{value:"Pacific Atlantic Water Flow",id:"pacific-atlantic-water-flow",level:3},{value:"Number of Islands",id:"number-of-islands",level:3},{value:"Longest Consecutive Sequence",id:"longest-consecutive-sequence",level:3},{value:"Alien Dictionary",id:"alien-dictionary",level:3},{value:"Graph Valid Tree",id:"graph-valid-tree",level:3},{value:"Number of Connected Components in an Undirected Graph",id:"number-of-connected-components-in-an-undirected-graph",level:3},{value:"Interval",id:"interval-1",level:2},{value:"Insert Interval",id:"insert-interval",level:3},{value:"Merge Intervals",id:"merge-intervals",level:3},{value:"Non-overlapping Intervals",id:"non-overlapping-intervals",level:3},{value:"Meeting Rooms",id:"meeting-rooms",level:3},{value:"Meeting Rooms II",id:"meeting-rooms-ii",level:3},{value:"Linked List",id:"linked-list-1",level:2},{value:"Reverse a Linked List",id:"reverse-a-linked-list",level:3},{value:"Detect Cycle in a Linked List",id:"detect-cycle-in-a-linked-list",level:3},{value:"Merge Two Sorted Lists",id:"merge-two-sorted-lists",level:3},{value:"Merge K Sorted Lists",id:"merge-k-sorted-lists",level:3},{value:"Remove Nth Node From End Of List",id:"remove-nth-node-from-end-of-list",level:3},{value:"Reorder List",id:"reorder-list",level:3},{value:"Matrix",id:"matrix-1",level:2},{value:"Set Matrix Zeroes",id:"set-matrix-zeroes",level:3},{value:"Spiral Matrix",id:"spiral-matrix",level:3},{value:"Rotate Image",id:"rotate-image",level:3},{value:"Word Search",id:"word-search",level:3},{value:"String",id:"string-1",level:2},{value:"Longest Substring Without Repeating Characters",id:"longest-substring-without-repeating-characters",level:3},{value:"Longest Repeating Character Replacement",id:"longest-repeating-character-replacement",level:3},{value:"Minimum Window Substring",id:"minimum-window-substring",level:3},{value:"Valid Anagram",id:"valid-anagram",level:3},{value:"Group Anagrams",id:"group-anagrams",level:3},{value:"Valid Parentheses",id:"valid-parentheses",level:3},{value:"Valid Palindrome",id:"valid-palindrome",level:3},{value:"Longest Palindromic Substring",id:"longest-palindromic-substring",level:3},{value:"Palindromic Substrings",id:"palindromic-substrings",level:3}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"leetcode-problems-solutions---javascript",children:"LeetCode Problems Solutions - JavaScript"})}),"\n",(0,t.jsx)(e.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,t.jsx)(e.h3,{id:"array",children:"Array"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#two-sum",children:"Two Sum"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#best-time-to-buy-and-sell-stock",children:"Best Time to Buy and Sell Stock"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#contains-duplicate",children:"Contains Duplicate"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#product-of-array-except-self",children:"Product of Array Except Self"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#maximum-subarray",children:"Maximum Subarray"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#maximum-product-subarray",children:"Maximum Product Subarray"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#find-minimum-in-rotated-sorted-array",children:"Find Minimum in Rotated Sorted Array"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#search-in-rotated-sorted-array",children:"Search in Rotated Sorted Array"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#3-sum",children:"3 Sum"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#container-with-most-water",children:"Container With Most Water"})}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"binary",children:"Binary"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#sum-of-two-integers",children:"Sum of Two Integers"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#number-of-1-bits",children:"Number of 1 Bits"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#counting-bits",children:"Counting Bits"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#missing-number",children:"Missing Number"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#reverse-bits",children:"Reverse Bits"})}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"dynamic-programming",children:"Dynamic Programming"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#climbing-stairs",children:"Climbing Stairs"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#coin-change",children:"Coin Change"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#longest-increasing-subsequence",children:"Longest Increasing Subsequence"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#longest-common-subsequence",children:"Longest Common Subsequence"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#word-break-problem",children:"Word Break Problem"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#combination-sum",children:"Combination Sum"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#house-robber",children:"House Robber"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#house-robber-ii",children:"House Robber II"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#decode-ways",children:"Decode Ways"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#unique-paths",children:"Unique Paths"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#jump-game",children:"Jump Game"})}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"graph",children:"Graph"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#clone-graph",children:"Clone Graph"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#course-schedule",children:"Course Schedule"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pacific-atlantic-water-flow",children:"Pacific Atlantic Water Flow"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#number-of-islands",children:"Number of Islands"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#longest-consecutive-sequence",children:"Longest Consecutive Sequence"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#alien-dictionary",children:"Alien Dictionary"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#graph-valid-tree",children:"Graph Valid Tree"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#number-of-connected-components-in-an-undirected-graph",children:"Number of Connected Components in an Undirected Graph"})}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"interval",children:"Interval"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#insert-interval",children:"Insert Interval"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#merge-intervals",children:"Merge Intervals"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#non-overlapping-intervals",children:"Non-overlapping Intervals"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#meeting-rooms",children:"Meeting Rooms"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#meeting-rooms-ii",children:"Meeting Rooms II"})}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"linked-list",children:"Linked List"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#reverse-a-linked-list",children:"Reverse a Linked List"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#detect-cycle-in-a-linked-list",children:"Detect Cycle in a Linked List"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#merge-two-sorted-lists",children:"Merge Two Sorted Lists"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#merge-k-sorted-lists",children:"Merge K Sorted Lists"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#remove-nth-node-from-end-of-list",children:"Remove Nth Node From End Of List"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#reorder-list",children:"Reorder List"})}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"matrix",children:"Matrix"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#set-matrix-zeroes",children:"Set Matrix Zeroes"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#spiral-matrix",children:"Spiral Matrix"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#rotate-image",children:"Rotate Image"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#word-search",children:"Word Search"})}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"string",children:"String"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#longest-substring-without-repeating-characters",children:"Longest Substring Without Repeating Characters"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#longest-repeating-character-replacement",children:"Longest Repeating Character Replacement"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#minimum-window-substring",children:"Minimum Window Substring"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#valid-anagram",children:"Valid Anagram"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#group-anagrams",children:"Group Anagrams"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#valid-parentheses",children:"Valid Parentheses"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#valid-palindrome",children:"Valid Palindrome"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#longest-palindromic-substring",children:"Longest Palindromic Substring"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#palindromic-substrings",children:"Palindromic Substrings"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#encode-and-decode-strings",children:"Encode and Decode Strings"})}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"tree",children:"Tree"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#maximum-depth-of-binary-tree",children:"Maximum Depth of Binary Tree"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#same-tree",children:"Same Tree"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#invertflip-binary-tree",children:"Invert/Flip Binary Tree"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#binary-tree-maximum-path-sum",children:"Binary Tree Maximum Path Sum"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#binary-tree-level-order-traversal",children:"Binary Tree Level Order Traversal"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#serialize-and-deserialize-binary-tree",children:"Serialize and Deserialize Binary Tree"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#subtree-of-another-tree",children:"Subtree of Another Tree"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#construct-binary-tree-from-preorder-and-inorder-traversal",children:"Construct Binary Tree from Preorder and Inorder Traversal"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#validate-binary-search-tree",children:"Validate Binary Search Tree"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#kth-smallest-element-in-a-bst",children:"Kth Smallest Element in a BST"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#lowest-common-ancestor-of-bst",children:"Lowest Common Ancestor of BST"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#implement-trie-prefix-tree",children:"Implement Trie (Prefix Tree)"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#add-and-search-word",children:"Add and Search Word"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#word-search-ii",children:"Word Search II"})}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"heap",children:"Heap"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#top-k-frequent-elements",children:"Top K Frequent Elements"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#find-median-from-data-stream",children:"Find Median from Data Stream"})}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"array-1",children:"Array"}),"\n",(0,t.jsx)(e.h3,{id:"two-sum",children:"Two Sum"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Given an array of integers nums and an integer target, return indices of the two numbers that add up to target."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n\xb2), Space: O(1)\nfunction twoSumBrute(nums, target) {\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j < nums.length; j++) {\n      if (nums[i] + nums[j] === target) {\n        return [i, j];\n      }\n    }\n  }\n  return [];\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n), Space: O(n)\nfunction twoSum(nums, target) {\n  const map = new Map();\n\n  for (let i = 0; i < nums.length; i++) {\n    const complement = target - nums[i];\n    if (map.has(complement)) {\n      return [map.get(complement), i];\n    }\n    map.set(nums[i], i);\n  }\n\n  return [];\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"best-time-to-buy-and-sell-stock",children:"Best Time to Buy and Sell Stock"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Find the maximum profit from buying and selling a stock once."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n\xb2), Space: O(1)\nfunction maxProfitBrute(prices) {\n  let maxProfit = 0;\n\n  for (let i = 0; i < prices.length; i++) {\n    for (let j = i + 1; j < prices.length; j++) {\n      maxProfit = Math.max(maxProfit, prices[j] - prices[i]);\n    }\n  }\n\n  return maxProfit;\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n), Space: O(1)\nfunction maxProfit(prices) {\n  let minPrice = Infinity;\n  let maxProfit = 0;\n\n  for (let price of prices) {\n    minPrice = Math.min(minPrice, price);\n    maxProfit = Math.max(maxProfit, price - minPrice);\n  }\n\n  return maxProfit;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"contains-duplicate",children:"Contains Duplicate"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Check if array contains any duplicates."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n\xb2), Space: O(1)\nfunction containsDuplicateBrute(nums) {\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j < nums.length; j++) {\n      if (nums[i] === nums[j]) return true;\n    }\n  }\n  return false;\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n), Space: O(n)\nfunction containsDuplicate(nums) {\n  const set = new Set(nums);\n  return set.size !== nums.length;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"product-of-array-except-self",children:"Product of Array Except Self"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Return array where each element is the product of all elements except itself (without division)."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n\xb2), Space: O(n)\nfunction productExceptSelfBrute(nums) {\n  const result = [];\n\n  for (let i = 0; i < nums.length; i++) {\n    let product = 1;\n    for (let j = 0; j < nums.length; j++) {\n      if (i !== j) {\n        product *= nums[j];\n      }\n    }\n    result.push(product);\n  }\n\n  return result;\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n), Space: O(1) - output array doesn't count\nfunction productExceptSelf(nums) {\n  const n = nums.length;\n  const result = new Array(n);\n\n  // Calculate left products\n  result[0] = 1;\n  for (let i = 1; i < n; i++) {\n    result[i] = result[i - 1] * nums[i - 1];\n  }\n\n  // Calculate right products and multiply\n  let right = 1;\n  for (let i = n - 1; i >= 0; i--) {\n    result[i] *= right;\n    right *= nums[i];\n  }\n\n  return result;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"maximum-subarray",children:"Maximum Subarray"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Find the contiguous subarray with the largest sum (Kadane's Algorithm)."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n\xb2), Space: O(1)\nfunction maxSubArrayBrute(nums) {\n  let maxSum = -Infinity;\n\n  for (let i = 0; i < nums.length; i++) {\n    let currentSum = 0;\n    for (let j = i; j < nums.length; j++) {\n      currentSum += nums[j];\n      maxSum = Math.max(maxSum, currentSum);\n    }\n  }\n\n  return maxSum;\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n), Space: O(1)\nfunction maxSubArray(nums) {\n  let maxSum = nums[0];\n  let currentSum = nums[0];\n\n  for (let i = 1; i < nums.length; i++) {\n    currentSum = Math.max(nums[i], currentSum + nums[i]);\n    maxSum = Math.max(maxSum, currentSum);\n  }\n\n  return maxSum;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"maximum-product-subarray",children:"Maximum Product Subarray"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Find the contiguous subarray with the largest product."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n\xb2), Space: O(1)\nfunction maxProductBrute(nums) {\n  let maxProd = -Infinity;\n\n  for (let i = 0; i < nums.length; i++) {\n    let currentProd = 1;\n    for (let j = i; j < nums.length; j++) {\n      currentProd *= nums[j];\n      maxProd = Math.max(maxProd, currentProd);\n    }\n  }\n\n  return maxProd;\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n), Space: O(1)\nfunction maxProduct(nums) {\n  let maxProd = nums[0];\n  let currentMax = nums[0];\n  let currentMin = nums[0];\n\n  for (let i = 1; i < nums.length; i++) {\n    const temp = currentMax;\n    currentMax = Math.max(nums[i], currentMax * nums[i], currentMin * nums[i]);\n    currentMin = Math.min(nums[i], temp * nums[i], currentMin * nums[i]);\n    maxProd = Math.max(maxProd, currentMax);\n  }\n\n  return maxProd;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"find-minimum-in-rotated-sorted-array",children:"Find Minimum in Rotated Sorted Array"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Find the minimum element in a rotated sorted array."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n), Space: O(1)\nfunction findMinBrute(nums) {\n  let min = nums[0];\n  for (let num of nums) {\n    min = Math.min(min, num);\n  }\n  return min;\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(log n), Space: O(1)\nfunction findMin(nums) {\n  let left = 0;\n  let right = nums.length - 1;\n\n  while (left < right) {\n    const mid = Math.floor((left + right) / 2);\n\n    if (nums[mid] > nums[right]) {\n      left = mid + 1;\n    } else {\n      right = mid;\n    }\n  }\n\n  return nums[left];\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"search-in-rotated-sorted-array",children:"Search in Rotated Sorted Array"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Search for a target value in a rotated sorted array."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n), Space: O(1)\nfunction searchBrute(nums, target) {\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === target) return i;\n  }\n  return -1;\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(log n), Space: O(1)\nfunction search(nums, target) {\n  let left = 0;\n  let right = nums.length - 1;\n\n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n\n    if (nums[mid] === target) return mid;\n\n    // Left half is sorted\n    if (nums[left] <= nums[mid]) {\n      if (target >= nums[left] && target < nums[mid]) {\n        right = mid - 1;\n      } else {\n        left = mid + 1;\n      }\n    }\n    // Right half is sorted\n    else {\n      if (target > nums[mid] && target <= nums[right]) {\n        left = mid + 1;\n      } else {\n        right = mid - 1;\n      }\n    }\n  }\n\n  return -1;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"3-sum",children:"3 Sum"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Find all unique triplets that sum to zero."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n\xb3), Space: O(n)\nfunction threeSumBrute(nums) {\n  const result = [];\n  const n = nums.length;\n\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (nums[i] + nums[j] + nums[k] === 0) {\n          const triplet = [nums[i], nums[j], nums[k]].sort((a, b) => a - b);\n          const key = triplet.join(',');\n          if (!result.some(r => r.join(',') === key)) {\n            result.push(triplet);\n          }\n        }\n      }\n    }\n  }\n\n  return result;\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n\xb2), Space: O(n)\nfunction threeSum(nums) {\n  const result = [];\n  nums.sort((a, b) => a - b);\n\n  for (let i = 0; i < nums.length - 2; i++) {\n    if (i > 0 && nums[i] === nums[i - 1]) continue;\n\n    let left = i + 1;\n    let right = nums.length - 1;\n\n    while (left < right) {\n      const sum = nums[i] + nums[left] + nums[right];\n\n      if (sum === 0) {\n        result.push([nums[i], nums[left], nums[right]]);\n        while (left < right && nums[left] === nums[left + 1]) left++;\n        while (left < right && nums[right] === nums[right - 1]) right--;\n        left++;\n        right--;\n      } else if (sum < 0) {\n        left++;\n      } else {\n        right--;\n      }\n    }\n  }\n\n  return result;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"container-with-most-water",children:"Container With Most Water"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Find two lines that together with x-axis form a container with most water."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n\xb2), Space: O(1)\nfunction maxAreaBrute(height) {\n  let maxArea = 0;\n\n  for (let i = 0; i < height.length; i++) {\n    for (let j = i + 1; j < height.length; j++) {\n      const area = Math.min(height[i], height[j]) * (j - i);\n      maxArea = Math.max(maxArea, area);\n    }\n  }\n\n  return maxArea;\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n), Space: O(1)\nfunction maxArea(height) {\n  let maxArea = 0;\n  let left = 0;\n  let right = height.length - 1;\n\n  while (left < right) {\n    const area = Math.min(height[left], height[right]) * (right - left);\n    maxArea = Math.max(maxArea, area);\n\n    if (height[left] < height[right]) {\n      left++;\n    } else {\n      right--;\n    }\n  }\n\n  return maxArea;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"binary-1",children:"Binary"}),"\n",(0,t.jsx)(e.h3,{id:"sum-of-two-integers",children:"Sum of Two Integers"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Add two integers without using + or - operators."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Using built-in operators (not allowed)\nfunction getSumBrute(a, b) {\n  return a + b;\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(1), Space: O(1)\nfunction getSum(a, b) {\n  while (b !== 0) {\n    const carry = (a & b) << 1;\n    a = a ^ b;\n    b = carry;\n  }\n  return a;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"number-of-1-bits",children:"Number of 1 Bits"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Count the number of 1 bits in an integer."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(32), Space: O(1)\nfunction hammingWeightBrute(n) {\n  let count = 0;\n  for (let i = 0; i < 32; i++) {\n    if ((n & (1 << i)) !== 0) {\n      count++;\n    }\n  }\n  return count;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"encode-and-decode-strings",children:"Encode and Decode Strings"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Design an algorithm to encode and decode a list of strings (Premium)."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n), Space: O(1)\nfunction encode(strs) {\n  let result = '';\n  for (let str of strs) {\n    result += str.length + '#' + str;\n  }\n  return result;\n}\n\nfunction decode(s) {\n  const result = [];\n  let i = 0;\n\n  while (i < s.length) {\n    let j = i;\n    while (s[j] !== '#') j++;\n\n    const length = parseInt(s.substring(i, j));\n    const str = s.substring(j + 1, j + 1 + length);\n    result.push(str);\n    i = j + 1 + length;\n  }\n\n  return result;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"tree-1",children:"Tree"}),"\n",(0,t.jsx)(e.h3,{id:"maximum-depth-of-binary-tree",children:"Maximum Depth of Binary Tree"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Find the maximum depth of a binary tree."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n), Space: O(n)\nfunction maxDepthBrute(root) {\n  if (!root) return 0;\n\n  const queue = [[root, 1]];\n  let maxDepth = 0;\n\n  while (queue.length > 0) {\n    const [node, depth] = queue.shift();\n    maxDepth = Math.max(maxDepth, depth);\n\n    if (node.left) queue.push([node.left, depth + 1]);\n    if (node.right) queue.push([node.right, depth + 1]);\n  }\n\n  return maxDepth;\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n), Space: O(h)\nfunction maxDepth(root) {\n  if (!root) return 0;\n  return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"same-tree",children:"Same Tree"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Check if two binary trees are identical."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n), Space: O(n)\nfunction isSameTreeBrute(p, q) {\n  const queue = [[p, q]];\n\n  while (queue.length > 0) {\n    const [node1, node2] = queue.shift();\n\n    if (!node1 && !node2) continue;\n    if (!node1 || !node2) return false;\n    if (node1.val !== node2.val) return false;\n\n    queue.push([node1.left, node2.left]);\n    queue.push([node1.right, node2.right]);\n  }\n\n  return true;\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n), Space: O(h)\nfunction isSameTree(p, q) {\n  if (!p && !q) return true;\n  if (!p || !q) return false;\n  if (p.val !== q.val) return false;\n\n  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"invertflip-binary-tree",children:"Invert/Flip Binary Tree"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Invert a binary tree."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n), Space: O(n)\nfunction invertTreeBrute(root) {\n  if (!root) return null;\n\n  const queue = [root];\n\n  while (queue.length > 0) {\n    const node = queue.shift();\n\n    [node.left, node.right] = [node.right, node.left];\n\n    if (node.left) queue.push(node.left);\n    if (node.right) queue.push(node.right);\n  }\n\n  return root;\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n), Space: O(h)\nfunction invertTree(root) {\n  if (!root) return null;\n\n  [root.left, root.right] = [root.right, root.left];\n\n  invertTree(root.left);\n  invertTree(root.right);\n\n  return root;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"binary-tree-maximum-path-sum",children:"Binary Tree Maximum Path Sum"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Find the maximum path sum in a binary tree."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n\xb2), Space: O(h)\nfunction maxPathSumBrute(root) {\n  let maxSum = -Infinity;\n\n  function allPaths(node, path, sum) {\n    if (!node) return;\n\n    sum += node.val;\n    maxSum = Math.max(maxSum, sum);\n\n    allPaths(node.left, path + 'L', sum);\n    allPaths(node.right, path + 'R', sum);\n  }\n\n  function helper(node) {\n    if (!node) return;\n    allPaths(node, '', 0);\n    helper(node.left);\n    helper(node.right);\n  }\n\n  helper(root);\n  return maxSum;\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n), Space: O(h)\nfunction maxPathSum(root) {\n  let maxSum = -Infinity;\n\n  function dfs(node) {\n    if (!node) return 0;\n\n    const left = Math.max(0, dfs(node.left));\n    const right = Math.max(0, dfs(node.right));\n\n    maxSum = Math.max(maxSum, node.val + left + right);\n\n    return node.val + Math.max(left, right);\n  }\n\n  dfs(root);\n  return maxSum;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"binary-tree-level-order-traversal",children:"Binary Tree Level Order Traversal"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Return level order traversal of a binary tree."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n), Space: O(n)\nfunction levelOrderBrute(root) {\n  if (!root) return [];\n\n  const result = [];\n  const queue = [root];\n\n  while (queue.length > 0) {\n    const level = [];\n    const size = queue.length;\n\n    for (let i = 0; i < size; i++) {\n      const node = queue.shift();\n      level.push(node.val);\n\n      if (node.left) queue.push(node.left);\n      if (node.right) queue.push(node.right);\n    }\n\n    result.push(level);\n  }\n\n  return result;\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n), Space: O(n)\nfunction levelOrder(root) {\n  if (!root) return [];\n\n  const result = [];\n  const queue = [root];\n\n  while (queue.length > 0) {\n    const levelSize = queue.length;\n    const level = [];\n\n    for (let i = 0; i < levelSize; i++) {\n      const node = queue.shift();\n      level.push(node.val);\n\n      if (node.left) queue.push(node.left);\n      if (node.right) queue.push(node.right);\n    }\n\n    result.push(level);\n  }\n\n  return result;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"serialize-and-deserialize-binary-tree",children:"Serialize and Deserialize Binary Tree"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Serialize and deserialize a binary tree."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n), Space: O(n)\nfunction serializeBrute(root) {\n  if (!root) return 'null';\n\n  const result = [];\n  const queue = [root];\n\n  while (queue.length > 0) {\n    const node = queue.shift();\n\n    if (node) {\n      result.push(node.val);\n      queue.push(node.left);\n      queue.push(node.right);\n    } else {\n      result.push('null');\n    }\n  }\n\n  return result.join(',');\n}\n\nfunction deserializeBrute(data) {\n  const values = data.split(',');\n  if (values[0] === 'null') return null;\n\n  const root = new TreeNode(parseInt(values[0]));\n  const queue = [root];\n  let i = 1;\n\n  while (queue.length > 0 && i < values.length) {\n    const node = queue.shift();\n\n    if (values[i] !== 'null') {\n      node.left = new TreeNode(parseInt(values[i]));\n      queue.push(node.left);\n    }\n    i++;\n\n    if (i < values.length && values[i] !== 'null') {\n      node.right = new TreeNode(parseInt(values[i]));\n      queue.push(node.right);\n    }\n    i++;\n  }\n\n  return root;\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n), Space: O(n)\nfunction serialize(root) {\n  const result = [];\n\n  function dfs(node) {\n    if (!node) {\n      result.push('null');\n      return;\n    }\n\n    result.push(node.val);\n    dfs(node.left);\n    dfs(node.right);\n  }\n\n  dfs(root);\n  return result.join(',');\n}\n\nfunction deserialize(data) {\n  const values = data.split(',');\n  let i = 0;\n\n  function dfs() {\n    if (values[i] === 'null') {\n      i++;\n      return null;\n    }\n\n    const node = new TreeNode(parseInt(values[i]));\n    i++;\n    node.left = dfs();\n    node.right = dfs();\n\n    return node;\n  }\n\n  return dfs();\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"subtree-of-another-tree",children:"Subtree of Another Tree"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Check if a tree is a subtree of another tree."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(m * n), Space: O(h)\nfunction isSubtreeBrute(root, subRoot) {\n  if (!root) return false;\n\n  function isSame(p, q) {\n    if (!p && !q) return true;\n    if (!p || !q) return false;\n    return (\n      p.val === q.val && isSame(p.left, q.left) && isSame(p.right, q.right)\n    );\n  }\n\n  if (isSame(root, subRoot)) return true;\n\n  return (\n    isSubtreeBrute(root.left, subRoot) || isSubtreeBrute(root.right, subRoot)\n  );\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(m * n), Space: O(h)\nfunction isSubtree(root, subRoot) {\n  if (!subRoot) return true;\n  if (!root) return false;\n\n  function isSameTree(p, q) {\n    if (!p && !q) return true;\n    if (!p || !q) return false;\n    return (\n      p.val === q.val &&\n      isSameTree(p.left, q.left) &&\n      isSameTree(p.right, q.right)\n    );\n  }\n\n  return (\n    isSameTree(root, subRoot) ||\n    isSubtree(root.left, subRoot) ||\n    isSubtree(root.right, subRoot)\n  );\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"construct-binary-tree-from-preorder-and-inorder-traversal",children:"Construct Binary Tree from Preorder and Inorder Traversal"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Build tree from preorder and inorder arrays."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n\xb2), Space: O(n)\nfunction buildTreeBrute(preorder, inorder) {\n  if (preorder.length === 0) return null;\n\n  const rootVal = preorder[0];\n  const root = new TreeNode(rootVal);\n\n  const rootIndex = inorder.indexOf(rootVal);\n\n  const leftInorder = inorder.slice(0, rootIndex);\n  const rightInorder = inorder.slice(rootIndex + 1);\n\n  const leftPreorder = preorder.slice(1, 1 + leftInorder.length);\n  const rightPreorder = preorder.slice(1 + leftInorder.length);\n\n  root.left = buildTreeBrute(leftPreorder, leftInorder);\n  root.right = buildTreeBrute(rightPreorder, rightInorder);\n\n  return root;\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n), Space: O(n)\nfunction buildTree(preorder, inorder) {\n  const inorderMap = new Map();\n  for (let i = 0; i < inorder.length; i++) {\n    inorderMap.set(inorder[i], i);\n  }\n\n  let preIndex = 0;\n\n  function helper(left, right) {\n    if (left > right) return null;\n\n    const rootVal = preorder[preIndex++];\n    const root = new TreeNode(rootVal);\n\n    const inIndex = inorderMap.get(rootVal);\n\n    root.left = helper(left, inIndex - 1);\n    root.right = helper(inIndex + 1, right);\n\n    return root;\n  }\n\n  return helper(0, inorder.length - 1);\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"validate-binary-search-tree",children:"Validate Binary Search Tree"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Check if a tree is a valid BST."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n\xb2), Space: O(h)\nfunction isValidBSTBrute(root) {\n  function getMax(node) {\n    if (!node) return -Infinity;\n    return Math.max(node.val, getMax(node.left), getMax(node.right));\n  }\n\n  function getMin(node) {\n    if (!node) return Infinity;\n    return Math.min(node.val, getMin(node.left), getMin(node.right));\n  }\n\n  function helper(node) {\n    if (!node) return true;\n\n    const leftMax = getMax(node.left);\n    const rightMin = getMin(node.right);\n\n    if (leftMax >= node.val || rightMin <= node.val) {\n      return false;\n    }\n\n    return helper(node.left) && helper(node.right);\n  }\n\n  return helper(root);\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n), Space: O(h)\nfunction isValidBST(root) {\n  function validate(node, min, max) {\n    if (!node) return true;\n\n    if (node.val <= min || node.val >= max) {\n      return false;\n    }\n\n    return (\n      validate(node.left, min, node.val) && validate(node.right, node.val, max)\n    );\n  }\n\n  return validate(root, -Infinity, Infinity);\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"kth-smallest-element-in-a-bst",children:"Kth Smallest Element in a BST"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Find the kth smallest element in a BST."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n), Space: O(n)\nfunction kthSmallestBrute(root, k) {\n  const values = [];\n\n  function inorder(node) {\n    if (!node) return;\n    inorder(node.left);\n    values.push(node.val);\n    inorder(node.right);\n  }\n\n  inorder(root);\n  return values[k - 1];\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(h + k), Space: O(h)\nfunction kthSmallest(root, k) {\n  let count = 0;\n  let result = null;\n\n  function inorder(node) {\n    if (!node || result !== null) return;\n\n    inorder(node.left);\n\n    count++;\n    if (count === k) {\n      result = node.val;\n      return;\n    }\n\n    inorder(node.right);\n  }\n\n  inorder(root);\n  return result;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"lowest-common-ancestor-of-bst",children:"Lowest Common Ancestor of BST"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Find the lowest common ancestor in a BST."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n), Space: O(n)\nfunction lowestCommonAncestorBrute(root, p, q) {\n  function findPath(node, target, path) {\n    if (!node) return false;\n\n    path.push(node);\n\n    if (node === target) return true;\n\n    if (\n      findPath(node.left, target, path) ||\n      findPath(node.right, target, path)\n    ) {\n      return true;\n    }\n\n    path.pop();\n    return false;\n  }\n\n  const pathP = [];\n  const pathQ = [];\n\n  findPath(root, p, pathP);\n  findPath(root, q, pathQ);\n\n  let lca = null;\n  for (let i = 0; i < Math.min(pathP.length, pathQ.length); i++) {\n    if (pathP[i] === pathQ[i]) {\n      lca = pathP[i];\n    } else {\n      break;\n    }\n  }\n\n  return lca;\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(h), Space: O(1)\nfunction lowestCommonAncestor(root, p, q) {\n  let current = root;\n\n  while (current) {\n    if (p.val < current.val && q.val < current.val) {\n      current = current.left;\n    } else if (p.val > current.val && q.val > current.val) {\n      current = current.right;\n    } else {\n      return current;\n    }\n  }\n\n  return null;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"implement-trie-prefix-tree",children:"Implement Trie (Prefix Tree)"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Implement a trie with insert, search, and startsWith methods."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"class TrieNode {\n  constructor() {\n    this.children = {};\n    this.isEndOfWord = false;\n  }\n}\n\nclass Trie {\n  constructor() {\n    this.root = new TrieNode();\n  }\n\n  // Time: O(m), Space: O(m) where m is key length\n  insert(word) {\n    let node = this.root;\n\n    for (let char of word) {\n      if (!node.children[char]) {\n        node.children[char] = new TrieNode();\n      }\n      node = node.children[char];\n    }\n\n    node.isEndOfWord = true;\n  }\n\n  // Time: O(m), Space: O(1)\n  search(word) {\n    let node = this.root;\n\n    for (let char of word) {\n      if (!node.children[char]) {\n        return false;\n      }\n      node = node.children[char];\n    }\n\n    return node.isEndOfWord;\n  }\n\n  // Time: O(m), Space: O(1)\n  startsWith(prefix) {\n    let node = this.root;\n\n    for (let char of prefix) {\n      if (!node.children[char]) {\n        return false;\n      }\n      node = node.children[char];\n    }\n\n    return true;\n  }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"add-and-search-word",children:"Add and Search Word"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Design a data structure that supports adding words and searching with '.' wildcard."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"class WordDictionary {\n  constructor() {\n    this.root = {};\n  }\n\n  // Time: O(m), Space: O(m)\n  addWord(word) {\n    let node = this.root;\n\n    for (let char of word) {\n      if (!node[char]) {\n        node[char] = {};\n      }\n      node = node[char];\n    }\n\n    node.isEnd = true;\n  }\n\n  // Time: O(m * 26^k) worst case, Space: O(m)\n  search(word) {\n    function dfs(index, node) {\n      if (index === word.length) {\n        return node.isEnd === true;\n      }\n\n      const char = word[index];\n\n      if (char === '.') {\n        for (let key in node) {\n          if (key !== 'isEnd' && dfs(index + 1, node[key])) {\n            return true;\n          }\n        }\n        return false;\n      } else {\n        if (!node[char]) return false;\n        return dfs(index + 1, node[char]);\n      }\n    }\n\n    return dfs(0, this.root);\n  }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"word-search-ii",children:"Word Search II"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Find all words from a dictionary in a 2D board."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(m * n * 4^L * k), Space: O(L)\nfunction findWordsBrute(board, words) {\n  const result = new Set();\n\n  function exist(word) {\n    const m = board.length;\n    const n = board[0].length;\n\n    function dfs(i, j, index) {\n      if (index === word.length) return true;\n      if (i < 0 || j < 0 || i >= m || j >= n || board[i][j] !== word[index]) {\n        return false;\n      }\n\n      const temp = board[i][j];\n      board[i][j] = '#';\n\n      const found =\n        dfs(i + 1, j, index + 1) ||\n        dfs(i - 1, j, index + 1) ||\n        dfs(i, j + 1, index + 1) ||\n        dfs(i, j - 1, index + 1);\n\n      board[i][j] = temp;\n      return found;\n    }\n\n    for (let i = 0; i < m; i++) {\n      for (let j = 0; j < n; j++) {\n        if (dfs(i, j, 0)) return true;\n      }\n    }\n    return false;\n  }\n\n  for (let word of words) {\n    if (exist(word)) {\n      result.add(word);\n    }\n  }\n\n  return Array.from(result);\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(m * n * 4^L), Space: O(t) where t is trie size\nfunction findWords(board, words) {\n  const result = new Set();\n  const m = board.length;\n  const n = board[0].length;\n\n  // Build Trie\n  const root = {};\n  for (let word of words) {\n    let node = root;\n    for (let char of word) {\n      if (!node[char]) {\n        node[char] = {};\n      }\n      node = node[char];\n    }\n    node.word = word;\n  }\n\n  function dfs(i, j, node) {\n    if (node.word) {\n      result.add(node.word);\n    }\n\n    if (\n      i < 0 ||\n      j < 0 ||\n      i >= m ||\n      j >= n ||\n      board[i][j] === '#' ||\n      !node[board[i][j]]\n    ) {\n      return;\n    }\n\n    const char = board[i][j];\n    board[i][j] = '#';\n\n    dfs(i + 1, j, node[char]);\n    dfs(i - 1, j, node[char]);\n    dfs(i, j + 1, node[char]);\n    dfs(i, j - 1, node[char]);\n\n    board[i][j] = char;\n  }\n\n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      dfs(i, j, root);\n    }\n  }\n\n  return Array.from(result);\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"heap-1",children:"Heap"}),"\n",(0,t.jsx)(e.h3,{id:"top-k-frequent-elements",children:"Top K Frequent Elements"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Find the k most frequent elements."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n log n), Space: O(n)\nfunction topKFrequentBrute(nums, k) {\n  const count = new Map();\n\n  for (let num of nums) {\n    count.set(num, (count.get(num) || 0) + 1);\n  }\n\n  const sorted = Array.from(count.entries()).sort((a, b) => b[1] - a[1]);\n\n  return sorted.slice(0, k).map(x => x[0]);\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n), Space: O(n)\nfunction topKFrequent(nums, k) {\n  const count = new Map();\n\n  for (let num of nums) {\n    count.set(num, (count.get(num) || 0) + 1);\n  }\n\n  // Bucket sort\n  const buckets = Array(nums.length + 1)\n    .fill(0)\n    .map(() => []);\n\n  for (let [num, freq] of count) {\n    buckets[freq].push(num);\n  }\n\n  const result = [];\n  for (let i = buckets.length - 1; i >= 0 && result.length < k; i--) {\n    result.push(...buckets[i]);\n  }\n\n  return result.slice(0, k);\n}\n\n// Alternative with Min Heap: O(n log k)\nfunction topKFrequentHeap(nums, k) {\n  const count = new Map();\n\n  for (let num of nums) {\n    count.set(num, (count.get(num) || 0) + 1);\n  }\n\n  const heap = [];\n\n  for (let [num, freq] of count) {\n    heap.push([freq, num]);\n\n    if (heap.length > k) {\n      heap.sort((a, b) => a[0] - b[0]);\n      heap.shift();\n    }\n  }\n\n  return heap.map(x => x[1]);\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"find-median-from-data-stream",children:"Find Median from Data Stream"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Design a data structure that supports adding numbers and finding the median."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: addNum O(1), findMedian O(n log n), Space: O(n)\nclass MedianFinderBrute {\n  constructor() {\n    this.nums = [];\n  }\n\n  addNum(num) {\n    this.nums.push(num);\n  }\n\n  findMedian() {\n    const sorted = [...this.nums].sort((a, b) => a - b);\n    const n = sorted.length;\n\n    if (n % 2 === 1) {\n      return sorted[Math.floor(n / 2)];\n    } else {\n      return (sorted[n / 2 - 1] + sorted[n / 2]) / 2;\n    }\n  }\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: addNum O(log n), findMedian O(1), Space: O(n)\nclass MedianFinder {\n  constructor() {\n    this.small = []; // max heap (inverted min heap)\n    this.large = []; // min heap\n  }\n\n  addNum(num) {\n    // Add to small heap (max heap)\n    this.small.push(-num);\n    this.small.sort((a, b) => a - b);\n\n    // Balance: move largest from small to large\n    if (\n      this.small.length > 0 &&\n      this.large.length > 0 &&\n      -this.small[0] > this.large[0]\n    ) {\n      this.large.push(-this.small.shift());\n      this.large.sort((a, b) => a - b);\n    }\n\n    // Ensure small has at most 1 more element than large\n    if (this.small.length > this.large.length + 1) {\n      this.large.push(-this.small.shift());\n      this.large.sort((a, b) => a - b);\n    }\n\n    if (this.large.length > this.small.length) {\n      this.small.push(-this.large.shift());\n      this.small.sort((a, b) => a - b);\n    }\n  }\n\n  findMedian() {\n    if (this.small.length > this.large.length) {\n      return -this.small[0];\n    }\n    return (-this.small[0] + this.large[0]) / 2;\n  }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(e.p,{children:"This comprehensive guide covers 75+ LeetCode problems organized by topic with both brute force and optimal solutions in JavaScript. Each solution includes:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Time Complexity"}),": Big O notation for time"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Space Complexity"}),": Big O notation for space"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Clear Code"}),": Well-commented JavaScript implementations"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Progressive Difficulty"}),": From brute force to optimal approaches"]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Key Patterns Covered:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Two Pointers"}),"\n",(0,t.jsx)(e.li,{children:"Sliding Window"}),"\n",(0,t.jsx)(e.li,{children:"Binary Search"}),"\n",(0,t.jsx)(e.li,{children:"Dynamic Programming"}),"\n",(0,t.jsx)(e.li,{children:"Backtracking"}),"\n",(0,t.jsx)(e.li,{children:"BFS/DFS"}),"\n",(0,t.jsx)(e.li,{children:"Trie"}),"\n",(0,t.jsx)(e.li,{children:"Heap/Priority Queue"}),"\n",(0,t.jsx)(e.li,{children:"Union Find"}),"\n",(0,t.jsx)(e.li,{children:"Bit Manipulation"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Practice Tips:"})}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Start with brute force to understand the problem"}),"\n",(0,t.jsx)(e.li,{children:"Identify bottlenecks and optimize"}),"\n",(0,t.jsx)(e.li,{children:"Practice explaining your approach"}),"\n",(0,t.jsx)(e.li,{children:"Focus on edge cases"}),"\n",(0,t.jsx)(e.li,{children:"Master the underlying patterns"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"Good luck with your interview preparation! \ud83d\ude80\n}"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"\n**Optimal Solution:**\n```javascript\n// Time: O(number of 1 bits), Space: O(1)\nfunction hammingWeight(n) {\n  let count = 0;\n  while (n !== 0) {\n    n &= (n - 1); // Removes the rightmost 1 bit\n    count++;\n  }\n  return count;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"counting-bits",children:"Counting Bits"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," For every number from 0 to n, count the number of 1's in their binary representation."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n * 32), Space: O(n)\nfunction countBitsBrute(n) {\n  const result = [];\n\n  for (let i = 0; i <= n; i++) {\n    let count = 0;\n    let num = i;\n    while (num !== 0) {\n      count += num & 1;\n      num >>= 1;\n    }\n    result.push(count);\n  }\n\n  return result;\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n), Space: O(n)\nfunction countBits(n) {\n  const result = new Array(n + 1).fill(0);\n\n  for (let i = 1; i <= n; i++) {\n    result[i] = result[i >> 1] + (i & 1);\n  }\n\n  return result;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"missing-number",children:"Missing Number"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Find the missing number in an array containing n distinct numbers from 0 to n."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n\xb2), Space: O(1)\nfunction missingNumberBrute(nums) {\n  const n = nums.length;\n\n  for (let i = 0; i <= n; i++) {\n    let found = false;\n    for (let num of nums) {\n      if (num === i) {\n        found = true;\n        break;\n      }\n    }\n    if (!found) return i;\n  }\n\n  return -1;\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n), Space: O(1)\nfunction missingNumber(nums) {\n  const n = nums.length;\n  let expectedSum = (n * (n + 1)) / 2;\n  let actualSum = nums.reduce((sum, num) => sum + num, 0);\n  return expectedSum - actualSum;\n}\n\n// Alternative using XOR\nfunction missingNumberXOR(nums) {\n  let result = nums.length;\n  for (let i = 0; i < nums.length; i++) {\n    result ^= i ^ nums[i];\n  }\n  return result;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"reverse-bits",children:"Reverse Bits"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Reverse bits of a 32-bit unsigned integer."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(32), Space: O(1)\nfunction reverseBitsBrute(n) {\n  let result = 0;\n\n  for (let i = 0; i < 32; i++) {\n    const bit = (n >> i) & 1;\n    result |= bit << (31 - i);\n  }\n\n  return result >>> 0; // Unsigned right shift\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(32), Space: O(1)\nfunction reverseBits(n) {\n  let result = 0;\n\n  for (let i = 0; i < 32; i++) {\n    result = (result << 1) | (n & 1);\n    n >>= 1;\n  }\n\n  return result >>> 0;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"dynamic-programming-1",children:"Dynamic Programming"}),"\n",(0,t.jsx)(e.h3,{id:"climbing-stairs",children:"Climbing Stairs"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Count ways to climb n stairs (1 or 2 steps at a time)."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution (Recursion):"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(2^n), Space: O(n)\nfunction climbStairsBrute(n) {\n  if (n <= 2) return n;\n  return climbStairsBrute(n - 1) + climbStairsBrute(n - 2);\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n), Space: O(1)\nfunction climbStairs(n) {\n  if (n <= 2) return n;\n\n  let prev2 = 1;\n  let prev1 = 2;\n\n  for (let i = 3; i <= n; i++) {\n    const current = prev1 + prev2;\n    prev2 = prev1;\n    prev1 = current;\n  }\n\n  return prev1;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"coin-change",children:"Coin Change"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Find minimum number of coins to make amount."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution (Recursion):"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(amount^n), Space: O(amount)\nfunction coinChangeBrute(coins, amount) {\n  if (amount === 0) return 0;\n  if (amount < 0) return -1;\n\n  let minCoins = Infinity;\n\n  for (let coin of coins) {\n    const result = coinChangeBrute(coins, amount - coin);\n    if (result >= 0) {\n      minCoins = Math.min(minCoins, result + 1);\n    }\n  }\n\n  return minCoins === Infinity ? -1 : minCoins;\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(amount * n), Space: O(amount)\nfunction coinChange(coins, amount) {\n  const dp = new Array(amount + 1).fill(Infinity);\n  dp[0] = 0;\n\n  for (let i = 1; i <= amount; i++) {\n    for (let coin of coins) {\n      if (i - coin >= 0) {\n        dp[i] = Math.min(dp[i], dp[i - coin] + 1);\n      }\n    }\n  }\n\n  return dp[amount] === Infinity ? -1 : dp[amount];\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"longest-increasing-subsequence",children:"Longest Increasing Subsequence"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Find the length of the longest increasing subsequence."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(2^n), Space: O(n)\nfunction lengthOfLISBrute(nums) {\n  function helper(index, prev) {\n    if (index === nums.length) return 0;\n\n    let exclude = helper(index + 1, prev);\n    let include = 0;\n\n    if (prev === -1 || nums[index] > nums[prev]) {\n      include = 1 + helper(index + 1, index);\n    }\n\n    return Math.max(include, exclude);\n  }\n\n  return helper(0, -1);\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n\xb2), Space: O(n)\nfunction lengthOfLIS(nums) {\n  if (nums.length === 0) return 0;\n\n  const dp = new Array(nums.length).fill(1);\n\n  for (let i = 1; i < nums.length; i++) {\n    for (let j = 0; j < i; j++) {\n      if (nums[i] > nums[j]) {\n        dp[i] = Math.max(dp[i], dp[j] + 1);\n      }\n    }\n  }\n\n  return Math.max(...dp);\n}\n\n// More optimal with binary search: O(n log n)\nfunction lengthOfLISOptimal(nums) {\n  const tails = [];\n\n  for (let num of nums) {\n    let left = 0,\n      right = tails.length;\n\n    while (left < right) {\n      const mid = Math.floor((left + right) / 2);\n      if (tails[mid] < num) {\n        left = mid + 1;\n      } else {\n        right = mid;\n      }\n    }\n\n    tails[left] = num;\n  }\n\n  return tails.length;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"longest-common-subsequence",children:"Longest Common Subsequence"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Find the length of the longest common subsequence between two strings."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(2^(m+n)), Space: O(m+n)\nfunction longestCommonSubsequenceBrute(text1, text2) {\n  function helper(i, j) {\n    if (i === text1.length || j === text2.length) return 0;\n\n    if (text1[i] === text2[j]) {\n      return 1 + helper(i + 1, j + 1);\n    }\n\n    return Math.max(helper(i + 1, j), helper(i, j + 1));\n  }\n\n  return helper(0, 0);\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(m * n), Space: O(m * n)\nfunction longestCommonSubsequence(text1, text2) {\n  const m = text1.length;\n  const n = text2.length;\n  const dp = Array(m + 1)\n    .fill(0)\n    .map(() => Array(n + 1).fill(0));\n\n  for (let i = 1; i <= m; i++) {\n    for (let j = 1; j <= n; j++) {\n      if (text1[i - 1] === text2[j - 1]) {\n        dp[i][j] = 1 + dp[i - 1][j - 1];\n      } else {\n        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n      }\n    }\n  }\n\n  return dp[m][n];\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"word-break-problem",children:"Word Break Problem"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Determine if string can be segmented into words from dictionary."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(2^n), Space: O(n)\nfunction wordBreakBrute(s, wordDict) {\n  function helper(start) {\n    if (start === s.length) return true;\n\n    for (let end = start + 1; end <= s.length; end++) {\n      const word = s.substring(start, end);\n      if (wordDict.includes(word) && helper(end)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  return helper(0);\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n\xb2 * m), Space: O(n)\nfunction wordBreak(s, wordDict) {\n  const wordSet = new Set(wordDict);\n  const dp = new Array(s.length + 1).fill(false);\n  dp[0] = true;\n\n  for (let i = 1; i <= s.length; i++) {\n    for (let j = 0; j < i; j++) {\n      if (dp[j] && wordSet.has(s.substring(j, i))) {\n        dp[i] = true;\n        break;\n      }\n    }\n  }\n\n  return dp[s.length];\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"combination-sum",children:"Combination Sum"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Find all unique combinations that sum to target."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(2^n), Space: O(target/min)\nfunction combinationSumBrute(candidates, target) {\n  const result = [];\n\n  function backtrack(start, current, sum) {\n    if (sum === target) {\n      result.push([...current]);\n      return;\n    }\n    if (sum > target) return;\n\n    for (let i = start; i < candidates.length; i++) {\n      current.push(candidates[i]);\n      backtrack(i, current, sum + candidates[i]);\n      current.pop();\n    }\n  }\n\n  backtrack(0, [], 0);\n  return result;\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(2^(target/min)), Space: O(target/min)\nfunction combinationSum(candidates, target) {\n  const result = [];\n  candidates.sort((a, b) => a - b);\n\n  function backtrack(start, current, sum) {\n    if (sum === target) {\n      result.push([...current]);\n      return;\n    }\n    if (sum > target) return;\n\n    for (let i = start; i < candidates.length; i++) {\n      if (sum + candidates[i] > target) break; // Optimization\n      current.push(candidates[i]);\n      backtrack(i, current, sum + candidates[i]);\n      current.pop();\n    }\n  }\n\n  backtrack(0, [], 0);\n  return result;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"house-robber",children:"House Robber"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Rob houses to maximize money without robbing adjacent houses."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(2^n), Space: O(n)\nfunction robBrute(nums) {\n  function helper(index) {\n    if (index >= nums.length) return 0;\n\n    // Rob current house or skip it\n    const rob = nums[index] + helper(index + 2);\n    const skip = helper(index + 1);\n\n    return Math.max(rob, skip);\n  }\n\n  return helper(0);\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n), Space: O(1)\nfunction rob(nums) {\n  if (nums.length === 0) return 0;\n  if (nums.length === 1) return nums[0];\n\n  let prev2 = 0;\n  let prev1 = 0;\n\n  for (let num of nums) {\n    const current = Math.max(prev1, prev2 + num);\n    prev2 = prev1;\n    prev1 = current;\n  }\n\n  return prev1;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"house-robber-ii",children:"House Robber II"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Rob houses in a circle (first and last are adjacent)."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(2^n), Space: O(n)\nfunction robIIBrute(nums) {\n  if (nums.length === 1) return nums[0];\n\n  function helper(start, end, index) {\n    if (index > end) return 0;\n\n    const rob = nums[index] + helper(start, end, index + 2);\n    const skip = helper(start, end, index + 1);\n\n    return Math.max(rob, skip);\n  }\n\n  // Either rob first house (skip last) or rob last house (skip first)\n  const robFirst = helper(0, nums.length - 2, 0);\n  const robLast = helper(1, nums.length - 1, 1);\n\n  return Math.max(robFirst, robLast);\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n), Space: O(1)\nfunction robII(nums) {\n  if (nums.length === 1) return nums[0];\n  if (nums.length === 2) return Math.max(nums[0], nums[1]);\n\n  function robLinear(start, end) {\n    let prev2 = 0;\n    let prev1 = 0;\n\n    for (let i = start; i <= end; i++) {\n      const current = Math.max(prev1, prev2 + nums[i]);\n      prev2 = prev1;\n      prev1 = current;\n    }\n\n    return prev1;\n  }\n\n  return Math.max(robLinear(0, nums.length - 2), robLinear(1, nums.length - 1));\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"decode-ways",children:"Decode Ways"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Count ways to decode a string of digits (A=1, B=2, ..., Z=26)."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(2^n), Space: O(n)\nfunction numDecodingsBrute(s) {\n  function helper(index) {\n    if (index === s.length) return 1;\n    if (s[index] === '0') return 0;\n\n    let ways = helper(index + 1);\n\n    if (index + 1 < s.length) {\n      const twoDigit = parseInt(s.substring(index, index + 2));\n      if (twoDigit <= 26) {\n        ways += helper(index + 2);\n      }\n    }\n\n    return ways;\n  }\n\n  return helper(0);\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n), Space: O(n)\nfunction numDecodings(s) {\n  if (s[0] === '0') return 0;\n\n  const n = s.length;\n  const dp = new Array(n + 1).fill(0);\n  dp[0] = 1;\n  dp[1] = 1;\n\n  for (let i = 2; i <= n; i++) {\n    const oneDigit = parseInt(s[i - 1]);\n    const twoDigits = parseInt(s.substring(i - 2, i));\n\n    if (oneDigit >= 1) {\n      dp[i] += dp[i - 1];\n    }\n\n    if (twoDigits >= 10 && twoDigits <= 26) {\n      dp[i] += dp[i - 2];\n    }\n  }\n\n  return dp[n];\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"unique-paths",children:"Unique Paths"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Count paths from top-left to bottom-right in a grid (only move right or down)."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(2^(m+n)), Space: O(m+n)\nfunction uniquePathsBrute(m, n) {\n  function helper(i, j) {\n    if (i === m - 1 && j === n - 1) return 1;\n    if (i >= m || j >= n) return 0;\n\n    return helper(i + 1, j) + helper(i, j + 1);\n  }\n\n  return helper(0, 0);\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(m * n), Space: O(m * n)\nfunction uniquePaths(m, n) {\n  const dp = Array(m)\n    .fill(0)\n    .map(() => Array(n).fill(1));\n\n  for (let i = 1; i < m; i++) {\n    for (let j = 1; j < n; j++) {\n      dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n    }\n  }\n\n  return dp[m - 1][n - 1];\n}\n\n// Space optimized: O(n)\nfunction uniquePathsOptimal(m, n) {\n  const dp = new Array(n).fill(1);\n\n  for (let i = 1; i < m; i++) {\n    for (let j = 1; j < n; j++) {\n      dp[j] += dp[j - 1];\n    }\n  }\n\n  return dp[n - 1];\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"jump-game",children:"Jump Game"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Determine if you can reach the last index."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(2^n), Space: O(n)\nfunction canJumpBrute(nums) {\n  function helper(index) {\n    if (index === nums.length - 1) return true;\n    if (index >= nums.length) return false;\n\n    const maxJump = Math.min(index + nums[index], nums.length - 1);\n\n    for (let i = index + 1; i <= maxJump; i++) {\n      if (helper(i)) return true;\n    }\n\n    return false;\n  }\n\n  return helper(0);\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n), Space: O(1)\nfunction canJump(nums) {\n  let maxReach = 0;\n\n  for (let i = 0; i < nums.length; i++) {\n    if (i > maxReach) return false;\n    maxReach = Math.max(maxReach, i + nums[i]);\n    if (maxReach >= nums.length - 1) return true;\n  }\n\n  return true;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"graph-1",children:"Graph"}),"\n",(0,t.jsx)(e.h3,{id:"clone-graph",children:"Clone Graph"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Deep clone an undirected graph."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n + e), Space: O(n)\nfunction cloneGraphBrute(node) {\n  if (!node) return null;\n\n  const visited = new Map();\n\n  function clone(node) {\n    if (visited.has(node.val)) {\n      return visited.get(node.val);\n    }\n\n    const newNode = new Node(node.val);\n    visited.set(node.val, newNode);\n\n    for (let neighbor of node.neighbors) {\n      newNode.neighbors.push(clone(neighbor));\n    }\n\n    return newNode;\n  }\n\n  return clone(node);\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n + e), Space: O(n)\nfunction cloneGraph(node) {\n  if (!node) return null;\n\n  const visited = new Map();\n\n  function dfs(node) {\n    if (visited.has(node)) {\n      return visited.get(node);\n    }\n\n    const clone = new Node(node.val);\n    visited.set(node, clone);\n\n    for (let neighbor of node.neighbors) {\n      clone.neighbors.push(dfs(neighbor));\n    }\n\n    return clone;\n  }\n\n  return dfs(node);\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"course-schedule",children:"Course Schedule"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Determine if you can finish all courses (detect cycle in directed graph)."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n * e), Space: O(n + e)\nfunction canFinishBrute(numCourses, prerequisites) {\n  const graph = Array(numCourses)\n    .fill(0)\n    .map(() => []);\n\n  for (let [course, prereq] of prerequisites) {\n    graph[prereq].push(course);\n  }\n\n  function hasCycle(node, visited, path) {\n    if (path.has(node)) return true;\n    if (visited.has(node)) return false;\n\n    visited.add(node);\n    path.add(node);\n\n    for (let neighbor of graph[node]) {\n      if (hasCycle(neighbor, visited, path)) {\n        return true;\n      }\n    }\n\n    path.delete(node);\n    return false;\n  }\n\n  const visited = new Set();\n\n  for (let i = 0; i < numCourses; i++) {\n    if (hasCycle(i, visited, new Set())) {\n      return false;\n    }\n  }\n\n  return true;\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n + e), Space: O(n + e)\nfunction canFinish(numCourses, prerequisites) {\n  const graph = Array(numCourses)\n    .fill(0)\n    .map(() => []);\n\n  for (let [course, prereq] of prerequisites) {\n    graph[prereq].push(course);\n  }\n\n  const visiting = new Set();\n  const visited = new Set();\n\n  function hasCycle(node) {\n    if (visiting.has(node)) return true;\n    if (visited.has(node)) return false;\n\n    visiting.add(node);\n\n    for (let neighbor of graph[node]) {\n      if (hasCycle(neighbor)) return true;\n    }\n\n    visiting.delete(node);\n    visited.add(node);\n    return false;\n  }\n\n  for (let i = 0; i < numCourses; i++) {\n    if (hasCycle(i)) return false;\n  }\n\n  return true;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"pacific-atlantic-water-flow",children:"Pacific Atlantic Water Flow"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Find cells where water can flow to both Pacific and Atlantic oceans."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(m * n * m * n), Space: O(m * n)\nfunction pacificAtlanticBrute(heights) {\n  const m = heights.length;\n  const n = heights[0].length;\n  const result = [];\n\n  function canReachOcean(i, j, ocean) {\n    const visited = new Set();\n\n    function dfs(r, c, prevHeight) {\n      const key = `${r},${c}`;\n      if (visited.has(key)) return false;\n      if (r < 0 || c < 0 || r >= m || c >= n) return false;\n      if (heights[r][c] > prevHeight) return false;\n\n      if (ocean === 'pacific' && (r === 0 || c === 0)) return true;\n      if (ocean === 'atlantic' && (r === m - 1 || c === n - 1)) return true;\n\n      visited.add(key);\n\n      return (\n        dfs(r + 1, c, heights[r][c]) ||\n        dfs(r - 1, c, heights[r][c]) ||\n        dfs(r, c + 1, heights[r][c]) ||\n        dfs(r, c - 1, heights[r][c])\n      );\n    }\n\n    return dfs(i, j, Infinity);\n  }\n\n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      if (canReachOcean(i, j, 'pacific') && canReachOcean(i, j, 'atlantic')) {\n        result.push([i, j]);\n      }\n    }\n  }\n\n  return result;\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(m * n), Space: O(m * n)\nfunction pacificAtlantic(heights) {\n  const m = heights.length;\n  const n = heights[0].length;\n  const pacific = Array(m)\n    .fill(0)\n    .map(() => Array(n).fill(false));\n  const atlantic = Array(m)\n    .fill(0)\n    .map(() => Array(n).fill(false));\n\n  function dfs(r, c, ocean, prevHeight) {\n    if (r < 0 || c < 0 || r >= m || c >= n) return;\n    if (ocean[r][c]) return;\n    if (heights[r][c] < prevHeight) return;\n\n    ocean[r][c] = true;\n\n    dfs(r + 1, c, ocean, heights[r][c]);\n    dfs(r - 1, c, ocean, heights[r][c]);\n    dfs(r, c + 1, ocean, heights[r][c]);\n    dfs(r, c - 1, ocean, heights[r][c]);\n  }\n\n  // Start from Pacific edges\n  for (let i = 0; i < m; i++) {\n    dfs(i, 0, pacific, heights[i][0]);\n    dfs(i, n - 1, atlantic, heights[i][n - 1]);\n  }\n\n  for (let j = 0; j < n; j++) {\n    dfs(0, j, pacific, heights[0][j]);\n    dfs(m - 1, j, atlantic, heights[m - 1][j]);\n  }\n\n  const result = [];\n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      if (pacific[i][j] && atlantic[i][j]) {\n        result.push([i, j]);\n      }\n    }\n  }\n\n  return result;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"number-of-islands",children:"Number of Islands"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Count the number of islands in a 2D grid."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(m * n * m * n), Space: O(m * n)\nfunction numIslandsBrute(grid) {\n  const m = grid.length;\n  const n = grid[0].length;\n  const visited = Array(m)\n    .fill(0)\n    .map(() => Array(n).fill(false));\n  let count = 0;\n\n  function bfs(i, j) {\n    const queue = [[i, j]];\n    visited[i][j] = true;\n\n    while (queue.length > 0) {\n      const [r, c] = queue.shift();\n      const directions = [\n        [0, 1],\n        [1, 0],\n        [0, -1],\n        [-1, 0],\n      ];\n\n      for (let [dr, dc] of directions) {\n        const nr = r + dr;\n        const nc = c + dc;\n\n        if (\n          nr >= 0 &&\n          nc >= 0 &&\n          nr < m &&\n          nc < n &&\n          grid[nr][nc] === '1' &&\n          !visited[nr][nc]\n        ) {\n          visited[nr][nc] = true;\n          queue.push([nr, nc]);\n        }\n      }\n    }\n  }\n\n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      if (grid[i][j] === '1' && !visited[i][j]) {\n        bfs(i, j);\n        count++;\n      }\n    }\n  }\n\n  return count;\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(m * n), Space: O(m * n)\nfunction numIslands(grid) {\n  const m = grid.length;\n  const n = grid[0].length;\n  let count = 0;\n\n  function dfs(i, j) {\n    if (i < 0 || j < 0 || i >= m || j >= n || grid[i][j] === '0') {\n      return;\n    }\n\n    grid[i][j] = '0'; // Mark as visited\n\n    dfs(i + 1, j);\n    dfs(i - 1, j);\n    dfs(i, j + 1);\n    dfs(i, j - 1);\n  }\n\n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      if (grid[i][j] === '1') {\n        dfs(i, j);\n        count++;\n      }\n    }\n  }\n\n  return count;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"longest-consecutive-sequence",children:"Longest Consecutive Sequence"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Find the length of the longest consecutive elements sequence."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n\xb3), Space: O(1)\nfunction longestConsecutiveBrute(nums) {\n  let maxLen = 0;\n\n  for (let num of nums) {\n    let currentNum = num;\n    let currentLen = 1;\n\n    while (nums.includes(currentNum + 1)) {\n      currentNum++;\n      currentLen++;\n    }\n\n    maxLen = Math.max(maxLen, currentLen);\n  }\n\n  return maxLen;\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n), Space: O(n)\nfunction longestConsecutive(nums) {\n  const numSet = new Set(nums);\n  let maxLen = 0;\n\n  for (let num of numSet) {\n    // Only start counting if it's the beginning of a sequence\n    if (!numSet.has(num - 1)) {\n      let currentNum = num;\n      let currentLen = 1;\n\n      while (numSet.has(currentNum + 1)) {\n        currentNum++;\n        currentLen++;\n      }\n\n      maxLen = Math.max(maxLen, currentLen);\n    }\n  }\n\n  return maxLen;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"alien-dictionary",children:"Alien Dictionary"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Derive the order of characters in an alien language (Premium)."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(C), Space: O(1) where C is total content in words\nfunction alienOrder(words) {\n  const graph = new Map();\n  const inDegree = new Map();\n\n  // Initialize graph\n  for (let word of words) {\n    for (let char of word) {\n      graph.set(char, new Set());\n      inDegree.set(char, 0);\n    }\n  }\n\n  // Build graph\n  for (let i = 0; i < words.length - 1; i++) {\n    const word1 = words[i];\n    const word2 = words[i + 1];\n    const minLen = Math.min(word1.length, word2.length);\n\n    // Check for invalid case\n    if (word1.length > word2.length && word1.startsWith(word2)) {\n      return '';\n    }\n\n    for (let j = 0; j < minLen; j++) {\n      if (word1[j] !== word2[j]) {\n        if (!graph.get(word1[j]).has(word2[j])) {\n          graph.get(word1[j]).add(word2[j]);\n          inDegree.set(word2[j], inDegree.get(word2[j]) + 1);\n        }\n        break;\n      }\n    }\n  }\n\n  // Topological sort\n  const queue = [];\n  for (let [char, degree] of inDegree) {\n    if (degree === 0) queue.push(char);\n  }\n\n  let result = '';\n  while (queue.length > 0) {\n    const char = queue.shift();\n    result += char;\n\n    for (let neighbor of graph.get(char)) {\n      inDegree.set(neighbor, inDegree.get(neighbor) - 1);\n      if (inDegree.get(neighbor) === 0) {\n        queue.push(neighbor);\n      }\n    }\n  }\n\n  return result.length === inDegree.size ? result : '';\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"graph-valid-tree",children:"Graph Valid Tree"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Check if graph is a valid tree (Premium)."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n + e), Space: O(n + e)\nfunction validTree(n, edges) {\n  if (edges.length !== n - 1) return false;\n\n  const graph = Array(n)\n    .fill(0)\n    .map(() => []);\n  for (let [u, v] of edges) {\n    graph[u].push(v);\n    graph[v].push(u);\n  }\n\n  const visited = new Set();\n\n  function dfs(node, parent) {\n    visited.add(node);\n\n    for (let neighbor of graph[node]) {\n      if (neighbor === parent) continue;\n      if (visited.has(neighbor)) return false;\n      if (!dfs(neighbor, node)) return false;\n    }\n\n    return true;\n  }\n\n  return dfs(0, -1) && visited.size === n;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"number-of-connected-components-in-an-undirected-graph",children:"Number of Connected Components in an Undirected Graph"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Count connected components (Premium)."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n + e), Space: O(n + e)\nfunction countComponents(n, edges) {\n  const graph = Array(n)\n    .fill(0)\n    .map(() => []);\n\n  for (let [u, v] of edges) {\n    graph[u].push(v);\n    graph[v].push(u);\n  }\n\n  const visited = new Set();\n  let count = 0;\n\n  function dfs(node) {\n    visited.add(node);\n    for (let neighbor of graph[node]) {\n      if (!visited.has(neighbor)) {\n        dfs(neighbor);\n      }\n    }\n  }\n\n  for (let i = 0; i < n; i++) {\n    if (!visited.has(i)) {\n      dfs(i);\n      count++;\n    }\n  }\n\n  return count;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"interval-1",children:"Interval"}),"\n",(0,t.jsx)(e.h3,{id:"insert-interval",children:"Insert Interval"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Insert a new interval and merge if necessary."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n\xb2), Space: O(n)\nfunction insertBrute(intervals, newInterval) {\n  intervals.push(newInterval);\n  intervals.sort((a, b) => a[0] - b[0]);\n\n  const merged = [intervals[0]];\n\n  for (let i = 1; i < intervals.length; i++) {\n    const last = merged[merged.length - 1];\n    const current = intervals[i];\n\n    if (current[0] <= last[1]) {\n      last[1] = Math.max(last[1], current[1]);\n    } else {\n      merged.push(current);\n    }\n  }\n\n  return merged;\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n), Space: O(n)\nfunction insert(intervals, newInterval) {\n  const result = [];\n  let i = 0;\n\n  // Add all intervals before newInterval\n  while (i < intervals.length && intervals[i][1] < newInterval[0]) {\n    result.push(intervals[i]);\n    i++;\n  }\n\n  // Merge overlapping intervals\n  while (i < intervals.length && intervals[i][0] <= newInterval[1]) {\n    newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\n    newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\n    i++;\n  }\n  result.push(newInterval);\n\n  // Add remaining intervals\n  while (i < intervals.length) {\n    result.push(intervals[i]);\n    i++;\n  }\n\n  return result;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"merge-intervals",children:"Merge Intervals"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Merge all overlapping intervals."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n\xb2 log n), Space: O(n)\nfunction mergeBrute(intervals) {\n  intervals.sort((a, b) => a[0] - b[0]);\n\n  let changed = true;\n  while (changed) {\n    changed = false;\n    for (let i = 0; i < intervals.length - 1; i++) {\n      if (intervals[i][1] >= intervals[i + 1][0]) {\n        intervals[i][1] = Math.max(intervals[i][1], intervals[i + 1][1]);\n        intervals.splice(i + 1, 1);\n        changed = true;\n        break;\n      }\n    }\n  }\n\n  return intervals;\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n log n), Space: O(n)\nfunction merge(intervals) {\n  if (intervals.length <= 1) return intervals;\n\n  intervals.sort((a, b) => a[0] - b[0]);\n  const merged = [intervals[0]];\n\n  for (let i = 1; i < intervals.length; i++) {\n    const last = merged[merged.length - 1];\n    const current = intervals[i];\n\n    if (current[0] <= last[1]) {\n      last[1] = Math.max(last[1], current[1]);\n    } else {\n      merged.push(current);\n    }\n  }\n\n  return merged;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"non-overlapping-intervals",children:"Non-overlapping Intervals"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Find minimum number of intervals to remove to make rest non-overlapping."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(2^n), Space: O(n)\nfunction eraseOverlapIntervalsBrute(intervals) {\n  intervals.sort((a, b) => a[0] - b[0]);\n\n  function helper(index, prev) {\n    if (index === intervals.length) return 0;\n\n    // Remove current interval\n    let remove = 1 + helper(index + 1, prev);\n\n    // Keep current interval if it doesn't overlap\n    let keep = Infinity;\n    if (prev === -1 || intervals[index][0] >= intervals[prev][1]) {\n      keep = helper(index + 1, index);\n    }\n\n    return Math.min(remove, keep);\n  }\n\n  return helper(0, -1);\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n log n), Space: O(1)\nfunction eraseOverlapIntervals(intervals) {\n  if (intervals.length === 0) return 0;\n\n  intervals.sort((a, b) => a[1] - b[1]);\n\n  let count = 0;\n  let end = intervals[0][1];\n\n  for (let i = 1; i < intervals.length; i++) {\n    if (intervals[i][0] < end) {\n      count++;\n    } else {\n      end = intervals[i][1];\n    }\n  }\n\n  return count;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"meeting-rooms",children:"Meeting Rooms"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Check if person can attend all meetings (Premium)."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n log n), Space: O(1)\nfunction canAttendMeetings(intervals) {\n  intervals.sort((a, b) => a[0] - b[0]);\n\n  for (let i = 1; i < intervals.length; i++) {\n    if (intervals[i][0] < intervals[i - 1][1]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"meeting-rooms-ii",children:"Meeting Rooms II"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Find minimum number of conference rooms required (Premium)."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n log n), Space: O(n)\nfunction minMeetingRooms(intervals) {\n  const starts = intervals.map(i => i[0]).sort((a, b) => a - b);\n  const ends = intervals.map(i => i[1]).sort((a, b) => a - b);\n\n  let rooms = 0;\n  let maxRooms = 0;\n  let i = 0,\n    j = 0;\n\n  while (i < starts.length) {\n    if (starts[i] < ends[j]) {\n      rooms++;\n      maxRooms = Math.max(maxRooms, rooms);\n      i++;\n    } else {\n      rooms--;\n      j++;\n    }\n  }\n\n  return maxRooms;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"linked-list-1",children:"Linked List"}),"\n",(0,t.jsx)(e.h3,{id:"reverse-a-linked-list",children:"Reverse a Linked List"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Reverse a singly linked list."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n), Space: O(n)\nfunction reverseListBrute(head) {\n  const values = [];\n  let current = head;\n\n  while (current) {\n    values.push(current.val);\n    current = current.next;\n  }\n\n  current = head;\n  while (current) {\n    current.val = values.pop();\n    current = current.next;\n  }\n\n  return head;\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n), Space: O(1)\nfunction reverseList(head) {\n  let prev = null;\n  let current = head;\n\n  while (current) {\n    const next = current.next;\n    current.next = prev;\n    prev = current;\n    current = next;\n  }\n\n  return prev;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"detect-cycle-in-a-linked-list",children:"Detect Cycle in a Linked List"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Detect if linked list has a cycle."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n), Space: O(n)\nfunction hasCycleBrute(head) {\n  const seen = new Set();\n  let current = head;\n\n  while (current) {\n    if (seen.has(current)) return true;\n    seen.add(current);\n    current = current.next;\n  }\n\n  return false;\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n), Space: O(1)\nfunction hasCycle(head) {\n  let slow = head;\n  let fast = head;\n\n  while (fast && fast.next) {\n    slow = slow.next;\n    fast = fast.next.next;\n\n    if (slow === fast) return true;\n  }\n\n  return false;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"merge-two-sorted-lists",children:"Merge Two Sorted Lists"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Merge two sorted linked lists."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n + m), Space: O(n + m)\nfunction mergeTwoListsBrute(l1, l2) {\n  const values = [];\n\n  while (l1) {\n    values.push(l1.val);\n    l1 = l1.next;\n  }\n\n  while (l2) {\n    values.push(l2.val);\n    l2 = l2.next;\n  }\n\n  values.sort((a, b) => a - b);\n\n  const dummy = new ListNode(0);\n  let current = dummy;\n\n  for (let val of values) {\n    current.next = new ListNode(val);\n    current = current.next;\n  }\n\n  return dummy.next;\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n + m), Space: O(1)\nfunction mergeTwoLists(l1, l2) {\n  const dummy = new ListNode(0);\n  let current = dummy;\n\n  while (l1 && l2) {\n    if (l1.val <= l2.val) {\n      current.next = l1;\n      l1 = l1.next;\n    } else {\n      current.next = l2;\n      l2 = l2.next;\n    }\n    current = current.next;\n  }\n\n  current.next = l1 || l2;\n\n  return dummy.next;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"merge-k-sorted-lists",children:"Merge K Sorted Lists"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Merge k sorted linked lists."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(nk log nk), Space: O(nk)\nfunction mergeKListsBrute(lists) {\n  const values = [];\n\n  for (let list of lists) {\n    while (list) {\n      values.push(list.val);\n      list = list.next;\n    }\n  }\n\n  values.sort((a, b) => a - b);\n\n  const dummy = new ListNode(0);\n  let current = dummy;\n\n  for (let val of values) {\n    current.next = new ListNode(val);\n    current = current.next;\n  }\n\n  return dummy.next;\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(nk log k), Space: O(k)\nfunction mergeKLists(lists) {\n  if (!lists || lists.length === 0) return null;\n\n  while (lists.length > 1) {\n    const mergedLists = [];\n\n    for (let i = 0; i < lists.length; i += 2) {\n      const l1 = lists[i];\n      const l2 = i + 1 < lists.length ? lists[i + 1] : null;\n      mergedLists.push(mergeTwoLists(l1, l2));\n    }\n\n    lists = mergedLists;\n  }\n\n  return lists[0];\n}\n\nfunction mergeTwoLists(l1, l2) {\n  const dummy = new ListNode(0);\n  let current = dummy;\n\n  while (l1 && l2) {\n    if (l1.val <= l2.val) {\n      current.next = l1;\n      l1 = l1.next;\n    } else {\n      current.next = l2;\n      l2 = l2.next;\n    }\n    current = current.next;\n  }\n\n  current.next = l1 || l2;\n  return dummy.next;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"remove-nth-node-from-end-of-list",children:"Remove Nth Node From End Of List"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Remove the nth node from the end of the list."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n), Space: O(1)\nfunction removeNthFromEndBrute(head, n) {\n  // First pass: count nodes\n  let length = 0;\n  let current = head;\n\n  while (current) {\n    length++;\n    current = current.next;\n  }\n\n  // Edge case: remove first node\n  if (length === n) return head.next;\n\n  // Second pass: remove node\n  current = head;\n  for (let i = 0; i < length - n - 1; i++) {\n    current = current.next;\n  }\n\n  current.next = current.next.next;\n  return head;\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n), Space: O(1)\nfunction removeNthFromEnd(head, n) {\n  const dummy = new ListNode(0);\n  dummy.next = head;\n\n  let slow = dummy;\n  let fast = dummy;\n\n  // Move fast n+1 steps ahead\n  for (let i = 0; i <= n; i++) {\n    fast = fast.next;\n  }\n\n  // Move both until fast reaches end\n  while (fast) {\n    slow = slow.next;\n    fast = fast.next;\n  }\n\n  // Remove node\n  slow.next = slow.next.next;\n\n  return dummy.next;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"reorder-list",children:"Reorder List"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Reorder list to L0\u2192Ln\u2192L1\u2192Ln-1\u2192L2\u2192Ln-2\u2192..."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n), Space: O(n)\nfunction reorderListBrute(head) {\n  const nodes = [];\n  let current = head;\n\n  while (current) {\n    nodes.push(current);\n    current = current.next;\n  }\n\n  let left = 0;\n  let right = nodes.length - 1;\n\n  while (left < right) {\n    nodes[left].next = nodes[right];\n    left++;\n\n    if (left === right) break;\n\n    nodes[right].next = nodes[left];\n    right--;\n  }\n\n  nodes[left].next = null;\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n), Space: O(1)\nfunction reorderList(head) {\n  if (!head || !head.next) return;\n\n  // Find middle\n  let slow = head;\n  let fast = head;\n\n  while (fast.next && fast.next.next) {\n    slow = slow.next;\n    fast = fast.next.next;\n  }\n\n  // Reverse second half\n  let prev = null;\n  let current = slow.next;\n  slow.next = null;\n\n  while (current) {\n    const next = current.next;\n    current.next = prev;\n    prev = current;\n    current = next;\n  }\n\n  // Merge two halves\n  let first = head;\n  let second = prev;\n\n  while (second) {\n    const temp1 = first.next;\n    const temp2 = second.next;\n\n    first.next = second;\n    second.next = temp1;\n\n    first = temp1;\n    second = temp2;\n  }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"matrix-1",children:"Matrix"}),"\n",(0,t.jsx)(e.h3,{id:"set-matrix-zeroes",children:"Set Matrix Zeroes"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Set entire row and column to 0 if element is 0."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(m * n * (m + n)), Space: O(m * n)\nfunction setZeroesBrute(matrix) {\n  const m = matrix.length;\n  const n = matrix[0].length;\n  const copy = matrix.map(row => [...row]);\n\n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      if (copy[i][j] === 0) {\n        for (let k = 0; k < n; k++) matrix[i][k] = 0;\n        for (let k = 0; k < m; k++) matrix[k][j] = 0;\n      }\n    }\n  }\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(m * n), Space: O(1)\nfunction setZeroes(matrix) {\n  const m = matrix.length;\n  const n = matrix[0].length;\n  let firstRowZero = false;\n  let firstColZero = false;\n\n  // Check if first row/col should be zero\n  for (let j = 0; j < n; j++) {\n    if (matrix[0][j] === 0) firstRowZero = true;\n  }\n\n  for (let i = 0; i < m; i++) {\n    if (matrix[i][0] === 0) firstColZero = true;\n  }\n\n  // Use first row/col as markers\n  for (let i = 1; i < m; i++) {\n    for (let j = 1; j < n; j++) {\n      if (matrix[i][j] === 0) {\n        matrix[i][0] = 0;\n        matrix[0][j] = 0;\n      }\n    }\n  }\n\n  // Set zeros based on markers\n  for (let i = 1; i < m; i++) {\n    for (let j = 1; j < n; j++) {\n      if (matrix[i][0] === 0 || matrix[0][j] === 0) {\n        matrix[i][j] = 0;\n      }\n    }\n  }\n\n  // Handle first row/col\n  if (firstRowZero) {\n    for (let j = 0; j < n; j++) matrix[0][j] = 0;\n  }\n\n  if (firstColZero) {\n    for (let i = 0; i < m; i++) matrix[i][0] = 0;\n  }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"spiral-matrix",children:"Spiral Matrix"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Return all elements in spiral order."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(m * n), Space: O(m * n)\nfunction spiralOrderBrute(matrix) {\n  const result = [];\n  const visited = Array(matrix.length)\n    .fill(0)\n    .map(() => Array(matrix[0].length).fill(false));\n\n  const directions = [\n    [0, 1],\n    [1, 0],\n    [0, -1],\n    [-1, 0],\n  ];\n  let dir = 0;\n  let r = 0,\n    c = 0;\n\n  for (let i = 0; i < matrix.length * matrix[0].length; i++) {\n    result.push(matrix[r][c]);\n    visited[r][c] = true;\n\n    const nr = r + directions[dir][0];\n    const nc = c + directions[dir][1];\n\n    if (\n      nr < 0 ||\n      nc < 0 ||\n      nr >= matrix.length ||\n      nc >= matrix[0].length ||\n      visited[nr][nc]\n    ) {\n      dir = (dir + 1) % 4;\n    }\n\n    r += directions[dir][0];\n    c += directions[dir][1];\n  }\n\n  return result;\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(m * n), Space: O(1)\nfunction spiralOrder(matrix) {\n  const result = [];\n\n  let top = 0;\n  let bottom = matrix.length - 1;\n  let left = 0;\n  let right = matrix[0].length - 1;\n\n  while (top <= bottom && left <= right) {\n    // Traverse right\n    for (let j = left; j <= right; j++) {\n      result.push(matrix[top][j]);\n    }\n    top++;\n\n    // Traverse down\n    for (let i = top; i <= bottom; i++) {\n      result.push(matrix[i][right]);\n    }\n    right--;\n\n    // Traverse left\n    if (top <= bottom) {\n      for (let j = right; j >= left; j--) {\n        result.push(matrix[bottom][j]);\n      }\n      bottom--;\n    }\n\n    // Traverse up\n    if (left <= right) {\n      for (let i = bottom; i >= top; i--) {\n        result.push(matrix[i][left]);\n      }\n      left++;\n    }\n  }\n\n  return result;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"rotate-image",children:"Rotate Image"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Rotate matrix 90 degrees clockwise in-place."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n\xb2), Space: O(n\xb2)\nfunction rotateBrute(matrix) {\n  const n = matrix.length;\n  const copy = matrix.map(row => [...row]);\n\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      matrix[j][n - 1 - i] = copy[i][j];\n    }\n  }\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n\xb2), Space: O(1)\nfunction rotate(matrix) {\n  const n = matrix.length;\n\n  // Transpose\n  for (let i = 0; i < n; i++) {\n    for (let j = i; j < n; j++) {\n      [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];\n    }\n  }\n\n  // Reverse each row\n  for (let i = 0; i < n; i++) {\n    matrix[i].reverse();\n  }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"word-search",children:"Word Search"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Search for a word in a 2D board."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(m * n * 4^L), Space: O(L)\nfunction existBrute(board, word) {\n  const m = board.length;\n  const n = board[0].length;\n\n  function dfs(i, j, index) {\n    if (index === word.length) return true;\n    if (i < 0 || j < 0 || i >= m || j >= n) return false;\n    if (board[i][j] !== word[index]) return false;\n\n    const temp = board[i][j];\n    board[i][j] = '#';\n\n    const found =\n      dfs(i + 1, j, index + 1) ||\n      dfs(i - 1, j, index + 1) ||\n      dfs(i, j + 1, index + 1) ||\n      dfs(i, j - 1, index + 1);\n\n    board[i][j] = temp;\n    return found;\n  }\n\n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      if (dfs(i, j, 0)) return true;\n    }\n  }\n\n  return false;\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(m * n * 4^L), Space: O(L)\nfunction exist(board, word) {\n  const m = board.length;\n  const n = board[0].length;\n\n  function dfs(i, j, index) {\n    if (index === word.length) return true;\n    if (i < 0 || j < 0 || i >= m || j >= n || board[i][j] !== word[index]) {\n      return false;\n    }\n\n    const temp = board[i][j];\n    board[i][j] = '#';\n\n    const found =\n      dfs(i + 1, j, index + 1) ||\n      dfs(i - 1, j, index + 1) ||\n      dfs(i, j + 1, index + 1) ||\n      dfs(i, j - 1, index + 1);\n\n    board[i][j] = temp;\n    return found;\n  }\n\n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      if (board[i][j] === word[0] && dfs(i, j, 0)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"string-1",children:"String"}),"\n",(0,t.jsx)(e.h3,{id:"longest-substring-without-repeating-characters",children:"Longest Substring Without Repeating Characters"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Find the length of the longest substring without repeating characters."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n\xb3), Space: O(min(n, m))\nfunction lengthOfLongestSubstringBrute(s) {\n  let maxLen = 0;\n\n  for (let i = 0; i < s.length; i++) {\n    for (let j = i; j < s.length; j++) {\n      const substring = s.substring(i, j + 1);\n      const set = new Set(substring);\n\n      if (set.size === substring.length) {\n        maxLen = Math.max(maxLen, substring.length);\n      } else {\n        break;\n      }\n    }\n  }\n\n  return maxLen;\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n), Space: O(min(n, m))\nfunction lengthOfLongestSubstring(s) {\n  const map = new Map();\n  let maxLen = 0;\n  let left = 0;\n\n  for (let right = 0; right < s.length; right++) {\n    if (map.has(s[right])) {\n      left = Math.max(left, map.get(s[right]) + 1);\n    }\n\n    map.set(s[right], right);\n    maxLen = Math.max(maxLen, right - left + 1);\n  }\n\n  return maxLen;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"longest-repeating-character-replacement",children:"Longest Repeating Character Replacement"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Find longest substring with same characters after k replacements."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n\xb2), Space: O(1)\nfunction characterReplacementBrute(s, k) {\n  let maxLen = 0;\n\n  for (let i = 0; i < s.length; i++) {\n    const count = new Array(26).fill(0);\n    let maxCount = 0;\n\n    for (let j = i; j < s.length; j++) {\n      count[s.charCodeAt(j) - 65]++;\n      maxCount = Math.max(maxCount, count[s.charCodeAt(j) - 65]);\n\n      const len = j - i + 1;\n      if (len - maxCount <= k) {\n        maxLen = Math.max(maxLen, len);\n      }\n    }\n  }\n\n  return maxLen;\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n), Space: O(1)\nfunction characterReplacement(s, k) {\n  const count = new Map();\n  let maxLen = 0;\n  let maxCount = 0;\n  let left = 0;\n\n  for (let right = 0; right < s.length; right++) {\n    count.set(s[right], (count.get(s[right]) || 0) + 1);\n    maxCount = Math.max(maxCount, count.get(s[right]));\n\n    while (right - left + 1 - maxCount > k) {\n      count.set(s[left], count.get(s[left]) - 1);\n      left++;\n    }\n\n    maxLen = Math.max(maxLen, right - left + 1);\n  }\n\n  return maxLen;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"minimum-window-substring",children:"Minimum Window Substring"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Find minimum window in s that contains all characters of t."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n\xb2m), Space: O(m)\nfunction minWindowBrute(s, t) {\n  let minLen = Infinity;\n  let result = '';\n\n  function containsAll(sub, target) {\n    const count = new Map();\n    for (let char of target) {\n      count.set(char, (count.get(char) || 0) + 1);\n    }\n\n    for (let char of sub) {\n      if (count.has(char)) {\n        count.set(char, count.get(char) - 1);\n      }\n    }\n\n    for (let val of count.values()) {\n      if (val > 0) return false;\n    }\n    return true;\n  }\n\n  for (let i = 0; i < s.length; i++) {\n    for (let j = i; j < s.length; j++) {\n      const substring = s.substring(i, j + 1);\n      if (containsAll(substring, t) && substring.length < minLen) {\n        minLen = substring.length;\n        result = substring;\n      }\n    }\n  }\n\n  return result;\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n + m), Space: O(m)\nfunction minWindow(s, t) {\n  if (s.length < t.length) return '';\n\n  const need = new Map();\n  const window = new Map();\n\n  for (let char of t) {\n    need.set(char, (need.get(char) || 0) + 1);\n  }\n\n  let left = 0;\n  let right = 0;\n  let valid = 0;\n  let start = 0;\n  let minLen = Infinity;\n\n  while (right < s.length) {\n    const char = s[right];\n    right++;\n\n    if (need.has(char)) {\n      window.set(char, (window.get(char) || 0) + 1);\n      if (window.get(char) === need.get(char)) {\n        valid++;\n      }\n    }\n\n    while (valid === need.size) {\n      if (right - left < minLen) {\n        start = left;\n        minLen = right - left;\n      }\n\n      const leftChar = s[left];\n      left++;\n\n      if (need.has(leftChar)) {\n        if (window.get(leftChar) === need.get(leftChar)) {\n          valid--;\n        }\n        window.set(leftChar, window.get(leftChar) - 1);\n      }\n    }\n  }\n\n  return minLen === Infinity ? '' : s.substring(start, start + minLen);\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"valid-anagram",children:"Valid Anagram"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Check if two strings are anagrams."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n log n), Space: O(n)\nfunction isAnagramBrute(s, t) {\n  if (s.length !== t.length) return false;\n\n  const sortedS = s.split('').sort().join('');\n  const sortedT = t.split('').sort().join('');\n\n  return sortedS === sortedT;\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n), Space: O(1)\nfunction isAnagram(s, t) {\n  if (s.length !== t.length) return false;\n\n  const count = new Array(26).fill(0);\n\n  for (let i = 0; i < s.length; i++) {\n    count[s.charCodeAt(i) - 97]++;\n    count[t.charCodeAt(i) - 97]--;\n  }\n\n  return count.every(c => c === 0);\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"group-anagrams",children:"Group Anagrams"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Group anagrams together."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n\xb2 * k log k), Space: O(nk)\nfunction groupAnagramsBrute(strs) {\n  const result = [];\n  const used = new Array(strs.length).fill(false);\n\n  for (let i = 0; i < strs.length; i++) {\n    if (used[i]) continue;\n\n    const group = [strs[i]];\n    used[i] = true;\n    const sortedI = strs[i].split('').sort().join('');\n\n    for (let j = i + 1; j < strs.length; j++) {\n      if (used[j]) continue;\n\n      const sortedJ = strs[j].split('').sort().join('');\n      if (sortedI === sortedJ) {\n        group.push(strs[j]);\n        used[j] = true;\n      }\n    }\n\n    result.push(group);\n  }\n\n  return result;\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n * k log k), Space: O(nk)\nfunction groupAnagrams(strs) {\n  const map = new Map();\n\n  for (let str of strs) {\n    const key = str.split('').sort().join('');\n    if (!map.has(key)) {\n      map.set(key, []);\n    }\n    map.get(key).push(str);\n  }\n\n  return Array.from(map.values());\n}\n\n// Alternative with character count\nfunction groupAnagramsCount(strs) {\n  const map = new Map();\n\n  for (let str of strs) {\n    const count = new Array(26).fill(0);\n    for (let char of str) {\n      count[char.charCodeAt(0) - 97]++;\n    }\n    const key = count.join('#');\n\n    if (!map.has(key)) {\n      map.set(key, []);\n    }\n    map.get(key).push(str);\n  }\n\n  return Array.from(map.values());\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"valid-parentheses",children:"Valid Parentheses"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Check if parentheses string is valid."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n\xb2), Space: O(n)\nfunction isValidBrute(s) {\n  while (s.includes('()') || s.includes('{}') || s.includes('[]')) {\n    s = s.replace('()', '').replace('{}', '').replace('[]', '');\n  }\n\n  return s.length === 0;\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n), Space: O(n)\nfunction isValid(s) {\n  const stack = [];\n  const pairs = {\n    ')': '(',\n    '}': '{',\n    ']': '[',\n  };\n\n  for (let char of s) {\n    if (char === '(' || char === '{' || char === '[') {\n      stack.push(char);\n    } else {\n      if (stack.length === 0 || stack.pop() !== pairs[char]) {\n        return false;\n      }\n    }\n  }\n\n  return stack.length === 0;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"valid-palindrome",children:"Valid Palindrome"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Check if string is a palindrome (ignoring non-alphanumeric)."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n), Space: O(n)\nfunction isPalindromeBrute(s) {\n  const cleaned = s.toLowerCase().replace(/[^a-z0-9]/g, '');\n  const reversed = cleaned.split('').reverse().join('');\n  return cleaned === reversed;\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n), Space: O(1)\nfunction isPalindrome(s) {\n  let left = 0;\n  let right = s.length - 1;\n\n  function isAlphanumeric(char) {\n    const code = char.charCodeAt(0);\n    return (\n      (code >= 48 && code <= 57) || // 0-9\n      (code >= 65 && code <= 90) || // A-Z\n      (code >= 97 && code <= 122)\n    ); // a-z\n  }\n\n  while (left < right) {\n    while (left < right && !isAlphanumeric(s[left])) left++;\n    while (left < right && !isAlphanumeric(s[right])) right--;\n\n    if (s[left].toLowerCase() !== s[right].toLowerCase()) {\n      return false;\n    }\n\n    left++;\n    right--;\n  }\n\n  return true;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"longest-palindromic-substring",children:"Longest Palindromic Substring"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Find the longest palindromic substring."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n\xb3), Space: O(1)\nfunction longestPalindromeBrute(s) {\n  let longest = '';\n\n  function isPalindrome(str) {\n    let left = 0;\n    let right = str.length - 1;\n\n    while (left < right) {\n      if (str[left] !== str[right]) return false;\n      left++;\n      right--;\n    }\n    return true;\n  }\n\n  for (let i = 0; i < s.length; i++) {\n    for (let j = i; j < s.length; j++) {\n      const substring = s.substring(i, j + 1);\n      if (isPalindrome(substring) && substring.length > longest.length) {\n        longest = substring;\n      }\n    }\n  }\n\n  return longest;\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n\xb2), Space: O(1)\nfunction longestPalindrome(s) {\n  let start = 0;\n  let maxLen = 0;\n\n  function expandAroundCenter(left, right) {\n    while (left >= 0 && right < s.length && s[left] === s[right]) {\n      left--;\n      right++;\n    }\n    return right - left - 1;\n  }\n\n  for (let i = 0; i < s.length; i++) {\n    const len1 = expandAroundCenter(i, i);\n    const len2 = expandAroundCenter(i, i + 1);\n    const len = Math.max(len1, len2);\n\n    if (len > maxLen) {\n      maxLen = len;\n      start = i - Math.floor((len - 1) / 2);\n    }\n  }\n\n  return s.substring(start, start + maxLen);\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"palindromic-substrings",children:"Palindromic Substrings"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Count all palindromic substrings."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Brute Force Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n\xb3), Space: O(1)\nfunction countSubstringsBrute(s) {\n  let count = 0;\n\n  function isPalindrome(str) {\n    let left = 0;\n    let right = str.length - 1;\n\n    while (left < right) {\n      if (str[left] !== str[right]) return false;\n      left++;\n      right--;\n    }\n    return true;\n  }\n\n  for (let i = 0; i < s.length; i++) {\n    for (let j = i; j < s.length; j++) {\n      if (isPalindrome(s.substring(i, j + 1))) {\n        count++;\n      }\n    }\n  }\n\n  return count;\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Optimal Solution:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Time: O(n\xb2), Space: O(1)\nfunction countSubstrings(s) {\n  let count = 0;\n\n  function expandAroundCenter(left, right) {\n    while (left >= 0 && right < s.length && s[left] === s[right]) {\n      count++;\n      left--;\n      right++;\n    }\n  }\n\n  for (let i = 0; i < s.length; i++) {\n    expandAroundCenter(i, i);       // odd length\n    expandAroundCenter(i, i + 1);   // even length\n  }\n\n  return count;\n"})})]})}function h(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}},28453:(n,e,r)=>{r.d(e,{R:()=>l,x:()=>a});var t=r(96540);const i={},s=t.createContext(i);function l(n){const e=t.useContext(s);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:l(n.components),t.createElement(s.Provider,{value:e},n.children)}}}]);