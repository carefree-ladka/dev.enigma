"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[3604],{28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>c});var i=t(96540);const r={},s=i.createContext(r);function a(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(s.Provider,{value:n},e.children)}},59866:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>c,toc:()=>o});var i=t(74848),r=t(28453);const s={},a="TypeScript Generics",c={id:"WebDev/TypeScript/TypeScriptGenerics",title:"TypeScript Generics",description:"Basic Generic Functions",source:"@site/docs/WebDev/TypeScript/TypeScriptGenerics.mdx",sourceDirName:"WebDev/TypeScript",slug:"/WebDev/TypeScript/TypeScriptGenerics",permalink:"/js.enigma/docs/WebDev/TypeScript/TypeScriptGenerics",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/WebDev/TypeScript/TypeScriptGenerics.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"SOLID Principles in React",permalink:"/js.enigma/docs/WebDev/React/SOLIDPrinciples"},next:{title:"TypeScript Cheatsheet",permalink:"/js.enigma/docs/WebDev/TypeScript/TypeScriptIntroduction"}},l={},o=[{value:"Basic Generic Functions",id:"basic-generic-functions",level:2},{value:"Generic Interfaces",id:"generic-interfaces",level:2},{value:"Generic Classes",id:"generic-classes",level:2},{value:"Generic Constraints",id:"generic-constraints",level:2},{value:"Generic Type Aliases",id:"generic-type-aliases",level:2},{value:"Advanced Generic Patterns",id:"advanced-generic-patterns",level:2},{value:"Practical Examples",id:"practical-examples",level:2}];function p(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",pre:"pre",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"typescript-generics",children:"TypeScript Generics"})}),"\n",(0,i.jsx)(n.h2,{id:"basic-generic-functions",children:"Basic Generic Functions"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// Regular function with generic\nfunction identity<T>(arg: T): T {\n  return arg;\n}\n\n// Arrow function with generic\nconst identityArrow = <T>(arg: T): T => {\n  return arg;\n}\n\n// Multiple type parameters\nfunction pair<T, U>(first: T, second: U): [T, U] {\n  return [first, second];\n}\n\n// Generic function with constraints\nfunction getLength<T extends { length: number }>(arg: T): number {\n  return arg.length;\n}\n\n// Default type parameters\nfunction createArray<T = string>(length: number, value: T): T[] {\n  return new Array(length).fill(value);\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"generic-interfaces",children:"Generic Interfaces"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// Basic generic interface\ninterface Box<T> {\n  value: T;\n}\n\n// Interface with multiple type parameters\ninterface Dictionary<K extends string | number, V> {\n  get(key: K): V | undefined;\n  set(key: K, value: V): void;\n}\n\n// Generic interface extending another generic interface\ninterface ReadOnlyBox<T> extends Box<T> {\n  readonly value: T;\n}\n\n// Generic interface with methods\ninterface Collection<T> {\n  add(item: T): void;\n  remove(item: T): void;\n  getItems(): T[];\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"generic-classes",children:"Generic Classes"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// Basic generic class\nclass Stack<T> {\n  private items: T[] = [];\n\n  push(item: T): void {\n    this.items.push(item);\n  }\n\n  pop(): T | undefined {\n    return this.items.pop();\n  }\n}\n\n// Generic class implementing generic interface\nclass ArrayCollection<T> implements Collection<T> {\n  private items: T[] = [];\n\n  add(item: T): void {\n    this.items.push(item);\n  }\n\n  remove(item: T): void {\n    const index = this.items.indexOf(item);\n    if (index > -1) {\n      this.items.splice(index, 1);\n    }\n  }\n\n  getItems(): T[] {\n    return [...this.items];\n  }\n}\n\n// Generic class with multiple type parameters\nclass KeyValuePair<K, V> {\n  constructor(public key: K, public value: V) {}\n\n  toString(): string {\n    return `${String(this.key)}: ${String(this.value)}`;\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"generic-constraints",children:"Generic Constraints"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// Constraint to object type\nfunction getProperty<T extends object, K extends keyof T>(obj: T, key: K): T[K] {\n  return obj[key];\n}\n\n// Constraint with interface\ninterface Lengthwise {\n  length: number;\n}\n\nfunction loggingIdentity<T extends Lengthwise>(arg: T): T {\n  console.log(arg.length);\n  return arg;\n}\n\n// Constraint to class type\nclass Animal {\n  name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n}\n\nfunction createInstance<T extends Animal>(c: new () => T): T {\n  return new c();\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"generic-type-aliases",children:"Generic Type Aliases"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// Simple generic type alias\ntype Container<T> = { value: T };\n\n// Generic mapped type\ntype Readonly<T> = {\n  readonly [P in keyof T]: T[P];\n};\n\n// Conditional generic type\ntype NonNullable<T> = T extends null | undefined ? never : T;\n\n// Generic utility type\ntype ReturnType<T extends (...args: any) => any> = \n  T extends (...args: any) => infer R ? R : any;\n"})}),"\n",(0,i.jsx)(n.h2,{id:"advanced-generic-patterns",children:"Advanced Generic Patterns"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// Generic factory function\nfunction create<T>(Factory: { new (): T }): T {\n  return new Factory();\n}\n\n// Generic method overloads\nclass DataContainer {\n  getData<T extends string>(id: number): string;\n  getData<T extends number>(id: string): number;\n  getData<T>(id: string | number): T {\n    // Implementation\n    return {} as T;\n  }\n}\n\n// Generic type guards\nfunction isOfType<T>(value: any, property: keyof T): value is T {\n  return property in value;\n}\n\n// Generic parameter defaults with constraints\nclass Api<T extends object = {}> {\n  constructor(private baseUrl: string) {}\n  \n  async get<U extends keyof T>(endpoint: U): Promise<T[U]> {\n    // Implementation\n    return {} as T[U];\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"practical-examples",children:"Practical Examples"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// Generic React component\ninterface Props<T> {\n  items: T[];\n  renderItem: (item: T) => React.ReactNode;\n}\n\nfunction List<T>({ items, renderItem }: Props<T>) {\n  return (\n    <ul>\n      {items.map((item, index) => (\n        <li key={index}>{renderItem(item)}</li>\n      ))}\n    </ul>\n  );\n}\n\n// Generic state management\nclass Store<State extends object> {\n  private state: State;\n\n  constructor(initialState: State) {\n    this.state = initialState;\n  }\n\n  getState(): Readonly<State> {\n    return Object.freeze({ ...this.state });\n  }\n\n  setState(partial: Partial<State>): void {\n    this.state = { ...this.state, ...partial };\n  }\n}\n\n// Generic event system\ntype Listener<T> = (event: T) => void;\n\nclass EventEmitter<T extends string> {\n  private listeners: Map<T, Listener<T>[]> = new Map();\n\n  on(event: T, listener: Listener<T>): void {\n    const listeners = this.listeners.get(event) || [];\n    this.listeners.set(event, [...listeners, listener]);\n  }\n\n  emit(event: T): void {\n    const listeners = this.listeners.get(event) || [];\n    listeners.forEach(listener => listener(event));\n  }\n}\n"})})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}}}]);