"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[6498],{28453:(n,e,t)=>{t.d(e,{R:()=>s,x:()=>l});var i=t(96540);const a={},r=i.createContext(a);function s(n){const e=i.useContext(r);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:s(n.components),i.createElement(r.Provider,{value:e},n.children)}},37432:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>o,contentTitle:()=>s,default:()=>u,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var i=t(74848),a=t(28453);const r={},s="Java Object-Oriented Programming",l={id:"Java/JavaOOP",title:"Java Object-Oriented Programming",description:"Table of Contents",source:"@site/docs/Java/JavaOOP.mdx",sourceDirName:"Java",slug:"/Java/JavaOOP",permalink:"/dev.enigma/docs/Java/JavaOOP",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/Java/JavaOOP.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Java Multithreading",permalink:"/dev.enigma/docs/Java/JavaMultithreading"},next:{title:"Java Stream API",permalink:"/dev.enigma/docs/Java/JavaStreamAPI"}},o={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Introduction to OOP",id:"introduction-to-oop",level:2},{value:"Core Principles of OOP",id:"core-principles-of-oop",level:3},{value:"Benefits of OOP",id:"benefits-of-oop",level:3},{value:"Real-World Analogy",id:"real-world-analogy",level:3},{value:"Classes and Objects",id:"classes-and-objects",level:2},{value:"What is a Class?",id:"what-is-a-class",level:3},{value:"What is an Object?",id:"what-is-an-object",level:3},{value:"Basic Class Structure",id:"basic-class-structure",level:3},{value:"Multiple Objects Example",id:"multiple-objects-example",level:3},{value:"Constructors",id:"constructors",level:2},{value:"Types of Constructors",id:"types-of-constructors",level:3},{value:"Constructor Chaining",id:"constructor-chaining",level:3},{value:"Instance Variables and Methods",id:"instance-variables-and-methods",level:2},{value:"Instance Variables",id:"instance-variables",level:3},{value:"Instance Methods",id:"instance-methods",level:3},{value:"Static Members",id:"static-members",level:2},{value:"Static Variables and Methods",id:"static-variables-and-methods",level:3},{value:"Static Block and Utility Class",id:"static-block-and-utility-class",level:3},{value:"Encapsulation",id:"encapsulation",level:2},{value:"Benefits of Encapsulation",id:"benefits-of-encapsulation",level:3},{value:"Inheritance",id:"inheritance",level:2},{value:"Key Terms",id:"key-terms",level:3},{value:"Basic Inheritance Example",id:"basic-inheritance-example",level:3},{value:"Polymorphism",id:"polymorphism",level:2},{value:"Types of Polymorphism",id:"types-of-polymorphism",level:3},{value:"Runtime Polymorphism Example",id:"runtime-polymorphism-example",level:3},{value:"Method Overloading (Compile-time Polymorphism)",id:"method-overloading-compile-time-polymorphism",level:3},{value:"Abstraction",id:"abstraction",level:2},{value:"Abstract Classes",id:"abstract-classes",level:3},{value:"Interfaces",id:"interfaces",level:2},{value:"Basic Interface Example",id:"basic-interface-example",level:3},{value:"Access Modifiers",id:"access-modifiers",level:2},{value:"Four Access Modifiers",id:"four-access-modifiers",level:3},{value:"Method Overloading and Overriding",id:"method-overloading-and-overriding",level:2},{value:"Method Overloading vs Method Overriding",id:"method-overloading-vs-method-overriding",level:3},{value:"Method Overriding Example",id:"method-overriding-example",level:3},{value:"Super Keyword",id:"super-keyword",level:2},{value:"Final Keyword",id:"final-keyword",level:2},{value:"Practical Examples",id:"practical-examples",level:2},{value:"Library Management System",id:"library-management-system",level:3},{value:"Online Shopping System",id:"online-shopping-system",level:3},{value:"Summary",id:"summary",level:2},{value:"Key Takeaways",id:"key-takeaways",level:3},{value:"Best Practices",id:"best-practices",level:3},{value:"Design Principles",id:"design-principles",level:3}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"java-object-oriented-programming",children:"Java Object-Oriented Programming"})}),"\n",(0,i.jsx)(e.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#introduction-to-oop",children:"Introduction to OOP"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#classes-and-objects",children:"Classes and Objects"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#constructors",children:"Constructors"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#instance-variables-and-methods",children:"Instance Variables and Methods"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#static-members",children:"Static Members"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#encapsulation",children:"Encapsulation"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#inheritance",children:"Inheritance"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#polymorphism",children:"Polymorphism"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#abstraction",children:"Abstraction"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#interfaces",children:"Interfaces"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#access-modifiers",children:"Access Modifiers"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#method-overloading-and-overriding",children:"Method Overloading and Overriding"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#super-keyword",children:"Super Keyword"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#final-keyword",children:"Final Keyword"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#practical-examples",children:"Practical Examples"})}),"\n"]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"introduction-to-oop",children:"Introduction to OOP"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Object-Oriented Programming (OOP)"}),' is a programming paradigm based on the concept of "objects" which contain data (attributes) and code (methods). Java is a pure object-oriented language where everything is an object (except primitives).']}),"\n",(0,i.jsx)(e.h3,{id:"core-principles-of-oop",children:"Core Principles of OOP"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Encapsulation"})," - Bundling data and methods that work on that data within one unit"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Inheritance"})," - Creating new classes based on existing classes"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Polymorphism"})," - One interface, multiple implementations"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Abstraction"})," - Hiding implementation details and showing only functionality"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"benefits-of-oop",children:"Benefits of OOP"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Modularity"})," - Code is organized into discrete objects"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Reusability"})," - Objects can be reused across different programs"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Maintainability"})," - Easy to modify and extend"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Scalability"})," - Easy to add new features"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Security"})," - Data hiding through encapsulation"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"real-world-analogy",children:"Real-World Analogy"}),"\n",(0,i.jsxs)(e.p,{children:["Think of a ",(0,i.jsx)(e.strong,{children:"Car"})," as an object:"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Attributes"}),": color, model, speed, fuel"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Methods"}),": start(), stop(), accelerate(), brake()"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Encapsulation"}),": Internal engine details are hidden"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Inheritance"}),": SportsCar extends Car"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Polymorphism"}),": Different cars implement start() differently"]}),"\n"]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"classes-and-objects",children:"Classes and Objects"}),"\n",(0,i.jsx)(e.h3,{id:"what-is-a-class",children:"What is a Class?"}),"\n",(0,i.jsxs)(e.p,{children:["A ",(0,i.jsx)(e.strong,{children:"class"})," is a blueprint or template for creating objects. It defines the structure and behavior that objects of that type will have."]}),"\n",(0,i.jsx)(e.h3,{id:"what-is-an-object",children:"What is an Object?"}),"\n",(0,i.jsxs)(e.p,{children:["An ",(0,i.jsx)(e.strong,{children:"object"})," is an instance of a class. It's a concrete entity created from the class blueprint."]}),"\n",(0,i.jsx)(e.h3,{id:"basic-class-structure",children:"Basic Class Structure"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'// Class definition\npublic class Car {\n    // Instance variables (attributes/properties)\n    private String brand;\n    private String model;\n    private int year;\n    private double price;\n\n    // Constructor\n    public Car(String brand, String model, int year, double price) {\n        this.brand = brand;\n        this.model = model;\n        this.year = year;\n        this.price = price;\n    }\n\n    // Instance methods (behavior)\n    public void startEngine() {\n        System.out.println(brand + " " + model + " engine started!");\n    }\n\n    public void displayInfo() {\n        System.out.println("Car: " + brand + " " + model + " (" + year + ") - $" + price);\n    }\n\n    // Getter methods\n    public String getBrand() {\n        return brand;\n    }\n\n    public String getModel() {\n        return model;\n    }\n}\n\n// Using the class to create objects\npublic class CarDemo {\n    public static void main(String[] args) {\n        // Creating objects (instantiation)\n        Car car1 = new Car("Toyota", "Camry", 2023, 28000.0);\n        Car car2 = new Car("Honda", "Civic", 2022, 25000.0);\n\n        // Using objects\n        car1.displayInfo();\n        car1.startEngine();\n\n        car2.displayInfo();\n        car2.startEngine();\n\n        // Accessing object properties through methods\n        System.out.println("Car 1 brand: " + car1.getBrand());\n    }\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"multiple-objects-example",children:"Multiple Objects Example"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'public class Student {\n    private String name;\n    private int age;\n    private String studentId;\n    private double gpa;\n\n    public Student(String name, int age, String studentId) {\n        this.name = name;\n        this.age = age;\n        this.studentId = studentId;\n        this.gpa = 0.0; // Default value\n    }\n\n    public void study(String subject) {\n        System.out.println(name + " is studying " + subject);\n    }\n\n    public void setGpa(double gpa) {\n        if (gpa >= 0.0 && gpa <= 4.0) {\n            this.gpa = gpa;\n        } else {\n            System.out.println("Invalid GPA! Must be between 0.0 and 4.0");\n        }\n    }\n\n    public String getGradeLevel() {\n        if (gpa >= 3.5) return "Excellent";\n        else if (gpa >= 3.0) return "Good";\n        else if (gpa >= 2.0) return "Average";\n        else return "Needs Improvement";\n    }\n\n    public void displayInfo() {\n        System.out.printf("Student: %s (ID: %s), Age: %d, GPA: %.2f (%s)%n",\n                         name, studentId, age, gpa, getGradeLevel());\n    }\n\n    // Getters\n    public String getName() { return name; }\n    public int getAge() { return age; }\n    public String getStudentId() { return studentId; }\n    public double getGpa() { return gpa; }\n}\n\npublic class StudentDemo {\n    public static void main(String[] args) {\n        // Creating multiple student objects\n        Student[] students = {\n            new Student("Alice Johnson", 20, "S001"),\n            new Student("Bob Smith", 19, "S002"),\n            new Student("Carol Davis", 21, "S003")\n        };\n\n        // Setting GPAs\n        students[0].setGpa(3.8);\n        students[1].setGpa(3.2);\n        students[2].setGpa(2.9);\n\n        // Display all students\n        System.out.println("=== Student Information ===");\n        for (Student student : students) {\n            student.displayInfo();\n            student.study("Java Programming");\n            System.out.println();\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"constructors",children:"Constructors"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Constructors"})," are special methods used to initialize objects when they are created. They have the same name as the class and no return type."]}),"\n",(0,i.jsx)(e.h3,{id:"types-of-constructors",children:"Types of Constructors"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'public class Rectangle {\n    private double length;\n    private double width;\n    private String color;\n\n    // 1. Default Constructor (no parameters)\n    public Rectangle() {\n        this.length = 1.0;\n        this.width = 1.0;\n        this.color = "white";\n        System.out.println("Default constructor called");\n    }\n\n    // 2. Parameterized Constructor\n    public Rectangle(double length, double width) {\n        this.length = length;\n        this.width = width;\n        this.color = "white"; // Default color\n        System.out.println("Parameterized constructor (2 params) called");\n    }\n\n    // 3. Constructor Overloading\n    public Rectangle(double length, double width, String color) {\n        this.length = length;\n        this.width = width;\n        this.color = color;\n        System.out.println("Parameterized constructor (3 params) called");\n    }\n\n    // 4. Copy Constructor\n    public Rectangle(Rectangle other) {\n        this.length = other.length;\n        this.width = other.width;\n        this.color = other.color;\n        System.out.println("Copy constructor called");\n    }\n\n    public double calculateArea() {\n        return length * width;\n    }\n\n    public double calculatePerimeter() {\n        return 2 * (length + width);\n    }\n\n    public void displayInfo() {\n        System.out.printf("Rectangle: %.2f x %.2f, Color: %s%n", length, width, color);\n        System.out.printf("Area: %.2f, Perimeter: %.2f%n", calculateArea(), calculatePerimeter());\n    }\n\n    // Getters and Setters\n    public double getLength() { return length; }\n    public double getWidth() { return width; }\n    public String getColor() { return color; }\n\n    public void setLength(double length) {\n        if (length > 0) this.length = length;\n    }\n\n    public void setWidth(double width) {\n        if (width > 0) this.width = width;\n    }\n\n    public void setColor(String color) {\n        this.color = color;\n    }\n}\n\npublic class ConstructorDemo {\n    public static void main(String[] args) {\n        System.out.println("Creating rectangles using different constructors:\\n");\n\n        // Using different constructors\n        Rectangle rect1 = new Rectangle();                    // Default\n        Rectangle rect2 = new Rectangle(5.0, 3.0);          // 2 parameters\n        Rectangle rect3 = new Rectangle(4.0, 6.0, "blue");  // 3 parameters\n        Rectangle rect4 = new Rectangle(rect2);              // Copy constructor\n\n        System.out.println("\\nRectangle Information:");\n        rect1.displayInfo();\n        System.out.println();\n\n        rect2.displayInfo();\n        System.out.println();\n\n        rect3.displayInfo();\n        System.out.println();\n\n        rect4.displayInfo();\n    }\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"constructor-chaining",children:"Constructor Chaining"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'public class Employee {\n    private String name;\n    private int id;\n    private double salary;\n    private String department;\n\n    // Constructor chaining using this()\n    public Employee() {\n        this("Unknown", 0); // Calls the two-parameter constructor\n    }\n\n    public Employee(String name, int id) {\n        this(name, id, 0.0); // Calls the three-parameter constructor\n    }\n\n    public Employee(String name, int id, double salary) {\n        this(name, id, salary, "General"); // Calls the four-parameter constructor\n    }\n\n    public Employee(String name, int id, double salary, String department) {\n        this.name = name;\n        this.id = id;\n        this.salary = salary;\n        this.department = department;\n        System.out.println("Main constructor called for: " + name);\n    }\n\n    public void displayEmployee() {\n        System.out.printf("Employee: %s (ID: %d), Department: %s, Salary: $%.2f%n",\n                         name, id, department, salary);\n    }\n}\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"instance-variables-and-methods",children:"Instance Variables and Methods"}),"\n",(0,i.jsx)(e.h3,{id:"instance-variables",children:"Instance Variables"}),"\n",(0,i.jsx)(e.p,{children:"Instance variables belong to specific objects and each object has its own copy."}),"\n",(0,i.jsx)(e.h3,{id:"instance-methods",children:"Instance Methods"}),"\n",(0,i.jsx)(e.p,{children:"Instance methods can access instance variables and other instance methods directly."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'public class BankAccount {\n    // Instance variables - each account has its own values\n    private String accountNumber;\n    private String accountHolder;\n    private double balance;\n    private String accountType;\n    private int transactionCount;\n\n    public BankAccount(String accountNumber, String accountHolder, String accountType) {\n        this.accountNumber = accountNumber;\n        this.accountHolder = accountHolder;\n        this.accountType = accountType;\n        this.balance = 0.0;\n        this.transactionCount = 0;\n    }\n\n    // Instance methods - operate on instance variables\n    public void deposit(double amount) {\n        if (amount > 0) {\n            balance += amount;\n            transactionCount++;\n            System.out.printf("Deposited $%.2f. New balance: $%.2f%n", amount, balance);\n        } else {\n            System.out.println("Invalid deposit amount!");\n        }\n    }\n\n    public void withdraw(double amount) {\n        if (amount > 0 && amount <= balance) {\n            balance -= amount;\n            transactionCount++;\n            System.out.printf("Withdrew $%.2f. New balance: $%.2f%n", amount, balance);\n        } else if (amount > balance) {\n            System.out.println("Insufficient funds!");\n        } else {\n            System.out.println("Invalid withdrawal amount!");\n        }\n    }\n\n    public void transfer(BankAccount targetAccount, double amount) {\n        if (amount > 0 && amount <= balance) {\n            this.withdraw(amount);\n            targetAccount.deposit(amount);\n            System.out.printf("Transferred $%.2f to account %s%n",\n                             amount, targetAccount.accountNumber);\n        } else {\n            System.out.println("Transfer failed!");\n        }\n    }\n\n    public double calculateInterest() {\n        double interestRate = accountType.equals("Savings") ? 0.03 : 0.01;\n        return balance * interestRate;\n    }\n\n    public void displayAccountInfo() {\n        System.out.println("=== Account Information ===");\n        System.out.println("Account Number: " + accountNumber);\n        System.out.println("Account Holder: " + accountHolder);\n        System.out.println("Account Type: " + accountType);\n        System.out.printf("Current Balance: $%.2f%n", balance);\n        System.out.println("Transaction Count: " + transactionCount);\n        System.out.printf("Potential Interest: $%.2f%n", calculateInterest());\n    }\n\n    // Getters\n    public String getAccountNumber() { return accountNumber; }\n    public String getAccountHolder() { return accountHolder; }\n    public double getBalance() { return balance; }\n    public String getAccountType() { return accountType; }\n}\n\npublic class BankingDemo {\n    public static void main(String[] args) {\n        // Creating bank account objects\n        BankAccount alice = new BankAccount("ACC001", "Alice Johnson", "Savings");\n        BankAccount bob = new BankAccount("ACC002", "Bob Smith", "Checking");\n\n        System.out.println("=== Banking Operations Demo ===\\n");\n\n        // Operations on Alice\'s account\n        alice.deposit(1000.0);\n        alice.withdraw(200.0);\n        alice.displayAccountInfo();\n\n        System.out.println();\n\n        // Operations on Bob\'s account\n        bob.deposit(500.0);\n        bob.displayAccountInfo();\n\n        System.out.println();\n\n        // Transfer between accounts\n        alice.transfer(bob, 150.0);\n\n        System.out.println("\\nAfter transfer:");\n        alice.displayAccountInfo();\n        System.out.println();\n        bob.displayAccountInfo();\n    }\n}\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"static-members",children:"Static Members"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Static members"})," belong to the class rather than to any specific object. They are shared among all objects of the class."]}),"\n",(0,i.jsx)(e.h3,{id:"static-variables-and-methods",children:"Static Variables and Methods"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'public class Counter {\n    // Static variable - shared by all objects\n    private static int totalCount = 0;\n\n    // Instance variable - unique to each object\n    private int instanceCount;\n    private String name;\n\n    public Counter(String name) {\n        this.name = name;\n        this.instanceCount = 0;\n        totalCount++; // Increment static variable\n        System.out.println("Counter created for: " + name);\n    }\n\n    // Instance method\n    public void increment() {\n        instanceCount++;\n        totalCount++;\n    }\n\n    // Static method - can only access static variables\n    public static int getTotalCount() {\n        return totalCount;\n    }\n\n    // Static method to reset total count\n    public static void resetTotalCount() {\n        totalCount = 0;\n        System.out.println("Total count reset to 0");\n    }\n\n    // Instance method\n    public void displayInfo() {\n        System.out.printf("%s - Instance: %d, Total: %d%n",\n                         name, instanceCount, totalCount);\n    }\n\n    public int getInstanceCount() {\n        return instanceCount;\n    }\n}\n\npublic class StaticDemo {\n    public static void main(String[] args) {\n        System.out.println("Initial total count: " + Counter.getTotalCount());\n\n        // Creating objects\n        Counter counter1 = new Counter("Counter1");\n        Counter counter2 = new Counter("Counter2");\n        Counter counter3 = new Counter("Counter3");\n\n        System.out.println("After creating 3 counters: " + Counter.getTotalCount());\n\n        // Using instance methods\n        counter1.increment();\n        counter1.increment();\n        counter2.increment();\n\n        System.out.println("\\nAfter some increments:");\n        counter1.displayInfo();\n        counter2.displayInfo();\n        counter3.displayInfo();\n\n        System.out.println("Total count: " + Counter.getTotalCount());\n\n        // Using static method\n        Counter.resetTotalCount();\n        System.out.println("After reset: " + Counter.getTotalCount());\n    }\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"static-block-and-utility-class",children:"Static Block and Utility Class"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'public class MathUtils {\n    // Static variables\n    private static final double PI = 3.14159;\n    private static boolean initialized = false;\n\n    // Static block - executes when class is first loaded\n    static {\n        System.out.println("Loading MathUtils class...");\n        initialized = true;\n        System.out.println("MathUtils initialized successfully!");\n    }\n\n    // Static utility methods\n    public static double calculateCircleArea(double radius) {\n        return PI * radius * radius;\n    }\n\n    public static double calculateRectangleArea(double length, double width) {\n        return length * width;\n    }\n\n    public static boolean isPrime(int number) {\n        if (number < 2) return false;\n        for (int i = 2; i <= Math.sqrt(number); i++) {\n            if (number % i == 0) return false;\n        }\n        return true;\n    }\n\n    public static int factorial(int n) {\n        if (n <= 1) return 1;\n        return n * factorial(n - 1);\n    }\n\n    public static boolean isInitialized() {\n        return initialized;\n    }\n}\n\npublic class StaticUtilityDemo {\n    public static void main(String[] args) {\n        // Static block executes automatically\n        System.out.println("MathUtils initialized: " + MathUtils.isInitialized());\n\n        // Using static utility methods\n        System.out.println("\\n=== Math Utilities ===");\n        System.out.println("Circle area (radius 5): " + MathUtils.calculateCircleArea(5.0));\n        System.out.println("Rectangle area (4x6): " + MathUtils.calculateRectangleArea(4.0, 6.0));\n        System.out.println("Is 17 prime? " + MathUtils.isPrime(17));\n        System.out.println("Is 20 prime? " + MathUtils.isPrime(20));\n        System.out.println("Factorial of 5: " + MathUtils.factorial(5));\n    }\n}\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"encapsulation",children:"Encapsulation"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Encapsulation"})," is the bundling of data (attributes) and methods (functions) that operate on the data into a single unit, and restricting access to some of the object's components. It's implemented using access modifiers and getter/setter methods."]}),"\n",(0,i.jsx)(e.h3,{id:"benefits-of-encapsulation",children:"Benefits of Encapsulation"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Data Protection"}),": Prevents direct access to sensitive data"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Validation"}),": Control how data is set and retrieved"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Maintainability"}),": Changes to internal implementation don't affect external code"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Flexibility"}),": Can change internal representation without affecting users"]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'public class Person {\n    // Private instance variables - encapsulated data\n    private String name;\n    private int age;\n    private String email;\n    private double salary;\n    private boolean isEmployed;\n\n    // Constructor\n    public Person(String name, int age, String email) {\n        setName(name);\n        setAge(age);\n        setEmail(email);\n        this.salary = 0.0;\n        this.isEmployed = false;\n    }\n\n    // Getter methods (accessors) - provide controlled access to read data\n    public String getName() {\n        return name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n\n    public double getSalary() {\n        return isEmployed ? salary : 0.0; // Only return salary if employed\n    }\n\n    public boolean isEmployed() {\n        return isEmployed;\n    }\n\n    // Setter methods (mutators) - provide controlled access to modify data\n    public void setName(String name) {\n        if (name != null && !name.trim().isEmpty()) {\n            this.name = name.trim();\n        } else {\n            throw new IllegalArgumentException("Name cannot be null or empty");\n        }\n    }\n\n    public void setAge(int age) {\n        if (age >= 0 && age <= 150) {\n            this.age = age;\n        } else {\n            throw new IllegalArgumentException("Age must be between 0 and 150");\n        }\n    }\n\n    public void setEmail(String email) {\n        if (email != null && email.contains("@") && email.contains(".")) {\n            this.email = email.toLowerCase();\n        } else {\n            throw new IllegalArgumentException("Invalid email format");\n        }\n    }\n\n    public void setSalary(double salary) {\n        if (salary >= 0) {\n            this.salary = salary;\n        } else {\n            throw new IllegalArgumentException("Salary cannot be negative");\n        }\n    }\n\n    public void setEmployed(boolean employed) {\n        this.isEmployed = employed;\n        if (!employed) {\n            this.salary = 0.0; // Reset salary when unemployed\n        }\n    }\n\n    // Business logic methods\n    public void hire(double salary) {\n        setEmployed(true);\n        setSalary(salary);\n        System.out.println(name + " has been hired with salary: $" + salary);\n    }\n\n    public void fire() {\n        setEmployed(false);\n        System.out.println(name + " has been terminated");\n    }\n\n    public void giveRaise(double percentage) {\n        if (isEmployed && percentage > 0) {\n            double newSalary = salary * (1 + percentage / 100);\n            setSalary(newSalary);\n            System.out.printf("%s received a %.1f%% raise. New salary: $%.2f%n",\n                             name, percentage, salary);\n        } else {\n            System.out.println("Cannot give raise: person not employed or invalid percentage");\n        }\n    }\n\n    public String getAgeGroup() {\n        if (age < 13) return "Child";\n        else if (age < 20) return "Teenager";\n        else if (age < 60) return "Adult";\n        else return "Senior";\n    }\n\n    public void displayInfo() {\n        System.out.println("=== Person Information ===");\n        System.out.println("Name: " + name);\n        System.out.println("Age: " + age + " (" + getAgeGroup() + ")");\n        System.out.println("Email: " + email);\n        System.out.println("Employment Status: " + (isEmployed ? "Employed" : "Unemployed"));\n        if (isEmployed) {\n            System.out.printf("Salary: $%.2f%n", salary);\n        }\n    }\n}\n\npublic class EncapsulationDemo {\n    public static void main(String[] args) {\n        try {\n            // Creating person objects\n            Person person1 = new Person("John Doe", 30, "john@email.com");\n            Person person2 = new Person("Jane Smith", 25, "jane@email.com");\n\n            System.out.println("=== Initial State ===");\n            person1.displayInfo();\n            System.out.println();\n            person2.displayInfo();\n\n            System.out.println("\\n=== Employment Operations ===");\n            // Hiring employees\n            person1.hire(50000.0);\n            person2.hire(45000.0);\n\n            System.out.println();\n            person1.displayInfo();\n            System.out.println();\n            person2.displayInfo();\n\n            System.out.println("\\n=== Giving Raises ===");\n            person1.giveRaise(10.0); // 10% raise\n            person2.giveRaise(7.5);  // 7.5% raise\n\n            System.out.println("\\n=== Trying to Set Invalid Data ===");\n            // These will throw exceptions due to validation in setters\n            try {\n                person1.setAge(-5); // Invalid age\n            } catch (IllegalArgumentException e) {\n                System.out.println("Error: " + e.getMessage());\n            }\n\n            try {\n                person2.setEmail("invalid-email"); // Invalid email\n            } catch (IllegalArgumentException e) {\n                System.out.println("Error: " + e.getMessage());\n            }\n\n            System.out.println("\\n=== Final State ===");\n            person1.displayInfo();\n            System.out.println();\n            person2.displayInfo();\n\n        } catch (Exception e) {\n            System.out.println("Error: " + e.getMessage());\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"inheritance",children:"Inheritance"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Inheritance"})," is a mechanism that allows a new class to inherit properties and methods from an existing class. It promotes code reuse and establishes a natural hierarchy."]}),"\n",(0,i.jsx)(e.h3,{id:"key-terms",children:"Key Terms"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Parent Class/Superclass/Base Class"}),": The class being inherited from"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Child Class/Subclass/Derived Class"}),": The class that inherits"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"extends"}),": Keyword used to establish inheritance relationship"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"basic-inheritance-example",children:"Basic Inheritance Example"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'// Parent class (Superclass)\npublic class Animal {\n    // Protected - accessible by subclasses\n    protected String name;\n    protected int age;\n    protected String species;\n\n    // Constructor\n    public Animal(String name, int age, String species) {\n        this.name = name;\n        this.age = age;\n        this.species = species;\n        System.out.println("Animal constructor called");\n    }\n\n    // Methods that can be inherited\n    public void eat() {\n        System.out.println(name + " is eating");\n    }\n\n    public void sleep() {\n        System.out.println(name + " is sleeping");\n    }\n\n    public void makeSound() {\n        System.out.println(name + " makes a sound");\n    }\n\n    public void displayInfo() {\n        System.out.println("Name: " + name);\n        System.out.println("Age: " + age);\n        System.out.println("Species: " + species);\n    }\n\n    // Getters\n    public String getName() { return name; }\n    public int getAge() { return age; }\n    public String getSpecies() { return species; }\n}\n\n// Child class 1\npublic class Dog extends Animal {\n    private String breed;\n    private boolean isGoodBoy;\n\n    public Dog(String name, int age, String breed) {\n        super(name, age, "Canine"); // Call parent constructor\n        this.breed = breed;\n        this.isGoodBoy = true;\n        System.out.println("Dog constructor called");\n    }\n\n    // Override parent method\n    @Override\n    public void makeSound() {\n        System.out.println(name + " barks: Woof! Woof!");\n    }\n\n    // New methods specific to Dog\n    public void wagTail() {\n        System.out.println(name + " is wagging tail happily!");\n    }\n\n    public void fetch() {\n        System.out.println(name + " is fetching the ball!");\n    }\n\n    public void setGoodBoy(boolean isGoodBoy) {\n        this.isGoodBoy = isGoodBoy;\n    }\n\n    // Override displayInfo to show additional Dog-specific info\n    @Override\n    public void displayInfo() {\n        super.displayInfo(); // Call parent method\n        System.out.println("Breed: " + breed);\n        System.out.println("Good Boy: " + (isGoodBoy ? "Yes" : "No"));\n    }\n\n    public String getBreed() { return breed; }\n}\n\n// Child class 2\npublic class Cat extends Animal {\n    private boolean isIndoor;\n    private int livesRemaining;\n\n    public Cat(String name, int age, boolean isIndoor) {\n        super(name, age, "Feline"); // Call parent constructor\n        this.isIndoor = isIndoor;\n        this.livesRemaining = 9; // Cats have 9 lives!\n        System.out.println("Cat constructor called");\n    }\n\n    // Override parent method\n    @Override\n    public void makeSound() {\n        System.out.println(name + " meows: Meow! Meow!");\n    }\n\n    // New methods specific to Cat\n    public void climb() {\n        System.out.println(name + " is climbing the tree!");\n    }\n\n    public void purr() {\n        System.out.println(name + " is purring contentedly");\n    }\n\n    public void useLife() {\n        if (livesRemaining > 0) {\n            livesRemaining--;\n            System.out.println(name + " used a life! Lives remaining: " + livesRemaining);\n        }\n    }\n\n    @Override\n    public void displayInfo() {\n        super.displayInfo(); // Call parent method\n        System.out.println("Indoor Cat: " + (isIndoor ? "Yes" : "No"));\n        System.out.println("Lives Remaining: " + livesRemaining);\n    }\n\n    public boolean isIndoor() { return isIndoor; }\n    public int getLivesRemaining() { return livesRemaining; }\n}\n\npublic class InheritanceDemo {\n    public static void main(String[] args) {\n        System.out.println("=== Creating Animals ===\\n");\n\n        // Creating different animals\n        Animal genericAnimal = new Animal("Generic", 5, "Unknown");\n        Dog dog = new Dog("Buddy", 3, "Golden Retriever");\n        Cat cat = new Cat("Whiskers", 2, true);\n\n        System.out.println("\\n=== Animal Information ===\\n");\n\n        // Display all animals\n        Animal[] animals = {genericAnimal, dog, cat};\n\n        for (Animal animal : animals) {\n            System.out.println("--- " + animal.getClass().getSimpleName() + " ---");\n            animal.displayInfo();\n            animal.makeSound(); // Polymorphism in action\n            animal.eat();\n            animal.sleep();\n\n            // Type-specific behaviors\n            if (animal instanceof Dog) {\n                Dog d = (Dog) animal;\n                d.wagTail();\n                d.fetch();\n            } else if (animal instanceof Cat) {\n                Cat c = (Cat) animal;\n                c.purr();\n                c.climb();\n            }\n\n            System.out.println();\n        }\n\n        System.out.println("=== Demonstrating Method Overriding ===\\n");\n        dog.makeSound();  // Calls Dog\'s version\n        cat.makeSound();  // Calls Cat\'s version\n        genericAnimal.makeSound(); // Calls Animal\'s version\n    }\n}\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"polymorphism",children:"Polymorphism"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Polymorphism"}),' means "many forms". It allows objects of different types to be treated as objects of a common base type, while still maintaining their specific behaviors.']}),"\n",(0,i.jsx)(e.h3,{id:"types-of-polymorphism",children:"Types of Polymorphism"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Compile-time Polymorphism"})," - Method Overloading"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Runtime Polymorphism"})," - Method Overriding"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"runtime-polymorphism-example",children:"Runtime Polymorphism Example"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'// Base class\npublic abstract class Shape {\n    protected String color;\n    protected boolean filled;\n\n    public Shape(String color, boolean filled) {\n        this.color = color;\n        this.filled = filled;\n    }\n\n    // Abstract method - must be implemented by subclasses\n    public abstract double getArea();\n    public abstract double getPerimeter();\n    public abstract void draw();\n\n    // Concrete method\n    public void displayInfo() {\n        System.out.println("Color: " + color);\n        System.out.println("Filled: " + (filled ? "Yes" : "No"));\n        System.out.printf("Area: %.2f%n", getArea());\n        System.out.printf("Perimeter: %.2f%n", getPerimeter());\n    }\n\n    // Getters and setters\n    public String getColor() { return color; }\n    public boolean isFilled() { return filled; }\n    public void setColor(String color) { this.color = color; }\n    public void setFilled(boolean filled) { this.filled = filled; }\n}\n\n// Derived class 1\npublic class Circle extends Shape {\n    private double radius;\n\n    public Circle(String color, boolean filled, double radius) {\n        super(color, filled);\n        this.radius = radius;\n    }\n\n    @Override\n    public double getArea() {\n        return Math.PI * radius * radius;\n    }\n\n    @Override\n    public double getPerimeter() {\n        return 2 * Math.PI * radius;\n    }\n\n    @Override\n    public void draw() {\n        System.out.println("Drawing a " + color + " circle with radius " + radius);\n    }\n\n    @Override\n    public void displayInfo() {\n        System.out.println("=== Circle ===");\n        System.out.println("Radius: " + radius);\n        super.displayInfo();\n    }\n\n    public double getRadius() { return radius; }\n    public void setRadius(double radius) { this.radius = radius; }\n}\n\n// Derived class 2\npublic class Rectangle extends Shape {\n    private double length;\n    private double width;\n\n    public Rectangle(String color, boolean filled, double length, double width) {\n        super(color, filled);\n        this.length = length;\n        this.width = width;\n    }\n\n    @Override\n    public double getArea() {\n        return length * width;\n    }\n\n    @Override\n    public double getPerimeter() {\n        return 2 * (length + width);\n    }\n\n    @Override\n    public void draw() {\n        System.out.println("Drawing a " + color + " rectangle " + length + "x" + width);\n    }\n\n    @Override\n    public void displayInfo() {\n        System.out.println("=== Rectangle ===");\n        System.out.println("Length: " + length);\n        System.out.println("Width: " + width);\n        super.displayInfo();\n    }\n\n    public double getLength() { return length; }\n    public double getWidth() { return width; }\n}\n\n// Derived class 3\npublic class Triangle extends Shape {\n    private double side1, side2, side3;\n\n    public Triangle(String color, boolean filled, double side1, double side2, double side3) {\n        super(color, filled);\n        this.side1 = side1;\n        this.side2 = side2;\n        this.side3 = side3;\n    }\n\n    @Override\n    public double getArea() {\n        // Using Heron\'s formula\n        double s = getPerimeter() / 2;\n        return Math.sqrt(s * (s - side1) * (s - side2) * (s - side3));\n    }\n\n    @Override\n    public double getPerimeter() {\n        return side1 + side2 + side3;\n    }\n\n    @Override\n    public void draw() {\n        System.out.println("Drawing a " + color + " triangle with sides " +\n                          side1 + ", " + side2 + ", " + side3);\n    }\n\n    @Override\n    public void displayInfo() {\n        System.out.println("=== Triangle ===");\n        System.out.println("Sides: " + side1 + ", " + side2 + ", " + side3);\n        super.displayInfo();\n    }\n\n    public double getSide1() { return side1; }\n    public double getSide2() { return side2; }\n    public double getSide3() { return side3; }\n}\n\n// Utility class to demonstrate polymorphism\npublic class ShapeCalculator {\n\n    // Method that works with any Shape (polymorphism)\n    public static void processShape(Shape shape) {\n        shape.displayInfo();\n        shape.draw();\n        System.out.println("Processing completed.\\n");\n    }\n\n    // Method to calculate total area of multiple shapes\n    public static double calculateTotalArea(Shape[] shapes) {\n        double totalArea = 0;\n        System.out.println("=== Calculating Total Area ===");\n\n        for (Shape shape : shapes) {\n            double area = shape.getArea(); // Polymorphic method call\n            System.out.printf("%s area: %.2f%n",\n                             shape.getClass().getSimpleName(), area);\n            totalArea += area;\n        }\n\n        return totalArea;\n    }\n\n    // Method to find the largest shape by area\n    public static Shape findLargestShape(Shape[] shapes) {\n        if (shapes == null || shapes.length == 0) return null;\n\n        Shape largest = shapes[0];\n        for (Shape shape : shapes) {\n            if (shape.getArea() > largest.getArea()) {\n                largest = shape;\n            }\n        }\n        return largest;\n    }\n}\n\npublic class PolymorphismDemo {\n    public static void main(String[] args) {\n        System.out.println("=== Polymorphism Demo ===\\n");\n\n        // Creating different shapes\n        Shape[] shapes = {\n            new Circle("Red", true, 5.0),\n            new Rectangle("Blue", false, 4.0, 6.0),\n            new Triangle("Green", true, 3.0, 4.0, 5.0),\n            new Circle("Yellow", true, 3.0),\n            new Rectangle("Purple", true, 2.5, 8.0)\n        };\n\n        // Polymorphism in action - same method works with all shapes\n        System.out.println("=== Processing All Shapes ===\\n");\n        for (Shape shape : shapes) {\n            ShapeCalculator.processShape(shape); // Polymorphic method call\n        }\n\n        // Calculate total area\n        double totalArea = ShapeCalculator.calculateTotalArea(shapes);\n        System.out.printf("Total area of all shapes: %.2f%n\\n", totalArea);\n\n        // Find largest shape\n        Shape largest = ShapeCalculator.findLargestShape(shapes);\n        if (largest != null) {\n            System.out.println("=== Largest Shape ===");\n            largest.displayInfo();\n        }\n\n        // Demonstrating runtime type checking\n        System.out.println("=== Runtime Type Information ===");\n        for (int i = 0; i < shapes.length; i++) {\n            Shape shape = shapes[i];\n            System.out.printf("Shape %d is a %s%n", i + 1, shape.getClass().getSimpleName());\n\n            // Type-specific operations using instanceof\n            if (shape instanceof Circle) {\n                Circle circle = (Circle) shape;\n                System.out.println("  Radius: " + circle.getRadius());\n            } else if (shape instanceof Rectangle) {\n                Rectangle rectangle = (Rectangle) shape;\n                System.out.println("  Dimensions: " + rectangle.getLength() +\n                                 " x " + rectangle.getWidth());\n            } else if (shape instanceof Triangle) {\n                Triangle triangle = (Triangle) shape;\n                System.out.println("  Sides: " + triangle.getSide1() +\n                                 ", " + triangle.getSide2() +\n                                 ", " + triangle.getSide3());\n            }\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"method-overloading-compile-time-polymorphism",children:"Method Overloading (Compile-time Polymorphism)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'public class Calculator {\n\n    // Method overloading - same name, different parameters\n    public int add(int a, int b) {\n        System.out.println("Adding two integers");\n        return a + b;\n    }\n\n    public double add(double a, double b) {\n        System.out.println("Adding two doubles");\n        return a + b;\n    }\n\n    public int add(int a, int b, int c) {\n        System.out.println("Adding three integers");\n        return a + b + c;\n    }\n\n    public String add(String a, String b) {\n        System.out.println("Concatenating two strings");\n        return a + b;\n    }\n\n    // Variable arguments (varargs)\n    public int add(int... numbers) {\n        System.out.println("Adding " + numbers.length + " integers using varargs");\n        int sum = 0;\n        for (int num : numbers) {\n            sum += num;\n        }\n        return sum;\n    }\n\n    // Different parameter order\n    public void display(String message, int number) {\n        System.out.println("Message: " + message + ", Number: " + number);\n    }\n\n    public void display(int number, String message) {\n        System.out.println("Number: " + number + ", Message: " + message);\n    }\n}\n\npublic class OverloadingDemo {\n    public static void main(String[] args) {\n        Calculator calc = new Calculator();\n\n        System.out.println("=== Method Overloading Demo ===\\n");\n\n        // Different methods will be called based on arguments\n        System.out.println("Result: " + calc.add(5, 3));                    // int version\n        System.out.println("Result: " + calc.add(5.5, 3.2));               // double version\n        System.out.println("Result: " + calc.add(1, 2, 3));                // three int version\n        System.out.println("Result: " + calc.add("Hello", " World"));       // String version\n        System.out.println("Result: " + calc.add(1, 2, 3, 4, 5));         // varargs version\n\n        System.out.println();\n        calc.display("Test", 100);        // String, int version\n        calc.display(200, "Message");     // int, String version\n    }\n}\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"abstraction",children:"Abstraction"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Abstraction"})," is the process of hiding implementation details and showing only the functionality to the user. In Java, abstraction is achieved using abstract classes and interfaces."]}),"\n",(0,i.jsx)(e.h3,{id:"abstract-classes",children:"Abstract Classes"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'// Abstract class - cannot be instantiated directly\npublic abstract class Employee {\n    protected String name;\n    protected int id;\n    protected String department;\n    protected double baseSalary;\n\n    // Constructor in abstract class\n    public Employee(String name, int id, String department, double baseSalary) {\n        this.name = name;\n        this.id = id;\n        this.department = department;\n        this.baseSalary = baseSalary;\n    }\n\n    // Concrete methods (implemented)\n    public void displayBasicInfo() {\n        System.out.println("Name: " + name);\n        System.out.println("ID: " + id);\n        System.out.println("Department: " + department);\n        System.out.println("Base Salary: $" + baseSalary);\n    }\n\n    public void clockIn() {\n        System.out.println(name + " has clocked in");\n    }\n\n    public void clockOut() {\n        System.out.println(name + " has clocked out");\n    }\n\n    // Abstract methods (must be implemented by subclasses)\n    public abstract double calculateSalary();\n    public abstract void performDuties();\n    public abstract String getEmployeeType();\n    public abstract double calculateBonus(double performanceRating);\n\n    // Getters\n    public String getName() { return name; }\n    public int getId() { return id; }\n    public String getDepartment() { return department; }\n    public double getBaseSalary() { return baseSalary; }\n}\n\n// Concrete subclass 1\npublic class FullTimeEmployee extends Employee {\n    private double benefits;\n    private int vacationDays;\n\n    public FullTimeEmployee(String name, int id, String department,\n                           double baseSalary, double benefits) {\n        super(name, id, department, baseSalary);\n        this.benefits = benefits;\n        this.vacationDays = 20; // Standard vacation days\n    }\n\n    @Override\n    public double calculateSalary() {\n        return baseSalary + benefits;\n    }\n\n    @Override\n    public void performDuties() {\n        System.out.println(name + " is working full-time duties in " + department);\n    }\n\n    @Override\n    public String getEmployeeType() {\n        return "Full-Time Employee";\n    }\n\n    @Override\n    public double calculateBonus(double performanceRating) {\n        // Full-time employees get bonus based on performance\n        if (performanceRating >= 4.0) {\n            return baseSalary * 0.15; // 15% bonus for excellent performance\n        } else if (performanceRating >= 3.0) {\n            return baseSalary * 0.10; // 10% bonus for good performance\n        } else {\n            return baseSalary * 0.05; // 5% bonus for satisfactory performance\n        }\n    }\n\n    public void takeVacation(int days) {\n        if (days <= vacationDays) {\n            vacationDays -= days;\n            System.out.println(name + " took " + days + " vacation days. Remaining: " + vacationDays);\n        } else {\n            System.out.println("Not enough vacation days available");\n        }\n    }\n\n    @Override\n    public void displayBasicInfo() {\n        super.displayBasicInfo();\n        System.out.println("Benefits: $" + benefits);\n        System.out.println("Vacation Days: " + vacationDays);\n        System.out.println("Total Salary: $" + calculateSalary());\n    }\n}\n\n// Concrete subclass 2\npublic class PartTimeEmployee extends Employee {\n    private int hoursWorked;\n    private double hourlyRate;\n\n    public PartTimeEmployee(String name, int id, String department, double hourlyRate) {\n        super(name, id, department, 0); // No base salary for part-time\n        this.hourlyRate = hourlyRate;\n        this.hoursWorked = 0;\n    }\n\n    @Override\n    public double calculateSalary() {\n        return hoursWorked * hourlyRate;\n    }\n\n    @Override\n    public void performDuties() {\n        System.out.println(name + " is working part-time duties in " + department);\n    }\n\n    @Override\n    public String getEmployeeType() {\n        return "Part-Time Employee";\n    }\n\n    @Override\n    public double calculateBonus(double performanceRating) {\n        // Part-time employees get smaller bonuses\n        if (performanceRating >= 4.0) {\n            return calculateSalary() * 0.05; // 5% bonus\n        } else if (performanceRating >= 3.0) {\n            return calculateSalary() * 0.03; // 3% bonus\n        } else {\n            return 0; // No bonus for poor performance\n        }\n    }\n\n    public void logHours(int hours) {\n        hoursWorked += hours;\n        System.out.println(name + " logged " + hours + " hours. Total: " + hoursWorked);\n    }\n\n    @Override\n    public void displayBasicInfo() {\n        super.displayBasicInfo();\n        System.out.println("Hourly Rate: $" + hourlyRate);\n        System.out.println("Hours Worked: " + hoursWorked);\n        System.out.println("Total Salary: $" + calculateSalary());\n    }\n}\n\npublic class AbstractionDemo {\n    public static void main(String[] args) {\n        System.out.println("=== Employee Management System ===\\n");\n\n        // Create different types of employees\n        Employee[] employees = {\n            new FullTimeEmployee("Alice Johnson", 101, "Engineering", 80000, 15000),\n            new PartTimeEmployee("Bob Smith", 102, "Marketing", 25.0)\n        };\n\n        // Set up some data\n        ((PartTimeEmployee)employees[1]).logHours(120);\n\n        System.out.println("=== Employee Information ===\\n");\n\n        // Polymorphism with abstract class\n        for (Employee emp : employees) {\n            System.out.println("--- " + emp.getEmployeeType() + " ---");\n            emp.displayBasicInfo();\n            emp.performDuties();\n\n            double bonus = emp.calculateBonus(3.8); // Good performance rating\n            System.out.println("Performance Bonus: $" + bonus);\n\n            emp.clockIn();\n            emp.clockOut();\n            System.out.println();\n        }\n\n        // Demonstrate abstraction - we can work with Employee type\n        // without knowing specific implementation details\n        System.out.println("=== Payroll Summary ===");\n        double totalPayroll = 0;\n\n        for (Employee emp : employees) {\n            double salary = emp.calculateSalary(); // Abstract method called\n            totalPayroll += salary;\n            System.out.printf("%s (%s): $%.2f%n",\n                             emp.getName(), emp.getEmployeeType(), salary);\n        }\n\n        System.out.printf("Total Monthly Payroll: $%.2f%n", totalPayroll);\n    }\n}\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"interfaces",children:"Interfaces"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Interfaces"})," define a contract that implementing classes must follow. They contain method signatures (and from Java 8+, default and static methods) but no implementation details."]}),"\n",(0,i.jsx)(e.h3,{id:"basic-interface-example",children:"Basic Interface Example"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'// Interface definition\npublic interface Drawable {\n    // Public, static, final by default\n    String DEFAULT_COLOR = "Black";\n    int MAX_SIZE = 1000;\n\n    // Abstract methods (public abstract by default)\n    void draw();\n    void resize(double factor);\n    void setColor(String color);\n    String getColor();\n\n    // Default method (Java 8+) - provides default implementation\n    default void display() {\n        System.out.println("Displaying drawable object with color: " + getColor());\n    }\n\n    // Static method (Java 8+)\n    static void printInfo() {\n        System.out.println("Drawable interface - defines drawing contract");\n    }\n}\n\n// Another interface\npublic interface Movable {\n    void move(int x, int y);\n    void rotate(double angle);\n\n    default void reset() {\n        move(0, 0);\n        rotate(0);\n        System.out.println("Position and rotation reset");\n    }\n}\n\n// Interface for mathematical operations\npublic interface Calculable {\n    double getArea();\n    double getPerimeter();\n\n    default void printCalculations() {\n        System.out.printf("Area: %.2f, Perimeter: %.2f%n", getArea(), getPerimeter());\n    }\n}\n\n// Class implementing multiple interfaces\npublic class Rectangle implements Drawable, Movable, Calculable {\n    private double width, height;\n    private String color;\n    private int x, y;\n    private double rotationAngle;\n\n    public Rectangle(double width, double height) {\n        this.width = width;\n        this.height = height;\n        this.color = Drawable.DEFAULT_COLOR;\n        this.x = 0;\n        this.y = 0;\n        this.rotationAngle = 0;\n    }\n\n    // Implementing Drawable interface\n    @Override\n    public void draw() {\n        System.out.printf("Drawing a %s rectangle %.1fx%.1f at (%d,%d) rotated %.1f\xb0%n",\n                         color, width, height, x, y, rotationAngle);\n    }\n\n    @Override\n    public void resize(double factor) {\n        width *= factor;\n        height *= factor;\n        System.out.printf("Rectangle resized by factor %.2f. New size: %.1fx%.1f%n",\n                         factor, width, height);\n    }\n\n    @Override\n    public void setColor(String color) {\n        this.color = color;\n    }\n\n    @Override\n    public String getColor() {\n        return color;\n    }\n\n    // Implementing Movable interface\n    @Override\n    public void move(int x, int y) {\n        this.x = x;\n        this.y = y;\n        System.out.println("Rectangle moved to position (" + x + ", " + y + ")");\n    }\n\n    @Override\n    public void rotate(double angle) {\n        this.rotationAngle = angle;\n        System.out.println("Rectangle rotated to " + angle + " degrees");\n    }\n\n    // Implementing Calculable interface\n    @Override\n    public double getArea() {\n        return width * height;\n    }\n\n    @Override\n    public double getPerimeter() {\n        return 2 * (width + height);\n    }\n\n    public double getWidth() { return width; }\n    public double getHeight() { return height; }\n}\n\npublic class InterfaceDemo {\n    public static void main(String[] args) {\n        System.out.println("=== Interface Implementation Demo ===\\n");\n\n        // Using static method from interface\n        Drawable.printInfo();\n        System.out.println();\n\n        // Creating objects\n        Rectangle rectangle = new Rectangle(4.0, 6.0);\n        rectangle.setColor("Blue");\n\n        System.out.println("=== Drawing Objects ===");\n        rectangle.draw();\n\n        System.out.println("\\n=== Using Default Methods ===");\n        rectangle.display(); // Default method from Drawable\n\n        System.out.println("\\n=== Calculations ===");\n        rectangle.printCalculations(); // Default method from Calculable\n\n        System.out.println("\\n=== Resizing Objects ===");\n        rectangle.resize(0.8);\n\n        System.out.println("\\n=== Moving Rectangle ===");\n        rectangle.move(10, 20);\n        rectangle.rotate(45.0);\n        rectangle.draw();\n\n        rectangle.reset(); // Default method from Movable\n        rectangle.draw();\n\n        // Polymorphism with interfaces\n        System.out.println("\\n=== Interface Polymorphism ===");\n        Drawable drawable = rectangle;\n        Movable movable = rectangle;\n        Calculable calculable = rectangle;\n\n        drawable.draw();\n        movable.move(50, 30);\n        System.out.println("Area through Calculable reference: " + calculable.getArea());\n    }\n}\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"access-modifiers",children:"Access Modifiers"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Access modifiers"})," control the visibility and accessibility of classes, methods, and variables."]}),"\n",(0,i.jsx)(e.h3,{id:"four-access-modifiers",children:"Four Access Modifiers"}),"\n",(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:"Modifier"}),(0,i.jsx)(e.th,{children:"Same Class"}),(0,i.jsx)(e.th,{children:"Same Package"}),(0,i.jsx)(e.th,{children:"Subclass"}),(0,i.jsx)(e.th,{children:"Different Package"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.code,{children:"private"})}),(0,i.jsx)(e.td,{children:"\u2713"}),(0,i.jsx)(e.td,{children:"\u2717"}),(0,i.jsx)(e.td,{children:"\u2717"}),(0,i.jsx)(e.td,{children:"\u2717"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsxs)(e.td,{children:[(0,i.jsx)(e.code,{children:"default"})," (package-private)"]}),(0,i.jsx)(e.td,{children:"\u2713"}),(0,i.jsx)(e.td,{children:"\u2713"}),(0,i.jsx)(e.td,{children:"\u2717"}),(0,i.jsx)(e.td,{children:"\u2717"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.code,{children:"protected"})}),(0,i.jsx)(e.td,{children:"\u2713"}),(0,i.jsx)(e.td,{children:"\u2713"}),(0,i.jsx)(e.td,{children:"\u2713"}),(0,i.jsx)(e.td,{children:"\u2717"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.code,{children:"public"})}),(0,i.jsx)(e.td,{children:"\u2713"}),(0,i.jsx)(e.td,{children:"\u2713"}),(0,i.jsx)(e.td,{children:"\u2713"}),(0,i.jsx)(e.td,{children:"\u2713"})]})]})]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'public class AccessModifierDemo {\n    // Private - only accessible within this class\n    private String privateField = "Private field";\n\n    // Package-private (default) - accessible within same package\n    String packageField = "Package field";\n\n    // Protected - accessible within package and by subclasses\n    protected String protectedField = "Protected field";\n\n    // Public - accessible from anywhere\n    public String publicField = "Public field";\n\n    // Private method\n    private void privateMethod() {\n        System.out.println("Private method called");\n    }\n\n    // Package-private method\n    void packageMethod() {\n        System.out.println("Package method called");\n    }\n\n    // Protected method\n    protected void protectedMethod() {\n        System.out.println("Protected method called");\n    }\n\n    // Public method\n    public void publicMethod() {\n        System.out.println("Public method called");\n    }\n\n    // Public method that can access all members of same class\n    public void accessAllMembers() {\n        System.out.println("=== Accessing from Same Class ===");\n        System.out.println(privateField);     // \u2713 Accessible\n        System.out.println(packageField);     // \u2713 Accessible\n        System.out.println(protectedField);   // \u2713 Accessible\n        System.out.println(publicField);      // \u2713 Accessible\n\n        privateMethod();    // \u2713 Accessible\n        packageMethod();    // \u2713 Accessible\n        protectedMethod();  // \u2713 Accessible\n        publicMethod();     // \u2713 Accessible\n    }\n}\n\n// Same package class\nclass SamePackageClass {\n    public void testAccess() {\n        System.out.println("=== Accessing from Same Package Class ===");\n        AccessModifierDemo demo = new AccessModifierDemo();\n\n        // System.out.println(demo.privateField);   // \u2717 Compilation error\n        System.out.println(demo.packageField);      // \u2713 Accessible\n        System.out.println(demo.protectedField);    // \u2713 Accessible\n        System.out.println(demo.publicField);       // \u2713 Accessible\n\n        // demo.privateMethod();    // \u2717 Compilation error\n        demo.packageMethod();       // \u2713 Accessible\n        demo.protectedMethod();     // \u2713 Accessible\n        demo.publicMethod();        // \u2713 Accessible\n    }\n}\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"method-overloading-and-overriding",children:"Method Overloading and Overriding"}),"\n",(0,i.jsx)(e.h3,{id:"method-overloading-vs-method-overriding",children:"Method Overloading vs Method Overriding"}),"\n",(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:"Aspect"}),(0,i.jsx)(e.th,{children:"Overloading"}),(0,i.jsx)(e.th,{children:"Overriding"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Definition"})}),(0,i.jsx)(e.td,{children:"Multiple methods with same name, different parameters"}),(0,i.jsx)(e.td,{children:"Child class provides specific implementation of parent method"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Relationship"})}),(0,i.jsx)(e.td,{children:"Same class"}),(0,i.jsx)(e.td,{children:"Inheritance relationship"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Compile Time"})}),(0,i.jsx)(e.td,{children:"Resolved at compile time"}),(0,i.jsx)(e.td,{children:"Resolved at runtime"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Parameters"})}),(0,i.jsx)(e.td,{children:"Must be different"}),(0,i.jsx)(e.td,{children:"Must be same"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Return Type"})}),(0,i.jsx)(e.td,{children:"Can be different"}),(0,i.jsx)(e.td,{children:"Must be same (or covariant)"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Access Modifier"})}),(0,i.jsx)(e.td,{children:"Can be different"}),(0,i.jsx)(e.td,{children:"Cannot reduce visibility"})]})]})]}),"\n",(0,i.jsx)(e.h3,{id:"method-overriding-example",children:"Method Overriding Example"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'// Parent class\npublic class Vehicle {\n    protected String brand;\n    protected String model;\n    protected int year;\n\n    public Vehicle(String brand, String model, int year) {\n        this.brand = brand;\n        this.model = model;\n        this.year = year;\n    }\n\n    // Method to be overridden\n    public void start() {\n        System.out.println(brand + " " + model + " is starting...");\n    }\n\n    public void stop() {\n        System.out.println(brand + " " + model + " has stopped.");\n    }\n\n    // Final method - cannot be overridden\n    public final void displayInfo() {\n        System.out.println("Vehicle: " + brand + " " + model + " (" + year + ")");\n    }\n\n    public String getBrand() { return brand; }\n    public String getModel() { return model; }\n    public int getYear() { return year; }\n}\n\n// Child class demonstrating method overriding\npublic class ElectricCar extends Vehicle {\n    private int batteryCapacity;\n    private int currentCharge;\n\n    public ElectricCar(String brand, String model, int year, int batteryCapacity) {\n        super(brand, model, year);\n        this.batteryCapacity = batteryCapacity;\n        this.currentCharge = batteryCapacity;\n    }\n\n    // Method overriding with @Override annotation\n    @Override\n    public void start() {\n        if (currentCharge > 0) {\n            System.out.println("Electric " + brand + " " + model + " starting silently...");\n            System.out.println("Battery level: " + currentCharge + "/" + batteryCapacity);\n        } else {\n            System.out.println("Cannot start - battery is empty!");\n        }\n    }\n\n    @Override\n    public void stop() {\n        System.out.println("Electric " + brand + " " + model + " stopped. Regenerating energy...");\n        currentCharge = Math.min(batteryCapacity, currentCharge + 5);\n    }\n\n    public void charge() {\n        currentCharge = batteryCapacity;\n        System.out.println("Battery fully charged!");\n    }\n}\n\npublic class OverridingDemo {\n    public static void main(String[] args) {\n        System.out.println("=== Method Overriding Demo ===\\n");\n\n        Vehicle[] vehicles = {\n            new Vehicle("Generic", "Vehicle", 2020),\n            new ElectricCar("Tesla", "Model 3", 2023, 100)\n        };\n\n        for (Vehicle vehicle : vehicles) {\n            System.out.println("--- " + vehicle.getClass().getSimpleName() + " ---");\n            vehicle.displayInfo();  // Final method - same for all\n            vehicle.start();        // Overridden method - different behavior\n            vehicle.stop();         // Overridden method\n            System.out.println();\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"super-keyword",children:"Super Keyword"}),"\n",(0,i.jsxs)(e.p,{children:["The ",(0,i.jsx)(e.strong,{children:"super"})," keyword is used to access parent class members and constructors."]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'class Animal {\n    protected String name;\n    protected int age;\n\n    public Animal(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public void makeSound() {\n        System.out.println(name + " makes a sound");\n    }\n\n    public void displayInfo() {\n        System.out.println("Animal: " + name + ", Age: " + age);\n    }\n}\n\nclass Dog extends Animal {\n    private String breed;\n\n    public Dog(String name, int age, String breed) {\n        super(name, age); // Call parent constructor\n        this.breed = breed;\n    }\n\n    @Override\n    public void makeSound() {\n        super.makeSound(); // Call parent method first\n        System.out.println(name + " barks: Woof!");\n    }\n\n    @Override\n    public void displayInfo() {\n        super.displayInfo(); // Call parent method\n        System.out.println("Breed: " + breed);\n    }\n}\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"final-keyword",children:"Final Keyword"}),"\n",(0,i.jsxs)(e.p,{children:["The ",(0,i.jsx)(e.strong,{children:"final"})," keyword can be used with variables, methods, and classes."]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'// Final class - cannot be extended\npublic final class Constants {\n    // Final variables - cannot be changed\n    public static final double PI = 3.14159;\n    public static final String APP_NAME = "MyApp";\n\n    // Final instance variable - must be initialized\n    private final int id;\n\n    public Constants(int id) {\n        this.id = id; // Can only be set once\n    }\n\n    // Final method - cannot be overridden\n    public final void displayId() {\n        System.out.println("ID: " + id);\n    }\n}\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"practical-examples",children:"Practical Examples"}),"\n",(0,i.jsx)(e.h3,{id:"library-management-system",children:"Library Management System"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'// Abstract base class\nabstract class LibraryItem {\n    protected String title;\n    protected String author;\n    protected String id;\n    protected boolean isAvailable;\n\n    public LibraryItem(String title, String author, String id) {\n        this.title = title;\n        this.author = author;\n        this.id = id;\n        this.isAvailable = true;\n    }\n\n    public abstract void displayInfo();\n    public abstract double calculateLateFee(int daysLate);\n\n    public void checkout() {\n        if (isAvailable) {\n            isAvailable = false;\n            System.out.println(title + " has been checked out");\n        } else {\n            System.out.println(title + " is not available");\n        }\n    }\n\n    public void returnItem() {\n        isAvailable = true;\n        System.out.println(title + " has been returned");\n    }\n\n    // Getters\n    public String getTitle() { return title; }\n    public String getAuthor() { return author; }\n    public String getId() { return id; }\n    public boolean isAvailable() { return isAvailable; }\n}\n\nclass Book extends LibraryItem {\n    private int pages;\n    private String genre;\n\n    public Book(String title, String author, String id, int pages, String genre) {\n        super(title, author, id);\n        this.pages = pages;\n        this.genre = genre;\n    }\n\n    @Override\n    public void displayInfo() {\n        System.out.println("=== Book ===");\n        System.out.println("Title: " + title);\n        System.out.println("Author: " + author);\n        System.out.println("ID: " + id);\n        System.out.println("Pages: " + pages);\n        System.out.println("Genre: " + genre);\n        System.out.println("Available: " + (isAvailable ? "Yes" : "No"));\n    }\n\n    @Override\n    public double calculateLateFee(int daysLate) {\n        return daysLate * 0.50; // $0.50 per day\n    }\n}\n\nclass DVD extends LibraryItem {\n    private int duration; // in minutes\n    private String rating;\n\n    public DVD(String title, String author, String id, int duration, String rating) {\n        super(title, author, id);\n        this.duration = duration;\n        this.rating = rating;\n    }\n\n    @Override\n    public void displayInfo() {\n        System.out.println("=== DVD ===");\n        System.out.println("Title: " + title);\n        System.out.println("Director: " + author);\n        System.out.println("ID: " + id);\n        System.out.println("Duration: " + duration + " minutes");\n        System.out.println("Rating: " + rating);\n        System.out.println("Available: " + (isAvailable ? "Yes" : "No"));\n    }\n\n    @Override\n    public double calculateLateFee(int daysLate) {\n        return daysLate * 1.00; // $1.00 per day\n    }\n}\n\nclass Magazine extends LibraryItem {\n    private String issueDate;\n    private int issueNumber;\n\n    public Magazine(String title, String author, String id, String issueDate, int issueNumber) {\n        super(title, author, id);\n        this.issueDate = issueDate;\n        this.issueNumber = issueNumber;\n    }\n\n    @Override\n    public void displayInfo() {\n        System.out.println("=== Magazine ===");\n        System.out.println("Title: " + title);\n        System.out.println("Publisher: " + author);\n        System.out.println("ID: " + id);\n        System.out.println("Issue Date: " + issueDate);\n        System.out.println("Issue Number: " + issueNumber);\n        System.out.println("Available: " + (isAvailable ? "Yes" : "No"));\n    }\n\n    @Override\n    public double calculateLateFee(int daysLate) {\n        return daysLate * 0.25; // $0.25 per day\n    }\n}\n\n// Library class to manage items\nclass Library {\n    private LibraryItem[] items;\n    private int itemCount;\n    private static final int MAX_ITEMS = 1000;\n\n    public Library() {\n        items = new LibraryItem[MAX_ITEMS];\n        itemCount = 0;\n    }\n\n    public void addItem(LibraryItem item) {\n        if (itemCount < MAX_ITEMS) {\n            items[itemCount] = item;\n            itemCount++;\n            System.out.println("Added: " + item.getTitle());\n        } else {\n            System.out.println("Library is full!");\n        }\n    }\n\n    public void displayAllItems() {\n        System.out.println("\\n=== Library Catalog ===");\n        for (int i = 0; i < itemCount; i++) {\n            items[i].displayInfo();\n            System.out.println();\n        }\n    }\n\n    public LibraryItem findItem(String id) {\n        for (int i = 0; i < itemCount; i++) {\n            if (items[i].getId().equals(id)) {\n                return items[i];\n            }\n        }\n        return null;\n    }\n\n    public void checkoutItem(String id) {\n        LibraryItem item = findItem(id);\n        if (item != null) {\n            item.checkout();\n        } else {\n            System.out.println("Item with ID " + id + " not found");\n        }\n    }\n\n    public void returnItem(String id, int daysLate) {\n        LibraryItem item = findItem(id);\n        if (item != null) {\n            item.returnItem();\n            if (daysLate > 0) {\n                double fee = item.calculateLateFee(daysLate);\n                System.out.printf("Late fee: $%.2f%n", fee);\n            }\n        } else {\n            System.out.println("Item with ID " + id + " not found");\n        }\n    }\n\n    public void displayAvailableItems() {\n        System.out.println("\\n=== Available Items ===");\n        boolean hasAvailable = false;\n        for (int i = 0; i < itemCount; i++) {\n            if (items[i].isAvailable()) {\n                System.out.println(items[i].getTitle() + " (ID: " + items[i].getId() + ")");\n                hasAvailable = true;\n            }\n        }\n        if (!hasAvailable) {\n            System.out.println("No items available");\n        }\n    }\n}\n\npublic class LibraryManagementDemo {\n    public static void main(String[] args) {\n        System.out.println("=== Library Management System ===\\n");\n\n        Library library = new Library();\n\n        // Adding different types of items\n        library.addItem(new Book("Java: The Complete Reference", "Herbert Schildt", "B001", 1200, "Programming"));\n        library.addItem(new Book("Clean Code", "Robert Martin", "B002", 464, "Programming"));\n        library.addItem(new DVD("The Matrix", "Wachowski Sisters", "D001", 136, "R"));\n        library.addItem(new DVD("Inception", "Christopher Nolan", "D002", 148, "PG-13"));\n        library.addItem(new Magazine("National Geographic", "National Geographic Society", "M001", "January 2024", 1));\n        library.addItem(new Magazine("Time", "Time USA", "M002", "February 2024", 2));\n\n        // Display all items\n        library.displayAllItems();\n\n        // Display available items\n        library.displayAvailableItems();\n\n        // Checkout some items\n        System.out.println("\\n=== Checkout Operations ===");\n        library.checkoutItem("B001");\n        library.checkoutItem("D001");\n        library.checkoutItem("M001");\n\n        // Display available items after checkout\n        library.displayAvailableItems();\n\n        // Return items with late fees\n        System.out.println("\\n=== Return Operations ===");\n        library.returnItem("B001", 5);  // 5 days late\n        library.returnItem("D001", 3);  // 3 days late\n        library.returnItem("M001", 0);  // On time\n\n        // Display available items after return\n        library.displayAvailableItems();\n    }\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"online-shopping-system",children:"Online Shopping System"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'// Interface for payment processing\ninterface PaymentProcessor {\n    boolean processPayment(double amount);\n    String getPaymentMethod();\n}\n\n// Concrete payment implementations\nclass CreditCardPayment implements PaymentProcessor {\n    private String cardNumber;\n    private String cardHolder;\n\n    public CreditCardPayment(String cardNumber, String cardHolder) {\n        this.cardNumber = cardNumber;\n        this.cardHolder = cardHolder;\n    }\n\n    @Override\n    public boolean processPayment(double amount) {\n        System.out.printf("Processing credit card payment of $%.2f for %s%n", amount, cardHolder);\n        System.out.println("Card ending in: " + cardNumber.substring(cardNumber.length() - 4));\n        return true; // Assume payment successful\n    }\n\n    @Override\n    public String getPaymentMethod() {\n        return "Credit Card";\n    }\n}\n\nclass PayPalPayment implements PaymentProcessor {\n    private String email;\n\n    public PayPalPayment(String email) {\n        this.email = email;\n    }\n\n    @Override\n    public boolean processPayment(double amount) {\n        System.out.printf("Processing PayPal payment of $%.2f for %s%n", amount, email);\n        return true; // Assume payment successful\n    }\n\n    @Override\n    public String getPaymentMethod() {\n        return "PayPal";\n    }\n}\n\n// Abstract product class\nabstract class Product {\n    protected String name;\n    protected double price;\n    protected String category;\n    protected int stockQuantity;\n\n    public Product(String name, double price, String category, int stockQuantity) {\n        this.name = name;\n        this.price = price;\n        this.category = category;\n        this.stockQuantity = stockQuantity;\n    }\n\n    public abstract void displayProductInfo();\n    public abstract double calculateShippingCost();\n\n    public boolean isInStock() {\n        return stockQuantity > 0;\n    }\n\n    public void reduceStock(int quantity) {\n        if (stockQuantity >= quantity) {\n            stockQuantity -= quantity;\n        } else {\n            throw new IllegalArgumentException("Insufficient stock");\n        }\n    }\n\n    // Getters\n    public String getName() { return name; }\n    public double getPrice() { return price; }\n    public String getCategory() { return category; }\n    public int getStockQuantity() { return stockQuantity; }\n}\n\nclass Electronics extends Product {\n    private int warrantyMonths;\n    private String brand;\n\n    public Electronics(String name, double price, int stockQuantity, int warrantyMonths, String brand) {\n        super(name, price, "Electronics", stockQuantity);\n        this.warrantyMonths = warrantyMonths;\n        this.brand = brand;\n    }\n\n    @Override\n    public void displayProductInfo() {\n        System.out.println("=== Electronics ===");\n        System.out.println("Name: " + name);\n        System.out.println("Brand: " + brand);\n        System.out.printf("Price: $%.2f%n", price);\n        System.out.println("Warranty: " + warrantyMonths + " months");\n        System.out.println("Stock: " + stockQuantity);\n    }\n\n    @Override\n    public double calculateShippingCost() {\n        return price > 100 ? 0.0 : 9.99; // Free shipping for expensive electronics\n    }\n}\n\nclass Clothing extends Product {\n    private String size;\n    private String color;\n\n    public Clothing(String name, double price, int stockQuantity, String size, String color) {\n        super(name, price, "Clothing", stockQuantity);\n        this.size = size;\n        this.color = color;\n    }\n\n    @Override\n    public void displayProductInfo() {\n        System.out.println("=== Clothing ===");\n        System.out.println("Name: " + name);\n        System.out.println("Size: " + size);\n        System.out.println("Color: " + color);\n        System.out.printf("Price: $%.2f%n", price);\n        System.out.println("Stock: " + stockQuantity);\n    }\n\n    @Override\n    public double calculateShippingCost() {\n        return 4.99; // Standard shipping for clothing\n    }\n}\n\n// Shopping cart item\nclass CartItem {\n    private Product product;\n    private int quantity;\n\n    public CartItem(Product product, int quantity) {\n        this.product = product;\n        this.quantity = quantity;\n    }\n\n    public double getTotalPrice() {\n        return product.getPrice() * quantity;\n    }\n\n    public double getShippingCost() {\n        return product.calculateShippingCost();\n    }\n\n    public Product getProduct() { return product; }\n    public int getQuantity() { return quantity; }\n}\n\n// Shopping cart\nclass ShoppingCart {\n    private CartItem[] items;\n    private int itemCount;\n    private static final int MAX_ITEMS = 100;\n\n    public ShoppingCart() {\n        items = new CartItem[MAX_ITEMS];\n        itemCount = 0;\n    }\n\n    public void addItem(Product product, int quantity) {\n        if (!product.isInStock()) {\n            System.out.println("Product not in stock: " + product.getName());\n            return;\n        }\n\n        if (product.getStockQuantity() < quantity) {\n            System.out.println("Insufficient stock for: " + product.getName());\n            return;\n        }\n\n        if (itemCount < MAX_ITEMS) {\n            items[itemCount] = new CartItem(product, quantity);\n            itemCount++;\n            System.out.println("Added to cart: " + product.getName() + " (Quantity: " + quantity + ")");\n        } else {\n            System.out.println("Cart is full!");\n        }\n    }\n\n    public double calculateSubtotal() {\n        double subtotal = 0;\n        for (int i = 0; i < itemCount; i++) {\n            subtotal += items[i].getTotalPrice();\n        }\n        return subtotal;\n    }\n\n    public double calculateShipping() {\n        double shipping = 0;\n        for (int i = 0; i < itemCount; i++) {\n            shipping += items[i].getShippingCost();\n        }\n        return shipping;\n    }\n\n    public double calculateTotal() {\n        return calculateSubtotal() + calculateShipping();\n    }\n\n    public void displayCart() {\n        System.out.println("\\n=== Shopping Cart ===");\n        if (itemCount == 0) {\n            System.out.println("Cart is empty");\n            return;\n        }\n\n        for (int i = 0; i < itemCount; i++) {\n            CartItem item = items[i];\n            System.out.printf("%s - Quantity: %d - Price: $%.2f%n",\n                             item.getProduct().getName(),\n                             item.getQuantity(),\n                             item.getTotalPrice());\n        }\n\n        System.out.printf("Subtotal: $%.2f%n", calculateSubtotal());\n        System.out.printf("Shipping: $%.2f%n", calculateShipping());\n        System.out.printf("Total: $%.2f%n", calculateTotal());\n    }\n\n    public boolean checkout(PaymentProcessor paymentProcessor) {\n        if (itemCount == 0) {\n            System.out.println("Cannot checkout - cart is empty");\n            return false;\n        }\n\n        double total = calculateTotal();\n        System.out.println("\\n=== Checkout ===");\n        System.out.printf("Total amount: $%.2f%n", total);\n        System.out.println("Payment method: " + paymentProcessor.getPaymentMethod());\n\n        boolean paymentSuccess = paymentProcessor.processPayment(total);\n\n        if (paymentSuccess) {\n            // Reduce stock for all items\n            for (int i = 0; i < itemCount; i++) {\n                CartItem item = items[i];\n                item.getProduct().reduceStock(item.getQuantity());\n            }\n\n            System.out.println("Order placed successfully!");\n            clearCart();\n            return true;\n        } else {\n            System.out.println("Payment failed. Please try again.");\n            return false;\n        }\n    }\n\n    private void clearCart() {\n        itemCount = 0;\n        System.out.println("Cart cleared.");\n    }\n\n    public int getItemCount() { return itemCount; }\n}\n\npublic class OnlineShoppingDemo {\n    public static void main(String[] args) {\n        System.out.println("=== Online Shopping System ===\\n");\n\n        // Create products\n        Product laptop = new Electronics("Gaming Laptop", 1299.99, 5, 24, "Dell");\n        Product phone = new Electronics("Smartphone", 799.99, 10, 12, "Apple");\n        Product shirt = new Clothing("Cotton T-Shirt", 29.99, 20, "L", "Blue");\n        Product jeans = new Clothing("Denim Jeans", 79.99, 15, "32", "Black");\n\n        // Display product information\n        System.out.println("=== Available Products ===");\n        laptop.displayProductInfo();\n        System.out.println();\n        phone.displayProductInfo();\n        System.out.println();\n        shirt.displayProductInfo();\n        System.out.println();\n        jeans.displayProductInfo();\n\n        // Create shopping cart\n        ShoppingCart cart = new ShoppingCart();\n\n        // Add items to cart\n        System.out.println("\\n=== Adding Items to Cart ===");\n        cart.addItem(laptop, 1);\n        cart.addItem(shirt, 2);\n        cart.addItem(jeans, 1);\n\n        // Display cart\n        cart.displayCart();\n\n        // Create payment processor\n        PaymentProcessor creditCard = new CreditCardPayment("1234567890123456", "John Doe");\n\n        // Checkout\n        cart.checkout(creditCard);\n\n        // Try to add the same laptop again (should have reduced stock)\n        System.out.println("\\n=== Checking Stock After Purchase ===");\n        System.out.println("Laptop stock remaining: " + laptop.getStockQuantity());\n\n        // Try different payment method\n        System.out.println("\\n=== Another Purchase ===");\n        cart.addItem(phone, 1);\n        cart.displayCart();\n\n        PaymentProcessor paypal = new PayPalPayment("john.doe@email.com");\n        cart.checkout(paypal);\n    }\n}\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(e.p,{children:"This comprehensive guide covers all the fundamental concepts of Object-Oriented Programming in Java:"}),"\n",(0,i.jsx)(e.h3,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Classes and Objects"}),": Classes are blueprints, objects are instances"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Constructors"}),": Initialize objects with different parameter combinations"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Encapsulation"}),": Use private fields with public getters/setters for data protection"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Inheritance"}),": Extend classes to reuse and enhance functionality"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Polymorphism"}),": Same interface, different implementations (overloading and overriding)"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Abstraction"}),": Hide implementation details using abstract classes and interfaces"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Access Modifiers"}),": Control visibility at different levels"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Static Members"}),": Belong to the class, shared among all instances"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Always use appropriate access modifiers"}),"\n",(0,i.jsx)(e.li,{children:"Follow naming conventions (CamelCase for classes, camelCase for methods/variables)"}),"\n",(0,i.jsxs)(e.li,{children:["Use ",(0,i.jsx)(e.code,{children:"@Override"})," annotation for method overriding"]}),"\n",(0,i.jsx)(e.li,{children:"Prefer composition over inheritance when appropriate"}),"\n",(0,i.jsxs)(e.li,{children:["Make classes immutable when possible using ",(0,i.jsx)(e.code,{children:"final"})," keyword"]}),"\n",(0,i.jsx)(e.li,{children:"Use interfaces to define contracts"}),"\n",(0,i.jsx)(e.li,{children:"Keep methods and classes focused on single responsibilities"}),"\n",(0,i.jsx)(e.li,{children:"Document your code with meaningful comments"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"design-principles",children:"Design Principles"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Single Responsibility Principle"}),": Each class should have one reason to change"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Open/Closed Principle"}),": Open for extension, closed for modification"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Liskov Substitution Principle"}),": Subclasses should be substitutable for their base classes"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Interface Segregation Principle"}),": Depend on abstractions, not concretions"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Dependency Inversion Principle"}),": High-level modules should not depend on low-level modules"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"This guide provides a solid foundation for understanding and implementing Object-Oriented Programming concepts in Java. Practice these concepts with real-world projects to master OOP principles effectively."})]})}function u(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(d,{...n})}):d(n)}}}]);