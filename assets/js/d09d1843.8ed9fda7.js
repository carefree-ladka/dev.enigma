"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[9176],{203:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>c,frontMatter:()=>i,metadata:()=>a,toc:()=>u});var t=r(74848),o=r(28453);const i={},l="Binary Tree Recursion",a={id:"DSA/DSA with Java/Binary Tree Recusion Patterns",title:"Binary Tree Recursion",description:"Table of Contents",source:"@site/docs/DSA/DSA with Java/Binary Tree Recusion Patterns.mdx",sourceDirName:"DSA/DSA with Java",slug:"/DSA/DSA with Java/Binary Tree Recusion Patterns",permalink:"/dev.enigma/docs/DSA/DSA with Java/Binary Tree Recusion Patterns",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with Java/Binary Tree Recusion Patterns.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Binary Tree & BST",permalink:"/dev.enigma/docs/DSA/DSA with Java/Binary Tree Patterns"},next:{title:"Binary Tree View Implementations",permalink:"/dev.enigma/docs/DSA/DSA with Java/Binary Tree View Implementations"}},s={},u=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Recursion Fundamentals",id:"recursion-fundamentals",level:2},{value:"Binary Tree Node Definition",id:"binary-tree-node-definition",level:3},{value:"Core Recursion Templates[2][3]",id:"core-recursion-templates23",level:3},{value:"Pattern 1: Basic Traversal Recursions",id:"pattern-1-basic-traversal-recursions",level:2},{value:"1.1 Classic Tree Traversals",id:"11-classic-tree-traversals",level:3},{value:"1.2 Morris Traversal (Space Optimized)",id:"12-morris-traversal-space-optimized",level:3},{value:"1.3 Boundary Traversal",id:"13-boundary-traversal",level:3},{value:"Pattern 2: Tree Property Recursions",id:"pattern-2-tree-property-recursions",level:2},{value:"2.1 Basic Tree Properties",id:"21-basic-tree-properties",level:3},{value:"2.2 Tree Size &amp; Count Properties",id:"22-tree-size--count-properties",level:3},{value:"2.3 Advanced Tree Properties",id:"23-advanced-tree-properties",level:3},{value:"Pattern 3: Path-Based Recursions",id:"pattern-3-path-based-recursions",level:2},{value:"3.1 Root-to-Leaf Paths",id:"31-root-to-leaf-paths",level:3},{value:"3.2 Any Path Problems",id:"32-any-path-problems",level:3},{value:"3.3 Distance &amp; LCA Problems",id:"33-distance--lca-problems",level:3},{value:"Pattern 4: Value Aggregation Recursions",id:"pattern-4-value-aggregation-recursions",level:2},{value:"4.1 Sum-Based Problems",id:"41-sum-based-problems",level:3},{value:"4.2 Min/Max Problems",id:"42-minmax-problems",level:3},{value:"Pattern 5: Tree Transformation Recursions",id:"pattern-5-tree-transformation-recursions",level:2},{value:"5.1 Tree Modification",id:"51-tree-modification",level:3},{value:"5.2 Tree to Other Data Structures",id:"52-tree-to-other-data-structures",level:3},{value:"Pattern 6: Tree Construction Recursions",id:"pattern-6-tree-construction-recursions",level:2},{value:"6.1 Build Tree from Traversals",id:"61-build-tree-from-traversals",level:3},{value:"6.2 Serialize and Deserialize",id:"62-serialize-and-deserialize",level:3},{value:"Pattern 7: Tree Validation Recursions",id:"pattern-7-tree-validation-recursions",level:2},{value:"7.1 BST Validation",id:"71-bst-validation",level:3},{value:"7.2 Tree Structure Validation",id:"72-tree-structure-validation",level:3},{value:"Pattern 8: Subtree &amp; Comparison Recursions",id:"pattern-8-subtree--comparison-recursions",level:2},{value:"8.1 Tree Comparison",id:"81-tree-comparison",level:3},{value:"8.2 Tree Isomorphism",id:"82-tree-isomorphism",level:3},{value:"Pattern 9: Advanced Path Recursions",id:"pattern-9-advanced-path-recursions",level:2},{value:"9.1 Complex Path Problems",id:"91-complex-path-problems",level:3},{value:"9.2 Path with Constraints",id:"92-path-with-constraints",level:3},{value:"Pattern 10: Dynamic Programming Recursions",id:"pattern-10-dynamic-programming-recursions",level:2},{value:"10.1 Tree DP Problems",id:"101-tree-dp-problems",level:3},{value:"10.2 Optimization Problems",id:"102-optimization-problems",level:3},{value:"Pattern 11: Multi-Tree Recursions",id:"pattern-11-multi-tree-recursions",level:2},{value:"11.1 Tree Array Operations",id:"111-tree-array-operations",level:3},{value:"Pattern 12: Complex Recursive Problems",id:"pattern-12-complex-recursive-problems",level:2},{value:"12.1 Advanced Tree Algorithms",id:"121-advanced-tree-algorithms",level:3},{value:"Time &amp; Space Complexity Reference",id:"time--space-complexity-reference",level:2},{value:"Best Practices &amp; Optimization Tips",id:"best-practices--optimization-tips",level:2},{value:"Recursion Guidelines",id:"recursion-guidelines",level:3},{value:"Common Pitfalls to Avoid",id:"common-pitfalls-to-avoid",level:3},{value:"Interview Tips[13][12]",id:"interview-tips1312",level:3}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"binary-tree-recursion",children:"Binary Tree Recursion"})}),"\n",(0,t.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#recursion-fundamentals",children:"Recursion Fundamentals"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-1-basic-traversal-recursions",children:"Pattern 1: Basic Traversal Recursions"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-2-tree-property-recursions",children:"Pattern 2: Tree Property Recursions"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-3-path-based-recursions",children:"Pattern 3: Path-Based Recursions"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-4-value-aggregation-recursions",children:"Pattern 4: Value Aggregation Recursions"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-5-tree-transformation-recursions",children:"Pattern 5: Tree Transformation Recursions"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-6-tree-construction-recursions",children:"Pattern 6: Tree Construction Recursions"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-7-tree-validation-recursions",children:"Pattern 7: Tree Validation Recursions"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-8-subtree--comparison-recursions",children:"Pattern 8: Subtree & Comparison Recursions"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-9-advanced-path-recursions",children:"Pattern 9: Advanced Path Recursions"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-10-dynamic-programming-recursions",children:"Pattern 10: Dynamic Programming Recursions"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-11-multi-tree-recursions",children:"Pattern 11: Multi-Tree Recursions"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-12-complex-recursive-problems",children:"Pattern 12: Complex Recursive Problems"})}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"recursion-fundamentals",children:"Recursion Fundamentals"}),"\n",(0,t.jsx)(n.h3,{id:"binary-tree-node-definition",children:"Binary Tree Node Definition"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Standard Binary Tree Node\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\n// Enhanced Node with Parent Pointer\nclass TreeNodeWithParent {\n    int val;\n    TreeNodeWithParent left;\n    TreeNodeWithParent right;\n    TreeNodeWithParent parent;\n\n    TreeNodeWithParent(int val) {\n        this.val = val;\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"core-recursion-templates23",children:"Core Recursion Templates[2][3]"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"class BinaryTreeRecursion {\n\n    // Template 1: Single Tree Recursion (Bottom-Up)\n    public int bottomUpRecursion(TreeNode root) {\n        // Base case\n        if (root == null) return 0;\n\n        // Recursive calls to children\n        int leftResult = bottomUpRecursion(root.left);\n        int rightResult = bottomUpRecursion(root.right);\n\n        // Process current node with children results\n        return processNode(root, leftResult, rightResult);\n    }\n\n    // Template 2: Single Tree Recursion (Top-Down)\n    public void topDownRecursion(TreeNode root, int parentValue) {\n        // Base case\n        if (root == null) return;\n\n        // Process current node with parent information\n        int currentValue = processWithParent(root, parentValue);\n\n        // Recursive calls to children\n        topDownRecursion(root.left, currentValue);\n        topDownRecursion(root.right, currentValue);\n    }\n\n    // Template 3: Path-Based Recursion\n    public void pathRecursion(TreeNode root, List<Integer> path, List<List<Integer>> result) {\n        if (root == null) return;\n\n        // Add current node to path\n        path.add(root.val);\n\n        // Check if leaf node\n        if (root.left == null && root.right == null) {\n            processPath(path, result);\n        } else {\n            // Continue recursion\n            pathRecursion(root.left, path, result);\n            pathRecursion(root.right, path, result);\n        }\n\n        // Backtrack\n        path.remove(path.size() - 1);\n    }\n\n    // Template 4: Two-Tree Recursion\n    public boolean twoTreeRecursion(TreeNode root1, TreeNode root2) {\n        // Base cases\n        if (root1 == null && root2 == null) return true;\n        if (root1 == null || root2 == null) return false;\n\n        // Process current nodes\n        if (!processNodes(root1, root2)) return false;\n\n        // Recursive calls\n        return twoTreeRecursion(root1.left, root2.left) &&\n               twoTreeRecursion(root1.right, root2.right);\n    }\n\n    // Template 5: Recursive with Global State\n    private int globalState;\n\n    public int recursionWithGlobalState(TreeNode root) {\n        globalState = initializeGlobalState();\n        recursionHelper(root);\n        return globalState;\n    }\n\n    private void recursionHelper(TreeNode root) {\n        if (root == null) return;\n\n        updateGlobalState(root);\n\n        recursionHelper(root.left);\n        recursionHelper(root.right);\n    }\n\n    // Helper methods (to be implemented by specific problems)\n    int processNode(TreeNode node, int leftResult, int rightResult) { return 0; }\n    int processWithParent(TreeNode node, int parentValue) { return 0; }\n    void processPath(List<Integer> path, List<List<Integer>> result) {}\n    boolean processNodes(TreeNode node1, TreeNode node2) { return true; }\n    int initializeGlobalState() { return 0; }\n    void updateGlobalState(TreeNode node) {}\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-1-basic-traversal-recursions",children:"Pattern 1: Basic Traversal Recursions"}),"\n",(0,t.jsx)(n.h3,{id:"11-classic-tree-traversals",children:"1.1 Classic Tree Traversals"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Preorder Traversal (Root -> Left -> Right)\npublic List<Integer> preorderTraversal(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n    preorderHelper(root, result);\n    return result;\n}\n\nprivate void preorderHelper(TreeNode root, List<Integer> result) {\n    if (root == null) return;\n\n    result.add(root.val);           // Process root\n    preorderHelper(root.left, result);   // Traverse left\n    preorderHelper(root.right, result);  // Traverse right\n}\n\n// Inorder Traversal (Left -> Root -> Right)\npublic List<Integer> inorderTraversal(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n    inorderHelper(root, result);\n    return result;\n}\n\nprivate void inorderHelper(TreeNode root, List<Integer> result) {\n    if (root == null) return;\n\n    inorderHelper(root.left, result);    // Traverse left\n    result.add(root.val);           // Process root\n    inorderHelper(root.right, result);   // Traverse right\n}\n\n// Postorder Traversal (Left -> Right -> Root)\npublic List<Integer> postorderTraversal(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n    postorderHelper(root, result);\n    return result;\n}\n\nprivate void postorderHelper(TreeNode root, List<Integer> result) {\n    if (root == null) return;\n\n    postorderHelper(root.left, result);  // Traverse left\n    postorderHelper(root.right, result); // Traverse right\n    result.add(root.val);           // Process root\n}\n\n// Generic Traversal with Function Parameter\npublic void genericTraversal(TreeNode root, Consumer<Integer> processor, TraversalOrder order) {\n    if (root == null) return;\n\n    switch (order) {\n        case PREORDER:\n            processor.accept(root.val);\n            genericTraversal(root.left, processor, order);\n            genericTraversal(root.right, processor, order);\n            break;\n\n        case INORDER:\n            genericTraversal(root.left, processor, order);\n            processor.accept(root.val);\n            genericTraversal(root.right, processor, order);\n            break;\n\n        case POSTORDER:\n            genericTraversal(root.left, processor, order);\n            genericTraversal(root.right, processor, order);\n            processor.accept(root.val);\n            break;\n    }\n}\n\nenum TraversalOrder {\n    PREORDER, INORDER, POSTORDER\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"12-morris-traversal-space-optimized",children:"1.2 Morris Traversal (Space Optimized)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Morris Inorder Traversal (O(1) space)\npublic List<Integer> morrisInorder(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n    TreeNode current = root;\n\n    while (current != null) {\n        if (current.left == null) {\n            result.add(current.val);\n            current = current.right;\n        } else {\n            // Find inorder predecessor\n            TreeNode predecessor = current.left;\n            while (predecessor.right != null && predecessor.right != current) {\n                predecessor = predecessor.right;\n            }\n\n            if (predecessor.right == null) {\n                // Make current the right child of predecessor\n                predecessor.right = current;\n                current = current.left;\n            } else {\n                // Revert the changes\n                predecessor.right = null;\n                result.add(current.val);\n                current = current.right;\n            }\n        }\n    }\n\n    return result;\n}\n\n// Morris Preorder Traversal\npublic List<Integer> morrisPreorder(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n    TreeNode current = root;\n\n    while (current != null) {\n        if (current.left == null) {\n            result.add(current.val);\n            current = current.right;\n        } else {\n            TreeNode predecessor = current.left;\n            while (predecessor.right != null && predecessor.right != current) {\n                predecessor = predecessor.right;\n            }\n\n            if (predecessor.right == null) {\n                result.add(current.val); // Process before going left\n                predecessor.right = current;\n                current = current.left;\n            } else {\n                predecessor.right = null;\n                current = current.right;\n            }\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"13-boundary-traversal",children:"1.3 Boundary Traversal"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Print Boundary of Binary Tree\npublic List<Integer> boundaryTraversal(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n    if (root == null) return result;\n\n    if (!isLeaf(root)) result.add(root.val);\n\n    addLeftBoundary(root, result);\n    addLeaves(root, result);\n    addRightBoundary(root, result);\n\n    return result;\n}\n\nprivate void addLeftBoundary(TreeNode root, List<Integer> result) {\n    TreeNode current = root.left;\n    while (current != null) {\n        if (!isLeaf(current)) {\n            result.add(current.val);\n        }\n        current = current.left != null ? current.left : current.right;\n    }\n}\n\nprivate void addRightBoundary(TreeNode root, List<Integer> result) {\n    TreeNode current = root.right;\n    List<Integer> temp = new ArrayList<>();\n\n    while (current != null) {\n        if (!isLeaf(current)) {\n            temp.add(current.val);\n        }\n        current = current.right != null ? current.right : current.left;\n    }\n\n    // Add in reverse order\n    for (int i = temp.size() - 1; i >= 0; i--) {\n        result.add(temp.get(i));\n    }\n}\n\nprivate void addLeaves(TreeNode root, List<Integer> result) {\n    if (root == null) return;\n\n    if (isLeaf(root)) {\n        result.add(root.val);\n        return;\n    }\n\n    addLeaves(root.left, result);\n    addLeaves(root.right, result);\n}\n\nprivate boolean isLeaf(TreeNode node) {\n    return node.left == null && node.right == null;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-2-tree-property-recursions",children:"Pattern 2: Tree Property Recursions"}),"\n",(0,t.jsx)(n.h3,{id:"21-basic-tree-properties",children:"2.1 Basic Tree Properties"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Maximum Depth of Binary Tree\npublic int maxDepth(TreeNode root) {\n    if (root == null) return 0;\n\n    int leftDepth = maxDepth(root.left);\n    int rightDepth = maxDepth(root.right);\n\n    return 1 + Math.max(leftDepth, rightDepth);\n}\n\n// Minimum Depth of Binary Tree\npublic int minDepth(TreeNode root) {\n    if (root == null) return 0;\n\n    // If one child is null, consider only the other\n    if (root.left == null) return 1 + minDepth(root.right);\n    if (root.right == null) return 1 + minDepth(root.left);\n\n    return 1 + Math.min(minDepth(root.left), minDepth(root.right));\n}\n\n// Check if Tree is Balanced\npublic boolean isBalanced(TreeNode root) {\n    return checkBalance(root) != -1;\n}\n\nprivate int checkBalance(TreeNode root) {\n    if (root == null) return 0;\n\n    int leftHeight = checkBalance(root.left);\n    if (leftHeight == -1) return -1;\n\n    int rightHeight = checkBalance(root.right);\n    if (rightHeight == -1) return -1;\n\n    if (Math.abs(leftHeight - rightHeight) > 1) return -1;\n\n    return 1 + Math.max(leftHeight, rightHeight);\n}\n\n// Diameter of Binary Tree\npublic int diameterOfBinaryTree(TreeNode root) {\n    int[] maxDiameter = {0};\n    height(root, maxDiameter);\n    return maxDiameter[0];\n}\n\nprivate int height(TreeNode root, int[] maxDiameter) {\n    if (root == null) return 0;\n\n    int leftHeight = height(root.left, maxDiameter);\n    int rightHeight = height(root.right, maxDiameter);\n\n    maxDiameter[0] = Math.max(maxDiameter[0], leftHeight + rightHeight);\n\n    return 1 + Math.max(leftHeight, rightHeight);\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"22-tree-size--count-properties",children:"2.2 Tree Size & Count Properties"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Count Total Nodes\npublic int countNodes(TreeNode root) {\n    if (root == null) return 0;\n\n    return 1 + countNodes(root.left) + countNodes(root.right);\n}\n\n// Count Leaf Nodes\npublic int countLeaves(TreeNode root) {\n    if (root == null) return 0;\n\n    if (root.left == null && root.right == null) return 1;\n\n    return countLeaves(root.left) + countLeaves(root.right);\n}\n\n// Count Nodes with One Child\npublic int countNodesWithOneChild(TreeNode root) {\n    if (root == null) return 0;\n\n    int count = 0;\n\n    // Check if current node has exactly one child\n    if ((root.left == null && root.right != null) ||\n        (root.left != null && root.right == null)) {\n        count = 1;\n    }\n\n    return count + countNodesWithOneChild(root.left) +\n           countNodesWithOneChild(root.right);\n}\n\n// Count Complete Tree Nodes (Optimized for Complete Trees)\npublic int countCompleteTreeNodes(TreeNode root) {\n    if (root == null) return 0;\n\n    int leftDepth = getLeftDepth(root);\n    int rightDepth = getRightDepth(root);\n\n    if (leftDepth == rightDepth) {\n        // Perfect binary tree\n        return (1 << leftDepth) - 1;\n    } else {\n        // Recursively count\n        return 1 + countCompleteTreeNodes(root.left) +\n               countCompleteTreeNodes(root.right);\n    }\n}\n\nprivate int getLeftDepth(TreeNode root) {\n    int depth = 0;\n    while (root != null) {\n        depth++;\n        root = root.left;\n    }\n    return depth;\n}\n\nprivate int getRightDepth(TreeNode root) {\n    int depth = 0;\n    while (root != null) {\n        depth++;\n        root = root.right;\n    }\n    return depth;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"23-advanced-tree-properties",children:"2.3 Advanced Tree Properties"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Check if Tree is Symmetric\npublic boolean isSymmetric(TreeNode root) {\n    if (root == null) return true;\n    return isSymmetricHelper(root.left, root.right);\n}\n\nprivate boolean isSymmetricHelper(TreeNode left, TreeNode right) {\n    if (left == null && right == null) return true;\n    if (left == null || right == null) return false;\n\n    return left.val == right.val &&\n           isSymmetricHelper(left.left, right.right) &&\n           isSymmetricHelper(left.right, right.left);\n}\n\n// Check if Tree is Complete\npublic boolean isCompleteTree(TreeNode root) {\n    if (root == null) return true;\n\n    Queue<TreeNode> queue = new LinkedList<>();\n    queue.offer(root);\n    boolean foundNull = false;\n\n    while (!queue.isEmpty()) {\n        TreeNode current = queue.poll();\n\n        if (current == null) {\n            foundNull = true;\n        } else {\n            if (foundNull) return false; // Found non-null after null\n            queue.offer(current.left);\n            queue.offer(current.right);\n        }\n    }\n\n    return true;\n}\n\n// Width of Binary Tree (Maximum nodes at any level)\npublic int widthOfBinaryTree(TreeNode root) {\n    if (root == null) return 0;\n\n    return widthHelper(root, 0, 1, new ArrayList<>(), new ArrayList<>());\n}\n\nprivate int widthHelper(TreeNode root, int level, int order,\n                       List<Integer> start, List<Integer> end) {\n    if (root == null) return 0;\n\n    if (start.size() == level) {\n        start.add(order);\n        end.add(order);\n    } else {\n        end.set(level, order);\n    }\n\n    int currentWidth = end.get(level) - start.get(level) + 1;\n    int leftWidth = widthHelper(root.left, level + 1, 2 * order, start, end);\n    int rightWidth = widthHelper(root.right, level + 1, 2 * order + 1, start, end);\n\n    return Math.max(currentWidth, Math.max(leftWidth, rightWidth));\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-3-path-based-recursions",children:"Pattern 3: Path-Based Recursions"}),"\n",(0,t.jsx)(n.h3,{id:"31-root-to-leaf-paths",children:"3.1 Root-to-Leaf Paths"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// Binary Tree Paths\npublic List<String> binaryTreePaths(TreeNode root) {\n    List<String> result = new ArrayList<>();\n    if (root != null) {\n        findPaths(root, "", result);\n    }\n    return result;\n}\n\nprivate void findPaths(TreeNode root, String path, List<String> result) {\n    if (root.left == null && root.right == null) {\n        result.add(path + root.val);\n        return;\n    }\n\n    if (root.left != null) {\n        findPaths(root.left, path + root.val + "->", result);\n    }\n\n    if (root.right != null) {\n        findPaths(root.right, path + root.val + "->", result);\n    }\n}\n\n// Path Sum (Root to Leaf)\npublic boolean hasPathSum(TreeNode root, int targetSum) {\n    if (root == null) return false;\n\n    if (root.left == null && root.right == null) {\n        return root.val == targetSum;\n    }\n\n    return hasPathSum(root.left, targetSum - root.val) ||\n           hasPathSum(root.right, targetSum - root.val);\n}\n\n// Path Sum II (All Paths)\npublic List<List<Integer>> pathSum(TreeNode root, int targetSum) {\n    List<List<Integer>> result = new ArrayList<>();\n    findPathSum(root, targetSum, new ArrayList<>(), result);\n    return result;\n}\n\nprivate void findPathSum(TreeNode root, int remainingSum,\n                        List<Integer> currentPath, List<List<Integer>> result) {\n    if (root == null) return;\n\n    currentPath.add(root.val);\n\n    if (root.left == null && root.right == null && remainingSum == root.val) {\n        result.add(new ArrayList<>(currentPath));\n    } else {\n        findPathSum(root.left, remainingSum - root.val, currentPath, result);\n        findPathSum(root.right, remainingSum - root.val, currentPath, result);\n    }\n\n    currentPath.remove(currentPath.size() - 1); // Backtrack\n}\n\n// Sum Root to Leaf Numbers\npublic int sumNumbers(TreeNode root) {\n    return sumNumbersHelper(root, 0);\n}\n\nprivate int sumNumbersHelper(TreeNode root, int currentNumber) {\n    if (root == null) return 0;\n\n    currentNumber = currentNumber * 10 + root.val;\n\n    if (root.left == null && root.right == null) {\n        return currentNumber;\n    }\n\n    return sumNumbersHelper(root.left, currentNumber) +\n           sumNumbersHelper(root.right, currentNumber);\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"32-any-path-problems",children:"3.2 Any Path Problems"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Path Sum III (Any path, not necessarily root-to-leaf)\npublic int pathSum(TreeNode root, int targetSum) {\n    if (root == null) return 0;\n\n    return pathSumFrom(root, targetSum) +\n           pathSum(root.left, targetSum) +\n           pathSum(root.right, targetSum);\n}\n\nprivate int pathSumFrom(TreeNode root, int targetSum) {\n    if (root == null) return 0;\n\n    int count = 0;\n    if (root.val == targetSum) count++;\n\n    count += pathSumFrom(root.left, targetSum - root.val);\n    count += pathSumFrom(root.right, targetSum - root.val);\n\n    return count;\n}\n\n// Path Sum III (Optimized with HashMap)\npublic int pathSumOptimized(TreeNode root, int targetSum) {\n    Map<Integer, Integer> prefixSum = new HashMap<>();\n    prefixSum.put(0, 1); // Base case\n    return pathSumHelper(root, 0, targetSum, prefixSum);\n}\n\nprivate int pathSumHelper(TreeNode root, int currentSum, int targetSum,\n                         Map<Integer, Integer> prefixSum) {\n    if (root == null) return 0;\n\n    currentSum += root.val;\n    int count = prefixSum.getOrDefault(currentSum - targetSum, 0);\n\n    prefixSum.put(currentSum, prefixSum.getOrDefault(currentSum, 0) + 1);\n\n    count += pathSumHelper(root.left, currentSum, targetSum, prefixSum);\n    count += pathSumHelper(root.right, currentSum, targetSum, prefixSum);\n\n    prefixSum.put(currentSum, prefixSum.get(currentSum) - 1); // Backtrack\n\n    return count;\n}\n\n// Maximum Path Sum\npublic int maxPathSum(TreeNode root) {\n    int[] maxSum = {Integer.MIN_VALUE};\n    maxPathSumHelper(root, maxSum);\n    return maxSum[0];\n}\n\nprivate int maxPathSumHelper(TreeNode root, int[] maxSum) {\n    if (root == null) return 0;\n\n    int leftSum = Math.max(0, maxPathSumHelper(root.left, maxSum));\n    int rightSum = Math.max(0, maxPathSumHelper(root.right, maxSum));\n\n    int currentPathSum = root.val + leftSum + rightSum;\n    maxSum[0] = Math.max(maxSum[0], currentPathSum);\n\n    return root.val + Math.max(leftSum, rightSum);\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"33-distance--lca-problems",children:"3.3 Distance & LCA Problems"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Lowest Common Ancestor of Binary Tree\npublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n    if (root == null || root == p || root == q) {\n        return root;\n    }\n\n    TreeNode leftLCA = lowestCommonAncestor(root.left, p, q);\n    TreeNode rightLCA = lowestCommonAncestor(root.right, p, q);\n\n    if (leftLCA != null && rightLCA != null) {\n        return root; // Current node is LCA\n    }\n\n    return leftLCA != null ? leftLCA : rightLCA;\n}\n\n// Distance Between Two Nodes\npublic int findDistance(TreeNode root, int val1, int val2) {\n    TreeNode lca = findLCA(root, val1, val2);\n    return getDistance(lca, val1, 0) + getDistance(lca, val2, 0);\n}\n\nprivate TreeNode findLCA(TreeNode root, int val1, int val2) {\n    if (root == null) return null;\n\n    if (root.val == val1 || root.val == val2) return root;\n\n    TreeNode leftLCA = findLCA(root.left, val1, val2);\n    TreeNode rightLCA = findLCA(root.right, val1, val2);\n\n    if (leftLCA != null && rightLCA != null) return root;\n    return leftLCA != null ? leftLCA : rightLCA;\n}\n\nprivate int getDistance(TreeNode root, int target, int distance) {\n    if (root == null) return -1;\n    if (root.val == target) return distance;\n\n    int leftDistance = getDistance(root.left, target, distance + 1);\n    if (leftDistance != -1) return leftDistance;\n\n    return getDistance(root.right, target, distance + 1);\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-4-value-aggregation-recursions",children:"Pattern 4: Value Aggregation Recursions"}),"\n",(0,t.jsx)(n.h3,{id:"41-sum-based-problems",children:"4.1 Sum-Based Problems"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Sum of All Nodes\npublic int sumOfNodes(TreeNode root) {\n    if (root == null) return 0;\n\n    return root.val + sumOfNodes(root.left) + sumOfNodes(root.right);\n}\n\n// Sum of Left Leaves\npublic int sumOfLeftLeaves(TreeNode root) {\n    return sumOfLeftLeavesHelper(root, false);\n}\n\nprivate int sumOfLeftLeavesHelper(TreeNode root, boolean isLeft) {\n    if (root == null) return 0;\n\n    if (root.left == null && root.right == null) {\n        return isLeft ? root.val : 0;\n    }\n\n    return sumOfLeftLeavesHelper(root.left, true) +\n           sumOfLeftLeavesHelper(root.right, false);\n}\n\n// Sum of Nodes at Even Levels\npublic int sumAtEvenLevels(TreeNode root) {\n    return sumAtLevel(root, 0);\n}\n\nprivate int sumAtLevel(TreeNode root, int level) {\n    if (root == null) return 0;\n\n    int currentSum = (level % 2 == 0) ? root.val : 0;\n\n    return currentSum +\n           sumAtLevel(root.left, level + 1) +\n           sumAtLevel(root.right, level + 1);\n}\n\n// Sum of Nodes with Grandparent X\npublic int sumOfNodesWithGrandparentX(TreeNode root, int x) {\n    return sumWithGrandparent(root, null, null, x);\n}\n\nprivate int sumWithGrandparent(TreeNode root, TreeNode parent, TreeNode grandparent, int x) {\n    if (root == null) return 0;\n\n    int sum = 0;\n    if (grandparent != null && grandparent.val == x) {\n        sum = root.val;\n    }\n\n    sum += sumWithGrandparent(root.left, root, parent, x);\n    sum += sumWithGrandparent(root.right, root, parent, x);\n\n    return sum;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"42-minmax-problems",children:"4.2 Min/Max Problems"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Find Maximum Value in Tree\npublic int findMaxValue(TreeNode root) {\n    if (root == null) return Integer.MIN_VALUE;\n\n    int leftMax = findMaxValue(root.left);\n    int rightMax = findMaxValue(root.right);\n\n    return Math.max(root.val, Math.max(leftMax, rightMax));\n}\n\n// Find Second Minimum Value\npublic int findSecondMinimumValue(TreeNode root) {\n    if (root == null) return -1;\n    return findSecondMin(root, root.val);\n}\n\nprivate int findSecondMin(TreeNode root, int min) {\n    if (root == null) return -1;\n\n    if (root.val > min) return root.val;\n\n    int leftSecondMin = findSecondMin(root.left, min);\n    int rightSecondMin = findSecondMin(root.right, min);\n\n    if (leftSecondMin == -1) return rightSecondMin;\n    if (rightSecondMin == -1) return leftSecondMin;\n\n    return Math.min(leftSecondMin, rightSecondMin);\n}\n\n// Find Mode in BST\npublic int[] findMode(TreeNode root) {\n    Map<Integer, Integer> countMap = new HashMap<>();\n    inorderCount(root, countMap);\n\n    int maxCount = Collections.max(countMap.values());\n    List<Integer> modes = new ArrayList<>();\n\n    for (Map.Entry<Integer, Integer> entry : countMap.entrySet()) {\n        if (entry.getValue() == maxCount) {\n            modes.add(entry.getKey());\n        }\n    }\n\n    return modes.stream().mapToInt(Integer::intValue).toArray();\n}\n\nprivate void inorderCount(TreeNode root, Map<Integer, Integer> countMap) {\n    if (root == null) return;\n\n    inorderCount(root.left, countMap);\n    countMap.put(root.val, countMap.getOrDefault(root.val, 0) + 1);\n    inorderCount(root.right, countMap);\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-5-tree-transformation-recursions",children:"Pattern 5: Tree Transformation Recursions"}),"\n",(0,t.jsx)(n.h3,{id:"51-tree-modification",children:"5.1 Tree Modification"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Invert Binary Tree (Mirror)\npublic TreeNode invertTree(TreeNode root) {\n    if (root == null) return null;\n\n    TreeNode temp = root.left;\n    root.left = root.right;\n    root.right = temp;\n\n    invertTree(root.left);\n    invertTree(root.right);\n\n    return root;\n}\n\n// Flatten Binary Tree to Linked List\npublic void flatten(TreeNode root) {\n    flattenHelper(root);\n}\n\nprivate TreeNode flattenHelper(TreeNode root) {\n    if (root == null) return null;\n\n    if (root.left == null && root.right == null) return root;\n\n    TreeNode leftTail = flattenHelper(root.left);\n    TreeNode rightTail = flattenHelper(root.right);\n\n    if (leftTail != null) {\n        leftTail.right = root.right;\n        root.right = root.left;\n        root.left = null;\n    }\n\n    return rightTail != null ? rightTail : leftTail;\n}\n\n// Convert BST to Greater Sum Tree\npublic TreeNode bstToGst(TreeNode root) {\n    int[] sum = {0};\n    reverseInorder(root, sum);\n    return root;\n}\n\nprivate void reverseInorder(TreeNode root, int[] sum) {\n    if (root == null) return;\n\n    reverseInorder(root.right, sum);\n    sum[0] += root.val;\n    root.val = sum[0];\n    reverseInorder(root.left, sum);\n}\n\n// Prune Binary Tree (Remove subtrees with no 1s)\npublic TreeNode pruneTree(TreeNode root) {\n    if (root == null) return null;\n\n    root.left = pruneTree(root.left);\n    root.right = pruneTree(root.right);\n\n    if (root.val == 0 && root.left == null && root.right == null) {\n        return null;\n    }\n\n    return root;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"52-tree-to-other-data-structures",children:"5.2 Tree to Other Data Structures"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Convert Binary Tree to Doubly Linked List\npublic Node treeToDoublyList(Node root) {\n    if (root == null) return null;\n\n    Node[] headTail = {null, null};\n    inorderDLL(root, headTail);\n\n    // Make circular\n    headTail[0].left = headTail[1];\n    headTail[1].right = headTail[0];\n\n    return headTail[0];\n}\n\nprivate void inorderDLL(Node root, Node[] headTail) {\n    if (root == null) return;\n\n    inorderDLL(root.left, headTail);\n\n    if (headTail[1] == null) {\n        headTail[0] = headTail[1] = root;\n    } else {\n        headTail[1].right = root;\n        root.left = headTail[1];\n        headTail[1] = root;\n    }\n\n    inorderDLL(root.right, headTail);\n}\n\n// Convert Sorted Array to BST\npublic TreeNode sortedArrayToBST(int[] nums) {\n    return arrayToBST(nums, 0, nums.length - 1);\n}\n\nprivate TreeNode arrayToBST(int[] nums, int left, int right) {\n    if (left > right) return null;\n\n    int mid = left + (right - left) / 2;\n    TreeNode root = new TreeNode(nums[mid]);\n\n    root.left = arrayToBST(nums, left, mid - 1);\n    root.right = arrayToBST(nums, mid + 1, right);\n\n    return root;\n}\n\n// Convert Sorted List to BST\npublic TreeNode sortedListToBST(ListNode head) {\n    if (head == null) return null;\n    if (head.next == null) return new TreeNode(head.val);\n\n    ListNode prev = null;\n    ListNode slow = head;\n    ListNode fast = head;\n\n    // Find middle\n    while (fast != null && fast.next != null) {\n        prev = slow;\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n\n    // Break the list\n    if (prev != null) prev.next = null;\n\n    TreeNode root = new TreeNode(slow.val);\n    root.left = sortedListToBST(head);\n    root.right = sortedListToBST(slow.next);\n\n    return root;\n}\n\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode(int val) { this.val = val; }\n}\n\nclass Node {\n    int val;\n    Node left;\n    Node right;\n    Node(int val) { this.val = val; }\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-6-tree-construction-recursions",children:"Pattern 6: Tree Construction Recursions"}),"\n",(0,t.jsx)(n.h3,{id:"61-build-tree-from-traversals",children:"6.1 Build Tree from Traversals"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Build Tree from Preorder and Inorder\npublic TreeNode buildTreePreIn(int[] preorder, int[] inorder) {\n    Map<Integer, Integer> inorderMap = new HashMap<>();\n    for (int i = 0; i < inorder.length; i++) {\n        inorderMap.put(inorder[i], i);\n    }\n\n    return buildPreIn(preorder, 0, preorder.length - 1,\n                      inorder, 0, inorder.length - 1, inorderMap);\n}\n\nprivate TreeNode buildPreIn(int[] preorder, int preStart, int preEnd,\n                           int[] inorder, int inStart, int inEnd,\n                           Map<Integer, Integer> inorderMap) {\n    if (preStart > preEnd || inStart > inEnd) return null;\n\n    TreeNode root = new TreeNode(preorder[preStart]);\n    int rootIndex = inorderMap.get(root.val);\n    int leftTreeSize = rootIndex - inStart;\n\n    root.left = buildPreIn(preorder, preStart + 1, preStart + leftTreeSize,\n                          inorder, inStart, rootIndex - 1, inorderMap);\n    root.right = buildPreIn(preorder, preStart + leftTreeSize + 1, preEnd,\n                           inorder, rootIndex + 1, inEnd, inorderMap);\n\n    return root;\n}\n\n// Build Tree from Postorder and Inorder\npublic TreeNode buildTreePostIn(int[] postorder, int[] inorder) {\n    Map<Integer, Integer> inorderMap = new HashMap<>();\n    for (int i = 0; i < inorder.length; i++) {\n        inorderMap.put(inorder[i], i);\n    }\n\n    return buildPostIn(postorder, 0, postorder.length - 1,\n                       inorder, 0, inorder.length - 1, inorderMap);\n}\n\nprivate TreeNode buildPostIn(int[] postorder, int postStart, int postEnd,\n                            int[] inorder, int inStart, int inEnd,\n                            Map<Integer, Integer> inorderMap) {\n    if (postStart > postEnd || inStart > inEnd) return null;\n\n    TreeNode root = new TreeNode(postorder[postEnd]);\n    int rootIndex = inorderMap.get(root.val);\n    int leftTreeSize = rootIndex - inStart;\n\n    root.left = buildPostIn(postorder, postStart, postStart + leftTreeSize - 1,\n                           inorder, inStart, rootIndex - 1, inorderMap);\n    root.right = buildPostIn(postorder, postStart + leftTreeSize, postEnd - 1,\n                            inorder, rootIndex + 1, inEnd, inorderMap);\n\n    return root;\n}\n\n// Build Maximum Binary Tree\npublic TreeNode constructMaximumBinaryTree(int[] nums) {\n    return buildMaxTree(nums, 0, nums.length - 1);\n}\n\nprivate TreeNode buildMaxTree(int[] nums, int left, int right) {\n    if (left > right) return null;\n\n    int maxIndex = findMaxIndex(nums, left, right);\n    TreeNode root = new TreeNode(nums[maxIndex]);\n\n    root.left = buildMaxTree(nums, left, maxIndex - 1);\n    root.right = buildMaxTree(nums, maxIndex + 1, right);\n\n    return root;\n}\n\nprivate int findMaxIndex(int[] nums, int left, int right) {\n    int maxIndex = left;\n    for (int i = left + 1; i <= right; i++) {\n        if (nums[i] > nums[maxIndex]) {\n            maxIndex = i;\n        }\n    }\n    return maxIndex;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"62-serialize-and-deserialize",children:"6.2 Serialize and Deserialize"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// Serialize and Deserialize Binary Tree (Preorder)\npublic String serialize(TreeNode root) {\n    StringBuilder sb = new StringBuilder();\n    serializeHelper(root, sb);\n    return sb.toString();\n}\n\nprivate void serializeHelper(TreeNode root, StringBuilder sb) {\n    if (root == null) {\n        sb.append("null,");\n        return;\n    }\n\n    sb.append(root.val).append(",");\n    serializeHelper(root.left, sb);\n    serializeHelper(root.right, sb);\n}\n\npublic TreeNode deserialize(String data) {\n    String[] nodes = data.split(",");\n    int[] index = {0};\n    return deserializeHelper(nodes, index);\n}\n\nprivate TreeNode deserializeHelper(String[] nodes, int[] index) {\n    if (index[0] >= nodes.length || "null".equals(nodes[index[0]])) {\n        index[0]++;\n        return null;\n    }\n\n    TreeNode root = new TreeNode(Integer.parseInt(nodes[index[0]++]));\n    root.left = deserializeHelper(nodes, index);\n    root.right = deserializeHelper(nodes, index);\n\n    return root;\n}\n\n// Serialize BST (Space Optimized)\npublic String serializeBST(TreeNode root) {\n    StringBuilder sb = new StringBuilder();\n    serializeBSTHelper(root, sb);\n    return sb.toString();\n}\n\nprivate void serializeBSTHelper(TreeNode root, StringBuilder sb) {\n    if (root == null) return;\n\n    sb.append(root.val).append(",");\n    serializeBSTHelper(root.left, sb);\n    serializeBSTHelper(root.right, sb);\n}\n\npublic TreeNode deserializeBST(String data) {\n    if (data.isEmpty()) return null;\n\n    String[] nodes = data.split(",");\n    int[] values = new int[nodes.length];\n    for (int i = 0; i < nodes.length; i++) {\n        values[i] = Integer.parseInt(nodes[i]);\n    }\n\n    return deserializeBSTHelper(values, 0, values.length - 1);\n}\n\nprivate TreeNode deserializeBSTHelper(int[] values, int left, int right) {\n    if (left > right) return null;\n\n    int rootVal = values[left];\n    TreeNode root = new TreeNode(rootVal);\n\n    int i = left + 1;\n    while (i <= right && values[i] < rootVal) {\n        i++;\n    }\n\n    root.left = deserializeBSTHelper(values, left + 1, i - 1);\n    root.right = deserializeBSTHelper(values, i, right);\n\n    return root;\n}\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-7-tree-validation-recursions",children:"Pattern 7: Tree Validation Recursions"}),"\n",(0,t.jsx)(n.h3,{id:"71-bst-validation",children:"7.1 BST Validation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Validate Binary Search Tree\npublic boolean isValidBST(TreeNode root) {\n    return isValidBST(root, null, null);\n}\n\nprivate boolean isValidBST(TreeNode root, Integer min, Integer max) {\n    if (root == null) return true;\n\n    if ((min != null && root.val <= min) ||\n        (max != null && root.val >= max)) {\n        return false;\n    }\n\n    return isValidBST(root.left, min, root.val) &&\n           isValidBST(root.right, root.val, max);\n}\n\n// Inorder approach for BST validation\npublic boolean isValidBSTInorder(TreeNode root) {\n    TreeNode[] prev = {null};\n    return inorderValidate(root, prev);\n}\n\nprivate boolean inorderValidate(TreeNode root, TreeNode[] prev) {\n    if (root == null) return true;\n\n    if (!inorderValidate(root.left, prev)) return false;\n\n    if (prev[0] != null && prev[0].val >= root.val) return false;\n    prev[0] = root;\n\n    return inorderValidate(root.right, prev);\n}\n\n// Recover BST (Two nodes swapped)\npublic void recoverTree(TreeNode root) {\n    TreeNode[] first = {null};\n    TreeNode[] second = {null};\n    TreeNode[] prev = {null};\n\n    inorderRecover(root, first, second, prev);\n\n    // Swap values\n    int temp = first[0].val;\n    first[0].val = second[0].val;\n    second[0].val = temp;\n}\n\nprivate void inorderRecover(TreeNode root, TreeNode[] first,\n                           TreeNode[] second, TreeNode[] prev) {\n    if (root == null) return;\n\n    inorderRecover(root.left, first, second, prev);\n\n    if (prev[0] != null && prev[0].val > root.val) {\n        if (first[0] == null) {\n            first[0] = prev[0];\n        }\n        second[0] = root;\n    }\n    prev[0] = root;\n\n    inorderRecover(root.right, first, second, prev);\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"72-tree-structure-validation",children:"7.2 Tree Structure Validation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Validate Binary Tree (General Structure)\npublic boolean isValidBinaryTree(TreeNode root) {\n    return validateStructure(root, new HashSet<>());\n}\n\nprivate boolean validateStructure(TreeNode root, Set<TreeNode> visited) {\n    if (root == null) return true;\n\n    if (visited.contains(root)) return false; // Cycle detected\n    visited.add(root);\n\n    boolean leftValid = validateStructure(root.left, visited);\n    boolean rightValid = validateStructure(root.right, visited);\n\n    visited.remove(root); // Backtrack\n\n    return leftValid && rightValid;\n}\n\n// Check if Binary Tree is Complete\npublic boolean isCompleteTreeRecursive(TreeNode root) {\n    int nodeCount = countNodes(root);\n    return isCompleteHelper(root, 0, nodeCount);\n}\n\nprivate boolean isCompleteHelper(TreeNode root, int index, int nodeCount) {\n    if (root == null) return true;\n\n    if (index >= nodeCount) return false;\n\n    return isCompleteHelper(root.left, 2 * index + 1, nodeCount) &&\n           isCompleteHelper(root.right, 2 * index + 2, nodeCount);\n}\n\n// Check if Binary Tree is Full\npublic boolean isFullBinaryTree(TreeNode root) {\n    if (root == null) return true;\n\n    if ((root.left == null) != (root.right == null)) {\n        return false; // One child exists but not the other\n    }\n\n    return isFullBinaryTree(root.left) && isFullBinaryTree(root.right);\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-8-subtree--comparison-recursions",children:"Pattern 8: Subtree & Comparison Recursions"}),"\n",(0,t.jsx)(n.h3,{id:"81-tree-comparison",children:"8.1 Tree Comparison"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// Same Tree\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (p == null || q == null) return false;\n\n    return p.val == q.val &&\n           isSameTree(p.left, q.left) &&\n           isSameTree(p.right, q.right);\n}\n\n// Subtree of Another Tree\npublic boolean isSubtree(TreeNode root, TreeNode subRoot) {\n    if (root == null) return false;\n\n    return isSameTree(root, subRoot) ||\n           isSubtree(root.left, subRoot) ||\n           isSubtree(root.right, subRoot);\n}\n\n// Merge Two Binary Trees\npublic TreeNode mergeTrees(TreeNode root1, TreeNode root2) {\n    if (root1 == null) return root2;\n    if (root2 == null) return root1;\n\n    TreeNode merged = new TreeNode(root1.val + root2.val);\n    merged.left = mergeTrees(root1.left, root2.left);\n    merged.right = mergeTrees(root1.right, root2.right);\n\n    return merged;\n}\n\n// Find Duplicate Subtrees\npublic List<TreeNode> findDuplicateSubtrees(TreeNode root) {\n    Map<String, Integer> subtreeCount = new HashMap<>();\n    List<TreeNode> result = new ArrayList<>();\n\n    serialize(root, subtreeCount, result);\n    return result;\n}\n\nprivate String serialize(TreeNode root, Map<String, Integer> subtreeCount,\n                        List<TreeNode> result) {\n    if (root == null) return "null";\n\n    String subtree = root.val + "," +\n                    serialize(root.left, subtreeCount, result) + "," +\n                    serialize(root.right, subtreeCount, result);\n\n    subtreeCount.put(subtree, subtreeCount.getOrDefault(subtree, 0) + 1);\n\n    if (subtreeCount.get(subtree) == 2) {\n        result.add(root);\n    }\n\n    return subtree;\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"82-tree-isomorphism",children:"8.2 Tree Isomorphism"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Check if Two Trees are Isomorphic\npublic boolean isIsomorphic(TreeNode root1, TreeNode root2) {\n    if (root1 == null && root2 == null) return true;\n    if (root1 == null || root2 == null) return false;\n    if (root1.val != root2.val) return false;\n\n    // Two possibilities: no flip or flip\n    return (isIsomorphic(root1.left, root2.left) &&\n            isIsomorphic(root1.right, root2.right)) ||\n           (isIsomorphic(root1.left, root2.right) &&\n            isIsomorphic(root1.right, root2.left));\n}\n\n// Flip Equivalent Binary Trees\npublic boolean flipEquiv(TreeNode root1, TreeNode root2) {\n    if (root1 == null && root2 == null) return true;\n    if (root1 == null || root2 == null || root1.val != root2.val) {\n        return false;\n    }\n\n    return (flipEquiv(root1.left, root2.left) &&\n            flipEquiv(root1.right, root2.right)) ||\n           (flipEquiv(root1.left, root2.right) &&\n            flipEquiv(root1.right, root2.left));\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-9-advanced-path-recursions",children:"Pattern 9: Advanced Path Recursions"}),"\n",(0,t.jsx)(n.h3,{id:"91-complex-path-problems",children:"9.1 Complex Path Problems"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Longest Univalue Path\npublic int longestUnivaluePath(TreeNode root) {\n    int[] maxLength = {0};\n    longestUniHelper(root, maxLength);\n    return maxLength[0];\n}\n\nprivate int longestUniHelper(TreeNode root, int[] maxLength) {\n    if (root == null) return 0;\n\n    int left = longestUniHelper(root.left, maxLength);\n    int right = longestUniHelper(root.right, maxLength);\n\n    int leftPath = (root.left != null && root.left.val == root.val) ? left + 1 : 0;\n    int rightPath = (root.right != null && root.right.val == root.val) ? right + 1 : 0;\n\n    maxLength[0] = Math.max(maxLength[0], leftPath + rightPath);\n\n    return Math.max(leftPath, rightPath);\n}\n\n// Binary Tree Maximum Path Sum (Any to Any)\npublic int maxPathSumAnyToAny(TreeNode root) {\n    int[] maxSum = {Integer.MIN_VALUE};\n    maxPathHelper(root, maxSum);\n    return maxSum[0];\n}\n\nprivate int maxPathHelper(TreeNode root, int[] maxSum) {\n    if (root == null) return 0;\n\n    int leftSum = Math.max(0, maxPathHelper(root.left, maxSum));\n    int rightSum = Math.max(0, maxPathHelper(root.right, maxSum));\n\n    int currentPathSum = root.val + leftSum + rightSum;\n    maxSum[0] = Math.max(maxSum[0], currentPathSum);\n\n    return root.val + Math.max(leftSum, rightSum);\n}\n\n// Longest ZigZag Path\npublic int longestZigZag(TreeNode root) {\n    return Math.max(zigZagHelper(root, true), zigZagHelper(root, false));\n}\n\nprivate int zigZagHelper(TreeNode root, boolean isLeft) {\n    if (root == null) return 0;\n\n    int leftZigZag = zigZagHelper(root.left, false);\n    int rightZigZag = zigZagHelper(root.right, true);\n\n    if (isLeft) {\n        return root.left != null ? 1 + leftZigZag : 0;\n    } else {\n        return root.right != null ? 1 + rightZigZag : 0;\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"92-path-with-constraints",children:"9.2 Path with Constraints"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Count Good Nodes (Node >= all ancestors)\npublic int goodNodes(TreeNode root) {\n    return countGoodNodes(root, root.val);\n}\n\nprivate int countGoodNodes(TreeNode root, int maxSoFar) {\n    if (root == null) return 0;\n\n    int count = (root.val >= maxSoFar) ? 1 : 0;\n    int newMax = Math.max(maxSoFar, root.val);\n\n    count += countGoodNodes(root.left, newMax);\n    count += countGoodNodes(root.right, newMax);\n\n    return count;\n}\n\n// Pseudo-Palindromic Paths\npublic int pseudoPalindromicPaths(TreeNode root) {\n    return countPseudoPalindromic(root, 0);\n}\n\nprivate int countPseudoPalindromic(TreeNode root, int path) {\n    if (root == null) return 0;\n\n    path ^= (1 << root.val); // Toggle bit for current value\n\n    if (root.left == null && root.right == null) {\n        // Check if at most one bit is set (palindrome possible)\n        return (path & (path - 1)) == 0 ? 1 : 0;\n    }\n\n    return countPseudoPalindromic(root.left, path) +\n           countPseudoPalindromic(root.right, path);\n}\n\n// Sum of Distances in Tree\npublic int[] sumOfDistancesInTree(int n, int[][] edges) {\n    List<List<Integer>> graph = new ArrayList<>();\n    for (int i = 0; i < n; i++) {\n        graph.add(new ArrayList<>());\n    }\n\n    for (int[] edge : edges) {\n        graph.get(edge[0]).add(edge[1]);\n        graph.get(edge[1]).add(edge[0]);\n    }\n\n    int[] count = new int[n]; // Number of nodes in subtree\n    int[] result = new int[n]; // Sum of distances\n\n    dfsCount(graph, 0, -1, count, result);\n    dfsResult(graph, 0, -1, count, result, n);\n\n    return result;\n}\n\nprivate void dfsCount(List<List<Integer>> graph, int node, int parent,\n                     int[] count, int[] result) {\n    count[node] = 1;\n\n    for (int child : graph.get(node)) {\n        if (child != parent) {\n            dfsCount(graph, child, node, count, result);\n            count[node] += count[child];\n            result[node] += result[child] + count[child];\n        }\n    }\n}\n\nprivate void dfsResult(List<List<Integer>> graph, int node, int parent,\n                      int[] count, int[] result, int n) {\n    for (int child : graph.get(node)) {\n        if (child != parent) {\n            result[child] = result[node] - count[child] + (n - count[child]);\n            dfsResult(graph, child, node, count, result, n);\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-10-dynamic-programming-recursions",children:"Pattern 10: Dynamic Programming Recursions"}),"\n",(0,t.jsx)(n.h3,{id:"101-tree-dp-problems",children:"10.1 Tree DP Problems"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// House Robber III\npublic int rob(TreeNode root) {\n    int[] result = robHelper(root);\n    return Math.max(result[0], result[1]);\n}\n\nprivate int[] robHelper(TreeNode root) {\n    if (root == null) return new int[]{0, 0};\n\n    int[] left = robHelper(root.left);\n    int[] right = robHelper(root.right);\n\n    // result[0] = max money when root is not robbed\n    // result[1] = max money when root is robbed\n    int[] result = new int[2];\n    result[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);\n    result[1] = root.val + left[0] + right[0];\n\n    return result;\n}\n\n// Binary Tree Cameras\npublic int minCameraCover(TreeNode root) {\n    int[] cameras = {0};\n    int state = dfsCamera(root, cameras);\n    return cameras[0] + (state == 0 ? 1 : 0);\n}\n\nprivate int dfsCamera(TreeNode root, int[] cameras) {\n    if (root == null) return 1; // Null nodes are covered\n\n    int left = dfsCamera(root.left, cameras);\n    int right = dfsCamera(root.right, cameras);\n\n    // State 0: not covered, State 1: covered, State 2: has camera\n    if (left == 0 || right == 0) {\n        cameras[0]++;\n        return 2;\n    }\n\n    if (left == 2 || right == 2) {\n        return 1;\n    }\n\n    return 0;\n}\n\n// Distribute Coins in Binary Tree\npublic int distributeCoins(TreeNode root) {\n    int[] moves = {0};\n    dfsDistribute(root, moves);\n    return moves[0];\n}\n\nprivate int dfsDistribute(TreeNode root, int[] moves) {\n    if (root == null) return 0;\n\n    int leftExcess = dfsDistribute(root.left, moves);\n    int rightExcess = dfsDistribute(root.right, moves);\n\n    moves[0] += Math.abs(leftExcess) + Math.abs(rightExcess);\n\n    return root.val + leftExcess + rightExcess - 1;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"102-optimization-problems",children:"10.2 Optimization Problems"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Maximum Product of Splitted Binary Tree\npublic int maxProduct(TreeNode root) {\n    List<Integer> subtreeSums = new ArrayList<>();\n    int totalSum = calculateSubtreeSums(root, subtreeSums);\n\n    long maxProduct = 0;\n    for (int sum : subtreeSums) {\n        long product = (long) sum * (totalSum - sum);\n        maxProduct = Math.max(maxProduct, product);\n    }\n\n    return (int) (maxProduct % 1000000007);\n}\n\nprivate int calculateSubtreeSums(TreeNode root, List<Integer> subtreeSums) {\n    if (root == null) return 0;\n\n    int leftSum = calculateSubtreeSums(root.left, subtreeSums);\n    int rightSum = calculateSubtreeSums(root.right, subtreeSums);\n    int currentSum = root.val + leftSum + rightSum;\n\n    subtreeSums.add(currentSum);\n    return currentSum;\n}\n\n// Delete Nodes and Return Forest\npublic List<TreeNode> delNodes(TreeNode root, int[] to_delete) {\n    Set<Integer> deleteSet = new HashSet<>();\n    for (int val : to_delete) {\n        deleteSet.add(val);\n    }\n\n    List<TreeNode> forest = new ArrayList<>();\n    if (deleteHelper(root, deleteSet, forest, true) != null) {\n        forest.add(root);\n    }\n\n    return forest;\n}\n\nprivate TreeNode deleteHelper(TreeNode root, Set<Integer> deleteSet,\n                             List<TreeNode> forest, boolean isRoot) {\n    if (root == null) return null;\n\n    boolean shouldDelete = deleteSet.contains(root.val);\n\n    root.left = deleteHelper(root.left, deleteSet, forest, shouldDelete);\n    root.right = deleteHelper(root.right, deleteSet, forest, shouldDelete);\n\n    if (shouldDelete) {\n        if (root.left != null) forest.add(root.left);\n        if (root.right != null) forest.add(root.right);\n        return null;\n    }\n\n    return root;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-11-multi-tree-recursions",children:"Pattern 11: Multi-Tree Recursions"}),"\n",(0,t.jsx)(n.h3,{id:"111-tree-array-operations",children:"11.1 Tree Array Operations"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// All Possible Full Binary Trees\npublic List<TreeNode> allPossibleFBT(int n) {\n    if (n % 2 == 0) return new ArrayList<>();\n\n    Map<Integer, List<TreeNode>> memo = new HashMap<>();\n    return allPossibleFBTHelper(n, memo);\n}\n\nprivate List<TreeNode> allPossibleFBTHelper(int n, Map<Integer, List<TreeNode>> memo) {\n    if (memo.containsKey(n)) return memo.get(n);\n\n    List<TreeNode> result = new ArrayList<>();\n\n    if (n == 1) {\n        result.add(new TreeNode(0));\n        memo.put(n, result);\n        return result;\n    }\n\n    for (int i = 1; i < n; i += 2) {\n        List<TreeNode> leftTrees = allPossibleFBTHelper(i, memo);\n        List<TreeNode> rightTrees = allPossibleFBTHelper(n - i - 1, memo);\n\n        for (TreeNode left : leftTrees) {\n            for (TreeNode right : rightTrees) {\n                TreeNode root = new TreeNode(0);\n                root.left = left;\n                root.right = right;\n                result.add(root);\n            }\n        }\n    }\n\n    memo.put(n, result);\n    return result;\n}\n\n// Unique Binary Search Trees II\npublic List<TreeNode> generateTrees(int n) {\n    return generateTreesHelper(1, n);\n}\n\nprivate List<TreeNode> generateTreesHelper(int start, int end) {\n    List<TreeNode> result = new ArrayList<>();\n\n    if (start > end) {\n        result.add(null);\n        return result;\n    }\n\n    for (int i = start; i <= end; i++) {\n        List<TreeNode> leftTrees = generateTreesHelper(start, i - 1);\n        List<TreeNode> rightTrees = generateTreesHelper(i + 1, end);\n\n        for (TreeNode left : leftTrees) {\n            for (TreeNode right : rightTrees) {\n                TreeNode root = new TreeNode(i);\n                root.left = left;\n                root.right = right;\n                result.add(root);\n            }\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-12-complex-recursive-problems",children:"Pattern 12: Complex Recursive Problems"}),"\n",(0,t.jsx)(n.h3,{id:"121-advanced-tree-algorithms",children:"12.1 Advanced Tree Algorithms"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Vertical Order Traversal\npublic List<List<Integer>> verticalTraversal(TreeNode root) {\n    TreeMap<Integer, TreeMap<Integer, PriorityQueue<Integer>>> map = new TreeMap<>();\n    dfsVertical(root, 0, 0, map);\n\n    List<List<Integer>> result = new ArrayList<>();\n    for (TreeMap<Integer, PriorityQueue<Integer>> levelMap : map.values()) {\n        List<Integer> column = new ArrayList<>();\n        for (PriorityQueue<Integer> pq : levelMap.values()) {\n            while (!pq.isEmpty()) {\n                column.add(pq.poll());\n            }\n        }\n        result.add(column);\n    }\n\n    return result;\n}\n\nprivate void dfsVertical(TreeNode root, int x, int y,\n                        TreeMap<Integer, TreeMap<Integer, PriorityQueue<Integer>>> map) {\n    if (root == null) return;\n\n    map.computeIfAbsent(x, k -> new TreeMap<>())\n       .computeIfAbsent(y, k -> new PriorityQueue<>())\n       .add(root.val);\n\n    dfsVertical(root.left, x - 1, y + 1, map);\n    dfsVertical(root.right, x + 1, y + 1, map);\n}\n\n// Expression Tree Evaluation\npublic int evalTree(TreeNode root) {\n    if (root.left == null && root.right == null) {\n        return root.val; // Leaf node (operand)\n    }\n\n    int leftVal = evalTree(root.left);\n    int rightVal = evalTree(root.right);\n\n    // Root contains operator\n    switch (root.val) {\n        case 2: return leftVal + rightVal; // Addition\n        case 3: return leftVal - rightVal; // Subtraction\n        case 4: return leftVal * rightVal; // Multiplication\n        case 5: return leftVal / rightVal; // Division\n        default: throw new IllegalArgumentException(\"Invalid operator\");\n    }\n}\n\n// Construct Binary Tree from String with Parentheses\npublic TreeNode str2tree(String s) {\n    if (s.isEmpty()) return null;\n\n    int[] index = {0};\n    return str2treeHelper(s, index);\n}\n\nprivate TreeNode str2treeHelper(String s, int[] index) {\n    if (index[0] >= s.length()) return null;\n\n    // Parse number (can be negative)\n    int start = index[0];\n    if (s.charAt(index[0]) == '-') index[0]++;\n\n    while (index[0] < s.length() && Character.isDigit(s.charAt(index[0]))) {\n        index[0]++;\n    }\n\n    TreeNode root = new TreeNode(Integer.parseInt(s.substring(start, index[0])));\n\n    // Parse left child\n    if (index[0] < s.length() && s.charAt(index[0]) == '(') {\n        index[0]++; // Skip '('\n        root.left = str2treeHelper(s, index);\n        index[0]++; // Skip ')'\n    }\n\n    // Parse right child\n    if (index[0] < s.length() && s.charAt(index[0]) == '(') {\n        index[0]++; // Skip '('\n        root.right = str2treeHelper(s, index);\n        index[0]++; // Skip ')'\n    }\n\n    return root;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"time--space-complexity-reference",children:"Time & Space Complexity Reference"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{style:{textAlign:"left"},children:"Pattern"}),(0,t.jsx)(n.th,{style:{textAlign:"left"},children:"Time Complexity"}),(0,t.jsx)(n.th,{style:{textAlign:"left"},children:"Space Complexity"}),(0,t.jsx)(n.th,{style:{textAlign:"left"},children:"Recursion Depth"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Tree Traversal"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(h)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(h)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Tree Properties"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(h)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(h)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Path Problems"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(h)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(h)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Tree Construction"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(h)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Tree Comparison"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(min(n1, n2))"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(h)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(h)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"BST Operations"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(h) to O(n)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(h)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(h)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Tree DP"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(h)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(h)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Multi-tree Generation"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(4^n / \u221an)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(4^n / \u221an)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(n)"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"Where n = number of nodes, h = height of tree"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"best-practices--optimization-tips",children:"Best Practices & Optimization Tips"}),"\n",(0,t.jsx)(n.h3,{id:"recursion-guidelines",children:"Recursion Guidelines"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// 1. Always handle null base case first\npublic int processTree(TreeNode root) {\n    if (root == null) return 0; // Base case first\n\n    // Process current node\n    // Recurse on children\n    // Combine results\n}\n\n// 2. Use helper methods for complex recursions\npublic List<String> complexOperation(TreeNode root) {\n    List<String> result = new ArrayList<>();\n    complexHelper(root, new StringBuilder(), result);\n    return result;\n}\n\nprivate void complexHelper(TreeNode root, StringBuilder path, List<String> result) {\n    // Implementation with additional parameters\n}\n\n// 3. Memoization for overlapping subproblems\nMap<TreeNode, Integer> memo = new HashMap<>();\n\npublic int expensiveOperation(TreeNode root) {\n    if (memo.containsKey(root)) return memo.get(root);\n\n    int result = computeExpensiveResult(root);\n    memo.put(root, result);\n    return result;\n}\n\n// 4. Use arrays for pass-by-reference in Java\npublic int maxValue(TreeNode root) {\n    int[] max = {Integer.MIN_VALUE}; // Wrapper for primitive\n    findMax(root, max);\n    return max[0];\n}\n\nprivate void findMax(TreeNode root, int[] max) {\n    if (root == null) return;\n    max[0] = Math.max(max[0], root.val);\n    findMax(root.left, max);\n    findMax(root.right, max);\n}\n\nint computeExpensiveResult(TreeNode root) { return 0; /* Implementation */ }\n"})}),"\n",(0,t.jsx)(n.h3,{id:"common-pitfalls-to-avoid",children:"Common Pitfalls to Avoid"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Stack Overflow"}),": For very deep trees, consider iterative solutions"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Null Pointer"}),": Always check for null before accessing node properties"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Infinite Recursion"}),": Ensure base cases are handled properly"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Memory Leaks"}),": Be careful with global state and memoization"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Incorrect Backtracking"}),": Remember to undo changes in path-based problems"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"interview-tips1312",children:"Interview Tips[13][12]"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Identify the pattern"})," early: traversal, property check, path problem, etc."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Draw small examples"})," to understand the recursive relationship"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Start with base cases"})," - what happens with null, single node?"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Think about the recursive assumption"})," - assume subproblems are solved"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Consider iterative alternatives"})," for space-constrained environments"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use helper functions"})," to maintain clean interfaces"]}),"\n"]})]})}function c(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>a});var t=r(96540);const o={},i=t.createContext(o);function l(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:l(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);