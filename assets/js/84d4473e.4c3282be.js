"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[96764],{28453:(n,e,r)=>{r.d(e,{R:()=>d,x:()=>s});var t=r(96540);const i={},o=t.createContext(i);function d(n){const e=t.useContext(o);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:d(n.components),t.createElement(o.Provider,{value:e},n.children)}},36858:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>a,contentTitle:()=>d,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var t=r(74848),i=r(28453);const o={},d="Trie Patterns",s={id:"DSA/DSA with Java/Trie Patterns",title:"Trie Patterns",description:"Table of Contents",source:"@site/docs/DSA/DSA with Java/Trie Patterns.mdx",sourceDirName:"DSA/DSA with Java",slug:"/DSA/DSA with Java/Trie Patterns",permalink:"/docs/DSA/DSA with Java/Trie Patterns",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with Java/Trie Patterns.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"String",permalink:"/docs/DSA/DSA with Java/String Patterns"},next:{title:"Two Pointers",permalink:"/docs/DSA/DSA with Java/Two Pointers"}},a={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Trie Fundamentals",id:"trie-fundamentals",level:2},{value:"Core Trie Concepts",id:"core-trie-concepts",level:3},{value:"Basic Trie Implementation",id:"basic-trie-implementation",level:3},{value:"Pattern 1: Basic Trie Operations",id:"pattern-1-basic-trie-operations",level:2},{value:"1.1 Enhanced Trie with Frequency",id:"11-enhanced-trie-with-frequency",level:3},{value:"1.2 Case-Insensitive Trie",id:"12-case-insensitive-trie",level:3},{value:"Pattern 2: Word Search &amp; Dictionary",id:"pattern-2-word-search--dictionary",level:2},{value:"2.1 Word Search II (Trie + Backtracking)",id:"21-word-search-ii-trie--backtracking",level:3},{value:"2.2 Dictionary and Word Validation",id:"22-dictionary-and-word-validation",level:3},{value:"Pattern 3: Prefix-Based Queries",id:"pattern-3-prefix-based-queries",level:2},{value:"3.1 Longest Common Prefix",id:"31-longest-common-prefix",level:3},{value:"3.2 Prefix Count and Queries",id:"32-prefix-count-and-queries",level:3},{value:"Pattern 4: Auto-Complete &amp; Suggestions",id:"pattern-4-auto-complete--suggestions",level:2},{value:"4.1 Auto-Complete System",id:"41-auto-complete-system",level:3},{value:"4.2 Word Suggestions with Fuzzy Matching",id:"42-word-suggestions-with-fuzzy-matching",level:3},{value:"Pattern 5: Word Frequency &amp; Counting",id:"pattern-5-word-frequency--counting",level:2},{value:"5.1 Top K Frequent Words",id:"51-top-k-frequent-words",level:3},{value:"Pattern 6: Longest Common Prefix",id:"pattern-6-longest-common-prefix",level:2},{value:"6.1 LCP with Trie Construction",id:"61-lcp-with-trie-construction",level:3},{value:"Pattern 7: Trie with Backtracking",id:"pattern-7-trie-with-backtracking",level:2},{value:"7.1 Word Break with Trie",id:"71-word-break-with-trie",level:3},{value:"Pattern 8: Compressed Trie (Patricia Tree)",id:"pattern-8-compressed-trie-patricia-tree",level:2},{value:"8.1 Patricia Tree Implementation",id:"81-patricia-tree-implementation",level:3},{value:"Pattern 9: Trie for Number Storage",id:"pattern-9-trie-for-number-storage",level:2},{value:"9.1 XOR Trie for Maximum XOR",id:"91-xor-trie-for-maximum-xor",level:3},{value:"9.2 Range XOR Queries",id:"92-range-xor-queries",level:3},{value:"Pattern 10: Suffix Trie",id:"pattern-10-suffix-trie",level:2},{value:"10.1 Suffix Trie Implementation",id:"101-suffix-trie-implementation",level:3},{value:"Pattern 11: Advanced Trie Applications",id:"pattern-11-advanced-trie-applications",level:2},{value:"11.1 Replace Words",id:"111-replace-words",level:3},{value:"11.2 Concatenated Words",id:"112-concatenated-words",level:3},{value:"Pattern 12: Trie Optimization Techniques",id:"pattern-12-trie-optimization-techniques",level:2},{value:"12.1 Memory-Optimized Trie",id:"121-memory-optimized-trie",level:3},{value:"12.2 Persistent Trie (Immutable)",id:"122-persistent-trie-immutable",level:3},{value:"Time &amp; Space Complexity Reference",id:"time--space-complexity-reference",level:2},{value:"Best Practices &amp; Optimization Tips",id:"best-practices--optimization-tips",level:2},{value:"Trie Implementation Guidelines",id:"trie-implementation-guidelines",level:3},{value:"Common Pitfalls to Avoid",id:"common-pitfalls-to-avoid",level:3},{value:"Interview Tips",id:"interview-tips",level:3}];function l(n){const e={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"trie-patterns",children:"Trie Patterns"})}),"\n",(0,t.jsx)(e.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#trie-fundamentals",children:"Trie Fundamentals"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-1-basic-trie-operations",children:"Pattern 1: Basic Trie Operations"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-2-word-search--dictionary",children:"Pattern 2: Word Search & Dictionary"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-3-prefix-based-queries",children:"Pattern 3: Prefix-Based Queries"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-4-auto-complete--suggestions",children:"Pattern 4: Auto-Complete & Suggestions"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-5-word-frequency--counting",children:"Pattern 5: Word Frequency & Counting"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-6-longest-common-prefix",children:"Pattern 6: Longest Common Prefix"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-7-trie-with-backtracking",children:"Pattern 7: Trie with Backtracking"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-8-compressed-trie-patricia-tree",children:"Pattern 8: Compressed Trie (Patricia Tree)"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-9-trie-for-number-storage",children:"Pattern 9: Trie for Number Storage"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-10-suffix-trie",children:"Pattern 10: Suffix Trie"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-11-advanced-trie-applications",children:"Pattern 11: Advanced Trie Applications"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-12-trie-optimization-techniques",children:"Pattern 12: Trie Optimization Techniques"})}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"trie-fundamentals",children:"Trie Fundamentals"}),"\n",(0,t.jsx)(e.h3,{id:"core-trie-concepts",children:"Core Trie Concepts"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Basic Trie Node Structure\nclass TrieNode {\n    Map<Character, TrieNode> children;\n    boolean isEndOfWord;\n    int frequency; // For counting word occurrences\n    String word;   // Optional: store complete word at end nodes\n\n    public TrieNode() {\n        children = new HashMap<>();\n        isEndOfWord = false;\n        frequency = 0;\n        word = null;\n    }\n}\n\n// Alternative Array-based Node (for English letters only)\nclass ArrayTrieNode {\n    ArrayTrieNode[] children;\n    boolean isEndOfWord;\n    int frequency;\n    static final int ALPHABET_SIZE = 26;\n\n    public ArrayTrieNode() {\n        children = new ArrayTrieNode[ALPHABET_SIZE];\n        isEndOfWord = false;\n        frequency = 0;\n    }\n\n    // Helper method to get index for character\n    private int getIndex(char c) {\n        return c - 'a';\n    }\n\n    // Check if character exists\n    public boolean hasChild(char c) {\n        return children[getIndex(c)] != null;\n    }\n\n    // Get child node for character\n    public ArrayTrieNode getChild(char c) {\n        return children[getIndex(c)];\n    }\n\n    // Set child node for character\n    public void setChild(char c, ArrayTrieNode node) {\n        children[getIndex(c)] = node;\n    }\n}\n\n// Enhanced Trie Node with additional features\nclass EnhancedTrieNode {\n    Map<Character, EnhancedTrieNode> children;\n    boolean isEndOfWord;\n    int frequency;\n    int prefixCount; // Count of words with this prefix\n    String word;\n    Set<String> wordSet; // All words passing through this node\n\n    public EnhancedTrieNode() {\n        children = new HashMap<>();\n        isEndOfWord = false;\n        frequency = 0;\n        prefixCount = 0;\n        word = null;\n        wordSet = new HashSet<>();\n    }\n}\n\n// Trie Interface for different implementations\ninterface Trie {\n    void insert(String word);\n    boolean search(String word);\n    boolean startsWith(String prefix);\n    void delete(String word);\n    List<String> getAllWords();\n    List<String> getWordsWithPrefix(String prefix);\n    int countWords();\n    int countWordsWithPrefix(String prefix);\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"basic-trie-implementation",children:"Basic Trie Implementation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Standard Trie Implementation\npublic class StandardTrie implements Trie {\n    private TrieNode root;\n\n    public StandardTrie() {\n        root = new TrieNode();\n    }\n\n    @Override\n    public void insert(String word) {\n        if (word == null || word.isEmpty()) return;\n\n        TrieNode current = root;\n\n        for (char c : word.toCharArray()) {\n            current.children.putIfAbsent(c, new TrieNode());\n            current = current.children.get(c);\n        }\n\n        current.isEndOfWord = true;\n        current.frequency++;\n        current.word = word; // Store complete word\n    }\n\n    @Override\n    public boolean search(String word) {\n        if (word == null) return false;\n\n        TrieNode node = searchNode(word);\n        return node != null && node.isEndOfWord;\n    }\n\n    @Override\n    public boolean startsWith(String prefix) {\n        if (prefix == null) return false;\n\n        return searchNode(prefix) != null;\n    }\n\n    // Helper method to find node for given string\n    private TrieNode searchNode(String str) {\n        TrieNode current = root;\n\n        for (char c : str.toCharArray()) {\n            if (!current.children.containsKey(c)) {\n                return null;\n            }\n            current = current.children.get(c);\n        }\n\n        return current;\n    }\n\n    @Override\n    public void delete(String word) {\n        if (word == null || !search(word)) return;\n\n        deleteHelper(root, word, 0);\n    }\n\n    private boolean deleteHelper(TrieNode current, String word, int index) {\n        if (index == word.length()) {\n            // We're at the end of the word\n            if (!current.isEndOfWord) return false;\n\n            current.isEndOfWord = false;\n            current.frequency = 0;\n            current.word = null;\n\n            // Return true if current has no children (can be deleted)\n            return current.children.isEmpty();\n        }\n\n        char c = word.charAt(index);\n        TrieNode node = current.children.get(c);\n\n        if (node == null) return false;\n\n        boolean shouldDeleteChild = deleteHelper(node, word, index + 1);\n\n        if (shouldDeleteChild) {\n            current.children.remove(c);\n\n            // Return true if current has no children and is not end of another word\n            return !current.isEndOfWord && current.children.isEmpty();\n        }\n\n        return false;\n    }\n\n    @Override\n    public List<String> getAllWords() {\n        List<String> words = new ArrayList<>();\n        getAllWordsHelper(root, words);\n        return words;\n    }\n\n    private void getAllWordsHelper(TrieNode node, List<String> words) {\n        if (node.isEndOfWord) {\n            words.add(node.word);\n        }\n\n        for (TrieNode child : node.children.values()) {\n            getAllWordsHelper(child, words);\n        }\n    }\n\n    @Override\n    public List<String> getWordsWithPrefix(String prefix) {\n        List<String> words = new ArrayList<>();\n        TrieNode prefixNode = searchNode(prefix);\n\n        if (prefixNode != null) {\n            getAllWordsHelper(prefixNode, words);\n        }\n\n        return words;\n    }\n\n    @Override\n    public int countWords() {\n        return countWordsHelper(root);\n    }\n\n    private int countWordsHelper(TrieNode node) {\n        int count = node.isEndOfWord ? 1 : 0;\n\n        for (TrieNode child : node.children.values()) {\n            count += countWordsHelper(child);\n        }\n\n        return count;\n    }\n\n    @Override\n    public int countWordsWithPrefix(String prefix) {\n        TrieNode prefixNode = searchNode(prefix);\n        return prefixNode != null ? countWordsHelper(prefixNode) : 0;\n    }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-1-basic-trie-operations",children:"Pattern 1: Basic Trie Operations"}),"\n",(0,t.jsx)(e.h3,{id:"11-enhanced-trie-with-frequency",children:"1.1 Enhanced Trie with Frequency"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Trie with word frequency tracking\npublic class FrequencyTrie {\n    private TrieNode root;\n\n    public FrequencyTrie() {\n        root = new TrieNode();\n    }\n\n    // Insert word and increment frequency\n    public void insert(String word) {\n        TrieNode current = root;\n\n        for (char c : word.toCharArray()) {\n            current.children.putIfAbsent(c, new TrieNode());\n            current = current.children.get(c);\n        }\n\n        current.isEndOfWord = true;\n        current.frequency++;\n        current.word = word;\n    }\n\n    // Get frequency of a word\n    public int getWordFrequency(String word) {\n        TrieNode node = searchNode(word);\n        return (node != null && node.isEndOfWord) ? node.frequency : 0;\n    }\n\n    // Count words starting with prefix\n    public int countWordsStartingWith(String prefix) {\n        TrieNode prefixNode = searchNode(prefix);\n        return prefixNode != null ? countWordsInSubtree(prefixNode) : 0;\n    }\n\n    private int countWordsInSubtree(TrieNode node) {\n        int count = node.isEndOfWord ? node.frequency : 0;\n\n        for (TrieNode child : node.children.values()) {\n            count += countWordsInSubtree(child);\n        }\n\n        return count;\n    }\n\n    // Erase one occurrence of word\n    public void eraseWord(String word) {\n        TrieNode node = searchNode(word);\n        if (node != null && node.isEndOfWord && node.frequency > 0) {\n            node.frequency--;\n            if (node.frequency == 0) {\n                node.isEndOfWord = false;\n                node.word = null;\n            }\n        }\n    }\n\n    // Get most frequent words with given prefix\n    public List<String> getMostFrequentWithPrefix(String prefix, int k) {\n        TrieNode prefixNode = searchNode(prefix);\n        if (prefixNode == null) return new ArrayList<>();\n\n        PriorityQueue<WordFrequency> maxHeap = new PriorityQueue<>(\n            (a, b) -> Integer.compare(b.frequency, a.frequency)\n        );\n\n        collectWordsWithFrequency(prefixNode, maxHeap);\n\n        List<String> result = new ArrayList<>();\n        while (k > 0 && !maxHeap.isEmpty()) {\n            result.add(maxHeap.poll().word);\n            k--;\n        }\n\n        return result;\n    }\n\n    private void collectWordsWithFrequency(TrieNode node, PriorityQueue<WordFrequency> heap) {\n        if (node.isEndOfWord) {\n            heap.offer(new WordFrequency(node.word, node.frequency));\n        }\n\n        for (TrieNode child : node.children.values()) {\n            collectWordsWithFrequency(child, heap);\n        }\n    }\n\n    private TrieNode searchNode(String str) {\n        TrieNode current = root;\n\n        for (char c : str.toCharArray()) {\n            if (!current.children.containsKey(c)) {\n                return null;\n            }\n            current = current.children.get(c);\n        }\n\n        return current;\n    }\n\n    static class WordFrequency {\n        String word;\n        int frequency;\n\n        WordFrequency(String word, int frequency) {\n            this.word = word;\n            this.frequency = frequency;\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"12-case-insensitive-trie",children:"1.2 Case-Insensitive Trie"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Case-insensitive Trie implementation\npublic class CaseInsensitiveTrie {\n    private TrieNode root;\n\n    public CaseInsensitiveTrie() {\n        root = new TrieNode();\n    }\n\n    public void insert(String word) {\n        if (word == null) return;\n\n        String normalizedWord = normalize(word);\n        TrieNode current = root;\n\n        for (char c : normalizedWord.toCharArray()) {\n            current.children.putIfAbsent(c, new TrieNode());\n            current = current.children.get(c);\n        }\n\n        current.isEndOfWord = true;\n        current.word = word; // Store original case\n    }\n\n    public boolean search(String word) {\n        if (word == null) return false;\n\n        String normalizedWord = normalize(word);\n        TrieNode node = searchNode(normalizedWord);\n        return node != null && node.isEndOfWord;\n    }\n\n    public boolean startsWith(String prefix) {\n        if (prefix == null) return false;\n\n        String normalizedPrefix = normalize(prefix);\n        return searchNode(normalizedPrefix) != null;\n    }\n\n    public List<String> getWordsWithPrefix(String prefix) {\n        if (prefix == null) return new ArrayList<>();\n\n        String normalizedPrefix = normalize(prefix);\n        TrieNode prefixNode = searchNode(normalizedPrefix);\n\n        if (prefixNode == null) return new ArrayList<>();\n\n        List<String> words = new ArrayList<>();\n        collectWords(prefixNode, words);\n        return words;\n    }\n\n    private String normalize(String str) {\n        return str.toLowerCase().trim();\n    }\n\n    private TrieNode searchNode(String str) {\n        TrieNode current = root;\n\n        for (char c : str.toCharArray()) {\n            if (!current.children.containsKey(c)) {\n                return null;\n            }\n            current = current.children.get(c);\n        }\n\n        return current;\n    }\n\n    private void collectWords(TrieNode node, List<String> words) {\n        if (node.isEndOfWord) {\n            words.add(node.word);\n        }\n\n        for (TrieNode child : node.children.values()) {\n            collectWords(child, words);\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-2-word-search--dictionary",children:"Pattern 2: Word Search & Dictionary"}),"\n",(0,t.jsx)(e.h3,{id:"21-word-search-ii-trie--backtracking",children:"2.1 Word Search II (Trie + Backtracking)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Word Search II - Find all words in board using Trie\npublic class WordSearchII {\n\n    public List<String> findWords(char[][] board, String[] words) {\n        // Build Trie from words\n        TrieNode root = buildTrie(words);\n\n        Set<String> result = new HashSet<>();\n        int m = board.length, n = board[_0].length;\n        boolean[][] visited = new boolean[m][n];\n\n        // Start DFS from each cell\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                dfs(board, i, j, root, visited, result);\n            }\n        }\n\n        return new ArrayList<>(result);\n    }\n\n    private void dfs(char[][] board, int row, int col, TrieNode node,\n                    boolean[][] visited, Set<String> result) {\n        if (row < 0 || row >= board.length || col < 0 || col >= board[_0].length ||\n            visited[row][col] || !node.children.containsKey(board[row][col])) {\n            return;\n        }\n\n        visited[row][col] = true;\n        TrieNode nextNode = node.children.get(board[row][col]);\n\n        // Found a word\n        if (nextNode.isEndOfWord) {\n            result.add(nextNode.word);\n            // Optional: remove word from Trie to avoid duplicates\n            nextNode.isEndOfWord = false;\n        }\n\n        // Explore all 4 directions\n        int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n        for (int[] dir : directions) {\n            dfs(board, row + dir[_0], col + dir[_1], nextNode, visited, result);\n        }\n\n        visited[row][col] = false; // Backtrack\n    }\n\n    private TrieNode buildTrie(String[] words) {\n        TrieNode root = new TrieNode();\n\n        for (String word : words) {\n            TrieNode current = root;\n\n            for (char c : word.toCharArray()) {\n                current.children.putIfAbsent(c, new TrieNode());\n                current = current.children.get(c);\n            }\n\n            current.isEndOfWord = true;\n            current.word = word;\n        }\n\n        return root;\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"22-dictionary-and-word-validation",children:"2.2 Dictionary and Word Validation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Dictionary with spell checking and suggestions\npublic class SpellChecker {\n    private StandardTrie dictionary;\n\n    public SpellChecker() {\n        dictionary = new StandardTrie();\n    }\n\n    // Load dictionary words\n    public void loadDictionary(List<String> words) {\n        for (String word : words) {\n            dictionary.insert(word.toLowerCase());\n        }\n    }\n\n    // Check if word is correctly spelled\n    public boolean isCorrect(String word) {\n        return dictionary.search(word.toLowerCase());\n    }\n\n    // Get spelling suggestions using edit distance\n    public List<String> getSuggestions(String word, int maxDistance) {\n        List<String> suggestions = new ArrayList<>();\n        String normalizedWord = word.toLowerCase();\n\n        // Get all words from dictionary\n        List<String> allWords = dictionary.getAllWords();\n\n        for (String dictWord : allWords) {\n            if (editDistance(normalizedWord, dictWord) <= maxDistance) {\n                suggestions.add(dictWord);\n            }\n        }\n\n        return suggestions;\n    }\n\n    // Get suggestions based on prefix matching\n    public List<String> getPrefixSuggestions(String prefix, int limit) {\n        List<String> suggestions = dictionary.getWordsWithPrefix(prefix.toLowerCase());\n\n        return suggestions.stream()\n                .limit(limit)\n                .collect(Collectors.toList());\n    }\n\n    // Calculate edit distance between two strings\n    private int editDistance(String word1, String word2) {\n        int m = word1.length(), n = word2.length();\n        int[][] dp = new int[m + 1][n + 1];\n\n        // Initialize base cases\n        for (int i = 0; i <= m; i++) dp[i][_0] = i;\n        for (int j = 0; j <= n; j++) dp[_0][j] = j;\n\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1];\n                } else {\n                    dp[i][j] = 1 + Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]),\n                                           dp[i - 1][j - 1]);\n                }\n            }\n        }\n\n        return dp[m][n];\n    }\n\n    // Find anagrams of a word\n    public List<String> findAnagrams(String word) {\n        String sortedWord = sortString(word.toLowerCase());\n        List<String> anagrams = new ArrayList<>();\n\n        for (String dictWord : dictionary.getAllWords()) {\n            if (dictWord.length() == word.length() &&\n                !dictWord.equals(word.toLowerCase()) &&\n                sortString(dictWord).equals(sortedWord)) {\n                anagrams.add(dictWord);\n            }\n        }\n\n        return anagrams;\n    }\n\n    private String sortString(String str) {\n        char[] chars = str.toCharArray();\n        Arrays.sort(chars);\n        return new String(chars);\n    }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-3-prefix-based-queries",children:"Pattern 3: Prefix-Based Queries"}),"\n",(0,t.jsx)(e.h3,{id:"31-longest-common-prefix",children:"3.1 Longest Common Prefix"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:'// Find longest common prefix among all words in Trie\npublic class LongestCommonPrefix {\n\n    public String longestCommonPrefix(String[] strs) {\n        if (strs == null || strs.length == 0) return "";\n\n        StandardTrie trie = new StandardTrie();\n\n        // Insert all strings into Trie\n        for (String str : strs) {\n            trie.insert(str);\n        }\n\n        return findLCP(trie);\n    }\n\n    private String findLCP(StandardTrie trie) {\n        StringBuilder lcp = new StringBuilder();\n        TrieNode current = trie.root;\n\n        while (current.children.size() == 1 && !current.isEndOfWord) {\n            Map.Entry<Character, TrieNode> entry = current.children.entrySet().iterator().next();\n            lcp.append(entry.getKey());\n            current = entry.getValue();\n        }\n\n        return lcp.toString();\n    }\n\n    // Find longest common prefix between two specific words\n    public String longestCommonPrefixBetween(String word1, String word2) {\n        int minLength = Math.min(word1.length(), word2.length());\n        StringBuilder lcp = new StringBuilder();\n\n        for (int i = 0; i < minLength; i++) {\n            if (word1.charAt(i) == word2.charAt(i)) {\n                lcp.append(word1.charAt(i));\n            } else {\n                break;\n            }\n        }\n\n        return lcp.toString();\n    }\n\n    // Get all pairs with longest common prefix of given length\n    public List<String[]> getPairsWithLCPLength(String[] words, int targetLength) {\n        List<String[]> pairs = new ArrayList<>();\n\n        for (int i = 0; i < words.length; i++) {\n            for (int j = i + 1; j < words.length; j++) {\n                String lcp = longestCommonPrefixBetween(words[i], words[j]);\n                if (lcp.length() == targetLength) {\n                    pairs.add(new String[]{words[i], words[j]});\n                }\n            }\n        }\n\n        return pairs;\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"32-prefix-count-and-queries",children:"3.2 Prefix Count and Queries"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Trie with efficient prefix counting\npublic class PrefixCountTrie {\n    private EnhancedTrieNode root;\n\n    public PrefixCountTrie() {\n        root = new EnhancedTrieNode();\n    }\n\n    public void insert(String word) {\n        EnhancedTrieNode current = root;\n\n        for (char c : word.toCharArray()) {\n            current.children.putIfAbsent(c, new EnhancedTrieNode());\n            current = current.children.get(c);\n            current.prefixCount++; // Increment prefix count\n        }\n\n        current.isEndOfWord = true;\n        current.frequency++;\n        current.word = word;\n    }\n\n    public int countWordsWithPrefix(String prefix) {\n        EnhancedTrieNode node = searchNode(prefix);\n        return node != null ? node.prefixCount : 0;\n    }\n\n    public boolean search(String word) {\n        EnhancedTrieNode node = searchNode(word);\n        return node != null && node.isEndOfWord;\n    }\n\n    public boolean startsWith(String prefix) {\n        return searchNode(prefix) != null;\n    }\n\n    // Erase word and update prefix counts\n    public void erase(String word) {\n        if (!search(word)) return;\n\n        EnhancedTrieNode current = root;\n        List<EnhancedTrieNode> path = new ArrayList<>();\n        path.add(current);\n\n        // Build path to word\n        for (char c : word.toCharArray()) {\n            current = current.children.get(c);\n            path.add(current);\n        }\n\n        // Update counts along the path\n        for (int i = 1; i < path.size(); i++) {\n            path.get(i).prefixCount--;\n        }\n\n        // Mark as not end of word\n        current.isEndOfWord = false;\n        current.frequency = 0;\n        current.word = null;\n    }\n\n    private EnhancedTrieNode searchNode(String str) {\n        EnhancedTrieNode current = root;\n\n        for (char c : str.toCharArray()) {\n            if (!current.children.containsKey(c)) {\n                return null;\n            }\n            current = current.children.get(c);\n        }\n\n        return current;\n    }\n\n    // Get all prefixes of a word that exist in Trie\n    public List<String> getAllPrefixes(String word) {\n        List<String> prefixes = new ArrayList<>();\n        EnhancedTrieNode current = root;\n        StringBuilder prefix = new StringBuilder();\n\n        for (char c : word.toCharArray()) {\n            if (!current.children.containsKey(c)) {\n                break;\n            }\n\n            current = current.children.get(c);\n            prefix.append(c);\n\n            if (current.isEndOfWord) {\n                prefixes.add(prefix.toString());\n            }\n        }\n\n        return prefixes;\n    }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-4-auto-complete--suggestions",children:"Pattern 4: Auto-Complete & Suggestions"}),"\n",(0,t.jsx)(e.h3,{id:"41-auto-complete-system",children:"4.1 Auto-Complete System"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Auto-complete system with ranking\npublic class AutocompleteSystem {\n    private TrieNode root;\n    private TrieNode currentNode;\n    private StringBuilder currentPrefix;\n\n    public AutocompleteSystem(String[] sentences, int[] times) {\n        root = new TrieNode();\n        currentNode = root;\n        currentPrefix = new StringBuilder();\n\n        // Build initial Trie with historical data\n        for (int i = 0; i < sentences.length; i++) {\n            insert(sentences[i], times[i]);\n        }\n    }\n\n    public List<String> input(char c) {\n        if (c == '#') {\n            // End of input - store the sentence\n            String sentence = currentPrefix.toString();\n            insert(sentence, 1);\n\n            // Reset for next input\n            currentNode = root;\n            currentPrefix = new StringBuilder();\n            return new ArrayList<>();\n        }\n\n        currentPrefix.append(c);\n\n        if (currentNode != null && currentNode.children.containsKey(c)) {\n            currentNode = currentNode.children.get(c);\n            return getTop3Suggestions(currentNode);\n        } else {\n            currentNode = null; // No matching prefix\n            return new ArrayList<>();\n        }\n    }\n\n    private void insert(String sentence, int frequency) {\n        TrieNode current = root;\n\n        for (char c : sentence.toCharArray()) {\n            current.children.putIfAbsent(c, new TrieNode());\n            current = current.children.get(c);\n        }\n\n        current.isEndOfWord = true;\n        current.frequency += frequency;\n        current.word = sentence;\n    }\n\n    private List<String> getTop3Suggestions(TrieNode node) {\n        List<SentenceFrequency> candidates = new ArrayList<>();\n        collectSentences(node, candidates);\n\n        // Sort by frequency (desc) then lexicographically (asc)\n        candidates.sort((a, b) -> {\n            if (a.frequency != b.frequency) {\n                return Integer.compare(b.frequency, a.frequency);\n            }\n            return a.sentence.compareTo(b.sentence);\n        });\n\n        return candidates.stream()\n                .limit(3)\n                .map(sf -> sf.sentence)\n                .collect(Collectors.toList());\n    }\n\n    private void collectSentences(TrieNode node, List<SentenceFrequency> candidates) {\n        if (node.isEndOfWord) {\n            candidates.add(new SentenceFrequency(node.word, node.frequency));\n        }\n\n        for (TrieNode child : node.children.values()) {\n            collectSentences(child, candidates);\n        }\n    }\n\n    static class SentenceFrequency {\n        String sentence;\n        int frequency;\n\n        SentenceFrequency(String sentence, int frequency) {\n            this.sentence = sentence;\n            this.frequency = frequency;\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"42-word-suggestions-with-fuzzy-matching",children:"4.2 Word Suggestions with Fuzzy Matching"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Auto-complete with fuzzy matching (allows typos)\npublic class FuzzyAutoComplete {\n    private StandardTrie trie;\n\n    public FuzzyAutoComplete() {\n        trie = new StandardTrie();\n    }\n\n    public void addWord(String word) {\n        trie.insert(word.toLowerCase());\n    }\n\n    // Get suggestions allowing up to maxEdits character edits\n    public List<String> getSuggestions(String prefix, int maxEdits, int limit) {\n        List<SuggestionScore> suggestions = new ArrayList<>();\n        String normalizedPrefix = prefix.toLowerCase();\n\n        // Get all words and calculate edit distance\n        List<String> allWords = trie.getAllWords();\n\n        for (String word : allWords) {\n            int editDist = calculateEditDistance(normalizedPrefix, word.substring(0,\n                Math.min(word.length(), normalizedPrefix.length())));\n\n            if (editDist <= maxEdits) {\n                int score = calculateScore(word, normalizedPrefix, editDist);\n                suggestions.add(new SuggestionScore(word, score, editDist));\n            }\n        }\n\n        // Sort by score (higher is better)\n        suggestions.sort((a, b) -> Integer.compare(b.score, a.score));\n\n        return suggestions.stream()\n                .limit(limit)\n                .map(s -> s.word)\n                .collect(Collectors.toList());\n    }\n\n    private int calculateScore(String word, String prefix, int editDistance) {\n        int score = 1000 - editDistance * 10; // Penalize edit distance\n\n        // Bonus for exact prefix match\n        if (word.startsWith(prefix)) {\n            score += 100;\n        }\n\n        // Bonus for shorter words (more likely to be what user wants)\n        score += Math.max(0, 50 - word.length());\n\n        return score;\n    }\n\n    private int calculateEditDistance(String s1, String s2) {\n        int m = s1.length(), n = s2.length();\n        int[][] dp = new int[m + 1][n + 1];\n\n        for (int i = 0; i <= m; i++) dp[i][_0] = i;\n        for (int j = 0; j <= n; j++) dp[_0][j] = j;\n\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1];\n                } else {\n                    dp[i][j] = 1 + Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]),\n                                           dp[i - 1][j - 1]);\n                }\n            }\n        }\n\n        return dp[m][n];\n    }\n\n    static class SuggestionScore {\n        String word;\n        int score;\n        int editDistance;\n\n        SuggestionScore(String word, int score, int editDistance) {\n            this.word = word;\n            this.score = score;\n            this.editDistance = editDistance;\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-5-word-frequency--counting",children:"Pattern 5: Word Frequency & Counting"}),"\n",(0,t.jsx)(e.h3,{id:"51-top-k-frequent-words",children:"5.1 Top K Frequent Words"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Find top K frequent words with Trie\npublic class TopKFrequentWords {\n\n    public List<String> topKFrequent(String[] words, int k) {\n        FrequencyTrie trie = new FrequencyTrie();\n\n        // Insert all words\n        for (String word : words) {\n            trie.insert(word);\n        }\n\n        // Get all words with frequencies\n        List<WordFrequency> wordFreqs = new ArrayList<>();\n        collectWordFrequencies(trie.root, wordFreqs);\n\n        // Sort by frequency (desc) then lexicographically (asc)\n        wordFreqs.sort((a, b) -> {\n            if (a.frequency != b.frequency) {\n                return Integer.compare(b.frequency, a.frequency);\n            }\n            return a.word.compareTo(b.word);\n        });\n\n        return wordFreqs.stream()\n                .limit(k)\n                .map(wf -> wf.word)\n                .collect(Collectors.toList());\n    }\n\n    private void collectWordFrequencies(TrieNode node, List<WordFrequency> wordFreqs) {\n        if (node.isEndOfWord) {\n            wordFreqs.add(new WordFrequency(node.word, node.frequency));\n        }\n\n        for (TrieNode child : node.children.values()) {\n            collectWordFrequencies(child, wordFreqs);\n        }\n    }\n\n    // Alternative using heap for large datasets\n    public List<String> topKFrequentHeap(String[] words, int k) {\n        FrequencyTrie trie = new FrequencyTrie();\n\n        for (String word : words) {\n            trie.insert(word);\n        }\n\n        // Use min-heap to maintain top k elements\n        PriorityQueue<WordFrequency> minHeap = new PriorityQueue<>((a, b) -> {\n            if (a.frequency != b.frequency) {\n                return Integer.compare(a.frequency, b.frequency);\n            }\n            return b.word.compareTo(a.word); // Reverse lexicographic for min-heap\n        });\n\n        collectTopK(trie.root, minHeap, k);\n\n        List<String> result = new ArrayList<>();\n        while (!minHeap.isEmpty()) {\n            result.add(0, minHeap.poll().word); // Add at beginning to reverse order\n        }\n\n        return result;\n    }\n\n    private void collectTopK(TrieNode node, PriorityQueue<WordFrequency> minHeap, int k) {\n        if (node.isEndOfWord) {\n            if (minHeap.size() < k) {\n                minHeap.offer(new WordFrequency(node.word, node.frequency));\n            } else if (shouldReplace(minHeap.peek(), node)) {\n                minHeap.poll();\n                minHeap.offer(new WordFrequency(node.word, node.frequency));\n            }\n        }\n\n        for (TrieNode child : node.children.values()) {\n            collectTopK(child, minHeap, k);\n        }\n    }\n\n    private boolean shouldReplace(WordFrequency current, TrieNode newNode) {\n        if (newNode.frequency > current.frequency) return true;\n        if (newNode.frequency < current.frequency) return false;\n        return newNode.word.compareTo(current.word) < 0;\n    }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-6-longest-common-prefix",children:"Pattern 6: Longest Common Prefix"}),"\n",(0,t.jsx)(e.h3,{id:"61-lcp-with-trie-construction",children:"6.1 LCP with Trie Construction"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:'// Find longest common prefix using Trie\npublic class TrieLongestCommonPrefix {\n\n    public String longestCommonPrefix(String[] strs) {\n        if (strs == null || strs.length == 0) return "";\n        if (strs.length == 1) return strs[_0];\n\n        TrieNode root = buildTrie(strs);\n        return findLongestCommonPrefix(root, strs.length);\n    }\n\n    private TrieNode buildTrie(String[] strs) {\n        TrieNode root = new TrieNode();\n\n        for (String str : strs) {\n            TrieNode current = root;\n\n            for (char c : str.toCharArray()) {\n                current.children.putIfAbsent(c, new TrieNode());\n                current = current.children.get(c);\n                current.frequency++; // Count how many strings pass through this node\n            }\n\n            current.isEndOfWord = true;\n        }\n\n        return root;\n    }\n\n    private String findLongestCommonPrefix(TrieNode root, int totalStrings) {\n        StringBuilder lcp = new StringBuilder();\n        TrieNode current = root;\n\n        while (current.children.size() == 1 && !current.isEndOfWord) {\n            Map.Entry<Character, TrieNode> entry = current.children.entrySet().iterator().next();\n            TrieNode child = entry.getValue();\n\n            // Check if all strings pass through this node\n            if (child.frequency == totalStrings) {\n                lcp.append(entry.getKey());\n                current = child;\n            } else {\n                break;\n            }\n        }\n\n        return lcp.toString();\n    }\n\n    // Find longest common prefix of any two strings in array\n    public String longestCommonPrefixAnyTwo(String[] strs) {\n        String maxLCP = "";\n\n        for (int i = 0; i < strs.length; i++) {\n            for (int j = i + 1; j < strs.length; j++) {\n                String lcp = longestCommonPrefixTwo(strs[i], strs[j]);\n                if (lcp.length() > maxLCP.length()) {\n                    maxLCP = lcp;\n                }\n            }\n        }\n\n        return maxLCP;\n    }\n\n    private String longestCommonPrefixTwo(String str1, String str2) {\n        int minLength = Math.min(str1.length(), str2.length());\n        StringBuilder lcp = new StringBuilder();\n\n        for (int i = 0; i < minLength; i++) {\n            if (str1.charAt(i) == str2.charAt(i)) {\n                lcp.append(str1.charAt(i));\n            } else {\n                break;\n            }\n        }\n\n        return lcp.toString();\n    }\n}\n'})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-7-trie-with-backtracking",children:"Pattern 7: Trie with Backtracking"}),"\n",(0,t.jsx)(e.h3,{id:"71-word-break-with-trie",children:"7.1 Word Break with Trie"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:'// Word Break problem using Trie\npublic class WordBreakTrie {\n\n    public boolean wordBreak(String s, List<String> wordDict) {\n        StandardTrie trie = new StandardTrie();\n\n        // Build Trie from dictionary\n        for (String word : wordDict) {\n            trie.insert(word);\n        }\n\n        Boolean[] memo = new Boolean[s.length()];\n        return wordBreakHelper(s, 0, trie, memo);\n    }\n\n    private boolean wordBreakHelper(String s, int start, StandardTrie trie, Boolean[] memo) {\n        if (start == s.length()) return true;\n\n        if (memo[start] != null) return memo[start];\n\n        TrieNode current = trie.root;\n\n        for (int end = start; end < s.length(); end++) {\n            char c = s.charAt(end);\n\n            if (!current.children.containsKey(c)) {\n                break; // No word in dictionary starts with this prefix\n            }\n\n            current = current.children.get(c);\n\n            // Found a complete word\n            if (current.isEndOfWord) {\n                if (wordBreakHelper(s, end + 1, trie, memo)) {\n                    memo[start] = true;\n                    return true;\n                }\n            }\n        }\n\n        memo[start] = false;\n        return false;\n    }\n\n    // Word Break II - Return all possible sentences\n    public List<String> wordBreakII(String s, List<String> wordDict) {\n        StandardTrie trie = new StandardTrie();\n\n        for (String word : wordDict) {\n            trie.insert(word);\n        }\n\n        Map<Integer, List<String>> memo = new HashMap<>();\n        return wordBreakAllHelper(s, 0, trie, memo);\n    }\n\n    private List<String> wordBreakAllHelper(String s, int start, StandardTrie trie,\n                                           Map<Integer, List<String>> memo) {\n        if (memo.containsKey(start)) {\n            return memo.get(start);\n        }\n\n        List<String> result = new ArrayList<>();\n\n        if (start == s.length()) {\n            result.add("");\n            return result;\n        }\n\n        TrieNode current = trie.root;\n\n        for (int end = start; end < s.length(); end++) {\n            char c = s.charAt(end);\n\n            if (!current.children.containsKey(c)) {\n                break;\n            }\n\n            current = current.children.get(c);\n\n            if (current.isEndOfWord) {\n                String word = s.substring(start, end + 1);\n                List<String> suffixes = wordBreakAllHelper(s, end + 1, trie, memo);\n\n                for (String suffix : suffixes) {\n                    result.add(word + (suffix.isEmpty() ? "" : " " + suffix));\n                }\n            }\n        }\n\n        memo.put(start, result);\n        return result;\n    }\n}\n'})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-8-compressed-trie-patricia-tree",children:"Pattern 8: Compressed Trie (Patricia Tree)"}),"\n",(0,t.jsx)(e.h3,{id:"81-patricia-tree-implementation",children:"8.1 Patricia Tree Implementation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Compressed Trie (Patricia Tree) - stores strings more efficiently\npublic class PatriciaTree {\n\n    static class PatriciaNode {\n        Map<String, PatriciaNode> children;\n        boolean isEndOfWord;\n        String word;\n\n        PatriciaNode() {\n            children = new HashMap<>();\n            isEndOfWord = false;\n        }\n    }\n\n    private PatriciaNode root;\n\n    public PatriciaTree() {\n        root = new PatriciaNode();\n    }\n\n    public void insert(String word) {\n        insertHelper(root, word, 0);\n    }\n\n    private void insertHelper(PatriciaNode node, String word, int index) {\n        if (index >= word.length()) {\n            node.isEndOfWord = true;\n            node.word = word;\n            return;\n        }\n\n        String remainingWord = word.substring(index);\n\n        // Look for existing edge that shares prefix\n        for (Map.Entry<String, PatriciaNode> entry : node.children.entrySet()) {\n            String edge = entry.getKey();\n            PatriciaNode child = entry.getValue();\n\n            int commonLength = findCommonPrefixLength(edge, remainingWord);\n\n            if (commonLength > 0) {\n                if (commonLength == edge.length()) {\n                    // Current edge is completely matched\n                    insertHelper(child, word, index + commonLength);\n                    return;\n                } else {\n                    // Need to split the edge\n                    splitEdge(node, edge, child, commonLength);\n                    insertHelper(node, word, index);\n                    return;\n                }\n            }\n        }\n\n        // No matching edge found, create new edge\n        PatriciaNode newChild = new PatriciaNode();\n        node.children.put(remainingWord, newChild);\n        newChild.isEndOfWord = true;\n        newChild.word = word;\n    }\n\n    private void splitEdge(PatriciaNode parent, String edge, PatriciaNode child, int splitIndex) {\n        String commonPrefix = edge.substring(0, splitIndex);\n        String remainingSuffix = edge.substring(splitIndex);\n\n        // Remove old edge\n        parent.children.remove(edge);\n\n        // Create intermediate node\n        PatriciaNode intermediateNode = new PatriciaNode();\n        parent.children.put(commonPrefix, intermediateNode);\n\n        // Connect intermediate node to original child\n        intermediateNode.children.put(remainingSuffix, child);\n    }\n\n    private int findCommonPrefixLength(String s1, String s2) {\n        int minLength = Math.min(s1.length(), s2.length());\n        int commonLength = 0;\n\n        for (int i = 0; i < minLength; i++) {\n            if (s1.charAt(i) == s2.charAt(i)) {\n                commonLength++;\n            } else {\n                break;\n            }\n        }\n\n        return commonLength;\n    }\n\n    public boolean search(String word) {\n        PatriciaNode node = searchHelper(root, word, 0);\n        return node != null && node.isEndOfWord;\n    }\n\n    private PatriciaNode searchHelper(PatriciaNode node, String word, int index) {\n        if (index >= word.length()) {\n            return node;\n        }\n\n        String remainingWord = word.substring(index);\n\n        for (Map.Entry<String, PatriciaNode> entry : node.children.entrySet()) {\n            String edge = entry.getKey();\n            PatriciaNode child = entry.getValue();\n\n            if (remainingWord.startsWith(edge)) {\n                return searchHelper(child, word, index + edge.length());\n            }\n        }\n\n        return null;\n    }\n\n    public boolean startsWith(String prefix) {\n        return searchHelper(root, prefix, 0) != null;\n    }\n\n    public List<String> getAllWords() {\n        List<String> words = new ArrayList<>();\n        getAllWordsHelper(root, words);\n        return words;\n    }\n\n    private void getAllWordsHelper(PatriciaNode node, List<String> words) {\n        if (node.isEndOfWord) {\n            words.add(node.word);\n        }\n\n        for (PatriciaNode child : node.children.values()) {\n            getAllWordsHelper(child, words);\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-9-trie-for-number-storage",children:"Pattern 9: Trie for Number Storage"}),"\n",(0,t.jsx)(e.h3,{id:"91-xor-trie-for-maximum-xor",children:"9.1 XOR Trie for Maximum XOR"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Trie for storing binary representations of numbers\npublic class XORTrie {\n\n    static class XORTrieNode {\n        XORTrieNode[] children;\n\n        XORTrieNode() {\n            children = new XORTrieNode[_2]; // 0 and 1\n        }\n    }\n\n    private XORTrieNode root;\n    private static final int MAX_BITS = 31; // For 32-bit integers\n\n    public XORTrie() {\n        root = new XORTrieNode();\n    }\n\n    // Insert number into XOR Trie\n    public void insert(int num) {\n        XORTrieNode current = root;\n\n        // Process bits from most significant to least significant\n        for (int i = MAX_BITS; i >= 0; i--) {\n            int bit = (num >> i) & 1;\n\n            if (current.children[bit] == null) {\n                current.children[bit] = new XORTrieNode();\n            }\n\n            current = current.children[bit];\n        }\n    }\n\n    // Find maximum XOR with given number\n    public int findMaxXOR(int num) {\n        XORTrieNode current = root;\n        int maxXOR = 0;\n\n        for (int i = MAX_BITS; i >= 0; i--) {\n            int bit = (num >> i) & 1;\n            int oppositeBit = 1 - bit;\n\n            // Try to go in opposite direction for maximum XOR\n            if (current.children[oppositeBit] != null) {\n                maxXOR |= (1 << i);\n                current = current.children[oppositeBit];\n            } else {\n                current = current.children[bit];\n            }\n        }\n\n        return maxXOR;\n    }\n\n    // Find maximum XOR pair in array\n    public int findMaximumXOR(int[] nums) {\n        if (nums.length < 2) return 0;\n\n        // Insert all numbers into Trie\n        for (int num : nums) {\n            insert(num);\n        }\n\n        int maxXOR = 0;\n\n        // Find maximum XOR for each number\n        for (int num : nums) {\n            maxXOR = Math.max(maxXOR, findMaxXOR(num));\n        }\n\n        return maxXOR;\n    }\n\n    // Remove number from XOR Trie\n    public void remove(int num) {\n        removeHelper(root, num, MAX_BITS);\n    }\n\n    private boolean removeHelper(XORTrieNode node, int num, int bitIndex) {\n        if (bitIndex < 0) {\n            return true; // Reached end, can remove\n        }\n\n        int bit = (num >> bitIndex) & 1;\n        XORTrieNode child = node.children[bit];\n\n        if (child == null) return false; // Number not in Trie\n\n        boolean shouldRemoveChild = removeHelper(child, num, bitIndex - 1);\n\n        if (shouldRemoveChild) {\n            node.children[bit] = null;\n\n            // Check if current node can be removed\n            return node.children[_0] == null && node.children[_1] == null;\n        }\n\n        return false;\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"92-range-xor-queries",children:"9.2 Range XOR Queries"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// XOR Trie with range queries\npublic class RangeXORTrie {\n\n    static class XORNode {\n        XORNode[] children;\n        int count; // Number of elements in this subtree\n\n        XORNode() {\n            children = new XORNode[_2];\n            count = 0;\n        }\n    }\n\n    private XORNode root;\n    private static final int MAX_BITS = 31;\n\n    public RangeXORTrie() {\n        root = new XORNode();\n    }\n\n    public void insert(int num) {\n        XORNode current = root;\n        current.count++;\n\n        for (int i = MAX_BITS; i >= 0; i--) {\n            int bit = (num >> i) & 1;\n\n            if (current.children[bit] == null) {\n                current.children[bit] = new XORNode();\n            }\n\n            current = current.children[bit];\n            current.count++;\n        }\n    }\n\n    public void remove(int num) {\n        if (!contains(num)) return;\n\n        XORNode current = root;\n        current.count--;\n\n        for (int i = MAX_BITS; i >= 0; i--) {\n            int bit = (num >> i) & 1;\n            current = current.children[bit];\n            current.count--;\n        }\n    }\n\n    public boolean contains(int num) {\n        XORNode current = root;\n\n        for (int i = MAX_BITS; i >= 0; i--) {\n            int bit = (num >> i) & 1;\n\n            if (current.children[bit] == null || current.children[bit].count == 0) {\n                return false;\n            }\n\n            current = current.children[bit];\n        }\n\n        return current.count > 0;\n    }\n\n    // Count numbers in range [left, right] that give maximum XOR with x\n    public int countMaxXORInRange(int x, int left, int right) {\n        int maxXOR = findMaxXORInRange(x, left, right);\n        return countWithXOR(x, maxXOR, left, right);\n    }\n\n    private int findMaxXORInRange(int x, int left, int right) {\n        // Implementation would involve checking range constraints\n        // This is a simplified version\n        return findMaxXOR(x);\n    }\n\n    private int findMaxXOR(int num) {\n        XORNode current = root;\n        int maxXOR = 0;\n\n        for (int i = MAX_BITS; i >= 0; i--) {\n            int bit = (num >> i) & 1;\n            int oppositeBit = 1 - bit;\n\n            if (current.children[oppositeBit] != null &&\n                current.children[oppositeBit].count > 0) {\n                maxXOR |= (1 << i);\n                current = current.children[oppositeBit];\n            } else {\n                current = current.children[bit];\n            }\n        }\n\n        return maxXOR;\n    }\n\n    private int countWithXOR(int x, int targetXOR, int left, int right) {\n        // Count numbers that XOR with x to give targetXOR and are in range [left, right]\n        int target = x ^ targetXOR;\n        return contains(target) && target >= left && target <= right ? 1 : 0;\n    }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-10-suffix-trie",children:"Pattern 10: Suffix Trie"}),"\n",(0,t.jsx)(e.h3,{id:"101-suffix-trie-implementation",children:"10.1 Suffix Trie Implementation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:'// Suffix Trie for pattern matching\npublic class SuffixTrie {\n\n    static class SuffixTrieNode {\n        Map<Character, SuffixTrieNode> children;\n        Set<Integer> positions; // Starting positions of suffixes\n        boolean isEndOfString;\n\n        SuffixTrieNode() {\n            children = new HashMap<>();\n            positions = new HashSet<>();\n            isEndOfString = false;\n        }\n    }\n\n    private SuffixTrieNode root;\n    private String text;\n\n    public SuffixTrie(String text) {\n        this.text = text;\n        this.root = new SuffixTrieNode();\n        buildSuffixTrie();\n    }\n\n    private void buildSuffixTrie() {\n        // Insert all suffixes\n        for (int i = 0; i < text.length(); i++) {\n            insertSuffix(text.substring(i), i);\n        }\n    }\n\n    private void insertSuffix(String suffix, int startPosition) {\n        SuffixTrieNode current = root;\n\n        for (int i = 0; i < suffix.length(); i++) {\n            char c = suffix.charAt(i);\n            current.children.putIfAbsent(c, new SuffixTrieNode());\n            current = current.children.get(c);\n            current.positions.add(startPosition);\n        }\n\n        current.isEndOfString = true;\n    }\n\n    // Search for pattern and return all starting positions\n    public List<Integer> searchPattern(String pattern) {\n        SuffixTrieNode current = root;\n\n        for (char c : pattern.toCharArray()) {\n            if (!current.children.containsKey(c)) {\n                return new ArrayList<>(); // Pattern not found\n            }\n            current = current.children.get(c);\n        }\n\n        return new ArrayList<>(current.positions);\n    }\n\n    // Check if pattern exists in text\n    public boolean contains(String pattern) {\n        return !searchPattern(pattern).isEmpty();\n    }\n\n    // Count occurrences of pattern\n    public int countOccurrences(String pattern) {\n        return searchPattern(pattern).size();\n    }\n\n    // Find longest repeated substring\n    public String longestRepeatedSubstring() {\n        String longest = "";\n        findLongestRepeated(root, new StringBuilder(), longest);\n        return longest;\n    }\n\n    private String findLongestRepeated(SuffixTrieNode node, StringBuilder current, String longest) {\n        // If this node has multiple positions, it\'s a repeated substring\n        if (node.positions.size() > 1 && current.length() > longest.length()) {\n            longest = current.toString();\n        }\n\n        for (Map.Entry<Character, SuffixTrieNode> entry : node.children.entrySet()) {\n            current.append(entry.getKey());\n            longest = findLongestRepeated(entry.getValue(), current, longest);\n            current.deleteCharAt(current.length() - 1);\n        }\n\n        return longest;\n    }\n\n    // Find all substrings that occur at least k times\n    public List<String> findFrequentSubstrings(int k) {\n        List<String> result = new ArrayList<>();\n        findFrequentHelper(root, new StringBuilder(), k, result);\n        return result;\n    }\n\n    private void findFrequentHelper(SuffixTrieNode node, StringBuilder current,\n                                   int k, List<String> result) {\n        if (node.positions.size() >= k && current.length() > 0) {\n            result.add(current.toString());\n        }\n\n        for (Map.Entry<Character, SuffixTrieNode> entry : node.children.entrySet()) {\n            current.append(entry.getKey());\n            findFrequentHelper(entry.getValue(), current, k, result);\n            current.deleteCharAt(current.length() - 1);\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-11-advanced-trie-applications",children:"Pattern 11: Advanced Trie Applications"}),"\n",(0,t.jsx)(e.h3,{id:"111-replace-words",children:"11.1 Replace Words"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:'// Replace Words problem using Trie\npublic class ReplaceWords {\n\n    public String replaceWords(List<String> dictionary, String sentence) {\n        StandardTrie trie = new StandardTrie();\n\n        // Build Trie with dictionary roots\n        for (String root : dictionary) {\n            trie.insert(root);\n        }\n\n        String[] words = sentence.split(" ");\n        StringBuilder result = new StringBuilder();\n\n        for (int i = 0; i < words.length; i++) {\n            if (i > 0) result.append(" ");\n\n            String replacement = findRoot(trie, words[i]);\n            result.append(replacement != null ? replacement : words[i]);\n        }\n\n        return result.toString();\n    }\n\n    private String findRoot(StandardTrie trie, String word) {\n        TrieNode current = trie.root;\n        StringBuilder root = new StringBuilder();\n\n        for (char c : word.toCharArray()) {\n            if (!current.children.containsKey(c)) {\n                return null; // No root found\n            }\n\n            root.append(c);\n            current = current.children.get(c);\n\n            if (current.isEndOfWord) {\n                return root.toString(); // Found shortest root\n            }\n        }\n\n        return null; // No complete root found\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"112-concatenated-words",children:"11.2 Concatenated Words"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Find all concatenated words using Trie\npublic class ConcatenatedWords {\n\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\n        StandardTrie trie = new StandardTrie();\n\n        // Sort words by length to process shorter words first\n        Arrays.sort(words, (a, b) -> Integer.compare(a.length(), b.length()));\n\n        List<String> result = new ArrayList<>();\n\n        for (String word : words) {\n            if (canFormWord(word, trie)) {\n                result.add(word);\n            }\n            trie.insert(word); // Add to Trie after checking\n        }\n\n        return result;\n    }\n\n    private boolean canFormWord(String word, StandardTrie trie) {\n        if (word.isEmpty()) return false;\n\n        Boolean[] memo = new Boolean[word.length()];\n        return canFormHelper(word, 0, trie, memo);\n    }\n\n    private boolean canFormHelper(String word, int start, StandardTrie trie, Boolean[] memo) {\n        if (start == word.length()) return true;\n\n        if (memo[start] != null) return memo[start];\n\n        TrieNode current = trie.root;\n\n        for (int end = start; end < word.length(); end++) {\n            char c = word.charAt(end);\n\n            if (!current.children.containsKey(c)) {\n                break;\n            }\n\n            current = current.children.get(c);\n\n            if (current.isEndOfWord) {\n                if (canFormHelper(word, end + 1, trie, memo)) {\n                    memo[start] = true;\n                    return true;\n                }\n            }\n        }\n\n        memo[start] = false;\n        return false;\n    }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-12-trie-optimization-techniques",children:"Pattern 12: Trie Optimization Techniques"}),"\n",(0,t.jsx)(e.h3,{id:"121-memory-optimized-trie",children:"12.1 Memory-Optimized Trie"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Memory-optimized Trie using arrays instead of HashMap\npublic class OptimizedTrie {\n\n    static class OptimizedTrieNode {\n        OptimizedTrieNode[] children;\n        boolean isEndOfWord;\n        String word;\n        static final int ALPHABET_SIZE = 26;\n\n        OptimizedTrieNode() {\n            children = new OptimizedTrieNode[ALPHABET_SIZE];\n            isEndOfWord = false;\n        }\n\n        private int getIndex(char c) {\n            return Character.toLowerCase(c) - 'a';\n        }\n\n        OptimizedTrieNode getChild(char c) {\n            int index = getIndex(c);\n            return index >= 0 && index < ALPHABET_SIZE ? children[index] : null;\n        }\n\n        void setChild(char c, OptimizedTrieNode node) {\n            int index = getIndex(c);\n            if (index >= 0 && index < ALPHABET_SIZE) {\n                children[index] = node;\n            }\n        }\n\n        boolean hasChild(char c) {\n            return getChild(c) != null;\n        }\n\n        int getChildCount() {\n            int count = 0;\n            for (OptimizedTrieNode child : children) {\n                if (child != null) count++;\n            }\n            return count;\n        }\n    }\n\n    private OptimizedTrieNode root;\n\n    public OptimizedTrie() {\n        root = new OptimizedTrieNode();\n    }\n\n    public void insert(String word) {\n        if (word == null || word.isEmpty()) return;\n\n        OptimizedTrieNode current = root;\n\n        for (char c : word.toCharArray()) {\n            if (!current.hasChild(c)) {\n                current.setChild(c, new OptimizedTrieNode());\n            }\n            current = current.getChild(c);\n        }\n\n        current.isEndOfWord = true;\n        current.word = word;\n    }\n\n    public boolean search(String word) {\n        OptimizedTrieNode node = searchNode(word);\n        return node != null && node.isEndOfWord;\n    }\n\n    public boolean startsWith(String prefix) {\n        return searchNode(prefix) != null;\n    }\n\n    private OptimizedTrieNode searchNode(String str) {\n        OptimizedTrieNode current = root;\n\n        for (char c : str.toCharArray()) {\n            current = current.getChild(c);\n            if (current == null) return null;\n        }\n\n        return current;\n    }\n\n    // Delete with node cleanup\n    public void delete(String word) {\n        deleteHelper(root, word, 0);\n    }\n\n    private boolean deleteHelper(OptimizedTrieNode current, String word, int index) {\n        if (index == word.length()) {\n            if (!current.isEndOfWord) return false;\n\n            current.isEndOfWord = false;\n            current.word = null;\n\n            return current.getChildCount() == 0;\n        }\n\n        char c = word.charAt(index);\n        OptimizedTrieNode node = current.getChild(c);\n\n        if (node == null) return false;\n\n        boolean shouldDeleteChild = deleteHelper(node, word, index + 1);\n\n        if (shouldDeleteChild) {\n            current.setChild(c, null);\n            return !current.isEndOfWord && current.getChildCount() == 0;\n        }\n\n        return false;\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"122-persistent-trie-immutable",children:"12.2 Persistent Trie (Immutable)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Persistent Trie - creates new versions without modifying existing ones\npublic class PersistentTrie {\n\n    static class PersistentTrieNode {\n        Map<Character, PersistentTrieNode> children;\n        boolean isEndOfWord;\n        String word;\n\n        PersistentTrieNode() {\n            children = new HashMap<>();\n            isEndOfWord = false;\n        }\n\n        // Copy constructor\n        PersistentTrieNode(PersistentTrieNode other) {\n            children = new HashMap<>(other.children);\n            isEndOfWord = other.isEndOfWord;\n            word = other.word;\n        }\n    }\n\n    private PersistentTrieNode root;\n\n    public PersistentTrie() {\n        root = new PersistentTrieNode();\n    }\n\n    private PersistentTrie(PersistentTrieNode root) {\n        this.root = root;\n    }\n\n    // Insert returns new Trie version\n    public PersistentTrie insert(String word) {\n        PersistentTrieNode newRoot = insertHelper(root, word, 0);\n        return new PersistentTrie(newRoot);\n    }\n\n    private PersistentTrieNode insertHelper(PersistentTrieNode node, String word, int index) {\n        PersistentTrieNode newNode = new PersistentTrieNode(node);\n\n        if (index == word.length()) {\n            newNode.isEndOfWord = true;\n            newNode.word = word;\n            return newNode;\n        }\n\n        char c = word.charAt(index);\n        PersistentTrieNode child = node.children.get(c);\n\n        if (child == null) {\n            child = new PersistentTrieNode();\n        }\n\n        PersistentTrieNode newChild = insertHelper(child, word, index + 1);\n        newNode.children.put(c, newChild);\n\n        return newNode;\n    }\n\n    public boolean search(String word) {\n        PersistentTrieNode node = searchNode(word);\n        return node != null && node.isEndOfWord;\n    }\n\n    public boolean startsWith(String prefix) {\n        return searchNode(prefix) != null;\n    }\n\n    private PersistentTrieNode searchNode(String str) {\n        PersistentTrieNode current = root;\n\n        for (char c : str.toCharArray()) {\n            current = current.children.get(c);\n            if (current == null) return null;\n        }\n\n        return current;\n    }\n\n    // Delete returns new Trie version\n    public PersistentTrie delete(String word) {\n        if (!search(word)) return this; // Word doesn't exist, return same version\n\n        PersistentTrieNode newRoot = deleteHelper(root, word, 0);\n        return new PersistentTrie(newRoot);\n    }\n\n    private PersistentTrieNode deleteHelper(PersistentTrieNode node, String word, int index) {\n        PersistentTrieNode newNode = new PersistentTrieNode(node);\n\n        if (index == word.length()) {\n            newNode.isEndOfWord = false;\n            newNode.word = null;\n            return newNode;\n        }\n\n        char c = word.charAt(index);\n        PersistentTrieNode child = node.children.get(c);\n\n        if (child != null) {\n            PersistentTrieNode newChild = deleteHelper(child, word, index + 1);\n\n            // If child becomes empty, remove it\n            if (!newChild.isEndOfWord && newChild.children.isEmpty()) {\n                newNode.children.remove(c);\n            } else {\n                newNode.children.put(c, newChild);\n            }\n        }\n\n        return newNode;\n    }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"time--space-complexity-reference",children:"Time & Space Complexity Reference"}),"\n",(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{style:{textAlign:"left"},children:"Operation"}),(0,t.jsx)(e.th,{style:{textAlign:"left"},children:"Time Complexity"}),(0,t.jsx)(e.th,{style:{textAlign:"left"},children:"Space Complexity"}),(0,t.jsx)(e.th,{style:{textAlign:"left"},children:"Notes"})]})}),(0,t.jsxs)(e.tbody,{children:[(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Insert"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(m)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(ALPHABET_SIZE \xd7 N \xd7 M)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"m = word length"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Search"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(m)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(1)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"m = word length"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Delete"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(m)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(1)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"m = word length"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Prefix Search"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(p)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(1)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"p = prefix length"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Get All Words"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(N \xd7 M)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(N \xd7 M)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"N = words, M = avg length"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Space Total"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"-"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(ALPHABET_SIZE \xd7 N \xd7 M)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Worst case"})]})]})]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.em,{children:"Where N = number of words, M = average word length, ALPHABET_SIZE = character set size"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"best-practices--optimization-tips",children:"Best Practices & Optimization Tips"}),"\n",(0,t.jsx)(e.h3,{id:"trie-implementation-guidelines",children:"Trie Implementation Guidelines"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:'// 1. Choose appropriate node structure\n// For English only: Use array of size 26\nclass ArrayNode {\n    ArrayNode[] children = new ArrayNode[_26];\n    boolean isEndOfWord;\n}\n\n// For general characters: Use HashMap\nclass MapNode {\n    Map<Character, MapNode> children = new HashMap<>();\n    boolean isEndOfWord;\n}\n\n// 2. Memory optimization techniques\npublic class MemoryOptimizedTrie {\n    // Use lazy initialization\n    class LazyTrieNode {\n        Map<Character, LazyTrieNode> children; // Initialize only when needed\n        boolean isEndOfWord;\n\n        void addChild(char c) {\n            if (children == null) {\n                children = new HashMap<>();\n            }\n            children.putIfAbsent(c, new LazyTrieNode());\n        }\n    }\n\n    // Compress single-child paths (Patricia Tree)\n    class CompressedNode {\n        Map<String, CompressedNode> children; // Store string edges\n        boolean isEndOfWord;\n        String word;\n    }\n}\n\n// 3. Handle edge cases\npublic void robustInsert(String word) {\n    if (word == null || word.isEmpty()) return;\n\n    // Normalize input\n    word = word.toLowerCase().trim();\n\n    // Validate characters if needed\n    if (!isValidWord(word)) return;\n\n    // Proceed with insertion\n    insertHelper(word);\n}\n\nprivate boolean isValidWord(String word) {\n    return word.matches("[a-zA-Z]+"); // Only letters\n}\n\n// 4. Batch operations for efficiency\npublic void insertBatch(List<String> words) {\n    for (String word : words) {\n        insert(word);\n    }\n}\n\nvoid insertHelper(String word) { /* Implementation */ }\n'})}),"\n",(0,t.jsx)(e.h3,{id:"common-pitfalls-to-avoid",children:"Common Pitfalls to Avoid"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Memory Usage"}),": Tries can be memory-intensive for large datasets"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Character Set"}),": Consider the character set size when choosing node structure"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Case Sensitivity"}),": Decide early whether to be case-sensitive or not"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Null Handling"}),": Always validate input strings"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Deletion Complexity"}),": Implement proper cleanup to avoid memory leaks"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"interview-tips",children:"Interview Tips"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Identify Trie use cases"}),": Prefix matching, dictionary operations, auto-complete"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Discuss trade-offs"}),": Time vs space complexity"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Consider alternatives"}),": Hash tables for exact matching, suffix arrays for advanced string operations"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Optimize for the specific problem"}),": Array vs HashMap based on character set"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Think about scalability"}),": How will the solution perform with large datasets?"]}),"\n"]})]})}function u(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(l,{...n})}):l(n)}}}]);