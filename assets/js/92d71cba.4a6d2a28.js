"use strict";(globalThis.webpackChunkdev_enigma=globalThis.webpackChunkdev_enigma||[]).push([[36122],{13052:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>c});var r=t(74848),i=t(28453);const s={},l="Interval Problems",a={id:"DSA/DSA/DSA with JavaScript/DSA Cheatsheets/Interval Problems",title:"Interval Problems",description:"Table of Contents",source:"@site/docs/05-DSA/DSA/DSA with JavaScript/DSA Cheatsheets/Interval Problems.mdx",sourceDirName:"05-DSA/DSA/DSA with JavaScript/DSA Cheatsheets",slug:"/DSA/DSA/DSA with JavaScript/DSA Cheatsheets/Interval Problems",permalink:"/docs/DSA/DSA/DSA with JavaScript/DSA Cheatsheets/Interval Problems",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/05-DSA/DSA/DSA with JavaScript/DSA Cheatsheets/Interval Problems.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Heap",permalink:"/docs/DSA/DSA/DSA with JavaScript/DSA Cheatsheets/Heap"},next:{title:"Knapsack Problems",permalink:"/docs/DSA/DSA/DSA with JavaScript/DSA Cheatsheets/Knapsack Problems"}},o={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Core Concepts",id:"core-concepts",level:2},{value:"Basic Interval Representation",id:"basic-interval-representation",level:3},{value:"Key Properties &amp; Relationships",id:"key-properties--relationships",level:3},{value:"Sorting-Based Patterns",id:"sorting-based-patterns",level:2},{value:"Template Pattern",id:"template-pattern",level:3},{value:"Merge Intervals Pattern",id:"merge-intervals-pattern",level:2},{value:"Classic Merge Intervals",id:"classic-merge-intervals",level:3},{value:"Merge with Custom Logic",id:"merge-with-custom-logic",level:3},{value:"Insert Interval Pattern",id:"insert-interval-pattern",level:2},{value:"Insert Interval Implementation",id:"insert-interval-implementation",level:3},{value:"Insert Multiple Intervals",id:"insert-multiple-intervals",level:3},{value:"Meeting Rooms Pattern",id:"meeting-rooms-pattern",level:2},{value:"Meeting Rooms I (Can Attend All)",id:"meeting-rooms-i-can-attend-all",level:3},{value:"Meeting Rooms II (Minimum Rooms)",id:"meeting-rooms-ii-minimum-rooms",level:3},{value:"Meeting Rooms with Priority Queue",id:"meeting-rooms-with-priority-queue",level:3},{value:"Sweep Line Algorithm",id:"sweep-line-algorithm",level:2},{value:"Event-Based Processing",id:"event-based-processing",level:3},{value:"Sweep Line for Range Sum Queries",id:"sweep-line-for-range-sum-queries",level:3},{value:"Interval Tree &amp; Advanced Structures",id:"interval-tree--advanced-structures",level:2},{value:"Simple Interval Tree Node",id:"simple-interval-tree-node",level:3},{value:"Two Pointers on Intervals",id:"two-pointers-on-intervals",level:2},{value:"Intersection of Two Interval Lists",id:"intersection-of-two-interval-lists",level:3},{value:"Merge Two Sorted Interval Lists",id:"merge-two-sorted-interval-lists",level:3},{value:"Priority Queue Patterns",id:"priority-queue-patterns",level:2},{value:"Interval Scheduling with Weights",id:"interval-scheduling-with-weights",level:3},{value:"CPU Scheduling Simulation",id:"cpu-scheduling-simulation",level:3},{value:"Common Problem Types",id:"common-problem-types",level:2},{value:"1. Non-Overlapping Intervals (Greedy)",id:"1-non-overlapping-intervals-greedy",level:3},{value:"2. Minimum Arrows to Burst Balloons",id:"2-minimum-arrows-to-burst-balloons",level:3},{value:"3. Activity Selection Problem",id:"3-activity-selection-problem",level:3},{value:"4. Calendar Scheduling",id:"4-calendar-scheduling",level:3},{value:"Complexity Analysis &amp; Tips",id:"complexity-analysis--tips",level:2},{value:"Time Complexities:",id:"time-complexities",level:3},{value:"Space Complexities:",id:"space-complexities",level:3},{value:"Key Optimization Strategies:",id:"key-optimization-strategies",level:3},{value:"Common Pitfalls:",id:"common-pitfalls",level:3},{value:"Summary",id:"summary",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"interval-problems",children:"Interval Problems"})}),"\n",(0,r.jsx)(e.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#core-concepts",children:"Core Concepts"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#sorting-based-patterns",children:"Sorting-Based Patterns"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#merge-intervals-pattern",children:"Merge Intervals Pattern"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#insert-interval-pattern",children:"Insert Interval Pattern"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#meeting-rooms-pattern",children:"Meeting Rooms Pattern"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#sweep-line-algorithm",children:"Sweep Line Algorithm"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#interval-tree--advanced-structures",children:"Interval Tree & Advanced Structures"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#two-pointers-on-intervals",children:"Two Pointers on Intervals"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#priority-queue-patterns",children:"Priority Queue Patterns"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#common-problem-types",children:"Common Problem Types"})}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,r.jsx)(e.h3,{id:"basic-interval-representation",children:"Basic Interval Representation"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"// Simple interval structure\nclass Interval {\n  constructor(start, end) {\n    this.start = start;\n    this.end = end;\n  }\n}\n\n// Array representation: [start, end]\nconst intervals = [\n  [1, 3],\n  [2, 6],\n  [8, 10],\n  [15, 18],\n];\n\n// Object representation\nconst meetings = [\n  { start: 1, end: 3 },\n  { start: 2, end: 6 },\n  { start: 8, end: 10 },\n];\n"})}),"\n",(0,r.jsx)(e.h3,{id:"key-properties--relationships",children:"Key Properties & Relationships"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"// Interval relationships\nfunction getRelationship(interval1, interval2) {\n  const [a1, a2] = interval1;\n  const [b1, b2] = interval2;\n\n  // No overlap\n  if (a2 < b1 || b2 < a1) return 'separate';\n\n  // Touch at endpoints\n  if (a2 === b1 || b2 === a1) return 'adjacent';\n\n  // Overlap cases\n  if (a1 === b1 && a2 === b2) return 'identical';\n  if (a1 >= b1 && a2 <= b2) return 'a_inside_b';\n  if (b1 >= a1 && b2 <= a2) return 'b_inside_a';\n\n  return 'partial_overlap';\n}\n\n// Check if intervals overlap\nfunction overlaps(interval1, interval2) {\n  return (\n    Math.max(interval1[0], interval2[0]) < Math.min(interval1[1], interval2[1])\n  );\n}\n\n// Merge two overlapping intervals\nfunction merge(interval1, interval2) {\n  return [\n    Math.min(interval1[0], interval2[0]),\n    Math.max(interval1[1], interval2[1]),\n  ];\n}\n"})}),"\n",(0,r.jsx)(e.h2,{id:"sorting-based-patterns",children:"Sorting-Based Patterns"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Core Idea"}),": Sort intervals by start time, then process sequentially."]}),"\n",(0,r.jsx)(e.h3,{id:"template-pattern",children:"Template Pattern"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function processIntervals(intervals) {\n  if (intervals.length <= 1) return intervals;\n\n  // Sort by start time\n  intervals.sort((a, b) => a[0] - b[0]);\n\n  const result = [];\n  let current = intervals[0];\n\n  for (let i = 1; i < intervals.length; i++) {\n    const next = intervals[i];\n\n    if (shouldCombine(current, next)) {\n      current = combine(current, next);\n    } else {\n      result.push(current);\n      current = next;\n    }\n  }\n\n  result.push(current);\n  return result;\n}\n"})}),"\n",(0,r.jsx)(e.h2,{id:"merge-intervals-pattern",children:"Merge Intervals Pattern"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Use Case"}),": Combine overlapping intervals into non-overlapping ones."]}),"\n",(0,r.jsx)(e.h3,{id:"classic-merge-intervals",children:"Classic Merge Intervals"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function merge(intervals) {\n  if (intervals.length <= 1) return intervals;\n\n  // Sort by start time\n  intervals.sort((a, b) => a[0] - b[0]);\n\n  const merged = [intervals[0]];\n\n  for (let i = 1; i < intervals.length; i++) {\n    const current = intervals[i];\n    const lastMerged = merged[merged.length - 1];\n\n    // If current interval overlaps with last merged interval\n    if (current[0] <= lastMerged[1]) {\n      // Merge them by extending the end time\n      lastMerged[1] = Math.max(lastMerged[1], current[1]);\n    } else {\n      // No overlap, add current interval\n      merged.push(current);\n    }\n  }\n\n  return merged;\n}\n\n// Example usage\nconsole.log(\n  merge([\n    [1, 3],\n    [2, 6],\n    [8, 10],\n    [15, 18],\n  ])\n);\n// Output: [[1,6],[8,10],[15,18]]\n"})}),"\n",(0,r.jsx)(e.h3,{id:"merge-with-custom-logic",children:"Merge with Custom Logic"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"// Merge intervals with minimum gap\nfunction mergeWithGap(intervals, gap) {\n  if (intervals.length <= 1) return intervals;\n\n  intervals.sort((a, b) => a[0] - b[0]);\n  const merged = [intervals[0]];\n\n  for (let i = 1; i < intervals.length; i++) {\n    const current = intervals[i];\n    const lastMerged = merged[merged.length - 1];\n\n    // Merge if overlap or gap is within threshold\n    if (current[0] - lastMerged[1] <= gap) {\n      lastMerged[1] = Math.max(lastMerged[1], current[1]);\n    } else {\n      merged.push(current);\n    }\n  }\n\n  return merged;\n}\n"})}),"\n",(0,r.jsx)(e.h2,{id:"insert-interval-pattern",children:"Insert Interval Pattern"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Use Case"}),": Insert a new interval into a sorted list of non-overlapping intervals."]}),"\n",(0,r.jsx)(e.h3,{id:"insert-interval-implementation",children:"Insert Interval Implementation"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function insert(intervals, newInterval) {\n  const result = [];\n  let i = 0;\n\n  // Add all intervals that end before new interval starts\n  while (i < intervals.length && intervals[i][1] < newInterval[0]) {\n    result.push(intervals[i]);\n    i++;\n  }\n\n  // Merge all overlapping intervals with new interval\n  while (i < intervals.length && intervals[i][0] <= newInterval[1]) {\n    newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\n    newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\n    i++;\n  }\n  result.push(newInterval);\n\n  // Add remaining intervals\n  while (i < intervals.length) {\n    result.push(intervals[i]);\n    i++;\n  }\n\n  return result;\n}\n\n// Example usage\nconsole.log(\n  insert(\n    [\n      [1, 3],\n      [6, 9],\n    ],\n    [2, 5]\n  )\n);\n// Output: [[1,5],[6,9]]\n"})}),"\n",(0,r.jsx)(e.h3,{id:"insert-multiple-intervals",children:"Insert Multiple Intervals"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function insertMultiple(intervals, newIntervals) {\n  // Sort new intervals by start time\n  newIntervals.sort((a, b) => a[0] - b[0]);\n\n  let result = intervals;\n\n  for (const newInterval of newIntervals) {\n    result = insert(result, newInterval);\n  }\n\n  return result;\n}\n"})}),"\n",(0,r.jsx)(e.h2,{id:"meeting-rooms-pattern",children:"Meeting Rooms Pattern"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Use Case"}),": Determine if meetings can be scheduled or find minimum rooms needed."]}),"\n",(0,r.jsx)(e.h3,{id:"meeting-rooms-i-can-attend-all",children:"Meeting Rooms I (Can Attend All)"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function canAttendMeetings(intervals) {\n  if (intervals.length <= 1) return true;\n\n  intervals.sort((a, b) => a[0] - b[0]);\n\n  for (let i = 1; i < intervals.length; i++) {\n    // If current meeting starts before previous ends\n    if (intervals[i][0] < intervals[i - 1][1]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"meeting-rooms-ii-minimum-rooms",children:"Meeting Rooms II (Minimum Rooms)"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function minMeetingRooms(intervals) {\n  if (intervals.length === 0) return 0;\n\n  const starts = intervals.map(interval => interval[0]).sort((a, b) => a - b);\n  const ends = intervals.map(interval => interval[1]).sort((a, b) => a - b);\n\n  let rooms = 0;\n  let maxRooms = 0;\n  let startPtr = 0;\n  let endPtr = 0;\n\n  while (startPtr < intervals.length) {\n    // A meeting starts\n    if (starts[startPtr] < ends[endPtr]) {\n      rooms++;\n      maxRooms = Math.max(maxRooms, rooms);\n      startPtr++;\n    } else {\n      // A meeting ends\n      rooms--;\n      endPtr++;\n    }\n  }\n\n  return maxRooms;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"meeting-rooms-with-priority-queue",children:"Meeting Rooms with Priority Queue"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"class MinHeap {\n  constructor() {\n    this.heap = [];\n  }\n\n  push(val) {\n    this.heap.push(val);\n    this._heapifyUp();\n  }\n\n  pop() {\n    if (this.heap.length === 0) return null;\n    if (this.heap.length === 1) return this.heap.pop();\n\n    const min = this.heap[0];\n    this.heap[0] = this.heap.pop();\n    this._heapifyDown();\n    return min;\n  }\n\n  peek() {\n    return this.heap.length > 0 ? this.heap[0] : null;\n  }\n\n  size() {\n    return this.heap.length;\n  }\n\n  _heapifyUp() {\n    let idx = this.heap.length - 1;\n    while (idx > 0) {\n      const parentIdx = Math.floor((idx - 1) / 2);\n      if (this.heap[parentIdx] <= this.heap[idx]) break;\n      [this.heap[parentIdx], this.heap[idx]] = [\n        this.heap[idx],\n        this.heap[parentIdx],\n      ];\n      idx = parentIdx;\n    }\n  }\n\n  _heapifyDown() {\n    let idx = 0;\n    while (2 * idx + 1 < this.heap.length) {\n      let minChildIdx = 2 * idx + 1;\n      if (\n        2 * idx + 2 < this.heap.length &&\n        this.heap[2 * idx + 2] < this.heap[minChildIdx]\n      ) {\n        minChildIdx = 2 * idx + 2;\n      }\n      if (this.heap[idx] <= this.heap[minChildIdx]) break;\n      [this.heap[idx], this.heap[minChildIdx]] = [\n        this.heap[minChildIdx],\n        this.heap[idx],\n      ];\n      idx = minChildIdx;\n    }\n  }\n}\n\nfunction minMeetingRoomsHeap(intervals) {\n  if (intervals.length === 0) return 0;\n\n  intervals.sort((a, b) => a[0] - b[0]);\n  const endTimes = new MinHeap();\n\n  for (const interval of intervals) {\n    // If earliest ending meeting has ended, reuse that room\n    if (endTimes.size() > 0 && endTimes.peek() <= interval[0]) {\n      endTimes.pop();\n    }\n    endTimes.push(interval[1]);\n  }\n\n  return endTimes.size();\n}\n"})}),"\n",(0,r.jsx)(e.h2,{id:"sweep-line-algorithm",children:"Sweep Line Algorithm"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Use Case"}),": Process events in chronological order to track active intervals."]}),"\n",(0,r.jsx)(e.h3,{id:"event-based-processing",children:"Event-Based Processing"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function sweepLine(intervals) {\n  const events = [];\n\n  // Create events for interval starts and ends\n  for (const [start, end] of intervals) {\n    events.push([start, 'start']);\n    events.push([end, 'end']);\n  }\n\n  // Sort events by time, with 'end' events before 'start' events at same time\n  events.sort((a, b) => {\n    if (a[0] !== b[0]) return a[0] - b[0];\n    return a[1] === 'end' ? -1 : 1;\n  });\n\n  let activeIntervals = 0;\n  let maxActive = 0;\n\n  for (const [time, type] of events) {\n    if (type === 'start') {\n      activeIntervals++;\n      maxActive = Math.max(maxActive, activeIntervals);\n    } else {\n      activeIntervals--;\n    }\n  }\n\n  return maxActive;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"sweep-line-for-range-sum-queries",children:"Sweep Line for Range Sum Queries"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function rangeSum(intervals, queries) {\n  const events = [];\n\n  // Create events for intervals\n  for (let i = 0; i < intervals.length; i++) {\n    const [start, end] = intervals[i];\n    events.push([start, 'start', i]);\n    events.push([end, 'end', i]);\n  }\n\n  // Create events for queries\n  for (let i = 0; i < queries.length; i++) {\n    const [point] = queries[i];\n    events.push([point, 'query', i]);\n  }\n\n  events.sort((a, b) => a[0] - b[0]);\n\n  const activeIntervals = new Set();\n  const results = new Array(queries.length);\n\n  for (const [time, type, idx] of events) {\n    if (type === 'start') {\n      activeIntervals.add(idx);\n    } else if (type === 'end') {\n      activeIntervals.delete(idx);\n    } else {\n      // query\n      results[idx] = activeIntervals.size;\n    }\n  }\n\n  return results;\n}\n"})}),"\n",(0,r.jsx)(e.h2,{id:"interval-tree--advanced-structures",children:"Interval Tree & Advanced Structures"}),"\n",(0,r.jsx)(e.h3,{id:"simple-interval-tree-node",children:"Simple Interval Tree Node"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"class IntervalTreeNode {\n  constructor(interval) {\n    this.interval = interval;\n    this.max = interval[1];\n    this.left = null;\n    this.right = null;\n  }\n}\n\nclass IntervalTree {\n  constructor() {\n    this.root = null;\n  }\n\n  insert(interval) {\n    this.root = this._insert(this.root, interval);\n  }\n\n  _insert(node, interval) {\n    if (!node) return new IntervalTreeNode(interval);\n\n    // Update max value\n    node.max = Math.max(node.max, interval[1]);\n\n    // Insert based on start time\n    if (interval[0] < node.interval[0]) {\n      node.left = this._insert(node.left, interval);\n    } else {\n      node.right = this._insert(node.right, interval);\n    }\n\n    return node;\n  }\n\n  search(interval) {\n    return this._search(this.root, interval);\n  }\n\n  _search(node, interval) {\n    if (!node) return null;\n\n    // Check if current interval overlaps\n    if (this._overlaps(node.interval, interval)) {\n      return node.interval;\n    }\n\n    // If left subtree can contain overlapping interval\n    if (node.left && node.left.max >= interval[0]) {\n      return this._search(node.left, interval);\n    }\n\n    return this._search(node.right, interval);\n  }\n\n  _overlaps(a, b) {\n    return Math.max(a[0], b[0]) < Math.min(a[1], b[1]);\n  }\n}\n"})}),"\n",(0,r.jsx)(e.h2,{id:"two-pointers-on-intervals",children:"Two Pointers on Intervals"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Use Case"}),": Compare or merge two sorted lists of intervals."]}),"\n",(0,r.jsx)(e.h3,{id:"intersection-of-two-interval-lists",children:"Intersection of Two Interval Lists"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function intervalIntersection(firstList, secondList) {\n  const result = [];\n  let i = 0,\n    j = 0;\n\n  while (i < firstList.length && j < secondList.length) {\n    const [start1, end1] = firstList[i];\n    const [start2, end2] = secondList[j];\n\n    // Find intersection\n    const start = Math.max(start1, start2);\n    const end = Math.min(end1, end2);\n\n    if (start < end) {\n      result.push([start, end]);\n    }\n\n    // Move pointer for interval that ends first\n    if (end1 < end2) {\n      i++;\n    } else {\n      j++;\n    }\n  }\n\n  return result;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"merge-two-sorted-interval-lists",children:"Merge Two Sorted Interval Lists"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function mergeTwoLists(list1, list2) {\n  const result = [];\n  let i = 0,\n    j = 0;\n\n  while (i < list1.length && j < list2.length) {\n    if (list1[i][0] <= list2[j][0]) {\n      result.push(list1[i]);\n      i++;\n    } else {\n      result.push(list2[j]);\n      j++;\n    }\n  }\n\n  while (i < list1.length) {\n    result.push(list1[i]);\n    i++;\n  }\n\n  while (j < list2.length) {\n    result.push(list2[j]);\n    j++;\n  }\n\n  return merge(result); // Apply merge intervals pattern\n}\n"})}),"\n",(0,r.jsx)(e.h2,{id:"priority-queue-patterns",children:"Priority Queue Patterns"}),"\n",(0,r.jsx)(e.h3,{id:"interval-scheduling-with-weights",children:"Interval Scheduling with Weights"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function maxWeight(intervals) {\n  // Add weight as third element: [start, end, weight]\n  intervals.sort((a, b) => a[1] - b[1]); // Sort by end time\n\n  const n = intervals.length;\n  const dp = new Array(n + 1).fill(0);\n\n  for (let i = 1; i <= n; i++) {\n    const [start, end, weight] = intervals[i - 1];\n\n    // Find latest non-overlapping interval\n    let j = i - 1;\n    while (j > 0 && intervals[j - 1][1] > start) {\n      j--;\n    }\n\n    // Take or skip current interval\n    dp[i] = Math.max(\n      dp[i - 1], // Skip\n      dp[j] + weight // Take\n    );\n  }\n\n  return dp[n];\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"cpu-scheduling-simulation",children:"CPU Scheduling Simulation"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function scheduleCPU(processes) {\n  // Process: [arrivalTime, burstTime, priority]\n  const events = [];\n  const completed = [];\n  let currentTime = 0;\n  let runningProcess = null;\n\n  // Create arrival events\n  for (let i = 0; i < processes.length; i++) {\n    events.push([processes[i][0], 'arrival', i]);\n  }\n\n  events.sort((a, b) => a[0] - b[0]);\n  const readyQueue = new MinHeap(); // Priority-based\n\n  for (const [time, type, processId] of events) {\n    currentTime = Math.max(currentTime, time);\n\n    if (type === 'arrival') {\n      const process = { ...processes[processId], id: processId };\n      readyQueue.push(process);\n\n      // Preempt if higher priority process arrives\n      if (!runningProcess || process.priority < runningProcess.priority) {\n        if (runningProcess) {\n          readyQueue.push(runningProcess);\n        }\n        runningProcess = readyQueue.pop();\n      }\n    }\n\n    // Process completion logic here...\n  }\n\n  return completed;\n}\n"})}),"\n",(0,r.jsx)(e.h2,{id:"common-problem-types",children:"Common Problem Types"}),"\n",(0,r.jsx)(e.h3,{id:"1-non-overlapping-intervals-greedy",children:"1. Non-Overlapping Intervals (Greedy)"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function eraseOverlapIntervals(intervals) {\n  if (intervals.length <= 1) return 0;\n\n  intervals.sort((a, b) => a[1] - b[1]); // Sort by end time\n\n  let count = 0;\n  let lastEnd = intervals[0][1];\n\n  for (let i = 1; i < intervals.length; i++) {\n    if (intervals[i][0] < lastEnd) {\n      count++; // Remove current interval\n    } else {\n      lastEnd = intervals[i][1];\n    }\n  }\n\n  return count;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"2-minimum-arrows-to-burst-balloons",children:"2. Minimum Arrows to Burst Balloons"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function findMinArrowShots(points) {\n  if (points.length === 0) return 0;\n\n  points.sort((a, b) => a[1] - b[1]); // Sort by end position\n\n  let arrows = 1;\n  let arrowPos = points[0][1];\n\n  for (let i = 1; i < points.length; i++) {\n    if (points[i][0] > arrowPos) {\n      arrows++;\n      arrowPos = points[i][1];\n    }\n  }\n\n  return arrows;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"3-activity-selection-problem",children:"3. Activity Selection Problem"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function activitySelection(activities) {\n  // Activity: [start, end]\n  activities.sort((a, b) => a[1] - b[1]);\n\n  const selected = [activities[0]];\n  let lastEnd = activities[0][1];\n\n  for (let i = 1; i < activities.length; i++) {\n    if (activities[i][0] >= lastEnd) {\n      selected.push(activities[i]);\n      lastEnd = activities[i][1];\n    }\n  }\n\n  return selected;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"4-calendar-scheduling",children:"4. Calendar Scheduling"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"class MyCalendar {\n  constructor() {\n    this.bookings = [];\n  }\n\n  book(start, end) {\n    // Check for conflicts\n    for (const [s, e] of this.bookings) {\n      if (Math.max(start, s) < Math.min(end, e)) {\n        return false; // Conflict found\n      }\n    }\n\n    this.bookings.push([start, end]);\n    this.bookings.sort((a, b) => a[0] - b[0]);\n    return true;\n  }\n}\n\nclass MyCalendarTwo {\n  constructor() {\n    this.bookings = [];\n    this.overlaps = [];\n  }\n\n  book(start, end) {\n    // Check for triple booking\n    for (const [s, e] of this.overlaps) {\n      if (Math.max(start, s) < Math.min(end, e)) {\n        return false;\n      }\n    }\n\n    // Add to overlaps if it conflicts with existing booking\n    for (const [s, e] of this.bookings) {\n      if (Math.max(start, s) < Math.min(end, e)) {\n        this.overlaps.push([Math.max(start, s), Math.min(end, e)]);\n      }\n    }\n\n    this.bookings.push([start, end]);\n    return true;\n  }\n}\n"})}),"\n",(0,r.jsx)(e.h2,{id:"complexity-analysis--tips",children:"Complexity Analysis & Tips"}),"\n",(0,r.jsx)(e.h3,{id:"time-complexities",children:"Time Complexities:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Sorting"}),": O(n log n)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Merge intervals"}),": O(n log n)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Meeting rooms"}),": O(n log n)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Sweep line"}),": O(n log n)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Interval tree search"}),": O(log n)"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"space-complexities",children:"Space Complexities:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Basic operations"}),": O(1) to O(n)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Priority queue"}),": O(n)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Interval tree"}),": O(n)"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"key-optimization-strategies",children:"Key Optimization Strategies:"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Sort First"}),": Most interval problems benefit from sorting"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Greedy Approach"}),": Often optimal for scheduling problems"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Two Pointers"}),": Efficient for merging sorted interval lists"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Event Processing"}),": Sweep line for complex overlapping scenarios"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Data Structures"}),": Use appropriate structures (heaps, trees) for dynamic scenarios"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"common-pitfalls",children:"Common Pitfalls:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"// 1. Edge case handling\nif (intervals.length <= 1) return intervals;\n\n// 2. Boundary conditions\nif (start === end) continue; // Empty interval\n\n// 3. Sorting stability\nintervals.sort((a, b) => {\n    if (a[0] !== b[0]) return a[0] - b[0];\n    return a[1] - b[1]; // Secondary sort by end time\n});\n\n// 4. Inclusive vs exclusive intervals\nconst overlaps = start1 < end2 && start2 < end1; // Exclusive\nconst overlapsInclusive = start1 <= end2 && start2 <= end1; // Inclusive\n"})}),"\n",(0,r.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(e.p,{children:"Master these patterns to solve any interval problem:"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Sort by start/end time"})," as needed"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Use greedy algorithms"})," for optimization problems"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Apply sweep line"})," for complex event processing"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Utilize data structures"})," (heaps, trees) for dynamic scenarios"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Handle edge cases"})," carefully (empty intervals, single interval, etc.)"]}),"\n"]})]})}function h(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}},28453:(n,e,t)=>{t.d(e,{R:()=>l,x:()=>a});var r=t(96540);const i={},s=r.createContext(i);function l(n){const e=r.useContext(s);return r.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:l(n.components),r.createElement(s.Provider,{value:e},n.children)}}}]);