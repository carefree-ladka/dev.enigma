"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[7141],{1797:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var t=r(4848),i=r(8453);const o={},l="N-ary Tree",s={id:"DSA/DSA Cheatsheets/N-ary Tree",title:"N-ary Tree",description:"A comprehensive guide to N-ary tree algorithms and techniques for Data Structures and Algorithms.",source:"@site/docs/DSA/DSA Cheatsheets/N-ary Tree.mdx",sourceDirName:"DSA/DSA Cheatsheets",slug:"/DSA/DSA Cheatsheets/N-ary Tree",permalink:"/js.enigma/docs/DSA/DSA Cheatsheets/N-ary Tree",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA Cheatsheets/N-ary Tree.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Mathematics DSA Tricks, Tips & Patterns",permalink:"/js.enigma/docs/DSA/DSA Cheatsheets/Mathematics DSA Tricks, Tips"},next:{title:"Prefix Sum",permalink:"/js.enigma/docs/DSA/DSA Cheatsheets/Prefix Sum"}},d={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Basic N-ary Tree Structures",id:"basic-n-ary-tree-structures",level:2},{value:"N-ary Tree Node Definition",id:"n-ary-tree-node-definition",level:3},{value:"Helper Functions",id:"helper-functions",level:3},{value:"Tree Traversal Techniques",id:"tree-traversal-techniques",level:2},{value:"1. Preorder Traversal",id:"1-preorder-traversal",level:3},{value:"2. Postorder Traversal",id:"2-postorder-traversal",level:3},{value:"3. Level Order Traversal (BFS)",id:"3-level-order-traversal-bfs",level:3},{value:"4. Zigzag Level Order Traversal",id:"4-zigzag-level-order-traversal",level:3},{value:"5. Vertical Order Traversal",id:"5-vertical-order-traversal",level:3},{value:"Tree Construction and Conversion",id:"tree-construction-and-conversion",level:2},{value:"1. Build Tree from Preorder and Postorder",id:"1-build-tree-from-preorder-and-postorder",level:3},{value:"2. Convert Binary Tree to N-ary Tree",id:"2-convert-binary-tree-to-n-ary-tree",level:3},{value:"3. Convert N-ary Tree to Binary Tree",id:"3-convert-n-ary-tree-to-binary-tree",level:3},{value:"Tree Properties and Measurements",id:"tree-properties-and-measurements",level:2},{value:"1. Maximum Depth/Height",id:"1-maximum-depthheight",level:3},{value:"2. Minimum Depth",id:"2-minimum-depth",level:3},{value:"3. Count Total Nodes",id:"3-count-total-nodes",level:3},{value:"4. Count Leaf Nodes",id:"4-count-leaf-nodes",level:3},{value:"5. Tree Diameter",id:"5-tree-diameter",level:3},{value:"Path and Route Finding",id:"path-and-route-finding",level:2},{value:"1. Find All Paths from Root to Leaves",id:"1-find-all-paths-from-root-to-leaves",level:3},{value:"2. Find Path to Target Node",id:"2-find-path-to-target-node",level:3},{value:"3. Path Sum Problems",id:"3-path-sum-problems",level:3},{value:"4. Lowest Common Ancestor",id:"4-lowest-common-ancestor",level:3},{value:"Tree Modification Operations",id:"tree-modification-operations",level:2},{value:"1. Clone/Copy Tree",id:"1-clonecopy-tree",level:3},{value:"2. Mirror/Flip Tree",id:"2-mirrorflip-tree",level:3},{value:"3. Delete Node",id:"3-delete-node",level:3},{value:"4. Insert Node",id:"4-insert-node",level:3},{value:"Serialization and Deserialization",id:"serialization-and-deserialization",level:2},{value:"1. Serialize to String",id:"1-serialize-to-string",level:3},{value:"2. Level Order Serialization",id:"2-level-order-serialization",level:3},{value:"Advanced Tree Algorithms",id:"advanced-tree-algorithms",level:2},{value:"1. Tree Codec with Null Markers",id:"1-tree-codec-with-null-markers",level:3},{value:"2. Tree Isomorphism",id:"2-tree-isomorphism",level:3},{value:"3. Tree Validation",id:"3-tree-validation",level:3},{value:"Tree Comparison and Validation",id:"tree-comparison-and-validation",level:2},{value:"1. Same Tree Check",id:"1-same-tree-check",level:3},{value:"2. Subtree Check",id:"2-subtree-check",level:3},{value:"3. Symmetric Tree Check",id:"3-symmetric-tree-check",level:3},{value:"Usage Examples",id:"usage-examples",level:2},{value:"Time Complexity Summary",id:"time-complexity-summary",level:2},{value:"Common Patterns to Remember",id:"common-patterns-to-remember",level:2},{value:"1. <strong>Recursive Pattern</strong>",id:"1-recursive-pattern",level:3},{value:"2. <strong>Level Order Pattern</strong>",id:"2-level-order-pattern",level:3},{value:"3. <strong>Path Tracking Pattern</strong>",id:"3-path-tracking-pattern",level:3},{value:"4. <strong>Bottom-Up Pattern</strong>",id:"4-bottom-up-pattern",level:3},{value:"5. <strong>Serialization Pattern</strong>",id:"5-serialization-pattern",level:3},{value:"Key Interview Tips",id:"key-interview-tips",level:2},{value:"1. <strong>N-ary vs Binary Trees</strong>",id:"1-n-ary-vs-binary-trees",level:3},{value:"2. <strong>Common Edge Cases</strong>",id:"2-common-edge-cases",level:3},{value:"3. <strong>Memory Optimization</strong>",id:"3-memory-optimization",level:3},{value:"4. <strong>Children Array Manipulation</strong>",id:"4-children-array-manipulation",level:3},{value:"5. <strong>Validation Techniques</strong>",id:"5-validation-techniques",level:3},{value:"Practice Problems Categories",id:"practice-problems-categories",level:2},{value:"<strong>Easy Level</strong>",id:"easy-level",level:3},{value:"<strong>Medium Level</strong>",id:"medium-level",level:3},{value:"<strong>Hard Level</strong>",id:"hard-level",level:3},{value:"Advanced Topics for Further Study",id:"advanced-topics-for-further-study",level:2},{value:"Trie Implementation (Special N-ary Tree)",id:"trie-implementation-special-n-ary-tree",level:2}];function a(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"n-ary-tree",children:"N-ary Tree"})}),"\n",(0,t.jsx)(n.p,{children:"A comprehensive guide to N-ary tree algorithms and techniques for Data Structures and Algorithms."}),"\n",(0,t.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#basic-n-ary-tree-structures",children:"Basic N-ary Tree Structures"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#tree-traversal-techniques",children:"Tree Traversal Techniques"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#tree-construction-and-conversion",children:"Tree Construction and Conversion"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#tree-properties-and-measurements",children:"Tree Properties and Measurements"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#path-and-route-finding",children:"Path and Route Finding"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#tree-modification-operations",children:"Tree Modification Operations"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#serialization-and-deserialization",children:"Serialization and Deserialization"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#advanced-tree-algorithms",children:"Advanced Tree Algorithms"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#tree-comparison-and-validation",children:"Tree Comparison and Validation"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#usage-examples",children:"Usage Examples"})}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"basic-n-ary-tree-structures",children:"Basic N-ary Tree Structures"}),"\n",(0,t.jsx)(n.h3,{id:"n-ary-tree-node-definition",children:"N-ary Tree Node Definition"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"class NaryTreeNode {\n    constructor(val = 0, children = []) {\n        this.val = val;\n        this.children = children; // Array of child nodes\n    }\n}\n\n// Alternative definition with parent reference\nclass NaryTreeNodeWithParent {\n    constructor(val = 0, children = [], parent = null) {\n        this.val = val;\n        this.children = children;\n        this.parent = parent;\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"helper-functions",children:"Helper Functions"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// Create N-ary tree from array representation\nfunction createNaryTree(arr) {\n    if (!arr || arr.length === 0) return null;\n\n    const root = new NaryTreeNode(arr[0]);\n    const queue = [root];\n    let i = 2; // Skip root and first null\n\n    while (queue.length > 0 && i < arr.length) {\n        const node = queue.shift();\n\n        // Read children until we hit null or end of array\n        while (i < arr.length && arr[i] !== null) {\n            const child = new NaryTreeNode(arr[i]);\n            node.children.push(child);\n            queue.push(child);\n            i++;\n        }\n        i++; // Skip the null separator\n    }\n\n    return root;\n}\n\n// Print tree structure for visualization\nfunction printNaryTree(root, level = 0) {\n    if (!root) return;\n\n    console.log('  '.repeat(level) + root.val);\n    for (const child of root.children) {\n        printNaryTree(child, level + 1);\n    }\n}\n\n// Convert tree to array representation\nfunction treeToArray(root) {\n    if (!root) return [];\n\n    const result = [root.val, null];\n    const queue = [root];\n\n    while (queue.length > 0) {\n        const node = queue.shift();\n\n        for (const child of node.children) {\n            result.push(child.val);\n            queue.push(child);\n        }\n\n        if (queue.length > 0) {\n            result.push(null);\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"tree-traversal-techniques",children:"Tree Traversal Techniques"}),"\n",(0,t.jsx)(n.h3,{id:"1-preorder-traversal",children:"1. Preorder Traversal"}),"\n",(0,t.jsx)(n.p,{children:"Visit root first, then children from left to right."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// Recursive Preorder\nfunction preorderRecursive(root) {\n    if (!root) return [];\n\n    const result = [root.val];\n\n    for (const child of root.children) {\n        result.push(...preorderRecursive(child));\n    }\n\n    return result;\n}\n\n// Iterative Preorder\nfunction preorderIterative(root) {\n    if (!root) return [];\n\n    const result = [];\n    const stack = [root];\n\n    while (stack.length > 0) {\n        const node = stack.pop();\n        result.push(node.val);\n\n        // Add children in reverse order to maintain left-to-right processing\n        for (let i = node.children.length - 1; i >= 0; i--) {\n            stack.push(node.children[i]);\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Time Complexity:"})," ",(0,t.jsx)(n.code,{children:"O(n)"})," | ",(0,t.jsx)(n.strong,{children:"Space Complexity:"})," ",(0,t.jsx)(n.code,{children:"O(h)"})," where h is height"]}),"\n",(0,t.jsx)(n.h3,{id:"2-postorder-traversal",children:"2. Postorder Traversal"}),"\n",(0,t.jsx)(n.p,{children:"Visit children first, then root."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// Recursive Postorder\nfunction postorderRecursive(root) {\n    if (!root) return [];\n\n    const result = [];\n\n    for (const child of root.children) {\n        result.push(...postorderRecursive(child));\n    }\n\n    result.push(root.val);\n    return result;\n}\n\n// Iterative Postorder\nfunction postorderIterative(root) {\n    if (!root) return [];\n\n    const result = [];\n    const stack = [root];\n    const visited = new Set();\n\n    while (stack.length > 0) {\n        const node = stack[stack.length - 1];\n\n        if (visited.has(node)) {\n            result.push(node.val);\n            stack.pop();\n        } else {\n            visited.add(node);\n            // Add children in reverse order\n            for (let i = node.children.length - 1; i >= 0; i--) {\n                stack.push(node.children[i]);\n            }\n        }\n    }\n\n    return result;\n}\n\n// Alternative iterative approach using two stacks\nfunction postorderTwoStacks(root) {\n    if (!root) return [];\n\n    const result = [];\n    const stack1 = [root];\n    const stack2 = [];\n\n    while (stack1.length > 0) {\n        const node = stack1.pop();\n        stack2.push(node);\n\n        for (const child of node.children) {\n            stack1.push(child);\n        }\n    }\n\n    while (stack2.length > 0) {\n        result.push(stack2.pop().val);\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"3-level-order-traversal-bfs",children:"3. Level Order Traversal (BFS)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function levelOrder(root) {\n    if (!root) return [];\n\n    const result = [];\n    const queue = [root];\n\n    while (queue.length > 0) {\n        const levelSize = queue.length;\n        const currentLevel = [];\n\n        for (let i = 0; i < levelSize; i++) {\n            const node = queue.shift();\n            currentLevel.push(node.val);\n\n            for (const child of node.children) {\n                queue.push(child);\n            }\n        }\n\n        result.push(currentLevel);\n    }\n\n    return result;\n}\n\n// Single array level order\nfunction levelOrderFlat(root) {\n    if (!root) return [];\n\n    const result = [];\n    const queue = [root];\n\n    while (queue.length > 0) {\n        const node = queue.shift();\n        result.push(node.val);\n\n        for (const child of node.children) {\n            queue.push(child);\n        }\n    }\n\n    return result;\n}\n\n// Reverse level order (bottom-up)\nfunction levelOrderBottom(root) {\n    const levels = levelOrder(root);\n    return levels.reverse();\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"4-zigzag-level-order-traversal",children:"4. Zigzag Level Order Traversal"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function zigzagLevelOrder(root) {\n    if (!root) return [];\n\n    const result = [];\n    const queue = [root];\n    let leftToRight = true;\n\n    while (queue.length > 0) {\n        const levelSize = queue.length;\n        const currentLevel = [];\n\n        for (let i = 0; i < levelSize; i++) {\n            const node = queue.shift();\n\n            if (leftToRight) {\n                currentLevel.push(node.val);\n            } else {\n                currentLevel.unshift(node.val);\n            }\n\n            for (const child of node.children) {\n                queue.push(child);\n            }\n        }\n\n        result.push(currentLevel);\n        leftToRight = !leftToRight;\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"5-vertical-order-traversal",children:"5. Vertical Order Traversal"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function verticalOrder(root) {\n    if (!root) return [];\n\n    const columnMap = new Map();\n    const queue = [[root, 0]]; // [node, column]\n    let minColumn = 0;\n    let maxColumn = 0;\n\n    while (queue.length > 0) {\n        const [node, col] = queue.shift();\n\n        if (!columnMap.has(col)) {\n            columnMap.set(col, []);\n        }\n        columnMap.get(col).push(node.val);\n\n        minColumn = Math.min(minColumn, col);\n        maxColumn = Math.max(maxColumn, col);\n\n        // For N-ary tree, distribute children across columns\n        const numChildren = node.children.length;\n        if (numChildren === 1) {\n            queue.push([node.children[0], col]);\n        } else if (numChildren > 1) {\n            const mid = Math.floor(numChildren / 2);\n            for (let i = 0; i < numChildren; i++) {\n                const childCol = col + (i - mid);\n                queue.push([node.children[i], childCol]);\n            }\n        }\n    }\n\n    const result = [];\n    for (let col = minColumn; col <= maxColumn; col++) {\n        if (columnMap.has(col)) {\n            result.push(columnMap.get(col));\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"tree-construction-and-conversion",children:"Tree Construction and Conversion"}),"\n",(0,t.jsx)(n.h3,{id:"1-build-tree-from-preorder-and-postorder",children:"1. Build Tree from Preorder and Postorder"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function buildTreePrePost(preorder, postorder) {\n    if (!preorder || !postorder || preorder.length === 0) return null;\n\n    const root = new NaryTreeNode(preorder[0]);\n\n    if (preorder.length === 1) return root;\n\n    // Find subtrees using postorder\n    const preorderChildren = preorder.slice(1);\n    const postorderChildren = postorder.slice(0, -1);\n\n    // For N-ary tree, we need additional information or constraints\n    // This is a simplified version assuming binary-like structure\n\n    return root;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"2-convert-binary-tree-to-n-ary-tree",children:"2. Convert Binary Tree to N-ary Tree"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function binaryToNary(binaryRoot) {\n    if (!binaryRoot) return null;\n\n    const naryRoot = new NaryTreeNode(binaryRoot.val);\n\n    // Convert left child\n    if (binaryRoot.left) {\n        naryRoot.children.push(binaryToNary(binaryRoot.left));\n    }\n\n    // Convert right child\n    if (binaryRoot.right) {\n        naryRoot.children.push(binaryToNary(binaryRoot.right));\n    }\n\n    return naryRoot;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"3-convert-n-ary-tree-to-binary-tree",children:"3. Convert N-ary Tree to Binary Tree"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function naryToBinary(naryRoot) {\n    if (!naryRoot) return null;\n\n    const binaryRoot = new TreeNode(naryRoot.val);\n\n    if (naryRoot.children.length > 0) {\n        // First child becomes left child\n        binaryRoot.left = naryToBinary(naryRoot.children[0]);\n\n        // Siblings become right children\n        let current = binaryRoot.left;\n        for (let i = 1; i < naryRoot.children.length; i++) {\n            current.right = naryToBinary(naryRoot.children[i]);\n            current = current.right;\n        }\n    }\n\n    return binaryRoot;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"tree-properties-and-measurements",children:"Tree Properties and Measurements"}),"\n",(0,t.jsx)(n.h3,{id:"1-maximum-depthheight",children:"1. Maximum Depth/Height"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function maxDepth(root) {\n    if (!root) return 0;\n\n    if (root.children.length === 0) return 1;\n\n    let maxChildDepth = 0;\n    for (const child of root.children) {\n        maxChildDepth = Math.max(maxChildDepth, maxDepth(child));\n    }\n\n    return maxChildDepth + 1;\n}\n\n// Iterative approach\nfunction maxDepthIterative(root) {\n    if (!root) return 0;\n\n    const queue = [[root, 1]]; // [node, depth]\n    let maxDepth = 0;\n\n    while (queue.length > 0) {\n        const [node, depth] = queue.shift();\n        maxDepth = Math.max(maxDepth, depth);\n\n        for (const child of node.children) {\n            queue.push([child, depth + 1]);\n        }\n    }\n\n    return maxDepth;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"2-minimum-depth",children:"2. Minimum Depth"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function minDepth(root) {\n    if (!root) return 0;\n\n    if (root.children.length === 0) return 1;\n\n    let minChildDepth = Infinity;\n    for (const child of root.children) {\n        minChildDepth = Math.min(minChildDepth, minDepth(child));\n    }\n\n    return minChildDepth + 1;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"3-count-total-nodes",children:"3. Count Total Nodes"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function countNodes(root) {\n    if (!root) return 0;\n\n    let count = 1; // Count current node\n\n    for (const child of root.children) {\n        count += countNodes(child);\n    }\n\n    return count;\n}\n\n// Iterative approach\nfunction countNodesIterative(root) {\n    if (!root) return 0;\n\n    let count = 0;\n    const stack = [root];\n\n    while (stack.length > 0) {\n        const node = stack.pop();\n        count++;\n\n        for (const child of node.children) {\n            stack.push(child);\n        }\n    }\n\n    return count;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"4-count-leaf-nodes",children:"4. Count Leaf Nodes"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function countLeaves(root) {\n    if (!root) return 0;\n\n    if (root.children.length === 0) return 1;\n\n    let leafCount = 0;\n    for (const child of root.children) {\n        leafCount += countLeaves(child);\n    }\n\n    return leafCount;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"5-tree-diameter",children:"5. Tree Diameter"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function diameter(root) {\n    if (!root) return 0;\n\n    let maxDiameter = 0;\n\n    function getDepth(node) {\n        if (!node) return 0;\n\n        if (node.children.length === 0) return 1;\n\n        // Get depths of all children\n        const childDepths = node.children.map(child => getDepth(child));\n        childDepths.sort((a, b) => b - a);\n\n        // Diameter through this node is sum of two largest child depths\n        const diameterThroughNode = (childDepths[0] || 0) + (childDepths[1] || 0);\n        maxDiameter = Math.max(maxDiameter, diameterThroughNode);\n\n        return (childDepths[0] || 0) + 1;\n    }\n\n    getDepth(root);\n    return maxDiameter;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"path-and-route-finding",children:"Path and Route Finding"}),"\n",(0,t.jsx)(n.h3,{id:"1-find-all-paths-from-root-to-leaves",children:"1. Find All Paths from Root to Leaves"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function rootToLeafPaths(root) {\n    if (!root) return [];\n\n    const paths = [];\n\n    function dfs(node, currentPath) {\n        if (!node) return;\n\n        currentPath.push(node.val);\n\n        if (node.children.length === 0) {\n            paths.push([...currentPath]);\n        } else {\n            for (const child of node.children) {\n                dfs(child, currentPath);\n            }\n        }\n\n        currentPath.pop(); // Backtrack\n    }\n\n    dfs(root, []);\n    return paths;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"2-find-path-to-target-node",children:"2. Find Path to Target Node"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function findPath(root, target) {\n    if (!root) return null;\n\n    function dfs(node, path) {\n        if (!node) return false;\n\n        path.push(node.val);\n\n        if (node.val === target) {\n            return true;\n        }\n\n        for (const child of node.children) {\n            if (dfs(child, path)) {\n                return true;\n            }\n        }\n\n        path.pop(); // Backtrack\n        return false;\n    }\n\n    const path = [];\n    return dfs(root, path) ? path : null;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"3-path-sum-problems",children:"3. Path Sum Problems"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// Check if path sum equals target\nfunction hasPathSum(root, targetSum) {\n    if (!root) return false;\n\n    if (root.children.length === 0) {\n        return root.val === targetSum;\n    }\n\n    for (const child of root.children) {\n        if (hasPathSum(child, targetSum - root.val)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n// Find all paths with target sum\nfunction pathSum(root, targetSum) {\n    if (!root) return [];\n\n    const paths = [];\n\n    function dfs(node, currentPath, currentSum) {\n        if (!node) return;\n\n        currentPath.push(node.val);\n        currentSum += node.val;\n\n        if (node.children.length === 0 && currentSum === targetSum) {\n            paths.push([...currentPath]);\n        } else {\n            for (const child of node.children) {\n                dfs(child, currentPath, currentSum);\n            }\n        }\n\n        currentPath.pop();\n    }\n\n    dfs(root, [], 0);\n    return paths;\n}\n\n// Maximum path sum\nfunction maxPathSum(root) {\n    let maxSum = -Infinity;\n\n    function dfs(node) {\n        if (!node) return 0;\n\n        if (node.children.length === 0) {\n            maxSum = Math.max(maxSum, node.val);\n            return node.val;\n        }\n\n        const childSums = node.children.map(child => dfs(child));\n        const maxChildSum = Math.max(0, ...childSums);\n\n        maxSum = Math.max(maxSum, node.val + maxChildSum);\n        return node.val + maxChildSum;\n    }\n\n    dfs(root);\n    return maxSum;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"4-lowest-common-ancestor",children:"4. Lowest Common Ancestor"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function lowestCommonAncestor(root, p, q) {\n    if (!root || root === p || root === q) return root;\n\n    const children = [];\n    for (const child of root.children) {\n        const result = lowestCommonAncestor(child, p, q);\n        if (result) children.push(result);\n    }\n\n    if (children.length === 2) return root;\n    if (children.length === 1) return children[0];\n    return null;\n}\n\n// Alternative approach with parent pointers\nfunction lcaWithParents(p, q) {\n    const ancestors = new Set();\n\n    // Collect all ancestors of p\n    let current = p;\n    while (current) {\n        ancestors.add(current);\n        current = current.parent;\n    }\n\n    // Find first common ancestor starting from q\n    current = q;\n    while (current) {\n        if (ancestors.has(current)) {\n            return current;\n        }\n        current = current.parent;\n    }\n\n    return null;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"tree-modification-operations",children:"Tree Modification Operations"}),"\n",(0,t.jsx)(n.h3,{id:"1-clonecopy-tree",children:"1. Clone/Copy Tree"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function cloneTree(root) {\n    if (!root) return null;\n\n    const cloned = new NaryTreeNode(root.val);\n\n    for (const child of root.children) {\n        cloned.children.push(cloneTree(child));\n    }\n\n    return cloned;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"2-mirrorflip-tree",children:"2. Mirror/Flip Tree"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function mirrorTree(root) {\n    if (!root) return null;\n\n    // Reverse children array\n    root.children.reverse();\n\n    // Recursively mirror all children\n    for (const child of root.children) {\n        mirrorTree(child);\n    }\n\n    return root;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"3-delete-node",children:"3. Delete Node"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function deleteNode(root, target) {\n    if (!root) return null;\n\n    // If root is the target, we need special handling\n    if (root.val === target) {\n        // Return null if no children, or promote first child\n        return root.children.length > 0 ? root.children[0] : null;\n    }\n\n    function deleteHelper(node) {\n        if (!node) return;\n\n        // Check if any child needs to be deleted\n        for (let i = 0; i < node.children.length; i++) {\n            if (node.children[i].val === target) {\n                // Remove this child and add its children to current node\n                const grandChildren = node.children[i].children;\n                node.children.splice(i, 1, ...grandChildren);\n                return;\n            }\n        }\n\n        // Recursively delete in children\n        for (const child of node.children) {\n            deleteHelper(child);\n        }\n    }\n\n    deleteHelper(root);\n    return root;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"4-insert-node",children:"4. Insert Node"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function insertNode(root, parentVal, newVal) {\n    if (!root) return null;\n\n    if (root.val === parentVal) {\n        root.children.push(new NaryTreeNode(newVal));\n        return root;\n    }\n\n    for (const child of root.children) {\n        insertNode(child, parentVal, newVal);\n    }\n\n    return root;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"serialization-and-deserialization",children:"Serialization and Deserialization"}),"\n",(0,t.jsx)(n.h3,{id:"1-serialize-to-string",children:"1. Serialize to String"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function serialize(root) {\n    if (!root) return \"\";\n\n    const result = [];\n\n    function preorder(node) {\n        if (!node) return;\n\n        result.push(node.val);\n        result.push(node.children.length); // Store number of children\n\n        for (const child of node.children) {\n            preorder(child);\n        }\n    }\n\n    preorder(root);\n    return result.join(',');\n}\n\nfunction deserialize(data) {\n    if (!data) return null;\n\n    const values = data.split(',').map(Number);\n    let index = 0;\n\n    function build() {\n        if (index >= values.length) return null;\n\n        const val = values[index++];\n        const childCount = values[index++];\n\n        const node = new NaryTreeNode(val);\n\n        for (let i = 0; i < childCount; i++) {\n            node.children.push(build());\n        }\n\n        return node;\n    }\n\n    return build();\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"2-level-order-serialization",children:"2. Level Order Serialization"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function serializeLevelOrder(root) {\n    if (!root) return \"\";\n\n    const result = [];\n    const queue = [root];\n\n    while (queue.length > 0) {\n        const node = queue.shift();\n\n        if (node) {\n            result.push(node.val);\n            result.push(node.children.length);\n\n            for (const child of node.children) {\n                queue.push(child);\n            }\n        }\n    }\n\n    return result.join(',');\n}\n\nfunction deserializeLevelOrder(data) {\n    if (!data) return null;\n\n    const values = data.split(',').map(Number);\n    if (values.length < 2) return null;\n\n    const root = new NaryTreeNode(values[0]);\n    const queue = [root];\n    let i = 1;\n\n    while (queue.length > 0 && i < values.length) {\n        const node = queue.shift();\n        const childCount = values[i++];\n\n        for (let j = 0; j < childCount && i < values.length; j++) {\n            const child = new NaryTreeNode(values[i++]);\n            node.children.push(child);\n            queue.push(child);\n        }\n    }\n\n    return root;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"advanced-tree-algorithms",children:"Advanced Tree Algorithms"}),"\n",(0,t.jsx)(n.h3,{id:"1-tree-codec-with-null-markers",children:"1. Tree Codec with Null Markers"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"class CodecWithNull {\n    serialize(root) {\n        const result = [];\n\n        function preorder(node) {\n            if (!node) {\n                result.push('null');\n                return;\n            }\n\n            result.push(node.val);\n            result.push(node.children.length);\n\n            for (const child of node.children) {\n                preorder(child);\n            }\n        }\n\n        preorder(root);\n        return result.join(',');\n    }\n\n    deserialize(data) {\n        if (!data) return null;\n\n        const values = data.split(',');\n        let index = 0;\n\n        function build() {\n            if (index >= values.length || values[index] === 'null') {\n                index++;\n                return null;\n            }\n\n            const val = parseInt(values[index++]);\n            const childCount = parseInt(values[index++]);\n            const node = new NaryTreeNode(val);\n\n            for (let i = 0; i < childCount; i++) {\n                node.children.push(build());\n            }\n\n            return node;\n        }\n\n        return build();\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"2-tree-isomorphism",children:"2. Tree Isomorphism"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function areTreesIsomorphic(root1, root2) {\n    if (!root1 && !root2) return true;\n    if (!root1 || !root2) return false;\n    if (root1.val !== root2.val) return false;\n    if (root1.children.length !== root2.children.length) return false;\n\n    // Try all permutations of children\n    return canMatchChildren(root1.children, root2.children);\n}\n\nfunction canMatchChildren(children1, children2) {\n    if (children1.length !== children2.length) return false;\n    if (children1.length === 0) return true;\n\n    const used = new Array(children2.length).fill(false);\n\n    function backtrack(index) {\n        if (index === children1.length) return true;\n\n        for (let i = 0; i < children2.length; i++) {\n            if (!used[i] && areTreesIsomorphic(children1[index], children2[i])) {\n                used[i] = true;\n                if (backtrack(index + 1)) return true;\n                used[i] = false;\n            }\n        }\n\n        return false;\n    }\n\n    return backtrack(0);\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"3-tree-validation",children:"3. Tree Validation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// Check if tree is complete\nfunction isCompleteTree(root) {\n    if (!root) return true;\n\n    const queue = [root];\n    let foundNull = false;\n\n    while (queue.length > 0) {\n        const node = queue.shift();\n\n        if (!node) {\n            foundNull = true;\n        } else {\n            if (foundNull) return false;\n\n            for (const child of node.children) {\n                queue.push(child);\n            }\n\n            // Add null markers for missing positions if needed\n            queue.push(null);\n        }\n    }\n\n    return true;\n}\n\n// Check if tree is balanced\nfunction isBalanced(root) {\n    function checkBalance(node) {\n        if (!node) return 0;\n\n        const childHeights = [];\n        for (const child of node.children) {\n            const height = checkBalance(child);\n            if (height === -1) return -1;\n            childHeights.push(height);\n        }\n\n        if (childHeights.length > 0) {\n            const maxHeight = Math.max(...childHeights);\n            const minHeight = Math.min(...childHeights);\n            if (maxHeight - minHeight > 1) return -1;\n        }\n\n        return Math.max(0, ...childHeights) + 1;\n    }\n\n    return checkBalance(root) !== -1;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"tree-comparison-and-validation",children:"Tree Comparison and Validation"}),"\n",(0,t.jsx)(n.h3,{id:"1-same-tree-check",children:"1. Same Tree Check"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function isSameTree(root1, root2) {\n    if (!root1 && !root2) return true;\n    if (!root1 || !root2) return false;\n    if (root1.val !== root2.val) return false;\n    if (root1.children.length !== root2.children.length) return false;\n\n    for (let i = 0; i < root1.children.length; i++) {\n        if (!isSameTree(root1.children[i], root2.children[i])) {\n            return false;\n        }\n    }\n\n    return true;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"2-subtree-check",children:"2. Subtree Check"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function isSubtree(root, subRoot) {\n    if (!root) return !subRoot;\n\n    return isSameTree(root, subRoot) ||\n           root.children.some(child => isSubtree(child, subRoot));\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"3-symmetric-tree-check",children:"3. Symmetric Tree Check"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function isSymmetric(root) {\n    if (!root) return true;\n\n    function areSymmetric(left, right) {\n        if (!left && !right) return true;\n        if (!left || !right) return false;\n        if (left.val !== right.val) return false;\n        if (left.children.length !== right.children.length) return false;\n\n        const leftChildren = left.children;\n        const rightChildren = right.children;\n\n        for (let i = 0; i < leftChildren.length; i++) {\n            const j = rightChildren.length - 1 - i;\n            if (!areSymmetric(leftChildren[i], rightChildren[j])) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    return root.children.length % 2 === 0 &&\n           areSymmetric(root, root);\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'console.log("=== N-ary Tree Algorithms Demo ===");\n\n// Create sample N-ary tree: [1,null,3,2,4,null,5,6]\n//       1\n//    /  |  \\\n//   3   2   4\n//  / \\\n// 5   6\n\nconst root = new NaryTreeNode(1);\nconst node3 = new NaryTreeNode(3);\nconst node2 = new NaryTreeNode(2);\nconst node4 = new NaryTreeNode(4);\nconst node5 = new NaryTreeNode(5);\nconst node6 = new NaryTreeNode(6);\n\nroot.children = [node3, node2, node4];\nnode3.children = [node5, node6];\n\nconsole.log("Tree structure:");\nprintNaryTree(root);\n\n// Traversals\nconsole.log("Preorder traversal:", preorderRecursive(root));\nconsole.log("Postorder traversal:", postorderRecursive(root));\nconsole.log("Level order traversal:", levelOrder(root));\nconsole.log("Zigzag traversal:", zigzagLevelOrder(root));\n\n// Tree properties\nconsole.log("Max depth:", maxDepth(root));\nconsole.log("Min depth:", minDepth(root));\nconsole.log("Total nodes:", countNodes(root));\nconsole.log("Leaf nodes:", countLeaves(root));\nconsole.log("Tree diameter:", diameter(root));\n\n// Path finding\nconsole.log("Root to leaf paths:", rootToLeafPaths(root));\nconsole.log("Path to node 5:", findPath(root, 5));\nconsole.log("Has path sum 9:", hasPathSum(root, 9)); // 1->3->5\nconsole.log("All paths with sum 9:", pathSum(root, 9));\n\n// Serialization\nconst codec = new CodecWithNull();\nconst serialized = codec.serialize(root);\nconsole.log("Serialized:", serialized);\nconst deserialized = codec.deserialize(serialized);\nconsole.log("Deserialized correctly:", isSameTree(root, deserialized));\n\n// Tree modifications\nconst cloned = cloneTree(root);\nconsole.log("Cloned tree same as original:", isSameTree(root, cloned));\n\nconst mirrored = mirrorTree(cloneTree(root));\nconsole.log("Mirrored tree preorder:", preorderRecursive(mirrored));\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"time-complexity-summary",children:"Time Complexity Summary"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Algorithm"}),(0,t.jsx)(n.th,{children:"Time Complexity"}),(0,t.jsx)(n.th,{children:"Space Complexity"}),(0,t.jsx)(n.th,{children:"Use Case"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Traversal Operations"})}),(0,t.jsx)(n.td,{}),(0,t.jsx)(n.td,{}),(0,t.jsx)(n.td,{})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Preorder Traversal"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"O(n)"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"O(h)"})}),(0,t.jsx)(n.td,{children:"Tree processing, copying"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Postorder Traversal"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"O(n)"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"O(h)"})}),(0,t.jsx)(n.td,{children:"Tree deletion, evaluation"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Level Order Traversal"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"O(n)"})}),(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"O(w)"})," where w = max width"]}),(0,t.jsx)(n.td,{children:"Level-wise processing"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Zigzag Traversal"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"O(n)"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"O(w)"})}),(0,t.jsx)(n.td,{children:"Special display requirements"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Tree Properties"})}),(0,t.jsx)(n.td,{}),(0,t.jsx)(n.td,{}),(0,t.jsx)(n.td,{})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Max/Min Depth"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"O(n)"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"O(h)"})}),(0,t.jsx)(n.td,{children:"Tree height analysis"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Count Nodes"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"O(n)"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"O(h)"})}),(0,t.jsx)(n.td,{children:"Size calculation"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Count Leaves"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"O(n)"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"O(h)"})}),(0,t.jsx)(n.td,{children:"Leaf analysis"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Tree Diameter"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"O(n\xb2)"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"O(h)"})}),(0,t.jsx)(n.td,{children:"Longest path finding"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Path Operations"})}),(0,t.jsx)(n.td,{}),(0,t.jsx)(n.td,{}),(0,t.jsx)(n.td,{})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Find All Paths"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"O(n * 2^n)"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"O(n * 2^n)"})}),(0,t.jsx)(n.td,{children:"Path enumeration"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Find Path to Target"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"O(n)"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"O(h)"})}),(0,t.jsx)(n.td,{children:"Path finding"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Path Sum"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"O(n)"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"O(h)"})}),(0,t.jsx)(n.td,{children:"Sum validation"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Lowest Common Ancestor"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"O(n)"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"O(h)"})}),(0,t.jsx)(n.td,{children:"Relationship finding"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Tree Modifications"})}),(0,t.jsx)(n.td,{}),(0,t.jsx)(n.td,{}),(0,t.jsx)(n.td,{})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Clone Tree"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"O(n)"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"O(n)"})}),(0,t.jsx)(n.td,{children:"Tree duplication"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Mirror Tree"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"O(n)"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"O(h)"})}),(0,t.jsx)(n.td,{children:"Tree reflection"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Insert Node"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"O(n)"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"O(h)"})}),(0,t.jsx)(n.td,{children:"Tree modification"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Delete Node"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"O(n)"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"O(h)"})}),(0,t.jsx)(n.td,{children:"Tree modification"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Serialization"})}),(0,t.jsx)(n.td,{}),(0,t.jsx)(n.td,{}),(0,t.jsx)(n.td,{})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Serialize"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"O(n)"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"O(n)"})}),(0,t.jsx)(n.td,{children:"Tree storage"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Deserialize"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"O(n)"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"O(n)"})}),(0,t.jsx)(n.td,{children:"Tree reconstruction"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Advanced Operations"})}),(0,t.jsx)(n.td,{}),(0,t.jsx)(n.td,{}),(0,t.jsx)(n.td,{})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Tree Isomorphism"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"O(n! * n)"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"O(n)"})}),(0,t.jsx)(n.td,{children:"Structure comparison"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Subtree Check"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"O(n * m)"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"O(h)"})}),(0,t.jsx)(n.td,{children:"Pattern matching"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Symmetric Check"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"O(n)"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"O(h)"})}),(0,t.jsx)(n.td,{children:"Symmetry validation"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Note:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"n"})," = number of nodes"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"h"})," = height of tree"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"w"})," = maximum width of tree"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"m"})," = size of subtree"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"common-patterns-to-remember",children:"Common Patterns to Remember"}),"\n",(0,t.jsxs)(n.h3,{id:"1-recursive-pattern",children:["1. ",(0,t.jsx)(n.strong,{children:"Recursive Pattern"})]}),"\n",(0,t.jsx)(n.p,{children:"Most N-ary tree problems follow this structure:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function processNaryTree(root) {\n    if (!root) return baseCase;\n\n    // Process current node\n    let result = processCurrentNode(root);\n\n    // Process all children\n    for (const child of root.children) {\n        const childResult = processNaryTree(child);\n        result = combineResults(result, childResult);\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"2-level-order-pattern",children:["2. ",(0,t.jsx)(n.strong,{children:"Level Order Pattern"})]}),"\n",(0,t.jsx)(n.p,{children:"For level-by-level processing:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function levelOrderPattern(root) {\n    if (!root) return [];\n\n    const queue = [root];\n\n    while (queue.length > 0) {\n        const levelSize = queue.length;\n\n        for (let i = 0; i < levelSize; i++) {\n            const node = queue.shift();\n            // Process current node\n\n            for (const child of node.children) {\n                queue.push(child);\n            }\n        }\n    }\n}\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"3-path-tracking-pattern",children:["3. ",(0,t.jsx)(n.strong,{children:"Path Tracking Pattern"})]}),"\n",(0,t.jsx)(n.p,{children:"For problems involving paths:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function pathPattern(root, path = []) {\n    if (!root) return;\n\n    path.push(root.val);\n\n    if (isLeaf(root)) {\n        // Process complete path\n        processPath(path);\n    } else {\n        for (const child of root.children) {\n            pathPattern(child, path);\n        }\n    }\n\n    path.pop(); // Backtrack\n}\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"4-bottom-up-pattern",children:["4. ",(0,t.jsx)(n.strong,{children:"Bottom-Up Pattern"})]}),"\n",(0,t.jsx)(n.p,{children:"For post-order processing:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function bottomUpPattern(root) {\n    if (!root) return null;\n\n    // Process all children first\n    const childResults = [];\n    for (const child of root.children) {\n        childResults.push(bottomUpPattern(child));\n    }\n\n    // Process current node using child results\n    return processWithChildResults(root, childResults);\n}\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"5-serialization-pattern",children:["5. ",(0,t.jsx)(n.strong,{children:"Serialization Pattern"})]}),"\n",(0,t.jsx)(n.p,{children:"For tree encoding/decoding:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function serializePattern(root) {\n    if (!root) return \"null\";\n\n    const result = [root.val, root.children.length];\n\n    for (const child of root.children) {\n        result.push(serializePattern(child));\n    }\n\n    return result.join(',');\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"key-interview-tips",children:"Key Interview Tips"}),"\n",(0,t.jsxs)(n.h3,{id:"1-n-ary-vs-binary-trees",children:["1. ",(0,t.jsx)(n.strong,{children:"N-ary vs Binary Trees"})]}),"\n",(0,t.jsx)(n.p,{children:"Key differences to remember:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"N-ary trees have variable number of children"}),"\n",(0,t.jsxs)(n.li,{children:["Use ",(0,t.jsx)(n.code,{children:"children"})," array instead of ",(0,t.jsx)(n.code,{children:"left"}),"/",(0,t.jsx)(n.code,{children:"right"})," pointers"]}),"\n",(0,t.jsx)(n.li,{children:"Algorithms need to iterate through all children"}),"\n",(0,t.jsx)(n.li,{children:"Space complexity often depends on branching factor"}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"2-common-edge-cases",children:["2. ",(0,t.jsx)(n.strong,{children:"Common Edge Cases"})]}),"\n",(0,t.jsx)(n.p,{children:"Always test with:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// Empty tree\nconst emptyTree = null;\n\n// Single node tree\nconst singleNode = new NaryTreeNode(1);\n\n// Tree with only one child per node (like linked list)\nconst chainTree = new NaryTreeNode(1);\nchainTree.children = [new NaryTreeNode(2)];\nchainTree.children[0].children = [new NaryTreeNode(3)];\n\n// Balanced tree with multiple children\nconst balancedTree = new NaryTreeNode(1);\nbalancedTree.children = [\n    new NaryTreeNode(2),\n    new NaryTreeNode(3),\n    new NaryTreeNode(4)\n];\n\n// Unbalanced tree\nconst unbalancedTree = new NaryTreeNode(1);\nunbalancedTree.children = [new NaryTreeNode(2)];\nunbalancedTree.children[0].children = [\n    new NaryTreeNode(3),\n    new NaryTreeNode(4)\n];\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"3-memory-optimization",children:["3. ",(0,t.jsx)(n.strong,{children:"Memory Optimization"})]}),"\n",(0,t.jsx)(n.p,{children:"For large trees, consider:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// Use iterative approaches to avoid stack overflow\nfunction iterativeTraversal(root) {\n    const stack = [root];\n\n    while (stack.length > 0) {\n        const node = stack.pop();\n        if (!node) continue;\n\n        // Process node\n\n        // Add children in reverse order for correct processing order\n        for (let i = node.children.length - 1; i >= 0; i--) {\n            stack.push(node.children[i]);\n        }\n    }\n}\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"4-children-array-manipulation",children:["4. ",(0,t.jsx)(n.strong,{children:"Children Array Manipulation"})]}),"\n",(0,t.jsx)(n.p,{children:"Common operations on children array:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// Add child\nnode.children.push(newChild);\n\n// Insert child at specific position\nnode.children.splice(index, 0, newChild);\n\n// Remove child at index\nnode.children.splice(index, 1);\n\n// Remove specific child\nconst childIndex = node.children.indexOf(childToRemove);\nif (childIndex !== -1) {\n    node.children.splice(childIndex, 1);\n}\n\n// Reverse children (for mirroring)\nnode.children.reverse();\n\n// Sort children by value\nnode.children.sort((a, b) => a.val - b.val);\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"5-validation-techniques",children:["5. ",(0,t.jsx)(n.strong,{children:"Validation Techniques"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// Validate tree structure\nfunction isValidNaryTree(root, visited = new Set()) {\n    if (!root) return true;\n\n    // Check for cycles\n    if (visited.has(root)) return false;\n    visited.add(root);\n\n    // Validate children\n    for (const child of root.children) {\n        if (!isValidNaryTree(child, visited)) {\n            return false;\n        }\n    }\n\n    visited.delete(root); // Allow node to be visited in different paths\n    return true;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"practice-problems-categories",children:"Practice Problems Categories"}),"\n",(0,t.jsx)(n.h3,{id:"easy-level",children:(0,t.jsx)(n.strong,{children:"Easy Level"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"N-ary Tree Preorder Traversal"}),"\n",(0,t.jsx)(n.li,{children:"N-ary Tree Postorder Traversal"}),"\n",(0,t.jsx)(n.li,{children:"Maximum Depth of N-ary Tree"}),"\n",(0,t.jsx)(n.li,{children:"N-ary Tree Level Order Traversal"}),"\n",(0,t.jsx)(n.li,{children:"Find Root of N-Ary Tree"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"medium-level",children:(0,t.jsx)(n.strong,{children:"Medium Level"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Encode and Decode N-ary Tree"}),"\n",(0,t.jsx)(n.li,{children:"Clone N-ary Tree"}),"\n",(0,t.jsx)(n.li,{children:"Diameter of N-Ary Tree"}),"\n",(0,t.jsx)(n.li,{children:"Serialize and Deserialize N-ary Tree"}),"\n",(0,t.jsx)(n.li,{children:"Lowest Common Ancestor of a N-ary Tree"}),"\n",(0,t.jsx)(n.li,{children:"Maximum Width of N-ary Tree"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"hard-level",children:(0,t.jsx)(n.strong,{children:"Hard Level"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"N-ary Tree Path Sum III"}),"\n",(0,t.jsx)(n.li,{children:"All Nodes Distance K in N-ary Tree"}),"\n",(0,t.jsx)(n.li,{children:"Vertical Order Traversal of N-ary Tree"}),"\n",(0,t.jsx)(n.li,{children:"N-ary Tree Isomorphism"}),"\n",(0,t.jsx)(n.li,{children:"Recover N-ary Tree from Preorder Traversal"}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"advanced-topics-for-further-study",children:"Advanced Topics for Further Study"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Trie (Prefix Tree)"})," - Special case of N-ary tree"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"B-Trees and B+ Trees"})," - Database indexing"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"R-Trees"})," - Spatial data structures"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Quadtrees and Octrees"})," - Spatial partitioning"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Decision Trees"})," - Machine learning applications"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Parse Trees"})," - Compiler design"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"File System Trees"})," - Directory structures"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"XML/HTML DOM Trees"})," - Document parsing"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"trie-implementation-special-n-ary-tree",children:"Trie Implementation (Special N-ary Tree)"}),"\n",(0,t.jsx)(n.p,{children:"Since Trie is a common special case of N-ary trees:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'class TrieNode {\n    constructor() {\n        this.children = new Map(); // Character -> TrieNode\n        this.isEndOfWord = false;\n    }\n}\n\nclass Trie {\n    constructor() {\n        this.root = new TrieNode();\n    }\n\n    insert(word) {\n        let current = this.root;\n\n        for (const char of word) {\n            if (!current.children.has(char)) {\n                current.children.set(char, new TrieNode());\n            }\n            current = current.children.get(char);\n        }\n\n        current.isEndOfWord = true;\n    }\n\n    search(word) {\n        let current = this.root;\n\n        for (const char of word) {\n            if (!current.children.has(char)) {\n                return false;\n            }\n            current = current.children.get(char);\n        }\n\n        return current.isEndOfWord;\n    }\n\n    startsWith(prefix) {\n        let current = this.root;\n\n        for (const char of prefix) {\n            if (!current.children.has(char)) {\n                return false;\n            }\n            current = current.children.get(char);\n        }\n\n        return true;\n    }\n\n    getAllWords() {\n        const words = [];\n\n        function dfs(node, prefix) {\n            if (node.isEndOfWord) {\n                words.push(prefix);\n            }\n\n            for (const [char, childNode] of node.children) {\n                dfs(childNode, prefix + char);\n            }\n        }\n\n        dfs(this.root, "");\n        return words;\n    }\n}\n\n// Usage\nconst trie = new Trie();\ntrie.insert("apple");\ntrie.insert("app");\ntrie.insert("application");\nconsole.log("Search \'app\':", trie.search("app")); // true\nconsole.log("Starts with \'app\':", trie.startsWith("app")); // true\nconsole.log("All words:", trie.getAllWords());\n'})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>s});var t=r(6540);const i={},o=t.createContext(i);function l(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);