"use strict";(globalThis.webpackChunkdev_enigma=globalThis.webpackChunkdev_enigma||[]).push([[34002],{28453:(n,e,i)=>{i.d(e,{R:()=>s,x:()=>l});var t=i(96540);const r={},o=t.createContext(r);function s(n){const e=t.useContext(o);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:s(n.components),t.createElement(o.Provider,{value:e},n.children)}},53039:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>a,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>l,toc:()=>d});var t=i(74848),r=i(28453);const o={},s="Grid-Based Graph",l={id:"DSA/DSA/DSA with JavaScript/DSA Cheatsheets/Grid-Based Graph",title:"Grid-Based Graph",description:"A comprehensive guide to grid-based graph algorithms and techniques for Data Structures and Algorithms in JavaScript.",source:"@site/docs/05-DSA/DSA/DSA with JavaScript/DSA Cheatsheets/Grid-Based Graph.mdx",sourceDirName:"05-DSA/DSA/DSA with JavaScript/DSA Cheatsheets",slug:"/DSA/DSA/DSA with JavaScript/DSA Cheatsheets/Grid-Based Graph",permalink:"/docs/DSA/DSA/DSA with JavaScript/DSA Cheatsheets/Grid-Based Graph",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/05-DSA/DSA/DSA with JavaScript/DSA Cheatsheets/Grid-Based Graph.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Graph",permalink:"/docs/DSA/DSA/DSA with JavaScript/DSA Cheatsheets/Graph"},next:{title:"Heap",permalink:"/docs/DSA/DSA/DSA with JavaScript/DSA Cheatsheets/Heap"}},a={},d=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Grid Fundamentals",id:"grid-fundamentals",level:2},{value:"Basic Grid Setup",id:"basic-grid-setup",level:3},{value:"Grid Creation Utilities",id:"grid-creation-utilities",level:3},{value:"Basic Grid Operations",id:"basic-grid-operations",level:2},{value:"1. Grid Traversal",id:"1-grid-traversal",level:3},{value:"2. Boundary Checking",id:"2-boundary-checking",level:3},{value:"Depth-First Search (DFS)",id:"depth-first-search-dfs",level:2},{value:"1. Basic DFS Implementation",id:"1-basic-dfs-implementation",level:3},{value:"2. DFS with Conditions",id:"2-dfs-with-conditions",level:3},{value:"3. DFS Applications",id:"3-dfs-applications",level:3},{value:"Breadth-First Search (BFS)",id:"breadth-first-search-bfs",level:2},{value:"1. Basic BFS Implementation",id:"1-basic-bfs-implementation",level:3},{value:"2. BFS for Shortest Path",id:"2-bfs-for-shortest-path",level:3},{value:"3. Multi-source BFS",id:"3-multi-source-bfs",level:3},{value:"Pathfinding Algorithms",id:"pathfinding-algorithms",level:2},{value:"1. A* Algorithm",id:"1-a-algorithm",level:3},{value:"2. Dijkstra&#39;s Algorithm for Weighted Grids",id:"2-dijkstras-algorithm-for-weighted-grids",level:3},{value:"Island and Connected Components",id:"island-and-connected-components",level:2},{value:"1. Count Islands",id:"1-count-islands",level:3},{value:"2. Largest Island",id:"2-largest-island",level:3},{value:"3. Island Shape Matching",id:"3-island-shape-matching",level:3},{value:"Flood Fill Algorithms",id:"flood-fill-algorithms",level:2},{value:"1. Basic Flood Fill",id:"1-basic-flood-fill",level:3},{value:"2. Advanced Flood Fill Variants",id:"2-advanced-flood-fill-variants",level:3},{value:"Dynamic Programming on Grids",id:"dynamic-programming-on-grids",level:2},{value:"1. Path Counting Problems",id:"1-path-counting-problems",level:3},{value:"2. Maximum/Minimum Problems",id:"2-maximumminimum-problems",level:3},{value:"3. Range and Area Problems",id:"3-range-and-area-problems",level:3},{value:"Advanced Grid Techniques",id:"advanced-grid-techniques",level:2},{value:"1. Rotations and Transformations",id:"1-rotations-and-transformations",level:3},{value:"2. Spiral Traversal",id:"2-spiral-traversal",level:3},{value:"3. Convex Hull and Geometry",id:"3-convex-hull-and-geometry",level:3},{value:"Multi-source and Multi-destination",id:"multi-source-and-multi-destination",level:2},{value:"1. Multiple Sources BFS",id:"1-multiple-sources-bfs",level:3},{value:"2. Multiple Destinations",id:"2-multiple-destinations",level:3},{value:"Usage Examples",id:"usage-examples",level:2},{value:"Time Complexity Summary",id:"time-complexity-summary",level:2},{value:"Common Patterns to Remember",id:"common-patterns-to-remember",level:2},{value:"1. <strong>Boundary Checks Pattern</strong>",id:"1-boundary-checks-pattern",level:3},{value:"2. <strong>Direction Iteration Pattern</strong>",id:"2-direction-iteration-pattern",level:3},{value:"3. <strong>Visited Set Pattern</strong>",id:"3-visited-set-pattern",level:3},{value:"4. <strong>BFS Level Processing Pattern</strong>",id:"4-bfs-level-processing-pattern",level:3},{value:"5. <strong>Multi-source Initialization Pattern</strong>",id:"5-multi-source-initialization-pattern",level:3},{value:"6. <strong>Path Reconstruction Pattern</strong>",id:"6-path-reconstruction-pattern",level:3},{value:"Key Interview Tips",id:"key-interview-tips",level:2},{value:"Real-World Applications",id:"real-world-applications",level:2},{value:"1. <strong>Game Development</strong>",id:"1-game-development",level:3},{value:"2. <strong>Image Processing</strong>",id:"2-image-processing",level:3},{value:"3. <strong>Geographic Information Systems</strong>",id:"3-geographic-information-systems",level:3},{value:"4. <strong>Robotics</strong>",id:"4-robotics",level:3},{value:"5. <strong>Network Analysis</strong>",id:"5-network-analysis",level:3}];function c(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"grid-based-graph",children:"Grid-Based Graph"})}),"\n",(0,t.jsx)(e.p,{children:"A comprehensive guide to grid-based graph algorithms and techniques for Data Structures and Algorithms in JavaScript."}),"\n",(0,t.jsx)(e.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#grid-fundamentals",children:"Grid Fundamentals"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#basic-grid-operations",children:"Basic Grid Operations"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#depth-first-search-dfs",children:"Depth-First Search (DFS)"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#breadth-first-search-bfs",children:"Breadth-First Search (BFS)"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pathfinding-algorithms",children:"Pathfinding Algorithms"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#island-and-connected-components",children:"Island and Connected Components"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#flood-fill-algorithms",children:"Flood Fill Algorithms"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#dynamic-programming-on-grids",children:"Dynamic Programming on Grids"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#advanced-grid-techniques",children:"Advanced Grid Techniques"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#multi-source-and-multi-destination",children:"Multi-source and Multi-destination"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#usage-examples",children:"Usage Examples"})}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"grid-fundamentals",children:"Grid Fundamentals"}),"\n",(0,t.jsx)(e.p,{children:"Grid-based problems are essentially graph problems where nodes are cells and edges represent valid movements between adjacent cells."}),"\n",(0,t.jsx)(e.h3,{id:"basic-grid-setup",children:"Basic Grid Setup"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Common grid directions (4-directional)\nconst DIRECTIONS_4 = [\n  [-1, 0], // Up\n  [1, 0], // Down\n  [0, -1], // Left\n  [0, 1], // Right\n];\n\n// 8-directional (including diagonals)\nconst DIRECTIONS_8 = [\n  [-1, -1],\n  [-1, 0],\n  [-1, 1], // Top row\n  [0, -1],\n  [0, 1], // Middle row\n  [1, -1],\n  [1, 0],\n  [1, 1], // Bottom row\n];\n\n// Check if coordinates are valid\nfunction isValid(grid, row, col) {\n  return row >= 0 && row < grid.length && col >= 0 && col < grid[0].length;\n}\n\n// Check if cell is valid and not blocked\nfunction isValidCell(grid, row, col, blocked = '#') {\n  return isValid(grid, row, col) && grid[row][col] !== blocked;\n}\n\n// Get all valid neighbors\nfunction getNeighbors(grid, row, col, directions = DIRECTIONS_4) {\n  const neighbors = [];\n\n  for (const [dr, dc] of directions) {\n    const newRow = row + dr;\n    const newCol = col + dc;\n\n    if (isValid(grid, newRow, newCol)) {\n      neighbors.push([newRow, newCol]);\n    }\n  }\n\n  return neighbors;\n}\n\n// Convert 2D coordinates to 1D (for hashing)\nfunction coordToKey(row, col) {\n  return `${row},${col}`;\n}\n\n// Convert 1D key back to coordinates\nfunction keyToCoord(key) {\n  return key.split(',').map(Number);\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"grid-creation-utilities",children:"Grid Creation Utilities"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Create empty grid\nfunction createGrid(rows, cols, defaultValue = 0) {\n  return Array(rows)\n    .fill(null)\n    .map(() => Array(cols).fill(defaultValue));\n}\n\n// Create grid from string array\nfunction parseGrid(gridString) {\n  return gridString\n    .trim()\n    .split('\\n')\n    .map(row => row.split(''));\n}\n\n// Print grid for visualization\nfunction printGrid(grid, highlight = null) {\n  for (let i = 0; i < grid.length; i++) {\n    let row = '';\n    for (let j = 0; j < grid[i].length; j++) {\n      if (highlight && highlight.has(coordToKey(i, j))) {\n        row += `[${grid[i][j]}]`;\n      } else {\n        row += ` ${grid[i][j]} `;\n      }\n    }\n    console.log(row);\n  }\n}\n\n// Clone grid\nfunction cloneGrid(grid) {\n  return grid.map(row => [...row]);\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"basic-grid-operations",children:"Basic Grid Operations"}),"\n",(0,t.jsx)(e.h3,{id:"1-grid-traversal",children:"1. Grid Traversal"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Traverse all cells\nfunction traverseGrid(grid, callback) {\n  for (let row = 0; row < grid.length; row++) {\n    for (let col = 0; col < grid[0].length; col++) {\n      callback(row, col, grid[row][col]);\n    }\n  }\n}\n\n// Find all cells with specific value\nfunction findCells(grid, target) {\n  const cells = [];\n  traverseGrid(grid, (row, col, value) => {\n    if (value === target) {\n      cells.push([row, col]);\n    }\n  });\n  return cells;\n}\n\n// Count cells with specific value\nfunction countCells(grid, target) {\n  let count = 0;\n  traverseGrid(grid, (row, col, value) => {\n    if (value === target) count++;\n  });\n  return count;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-boundary-checking",children:"2. Boundary Checking"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Check if cell is on boundary\nfunction isOnBoundary(grid, row, col) {\n  return (\n    row === 0 ||\n    row === grid.length - 1 ||\n    col === 0 ||\n    col === grid[0].length - 1\n  );\n}\n\n// Get boundary cells\nfunction getBoundaryCells(grid) {\n  const boundary = [];\n  const rows = grid.length;\n  const cols = grid[0].length;\n\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (isOnBoundary(grid, i, j)) {\n        boundary.push([i, j]);\n      }\n    }\n  }\n\n  return boundary;\n}\n\n// Get corner cells\nfunction getCornerCells(grid) {\n  const rows = grid.length;\n  const cols = grid[0].length;\n\n  return [\n    [0, 0], // Top-left\n    [0, cols - 1], // Top-right\n    [rows - 1, 0], // Bottom-left\n    [rows - 1, cols - 1], // Bottom-right\n  ];\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"depth-first-search-dfs",children:"Depth-First Search (DFS)"}),"\n",(0,t.jsx)(e.p,{children:"DFS is perfect for exploring paths, finding connected components, and solving maze problems."}),"\n",(0,t.jsx)(e.h3,{id:"1-basic-dfs-implementation",children:"1. Basic DFS Implementation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Recursive DFS\nfunction dfsRecursive(grid, row, col, visited = new Set(), path = []) {\n  const key = coordToKey(row, col);\n\n  if (!isValid(grid, row, col) || visited.has(key)) {\n    return;\n  }\n\n  visited.add(key);\n  path.push([row, col]);\n\n  // Process current cell\n  console.log(`Visiting: ${row}, ${col}`);\n\n  // Explore neighbors\n  for (const [dr, dc] of DIRECTIONS_4) {\n    const newRow = row + dr;\n    const newCol = col + dc;\n    dfsRecursive(grid, newRow, newCol, visited, path);\n  }\n}\n\n// Iterative DFS\nfunction dfsIterative(grid, startRow, startCol) {\n  const visited = new Set();\n  const stack = [[startRow, startCol]];\n  const path = [];\n\n  while (stack.length > 0) {\n    const [row, col] = stack.pop();\n    const key = coordToKey(row, col);\n\n    if (!isValid(grid, row, col) || visited.has(key)) {\n      continue;\n    }\n\n    visited.add(key);\n    path.push([row, col]);\n\n    // Add neighbors to stack\n    for (const [dr, dc] of DIRECTIONS_4) {\n      const newRow = row + dr;\n      const newCol = col + dc;\n      if (isValid(grid, newRow, newCol)) {\n        stack.push([newRow, newCol]);\n      }\n    }\n  }\n\n  return path;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-dfs-with-conditions",children:"2. DFS with Conditions"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// DFS only on valid cells (not blocked)\nfunction dfsValidCells(grid, row, col, visited = new Set()) {\n  const key = coordToKey(row, col);\n\n  if (!isValidCell(grid, row, col) || visited.has(key)) {\n    return [];\n  }\n\n  visited.add(key);\n  const component = [[row, col]];\n\n  for (const [dr, dc] of DIRECTIONS_4) {\n    const newRow = row + dr;\n    const newCol = col + dc;\n    component.push(...dfsValidCells(grid, newRow, newCol, visited));\n  }\n\n  return component;\n}\n\n// DFS with path tracking\nfunction dfsWithPath(grid, row, col, target, path = [], visited = new Set()) {\n  const key = coordToKey(row, col);\n\n  if (!isValid(grid, row, col) || visited.has(key)) {\n    return null;\n  }\n\n  path.push([row, col]);\n  visited.add(key);\n\n  if (grid[row][col] === target) {\n    return [...path]; // Found target, return path\n  }\n\n  for (const [dr, dc] of DIRECTIONS_4) {\n    const newRow = row + dr;\n    const newCol = col + dc;\n    const result = dfsWithPath(grid, newRow, newCol, target, path, visited);\n    if (result) return result;\n  }\n\n  path.pop(); // Backtrack\n  return null;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-dfs-applications",children:"3. DFS Applications"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Check if path exists between two points\nfunction hasPath(grid, start, end) {\n  const [startRow, startCol] = start;\n  const [endRow, endCol] = end;\n\n  function dfs(row, col, visited) {\n    if (!isValidCell(grid, row, col) || visited.has(coordToKey(row, col))) {\n      return false;\n    }\n\n    if (row === endRow && col === endCol) {\n      return true;\n    }\n\n    visited.add(coordToKey(row, col));\n\n    for (const [dr, dc] of DIRECTIONS_4) {\n      if (dfs(row + dr, col + dc, visited)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  return dfs(startRow, startCol, new Set());\n}\n\n// Find all paths between two points\nfunction findAllPaths(grid, start, end) {\n  const [startRow, startCol] = start;\n  const [endRow, endCol] = end;\n  const allPaths = [];\n\n  function dfs(row, col, path, visited) {\n    if (!isValidCell(grid, row, col) || visited.has(coordToKey(row, col))) {\n      return;\n    }\n\n    const newPath = [...path, [row, col]];\n\n    if (row === endRow && col === endCol) {\n      allPaths.push(newPath);\n      return;\n    }\n\n    const key = coordToKey(row, col);\n    visited.add(key);\n\n    for (const [dr, dc] of DIRECTIONS_4) {\n      dfs(row + dr, col + dc, newPath, visited);\n    }\n\n    visited.delete(key); // Backtrack\n  }\n\n  dfs(startRow, startCol, [], new Set());\n  return allPaths;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"breadth-first-search-bfs",children:"Breadth-First Search (BFS)"}),"\n",(0,t.jsx)(e.p,{children:"BFS is ideal for finding shortest paths, level-order traversal, and minimum step problems."}),"\n",(0,t.jsx)(e.h3,{id:"1-basic-bfs-implementation",children:"1. Basic BFS Implementation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Standard BFS\nfunction bfs(grid, startRow, startCol) {\n  const queue = [[startRow, startCol, 0]]; // [row, col, distance]\n  const visited = new Set();\n  const result = [];\n\n  while (queue.length > 0) {\n    const [row, col, dist] = queue.shift();\n    const key = coordToKey(row, col);\n\n    if (!isValid(grid, row, col) || visited.has(key)) {\n      continue;\n    }\n\n    visited.add(key);\n    result.push([row, col, dist]);\n\n    // Add neighbors\n    for (const [dr, dc] of DIRECTIONS_4) {\n      const newRow = row + dr;\n      const newCol = col + dc;\n      if (isValid(grid, newRow, newCol)) {\n        queue.push([newRow, newCol, dist + 1]);\n      }\n    }\n  }\n\n  return result;\n}\n\n// BFS with level tracking\nfunction bfsLevels(grid, startRow, startCol) {\n  const queue = [[startRow, startCol]];\n  const visited = new Set([coordToKey(startRow, startCol)]);\n  const levels = [];\n\n  while (queue.length > 0) {\n    const levelSize = queue.length;\n    const currentLevel = [];\n\n    for (let i = 0; i < levelSize; i++) {\n      const [row, col] = queue.shift();\n      currentLevel.push([row, col]);\n\n      for (const [dr, dc] of DIRECTIONS_4) {\n        const newRow = row + dr;\n        const newCol = col + dc;\n        const key = coordToKey(newRow, newCol);\n\n        if (isValidCell(grid, newRow, newCol) && !visited.has(key)) {\n          visited.add(key);\n          queue.push([newRow, newCol]);\n        }\n      }\n    }\n\n    levels.push(currentLevel);\n  }\n\n  return levels;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-bfs-for-shortest-path",children:"2. BFS for Shortest Path"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Find shortest path between two points\nfunction shortestPath(grid, start, end) {\n  const [startRow, startCol] = start;\n  const [endRow, endCol] = end;\n\n  const queue = [[startRow, startCol, 0, [[startRow, startCol]]]];\n  const visited = new Set([coordToKey(startRow, startCol)]);\n\n  while (queue.length > 0) {\n    const [row, col, dist, path] = queue.shift();\n\n    if (row === endRow && col === endCol) {\n      return { distance: dist, path };\n    }\n\n    for (const [dr, dc] of DIRECTIONS_4) {\n      const newRow = row + dr;\n      const newCol = col + dc;\n      const key = coordToKey(newRow, newCol);\n\n      if (isValidCell(grid, newRow, newCol) && !visited.has(key)) {\n        visited.add(key);\n        queue.push([newRow, newCol, dist + 1, [...path, [newRow, newCol]]]);\n      }\n    }\n  }\n\n  return null; // No path found\n}\n\n// Find shortest distance to any target\nfunction shortestDistanceToTarget(grid, start, targets) {\n  const [startRow, startCol] = start;\n  const targetSet = new Set(targets.map(([r, c]) => coordToKey(r, c)));\n\n  const queue = [[startRow, startCol, 0]];\n  const visited = new Set([coordToKey(startRow, startCol)]);\n\n  while (queue.length > 0) {\n    const [row, col, dist] = queue.shift();\n\n    if (targetSet.has(coordToKey(row, col))) {\n      return dist;\n    }\n\n    for (const [dr, dc] of DIRECTIONS_4) {\n      const newRow = row + dr;\n      const newCol = col + dc;\n      const key = coordToKey(newRow, newCol);\n\n      if (isValidCell(grid, newRow, newCol) && !visited.has(key)) {\n        visited.add(key);\n        queue.push([newRow, newCol, dist + 1]);\n      }\n    }\n  }\n\n  return -1; // No target reachable\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-multi-source-bfs",children:"3. Multi-source BFS"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// BFS from multiple starting points simultaneously\nfunction multiSourceBFS(grid, sources) {\n  const queue = [];\n  const visited = new Set();\n  const distances = createGrid(grid.length, grid[0].length, -1);\n\n  // Initialize with all sources\n  for (const [row, col] of sources) {\n    queue.push([row, col, 0]);\n    visited.add(coordToKey(row, col));\n    distances[row][col] = 0;\n  }\n\n  while (queue.length > 0) {\n    const [row, col, dist] = queue.shift();\n\n    for (const [dr, dc] of DIRECTIONS_4) {\n      const newRow = row + dr;\n      const newCol = col + dc;\n      const key = coordToKey(newRow, newCol);\n\n      if (isValidCell(grid, newRow, newCol) && !visited.has(key)) {\n        visited.add(key);\n        distances[newRow][newCol] = dist + 1;\n        queue.push([newRow, newCol, dist + 1]);\n      }\n    }\n  }\n\n  return distances;\n}\n\n// Find nearest source for each cell\nfunction nearestSource(grid, sources) {\n  const queue = [];\n  const visited = new Set();\n  const nearest = createGrid(grid.length, grid[0].length, -1);\n\n  // Initialize with all sources\n  for (let i = 0; i < sources.length; i++) {\n    const [row, col] = sources[i];\n    queue.push([row, col, i]);\n    visited.add(coordToKey(row, col));\n    nearest[row][col] = i;\n  }\n\n  while (queue.length > 0) {\n    const [row, col, sourceId] = queue.shift();\n\n    for (const [dr, dc] of DIRECTIONS_4) {\n      const newRow = row + dr;\n      const newCol = col + dc;\n      const key = coordToKey(newRow, newCol);\n\n      if (isValidCell(grid, newRow, newCol) && !visited.has(key)) {\n        visited.add(key);\n        nearest[newRow][newCol] = sourceId;\n        queue.push([newRow, newCol, sourceId]);\n      }\n    }\n  }\n\n  return nearest;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pathfinding-algorithms",children:"Pathfinding Algorithms"}),"\n",(0,t.jsx)(e.h3,{id:"1-a-algorithm",children:"1. A* Algorithm"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"class PriorityQueue {\n  constructor() {\n    this.heap = [];\n  }\n\n  enqueue(item, priority) {\n    this.heap.push({ item, priority });\n    this.heapifyUp();\n  }\n\n  dequeue() {\n    if (this.isEmpty()) return null;\n\n    const top = this.heap[0];\n    const last = this.heap.pop();\n\n    if (!this.isEmpty()) {\n      this.heap[0] = last;\n      this.heapifyDown();\n    }\n\n    return top.item;\n  }\n\n  isEmpty() {\n    return this.heap.length === 0;\n  }\n\n  heapifyUp() {\n    let index = this.heap.length - 1;\n\n    while (index > 0) {\n      const parentIndex = Math.floor((index - 1) / 2);\n\n      if (this.heap[index].priority >= this.heap[parentIndex].priority) {\n        break;\n      }\n\n      [this.heap[index], this.heap[parentIndex]] = [\n        this.heap[parentIndex],\n        this.heap[index],\n      ];\n\n      index = parentIndex;\n    }\n  }\n\n  heapifyDown() {\n    let index = 0;\n\n    while (2 * index + 1 < this.heap.length) {\n      let childIndex = 2 * index + 1;\n\n      if (\n        2 * index + 2 < this.heap.length &&\n        this.heap[2 * index + 2].priority < this.heap[childIndex].priority\n      ) {\n        childIndex = 2 * index + 2;\n      }\n\n      if (this.heap[index].priority <= this.heap[childIndex].priority) {\n        break;\n      }\n\n      [this.heap[index], this.heap[childIndex]] = [\n        this.heap[childIndex],\n        this.heap[index],\n      ];\n\n      index = childIndex;\n    }\n  }\n}\n\n// Manhattan distance heuristic\nfunction manhattanDistance(pos1, pos2) {\n  return Math.abs(pos1[0] - pos2[0]) + Math.abs(pos1[1] - pos2[1]);\n}\n\n// A* pathfinding algorithm\nfunction aStar(grid, start, goal) {\n  const [startRow, startCol] = start;\n  const [goalRow, goalCol] = goal;\n\n  const openSet = new PriorityQueue();\n  const closedSet = new Set();\n  const gScore = new Map();\n  const fScore = new Map();\n  const cameFrom = new Map();\n\n  const startKey = coordToKey(startRow, startCol);\n  gScore.set(startKey, 0);\n  fScore.set(startKey, manhattanDistance(start, goal));\n  openSet.enqueue([startRow, startCol], fScore.get(startKey));\n\n  while (!openSet.isEmpty()) {\n    const [row, col] = openSet.dequeue();\n    const currentKey = coordToKey(row, col);\n\n    if (row === goalRow && col === goalCol) {\n      // Reconstruct path\n      const path = [];\n      let current = currentKey;\n\n      while (current) {\n        const [r, c] = keyToCoord(current);\n        path.unshift([r, c]);\n        current = cameFrom.get(current);\n      }\n\n      return path;\n    }\n\n    closedSet.add(currentKey);\n\n    for (const [dr, dc] of DIRECTIONS_4) {\n      const newRow = row + dr;\n      const newCol = col + dc;\n      const neighborKey = coordToKey(newRow, newCol);\n\n      if (!isValidCell(grid, newRow, newCol) || closedSet.has(neighborKey)) {\n        continue;\n      }\n\n      const tentativeGScore = gScore.get(currentKey) + 1;\n\n      if (\n        !gScore.has(neighborKey) ||\n        tentativeGScore < gScore.get(neighborKey)\n      ) {\n        cameFrom.set(neighborKey, currentKey);\n        gScore.set(neighborKey, tentativeGScore);\n        const hScore = manhattanDistance([newRow, newCol], goal);\n        fScore.set(neighborKey, tentativeGScore + hScore);\n\n        openSet.enqueue([newRow, newCol], fScore.get(neighborKey));\n      }\n    }\n  }\n\n  return null; // No path found\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-dijkstras-algorithm-for-weighted-grids",children:"2. Dijkstra's Algorithm for Weighted Grids"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Dijkstra for weighted grids\nfunction dijkstra(grid, start, end) {\n  const [startRow, startCol] = start;\n  const [endRow, endCol] = end;\n\n  const distances = createGrid(grid.length, grid[0].length, Infinity);\n  const previous = new Map();\n  const pq = new PriorityQueue();\n\n  distances[startRow][startCol] = 0;\n  pq.enqueue([startRow, startCol], 0);\n\n  while (!pq.isEmpty()) {\n    const [row, col] = pq.dequeue();\n\n    if (row === endRow && col === endCol) {\n      // Reconstruct path\n      const path = [];\n      let current = coordToKey(row, col);\n\n      while (current) {\n        const [r, c] = keyToCoord(current);\n        path.unshift([r, c]);\n        current = previous.get(current);\n      }\n\n      return {\n        distance: distances[endRow][endCol],\n        path,\n      };\n    }\n\n    for (const [dr, dc] of DIRECTIONS_4) {\n      const newRow = row + dr;\n      const newCol = col + dc;\n\n      if (!isValid(grid, newRow, newCol)) continue;\n\n      // Weight is the value in the cell (or 1 for unweighted)\n      const weight =\n        typeof grid[newRow][newCol] === 'number' ? grid[newRow][newCol] : 1;\n\n      if (weight === Infinity) continue; // Blocked cell\n\n      const newDistance = distances[row][col] + weight;\n\n      if (newDistance < distances[newRow][newCol]) {\n        distances[newRow][newCol] = newDistance;\n        previous.set(coordToKey(newRow, newCol), coordToKey(row, col));\n        pq.enqueue([newRow, newCol], newDistance);\n      }\n    }\n  }\n\n  return null; // No path found\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"island-and-connected-components",children:"Island and Connected Components"}),"\n",(0,t.jsx)(e.h3,{id:"1-count-islands",children:"1. Count Islands"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Count number of islands (connected components of 1s)\nfunction numIslands(grid) {\n  if (!grid || grid.length === 0) return 0;\n\n  const visited = new Set();\n  let count = 0;\n\n  function dfs(row, col) {\n    const key = coordToKey(row, col);\n\n    if (\n      !isValid(grid, row, col) ||\n      visited.has(key) ||\n      grid[row][col] === '0'\n    ) {\n      return;\n    }\n\n    visited.add(key);\n\n    for (const [dr, dc] of DIRECTIONS_4) {\n      dfs(row + dr, col + dc);\n    }\n  }\n\n  for (let row = 0; row < grid.length; row++) {\n    for (let col = 0; col < grid[0].length; col++) {\n      if (grid[row][col] === '1' && !visited.has(coordToKey(row, col))) {\n        count++;\n        dfs(row, col);\n      }\n    }\n  }\n\n  return count;\n}\n\n// Get all islands with their cells\nfunction getAllIslands(grid) {\n  const visited = new Set();\n  const islands = [];\n\n  function dfs(row, col, island) {\n    const key = coordToKey(row, col);\n\n    if (\n      !isValid(grid, row, col) ||\n      visited.has(key) ||\n      grid[row][col] === '0'\n    ) {\n      return;\n    }\n\n    visited.add(key);\n    island.push([row, col]);\n\n    for (const [dr, dc] of DIRECTIONS_4) {\n      dfs(row + dr, col + dc, island);\n    }\n  }\n\n  for (let row = 0; row < grid.length; row++) {\n    for (let col = 0; col < grid[0].length; col++) {\n      if (grid[row][col] === '1' && !visited.has(coordToKey(row, col))) {\n        const island = [];\n        dfs(row, col, island);\n        islands.push(island);\n      }\n    }\n  }\n\n  return islands;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-largest-island",children:"2. Largest Island"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Find size of largest island\nfunction maxAreaOfIsland(grid) {\n  const visited = new Set();\n  let maxArea = 0;\n\n  function dfs(row, col) {\n    const key = coordToKey(row, col);\n\n    if (!isValid(grid, row, col) || visited.has(key) || grid[row][col] === 0) {\n      return 0;\n    }\n\n    visited.add(key);\n    let area = 1;\n\n    for (const [dr, dc] of DIRECTIONS_4) {\n      area += dfs(row + dr, col + dc);\n    }\n\n    return area;\n  }\n\n  for (let row = 0; row < grid.length; row++) {\n    for (let col = 0; col < grid[0].length; col++) {\n      if (grid[row][col] === 1 && !visited.has(coordToKey(row, col))) {\n        maxArea = Math.max(maxArea, dfs(row, col));\n      }\n    }\n  }\n\n  return maxArea;\n}\n\n// Find perimeter of all islands\nfunction islandPerimeter(grid) {\n  let perimeter = 0;\n\n  for (let row = 0; row < grid.length; row++) {\n    for (let col = 0; col < grid[0].length; col++) {\n      if (grid[row][col] === 1) {\n        // Check all 4 directions\n        for (const [dr, dc] of DIRECTIONS_4) {\n          const newRow = row + dr;\n          const newCol = col + dc;\n\n          // If neighbor is out of bounds or water, add to perimeter\n          if (!isValid(grid, newRow, newCol) || grid[newRow][newCol] === 0) {\n            perimeter++;\n          }\n        }\n      }\n    }\n  }\n\n  return perimeter;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-island-shape-matching",children:"3. Island Shape Matching"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Check if two islands have the same shape\nfunction sameIslandShape(island1, island2) {\n  if (island1.length !== island2.length) return false;\n\n  // Normalize both islands to start from (0,0)\n  function normalize(island) {\n    if (island.length === 0) return [];\n\n    const minRow = Math.min(...island.map(([r]) => r));\n    const minCol = Math.min(...island.map(([, c]) => c));\n\n    return island\n      .map(([r, c]) => [r - minRow, c - minCol])\n      .sort((a, b) => a[0] - b[0] || a[1] - b[1]);\n  }\n\n  const norm1 = normalize(island1);\n  const norm2 = normalize(island2);\n\n  return JSON.stringify(norm1) === JSON.stringify(norm2);\n}\n\n// Get unique island shapes\nfunction getUniqueShapes(grid) {\n  const islands = getAllIslands(grid);\n  const uniqueShapes = [];\n\n  for (const island of islands) {\n    const isUnique = uniqueShapes.every(\n      shape => !sameIslandShape(island, shape)\n    );\n\n    if (isUnique) {\n      uniqueShapes.push(island);\n    }\n  }\n\n  return uniqueShapes.length;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"flood-fill-algorithms",children:"Flood Fill Algorithms"}),"\n",(0,t.jsx)(e.h3,{id:"1-basic-flood-fill",children:"1. Basic Flood Fill"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Classic flood fill algorithm\nfunction floodFill(grid, row, col, newColor) {\n  if (!isValid(grid, row, col)) return grid;\n\n  const originalColor = grid[row][col];\n  if (originalColor === newColor) return grid;\n\n  function fill(r, c) {\n    if (!isValid(grid, r, c) || grid[r][c] !== originalColor) {\n      return;\n    }\n\n    grid[r][c] = newColor;\n\n    for (const [dr, dc] of DIRECTIONS_4) {\n      fill(r + dr, c + dc);\n    }\n  }\n\n  fill(row, col);\n  return grid;\n}\n\n// Iterative flood fill\nfunction floodFillIterative(grid, row, col, newColor) {\n  if (!isValid(grid, row, col)) return grid;\n\n  const originalColor = grid[row][col];\n  if (originalColor === newColor) return grid;\n\n  const stack = [[row, col]];\n\n  while (stack.length > 0) {\n    const [r, c] = stack.pop();\n\n    if (!isValid(grid, r, c) || grid[r][c] !== originalColor) {\n      continue;\n    }\n\n    grid[r][c] = newColor;\n\n    for (const [dr, dc] of DIRECTIONS_4) {\n      stack.push([r + dr, c + dc]);\n    }\n  }\n\n  return grid;\n}\n\n// Boundary flood fill (fill area surrounded by boundary)\nfunction boundaryFill(grid, row, col, fillColor, boundaryColor) {\n  if (\n    !isValid(grid, row, col) ||\n    grid[row][col] === boundaryColor ||\n    grid[row][col] === fillColor\n  ) {\n    return;\n  }\n\n  grid[row][col] = fillColor;\n\n  for (const [dr, dc] of DIRECTIONS_4) {\n    boundaryFill(grid, row + dr, col + dc, fillColor, boundaryColor);\n  }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-advanced-flood-fill-variants",children:"2. Advanced Flood Fill Variants"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Flood fill with pattern\nfunction patternFill(grid, row, col, pattern) {\n  const originalColor = grid[row][col];\n  const patternHeight = pattern.length;\n  const patternWidth = pattern[0].length;\n\n  function fill(r, c, patternR, patternC) {\n    if (!isValid(grid, r, c) || grid[r][c] !== originalColor) {\n      return;\n    }\n\n    grid[r][c] = pattern[patternR % patternHeight][patternC % patternWidth];\n\n    for (const [dr, dc] of DIRECTIONS_4) {\n      fill(r + dr, c + dc, patternR + dr, patternC + dc);\n    }\n  }\n\n  fill(row, col, 0, 0);\n  return grid;\n}\n\n// Gradient flood fill\nfunction gradientFill(grid, row, col, startValue, endValue, maxDistance) {\n  const visited = new Set();\n  const queue = [[row, col, 0]];\n\n  while (queue.length > 0) {\n    const [r, c, dist] = queue.shift();\n    const key = coordToKey(r, c);\n\n    if (!isValid(grid, r, c) || visited.has(key) || dist > maxDistance) {\n      continue;\n    }\n\n    visited.add(key);\n\n    // Calculate gradient value\n    const ratio = dist / maxDistance;\n    const value = startValue + (endValue - startValue) * ratio;\n    grid[r][c] = Math.round(value);\n\n    for (const [dr, dc] of DIRECTIONS_4) {\n      queue.push([r + dr, c + dc, dist + 1]);\n    }\n  }\n\n  return grid;\n}\n\n// Conditional flood fill\nfunction conditionalFill(grid, row, col, newColor, condition) {\n  const originalColor = grid[row][col];\n\n  function fill(r, c) {\n    if (!isValid(grid, r, c) || grid[r][c] !== originalColor) {\n      return;\n    }\n\n    if (!condition(r, c, grid[r][c])) {\n      return;\n    }\n\n    grid[r][c] = newColor;\n\n    for (const [dr, dc] of DIRECTIONS_4) {\n      fill(r + dr, c + dc);\n    }\n  }\n\n  fill(row, col);\n  return grid;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"dynamic-programming-on-grids",children:"Dynamic Programming on Grids"}),"\n",(0,t.jsx)(e.h3,{id:"1-path-counting-problems",children:"1. Path Counting Problems"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Count unique paths from top-left to bottom-right\nfunction uniquePaths(m, n) {\n  const dp = createGrid(m, n, 0);\n\n  // Initialize first row and column\n  for (let i = 0; i < m; i++) dp[i][0] = 1;\n  for (let j = 0; j < n; j++) dp[0][j] = 1;\n\n  for (let i = 1; i < m; i++) {\n    for (let j = 1; j < n; j++) {\n      dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n    }\n  }\n\n  return dp[m - 1][n - 1];\n}\n\n// Unique paths with obstacles\nfunction uniquePathsWithObstacles(grid) {\n  const m = grid.length;\n  const n = grid[0].length;\n\n  if (grid[0][0] === 1 || grid[m - 1][n - 1] === 1) return 0;\n\n  const dp = createGrid(m, n, 0);\n  dp[0][0] = 1;\n\n  // Initialize first row\n  for (let j = 1; j < n; j++) {\n    dp[0][j] = grid[0][j] === 1 ? 0 : dp[0][j - 1];\n  }\n\n  // Initialize first column\n  for (let i = 1; i < m; i++) {\n    dp[i][0] = grid[i][0] === 1 ? 0 : dp[i - 1][0];\n  }\n\n  for (let i = 1; i < m; i++) {\n    for (let j = 1; j < n; j++) {\n      if (grid[i][j] === 1) {\n        dp[i][j] = 0;\n      } else {\n        dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n      }\n    }\n  }\n\n  return dp[m - 1][n - 1];\n}\n\n// Minimum path sum\nfunction minPathSum(grid) {\n  const m = grid.length;\n  const n = grid[0].length;\n\n  const dp = cloneGrid(grid);\n\n  // Initialize first row\n  for (let j = 1; j < n; j++) {\n    dp[0][j] += dp[0][j - 1];\n  }\n\n  // Initialize first column\n  for (let i = 1; i < m; i++) {\n    dp[i][0] += dp[i - 1][0];\n  }\n\n  for (let i = 1; i < m; i++) {\n    for (let j = 1; j < n; j++) {\n      dp[i][j] += Math.min(dp[i - 1][j], dp[i][j - 1]);\n    }\n  }\n\n  return dp[m - 1][n - 1];\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-maximumminimum-problems",children:"2. Maximum/Minimum Problems"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Maximum path sum (can move in 4 directions)\nfunction maxPathSum(grid) {\n  const m = grid.length;\n  const n = grid[0].length;\n  const memo = new Map();\n\n  function dfs(row, col) {\n    const key = coordToKey(row, col);\n\n    if (!isValid(grid, row, col)) return -Infinity;\n    if (memo.has(key)) return memo.get(key);\n\n    let maxSum = grid[row][col];\n\n    for (const [dr, dc] of DIRECTIONS_4) {\n      const newRow = row + dr;\n      const newCol = col + dc;\n      maxSum = Math.max(maxSum, grid[row][col] + dfs(newRow, newCol));\n    }\n\n    memo.set(key, maxSum);\n    return maxSum;\n  }\n\n  let globalMax = -Infinity;\n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      globalMax = Math.max(globalMax, dfs(i, j));\n    }\n  }\n\n  return globalMax;\n}\n\n// Minimum falling path sum\nfunction minFallingPathSum(grid) {\n  const m = grid.length;\n  const n = grid[0].length;\n\n  const dp = cloneGrid(grid);\n\n  for (let i = 1; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      let minPrev = dp[i - 1][j]; // From directly above\n\n      if (j > 0) minPrev = Math.min(minPrev, dp[i - 1][j - 1]); // From left diagonal\n      if (j < n - 1) minPrev = Math.min(minPrev, dp[i - 1][j + 1]); // From right diagonal\n\n      dp[i][j] += minPrev;\n    }\n  }\n\n  return Math.min(...dp[m - 1]);\n}\n\n// Maximum square area\nfunction maximalSquare(grid) {\n  const m = grid.length;\n  const n = grid[0].length;\n\n  const dp = createGrid(m + 1, n + 1, 0);\n  let maxSide = 0;\n\n  for (let i = 1; i <= m; i++) {\n    for (let j = 1; j <= n; j++) {\n      if (grid[i - 1][j - 1] === '1') {\n        dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1;\n        maxSide = Math.max(maxSide, dp[i][j]);\n      }\n    }\n  }\n\n  return maxSide * maxSide;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-range-and-area-problems",children:"3. Range and Area Problems"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Largest rectangle in histogram (for each row)\nfunction largestRectangleArea(heights) {\n  const stack = [];\n  let maxArea = 0;\n\n  for (let i = 0; i <= heights.length; i++) {\n    const h = i === heights.length ? 0 : heights[i];\n\n    while (stack.length > 0 && h < heights[stack[stack.length - 1]]) {\n      const height = heights[stack.pop()];\n      const width = stack.length === 0 ? i : i - stack[stack.length - 1] - 1;\n      maxArea = Math.max(maxArea, height * width);\n    }\n\n    stack.push(i);\n  }\n\n  return maxArea;\n}\n\n// Maximal rectangle in binary grid\nfunction maximalRectangle(grid) {\n  if (!grid || grid.length === 0) return 0;\n\n  const m = grid.length;\n  const n = grid[0].length;\n  const heights = Array(n).fill(0);\n  let maxArea = 0;\n\n  for (let i = 0; i < m; i++) {\n    // Update heights for current row\n    for (let j = 0; j < n; j++) {\n      heights[j] = grid[i][j] === '1' ? heights[j] + 1 : 0;\n    }\n\n    // Find max rectangle in current histogram\n    maxArea = Math.max(maxArea, largestRectangleArea(heights));\n  }\n\n  return maxArea;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"advanced-grid-techniques",children:"Advanced Grid Techniques"}),"\n",(0,t.jsx)(e.h3,{id:"1-rotations-and-transformations",children:"1. Rotations and Transformations"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Rotate grid 90 degrees clockwise\nfunction rotateGrid(grid) {\n  const n = grid.length;\n  const rotated = createGrid(n, n);\n\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      rotated[j][n - 1 - i] = grid[i][j];\n    }\n  }\n\n  return rotated;\n}\n\n// Flip grid horizontally\nfunction flipHorizontal(grid) {\n  return grid.map(row => [...row].reverse());\n}\n\n// Flip grid vertically\nfunction flipVertical(grid) {\n  return [...grid].reverse();\n}\n\n// Transpose grid\nfunction transposeGrid(grid) {\n  const m = grid.length;\n  const n = grid[0].length;\n  const transposed = createGrid(n, m);\n\n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      transposed[j][i] = grid[i][j];\n    }\n  }\n\n  return transposed;\n}\n\n// Get all rotations and reflections\nfunction getAllTransformations(grid) {\n  const transformations = [];\n  let current = grid;\n\n  // 4 rotations\n  for (let i = 0; i < 4; i++) {\n    transformations.push(cloneGrid(current));\n    transformations.push(flipHorizontal(current));\n    current = rotateGrid(current);\n  }\n\n  return transformations;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-spiral-traversal",children:"2. Spiral Traversal"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Spiral traversal of grid\nfunction spiralOrder(grid) {\n  if (!grid || grid.length === 0) return [];\n\n  const result = [];\n  let top = 0,\n    bottom = grid.length - 1;\n  let left = 0,\n    right = grid[0].length - 1;\n\n  while (top <= bottom && left <= right) {\n    // Traverse right\n    for (let col = left; col <= right; col++) {\n      result.push(grid[top][col]);\n    }\n    top++;\n\n    // Traverse down\n    for (let row = top; row <= bottom; row++) {\n      result.push(grid[row][right]);\n    }\n    right--;\n\n    // Traverse left (if we have rows left)\n    if (top <= bottom) {\n      for (let col = right; col >= left; col--) {\n        result.push(grid[bottom][col]);\n      }\n      bottom--;\n    }\n\n    // Traverse up (if we have columns left)\n    if (left <= right) {\n      for (let row = bottom; row >= top; row--) {\n        result.push(grid[row][left]);\n      }\n      left++;\n    }\n  }\n\n  return result;\n}\n\n// Generate spiral grid\nfunction generateSpiralGrid(n) {\n  const grid = createGrid(n, n, 0);\n  let top = 0,\n    bottom = n - 1;\n  let left = 0,\n    right = n - 1;\n  let num = 1;\n\n  while (top <= bottom && left <= right) {\n    // Fill right\n    for (let col = left; col <= right; col++) {\n      grid[top][col] = num++;\n    }\n    top++;\n\n    // Fill down\n    for (let row = top; row <= bottom; row++) {\n      grid[row][right] = num++;\n    }\n    right--;\n\n    // Fill left\n    if (top <= bottom) {\n      for (let col = right; col >= left; col--) {\n        grid[bottom][col] = num++;\n      }\n      bottom--;\n    }\n\n    // Fill up\n    if (left <= right) {\n      for (let row = bottom; row >= top; row--) {\n        grid[row][left] = num++;\n      }\n      left++;\n    }\n  }\n\n  return grid;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-convex-hull-and-geometry",children:"3. Convex Hull and Geometry"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Find convex hull of points in grid\nfunction convexHull(points) {\n  if (points.length < 3) return points;\n\n  // Sort points lexicographically\n  points.sort((a, b) => a[0] - b[0] || a[1] - b[1]);\n\n  // Build lower hull\n  const lower = [];\n  for (const point of points) {\n    while (\n      lower.length >= 2 &&\n      cross(lower[lower.length - 2], lower[lower.length - 1], point) <= 0\n    ) {\n      lower.pop();\n    }\n    lower.push(point);\n  }\n\n  // Build upper hull\n  const upper = [];\n  for (let i = points.length - 1; i >= 0; i--) {\n    const point = points[i];\n    while (\n      upper.length >= 2 &&\n      cross(upper[upper.length - 2], upper[upper.length - 1], point) <= 0\n    ) {\n      upper.pop();\n    }\n    upper.push(point);\n  }\n\n  // Remove last point of each half because it's repeated\n  lower.pop();\n  upper.pop();\n\n  return lower.concat(upper);\n}\n\n// Cross product for convex hull\nfunction cross(O, A, B) {\n  return (A[0] - O[0]) * (B[1] - O[1]) - (A[1] - O[1]) * (B[0] - O[0]);\n}\n\n// Find all points inside polygon\nfunction pointsInPolygon(grid, polygon) {\n  const inside = [];\n\n  for (let row = 0; row < grid.length; row++) {\n    for (let col = 0; col < grid[0].length; col++) {\n      if (isPointInPolygon([row, col], polygon)) {\n        inside.push([row, col]);\n      }\n    }\n  }\n\n  return inside;\n}\n\n// Ray casting algorithm for point in polygon\nfunction isPointInPolygon(point, polygon) {\n  const [x, y] = point;\n  let inside = false;\n\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const [xi, yi] = polygon[i];\n    const [xj, yj] = polygon[j];\n\n    if (yi > y !== yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi) + xi) {\n      inside = !inside;\n    }\n  }\n\n  return inside;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"multi-source-and-multi-destination",children:"Multi-source and Multi-destination"}),"\n",(0,t.jsx)(e.h3,{id:"1-multiple-sources-bfs",children:"1. Multiple Sources BFS"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Shortest distance from any source\nfunction shortestDistanceMultiSource(grid, sources) {\n  const queue = [];\n  const visited = new Set();\n  const distances = createGrid(grid.length, grid[0].length, -1);\n\n  // Initialize all sources\n  for (const [row, col] of sources) {\n    queue.push([row, col, 0]);\n    visited.add(coordToKey(row, col));\n    distances[row][col] = 0;\n  }\n\n  while (queue.length > 0) {\n    const [row, col, dist] = queue.shift();\n\n    for (const [dr, dc] of DIRECTIONS_4) {\n      const newRow = row + dr;\n      const newCol = col + dc;\n      const key = coordToKey(newRow, newCol);\n\n      if (isValidCell(grid, newRow, newCol) && !visited.has(key)) {\n        visited.add(key);\n        distances[newRow][newCol] = dist + 1;\n        queue.push([newRow, newCol, dist + 1]);\n      }\n    }\n  }\n\n  return distances;\n}\n\n// Find meeting point of multiple sources\nfunction findMeetingPoint(grid, sources) {\n  const distanceMaps = sources.map(source =>\n    shortestDistanceMultiSource(grid, [source])\n  );\n\n  let minMaxDistance = Infinity;\n  let meetingPoint = null;\n\n  for (let row = 0; row < grid.length; row++) {\n    for (let col = 0; col < grid[0].length; col++) {\n      if (!isValidCell(grid, row, col)) continue;\n\n      const maxDistance = Math.max(\n        ...distanceMaps.map(distMap => distMap[row][col])\n      );\n\n      if (maxDistance < minMaxDistance && maxDistance !== -1) {\n        minMaxDistance = maxDistance;\n        meetingPoint = [row, col];\n      }\n    }\n  }\n\n  return { point: meetingPoint, distance: minMaxDistance };\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-multiple-destinations",children:"2. Multiple Destinations"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Find shortest path to any destination\nfunction shortestPathToAnyDestination(grid, start, destinations) {\n  const [startRow, startCol] = start;\n  const destSet = new Set(destinations.map(([r, c]) => coordToKey(r, c)));\n\n  const queue = [[startRow, startCol, 0, [[startRow, startCol]]]];\n  const visited = new Set([coordToKey(startRow, startCol)]);\n\n  while (queue.length > 0) {\n    const [row, col, dist, path] = queue.shift();\n\n    if (destSet.has(coordToKey(row, col))) {\n      return { destination: [row, col], distance: dist, path };\n    }\n\n    for (const [dr, dc] of DIRECTIONS_4) {\n      const newRow = row + dr;\n      const newCol = col + dc;\n      const key = coordToKey(newRow, newCol);\n\n      if (isValidCell(grid, newRow, newCol) && !visited.has(key)) {\n        visited.add(key);\n        queue.push([newRow, newCol, dist + 1, [...path, [newRow, newCol]]]);\n      }\n    }\n  }\n\n  return null; // No destination reachable\n}\n\n// Find all reachable destinations with distances\nfunction allReachableDestinations(grid, start, destinations) {\n  const [startRow, startCol] = start;\n  const destSet = new Set(destinations.map(([r, c]) => coordToKey(r, c)));\n  const results = [];\n\n  const queue = [[startRow, startCol, 0]];\n  const visited = new Set([coordToKey(startRow, startCol)]);\n\n  while (queue.length > 0) {\n    const [row, col, dist] = queue.shift();\n\n    if (destSet.has(coordToKey(row, col))) {\n      results.push({ destination: [row, col], distance: dist });\n    }\n\n    for (const [dr, dc] of DIRECTIONS_4) {\n      const newRow = row + dr;\n      const newCol = col + dc;\n      const key = coordToKey(newRow, newCol);\n\n      if (isValidCell(grid, newRow, newCol) && !visited.has(key)) {\n        visited.add(key);\n        queue.push([newRow, newCol, dist + 1]);\n      }\n    }\n  }\n\n  return results;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"console.log('=== Grid-Based Graph Algorithms Demo ===');\n\n// Create sample grids\nconst binaryGrid = [\n  ['1', '1', '0', '0', '0'],\n  ['1', '1', '0', '0', '0'],\n  ['0', '0', '1', '0', '0'],\n  ['0', '0', '0', '1', '1'],\n];\n\nconst pathGrid = [\n  [0, 0, 0, 1, 0],\n  [1, 1, 0, 1, 0],\n  [0, 0, 0, 0, 0],\n  [0, 1, 1, 1, 0],\n  [0, 0, 0, 0, 0],\n]; // 0 = walkable, 1 = blocked\n\nconsole.log('Original binary grid:');\nprintGrid(binaryGrid);\n\n// Count islands\nconst islandCount = numIslands(binaryGrid);\nconsole.log('Number of islands:', islandCount);\n\n// Find all islands\nconst allIslands = getAllIslands(binaryGrid);\nconsole.log('All islands:', allIslands);\n\n// Largest island area\nconst maxArea = maxAreaOfIsland(\n  binaryGrid.map(row => row.map(cell => (cell === '1' ? 1 : 0)))\n);\nconsole.log('Largest island area:', maxArea);\n\n// Shortest path finding\nconsole.log('\\nPath finding demo:');\nprintGrid(pathGrid);\n\nconst start = [0, 0];\nconst end = [4, 4];\nconst shortestPathResult = shortestPath(pathGrid, start, end);\n\nif (shortestPathResult) {\n  console.log('Shortest path distance:', shortestPathResult.distance);\n  console.log('Path:', shortestPathResult.path);\n} else {\n  console.log('No path found');\n}\n\n// A* pathfinding\nconst aStarPath = aStar(pathGrid, start, end);\nconsole.log('A* path:', aStarPath);\n\n// Flood fill demo\nconst floodGrid = [\n  [1, 1, 1],\n  [1, 1, 0],\n  [1, 0, 1],\n];\n\nconsole.log('\\nBefore flood fill:');\nprintGrid(floodGrid);\n\nfloodFill(floodGrid, 1, 1, 2);\nconsole.log('After flood fill:');\nprintGrid(floodGrid);\n\n// Multi-source BFS\nconst multiSourceGrid = createGrid(5, 5, 0);\nconst sources = [\n  [0, 0],\n  [4, 4],\n];\nconst distances = shortestDistanceMultiSource(multiSourceGrid, sources);\n\nconsole.log('\\nDistances from multiple sources:');\nprintGrid(distances);\n\n// DFS applications\nconsole.log('\\nDFS path finding:');\nconst dfsPath = dfsWithPath(pathGrid, 0, 0, 0); // Find any 0 (walkable cell)\nif (dfsPath) {\n  console.log('DFS found path to walkable cell:', dfsPath.slice(0, 5)); // Show first 5 steps\n}\n\n// Unique paths counting\nconst pathCount = uniquePaths(3, 3);\nconsole.log('Unique paths in 3x3 grid:', pathCount);\n\n// Spiral traversal\nconst spiralGrid = generateSpiralGrid(4);\nconsole.log('\\nSpiral grid:');\nprintGrid(spiralGrid);\n\nconst spiral = spiralOrder(spiralGrid);\nconsole.log('Spiral order:', spiral);\n\n// Grid transformations\nconst originalGrid = [\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9],\n];\n\nconsole.log('\\nOriginal grid:');\nprintGrid(originalGrid);\n\nconsole.log('Rotated 90\xb0 clockwise:');\nprintGrid(rotateGrid(originalGrid));\n\nconsole.log('Flipped horizontally:');\nprintGrid(flipHorizontal(originalGrid));\n\n// Dynamic programming example\nconst dpGrid = [\n  [1, 3, 1],\n  [1, 5, 1],\n  [4, 2, 1],\n];\n\nconst minSum = minPathSum(cloneGrid(dpGrid));\nconsole.log('Minimum path sum:', minSum);\n\n// Meeting point example\nconst meetingPointResult = findMeetingPoint(createGrid(5, 5, 0), [\n  [0, 0],\n  [4, 4],\n  [2, 0],\n]);\nconsole.log('Optimal meeting point:', meetingPointResult);\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"time-complexity-summary",children:"Time Complexity Summary"}),"\n",(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{children:"Algorithm"}),(0,t.jsx)(e.th,{children:"Time Complexity"}),(0,t.jsx)(e.th,{children:"Space Complexity"})]})}),(0,t.jsxs)(e.tbody,{children:[(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"DFS"}),(0,t.jsx)(e.td,{children:"O(V + E) = O(mn)"}),(0,t.jsx)(e.td,{children:"O(mn)"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"BFS"}),(0,t.jsx)(e.td,{children:"O(V + E) = O(mn)"}),(0,t.jsx)(e.td,{children:"O(mn)"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"A*"}),(0,t.jsx)(e.td,{children:"O(E log V)"}),(0,t.jsx)(e.td,{children:"O(V)"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Dijkstra"}),(0,t.jsx)(e.td,{children:"O(E log V)"}),(0,t.jsx)(e.td,{children:"O(V)"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Flood Fill"}),(0,t.jsx)(e.td,{children:"O(mn)"}),(0,t.jsx)(e.td,{children:"O(mn)"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Island Count"}),(0,t.jsx)(e.td,{children:"O(mn)"}),(0,t.jsx)(e.td,{children:"O(mn)"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Union Find"}),(0,t.jsx)(e.td,{children:"O(mn\u03b1(n))"}),(0,t.jsx)(e.td,{children:"O(mn)"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Multi-source BFS"}),(0,t.jsx)(e.td,{children:"O(mn)"}),(0,t.jsx)(e.td,{children:"O(mn)"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Unique Paths"}),(0,t.jsx)(e.td,{children:"O(mn)"}),(0,t.jsx)(e.td,{children:"O(mn)"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Min Path Sum"}),(0,t.jsx)(e.td,{children:"O(mn)"}),(0,t.jsx)(e.td,{children:"O(1)"})]})]})]}),"\n",(0,t.jsx)(e.p,{children:"Where m = number of rows, n = number of columns, V = vertices (mn), E = edges (\u2264 4mn)"}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"common-patterns-to-remember",children:"Common Patterns to Remember"}),"\n",(0,t.jsxs)(e.h3,{id:"1-boundary-checks-pattern",children:["1. ",(0,t.jsx)(e.strong,{children:"Boundary Checks Pattern"})]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"if (\n  !isValid(grid, row, col) ||\n  visited.has(key) ||\n  grid[row][col] === blocked\n) {\n  return;\n}\n"})}),"\n",(0,t.jsxs)(e.h3,{id:"2-direction-iteration-pattern",children:["2. ",(0,t.jsx)(e.strong,{children:"Direction Iteration Pattern"})]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"for (const [dr, dc] of DIRECTIONS_4) {\n  const newRow = row + dr;\n  const newCol = col + dc;\n  // Process neighbor\n}\n"})}),"\n",(0,t.jsxs)(e.h3,{id:"3-visited-set-pattern",children:["3. ",(0,t.jsx)(e.strong,{children:"Visited Set Pattern"})]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"const visited = new Set();\nconst key = coordToKey(row, col);\nif (visited.has(key)) return;\nvisited.add(key);\n"})}),"\n",(0,t.jsxs)(e.h3,{id:"4-bfs-level-processing-pattern",children:["4. ",(0,t.jsx)(e.strong,{children:"BFS Level Processing Pattern"})]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"while (queue.length > 0) {\n  const levelSize = queue.length;\n  for (let i = 0; i < levelSize; i++) {\n    // Process all nodes at current level\n  }\n}\n"})}),"\n",(0,t.jsxs)(e.h3,{id:"5-multi-source-initialization-pattern",children:["5. ",(0,t.jsx)(e.strong,{children:"Multi-source Initialization Pattern"})]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"for (const [row, col] of sources) {\n  queue.push([row, col, 0]);\n  visited.add(coordToKey(row, col));\n}\n"})}),"\n",(0,t.jsxs)(e.h3,{id:"6-path-reconstruction-pattern",children:["6. ",(0,t.jsx)(e.strong,{children:"Path Reconstruction Pattern"})]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"const path = [];\nlet current = endKey;\nwhile (current) {\n  const [r, c] = keyToCoord(current);\n  path.unshift([r, c]);\n  current = parent.get(current);\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"key-interview-tips",children:"Key Interview Tips"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Always validate coordinates"}),": Use ",(0,t.jsx)(e.code,{children:"isValid()"})," before accessing grid cells"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Choose right traversal"}),": DFS for paths/connectivity, BFS for shortest distance"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Use proper data structures"}),": Set for visited, Map for distances/parents"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Handle edge cases"}),": Empty grid, single cell, no path exists"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Consider 4 vs 8 directions"}),": Clarify movement rules with interviewer"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Optimize space"}),": Use in-place modifications when possible"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Test with examples"}),": Draw small grids and trace through algorithm"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Time vs Space tradeoffs"}),": Sometimes recursion limit requires iterative approach"]}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"real-world-applications",children:"Real-World Applications"}),"\n",(0,t.jsxs)(e.h3,{id:"1-game-development",children:["1. ",(0,t.jsx)(e.strong,{children:"Game Development"})]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Pathfinding for NPCs"}),"\n",(0,t.jsx)(e.li,{children:"Line of sight calculations"}),"\n",(0,t.jsx)(e.li,{children:"Procedural map generation"}),"\n"]}),"\n",(0,t.jsxs)(e.h3,{id:"2-image-processing",children:["2. ",(0,t.jsx)(e.strong,{children:"Image Processing"})]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Connected component analysis"}),"\n",(0,t.jsx)(e.li,{children:"Flood fill tools"}),"\n",(0,t.jsx)(e.li,{children:"Edge detection"}),"\n"]}),"\n",(0,t.jsxs)(e.h3,{id:"3-geographic-information-systems",children:["3. ",(0,t.jsx)(e.strong,{children:"Geographic Information Systems"})]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Route planning"}),"\n",(0,t.jsx)(e.li,{children:"Watershed analysis"}),"\n",(0,t.jsx)(e.li,{children:"Land use classification"}),"\n"]}),"\n",(0,t.jsxs)(e.h3,{id:"4-robotics",children:["4. ",(0,t.jsx)(e.strong,{children:"Robotics"})]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Navigation in grid environments"}),"\n",(0,t.jsx)(e.li,{children:"Obstacle avoidance"}),"\n",(0,t.jsx)(e.li,{children:"Coverage path planning"}),"\n"]}),"\n",(0,t.jsxs)(e.h3,{id:"5-network-analysis",children:["5. ",(0,t.jsx)(e.strong,{children:"Network Analysis"})]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Social network clustering"}),"\n",(0,t.jsx)(e.li,{children:"Infrastructure planning"}),"\n",(0,t.jsx)(e.li,{children:"Facility location problems"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"This comprehensive guide covers all essential grid-based graph algorithms needed for coding interviews and real-world applications!"})]})}function h(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(c,{...n})}):c(n)}}}]);