"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[5115],{28453:(n,i,t)=>{t.d(i,{R:()=>a,x:()=>o});var e=t(96540);const r={},s=e.createContext(r);function a(n){const i=e.useContext(s);return e.useMemo(function(){return"function"==typeof n?n(i):{...i,...n}},[i,n])}function o(n){let i;return i=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:a(n.components),e.createElement(s.Provider,{value:i},n.children)}},92523:(n,i,t)=>{t.r(i),t.d(i,{assets:()=>l,contentTitle:()=>a,default:()=>p,frontMatter:()=>s,metadata:()=>o,toc:()=>u});var e=t(74848),r=t(28453);const s={},a="Bit Manipulation",o={id:"DSA/DSA with Java/Bit Manipulation",title:"Bit Manipulation",description:"Table of Contents",source:"@site/docs/DSA/DSA with Java/Bit Manipulation.mdx",sourceDirName:"DSA/DSA with Java",slug:"/DSA/DSA with Java/Bit Manipulation",permalink:"/js.enigma/docs/DSA/DSA with Java/Bit Manipulation",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with Java/Bit Manipulation.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Binary Tree View Implementations",permalink:"/js.enigma/docs/DSA/DSA with Java/Binary Tree View Implementations"},next:{title:"Dynamic Programming",permalink:"/js.enigma/docs/DSA/DSA with Java/Dynamic Programming"}},l={},u=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Bit Manipulation Fundamentals",id:"bit-manipulation-fundamentals",level:2},{value:"Core Concepts and Operations",id:"core-concepts-and-operations",level:3},{value:"Pattern 1: Basic Bitwise Operations",id:"pattern-1-basic-bitwise-operations",level:2},{value:"1.1 Fundamental Bit Operations",id:"11-fundamental-bit-operations",level:3},{value:"1.2 Advanced Bit Checking",id:"12-advanced-bit-checking",level:3},{value:"Pattern 2: Bit Checking &amp; Setting",id:"pattern-2-bit-checking--setting",level:2},{value:"2.1 Bit Manipulation for Arrays",id:"21-bit-manipulation-for-arrays",level:3},{value:"Pattern 3: Power of Two Operations",id:"pattern-3-power-of-two-operations",level:2},{value:"3.1 Power of Two Detection and Manipulation",id:"31-power-of-two-detection-and-manipulation",level:3},{value:"3.2 Advanced Power Operations",id:"32-advanced-power-operations",level:3},{value:"Pattern 4: Single Number Problems",id:"pattern-4-single-number-problems",level:2},{value:"4.1 Finding Unique Elements",id:"41-finding-unique-elements",level:3},{value:"Pattern 5: Bit Counting &amp; Manipulation",id:"pattern-5-bit-counting--manipulation",level:2},{value:"5.1 Counting Set Bits",id:"51-counting-set-bits",level:3},{value:"5.2 Bit Manipulation Tricks",id:"52-bit-manipulation-tricks",level:3},{value:"Pattern 6: Bitmasking Techniques[6]",id:"pattern-6-bitmasking-techniques6",level:2},{value:"6.1 Basic Bitmasking",id:"61-basic-bitmasking",level:3},{value:"6.2 Advanced Bitmasking Applications",id:"62-advanced-bitmasking-applications",level:3},{value:"Pattern 7: XOR-Based Problems",id:"pattern-7-xor-based-problems",level:2},{value:"7.1 XOR Properties and Applications",id:"71-xor-properties-and-applications",level:3},{value:"Pattern 8: Bit Shifting Patterns",id:"pattern-8-bit-shifting-patterns",level:2},{value:"8.1 Left and Right Shift Operations[8]",id:"81-left-and-right-shift-operations8",level:3},{value:"8.2 Advanced Shifting Applications",id:"82-advanced-shifting-applications",level:3},{value:"Pattern 9: Gray Code &amp; Binary Representation",id:"pattern-9-gray-code--binary-representation",level:2},{value:"9.1 Gray Code Generation and Properties",id:"91-gray-code-generation-and-properties",level:3},{value:"9.2 Binary Representation Utilities",id:"92-binary-representation-utilities",level:3},{value:"Pattern 10: Advanced Bit Manipulation",id:"pattern-10-advanced-bit-manipulation",level:2},{value:"10.1 Complex Bit Operations",id:"101-complex-bit-operations",level:3},{value:"Pattern 11: Optimization with Bits",id:"pattern-11-optimization-with-bits",level:2},{value:"11.1 Space and Time Optimizations",id:"111-space-and-time-optimizations",level:3},{value:"Pattern 12: Real-World Applications",id:"pattern-12-real-world-applications",level:2},{value:"12.1 Practical Bit Manipulation Applications",id:"121-practical-bit-manipulation-applications",level:3},{value:"Time &amp; Space Complexity Reference",id:"time--space-complexity-reference",level:2}];function c(n){const i={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.R)(),...n.components};return(0,e.jsxs)(e.Fragment,{children:[(0,e.jsx)(i.header,{children:(0,e.jsx)(i.h1,{id:"bit-manipulation",children:"Bit Manipulation"})}),"\n",(0,e.jsx)(i.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,e.jsxs)(i.ol,{children:["\n",(0,e.jsx)(i.li,{children:(0,e.jsx)(i.a,{href:"#bit-manipulation-fundamentals",children:"Bit Manipulation Fundamentals"})}),"\n",(0,e.jsx)(i.li,{children:(0,e.jsx)(i.a,{href:"#pattern-1-basic-bitwise-operations",children:"Pattern 1: Basic Bitwise Operations"})}),"\n",(0,e.jsx)(i.li,{children:(0,e.jsx)(i.a,{href:"#pattern-2-bit-checking--setting",children:"Pattern 2: Bit Checking & Setting"})}),"\n",(0,e.jsx)(i.li,{children:(0,e.jsx)(i.a,{href:"#pattern-3-power-of-two-operations",children:"Pattern 3: Power of Two Operations"})}),"\n",(0,e.jsx)(i.li,{children:(0,e.jsx)(i.a,{href:"#pattern-4-single-number-problems",children:"Pattern 4: Single Number Problems"})}),"\n",(0,e.jsx)(i.li,{children:(0,e.jsx)(i.a,{href:"#pattern-5-bit-counting--manipulation",children:"Pattern 5: Bit Counting & Manipulation"})}),"\n",(0,e.jsx)(i.li,{children:(0,e.jsx)(i.a,{href:"#pattern-6-bitmasking-techniques",children:"Pattern 6: Bitmasking Techniques"})}),"\n",(0,e.jsx)(i.li,{children:(0,e.jsx)(i.a,{href:"#pattern-7-xor-based-problems",children:"Pattern 7: XOR-Based Problems"})}),"\n",(0,e.jsx)(i.li,{children:(0,e.jsx)(i.a,{href:"#pattern-8-bit-shifting-patterns",children:"Pattern 8: Bit Shifting Patterns"})}),"\n",(0,e.jsx)(i.li,{children:(0,e.jsx)(i.a,{href:"#pattern-9-gray-code--binary-representation",children:"Pattern 9: Gray Code & Binary Representation"})}),"\n",(0,e.jsx)(i.li,{children:(0,e.jsx)(i.a,{href:"#pattern-10-advanced-bit-manipulation",children:"Pattern 10: Advanced Bit Manipulation"})}),"\n",(0,e.jsx)(i.li,{children:(0,e.jsx)(i.a,{href:"#pattern-11-optimization-with-bits",children:"Pattern 11: Optimization with Bits"})}),"\n",(0,e.jsx)(i.li,{children:(0,e.jsx)(i.a,{href:"#pattern-12-real-world-applications",children:"Pattern 12: Real-World Applications"})}),"\n"]}),"\n",(0,e.jsx)(i.hr,{}),"\n",(0,e.jsx)(i.h2,{id:"bit-manipulation-fundamentals",children:"Bit Manipulation Fundamentals"}),"\n",(0,e.jsx)(i.h3,{id:"core-concepts-and-operations",children:"Core Concepts and Operations"}),"\n",(0,e.jsx)(i.pre,{children:(0,e.jsx)(i.code,{className:"language-java",children:'// Basic Bitwise Operations in Java\npublic class BitManipulationFundamentals {\n\n    // Bitwise Operators\n    public static void demonstrateBitwiseOperators() {\n        int a = 12;  // Binary: 1100\n        int b = 10;  // Binary: 1010\n\n        System.out.println("a = " + a + " (Binary: " + Integer.toBinaryString(a) + ")");\n        System.out.println("b = " + b + " (Binary: " + Integer.toBinaryString(b) + ")");\n\n        // AND operator (&)\n        int andResult = a & b; // 1100 & 1010 = 1000 (8)\n        System.out.println("a & b = " + andResult + " (Binary: " + Integer.toBinaryString(andResult) + ")");\n\n        // OR operator (|)\n        int orResult = a | b; // 1100 | 1010 = 1110 (14)\n        System.out.println("a | b = " + orResult + " (Binary: " + Integer.toBinaryString(orResult) + ")");\n\n        // XOR operator (^)\n        int xorResult = a ^ b; // 1100 ^ 1010 = 0110 (6)\n        System.out.println("a ^ b = " + xorResult + " (Binary: " + Integer.toBinaryString(xorResult) + ")");\n\n        // NOT operator (~) - Bitwise complement\n        int notA = ~a; // ~1100 = ...11110011 (two\'s complement)\n        System.out.println("~a = " + notA + " (Binary: " + Integer.toBinaryString(notA) + ")");\n\n        // Left shift (<<)\n        int leftShift = a << 2; // 1100 << 2 = 110000 (48)\n        System.out.println("a << 2 = " + leftShift + " (Binary: " + Integer.toBinaryString(leftShift) + ")");\n\n        // Right shift (>>)\n        int rightShift = a >> 2; // 1100 >> 2 = 11 (3)\n        System.out.println("a >> 2 = " + rightShift + " (Binary: " + Integer.toBinaryString(rightShift) + ")");\n\n        // Unsigned right shift (>>>)\n        int unsignedRightShift = a >>> 2;\n        System.out.println("a >>> 2 = " + unsignedRightShift + " (Binary: " + Integer.toBinaryString(unsignedRightShift) + ")");\n    }\n\n    // Essential Bit Manipulation Utilities\n    public static class BitUtils {\n\n        // Get bit at position i (0-indexed from right)\n        public static boolean getBit(int num, int i) {\n            return (num & (1 << i)) != 0;\n        }\n\n        // Set bit at position i\n        public static int setBit(int num, int i) {\n            return num | (1 << i);\n        }\n\n        // Clear bit at position i\n        public static int clearBit(int num, int i) {\n            return num & ~(1 << i);\n        }\n\n        // Toggle bit at position i\n        public static int toggleBit(int num, int i) {\n            return num ^ (1 << i);\n        }\n\n        // Count number of set bits (1s)\n        public static int countSetBits(int num) {\n            int count = 0;\n            while (num != 0) {\n                count++;\n                num &= (num - 1); // Remove rightmost set bit\n            }\n            return count;\n        }\n\n        // Count number of set bits using built-in method\n        public static int countSetBitsBuiltIn(int num) {\n            return Integer.bitCount(num);\n        }\n\n        // Find rightmost set bit position (1-indexed)\n        public static int rightmostSetBit(int num) {\n            if (num == 0) return 0;\n            return Integer.numberOfTrailingZeros(num) + 1;\n        }\n\n        // Find leftmost set bit position (1-indexed from right)\n        public static int leftmostSetBit(int num) {\n            if (num == 0) return 0;\n            return 32 - Integer.numberOfLeadingZeros(num);\n        }\n\n        // Isolate rightmost set bit\n        public static int isolateRightmostSetBit(int num) {\n            return num & (-num);\n        }\n\n        // Remove rightmost set bit\n        public static int removeRightmostSetBit(int num) {\n            return num & (num - 1);\n        }\n\n        // Check if number is power of 2\n        public static boolean isPowerOfTwo(int num) {\n            return num > 0 && (num & (num - 1)) == 0;\n        }\n\n        // Reverse bits of a 32-bit integer\n        public static int reverseBits(int num) {\n            int result = 0;\n            for (int i = 0; i < 32; i++) {\n                result = (result << 1) | (num & 1);\n                num >>= 1;\n            }\n            return result;\n        }\n\n        // Check if bits are in alternating pattern\n        public static boolean hasAlternatingBits(int num) {\n            int xor = num ^ (num >> 1);\n            return (xor & (xor + 1)) == 0;\n        }\n\n        // Swap two numbers without using temporary variable\n        public static void swapNumbers(int a, int b) {\n            System.out.println("Before swap: a = " + a + ", b = " + b);\n            a = a ^ b;\n            b = a ^ b;\n            a = a ^ b;\n            System.out.println("After swap: a = " + a + ", b = " + b);\n        }\n    }\n\n    // Binary representation utilities\n    public static class BinaryUtils {\n\n        // Convert decimal to binary string\n        public static String decimalToBinary(int num) {\n            return Integer.toBinaryString(num);\n        }\n\n        // Convert binary string to decimal\n        public static int binaryToDecimal(String binary) {\n            return Integer.parseInt(binary, 2);\n        }\n\n        // Print binary representation with fixed width\n        public static void printBinary(int num, int width) {\n            String binary = Integer.toBinaryString(num);\n            String formatted = String.format("%" + width + "s", binary).replace(\' \', \'0\');\n            System.out.println(num + " -> " + formatted);\n        }\n\n        // Get binary representation of negative numbers (two\'s complement)\n        public static String getBinaryWithSign(int num) {\n            if (num >= 0) {\n                return Integer.toBinaryString(num);\n            } else {\n                // For negative numbers, show 32-bit two\'s complement\n                return String.format("%32s", Integer.toBinaryString(num)).replace(\' \', \'1\');\n            }\n        }\n    }\n}\n'})}),"\n",(0,e.jsx)(i.hr,{}),"\n",(0,e.jsx)(i.h2,{id:"pattern-1-basic-bitwise-operations",children:"Pattern 1: Basic Bitwise Operations"}),"\n",(0,e.jsx)(i.h3,{id:"11-fundamental-bit-operations",children:"1.1 Fundamental Bit Operations"}),"\n",(0,e.jsx)(i.pre,{children:(0,e.jsx)(i.code,{className:"language-java",children:"// Basic bit manipulation operations\npublic class BasicBitOperations {\n\n    // Check if a bit is set at position i\n    public boolean isBitSet(int num, int position) {\n        return (num & (1 << position)) != 0;\n    }\n\n    // Set a bit at position i\n    public int setBit(int num, int position) {\n        return num | (1 << position);\n    }\n\n    // Clear a bit at position i\n    public int clearBit(int num, int position) {\n        int mask = ~(1 << position);\n        return num & mask;\n    }\n\n    // Toggle a bit at position i\n    public int toggleBit(int num, int position) {\n        return num ^ (1 << position);\n    }\n\n    // Update bit at position i with given value (0 or 1)\n    public int updateBit(int num, int position, boolean bitValue) {\n        int value = bitValue ? 1 : 0;\n        int mask = ~(1 << position); // Clear the bit at position\n        return (num & mask) | (value << position); // Set new value\n    }\n\n    // Get range of bits from position i to j (inclusive)\n    public int getBitRange(int num, int i, int j) {\n        // Create mask with 1s from position i to j\n        int allOnes = ~0; // All 1s\n        int left = allOnes << (j + 1);\n        int right = (1 << i) - 1;\n        int mask = left | right;\n\n        return (num & ~mask) >> i;\n    }\n\n    // Set range of bits from position i to j with given value\n    public int setBitRange(int num, int value, int i, int j) {\n        // Clear bits from i to j\n        int allOnes = ~0;\n        int left = allOnes << (j + 1);\n        int right = (1 << i) - 1;\n        int mask = left | right;\n\n        int cleared = num & mask;\n        return cleared | (value << i);\n    }\n\n    // Count consecutive 1s from right\n    public int countTrailingOnes(int num) {\n        int count = 0;\n        while ((num & 1) == 1) {\n            count++;\n            num >>= 1;\n        }\n        return count;\n    }\n\n    // Count consecutive 0s from right\n    public int countTrailingZeros(int num) {\n        if (num == 0) return 32; // All bits are 0\n\n        int count = 0;\n        while ((num & 1) == 0) {\n            count++;\n            num >>= 1;\n        }\n        return count;\n    }\n\n    // Find position of rightmost set bit (1-indexed)\n    public int findRightmostSetBit(int num) {\n        if (num == 0) return -1;\n\n        // Method 1: Using loop\n        int position = 1;\n        while ((num & 1) == 0) {\n            num >>= 1;\n            position++;\n        }\n        return position;\n    }\n\n    // Alternative method using bit manipulation trick\n    public int findRightmostSetBitOptimized(int num) {\n        if (num == 0) return -1;\n\n        // Isolate rightmost set bit and count trailing zeros\n        return Integer.numberOfTrailingZeros(num & -num) + 1;\n    }\n\n    // Check if only one bit is set (power of 2)\n    public boolean hasOnlyOneBitSet(int num) {\n        return num > 0 && (num & (num - 1)) == 0;\n    }\n\n    // Count number of different bits between two numbers\n    public int countDifferentBits(int a, int b) {\n        int xor = a ^ b;\n        return Integer.bitCount(xor);\n    }\n}\n"})}),"\n",(0,e.jsx)(i.h3,{id:"12-advanced-bit-checking",children:"1.2 Advanced Bit Checking"}),"\n",(0,e.jsx)(i.pre,{children:(0,e.jsx)(i.code,{className:"language-java",children:"// Advanced bit checking operations\npublic class AdvancedBitChecking {\n\n    // Check if number has alternating bits (101010... pattern)\n    public boolean hasAlternatingBits(int n) {\n        // XOR with right-shifted version should give all 1s\n        int xor = n ^ (n >> 1);\n        return (xor & (xor + 1)) == 0;\n    }\n\n    // Check if all bits in given range are set\n    public boolean areAllBitsSetInRange(int num, int left, int right) {\n        // Create mask with 1s from left to right\n        int len = right - left + 1;\n        int mask = ((1 << len) - 1) << left;\n\n        return (num & mask) == mask;\n    }\n\n    // Check if any bit in given range is set\n    public boolean isAnyBitSetInRange(int num, int left, int right) {\n        int len = right - left + 1;\n        int mask = ((1 << len) - 1) << left;\n\n        return (num & mask) != 0;\n    }\n\n    // Find first set bit position from left (MSB side)\n    public int findFirstSetBitFromLeft(int num) {\n        if (num == 0) return -1;\n\n        return 32 - Integer.numberOfLeadingZeros(num);\n    }\n\n    // Check if bits form a palindrome\n    public boolean areBitsPalindrome(int num) {\n        // Get significant bits only\n        int significantBits = 32 - Integer.numberOfLeadingZeros(num);\n\n        for (int i = 0; i < significantBits / 2; i++) {\n            int leftBit = (num >> (significantBits - 1 - i)) & 1;\n            int rightBit = (num >> i) & 1;\n\n            if (leftBit != rightBit) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    // Check if number is sparse (no two adjacent bits are set)\n    public boolean isSparseNumber(int num) {\n        return (num & (num >> 1)) == 0;\n    }\n\n    // Find next sparse number\n    public int nextSparseNumber(int num) {\n        num++;\n        while (!isSparseNumber(num)) {\n            num++;\n        }\n        return num;\n    }\n\n    // Check if bit pattern matches given pattern with wildcards\n    public boolean matchesPattern(int num, String pattern) {\n        // Pattern can contain '0', '1', or 'X' (wildcard)\n        if (pattern.length() > 32) return false;\n\n        for (int i = 0; i < pattern.length(); i++) {\n            char expected = pattern.charAt(pattern.length() - 1 - i);\n            if (expected == 'X') continue;\n\n            int actualBit = (num >> i) & 1;\n            int expectedBit = expected - '0';\n\n            if (actualBit != expectedBit) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n"})}),"\n",(0,e.jsx)(i.hr,{}),"\n",(0,e.jsx)(i.h2,{id:"pattern-2-bit-checking--setting",children:"Pattern 2: Bit Checking & Setting"}),"\n",(0,e.jsx)(i.h3,{id:"21-bit-manipulation-for-arrays",children:"2.1 Bit Manipulation for Arrays"}),"\n",(0,e.jsx)(i.pre,{children:(0,e.jsx)(i.code,{className:"language-java",children:"// Bit manipulation operations on arrays\npublic class ArrayBitOperations {\n\n    // Find element that appears odd number of times\n    public int findOddOccurrence(int[] arr) {\n        int result = 0;\n        for (int num : arr) {\n            result ^= num;\n        }\n        return result; // XOR of all elements cancels out even occurrences\n    }\n\n    // Find two elements that appear odd number of times\n    public int[] findTwoOddOccurrences(int[] arr) {\n        int xor = 0;\n\n        // XOR all elements\n        for (int num : arr) {\n            xor ^= num;\n        }\n\n        // Find rightmost set bit in XOR\n        int rightmostSetBit = xor & (-xor);\n\n        int first = 0, second = 0;\n\n        // Divide numbers into two groups based on rightmost set bit\n        for (int num : arr) {\n            if ((num & rightmostSetBit) != 0) {\n                first ^= num;\n            } else {\n                second ^= num;\n            }\n        }\n\n        return new int[]{first, second};\n    }\n\n    // Check if array can be divided into pairs with equal XOR\n    public boolean canDivideIntoPairs(int[] arr) {\n        int xor = 0;\n        for (int num : arr) {\n            xor ^= num;\n        }\n        return xor == 0; // Total XOR should be 0\n    }\n\n    // Find minimum XOR pair in array\n    public int minXORPair(int[] arr) {\n        Arrays.sort(arr); // Sort to minimize XOR between adjacent elements\n\n        int minXOR = Integer.MAX_VALUE;\n        for (int i = 0; i < arr.length - 1; i++) {\n            minXOR = Math.min(minXOR, arr[i] ^ arr[i + 1]);\n        }\n\n        return minXOR;\n    }\n\n    // Count pairs with given XOR\n    public int countPairsWithXOR(int[] arr, int k) {\n        Set<Integer> seen = new HashSet<>();\n        int count = 0;\n\n        for (int num : arr) {\n            if (seen.contains(num ^ k)) {\n                count++;\n            }\n            seen.add(num);\n        }\n\n        return count;\n    }\n\n    // Find subarray with maximum XOR\n    public int maxSubarrayXOR(int[] arr) {\n        int maxXOR = Integer.MIN_VALUE;\n\n        for (int i = 0; i < arr.length; i++) {\n            int currentXOR = 0;\n            for (int j = i; j < arr.length; j++) {\n                currentXOR ^= arr[j];\n                maxXOR = Math.max(maxXOR, currentXOR);\n            }\n        }\n\n        return maxXOR;\n    }\n\n    // Count subarrays with XOR equal to k\n    public int countSubarraysWithXOR(int[] arr, int k) {\n        Map<Integer, Integer> prefixXORCount = new HashMap<>();\n        prefixXORCount.put(0, 1); // Empty prefix\n\n        int currentXOR = 0;\n        int count = 0;\n\n        for (int num : arr) {\n            currentXOR ^= num;\n\n            // Check if there exists a prefix with XOR = currentXOR ^ k\n            if (prefixXORCount.containsKey(currentXOR ^ k)) {\n                count += prefixXORCount.get(currentXOR ^ k);\n            }\n\n            prefixXORCount.put(currentXOR, prefixXORCount.getOrDefault(currentXOR, 0) + 1);\n        }\n\n        return count;\n    }\n}\n"})}),"\n",(0,e.jsx)(i.hr,{}),"\n",(0,e.jsx)(i.h2,{id:"pattern-3-power-of-two-operations",children:"Pattern 3: Power of Two Operations"}),"\n",(0,e.jsx)(i.h3,{id:"31-power-of-two-detection-and-manipulation",children:"3.1 Power of Two Detection and Manipulation"}),"\n",(0,e.jsx)(i.pre,{children:(0,e.jsx)(i.code,{className:"language-java",children:"// Power of two related operations\npublic class PowerOfTwoOperations {\n\n    // Check if number is power of 2\n    public boolean isPowerOfTwo(int n) {\n        return n > 0 && (n & (n - 1)) == 0;\n    }\n\n    // Find next power of 2 greater than or equal to n\n    public int nextPowerOfTwo(int n) {\n        if (n <= 0) return 1;\n        if (isPowerOfTwo(n)) return n;\n\n        // Set all bits after MSB\n        n |= n >> 1;\n        n |= n >> 2;\n        n |= n >> 4;\n        n |= n >> 8;\n        n |= n >> 16;\n\n        return n + 1;\n    }\n\n    // Find previous power of 2 less than or equal to n\n    public int previousPowerOfTwo(int n) {\n        if (n <= 0) return 0;\n\n        // Find position of MSB\n        return 1 << (31 - Integer.numberOfLeadingZeros(n));\n    }\n\n    // Check if number is power of 4\n    public boolean isPowerOfFour(int n) {\n        // Must be power of 2 and have set bit at even position\n        return n > 0 && (n & (n - 1)) == 0 && (n & 0x55555555) != 0;\n    }\n\n    // Count powers of 2 less than n\n    public int countPowersOfTwo(int n) {\n        if (n <= 1) return 0;\n\n        return 32 - Integer.numberOfLeadingZeros(n - 1);\n    }\n\n    // Find largest power of 2 divisor\n    public int largestPowerOfTwoDivisor(int n) {\n        return n & (-n); // Isolates rightmost set bit\n    }\n\n    // Multiply by power of 2 using bit shifting\n    public int multiplyByPowerOfTwo(int num, int power) {\n        return num << power; // num * (2^power)\n    }\n\n    // Divide by power of 2 using bit shifting\n    public int divideByPowerOfTwo(int num, int power) {\n        return num >> power; // num / (2^power)\n    }\n\n    // Check if division by power of 2 is exact\n    public boolean isDivisibleByPowerOfTwo(int num, int power) {\n        int divisor = 1 << power;\n        return (num & (divisor - 1)) == 0;\n    }\n\n    // Round up to nearest power of 2\n    public int roundUpToPowerOfTwo(int n) {\n        if (n <= 1) return 1;\n\n        return nextPowerOfTwo(n);\n    }\n\n    // Round down to nearest power of 2\n    public int roundDownToPowerOfTwo(int n) {\n        if (n <= 0) return 0;\n\n        return previousPowerOfTwo(n);\n    }\n}\n"})}),"\n",(0,e.jsx)(i.h3,{id:"32-advanced-power-operations",children:"3.2 Advanced Power Operations"}),"\n",(0,e.jsx)(i.pre,{children:(0,e.jsx)(i.code,{className:"language-java",children:"// Advanced power-related bit operations\npublic class AdvancedPowerOperations {\n\n    // Fast exponentiation using bit manipulation (a^b)\n    public long fastPower(long base, int exponent) {\n        long result = 1;\n\n        while (exponent > 0) {\n            // If exponent is odd, multiply result with base\n            if ((exponent & 1) == 1) {\n                result *= base;\n            }\n\n            // Square the base and divide exponent by 2\n            base *= base;\n            exponent >>= 1;\n        }\n\n        return result;\n    }\n\n    // Fast exponentiation with modulo\n    public long fastPowerMod(long base, int exponent, long mod) {\n        long result = 1;\n        base %= mod;\n\n        while (exponent > 0) {\n            if ((exponent & 1) == 1) {\n                result = (result * base) % mod;\n            }\n\n            base = (base * base) % mod;\n            exponent >>= 1;\n        }\n\n        return result;\n    }\n\n    // Check if number can be expressed as sum of two powers of 2\n    public boolean isSumOfTwoPowersOfTwo(int n) {\n        // Try all powers of 2 less than n\n        for (int i = 0; (1 << i) < n; i++) {\n            int powerOfTwo = 1 << i;\n            int remaining = n - powerOfTwo;\n\n            if (isPowerOfTwo(remaining)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    // Find minimum operations to reach target using doubling\n    public int minOperationsToReach(int start, int target) {\n        if (start >= target) return start - target;\n\n        int operations = 0;\n\n        while (start < target) {\n            if (target % 2 == 1) {\n                target++;\n                operations++;\n            } else {\n                target /= 2;\n                operations++;\n            }\n        }\n\n        return operations + start - target;\n    }\n\n    // Count set bits in all numbers from 1 to n\n    public int countSetBitsInRange(int n) {\n        int count = 0;\n\n        // For each bit position\n        for (int i = 0; i < 32; i++) {\n            int cycleLength = 1 << (i + 1);\n            int completeCycles = (n + 1) / cycleLength;\n            int remainder = (n + 1) % cycleLength;\n\n            count += completeCycles * (1 << i);\n\n            if (remainder > (1 << i)) {\n                count += remainder - (1 << i);\n            }\n        }\n\n        return count;\n    }\n}\n"})}),"\n",(0,e.jsx)(i.hr,{}),"\n",(0,e.jsx)(i.h2,{id:"pattern-4-single-number-problems",children:"Pattern 4: Single Number Problems"}),"\n",(0,e.jsx)(i.h3,{id:"41-finding-unique-elements",children:"4.1 Finding Unique Elements"}),"\n",(0,e.jsx)(i.pre,{children:(0,e.jsx)(i.code,{className:"language-java",children:"// Single number pattern problems\npublic class SingleNumberProblems {\n\n    // Single Number I: Find element that appears once (others appear twice)\n    public int singleNumber(int[] nums) {\n        int result = 0;\n        for (int num : nums) {\n            result ^= num;\n        }\n        return result;\n    }\n\n    // Single Number II: Find element that appears once (others appear thrice)\n    public int singleNumberII(int[] nums) {\n        int ones = 0, twos = 0;\n\n        for (int num : nums) {\n            // Update twos with bits that appear twice\n            twos |= ones & num;\n\n            // Update ones with bits that appear once\n            ones ^= num;\n\n            // Remove bits that appear three times\n            int threes = ones & twos;\n            ones &= ~threes;\n            twos &= ~threes;\n        }\n\n        return ones;\n    }\n\n    // Alternative approach for Single Number II using bit counting\n    public int singleNumberIIAlternative(int[] nums) {\n        int result = 0;\n\n        // Check each bit position\n        for (int i = 0; i < 32; i++) {\n            int count = 0;\n\n            // Count occurrences of bit i\n            for (int num : nums) {\n                if ((num & (1 << i)) != 0) {\n                    count++;\n                }\n            }\n\n            // If count is not divisible by 3, set this bit in result\n            if (count % 3 != 0) {\n                result |= (1 << i);\n            }\n        }\n\n        return result;\n    }\n\n    // Single Number III: Find two elements that appear once (others appear twice)\n    public int[] singleNumberIII(int[] nums) {\n        int xor = 0;\n\n        // XOR all numbers\n        for (int num : nums) {\n            xor ^= num;\n        }\n\n        // Find rightmost set bit\n        int rightmostSetBit = xor & (-xor);\n\n        int[] result = new int[2];\n\n        // Divide numbers into two groups\n        for (int num : nums) {\n            if ((num & rightmostSetBit) == 0) {\n                result[0] ^= num;\n            } else {\n                result[1] ^= num;\n            }\n        }\n\n        return result;\n    }\n\n    // Find element that appears k times while others appear m times\n    public int singleNumberGeneral(int[] nums, int k, int m) {\n        int[] bitCount = new int[32];\n\n        // Count bits at each position\n        for (int num : nums) {\n            for (int i = 0; i < 32; i++) {\n                if ((num & (1 << i)) != 0) {\n                    bitCount[i]++;\n                }\n            }\n        }\n\n        int result = 0;\n        for (int i = 0; i < 32; i++) {\n            if (bitCount[i] % m == k) {\n                result |= (1 << i);\n            }\n        }\n\n        return result;\n    }\n\n    // Find missing number in array [0, n]\n    public int missingNumber(int[] nums) {\n        int n = nums.length;\n        int expectedXOR = 0;\n        int actualXOR = 0;\n\n        // XOR of all numbers from 0 to n\n        for (int i = 0; i <= n; i++) {\n            expectedXOR ^= i;\n        }\n\n        // XOR of all numbers in array\n        for (int num : nums) {\n            actualXOR ^= num;\n        }\n\n        return expectedXOR ^ actualXOR;\n    }\n\n    // Alternative missing number using sum difference\n    public int missingNumberSum(int[] nums) {\n        int n = nums.length;\n        int expectedSum = n * (n + 1) / 2;\n        int actualSum = 0;\n\n        for (int num : nums) {\n            actualSum += num;\n        }\n\n        return expectedSum - actualSum;\n    }\n\n    // Find duplicate number using bit manipulation\n    public int findDuplicate(int[] nums) {\n        int n = nums.length - 1;\n\n        // Count bits at each position\n        int[] bitCount = new int[32];\n\n        for (int num : nums) {\n            for (int i = 0; i < 32; i++) {\n                if ((num & (1 << i)) != 0) {\n                    bitCount[i]++;\n                }\n            }\n        }\n\n        // Count expected bits for range [1, n]\n        int[] expectedBitCount = new int[32];\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j < 32; j++) {\n                if ((i & (1 << j)) != 0) {\n                    expectedBitCount[j]++;\n                }\n            }\n        }\n\n        int result = 0;\n        for (int i = 0; i < 32; i++) {\n            if (bitCount[i] > expectedBitCount[i]) {\n                result |= (1 << i);\n            }\n        }\n\n        return result;\n    }\n}\n"})}),"\n",(0,e.jsx)(i.hr,{}),"\n",(0,e.jsx)(i.h2,{id:"pattern-5-bit-counting--manipulation",children:"Pattern 5: Bit Counting & Manipulation"}),"\n",(0,e.jsx)(i.h3,{id:"51-counting-set-bits",children:"5.1 Counting Set Bits"}),"\n",(0,e.jsx)(i.pre,{children:(0,e.jsx)(i.code,{className:"language-java",children:"// Bit counting operations\npublic class BitCountingOperations {\n\n    // Count set bits (Hamming weight) - Brian Kernighan's algorithm\n    public int countSetBits(int n) {\n        int count = 0;\n        while (n != 0) {\n            n &= (n - 1); // Remove rightmost set bit\n            count++;\n        }\n        return count;\n    }\n\n    // Count set bits using built-in method\n    public int countSetBitsBuiltIn(int n) {\n        return Integer.bitCount(n);\n    }\n\n    // Count set bits using lookup table\n    private static final int[] BIT_COUNT_TABLE = new int[256];\n\n    static {\n        for (int i = 0; i < 256; i++) {\n            BIT_COUNT_TABLE[i] = (i & 1) + BIT_COUNT_TABLE[i >> 1];\n        }\n    }\n\n    public int countSetBitsLookup(int n) {\n        return BIT_COUNT_TABLE[n & 0xFF] +\n               BIT_COUNT_TABLE[(n >> 8) & 0xFF] +\n               BIT_COUNT_TABLE[(n >> 16) & 0xFF] +\n               BIT_COUNT_TABLE[(n >> 24) & 0xFF];\n    }\n\n    // Count total set bits from 1 to n\n    public int countSetBitsInRange(int n) {\n        int count = 0;\n\n        for (int i = 0; i < 32; i++) {\n            // Calculate pattern for bit i\n            int cycleLength = 1 << (i + 1);\n            int completeCycles = (n + 1) / cycleLength;\n            int remainder = (n + 1) % cycleLength;\n\n            count += completeCycles * (1 << i);\n\n            if (remainder > (1 << i)) {\n                count += remainder - (1 << i);\n            }\n        }\n\n        return count;\n    }\n\n    // Count numbers with even number of set bits in range [1, n]\n    public int countEvenSetBitNumbers(int n) {\n        // For large ranges, approximately half have even set bits\n        // For exact count, we need to iterate\n        int count = 0;\n        for (int i = 1; i <= n; i++) {\n            if (countSetBits(i) % 2 == 0) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    // Find number with maximum set bits in given range\n    public int maxSetBitsInRange(int left, int right) {\n        int max = 0;\n        int result = left;\n\n        for (int i = left; i <= right; i++) {\n            int setBits = countSetBits(i);\n            if (setBits > max) {\n                max = setBits;\n                result = i;\n            }\n        }\n\n        return result;\n    }\n\n    // Check if count of set bits is prime\n    public boolean hasSetBitCountPrime(int n) {\n        int count = countSetBits(n);\n        return isPrime(count);\n    }\n\n    private boolean isPrime(int n) {\n        if (n <= 1) return false;\n        if (n <= 3) return true;\n        if (n % 2 == 0 || n % 3 == 0) return false;\n\n        for (int i = 5; i * i <= n; i += 6) {\n            if (n % i == 0 || n % (i + 2) == 0) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    // Count numbers with exactly k set bits in range [1, n]\n    public int countNumbersWithKSetBits(int n, int k) {\n        int count = 0;\n        for (int i = 1; i <= n; i++) {\n            if (countSetBits(i) == k) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    // Generate next number with same number of set bits\n    public int nextNumberWithSameSetBits(int n) {\n        int c = n;\n        int c0 = 0; // Count of trailing zeros\n        int c1 = 0; // Count of ones after trailing zeros\n\n        // Count trailing zeros\n        while (((c & 1) == 0) && (c != 0)) {\n            c0++;\n            c >>= 1;\n        }\n\n        // Count ones after trailing zeros\n        while ((c & 1) == 1) {\n            c1++;\n            c >>= 1;\n        }\n\n        // If c0 + c1 == 31 or c0 + c1 == 0, then no bigger number exists\n        if (c0 + c1 == 31 || c0 + c1 == 0) {\n            return -1;\n        }\n\n        int pos = c0 + c1; // Position of rightmost non-trailing zero\n        n |= (1 << pos); // Flip the rightmost non-trailing zero\n        n &= ~((1 << pos) - 1); // Clear all bits to the right of pos\n        n |= (1 << (c1 - 1)) - 1; // Insert (c1-1) ones on the right\n\n        return n;\n    }\n}\n"})}),"\n",(0,e.jsx)(i.h3,{id:"52-bit-manipulation-tricks",children:"5.2 Bit Manipulation Tricks"}),"\n",(0,e.jsx)(i.pre,{children:(0,e.jsx)(i.code,{className:"language-java",children:"// Advanced bit manipulation tricks\npublic class BitManipulationTricks {\n\n    // Isolate rightmost set bit\n    public int isolateRightmostSetBit(int n) {\n        return n & (-n);\n    }\n\n    // Remove rightmost set bit\n    public int removeRightmostSetBit(int n) {\n        return n & (n - 1);\n    }\n\n    // Isolate rightmost 0 bit\n    public int isolateRightmostZeroBit(int n) {\n        return ~n & (n + 1);\n    }\n\n    // Set rightmost 0 bit\n    public int setRightmostZeroBit(int n) {\n        return n | (n + 1);\n    }\n\n    // Check if number has adjacent set bits\n    public boolean hasAdjacentSetBits(int n) {\n        return (n & (n << 1)) != 0;\n    }\n\n    // Swap bits at positions i and j\n    public int swapBits(int n, int i, int j) {\n        // Check if bits are different\n        if (((n >> i) & 1) != ((n >> j) & 1)) {\n            // Swap by toggling both bits\n            n ^= (1 << i) | (1 << j);\n        }\n        return n;\n    }\n\n    // Reverse bits in a number\n    public int reverseBits(int n) {\n        int result = 0;\n        for (int i = 0; i < 32; i++) {\n            result = (result << 1) | (n & 1);\n            n >>= 1;\n        }\n        return result;\n    }\n\n    // Fast way to reverse bits using lookup table\n    private static final int[] REVERSE_TABLE = new int[256];\n\n    static {\n        for (int i = 0; i < 256; i++) {\n            int reversed = 0;\n            int temp = i;\n            for (int j = 0; j < 8; j++) {\n                reversed = (reversed << 1) | (temp & 1);\n                temp >>= 1;\n            }\n            REVERSE_TABLE[i] = reversed;\n        }\n    }\n\n    public int reverseBitsFast(int n) {\n        return (REVERSE_TABLE[n & 0xFF] << 24) |\n               (REVERSE_TABLE[(n >> 8) & 0xFF] << 16) |\n               (REVERSE_TABLE[(n >> 16) & 0xFF] << 8) |\n               (REVERSE_TABLE[(n >> 24) & 0xFF]);\n    }\n\n    // Count leading zeros\n    public int countLeadingZeros(int n) {\n        if (n == 0) return 32;\n\n        int count = 0;\n        if ((n & 0xFFFF0000) == 0) { count += 16; n <<= 16; }\n        if ((n & 0xFF000000) == 0) { count += 8; n <<= 8; }\n        if ((n & 0xF0000000) == 0) { count += 4; n <<= 4; }\n        if ((n & 0xC0000000) == 0) { count += 2; n <<= 2; }\n        if ((n & 0x80000000) == 0) { count += 1; }\n\n        return count;\n    }\n\n    // Count trailing zeros\n    public int countTrailingZeros(int n) {\n        if (n == 0) return 32;\n\n        int count = 0;\n        if ((n & 0x0000FFFF) == 0) { count += 16; n >>= 16; }\n        if ((n & 0x000000FF) == 0) { count += 8; n >>= 8; }\n        if ((n & 0x0000000F) == 0) { count += 4; n >>= 4; }\n        if ((n & 0x00000003) == 0) { count += 2; n >>= 2; }\n        if ((n & 0x00000001) == 0) { count += 1; }\n\n        return count;\n    }\n\n    // Check if number is palindrome in binary\n    public boolean isBinaryPalindrome(int n) {\n        // Find number of significant bits\n        int bits = 32 - Integer.numberOfLeadingZeros(n);\n\n        for (int i = 0; i < bits / 2; i++) {\n            int leftBit = (n >> (bits - 1 - i)) & 1;\n            int rightBit = (n >> i) & 1;\n\n            if (leftBit != rightBit) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    // Generate all subsets using bit manipulation\n    public List<List<Integer>> generateSubsets(int[] nums) {\n        List<List<Integer>> subsets = new ArrayList<>();\n        int n = nums.length;\n\n        // Generate all 2^n subsets\n        for (int mask = 0; mask < (1 << n); mask++) {\n            List<Integer> subset = new ArrayList<>();\n\n            for (int i = 0; i < n; i++) {\n                if ((mask & (1 << i)) != 0) {\n                    subset.add(nums[i]);\n                }\n            }\n\n            subsets.add(subset);\n        }\n\n        return subsets;\n    }\n}\n"})}),"\n",(0,e.jsx)(i.hr,{}),"\n",(0,e.jsx)(i.h2,{id:"pattern-6-bitmasking-techniques6",children:"Pattern 6: Bitmasking Techniques[6]"}),"\n",(0,e.jsx)(i.h3,{id:"61-basic-bitmasking",children:"6.1 Basic Bitmasking"}),"\n",(0,e.jsx)(i.pre,{children:(0,e.jsx)(i.code,{className:"language-java",children:"// Bitmasking techniques for state representation\npublic class BitwaskingTechniques {\n\n    // Check if subset represented by mask has target sum\n    public boolean hasSubsetSum(int[] arr, int mask, int targetSum) {\n        int sum = 0;\n        for (int i = 0; i < arr.length; i++) {\n            if ((mask & (1 << i)) != 0) {\n                sum += arr[i];\n            }\n        }\n        return sum == targetSum;\n    }\n\n    // Find all subsets with given sum using bitmask\n    public List<List<Integer>> findSubsetsWithSum(int[] arr, int targetSum) {\n        List<List<Integer>> result = new ArrayList<>();\n        int n = arr.length;\n\n        // Check all possible subsets\n        for (int mask = 0; mask < (1 << n); mask++) {\n            if (hasSubsetSum(arr, mask, targetSum)) {\n                List<Integer> subset = new ArrayList<>();\n                for (int i = 0; i < n; i++) {\n                    if ((mask & (1 << i)) != 0) {\n                        subset.add(arr[i]);\n                    }\n                }\n                result.add(subset);\n            }\n        }\n\n        return result;\n    }\n\n    // Count number of ways to partition set into k non-empty subsets\n    public int countPartitions(int n, int k) {\n        // dp[mask][groups] = number of ways to partition elements in mask into groups subsets\n        int[][] dp = new int[1 << n][k + 1];\n        dp[0][0] = 1;\n\n        for (int mask = 0; mask < (1 << n); mask++) {\n            for (int groups = 0; groups <= k; groups++) {\n                if (dp[mask][groups] == 0) continue;\n\n                // Try adding a new subset\n                for (int subset = mask; subset < (1 << n); subset = (subset + 1) | mask) {\n                    if (groups < k) {\n                        dp[subset][groups + 1] += dp[mask][groups];\n                    }\n                }\n            }\n        }\n\n        return dp[(1 << n) - 1][k];\n    }\n\n    // Traveling Salesman Problem using bitmask DP\n    public int tsp(int[][] dist) {\n        int n = dist.length;\n        int[][] dp = new int[1 << n][n];\n\n        // Initialize with infinity\n        for (int[] row : dp) {\n            Arrays.fill(row, Integer.MAX_VALUE);\n        }\n\n        dp[1][0] = 0; // Start from city 0\n\n        for (int mask = 0; mask < (1 << n); mask++) {\n            for (int u = 0; u < n; u++) {\n                if ((mask & (1 << u)) == 0 || dp[mask][u] == Integer.MAX_VALUE) {\n                    continue;\n                }\n\n                for (int v = 0; v < n; v++) {\n                    if (mask & (1 << v)) continue;\n\n                    int newMask = mask | (1 << v);\n                    dp[newMask][v] = Math.min(dp[newMask][v], dp[mask][u] + dist[u][v]);\n                }\n            }\n        }\n\n        int result = Integer.MAX_VALUE;\n        for (int i = 1; i < n; i++) {\n            if (dp[(1 << n) - 1][i] != Integer.MAX_VALUE) {\n                result = Math.min(result, dp[(1 << n) - 1][i] + dist[i][0]);\n            }\n        }\n\n        return result;\n    }\n\n    // Assignment problem using bitmask\n    public int minCostAssignment(int[][] cost) {\n        int n = cost.length;\n        int[] dp = new int[1 << n];\n        Arrays.fill(dp, Integer.MAX_VALUE);\n        dp[0] = 0;\n\n        for (int mask = 0; mask < (1 << n); mask++) {\n            if (dp[mask] == Integer.MAX_VALUE) continue;\n\n            int person = Integer.bitCount(mask);\n            if (person >= n) continue;\n\n            for (int task = 0; task < n; task++) {\n                if ((mask & (1 << task)) == 0) {\n                    int newMask = mask | (1 << task);\n                    dp[newMask] = Math.min(dp[newMask], dp[mask] + cost[person][task]);\n                }\n            }\n        }\n\n        return dp[(1 << n) - 1];\n    }\n\n    // Check if two sets represented by bitmasks are disjoint\n    public boolean areDisjoint(int mask1, int mask2) {\n        return (mask1 & mask2) == 0;\n    }\n\n    // Get complement of a set in universal set\n    public int getComplement(int mask, int universeSize) {\n        return ((1 << universeSize) - 1) ^ mask;\n    }\n\n    // Get all subsets of a given set\n    public List<Integer> getAllSubsets(int mask) {\n        List<Integer> subsets = new ArrayList<>();\n\n        for (int subset = mask; ; subset = (subset - 1) & mask) {\n            subsets.add(subset);\n            if (subset == 0) break;\n        }\n\n        return subsets;\n    }\n\n    // Check if one set is subset of another\n    public boolean isSubset(int subset, int superset) {\n        return (subset & superset) == subset;\n    }\n}\n"})}),"\n",(0,e.jsx)(i.h3,{id:"62-advanced-bitmasking-applications",children:"6.2 Advanced Bitmasking Applications"}),"\n",(0,e.jsx)(i.pre,{children:(0,e.jsx)(i.code,{className:"language-java",children:"// Advanced bitmasking for complex problems\npublic class AdvancedBitmasking {\n\n    // Maximum subset XOR\n    public int maxSubsetXOR(int[] arr) {\n        int maxXOR = 0;\n        int n = arr.length;\n\n        // Try all possible subsets\n        for (int mask = 1; mask < (1 << n); mask++) {\n            int xor = 0;\n            for (int i = 0; i < n; i++) {\n                if ((mask & (1 << i)) != 0) {\n                    xor ^= arr[i];\n                }\n            }\n            maxXOR = Math.max(maxXOR, xor);\n        }\n\n        return maxXOR;\n    }\n\n    // Count number of subsets with XOR equal to target\n    public int countSubsetsWithXOR(int[] arr, int target) {\n        int count = 0;\n        int n = arr.length;\n\n        for (int mask = 0; mask < (1 << n); mask++) {\n            int xor = 0;\n            for (int i = 0; i < n; i++) {\n                if ((mask & (1 << i)) != 0) {\n                    xor ^= arr[i];\n                }\n            }\n            if (xor == target) {\n                count++;\n            }\n        }\n\n        return count;\n    }\n\n    // Shortest Hamiltonian path using bitmask DP\n    public int shortestHamiltonianPath(int[][] graph) {\n        int n = graph.length;\n        int[][] dp = new int[1 << n][n];\n\n        for (int[] row : dp) {\n            Arrays.fill(row, Integer.MAX_VALUE);\n        }\n\n        // Can start from any node\n        for (int i = 0; i < n; i++) {\n            dp[1 << i][i] = 0;\n        }\n\n        for (int mask = 0; mask < (1 << n); mask++) {\n            for (int u = 0; u < n; u++) {\n                if ((mask & (1 << u)) == 0 || dp[mask][u] == Integer.MAX_VALUE) {\n                    continue;\n                }\n\n                for (int v = 0; v < n; v++) {\n                    if ((mask & (1 << v)) != 0 || graph[u][v] == 0) {\n                        continue;\n                    }\n\n                    int newMask = mask | (1 << v);\n                    dp[newMask][v] = Math.min(dp[newMask][v], dp[mask][u] + graph[u][v]);\n                }\n            }\n        }\n\n        int result = Integer.MAX_VALUE;\n        for (int i = 0; i < n; i++) {\n            result = Math.min(result, dp[(1 << n) - 1][i]);\n        }\n\n        return result == Integer.MAX_VALUE ? -1 : result;\n    }\n\n    // Count number of ways to color graph with k colors (bitmask DP)\n    public int countGraphColorings(int[][] graph, int k) {\n        int n = graph.length;\n        // dp[mask][color] = ways to color vertices in mask with last vertex having color\n        int[][] dp = new int[1 << n][k];\n\n        // Base case: single vertex can be colored in k ways\n        for (int i = 0; i < n; i++) {\n            for (int color = 0; color < k; color++) {\n                dp[1 << i][color] = 1;\n            }\n        }\n\n        for (int mask = 1; mask < (1 << n); mask++) {\n            int vertices = Integer.bitCount(mask);\n            if (vertices == 1) continue;\n\n            for (int lastVertex = 0; lastVertex < n; lastVertex++) {\n                if ((mask & (1 << lastVertex)) == 0) continue;\n\n                int prevMask = mask ^ (1 << lastVertex);\n\n                for (int color = 0; color < k; color++) {\n                    // Check if this color conflicts with adjacent vertices\n                    boolean canUseColor = true;\n                    for (int adj = 0; adj < n; adj++) {\n                        if ((mask & (1 << adj)) != 0 && graph[lastVertex][adj] == 1) {\n                            // Adjacent vertex exists in current mask\n                            if (adj != lastVertex) {\n                                // We need to ensure adjacent vertex doesn't have same color\n                                // This is handled by considering all valid colorings of previous mask\n                            }\n                        }\n                    }\n\n                    if (canUseColor) {\n                        for (int prevColor = 0; prevColor < k; prevColor++) {\n                            // Check if prevColor conflicts with current color for adjacent vertices\n                            boolean valid = true;\n                            for (int adj = 0; adj < n; adj++) {\n                                if ((prevMask & (1 << adj)) != 0 && graph[lastVertex][adj] == 1 &&\n                                    prevColor == color) {\n                                    valid = false;\n                                    break;\n                                }\n                            }\n\n                            if (valid) {\n                                dp[mask][color] += dp[prevMask][prevColor];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        int result = 0;\n        for (int color = 0; color < k; color++) {\n            result += dp[(1 << n) - 1][color];\n        }\n\n        return result;\n    }\n}\n"})}),"\n",(0,e.jsx)(i.hr,{}),"\n",(0,e.jsx)(i.h2,{id:"pattern-7-xor-based-problems",children:"Pattern 7: XOR-Based Problems"}),"\n",(0,e.jsx)(i.h3,{id:"71-xor-properties-and-applications",children:"7.1 XOR Properties and Applications"}),"\n",(0,e.jsx)(i.pre,{children:(0,e.jsx)(i.code,{className:"language-java",children:'// XOR-based problem solving\npublic class XORProblems {\n\n    // Find missing number using XOR\n    public int findMissingNumber(int[] arr, int n) {\n        int xor1 = 0; // XOR of all elements in array\n        int xor2 = 0; // XOR of all numbers from 1 to n+1\n\n        for (int num : arr) {\n            xor1 ^= num;\n        }\n\n        for (int i = 1; i <= n + 1; i++) {\n            xor2 ^= i;\n        }\n\n        return xor1 ^ xor2;\n    }\n\n    // Swap two numbers without temporary variable\n    public void swapNumbers(int a, int b) {\n        System.out.println("Before: a = " + a + ", b = " + b);\n\n        if (a != b) { // Avoid swapping same memory location\n            a = a ^ b;\n            b = a ^ b;\n            a = a ^ b;\n        }\n\n        System.out.println("After: a = " + a + ", b = " + b);\n    }\n\n    // Find two non-repeating elements in array\n    public int[] findTwoNonRepeating(int[] arr) {\n        int xor = 0;\n\n        // XOR all elements\n        for (int num : arr) {\n            xor ^= num;\n        }\n\n        // Find rightmost set bit\n        int rightmostSetBit = xor & (-xor);\n\n        int first = 0, second = 0;\n\n        // Divide elements into two groups\n        for (int num : arr) {\n            if ((num & rightmostSetBit) != 0) {\n                first ^= num;\n            } else {\n                second ^= num;\n            }\n        }\n\n        return new int[]{first, second};\n    }\n\n    // Maximum XOR of two numbers in array\n    public int findMaximumXOR(int[] nums) {\n        int maxXOR = 0;\n        int mask = 0;\n\n        // Build prefix mask bit by bit\n        for (int i = 30; i >= 0; i--) {\n            mask |= (1 << i);\n            Set<Integer> prefixes = new HashSet<>();\n\n            // Get all prefixes with current mask\n            for (int num : nums) {\n                prefixes.add(num & mask);\n            }\n\n            int candidate = maxXOR | (1 << i);\n\n            // Check if candidate is achievable\n            for (int prefix : prefixes) {\n                if (prefixes.contains(candidate ^ prefix)) {\n                    maxXOR = candidate;\n                    break;\n                }\n            }\n        }\n\n        return maxXOR;\n    }\n\n    // Count pairs with given XOR\n    public int countPairsWithXOR(int[] arr, int k) {\n        Map<Integer, Integer> freq = new HashMap<>();\n        int count = 0;\n\n        for (int num : arr) {\n            int complement = num ^ k;\n            if (freq.containsKey(complement)) {\n                count += freq.get(complement);\n            }\n            freq.put(num, freq.getOrDefault(num, 0) + 1);\n        }\n\n        return count;\n    }\n\n    // XOR of all subarrays\n    public int xorOfAllSubarrays(int[] arr) {\n        int n = arr.length;\n        int result = 0;\n\n        for (int i = 0; i < n; i++) {\n            // Count frequency of arr[i] in all subarrays\n            int frequency = (i + 1) * (n - i);\n\n            // If frequency is odd, include arr[i] in result\n            if (frequency % 2 == 1) {\n                result ^= arr[i];\n            }\n        }\n\n        return result;\n    }\n\n    // Find XOR from L to R\n    public int xorInRange(int l, int r) {\n        return xorFromZero(r) ^ xorFromZero(l - 1);\n    }\n\n    private int xorFromZero(int n) {\n        if (n < 0) return 0;\n\n        int remainder = n % 4;\n        switch (remainder) {\n            case 0: return n;\n            case 1: return 1;\n            case 2: return n + 1;\n            case 3: return 0;\n            default: return 0;\n        }\n    }\n\n    // Check if array can be divided into pairs with equal XOR\n    public boolean canDivideIntoPairs(int[] arr) {\n        int xor = 0;\n        for (int num : arr) {\n            xor ^= num;\n        }\n        return xor == 0;\n    }\n\n    // Minimum XOR subarray\n    public int minXORSubarray(int[] arr) {\n        int n = arr.length;\n        int minXOR = Integer.MAX_VALUE;\n\n        // Try all subarrays\n        for (int i = 0; i < n; i++) {\n            int xor = 0;\n            for (int j = i; j < n; j++) {\n                xor ^= arr[j];\n                minXOR = Math.min(minXOR, xor);\n            }\n        }\n\n        return minXOR;\n    }\n\n    // Count subarrays with XOR equal to k\n    public int countSubarraysWithXOR(int[] arr, int k) {\n        Map<Integer, Integer> prefixXORCount = new HashMap<>();\n        prefixXORCount.put(0, 1);\n\n        int count = 0;\n        int xor = 0;\n\n        for (int num : arr) {\n            xor ^= num;\n\n            if (prefixXORCount.containsKey(xor ^ k)) {\n                count += prefixXORCount.get(xor ^ k);\n            }\n\n            prefixXORCount.put(xor, prefixXORCount.getOrDefault(xor, 0) + 1);\n        }\n\n        return count;\n    }\n}\n'})}),"\n",(0,e.jsx)(i.hr,{}),"\n",(0,e.jsx)(i.h2,{id:"pattern-8-bit-shifting-patterns",children:"Pattern 8: Bit Shifting Patterns"}),"\n",(0,e.jsx)(i.h3,{id:"81-left-and-right-shift-operations8",children:"8.1 Left and Right Shift Operations[8]"}),"\n",(0,e.jsx)(i.pre,{children:(0,e.jsx)(i.code,{className:"language-java",children:"// Bit shifting operations and applications\npublic class BitShiftingPatterns {\n\n    // Multiply by power of 2 using left shift\n    public int multiplyByPowerOf2(int num, int power) {\n        return num << power; // num * (2^power)\n    }\n\n    // Divide by power of 2 using right shift\n    public int divideByPowerOf2(int num, int power) {\n        return num >> power; // num / (2^power)\n    }\n\n    // Check if number is divisible by power of 2\n    public boolean isDivisibleByPowerOf2(int num, int power) {\n        int divisor = 1 << power;\n        return (num & (divisor - 1)) == 0;\n    }\n\n    // Rotate bits left\n    public int rotateLeft(int num, int positions) {\n        positions %= 32; // Handle positions > 32\n        return (num << positions) | (num >>> (32 - positions));\n    }\n\n    // Rotate bits right\n    public int rotateRight(int num, int positions) {\n        positions %= 32;\n        return (num >>> positions) | (num << (32 - positions));\n    }\n\n    // Extract bits from position i to j\n    public int extractBits(int num, int i, int j) {\n        // Shift right to bring bits to least significant positions\n        int shifted = num >> i;\n\n        // Create mask for j-i+1 bits\n        int mask = (1 << (j - i + 1)) - 1;\n\n        return shifted & mask;\n    }\n\n    // Set bits from position i to j with given value\n    public int setBitsInRange(int num, int value, int i, int j) {\n        // Create mask to clear bits from i to j\n        int allOnes = ~0;\n        int left = allOnes << (j + 1);\n        int right = (1 << i) - 1;\n        int mask = left | right;\n\n        // Clear bits and set new value\n        return (num & mask) | (value << i);\n    }\n\n    // Arithmetic right shift (preserves sign)\n    public int arithmeticRightShift(int num, int positions) {\n        return num >> positions;\n    }\n\n    // Logical right shift (fills with zeros)\n    public int logicalRightShift(int num, int positions) {\n        return num >>> positions;\n    }\n\n    // Efficient modulo operation for powers of 2\n    public int modPowerOf2(int num, int power) {\n        int mask = (1 << power) - 1;\n        return num & mask; // Equivalent to num % (2^power)\n    }\n\n    // Check if shifting causes overflow\n    public boolean willLeftShiftOverflow(int num, int positions) {\n        if (positions >= 32) return true;\n\n        // Check if any bit in the top 'positions' bits is set\n        int mask = ~((1 << (32 - positions)) - 1);\n        return (num & mask) != 0;\n    }\n\n    // Circular shift left with overflow detection\n    public int circularShiftLeft(int num, int positions) {\n        positions %= 32;\n        return (num << positions) | (num >>> (32 - positions));\n    }\n\n    // Count number of positions to shift to make number odd\n    public int shiftToMakeOdd(int num) {\n        if (num == 0) return -1; // Cannot make 0 odd\n\n        int shifts = 0;\n        while ((num & 1) == 0) {\n            num >>= 1;\n            shifts++;\n        }\n\n        return shifts;\n    }\n\n    // Binary search using bit shifting\n    public int binarySearchWithShifting(int[] arr, int target) {\n        int left = 0;\n        int right = arr.length - 1;\n\n        while (left <= right) {\n            int mid = left + ((right - left) >> 1); // (left + right) / 2\n\n            if (arr[mid] == target) {\n                return mid;\n            } else if (arr[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n        return -1;\n    }\n\n    // Fast multiplication using bit shifting\n    public int fastMultiply(int a, int b) {\n        int result = 0;\n\n        while (b > 0) {\n            if ((b & 1) == 1) {\n                result += a;\n            }\n            a <<= 1; // a = a * 2\n            b >>= 1; // b = b / 2\n        }\n\n        return result;\n    }\n\n    // Generate powers of 2 using shifting\n    public List<Integer> generatePowersOf2(int maxPower) {\n        List<Integer> powers = new ArrayList<>();\n\n        for (int i = 0; i <= maxPower; i++) {\n            powers.add(1 << i);\n        }\n\n        return powers;\n    }\n}\n"})}),"\n",(0,e.jsx)(i.h3,{id:"82-advanced-shifting-applications",children:"8.2 Advanced Shifting Applications"}),"\n",(0,e.jsx)(i.pre,{children:(0,e.jsx)(i.code,{className:"language-java",children:'// Advanced applications of bit shifting\npublic class AdvancedShiftingApplications {\n\n    // Efficient square root using bit shifting\n    public int integerSquareRoot(int n) {\n        if (n < 2) return n;\n\n        int x = n;\n\n        // Newton\'s method with bit shifting optimization\n        while (x > n / x) {\n            x = (x + n / x) >> 1; // Divide by 2 using right shift\n        }\n\n        return x;\n    }\n\n    // Fast integer division using bit shifting\n    public int fastDivide(int dividend, int divisor) {\n        if (divisor == 0) throw new ArithmeticException("Division by zero");\n\n        boolean negative = (dividend < 0) ^ (divisor < 0);\n\n        long absDividend = Math.abs((long) dividend);\n        long absDivisor = Math.abs((long) divisor);\n\n        long result = 0;\n\n        while (absDividend >= absDivisor) {\n            long temp = absDivisor;\n            long count = 1;\n\n            while (absDividend >= (temp << 1)) {\n                temp <<= 1;\n                count <<= 1;\n            }\n\n            absDividend -= temp;\n            result += count;\n        }\n\n        if (negative) result = -result;\n\n        return (int) Math.max(Integer.MIN_VALUE, Math.min(Integer.MAX_VALUE, result));\n    }\n\n    // Check if number is power of 4 using shifting\n    public boolean isPowerOfFour(int n) {\n        return n > 0 && (n & (n - 1)) == 0 && (n & 0x55555555) != 0;\n    }\n\n    // Convert decimal to binary using shifting\n    public String decimalToBinaryShifting(int n) {\n        if (n == 0) return "0";\n\n        StringBuilder binary = new StringBuilder();\n\n        while (n > 0) {\n            binary.append(n & 1);\n            n >>= 1;\n        }\n\n        return binary.reverse().toString();\n    }\n\n    // Find log base 2 using bit shifting\n    public int log2(int n) {\n        if (n <= 0) return -1;\n\n        int log = 0;\n        while ((n >>= 1) > 0) {\n            log++;\n        }\n\n        return log;\n    }\n\n    // Ceiling of log base 2\n    public int ceilLog2(int n) {\n        if (n <= 1) return 0;\n\n        int log = log2(n);\n\n        // If n is power of 2, return log, otherwise log + 1\n        return isPowerOfTwo(n) ? log : log + 1;\n    }\n\n    private boolean isPowerOfTwo(int n) {\n        return n > 0 && (n & (n - 1)) == 0;\n    }\n\n    // Efficient GCD using bit shifting\n    public int gcdBitShifting(int a, int b) {\n        if (a == 0) return b;\n        if (b == 0) return a;\n\n        // Count common factors of 2\n        int shift = 0;\n        while (((a | b) & 1) == 0) {\n            a >>= 1;\n            b >>= 1;\n            shift++;\n        }\n\n        // Remove factors of 2 from a\n        while ((a & 1) == 0) {\n            a >>= 1;\n        }\n\n        do {\n            // Remove factors of 2 from b\n            while ((b & 1) == 0) {\n                b >>= 1;\n            }\n\n            // Ensure a <= b\n            if (a > b) {\n                int temp = a;\n                a = b;\n                b = temp;\n            }\n\n            b -= a;\n        } while (b != 0);\n\n        return a << shift;\n    }\n\n    // Count set bits using shifting\n    public int countSetBitsShifting(int n) {\n        int count = 0;\n\n        while (n != 0) {\n            count += n & 1;\n            n >>= 1;\n        }\n\n        return count;\n    }\n\n    // Generate Gray code using bit shifting\n    public List<Integer> generateGrayCode(int n) {\n        List<Integer> grayCode = new ArrayList<>();\n\n        for (int i = 0; i < (1 << n); i++) {\n            grayCode.add(i ^ (i >> 1));\n        }\n\n        return grayCode;\n    }\n\n    // Reverse Gray code\n    public int reverseGrayCode(int gray) {\n        int binary = 0;\n        while (gray != 0) {\n            binary ^= gray;\n            gray >>= 1;\n        }\n        return binary;\n    }\n}\n'})}),"\n",(0,e.jsx)(i.hr,{}),"\n",(0,e.jsx)(i.h2,{id:"pattern-9-gray-code--binary-representation",children:"Pattern 9: Gray Code & Binary Representation"}),"\n",(0,e.jsx)(i.h3,{id:"91-gray-code-generation-and-properties",children:"9.1 Gray Code Generation and Properties"}),"\n",(0,e.jsx)(i.pre,{children:(0,e.jsx)(i.code,{className:"language-java",children:'// Gray code operations and binary representations\npublic class GrayCodeOperations {\n\n    // Generate Gray code sequence for n bits\n    public List<Integer> grayCode(int n) {\n        List<Integer> result = new ArrayList<>();\n\n        for (int i = 0; i < (1 << n); i++) {\n            result.add(i ^ (i >> 1)); // Convert binary to Gray code\n        }\n\n        return result;\n    }\n\n    // Generate Gray code as binary strings\n    public List<String> grayCodeStrings(int n) {\n        List<String> result = new ArrayList<>();\n\n        for (int i = 0; i < (1 << n); i++) {\n            int gray = i ^ (i >> 1);\n            String binaryString = String.format("%" + n + "s",\n                Integer.toBinaryString(gray)).replace(\' \', \'0\');\n            result.add(binaryString);\n        }\n\n        return result;\n    }\n\n    // Convert binary to Gray code\n    public int binaryToGray(int binary) {\n        return binary ^ (binary >> 1);\n    }\n\n    // Convert Gray code to binary\n    public int grayToBinary(int gray) {\n        int binary = 0;\n\n        while (gray != 0) {\n            binary ^= gray;\n            gray >>= 1;\n        }\n\n        return binary;\n    }\n\n    // Generate Gray code using recursive approach\n    public List<String> grayCodeRecursive(int n) {\n        if (n == 0) {\n            return Arrays.asList("");\n        }\n\n        if (n == 1) {\n            return Arrays.asList("0", "1");\n        }\n\n        List<String> prevGrayCode = grayCodeRecursive(n - 1);\n        List<String> result = new ArrayList<>();\n\n        // First half: add \'0\' prefix to previous Gray codes\n        for (String code : prevGrayCode) {\n            result.add("0" + code);\n        }\n\n        // Second half: add \'1\' prefix to reversed previous Gray codes\n        for (int i = prevGrayCode.size() - 1; i >= 0; i--) {\n            result.add("1" + prevGrayCode.get(i));\n        }\n\n        return result;\n    }\n\n    // Find position of difference between consecutive Gray codes\n    public int findGrayCodeDifference(int gray1, int gray2) {\n        int diff = gray1 ^ gray2;\n\n        // Find position of the single set bit\n        return Integer.numberOfTrailingZeros(diff);\n    }\n\n    // Check if two numbers are consecutive in Gray code sequence\n    public boolean areConsecutiveGrayCodes(int a, int b) {\n        // Convert to Gray codes and check if they differ by exactly one bit\n        int grayA = binaryToGray(a);\n        int grayB = binaryToGray(b);\n        int diff = grayA ^ grayB;\n\n        // Check if diff is power of 2 (exactly one bit set)\n        return diff > 0 && (diff & (diff - 1)) == 0;\n    }\n\n    // Generate balanced Gray code (equal number of 0s and 1s in each position)\n    public List<String> balancedGrayCode(int n) {\n        // This is only possible for even n\n        if (n % 2 != 0) {\n            throw new IllegalArgumentException("Balanced Gray code requires even number of bits");\n        }\n\n        List<String> result = new ArrayList<>();\n        // Implementation would be more complex for true balanced Gray code\n        // This is a simplified version\n        return grayCodeStrings(n);\n    }\n\n    // Count transitions in Gray code sequence\n    public int countGrayCodeTransitions(int n) {\n        // Each transition changes exactly one bit\n        return (1 << n) - 1; // 2^n - 1 transitions for n-bit Gray code\n    }\n\n    // Generate modified Gray code with custom starting point\n    public List<Integer> customGrayCode(int n, int start) {\n        List<Integer> standardGray = grayCode(n);\n        List<Integer> result = new ArrayList<>();\n\n        // Find starting position\n        int startPos = standardGray.indexOf(start);\n        if (startPos == -1) {\n            throw new IllegalArgumentException("Invalid starting point");\n        }\n\n        // Rotate the sequence\n        for (int i = 0; i < standardGray.size(); i++) {\n            result.add(standardGray.get((i + startPos) % standardGray.size()));\n        }\n\n        return result;\n    }\n\n    // Check if a sequence follows Gray code property\n    public boolean isValidGrayCodeSequence(List<Integer> sequence) {\n        for (int i = 1; i < sequence.size(); i++) {\n            int diff = sequence.get(i - 1) ^ sequence.get(i);\n\n            // Check if exactly one bit is different\n            if (diff == 0 || (diff & (diff - 1)) != 0) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    // Find next Gray code in sequence\n    public int nextGrayCode(int current, int n) {\n        List<Integer> graySequence = grayCode(n);\n        int currentIndex = graySequence.indexOf(current);\n\n        if (currentIndex == -1) {\n            throw new IllegalArgumentException("Invalid Gray code");\n        }\n\n        return graySequence.get((currentIndex + 1) % graySequence.size());\n    }\n}\n'})}),"\n",(0,e.jsx)(i.h3,{id:"92-binary-representation-utilities",children:"9.2 Binary Representation Utilities"}),"\n",(0,e.jsx)(i.pre,{children:(0,e.jsx)(i.code,{className:"language-java",children:"// Binary representation and manipulation utilities\npublic class BinaryRepresentationUtils {\n\n    // Get binary representation with leading zeros\n    public String toBinaryString(int num, int width) {\n        String binary = Integer.toBinaryString(num);\n        return String.format(\"%\" + width + \"s\", binary).replace(' ', '0');\n    }\n\n    // Convert signed integer to binary (two's complement)\n    public String signedToBinary(int num) {\n        if (num >= 0) {\n            return toBinaryString(num, 32);\n        } else {\n            // For negative numbers, Java's toBinaryString already gives two's complement\n            return Integer.toBinaryString(num);\n        }\n    }\n\n    // Parse binary string to integer\n    public int parseBinary(String binary) {\n        return Integer.parseInt(binary, 2);\n    }\n\n    // Count hamming distance between two numbers\n    public int hammingDistance(int x, int y) {\n        return Integer.bitCount(x ^ y);\n    }\n\n    // Total hamming distance for all pairs in array\n    public int totalHammingDistance(int[] nums) {\n        int total = 0;\n        int n = nums.length;\n\n        // For each bit position\n        for (int i = 0; i < 32; i++) {\n            int countOnes = 0;\n\n            // Count how many numbers have bit i set\n            for (int num : nums) {\n                if ((num & (1 << i)) != 0) {\n                    countOnes++;\n                }\n            }\n\n            // Hamming distance contribution for bit i\n            total += countOnes * (n - countOnes);\n        }\n\n        return total;\n    }\n\n    // Check if binary representation is palindrome\n    public boolean isBinaryPalindrome(int num) {\n        String binary = Integer.toBinaryString(num);\n        String reversed = new StringBuilder(binary).reverse().toString();\n        return binary.equals(reversed);\n    }\n\n    // Find longest run of 1s in binary representation\n    public int longestRunOfOnes(int num) {\n        int maxRun = 0;\n        int currentRun = 0;\n\n        while (num != 0) {\n            if ((num & 1) == 1) {\n                currentRun++;\n                maxRun = Math.max(maxRun, currentRun);\n            } else {\n                currentRun = 0;\n            }\n            num >>= 1;\n        }\n\n        return maxRun;\n    }\n\n    // Find longest run of 0s in binary representation\n    public int longestRunOfZeros(int num) {\n        // Invert the number and find longest run of 1s\n        return longestRunOfOnes(~num);\n    }\n\n    // Count number of bit flips needed to convert a to b\n    public int bitFlipsToConvert(int a, int b) {\n        return Integer.bitCount(a ^ b);\n    }\n\n    // Generate all binary strings of length n\n    public List<String> generateBinaryStrings(int n) {\n        List<String> result = new ArrayList<>();\n\n        for (int i = 0; i < (1 << n); i++) {\n            result.add(toBinaryString(i, n));\n        }\n\n        return result;\n    }\n\n    // Generate all binary strings with exactly k ones\n    public List<String> generateBinaryStringsWithKOnes(int n, int k) {\n        List<String> result = new ArrayList<>();\n\n        for (int i = 0; i < (1 << n); i++) {\n            if (Integer.bitCount(i) == k) {\n                result.add(toBinaryString(i, n));\n            }\n        }\n\n        return result;\n    }\n\n    // Check if binary string has alternating pattern\n    public boolean hasAlternatingPattern(String binary) {\n        for (int i = 1; i < binary.length(); i++) {\n            if (binary.charAt(i) == binary.charAt(i - 1)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // Generate next lexicographic binary string\n    public String nextBinaryString(String binary) {\n        int num = parseBinary(binary);\n        num++;\n        return toBinaryString(num, binary.length());\n    }\n\n    // Find binary string with maximum decimal value using k flips\n    public String maxBinaryWithKFlips(String binary, int k) {\n        char[] chars = binary.toCharArray();\n\n        for (int i = 0; i < chars.length && k > 0; i++) {\n            if (chars[i] == '0') {\n                chars[i] = '1';\n                k--;\n            }\n        }\n\n        // If k is still positive and even, we can flip back and forth\n        // If k is odd, flip the rightmost 1 to 0\n        if (k > 0 && k % 2 == 1) {\n            for (int i = chars.length - 1; i >= 0; i--) {\n                if (chars[i] == '1') {\n                    chars[i] = '0';\n                    break;\n                }\n            }\n        }\n\n        return new String(chars);\n    }\n}\n"})}),"\n",(0,e.jsx)(i.hr,{}),"\n",(0,e.jsx)(i.h2,{id:"pattern-10-advanced-bit-manipulation",children:"Pattern 10: Advanced Bit Manipulation"}),"\n",(0,e.jsx)(i.h3,{id:"101-complex-bit-operations",children:"10.1 Complex Bit Operations"}),"\n",(0,e.jsx)(i.pre,{children:(0,e.jsx)(i.code,{className:"language-java",children:"// Advanced bit manipulation techniques\npublic class AdvancedBitManipulation {\n\n    // Sparse number operations\n    public int nextSparseNumber(int n) {\n        // A sparse number has no two adjacent bits set\n        List<Integer> binary = new ArrayList<>();\n\n        // Convert to binary array\n        while (n > 0) {\n            binary.add(n & 1);\n            n >>= 1;\n        }\n\n        // Scan from second bit to check for adjacent 1s\n        for (int i = 1; i < binary.size(); i++) {\n            if (binary.get(i) == 1 && binary.get(i - 1) == 1) {\n                // Found adjacent 1s\n                // Make all bits after position i equal to 0\n                for (int j = 0; j < i; j++) {\n                    binary.set(j, 0);\n                }\n\n                // Find next position to set\n                int pos = i;\n                while (pos < binary.size() && binary.get(pos) == 1) {\n                    binary.set(pos, 0);\n                    pos++;\n                }\n\n                if (pos == binary.size()) {\n                    binary.add(1);\n                } else {\n                    binary.set(pos, 1);\n                }\n\n                break;\n            }\n        }\n\n        // Convert back to decimal\n        int result = 0;\n        for (int i = 0; i < binary.size(); i++) {\n            result += binary.get(i) * (1 << i);\n        }\n\n        return result;\n    }\n\n    // Check if number has alternating bits\n    public boolean hasAlternatingBits(int n) {\n        int prev = n & 1;\n        n >>= 1;\n\n        while (n > 0) {\n            int curr = n & 1;\n            if (curr == prev) {\n                return false;\n            }\n            prev = curr;\n            n >>= 1;\n        }\n\n        return true;\n    }\n\n    // Binary string with substrings representing 1 to N\n    public String binaryStringWithSubstrings(int n) {\n        // This is a complex problem - simplified implementation\n        StringBuilder sb = new StringBuilder();\n\n        for (int i = 1; i <= n; i++) {\n            String binary = Integer.toBinaryString(i);\n            if (sb.length() == 0 || sb.indexOf(binary) == -1) {\n                sb.append(binary);\n            }\n        }\n\n        return sb.toString();\n    }\n\n    // Minimum number of flips to make binary string alternating\n    public int minFlipsToAlternating(String s) {\n        int flips1 = 0; // Starting with '0'\n        int flips2 = 0; // Starting with '1'\n\n        for (int i = 0; i < s.length(); i++) {\n            char expected1 = (i % 2 == 0) ? '0' : '1';\n            char expected2 = (i % 2 == 0) ? '1' : '0';\n\n            if (s.charAt(i) != expected1) flips1++;\n            if (s.charAt(i) != expected2) flips2++;\n        }\n\n        return Math.min(flips1, flips2);\n    }\n\n    // Count number of 1 bits you need to flip to get longest sequence of 1s\n    public int findLengthWithFlip(int num, int flips) {\n        int left = 0, right = 0;\n        int zerosCount = 0;\n        int maxLength = 0;\n\n        // Convert to binary array for easier processing\n        List<Integer> bits = new ArrayList<>();\n        int temp = num;\n        while (temp > 0) {\n            bits.add(temp & 1);\n            temp >>= 1;\n        }\n        Collections.reverse(bits);\n\n        while (right < bits.size()) {\n            if (bits.get(right) == 0) {\n                zerosCount++;\n            }\n\n            while (zerosCount > flips) {\n                if (bits.get(left) == 0) {\n                    zerosCount--;\n                }\n                left++;\n            }\n\n            maxLength = Math.max(maxLength, right - left + 1);\n            right++;\n        }\n\n        return maxLength;\n    }\n\n    // Bitwise AND of range [left, right]\n    public int rangeBitwiseAnd(int left, int right) {\n        int shift = 0;\n\n        // Find common prefix\n        while (left != right) {\n            left >>= 1;\n            right >>= 1;\n            shift++;\n        }\n\n        return left << shift;\n    }\n\n    // Count number of bit differences in all pairs\n    public int sumOfBitDifferences(int[] arr) {\n        int sum = 0;\n        int n = arr.length;\n\n        // For each bit position\n        for (int i = 0; i < 32; i++) {\n            int count = 0;\n\n            // Count numbers with bit i set\n            for (int num : arr) {\n                if ((num & (1 << i)) != 0) {\n                    count++;\n                }\n            }\n\n            // Add contribution of this bit position\n            sum += count * (n - count) * 2;\n        }\n\n        return sum;\n    }\n\n    // Maximum product of word lengths where words don't share common letters\n    public int maxProduct(String[] words) {\n        int n = words.length;\n        int[] masks = new int[n];\n\n        // Create bit mask for each word\n        for (int i = 0; i < n; i++) {\n            for (char c : words[i].toCharArray()) {\n                masks[i] |= 1 << (c - 'a');\n            }\n        }\n\n        int maxProd = 0;\n\n        // Check all pairs\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if ((masks[i] & masks[j]) == 0) {\n                    maxProd = Math.max(maxProd, words[i].length() * words[j].length());\n                }\n            }\n        }\n\n        return maxProd;\n    }\n\n    // Flip bits to convert A to B\n    public int convertAtoB(int a, int b) {\n        int diff = a ^ b;\n        return Integer.bitCount(diff);\n    }\n\n    // Find complement of number in given range\n    public int findComplement(int num) {\n        // Find number of bits in num\n        int bitLength = Integer.toBinaryString(num).length();\n\n        // Create mask with all 1s of same length\n        int mask = (1 << bitLength) - 1;\n\n        return num ^ mask;\n    }\n}\n"})}),"\n",(0,e.jsx)(i.hr,{}),"\n",(0,e.jsx)(i.h2,{id:"pattern-11-optimization-with-bits",children:"Pattern 11: Optimization with Bits"}),"\n",(0,e.jsx)(i.h3,{id:"111-space-and-time-optimizations",children:"11.1 Space and Time Optimizations"}),"\n",(0,e.jsx)(i.pre,{children:(0,e.jsx)(i.code,{className:"language-java",children:"// Using bit manipulation for optimization\npublic class BitOptimizations {\n\n    // Sieve of Eratosthenes using bit manipulation\n    public List<Integer> sieveOfEratosthenes(int n) {\n        // Use bit array to save space\n        int[] primes = new int[(n + 31) / 32]; // Each int stores 32 bits\n\n        // Set all bits to 1 initially (assume all are prime)\n        Arrays.fill(primes, -1); // All bits set\n\n        // Clear bit for 0 and 1\n        clearBit(primes, 0);\n        clearBit(primes, 1);\n\n        for (int i = 2; i * i <= n; i++) {\n            if (getBit(primes, i)) {\n                for (int j = i * i; j <= n; j += i) {\n                    clearBit(primes, j);\n                }\n            }\n        }\n\n        List<Integer> result = new ArrayList<>();\n        for (int i = 2; i <= n; i++) {\n            if (getBit(primes, i)) {\n                result.add(i);\n            }\n        }\n\n        return result;\n    }\n\n    private boolean getBit(int[] arr, int index) {\n        int intIndex = index / 32;\n        int bitIndex = index % 32;\n        return (arr[intIndex] & (1 << bitIndex)) != 0;\n    }\n\n    private void clearBit(int[] arr, int index) {\n        int intIndex = index / 32;\n        int bitIndex = index % 32;\n        arr[intIndex] &= ~(1 << bitIndex);\n    }\n\n    // Counting sort for small range using bit manipulation\n    public void countingSortBitwise(int[] arr, int maxVal) {\n        // Use bit array for counting\n        int[] count = new int[(maxVal + 31) / 32];\n\n        // Set bits for present elements\n        for (int num : arr) {\n            setBitInArray(count, num);\n        }\n\n        // Reconstruct array\n        int index = 0;\n        for (int i = 0; i <= maxVal; i++) {\n            while (getBitInArray(count, i)) {\n                arr[index++] = i;\n                clearBitInArray(count, i);\n            }\n        }\n    }\n\n    private void setBitInArray(int[] arr, int index) {\n        arr[index / 32] |= (1 << (index % 32));\n    }\n\n    private boolean getBitInArray(int[] arr, int index) {\n        return (arr[index / 32] & (1 << (index % 32))) != 0;\n    }\n\n    private void clearBitInArray(int[] arr, int index) {\n        arr[index / 32] &= ~(1 << (index % 32));\n    }\n\n    // Fast set operations using bit manipulation\n    public static class BitSet {\n        private long[] bits;\n        private int size;\n\n        public BitSet(int maxSize) {\n            this.size = maxSize;\n            this.bits = new long[(maxSize + 63) / 64];\n        }\n\n        public void set(int index) {\n            bits[index / 64] |= (1L << (index % 64));\n        }\n\n        public void clear(int index) {\n            bits[index / 64] &= ~(1L << (index % 64));\n        }\n\n        public boolean get(int index) {\n            return (bits[index / 64] & (1L << (index % 64))) != 0;\n        }\n\n        public BitSet union(BitSet other) {\n            BitSet result = new BitSet(Math.max(this.size, other.size));\n            for (int i = 0; i < result.bits.length; i++) {\n                if (i < this.bits.length && i < other.bits.length) {\n                    result.bits[i] = this.bits[i] | other.bits[i];\n                } else if (i < this.bits.length) {\n                    result.bits[i] = this.bits[i];\n                } else if (i < other.bits.length) {\n                    result.bits[i] = other.bits[i];\n                }\n            }\n            return result;\n        }\n\n        public BitSet intersection(BitSet other) {\n            BitSet result = new BitSet(Math.max(this.size, other.size));\n            for (int i = 0; i < Math.min(this.bits.length, other.bits.length); i++) {\n                result.bits[i] = this.bits[i] & other.bits[i];\n            }\n            return result;\n        }\n\n        public int cardinality() {\n            int count = 0;\n            for (long bit : bits) {\n                count += Long.bitCount(bit);\n            }\n            return count;\n        }\n    }\n\n    // Fast duplicate detection using bit manipulation\n    public boolean hasDuplicates(int[] arr, int maxVal) {\n        if (maxVal >= 32 * 1000000) { // Too large for bit array\n            return hasDuplicatesHashSet(arr);\n        }\n\n        int[] bitArray = new int[(maxVal + 31) / 32];\n\n        for (int num : arr) {\n            if (getBitInArray(bitArray, num)) {\n                return true; // Duplicate found\n            }\n            setBitInArray(bitArray, num);\n        }\n\n        return false;\n    }\n\n    private boolean hasDuplicatesHashSet(int[] arr) {\n        Set<Integer> seen = new HashSet<>();\n        for (int num : arr) {\n            if (!seen.add(num)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // Compress boolean array using bit manipulation\n    public int[] compressBooleanArray(boolean[] boolArray) {\n        int[] compressed = new int[(boolArray.length + 31) / 32];\n\n        for (int i = 0; i < boolArray.length; i++) {\n            if (boolArray[i]) {\n                compressed[i / 32] |= (1 << (i % 32));\n            }\n        }\n\n        return compressed;\n    }\n\n    public boolean[] decompressBooleanArray(int[] compressed, int originalSize) {\n        boolean[] decompressed = new boolean[originalSize];\n\n        for (int i = 0; i < originalSize; i++) {\n            decompressed[i] = (compressed[i / 32] & (1 << (i % 32))) != 0;\n        }\n\n        return decompressed;\n    }\n\n    // Efficient subset enumeration\n    public void enumerateSubsets(int set, Consumer<Integer> processor) {\n        // Enumerate all subsets of 'set'\n        for (int subset = set; ; subset = (subset - 1) & set) {\n            processor.accept(subset);\n            if (subset == 0) break;\n        }\n    }\n\n    // Fast population count for arrays\n    public int totalPopulationCount(int[] arr) {\n        int total = 0;\n        for (int num : arr) {\n            total += Integer.bitCount(num);\n        }\n        return total;\n    }\n}\n"})}),"\n",(0,e.jsx)(i.hr,{}),"\n",(0,e.jsx)(i.h2,{id:"pattern-12-real-world-applications",children:"Pattern 12: Real-World Applications"}),"\n",(0,e.jsx)(i.h3,{id:"121-practical-bit-manipulation-applications",children:"12.1 Practical Bit Manipulation Applications"}),"\n",(0,e.jsx)(i.pre,{children:(0,e.jsx)(i.code,{className:"language-java",children:"// Real-world applications of bit manipulation\npublic class RealWorldBitApplications {\n\n    // File permission system (Unix-style)\n    public static class FilePermissions {\n        private int permissions;\n\n        // Permission constants\n        public static final int OWNER_READ = 1 << 8;    // 400\n        public static final int OWNER_WRITE = 1 << 7;   // 200\n        public static final int OWNER_EXECUTE = 1 << 6; // 100\n        public static final int GROUP_READ = 1 << 5;    // 040\n        public static final int GROUP_WRITE = 1 << 4;   // 020\n        public static final int GROUP_EXECUTE = 1 << 3; // 010\n        public static final int OTHER_READ = 1 << 2;    // 004\n        public static final int OTHER_WRITE = 1 << 1;   // 002\n        public static final int OTHER_EXECUTE = 1;      // 001\n\n        public FilePermissions(int permissions) {\n            this.permissions = permissions;\n        }\n\n        public boolean hasPermission(int permission) {\n            return (permissions & permission) != 0;\n        }\n\n        public void grantPermission(int permission) {\n            permissions |= permission;\n        }\n\n        public void revokePermission(int permission) {\n            permissions &= ~permission;\n        }\n\n        public String toOctalString() {\n            return Integer.toOctalString(permissions);\n        }\n\n        public String toReadableString() {\n            StringBuilder sb = new StringBuilder();\n\n            // Owner permissions\n            sb.append(hasPermission(OWNER_READ) ? 'r' : '-');\n            sb.append(hasPermission(OWNER_WRITE) ? 'w' : '-');\n            sb.append(hasPermission(OWNER_EXECUTE) ? 'x' : '-');\n\n            // Group permissions\n            sb.append(hasPermission(GROUP_READ) ? 'r' : '-');\n            sb.append(hasPermission(GROUP_WRITE) ? 'w' : '-');\n            sb.append(hasPermission(GROUP_EXECUTE) ? 'x' : '-');\n\n            // Other permissions\n            sb.append(hasPermission(OTHER_READ) ? 'r' : '-');\n            sb.append(hasPermission(OTHER_WRITE) ? 'w' : '-');\n            sb.append(hasPermission(OTHER_EXECUTE) ? 'x' : '-');\n\n            return sb.toString();\n        }\n    }\n\n    // Network subnet calculator using bit manipulation\n    public static class SubnetCalculator {\n\n        public static class SubnetInfo {\n            public String networkAddress;\n            public String broadcastAddress;\n            public String subnetMask;\n            public int hostCount;\n            public String firstHost;\n            public String lastHost;\n        }\n\n        public SubnetInfo calculateSubnet(String ip, int prefixLength) {\n            int ipInt = ipToInt(ip);\n            int subnetMask = (-1) << (32 - prefixLength);\n\n            int networkAddress = ipInt & subnetMask;\n            int broadcastAddress = networkAddress | (~subnetMask);\n\n            SubnetInfo info = new SubnetInfo();\n            info.networkAddress = intToIp(networkAddress);\n            info.broadcastAddress = intToIp(broadcastAddress);\n            info.subnetMask = intToIp(subnetMask);\n            info.hostCount = (1 << (32 - prefixLength)) - 2; // Exclude network and broadcast\n            info.firstHost = intToIp(networkAddress + 1);\n            info.lastHost = intToIp(broadcastAddress - 1);\n\n            return info;\n        }\n\n        private int ipToInt(String ip) {\n            String[] parts = ip.split(\"\\\\.\");\n            return (Integer.parseInt(parts[0]) << 24) |\n                   (Integer.parseInt(parts[1]) << 16) |\n                   (Integer.parseInt(parts[2]) << 8) |\n                   Integer.parseInt(parts[3]);\n        }\n\n        private String intToIp(int ip) {\n            return ((ip >> 24) & 0xFF) + \".\" +\n                   ((ip >> 16) & 0xFF) + \".\" +\n                   ((ip >> 8) & 0xFF) + \".\" +\n                   (ip & 0xFF);\n        }\n    }\n\n    // Flag system for application settings\n    public static class ApplicationFlags {\n        private long flags;\n\n        // Feature flags\n        public static final long DARK_MODE = 1L << 0;\n        public static final long NOTIFICATIONS = 1L << 1;\n        public static final long AUTO_SAVE = 1L << 2;\n        public static final long SPELL_CHECK = 1L << 3;\n        public static final long SYNTAX_HIGHLIGHTING = 1L << 4;\n        public static final long LINE_NUMBERS = 1L << 5;\n        public static final long WORD_WRAP = 1L << 6;\n        public static final long AUTO_INDENT = 1L << 7;\n        // ... up to 64 flags\n\n        public void enableFlag(long flag) {\n            flags |= flag;\n        }\n\n        public void disableFlag(long flag) {\n            flags &= ~flag;\n        }\n\n        public boolean isFlagEnabled(long flag) {\n            return (flags & flag) != 0;\n        }\n\n        public void toggleFlag(long flag) {\n            flags ^= flag;\n        }\n\n        public long getAllFlags() {\n            return flags;\n        }\n\n        public void setAllFlags(long flags) {\n            this.flags = flags;\n        }\n\n        public int getEnabledFlagCount() {\n            return Long.bitCount(flags);\n        }\n    }\n\n    // Database indexing using bit manipulation\n    public static class BitIndex {\n        private Map<String, BitSet> columnIndexes;\n\n        public BitIndex() {\n            columnIndexes = new HashMap<>();\n        }\n\n        public void createIndex(String column, List<Object> values) {\n            Set<Object> uniqueValues = new HashSet<>(values);\n\n            for (Object value : uniqueValues) {\n                BitSet bitSet = new BitSet(values.size());\n\n                for (int i = 0; i < values.size(); i++) {\n                    if (values.get(i).equals(value)) {\n                        bitSet.set(i);\n                    }\n                }\n\n                columnIndexes.put(column + \":\" + value, bitSet);\n            }\n        }\n\n        public BitSet query(String column, Object value) {\n            return columnIndexes.get(column + \":\" + value);\n        }\n\n        public BitSet intersect(BitSet... bitSets) {\n            if (bitSets.length == 0) return new BitSet();\n\n            BitSet result = (BitSet) bitSets[0].clone();\n            for (int i = 1; i < bitSets.length; i++) {\n                result.and(bitSets[i]);\n            }\n\n            return result;\n        }\n\n        public BitSet union(BitSet... bitSets) {\n            if (bitSets.length == 0) return new BitSet();\n\n            BitSet result = (BitSet) bitSets[0].clone();\n            for (int i = 1; i < bitSets.length; i++) {\n                result.or(bitSets[i]);\n            }\n\n            return result;\n        }\n    }\n\n    // Bloom filter implementation\n    public static class BloomFilter {\n        private BitSet bitSet;\n        private int size;\n        private int hashFunctions;\n\n        public BloomFilter(int size, int hashFunctions) {\n            this.size = size;\n            this.hashFunctions = hashFunctions;\n            this.bitSet = new BitSet(size);\n        }\n\n        public void add(String item) {\n            for (int i = 0; i < hashFunctions; i++) {\n                int hash = hash(item, i) % size;\n                if (hash < 0) hash += size;\n                bitSet.set(hash);\n            }\n        }\n\n        public boolean mightContain(String item) {\n            for (int i = 0; i < hashFunctions; i++) {\n                int hash = hash(item, i) % size;\n                if (hash < 0) hash += size;\n                if (!bitSet.get(hash)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int hash(String item, int seed) {\n            int hash = seed;\n            for (char c : item.toCharArray()) {\n                hash = hash * 31 + c;\n            }\n            return hash;\n        }\n\n        public double getFalsePositiveRate() {\n            int setBits = bitSet.cardinality();\n            return Math.pow(1.0 - Math.exp(-hashFunctions * setBits / (double) size), hashFunctions);\n        }\n    }\n}\n"})}),"\n",(0,e.jsx)(i.hr,{}),"\n",(0,e.jsx)(i.h2,{id:"time--space-complexity-reference",children:"Time & Space Complexity Reference"}),"\n",(0,e.jsxs)(i.table,{children:[(0,e.jsx)(i.thead,{children:(0,e.jsxs)(i.tr,{children:[(0,e.jsx)(i.th,{style:{textAlign:"left"},children:"Operation"}),(0,e.jsx)(i.th,{style:{textAlign:"left"},children:"Time Complexity"}),(0,e.jsx)(i.th,{style:{textAlign:"left"},children:"Space Complexity"}),(0,e.jsx)(i.th,{style:{textAlign:"left"},children:"Notes"})]})}),(0,e.jsxs)(i.tbody,{children:[(0,e.jsxs)(i.tr,{children:[(0,e.jsx)(i.td,{style:{textAlign:"left"},children:"Basic Bit Ops"}),(0,e.jsx)(i.td,{style:{textAlign:"left"},children:"O(1)"}),(0,e.jsx)(i.td,{style:{textAlign:"left"},children:"O(1)"}),(0,e.jsx)(i.td,{style:{textAlign:"left"},children:"AND, OR, XOR, NOT, shifts"})]}),(0,e.jsxs)(i.tr,{children:[(0,e.jsx)(i.td,{style:{textAlign:"left"},children:"Count Set Bits"}),(0,e.jsx)(i.td,{style:{textAlign:"left"},children:"O(log n)"}),(0,e.jsx)(i.td,{style:{textAlign:"left"},children:"O(1)"}),(0,e.jsx)(i.td,{style:{textAlign:"left"},children:"Brian Kernighan's algorithm"})]}),(0,e.jsxs)(i.tr,{children:[(0,e.jsx)(i.td,{style:{textAlign:"left"},children:"Check Power of 2"}),(0,e.jsx)(i.td,{style:{textAlign:"left"},children:"O(1)"}),(0,e.jsx)(i.td,{style:{textAlign:"left"},children:"O(1)"}),(0,e.jsx)(i.td,{style:{textAlign:"left"},children:"n & (n-1) == 0"})]}),(0,e.jsxs)(i.tr,{children:[(0,e.jsx)(i.td,{style:{textAlign:"left"},children:"Generate Subsets"}),(0,e.jsx)(i.td,{style:{textAlign:"left"},children:"O(2^n)"}),(0,e.jsx)(i.td,{style:{textAlign:"left"},children:"O(2^n)"}),(0,e.jsx)(i.td,{style:{textAlign:"left"},children:"All possible combinations"})]}),(0,e.jsxs)(i.tr,{children:[(0,e.jsx)(i.td,{style:{textAlign:"left"},children:"XOR All Elements"}),(0,e.jsx)(i.td,{style:{textAlign:"left"},children:"O(n)"}),(0,e.jsx)(i.td,{style:{textAlign:"left"},children:"O(1)"}),(0,e.jsx)(i.td,{style:{textAlign:"left"},children:"Linear scan"})]}),(0,e.jsxs)(i.tr,{children:[(0,e.jsx)(i.td,{style:{textAlign:"left"},children:"Bitmasking DP"}),(0,e.jsx)(i.td,{style:{textAlign:"left"},children:"O(n \xd7 2^m)"}),(0,e.jsx)(i.td,{style:{textAlign:"left"},children:"O(2^m)"}),(0,e.jsx)(i.td,{style:{textAlign:"left"},children:"m = number of items in mask"})]}),(0,e.jsxs)(i.tr,{children:[(0,e.jsx)(i.td,{style:{textAlign:"left"},children:"Sieve with Bits"}),(0,e.jsx)(i.td,{style:{textAlign:"left"},children:"O(n log log n)"}),(0,e.jsx)(i.td,{style:{textAlign:"left"},children:"O(n/32)"}),(0,e.jsx)(i.td,{style:{textAlign:"left"},children:"Space optimized sieve"})]}),(0,e.jsxs)(i.tr,{children:[(0,e.jsx)(i.td,{style:{textAlign:"left"},children:"Bloom Filter"}),(0,e.jsx)(i.td,{style:{textAlign:"left"},children:"O(k)"}),(0,e.jsx)(i.td,{style:{textAlign:"left"},children:"O(m/8)"}),(0,e.jsx)(i.td,{style:{textAlign:"left"},children:"k = hash functions, m = bits"})]})]})]})]})}function p(n={}){const{wrapper:i}={...(0,r.R)(),...n.components};return i?(0,e.jsx)(i,{...n,children:(0,e.jsx)(c,{...n})}):c(n)}}}]);