"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[9568],{13703:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>c,frontMatter:()=>s,metadata:()=>a,toc:()=>d});var n=r(74848),o=r(28453);const s={title:"Depth-First Search (DFS) for Trees"},i=void 0,a={id:"DSA/DSA with JavaScript/DFSTree",title:"Depth-First Search (DFS) for Trees",description:"Depth-First Search (DFS) for Trees",source:"@site/docs/DSA/DSA with JavaScript/DFSTree.mdx",sourceDirName:"DSA/DSA with JavaScript",slug:"/DSA/DSA with JavaScript/DFSTree",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/DFSTree",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with JavaScript/DFSTree.mdx",tags:[],version:"current",frontMatter:{title:"Depth-First Search (DFS) for Trees"},sidebar:"tutorialSidebar",previous:{title:"DFS & BFS on Graphs",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/DFSBFSGraph"},next:{title:"Dequeue (Double-Ended Queue) Implementation Cheatsheet",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/Dequeue"}},l={},d=[{value:"Depth-First Search (DFS) for Trees",id:"depth-first-search-dfs-for-trees",level:2},{value:"Overview",id:"overview",level:3},{value:"Algorithm Steps",id:"algorithm-steps",level:3},{value:"Example Implementation",id:"example-implementation",level:3},{value:"DFS Pre Order (Root, Left, Right)",id:"dfs-pre-order-root-left-right",level:3},{value:"DFS In Order (Left, Root, Right)",id:"dfs-in-order-left-root-right",level:3},{value:"DFS Post Order (Left, Right, Root)",id:"dfs-post-order-left-right-root",level:3},{value:"Output",id:"output",level:3},{value:"Iterative DFS Version",id:"iterative-dfs-version",level:2},{value:"In-order",id:"in-order",level:3},{value:"Pre-order",id:"pre-order",level:3},{value:"Post-order",id:"post-order",level:3},{value:"Postorder 2",id:"postorder-2",level:3},{value:"DFS with Parent Tracking",id:"dfs-with-parent-tracking",level:2},{value:"DFS for Path Finding (Target Node)",id:"dfs-for-path-finding-target-node",level:2}];function h(e){const t={code:"code",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h2,{id:"depth-first-search-dfs-for-trees",children:"Depth-First Search (DFS) for Trees"}),"\n",(0,n.jsx)(t.p,{children:"Depth-First Search (DFS) is an algorithm used to traverse or search through tree or graph structures. It explores as far as possible along each branch before backtracking. DFS is useful for problems where you need to explore all possible paths or need to visit nodes in a specific order."}),"\n",(0,n.jsx)(t.h3,{id:"overview",children:"Overview"}),"\n",(0,n.jsx)(t.p,{children:"DFS starts from the root (or any arbitrary node in a graph) and explores as far as possible along each branch before backtracking. It can be implemented using recursion or a stack. DFS is useful for tasks such as searching paths, topological sorting, and solving puzzles."}),"\n",(0,n.jsx)(t.h3,{id:"algorithm-steps",children:"Algorithm Steps"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Initialize"}),": Start at the root node and mark it as visited."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Explore"}),": Recursively or iteratively visit all unvisited child nodes (or neighbors) of the current node."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Backtrack"}),": Once all nodes at the current branch have been explored, backtrack to explore other branches."]}),"\n"]}),"\n",(0,n.jsx)(t.h3,{id:"example-implementation",children:"Example Implementation"}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Code Example"}),":"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-JavaScript",children:"//TreeNode\nclass TreeNode {\n  constructor(val) {\n    this.val = val;   //Node value\n    this.left = null; // Left node\n    this.right = null; //Right node\n  }\n}\n"})}),"\n",(0,n.jsx)(t.h3,{id:"dfs-pre-order-root-left-right",children:"DFS Pre Order (Root, Left, Right)"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-JavaScript",children:"/**\n * Perform DFS traversal on a tree using Preorder (Root, Left, Right).\n * @param {TreeNode} root - The root of the tree.\n * @return {number[]} - The values of the nodes in DFS order.\n */\nconst dfsPreorder = (root) => {\n  const result = [];\n  \n  const traverse = (node) => {\n    if (!node) return;\n    result.push(node.val); // Process the node\n    traverse(node.left);  // Visit left subtree\n    traverse(node.right); // Visit right subtree\n  };\n  \n  traverse(root);\n  return result;\n};\n"})}),"\n",(0,n.jsx)(t.h3,{id:"dfs-in-order-left-root-right",children:"DFS In Order (Left, Root, Right)"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-JavaScript",children:"/**\n * Perform DFS traversal on a tree using Inorder (Left, Root, Right).\n * @param {TreeNode} root - The root of the tree.\n * @return {number[]} - The values of the nodes in DFS Inorder order.\n */\nconst dfsInorder = (root) => {\n  const result = [];\n  \n  const traverse = (node) => {\n    if (!node) return;\n    traverse(node.left);  // Visit left subtree\n    result.push(node.val); // Process the node\n    traverse(node.right); // Visit right subtree\n  };\n  \n  traverse(root);\n  return result;\n};\n"})}),"\n",(0,n.jsx)(t.h3,{id:"dfs-post-order-left-right-root",children:"DFS Post Order (Left, Right, Root)"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-JavaScript",children:"/**\n * Perform DFS traversal on a tree using Postorder (Left, Right, Root).\n * @param {TreeNode} root - The root of the tree.\n * @return {number[]} - The values of the nodes in DFS Postorder order.\n */\nconst dfsPostorder = (root) => {\n  const result = [];\n  \n  const traverse = (node) => {\n    if (!node) return;\n    traverse(node.left);  // Visit left subtree\n    traverse(node.right); // Visit right subtree\n    result.push(node.val); // Process the node\n  };\n  \n  traverse(root);\n  return result;\n};\n"})}),"\n",(0,n.jsx)(t.h3,{id:"output",children:"Output"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-JavaScript",children:"const root = new TreeNode(1);\nroot.left = new TreeNode(2);\nroot.right = new TreeNode(3);\nroot.left.left = new TreeNode(4);\nroot.left.right = new TreeNode(5);\nroot.right.left = new TreeNode(6);\nroot.right.right = new TreeNode(7);\n\n/* \n                     1\n                    / \\\n                   2   3\n                  / \\ / \\\n                 4  5 6  7\n*/\n\nconsole.log(dfsPreorder(root));  // Output: [1, 2, 4, 5, 3, 6, 7]\nconsole.log(dfsInorder(root));   // Output: [4, 2, 5, 1, 6, 3, 7]\nconsole.log(dfsPostorder(root)); // Output: [4, 5, 2, 6, 7, 3, 1]\n"})}),"\n",(0,n.jsx)(t.hr,{}),"\n",(0,n.jsx)(t.h2,{id:"iterative-dfs-version",children:"Iterative DFS Version"}),"\n",(0,n.jsx)(t.h3,{id:"in-order",children:"In-order"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-JavaScript",children:"function inOrderTraversal(root) {\n    const stack = [];\n    const result = [];\n\n    while (root || stack.length) {\n        // Go as left as possible and push all left nodes to the stack\n        while (root) {\n            stack.push(root);\n            root = root.left;\n        }\n\n        // Backtrack by popping from the stack\n        root = stack.pop();\n        result.push(root.val); // Add the node value to the result\n\n        // Now, visit the right subtree\n        root = root.right;\n    }\n\n    return result;\n}\n"})}),"\n",(0,n.jsx)(t.h3,{id:"pre-order",children:"Pre-order"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-JavaScript",children:"function preOrderTraversal(root) {\n    const stack = [];\n    const result = [];\n\n    if (root) stack.push(root); // Start by pushing the root node to the stack\n\n    while (stack.length) {\n        root = stack.pop(); // Pop the top node from the stack\n        result.push(root.val); // Add the node value to the result\n\n        // Push right child first so left child is processed first\n        if (root.right) stack.push(root.right);\n        if (root.left) stack.push(root.left);\n    }\n\n    return result;\n}\n"})}),"\n",(0,n.jsx)(t.h3,{id:"post-order",children:"Post-order"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-JavaScript",children:"function postOrderTraversal(root) {\n    const stack = [];\n    const result = [];\n    let lastVisited = null; // Track the last visited node\n\n    while (root || stack.length) {\n        if (root) {\n            // Go left as far as possible\n            stack.push(root);\n            root = root.left;\n        } else {\n            const peekNode = stack[stack.length - 1]; // Look at the top of the stack\n            // Check if we can visit the right subtree\n            if (peekNode.right && lastVisited !== peekNode.right) {\n                root = peekNode.right; // Go to the right subtree\n            } else {\n                // If right subtree is null or already visited, process current node\n                result.push(peekNode.val);\n                lastVisited = stack.pop(); // Mark this node as visited\n            }\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,n.jsx)(t.h3,{id:"postorder-2",children:"Postorder 2"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-JavaScript",children:"function dfsPostorder(root) {\n    if (!root) return [];\n    \n    const stack = [root];\n    const result = [];\n    \n    while (stack.length > 0) {\n        const node = stack.pop();\n        result.push(node.val);\n\n        // Push left first so right is processed first\n        if (node.left) stack.push(node.left);\n        if (node.right) stack.push(node.right);\n    }\n\n    return result.reverse(); // Reverse at the end to get Left -> Right -> Root order\n}\n"})}),"\n",(0,n.jsx)(t.h2,{id:"dfs-with-parent-tracking",children:"DFS with Parent Tracking"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-JavaScript",children:"function dfsWithParent(root) {\n    if (!root) return [];\n\n    const stack = [[root, null]]; // [node, parent]\n    const parentMap = new Map();\n\n    while (stack.length > 0) {\n        const [node, parent] = stack.pop();\n        parentMap.set(node, parent);\n\n        if (node.right) stack.push([node.right, node]);\n        if (node.left) stack.push([node.left, node]);\n    }\n\n    return parentMap;\n}\n"})}),"\n",(0,n.jsx)(t.h2,{id:"dfs-for-path-finding-target-node",children:"DFS for Path Finding (Target Node)"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-JavaScript",children:"function dfsFindPath(root, target) {\n    if (!root) return null;\n    \n    const stack = [[root, [root.val]]]; // [node, pathSoFar]\n\n    while (stack.length > 0) {\n        const [node, path] = stack.pop();\n\n        if (node.val === target) return path;\n\n        if (node.right) stack.push([node.right, [...path, node.right.val]]);\n        if (node.left) stack.push([node.left, [...path, node.left.val]]);\n    }\n\n    return null;\n}\n"})})]})}function c(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},28453:(e,t,r)=>{r.d(t,{R:()=>i,x:()=>a});var n=r(96540);const o={},s=n.createContext(o);function i(e){const t=n.useContext(s);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);