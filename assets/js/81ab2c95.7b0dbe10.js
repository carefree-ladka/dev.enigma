"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[89504],{24010:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>d});var r=t(74848),i=t(28453);const s={},o="Graph",a={id:"DSA/DSA with JavaScript/DSA Cheatsheets/Graph",title:"Graph",description:"A comprehensive guide to graph algorithms and techniques for Data Structures and Algorithms.",source:"@site/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Graph.mdx",sourceDirName:"DSA/DSA with JavaScript/DSA Cheatsheets",slug:"/DSA/DSA with JavaScript/DSA Cheatsheets/Graph",permalink:"/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Graph",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Graph.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Dynamic Programming",permalink:"/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Dynamic Programming"},next:{title:"Grid-Based Graph",permalink:"/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Grid-Based Graph"}},l={},d=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Graph Representations",id:"graph-representations",level:2},{value:"1. Adjacency List (Most Common)",id:"1-adjacency-list-most-common",level:3},{value:"2. Adjacency Matrix",id:"2-adjacency-matrix",level:3},{value:"3. Edge List",id:"3-edge-list",level:3},{value:"Graph Traversal Techniques",id:"graph-traversal-techniques",level:2},{value:"1. Depth-First Search (DFS)",id:"1-depth-first-search-dfs",level:3},{value:"Recursive Implementation",id:"recursive-implementation",level:4},{value:"Iterative Implementation",id:"iterative-implementation",level:4},{value:"2. Breadth-First Search (BFS)",id:"2-breadth-first-search-bfs",level:3},{value:"3. BFS Level-by-Level",id:"3-bfs-level-by-level",level:3},{value:"Shortest Path Algorithms",id:"shortest-path-algorithms",level:2},{value:"1. Dijkstra&#39;s Algorithm (Single Source Shortest Path)",id:"1-dijkstras-algorithm-single-source-shortest-path",level:3},{value:"2. Bellman-Ford Algorithm (Handles Negative Weights)",id:"2-bellman-ford-algorithm-handles-negative-weights",level:3},{value:"3. Floyd-Warshall Algorithm (All Pairs Shortest Path)",id:"3-floyd-warshall-algorithm-all-pairs-shortest-path",level:3},{value:"Cycle Detection",id:"cycle-detection",level:2},{value:"1. Cycle Detection in Undirected Graph (DFS)",id:"1-cycle-detection-in-undirected-graph-dfs",level:3},{value:"2. Cycle Detection in Directed Graph (DFS)",id:"2-cycle-detection-in-directed-graph-dfs",level:3},{value:"3. Union-Find for Cycle Detection",id:"3-union-find-for-cycle-detection",level:3},{value:"Topological Sorting",id:"topological-sorting",level:2},{value:"1. Kahn&#39;s Algorithm (BFS-based)",id:"1-kahns-algorithm-bfs-based",level:3},{value:"2. DFS-based Topological Sort",id:"2-dfs-based-topological-sort",level:3},{value:"Connected Components",id:"connected-components",level:2},{value:"1. Find Connected Components (Undirected Graph)",id:"1-find-connected-components-undirected-graph",level:3},{value:"2. Strongly Connected Components (Kosaraju&#39;s Algorithm)",id:"2-strongly-connected-components-kosarajus-algorithm",level:3},{value:"Minimum Spanning Tree",id:"minimum-spanning-tree",level:2},{value:"1. Kruskal&#39;s Algorithm",id:"1-kruskals-algorithm",level:3},{value:"2. Prim&#39;s Algorithm",id:"2-prims-algorithm",level:3},{value:"Advanced Graph Algorithms",id:"advanced-graph-algorithms",level:2},{value:"1. Articulation Points (Cut Vertices)",id:"1-articulation-points-cut-vertices",level:3},{value:"2. Bridges in Graph",id:"2-bridges-in-graph",level:3},{value:"3. Maximum Flow (Ford-Fulkerson with DFS)",id:"3-maximum-flow-ford-fulkerson-with-dfs",level:3},{value:"Graph Coloring",id:"graph-coloring",level:2},{value:"1. Graph Coloring (Greedy)",id:"1-graph-coloring-greedy",level:3},{value:"2. Check if Graph is Bipartite",id:"2-check-if-graph-is-bipartite",level:3},{value:"Usage Examples",id:"usage-examples",level:2},{value:"Time Complexity Summary",id:"time-complexity-summary",level:2},{value:"Graph Representations Comparison",id:"graph-representations-comparison",level:2},{value:"Common Graph Patterns",id:"common-graph-patterns",level:2},{value:"1. <strong>Graph Traversal Pattern</strong>",id:"1-graph-traversal-pattern",level:3},{value:"2. <strong>Path Finding Pattern</strong>",id:"2-path-finding-pattern",level:3},{value:"3. <strong>Component Detection Pattern</strong>",id:"3-component-detection-pattern",level:3},{value:"Advanced Problem Patterns",id:"advanced-problem-patterns",level:2},{value:"1. <strong>Graph Validation Problems</strong>",id:"1-graph-validation-problems",level:3},{value:"Valid Tree (N nodes, N-1 edges, connected, no cycles)",id:"valid-tree-n-nodes-n-1-edges-connected-no-cycles",level:4},{value:"Number of Islands",id:"number-of-islands",level:4},{value:"2. <strong>Course Schedule Problems</strong>",id:"2-course-schedule-problems",level:3},{value:"3. <strong>Word Ladder Problem</strong>",id:"3-word-ladder-problem",level:3},{value:"Key Interview Tips",id:"key-interview-tips",level:2},{value:"<strong>When to Use Each Algorithm:</strong>",id:"when-to-use-each-algorithm",level:3},{value:"<strong>Common Mistakes to Avoid:</strong>",id:"common-mistakes-to-avoid",level:3},{value:"<strong>Optimization Techniques:</strong>",id:"optimization-techniques",level:3},{value:"Real-World Applications",id:"real-world-applications",level:2},{value:"<strong>Social Networks:</strong>",id:"social-networks",level:3},{value:"<strong>Transportation:</strong>",id:"transportation",level:3},{value:"<strong>Computer Networks:</strong>",id:"computer-networks",level:3},{value:"<strong>Scheduling:</strong>",id:"scheduling",level:3}];function c(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"graph",children:"Graph"})}),"\n",(0,r.jsx)(n.p,{children:"A comprehensive guide to graph algorithms and techniques for Data Structures and Algorithms."}),"\n",(0,r.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#graph-representations",children:"Graph Representations"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#graph-traversal-techniques",children:"Graph Traversal Techniques"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#shortest-path-algorithms",children:"Shortest Path Algorithms"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#cycle-detection",children:"Cycle Detection"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#topological-sorting",children:"Topological Sorting"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#connected-components",children:"Connected Components"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#minimum-spanning-tree",children:"Minimum Spanning Tree"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#advanced-graph-algorithms",children:"Advanced Graph Algorithms"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#graph-coloring",children:"Graph Coloring"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#usage-examples",children:"Usage Examples"})}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"graph-representations",children:"Graph Representations"}),"\n",(0,r.jsx)(n.p,{children:"Graphs can be represented in multiple ways, each with its own advantages and use cases."}),"\n",(0,r.jsx)(n.h3,{id:"1-adjacency-list-most-common",children:"1. Adjacency List (Most Common)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class Graph {\n  constructor() {\n    this.adjacencyList = new Map();\n  }\n\n  addVertex(vertex) {\n    if (!this.adjacencyList.has(vertex)) {\n      this.adjacencyList.set(vertex, []);\n    }\n  }\n\n  addEdge(v1, v2, directed = false) {\n    this.addVertex(v1);\n    this.addVertex(v2);\n\n    this.adjacencyList.get(v1).push(v2);\n    if (!directed) {\n      this.adjacencyList.get(v2).push(v1);\n    }\n  }\n\n  removeEdge(v1, v2, directed = false) {\n    if (this.adjacencyList.has(v1)) {\n      this.adjacencyList.set(\n        v1,\n        this.adjacencyList.get(v1).filter(v => v !== v2)\n      );\n    }\n    if (!directed && this.adjacencyList.has(v2)) {\n      this.adjacencyList.set(\n        v2,\n        this.adjacencyList.get(v2).filter(v => v !== v1)\n      );\n    }\n  }\n\n  removeVertex(vertex) {\n    if (!this.adjacencyList.has(vertex)) return;\n\n    // Remove all edges to this vertex\n    for (let adjacentVertex of this.adjacencyList.get(vertex)) {\n      this.removeEdge(vertex, adjacentVertex);\n    }\n\n    this.adjacencyList.delete(vertex);\n  }\n\n  getNeighbors(vertex) {\n    return this.adjacencyList.get(vertex) || [];\n  }\n\n  getVertices() {\n    return Array.from(this.adjacencyList.keys());\n  }\n\n  hasEdge(v1, v2) {\n    return (\n      this.adjacencyList.has(v1) && this.adjacencyList.get(v1).includes(v2)\n    );\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Space Complexity:"})," O(V + E) where V = vertices, E = edges"]}),"\n",(0,r.jsx)(n.h3,{id:"2-adjacency-matrix",children:"2. Adjacency Matrix"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class GraphMatrix {\n  constructor(numVertices) {\n    this.numVertices = numVertices;\n    this.matrix = Array(numVertices)\n      .fill()\n      .map(() => Array(numVertices).fill(0));\n  }\n\n  addEdge(v1, v2, weight = 1, directed = false) {\n    this.matrix[v1][v2] = weight;\n    if (!directed) {\n      this.matrix[v2][v1] = weight;\n    }\n  }\n\n  removeEdge(v1, v2, directed = false) {\n    this.matrix[v1][v2] = 0;\n    if (!directed) {\n      this.matrix[v2][v1] = 0;\n    }\n  }\n\n  hasEdge(v1, v2) {\n    return this.matrix[v1][v2] !== 0;\n  }\n\n  getNeighbors(vertex) {\n    const neighbors = [];\n    for (let i = 0; i < this.numVertices; i++) {\n      if (this.matrix[vertex][i] !== 0) {\n        neighbors.push(i);\n      }\n    }\n    return neighbors;\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Space Complexity:"})," O(V\xb2)"]}),"\n",(0,r.jsx)(n.h3,{id:"3-edge-list",children:"3. Edge List"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class EdgeList {\n  constructor() {\n    this.edges = [];\n    this.vertices = new Set();\n  }\n\n  addEdge(v1, v2, weight = 1) {\n    this.edges.push({ from: v1, to: v2, weight });\n    this.vertices.add(v1);\n    this.vertices.add(v2);\n  }\n\n  getEdges() {\n    return this.edges;\n  }\n\n  getVertices() {\n    return Array.from(this.vertices);\n  }\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"graph-traversal-techniques",children:"Graph Traversal Techniques"}),"\n",(0,r.jsx)(n.h3,{id:"1-depth-first-search-dfs",children:"1. Depth-First Search (DFS)"}),"\n",(0,r.jsx)(n.h4,{id:"recursive-implementation",children:"Recursive Implementation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function dfsRecursive(graph, startVertex, visited = new Set()) {\n  const result = [];\n\n  function dfs(vertex) {\n    visited.add(vertex);\n    result.push(vertex);\n\n    for (let neighbor of graph.getNeighbors(vertex)) {\n      if (!visited.has(neighbor)) {\n        dfs(neighbor);\n      }\n    }\n  }\n\n  dfs(startVertex);\n  return result;\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"iterative-implementation",children:"Iterative Implementation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function dfsIterative(graph, startVertex) {\n  const result = [];\n  const visited = new Set();\n  const stack = [startVertex];\n\n  while (stack.length > 0) {\n    const vertex = stack.pop();\n\n    if (!visited.has(vertex)) {\n      visited.add(vertex);\n      result.push(vertex);\n\n      // Add neighbors to stack (in reverse order for consistent traversal)\n      const neighbors = graph.getNeighbors(vertex);\n      for (let i = neighbors.length - 1; i >= 0; i--) {\n        if (!visited.has(neighbors[i])) {\n          stack.push(neighbors[i]);\n        }\n      }\n    }\n  }\n\n  return result;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Time Complexity:"})," O(V + E) | ",(0,r.jsx)(n.strong,{children:"Space Complexity:"})," O(V)"]}),"\n",(0,r.jsx)(n.h3,{id:"2-breadth-first-search-bfs",children:"2. Breadth-First Search (BFS)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function bfs(graph, startVertex) {\n  const result = [];\n  const visited = new Set();\n  const queue = [startVertex];\n\n  visited.add(startVertex);\n\n  while (queue.length > 0) {\n    const vertex = queue.shift();\n    result.push(vertex);\n\n    for (let neighbor of graph.getNeighbors(vertex)) {\n      if (!visited.has(neighbor)) {\n        visited.add(neighbor);\n        queue.push(neighbor);\n      }\n    }\n  }\n\n  return result;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Time Complexity:"})," O(V + E) | ",(0,r.jsx)(n.strong,{children:"Space Complexity:"})," O(V)"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"\ud83d\udca1 Pro Tip:"})," BFS finds shortest path in unweighted graphs!"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"3-bfs-level-by-level",children:"3. BFS Level-by-Level"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function bfsByLevels(graph, startVertex) {\n  const levels = [];\n  const visited = new Set();\n  let queue = [startVertex];\n\n  visited.add(startVertex);\n\n  while (queue.length > 0) {\n    const currentLevel = [...queue];\n    levels.push(currentLevel);\n    queue = [];\n\n    for (let vertex of currentLevel) {\n      for (let neighbor of graph.getNeighbors(vertex)) {\n        if (!visited.has(neighbor)) {\n          visited.add(neighbor);\n          queue.push(neighbor);\n        }\n      }\n    }\n  }\n\n  return levels;\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"shortest-path-algorithms",children:"Shortest Path Algorithms"}),"\n",(0,r.jsx)(n.h3,{id:"1-dijkstras-algorithm-single-source-shortest-path",children:"1. Dijkstra's Algorithm (Single Source Shortest Path)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class PriorityQueue {\n  constructor() {\n    this.values = [];\n  }\n\n  enqueue(val, priority) {\n    this.values.push({ val, priority });\n    this.sort();\n  }\n\n  dequeue() {\n    return this.values.shift();\n  }\n\n  sort() {\n    this.values.sort((a, b) => a.priority - b.priority);\n  }\n\n  isEmpty() {\n    return this.values.length === 0;\n  }\n}\n\nfunction dijkstra(graph, start, end) {\n  const distances = {};\n  const previous = {};\n  const pq = new PriorityQueue();\n  const path = [];\n\n  // Initialize distances and previous\n  for (let vertex of graph.getVertices()) {\n    if (vertex === start) {\n      distances[vertex] = 0;\n      pq.enqueue(vertex, 0);\n    } else {\n      distances[vertex] = Infinity;\n      pq.enqueue(vertex, Infinity);\n    }\n    previous[vertex] = null;\n  }\n\n  while (!pq.isEmpty()) {\n    let smallest = pq.dequeue().val;\n\n    if (smallest === end) {\n      // Build path\n      while (previous[smallest]) {\n        path.push(smallest);\n        smallest = previous[smallest];\n      }\n      break;\n    }\n\n    if (smallest || distances[smallest] !== Infinity) {\n      for (let neighbor of graph.getNeighbors(smallest)) {\n        // Calculate new distance\n        let candidate = distances[smallest] + getWeight(smallest, neighbor);\n        let nextNeighbor = neighbor;\n\n        if (candidate < distances[nextNeighbor]) {\n          distances[nextNeighbor] = candidate;\n          previous[nextNeighbor] = smallest;\n          pq.enqueue(nextNeighbor, candidate);\n        }\n      }\n    }\n  }\n\n  return {\n    path: path.concat(start).reverse(),\n    distance: distances[end],\n  };\n}\n\n// Helper function for weighted graphs\nfunction getWeight(v1, v2) {\n  // This would be implemented based on your graph representation\n  return 1; // Default weight for unweighted graphs\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Time Complexity:"})," O((V + E) log V) with binary heap"]}),"\n",(0,r.jsx)(n.h3,{id:"2-bellman-ford-algorithm-handles-negative-weights",children:"2. Bellman-Ford Algorithm (Handles Negative Weights)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function bellmanFord(edges, vertices, start) {\n  const distances = {};\n\n  // Initialize distances\n  for (let vertex of vertices) {\n    distances[vertex] = vertex === start ? 0 : Infinity;\n  }\n\n  // Relax edges V-1 times\n  for (let i = 0; i < vertices.length - 1; i++) {\n    for (let edge of edges) {\n      const { from, to, weight } = edge;\n      if (\n        distances[from] !== Infinity &&\n        distances[from] + weight < distances[to]\n      ) {\n        distances[to] = distances[from] + weight;\n      }\n    }\n  }\n\n  // Check for negative cycles\n  for (let edge of edges) {\n    const { from, to, weight } = edge;\n    if (\n      distances[from] !== Infinity &&\n      distances[from] + weight < distances[to]\n    ) {\n      throw new Error('Graph contains negative cycle');\n    }\n  }\n\n  return distances;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Time Complexity:"})," O(VE) | ",(0,r.jsx)(n.strong,{children:"Space Complexity:"})," O(V)"]}),"\n",(0,r.jsx)(n.h3,{id:"3-floyd-warshall-algorithm-all-pairs-shortest-path",children:"3. Floyd-Warshall Algorithm (All Pairs Shortest Path)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function floydWarshall(matrix) {\n  const n = matrix.length;\n  const dist = matrix.map(row => [...row]); // Deep copy\n\n  // Replace 0 with Infinity for non-diagonal elements\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      if (i !== j && dist[i][j] === 0) {\n        dist[i][j] = Infinity;\n      }\n    }\n  }\n\n  // Floyd-Warshall algorithm\n  for (let k = 0; k < n; k++) {\n    for (let i = 0; i < n; i++) {\n      for (let j = 0; j < n; j++) {\n        if (dist[i][k] + dist[k][j] < dist[i][j]) {\n          dist[i][j] = dist[i][k] + dist[k][j];\n        }\n      }\n    }\n  }\n\n  return dist;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Time Complexity:"})," O(V\xb3) | ",(0,r.jsx)(n.strong,{children:"Space Complexity:"})," O(V\xb2)"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"cycle-detection",children:"Cycle Detection"}),"\n",(0,r.jsx)(n.h3,{id:"1-cycle-detection-in-undirected-graph-dfs",children:"1. Cycle Detection in Undirected Graph (DFS)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function hasCycleUndirected(graph) {\n  const visited = new Set();\n\n  function dfs(vertex, parent) {\n    visited.add(vertex);\n\n    for (let neighbor of graph.getNeighbors(vertex)) {\n      if (!visited.has(neighbor)) {\n        if (dfs(neighbor, vertex)) {\n          return true;\n        }\n      } else if (neighbor !== parent) {\n        return true; // Back edge found\n      }\n    }\n\n    return false;\n  }\n\n  // Check all components\n  for (let vertex of graph.getVertices()) {\n    if (!visited.has(vertex)) {\n      if (dfs(vertex, null)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-cycle-detection-in-directed-graph-dfs",children:"2. Cycle Detection in Directed Graph (DFS)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function hasCycleDirected(graph) {\n  const WHITE = 0,\n    GRAY = 1,\n    BLACK = 2;\n  const colors = new Map();\n\n  // Initialize all vertices as WHITE\n  for (let vertex of graph.getVertices()) {\n    colors.set(vertex, WHITE);\n  }\n\n  function dfs(vertex) {\n    colors.set(vertex, GRAY);\n\n    for (let neighbor of graph.getNeighbors(vertex)) {\n      if (colors.get(neighbor) === GRAY) {\n        return true; // Back edge found\n      }\n      if (colors.get(neighbor) === WHITE && dfs(neighbor)) {\n        return true;\n      }\n    }\n\n    colors.set(vertex, BLACK);\n    return false;\n  }\n\n  // Check all vertices\n  for (let vertex of graph.getVertices()) {\n    if (colors.get(vertex) === WHITE) {\n      if (dfs(vertex)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"3-union-find-for-cycle-detection",children:"3. Union-Find for Cycle Detection"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class UnionFind {\n  constructor(n) {\n    this.parent = Array(n)\n      .fill()\n      .map((_, i) => i);\n    this.rank = Array(n).fill(0);\n  }\n\n  find(x) {\n    if (this.parent[x] !== x) {\n      this.parent[x] = this.find(this.parent[x]); // Path compression\n    }\n    return this.parent[x];\n  }\n\n  union(x, y) {\n    const rootX = this.find(x);\n    const rootY = this.find(y);\n\n    if (rootX === rootY) {\n      return false; // Already in same set (cycle detected)\n    }\n\n    // Union by rank\n    if (this.rank[rootX] < this.rank[rootY]) {\n      this.parent[rootX] = rootY;\n    } else if (this.rank[rootX] > this.rank[rootY]) {\n      this.parent[rootY] = rootX;\n    } else {\n      this.parent[rootY] = rootX;\n      this.rank[rootX]++;\n    }\n\n    return true;\n  }\n}\n\nfunction detectCycleUnionFind(edges, numVertices) {\n  const uf = new UnionFind(numVertices);\n\n  for (let edge of edges) {\n    const [u, v] = edge;\n    if (!uf.union(u, v)) {\n      return true; // Cycle detected\n    }\n  }\n\n  return false;\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"topological-sorting",children:"Topological Sorting"}),"\n",(0,r.jsx)(n.h3,{id:"1-kahns-algorithm-bfs-based",children:"1. Kahn's Algorithm (BFS-based)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function topologicalSortKahn(graph) {\n  const inDegree = new Map();\n  const queue = [];\n  const result = [];\n\n  // Initialize in-degrees\n  for (let vertex of graph.getVertices()) {\n    inDegree.set(vertex, 0);\n  }\n\n  // Calculate in-degrees\n  for (let vertex of graph.getVertices()) {\n    for (let neighbor of graph.getNeighbors(vertex)) {\n      inDegree.set(neighbor, inDegree.get(neighbor) + 1);\n    }\n  }\n\n  // Add vertices with 0 in-degree to queue\n  for (let [vertex, degree] of inDegree) {\n    if (degree === 0) {\n      queue.push(vertex);\n    }\n  }\n\n  while (queue.length > 0) {\n    const vertex = queue.shift();\n    result.push(vertex);\n\n    for (let neighbor of graph.getNeighbors(vertex)) {\n      inDegree.set(neighbor, inDegree.get(neighbor) - 1);\n      if (inDegree.get(neighbor) === 0) {\n        queue.push(neighbor);\n      }\n    }\n  }\n\n  // Check if graph has cycle\n  if (result.length !== graph.getVertices().length) {\n    throw new Error('Graph has cycle - topological sort not possible');\n  }\n\n  return result;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-dfs-based-topological-sort",children:"2. DFS-based Topological Sort"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function topologicalSortDFS(graph) {\n  const visited = new Set();\n  const stack = [];\n\n  function dfs(vertex) {\n    visited.add(vertex);\n\n    for (let neighbor of graph.getNeighbors(vertex)) {\n      if (!visited.has(neighbor)) {\n        dfs(neighbor);\n      }\n    }\n\n    stack.push(vertex); // Push to stack after visiting all neighbors\n  }\n\n  // Visit all vertices\n  for (let vertex of graph.getVertices()) {\n    if (!visited.has(vertex)) {\n      dfs(vertex);\n    }\n  }\n\n  return stack.reverse();\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Time Complexity:"})," O(V + E) | ",(0,r.jsx)(n.strong,{children:"Space Complexity:"})," O(V)"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"connected-components",children:"Connected Components"}),"\n",(0,r.jsx)(n.h3,{id:"1-find-connected-components-undirected-graph",children:"1. Find Connected Components (Undirected Graph)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function findConnectedComponents(graph) {\n  const visited = new Set();\n  const components = [];\n\n  function dfs(vertex, component) {\n    visited.add(vertex);\n    component.push(vertex);\n\n    for (let neighbor of graph.getNeighbors(vertex)) {\n      if (!visited.has(neighbor)) {\n        dfs(neighbor, component);\n      }\n    }\n  }\n\n  for (let vertex of graph.getVertices()) {\n    if (!visited.has(vertex)) {\n      const component = [];\n      dfs(vertex, component);\n      components.push(component);\n    }\n  }\n\n  return components;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-strongly-connected-components-kosarajus-algorithm",children:"2. Strongly Connected Components (Kosaraju's Algorithm)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function stronglyConnectedComponents(graph) {\n  const visited = new Set();\n  const stack = [];\n\n  // Step 1: Fill stack with vertices in finishing time order\n  function dfs1(vertex) {\n    visited.add(vertex);\n    for (let neighbor of graph.getNeighbors(vertex)) {\n      if (!visited.has(neighbor)) {\n        dfs1(neighbor);\n      }\n    }\n    stack.push(vertex);\n  }\n\n  for (let vertex of graph.getVertices()) {\n    if (!visited.has(vertex)) {\n      dfs1(vertex);\n    }\n  }\n\n  // Step 2: Create transpose graph\n  const transpose = new Graph();\n  for (let vertex of graph.getVertices()) {\n    for (let neighbor of graph.getNeighbors(vertex)) {\n      transpose.addEdge(neighbor, vertex, true); // Reverse edge\n    }\n  }\n\n  // Step 3: DFS on transpose graph in stack order\n  visited.clear();\n  const sccs = [];\n\n  function dfs2(vertex, scc) {\n    visited.add(vertex);\n    scc.push(vertex);\n    for (let neighbor of transpose.getNeighbors(vertex)) {\n      if (!visited.has(neighbor)) {\n        dfs2(neighbor, scc);\n      }\n    }\n  }\n\n  while (stack.length > 0) {\n    const vertex = stack.pop();\n    if (!visited.has(vertex)) {\n      const scc = [];\n      dfs2(vertex, scc);\n      sccs.push(scc);\n    }\n  }\n\n  return sccs;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Time Complexity:"})," O(V + E) | ",(0,r.jsx)(n.strong,{children:"Space Complexity:"})," O(V)"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"minimum-spanning-tree",children:"Minimum Spanning Tree"}),"\n",(0,r.jsx)(n.h3,{id:"1-kruskals-algorithm",children:"1. Kruskal's Algorithm"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function kruskalMST(edges, numVertices) {\n  const mst = [];\n  const uf = new UnionFind(numVertices);\n\n  // Sort edges by weight\n  edges.sort((a, b) => a.weight - b.weight);\n\n  for (let edge of edges) {\n    const { from, to, weight } = edge;\n\n    if (uf.union(from, to)) {\n      mst.push(edge);\n      if (mst.length === numVertices - 1) {\n        break;\n      }\n    }\n  }\n\n  return mst;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Time Complexity:"})," O(E log E) | ",(0,r.jsx)(n.strong,{children:"Space Complexity:"})," O(V)"]}),"\n",(0,r.jsx)(n.h3,{id:"2-prims-algorithm",children:"2. Prim's Algorithm"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function primMST(graph, startVertex) {\n  const mst = [];\n  const visited = new Set();\n  const pq = new PriorityQueue();\n\n  visited.add(startVertex);\n\n  // Add all edges from start vertex\n  for (let neighbor of graph.getNeighbors(startVertex)) {\n    pq.enqueue(\n      {\n        from: startVertex,\n        to: neighbor,\n        weight: getWeight(startVertex, neighbor),\n      },\n      getWeight(startVertex, neighbor)\n    );\n  }\n\n  while (!pq.isEmpty() && mst.length < graph.getVertices().length - 1) {\n    const edge = pq.dequeue().val;\n    const { from, to, weight } = edge;\n\n    if (visited.has(to)) continue;\n\n    visited.add(to);\n    mst.push(edge);\n\n    // Add all edges from newly added vertex\n    for (let neighbor of graph.getNeighbors(to)) {\n      if (!visited.has(neighbor)) {\n        pq.enqueue(\n          { from: to, to: neighbor, weight: getWeight(to, neighbor) },\n          getWeight(to, neighbor)\n        );\n      }\n    }\n  }\n\n  return mst;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Time Complexity:"})," O(E log V) | ",(0,r.jsx)(n.strong,{children:"Space Complexity:"})," O(V)"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"advanced-graph-algorithms",children:"Advanced Graph Algorithms"}),"\n",(0,r.jsx)(n.h3,{id:"1-articulation-points-cut-vertices",children:"1. Articulation Points (Cut Vertices)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function findArticulationPoints(graph) {\n  const visited = new Set();\n  const disc = new Map(); // Discovery time\n  const low = new Map(); // Lowest discovery time reachable\n  const parent = new Map();\n  const ap = new Set(); // Articulation points\n  let time = 0;\n\n  function dfs(u) {\n    let children = 0;\n    visited.add(u);\n    disc.set(u, time);\n    low.set(u, time);\n    time++;\n\n    for (let v of graph.getNeighbors(u)) {\n      if (!visited.has(v)) {\n        children++;\n        parent.set(v, u);\n        dfs(v);\n\n        low.set(u, Math.min(low.get(u), low.get(v)));\n\n        // Root is articulation point if it has more than one child\n        if (!parent.has(u) && children > 1) {\n          ap.add(u);\n        }\n\n        // Non-root is articulation point if low[v] >= disc[u]\n        if (parent.has(u) && low.get(v) >= disc.get(u)) {\n          ap.add(u);\n        }\n      } else if (v !== parent.get(u)) {\n        low.set(u, Math.min(low.get(u), disc.get(v)));\n      }\n    }\n  }\n\n  for (let vertex of graph.getVertices()) {\n    if (!visited.has(vertex)) {\n      dfs(vertex);\n    }\n  }\n\n  return Array.from(ap);\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-bridges-in-graph",children:"2. Bridges in Graph"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function findBridges(graph) {\n  const visited = new Set();\n  const disc = new Map();\n  const low = new Map();\n  const parent = new Map();\n  const bridges = [];\n  let time = 0;\n\n  function dfs(u) {\n    visited.add(u);\n    disc.set(u, time);\n    low.set(u, time);\n    time++;\n\n    for (let v of graph.getNeighbors(u)) {\n      if (!visited.has(v)) {\n        parent.set(v, u);\n        dfs(v);\n\n        low.set(u, Math.min(low.get(u), low.get(v)));\n\n        // If low[v] > disc[u], then u-v is a bridge\n        if (low.get(v) > disc.get(u)) {\n          bridges.push([u, v]);\n        }\n      } else if (v !== parent.get(u)) {\n        low.set(u, Math.min(low.get(u), disc.get(v)));\n      }\n    }\n  }\n\n  for (let vertex of graph.getVertices()) {\n    if (!visited.has(vertex)) {\n      dfs(vertex);\n    }\n  }\n\n  return bridges;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"3-maximum-flow-ford-fulkerson-with-dfs",children:"3. Maximum Flow (Ford-Fulkerson with DFS)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function maxFlow(graph, source, sink) {\n  // Create residual graph\n  const residualGraph = createResidualGraph(graph);\n  let maxFlowValue = 0;\n\n  function dfs(current, sink, visited, pathFlow) {\n    if (current === sink) return pathFlow;\n\n    visited.add(current);\n\n    for (let neighbor of residualGraph.getNeighbors(current)) {\n      const capacity = getCapacity(residualGraph, current, neighbor);\n\n      if (!visited.has(neighbor) && capacity > 0) {\n        const minFlow = Math.min(pathFlow, capacity);\n        const flow = dfs(neighbor, sink, visited, minFlow);\n\n        if (flow > 0) {\n          // Update residual graph\n          updateCapacity(residualGraph, current, neighbor, -flow);\n          updateCapacity(residualGraph, neighbor, current, flow);\n          return flow;\n        }\n      }\n    }\n\n    return 0;\n  }\n\n  while (true) {\n    const visited = new Set();\n    const pathFlow = dfs(source, sink, visited, Infinity);\n\n    if (pathFlow === 0) break;\n    maxFlowValue += pathFlow;\n  }\n\n  return maxFlowValue;\n}\n\n// Helper functions for capacity management\nfunction createResidualGraph(graph) {\n  // Implementation depends on your graph representation\n  // This would create a copy with capacity information\n}\n\nfunction getCapacity(graph, from, to) {\n  // Return current capacity between vertices\n}\n\nfunction updateCapacity(graph, from, to, delta) {\n  // Update capacity by delta amount\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"graph-coloring",children:"Graph Coloring"}),"\n",(0,r.jsx)(n.h3,{id:"1-graph-coloring-greedy",children:"1. Graph Coloring (Greedy)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function greedyColoring(graph) {\n  const colors = new Map();\n  const vertices = graph.getVertices();\n\n  if (vertices.length === 0) return colors;\n\n  // Color first vertex with color 0\n  colors.set(vertices[0], 0);\n\n  for (let i = 1; i < vertices.length; i++) {\n    const vertex = vertices[i];\n    const unavailableColors = new Set();\n\n    // Find colors used by adjacent vertices\n    for (let neighbor of graph.getNeighbors(vertex)) {\n      if (colors.has(neighbor)) {\n        unavailableColors.add(colors.get(neighbor));\n      }\n    }\n\n    // Find first available color\n    let color = 0;\n    while (unavailableColors.has(color)) {\n      color++;\n    }\n\n    colors.set(vertex, color);\n  }\n\n  return colors;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-check-if-graph-is-bipartite",children:"2. Check if Graph is Bipartite"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function isBipartite(graph) {\n  const colors = new Map();\n\n  function bfs(start) {\n    const queue = [start];\n    colors.set(start, 0);\n\n    while (queue.length > 0) {\n      const vertex = queue.shift();\n      const currentColor = colors.get(vertex);\n\n      for (let neighbor of graph.getNeighbors(vertex)) {\n        if (!colors.has(neighbor)) {\n          colors.set(neighbor, 1 - currentColor);\n          queue.push(neighbor);\n        } else if (colors.get(neighbor) === currentColor) {\n          return false; // Adjacent vertices have same color\n        }\n      }\n    }\n\n    return true;\n  }\n\n  // Check all components\n  for (let vertex of graph.getVertices()) {\n    if (!colors.has(vertex)) {\n      if (!bfs(vertex)) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,r.jsx)(n.p,{children:"Here's how to use these graph techniques:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"console.log('=== Graph Techniques Demo ===');\n\n// Create sample graph\nconst graph = new Graph();\nconst vertices = ['A', 'B', 'C', 'D', 'E'];\nvertices.forEach(v => graph.addVertex(v));\n\ngraph.addEdge('A', 'B');\ngraph.addEdge('A', 'C');\ngraph.addEdge('B', 'D');\ngraph.addEdge('C', 'D');\ngraph.addEdge('D', 'E');\n\nconsole.log('DFS Traversal:', dfsRecursive(graph, 'A'));\nconsole.log('BFS Traversal:', bfs(graph, 'A'));\nconsole.log('BFS by Levels:', bfsByLevels(graph, 'A'));\n\nconsole.log('Has Cycle (Undirected):', hasCycleUndirected(graph));\nconsole.log('Connected Components:', findConnectedComponents(graph));\n\n// Create directed graph for topological sort\nconst directedGraph = new Graph();\n['0', '1', '2', '3', '4', '5'].forEach(v => directedGraph.addVertex(v));\ndirectedGraph.addEdge('5', '2', true);\ndirectedGraph.addEdge('5', '0', true);\ndirectedGraph.addEdge('4', '0', true);\ndirectedGraph.addEdge('4', '1', true);\ndirectedGraph.addEdge('2', '3', true);\ndirectedGraph.addEdge('3', '1', true);\n\nconsole.log('Topological Sort (Kahn):', topologicalSortKahn(directedGraph));\nconsole.log('Topological Sort (DFS):', topologicalSortDFS(directedGraph));\n\nconsole.log('Is Bipartite:', isBipartite(graph));\n\n// Graph coloring\nconst coloring = greedyColoring(graph);\nconsole.log('Graph Coloring:', coloring);\n\n// Articulation points and bridges\nconsole.log('Articulation Points:', findArticulationPoints(graph));\nconsole.log('Bridges:', findBridges(graph));\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"time-complexity-summary",children:"Time Complexity Summary"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Algorithm"}),(0,r.jsx)(n.th,{children:"Time Complexity"}),(0,r.jsx)(n.th,{children:"Space Complexity"}),(0,r.jsx)(n.th,{children:"Use Case"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"DFS/BFS"}),(0,r.jsx)(n.td,{children:"O(V + E)"}),(0,r.jsx)(n.td,{children:"O(V)"}),(0,r.jsx)(n.td,{children:"Traversal, connectivity"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Dijkstra"}),(0,r.jsx)(n.td,{children:"O((V + E) log V)"}),(0,r.jsx)(n.td,{children:"O(V)"}),(0,r.jsx)(n.td,{children:"Single-source shortest path"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Bellman-Ford"}),(0,r.jsx)(n.td,{children:"O(VE)"}),(0,r.jsx)(n.td,{children:"O(V)"}),(0,r.jsx)(n.td,{children:"Shortest path with negative weights"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Floyd-Warshall"}),(0,r.jsx)(n.td,{children:"O(V\xb3)"}),(0,r.jsx)(n.td,{children:"O(V\xb2)"}),(0,r.jsx)(n.td,{children:"All-pairs shortest path"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Topological Sort"}),(0,r.jsx)(n.td,{children:"O(V + E)"}),(0,r.jsx)(n.td,{children:"O(V)"}),(0,r.jsx)(n.td,{children:"Task scheduling, dependency resolution"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Union-Find"}),(0,r.jsx)(n.td,{children:"O(\u03b1(V)) per operation"}),(0,r.jsx)(n.td,{children:"O(V)"}),(0,r.jsx)(n.td,{children:"Cycle detection, connectivity"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Kruskal's MST"}),(0,r.jsx)(n.td,{children:"O(E log E)"}),(0,r.jsx)(n.td,{children:"O(V)"}),(0,r.jsx)(n.td,{children:"Minimum spanning tree"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Prim's MST"}),(0,r.jsx)(n.td,{children:"O(E log V)"}),(0,r.jsx)(n.td,{children:"O(V)"}),(0,r.jsx)(n.td,{children:"Minimum spanning tree"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Tarjan's SCC"}),(0,r.jsx)(n.td,{children:"O(V + E)"}),(0,r.jsx)(n.td,{children:"O(V)"}),(0,r.jsx)(n.td,{children:"Strongly connected components"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Max Flow"}),(0,r.jsx)(n.td,{children:"O(VE\xb2)"}),(0,r.jsx)(n.td,{children:"O(V)"}),(0,r.jsx)(n.td,{children:"Network flow problems"})]})]})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"graph-representations-comparison",children:"Graph Representations Comparison"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Representation"}),(0,r.jsx)(n.th,{children:"Space"}),(0,r.jsx)(n.th,{children:"Add Vertex"}),(0,r.jsx)(n.th,{children:"Add Edge"}),(0,r.jsx)(n.th,{children:"Remove Vertex"}),(0,r.jsx)(n.th,{children:"Remove Edge"}),(0,r.jsx)(n.th,{children:"Check Edge"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Adjacency List"}),(0,r.jsx)(n.td,{children:"O(V + E)"}),(0,r.jsx)(n.td,{children:"O(1)"}),(0,r.jsx)(n.td,{children:"O(1)"}),(0,r.jsx)(n.td,{children:"O(V + E)"}),(0,r.jsx)(n.td,{children:"O(V)"}),(0,r.jsx)(n.td,{children:"O(V)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Adjacency Matrix"}),(0,r.jsx)(n.td,{children:"O(V\xb2)"}),(0,r.jsx)(n.td,{children:"O(V\xb2)"}),(0,r.jsx)(n.td,{children:"O(1)"}),(0,r.jsx)(n.td,{children:"O(V\xb2)"}),(0,r.jsx)(n.td,{children:"O(1)"}),(0,r.jsx)(n.td,{children:"O(1)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Edge List"}),(0,r.jsx)(n.td,{children:"O(E)"}),(0,r.jsx)(n.td,{children:"O(1)"}),(0,r.jsx)(n.td,{children:"O(1)"}),(0,r.jsx)(n.td,{children:"O(E)"}),(0,r.jsx)(n.td,{children:"O(E)"}),(0,r.jsx)(n.td,{children:"O(E)"})]})]})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"common-graph-patterns",children:"Common Graph Patterns"}),"\n",(0,r.jsxs)(n.h3,{id:"1-graph-traversal-pattern",children:["1. ",(0,r.jsx)(n.strong,{children:"Graph Traversal Pattern"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function graphTraversal(graph, start, method = 'dfs') {\n  const visited = new Set();\n  const result = [];\n\n  if (method === 'dfs') {\n    function dfs(vertex) {\n      visited.add(vertex);\n      result.push(vertex);\n\n      for (let neighbor of graph.getNeighbors(vertex)) {\n        if (!visited.has(neighbor)) {\n          dfs(neighbor);\n        }\n      }\n    }\n    dfs(start);\n  } else {\n    // BFS implementation\n    const queue = [start];\n    visited.add(start);\n\n    while (queue.length > 0) {\n      const vertex = queue.shift();\n      result.push(vertex);\n\n      for (let neighbor of graph.getNeighbors(vertex)) {\n        if (!visited.has(neighbor)) {\n          visited.add(neighbor);\n          queue.push(neighbor);\n        }\n      }\n    }\n  }\n\n  return result;\n}\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"2-path-finding-pattern",children:["2. ",(0,r.jsx)(n.strong,{children:"Path Finding Pattern"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function findPath(graph, start, end) {\n  const visited = new Set();\n  const parent = new Map();\n  const queue = [start];\n\n  visited.add(start);\n  parent.set(start, null);\n\n  while (queue.length > 0) {\n    const vertex = queue.shift();\n\n    if (vertex === end) {\n      // Reconstruct path\n      const path = [];\n      let current = end;\n      while (current !== null) {\n        path.unshift(current);\n        current = parent.get(current);\n      }\n      return path;\n    }\n\n    for (let neighbor of graph.getNeighbors(vertex)) {\n      if (!visited.has(neighbor)) {\n        visited.add(neighbor);\n        parent.set(neighbor, vertex);\n        queue.push(neighbor);\n      }\n    }\n  }\n\n  return null; // No path found\n}\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"3-component-detection-pattern",children:["3. ",(0,r.jsx)(n.strong,{children:"Component Detection Pattern"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function processAllComponents(graph, processComponent) {\n  const visited = new Set();\n  const components = [];\n\n  function dfs(vertex, component) {\n    visited.add(vertex);\n    component.push(vertex);\n\n    for (let neighbor of graph.getNeighbors(vertex)) {\n      if (!visited.has(neighbor)) {\n        dfs(neighbor, component);\n      }\n    }\n  }\n\n  for (let vertex of graph.getVertices()) {\n    if (!visited.has(vertex)) {\n      const component = [];\n      dfs(vertex, component);\n      components.push(processComponent(component));\n    }\n  }\n\n  return components;\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"advanced-problem-patterns",children:"Advanced Problem Patterns"}),"\n",(0,r.jsxs)(n.h3,{id:"1-graph-validation-problems",children:["1. ",(0,r.jsx)(n.strong,{children:"Graph Validation Problems"})]}),"\n",(0,r.jsx)(n.h4,{id:"valid-tree-n-nodes-n-1-edges-connected-no-cycles",children:"Valid Tree (N nodes, N-1 edges, connected, no cycles)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function validTree(n, edges) {\n  if (edges.length !== n - 1) return false;\n\n  const graph = new Graph();\n  for (let i = 0; i < n; i++) {\n    graph.addVertex(i);\n  }\n\n  for (let [u, v] of edges) {\n    graph.addEdge(u, v);\n  }\n\n  // Check if connected (BFS from node 0 should visit all nodes)\n  const visited = new Set();\n  const queue = [0];\n  visited.add(0);\n\n  while (queue.length > 0) {\n    const vertex = queue.shift();\n    for (let neighbor of graph.getNeighbors(vertex)) {\n      if (!visited.has(neighbor)) {\n        visited.add(neighbor);\n        queue.push(neighbor);\n      }\n    }\n  }\n\n  return visited.size === n;\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"number-of-islands",children:"Number of Islands"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function numIslands(grid) {\n  if (!grid || grid.length === 0) return 0;\n\n  const rows = grid.length;\n  const cols = grid[0].length;\n  let count = 0;\n\n  function dfs(i, j) {\n    if (i < 0 || i >= rows || j < 0 || j >= cols || grid[i][j] !== '1') {\n      return;\n    }\n\n    grid[i][j] = '0'; // Mark as visited\n\n    // Check 4 directions\n    dfs(i + 1, j);\n    dfs(i - 1, j);\n    dfs(i, j + 1);\n    dfs(i, j - 1);\n  }\n\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (grid[i][j] === '1') {\n        count++;\n        dfs(i, j);\n      }\n    }\n  }\n\n  return count;\n}\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"2-course-schedule-problems",children:["2. ",(0,r.jsx)(n.strong,{children:"Course Schedule Problems"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// Course Schedule I - Can finish all courses?\nfunction canFinish(numCourses, prerequisites) {\n  const graph = new Graph();\n\n  // Build graph\n  for (let i = 0; i < numCourses; i++) {\n    graph.addVertex(i);\n  }\n\n  for (let [course, prereq] of prerequisites) {\n    graph.addEdge(prereq, course, true); // Directed edge\n  }\n\n  // Check for cycle using DFS\n  return !hasCycleDirected(graph);\n}\n\n// Course Schedule II - Return valid order\nfunction findOrder(numCourses, prerequisites) {\n  const graph = new Graph();\n\n  // Build graph\n  for (let i = 0; i < numCourses; i++) {\n    graph.addVertex(i);\n  }\n\n  for (let [course, prereq] of prerequisites) {\n    graph.addEdge(prereq, course, true);\n  }\n\n  try {\n    return topologicalSortKahn(graph);\n  } catch (error) {\n    return []; // Has cycle\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"3-word-ladder-problem",children:["3. ",(0,r.jsx)(n.strong,{children:"Word Ladder Problem"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function ladderLength(beginWord, endWord, wordList) {\n  const wordSet = new Set(wordList);\n  if (!wordSet.has(endWord)) return 0;\n\n  const queue = [[beginWord, 1]];\n  const visited = new Set([beginWord]);\n\n  while (queue.length > 0) {\n    const [word, level] = queue.shift();\n\n    if (word === endWord) return level;\n\n    // Generate all possible next words\n    for (let i = 0; i < word.length; i++) {\n      for (let c = 0; c < 26; c++) {\n        const newChar = String.fromCharCode(97 + c); // 'a' + c\n        const newWord = word.slice(0, i) + newChar + word.slice(i + 1);\n\n        if (wordSet.has(newWord) && !visited.has(newWord)) {\n          visited.add(newWord);\n          queue.push([newWord, level + 1]);\n        }\n      }\n    }\n  }\n\n  return 0;\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"key-interview-tips",children:"Key Interview Tips"}),"\n",(0,r.jsx)(n.h3,{id:"when-to-use-each-algorithm",children:(0,r.jsx)(n.strong,{children:"When to Use Each Algorithm:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"DFS"}),": When you need to explore all paths, detect cycles, or solve puzzles"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"BFS"}),": For shortest path in unweighted graphs, level-order traversal"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Dijkstra"}),": Single-source shortest path with non-negative weights"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Bellman-Ford"}),": When graph has negative weights"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Topological Sort"}),": For dependency resolution, task scheduling"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Union-Find"}),": For dynamic connectivity, cycle detection in undirected graphs"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"common-mistakes-to-avoid",children:(0,r.jsx)(n.strong,{children:"Common Mistakes to Avoid:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Not handling disconnected graphs"}),": Always check all vertices"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Forgetting to mark vertices as visited"}),": Leads to infinite loops"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Using wrong data structure"}),": Stack for DFS, Queue for BFS"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Not considering edge cases"}),": Empty graph, single vertex, no path exists"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"optimization-techniques",children:(0,r.jsx)(n.strong,{children:"Optimization Techniques:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Path Compression in Union-Find"}),": Reduces time complexity"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Early termination"}),": Stop when target is found"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Bidirectional search"}),": For shortest path problems"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Memoization"}),": For overlapping subproblems"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"real-world-applications",children:"Real-World Applications"}),"\n",(0,r.jsx)(n.h3,{id:"social-networks",children:(0,r.jsx)(n.strong,{children:"Social Networks:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Friend recommendations (graph traversal)"}),"\n",(0,r.jsx)(n.li,{children:"Shortest connection path (BFS/Dijkstra)"}),"\n",(0,r.jsx)(n.li,{children:"Community detection (connected components)"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"transportation",children:(0,r.jsx)(n.strong,{children:"Transportation:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Route planning (shortest path algorithms)"}),"\n",(0,r.jsx)(n.li,{children:"Traffic flow optimization (max flow)"}),"\n",(0,r.jsx)(n.li,{children:"Critical road detection (bridges/articulation points)"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"computer-networks",children:(0,r.jsx)(n.strong,{children:"Computer Networks:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Network topology analysis"}),"\n",(0,r.jsx)(n.li,{children:"Routing protocols"}),"\n",(0,r.jsx)(n.li,{children:"Fault tolerance (connectivity)"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"scheduling",children:(0,r.jsx)(n.strong,{children:"Scheduling:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Task dependencies (topological sort)"}),"\n",(0,r.jsx)(n.li,{children:"Resource allocation"}),"\n",(0,r.jsx)(n.li,{children:"Project planning"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This comprehensive guide provides all the essential graph algorithms and techniques needed for coding interviews, competitive programming, and real-world applications!"})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var r=t(96540);const i={},s=r.createContext(i);function o(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);