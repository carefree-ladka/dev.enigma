"use strict";(globalThis.webpackChunkdev_enigma=globalThis.webpackChunkdev_enigma||[]).push([[66389],{28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var i=t(96540);const r={},s=i.createContext(r);function o(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(s.Provider,{value:n},e.children)}},82805:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>g,frontMatter:()=>s,metadata:()=>a,toc:()=>c});var i=t(74848),r=t(28453);const s={title:"Netflix Frontend Design",description:"Frontend system design for Netflix using RADIO framework"},o="\ud83c\udfac Netflix Frontend Design",a={id:"Frontend/System-Design/Frontend System Design/Netflix",title:"Netflix Frontend Design",description:"Frontend system design for Netflix using RADIO framework",source:"@site/docs/01-Frontend/System-Design/Frontend System Design/Netflix.mdx",sourceDirName:"01-Frontend/System-Design/Frontend System Design",slug:"/Frontend/System-Design/Frontend System Design/Netflix",permalink:"/docs/Frontend/System-Design/Frontend System Design/Netflix",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/01-Frontend/System-Design/Frontend System Design/Netflix.mdx",tags:[],version:"current",frontMatter:{title:"Netflix Frontend Design",description:"Frontend system design for Netflix using RADIO framework"},sidebar:"tutorialSidebar",previous:{title:"Instagram Feed Frontend Design",permalink:"/docs/Frontend/System-Design/Frontend System Design/Instagram"},next:{title:"RADIO Framework Cheatsheet",permalink:"/docs/Frontend/System-Design/Frontend System Design/RADIO"}},l={},c=[{value:"R - Requirements (15%)",id:"r---requirements-15",level:2},{value:"Functional Requirements",id:"functional-requirements",level:3},{value:"Non-Functional Requirements",id:"non-functional-requirements",level:3},{value:"A - Architecture (20%)",id:"a---architecture-20",level:2},{value:"Netflix&#39;s Real Architecture",id:"netflixs-real-architecture",level:3},{value:"D - Data Model (10%)",id:"d---data-model-10",level:2},{value:"I - Interface (15%)",id:"i---interface-15",level:2},{value:"O - Optimizations (40%)",id:"o---optimizations-40",level:2},{value:"Streaming Performance Architecture",id:"streaming-performance-architecture",level:3},{value:"Netflix&#39;s Real-world Performance",id:"netflixs-real-world-performance",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"-netflix-frontend-design",children:"\ud83c\udfac Netflix Frontend Design"})}),"\n",(0,i.jsx)(n.h2,{id:"r---requirements-15",children:"R - Requirements (15%)"}),"\n",(0,i.jsx)(n.h3,{id:"functional-requirements",children:"Functional Requirements"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Content Browsing"}),": 15,000+ titles, personalized rows, infinite scroll"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Video Streaming"}),": Adaptive bitrate (240p-4K), HDR support, 5.1 audio"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"User Profiles"}),": Up to 5 profiles per account, parental controls, viewing history"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Search & Discovery"}),": Real-time search, genre filtering, trending content"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Recommendations"}),": ML-powered personalization, 80% of viewing from recommendations"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Offline Downloads"}),": Mobile/tablet support, up to 100 downloads per device"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Multi-device Sync"}),": Continue watching across devices, simultaneous streams"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"non-functional-requirements",children:"Non-Functional Requirements"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Scale"}),": 230M+ subscribers, 1B+ hours watched daily"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Performance"}),": <3s page load, <10s video start time, 99.9% uptime"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Quality"}),": Adaptive streaming, <1% rebuffering rate"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Global"}),": 190+ countries, 30+ languages, regional content"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Accessibility"}),": Audio descriptions, subtitles in 20+ languages"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"a---architecture-20",children:"A - Architecture (20%)"}),"\n",(0,i.jsx)(n.mermaid,{value:'graph TB\n    User[User Device] --\x3e CDN[Netflix Open Connect CDN]\n    CDN --\x3e WebApp[Netflix Web App - React]\n    \n    WebApp --\x3e VideoPlayer[Custom Video Player]\n    WebApp --\x3e ContentCatalog[Content Discovery Engine]\n    WebApp --\x3e RecommendationEngine[ML Recommendation Engine]\n    WebApp --\x3e UserService[User Profile Service]\n    \n    VideoPlayer --\x3e StreamingService[Adaptive Streaming Service]\n    VideoPlayer --\x3e DRMService[DRM Protection Service]\n    VideoPlayer --\x3e QualitySelector[Quality Adaptation Engine]\n    \n    ContentCatalog --\x3e ContentAPI[Content Metadata API]\n    ContentCatalog --\x3e SearchService[Elasticsearch Search]\n    ContentCatalog --\x3e TrendingService[Trending Analytics]\n    \n    RecommendationEngine --\x3e MLPipeline[ML Inference Pipeline]\n    RecommendationEngine --\x3e ViewingHistory[Viewing History Service]\n    RecommendationEngine --\x3e ABTestingService[A/B Testing Platform]\n    \n    StreamingService --\x3e VideoOrigin[Video Origin Servers]\n    DRMService --\x3e LicenseServer[DRM License Server]\n    \n    subgraph "Netflix Microservices"\n        ContentAPI --\x3e ContentDB[(Content Database)]\n        ViewingHistory --\x3e AnalyticsDB[(Analytics Database)]\n        UserService --\x3e UserDB[(User Database)]\n        MLPipeline --\x3e MLModels[(ML Model Store)]\n    end\n    \n    subgraph "Global Infrastructure"\n        VideoOrigin --\x3e OpenConnect[Open Connect Appliances]\n        OpenConnect --\x3e ISPCache[ISP-level Caches]\n    end'}),"\n",(0,i.jsx)(n.h3,{id:"netflixs-real-architecture",children:"Netflix's Real Architecture"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Open Connect CDN"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"17,000+ servers in 1,000+ locations"}),"\n",(0,i.jsx)(n.li,{children:"95% of traffic served from ISP networks"}),"\n",(0,i.jsx)(n.li,{children:"Custom appliances at ISP locations"}),"\n",(0,i.jsx)(n.li,{children:"Predictive caching based on viewing patterns"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Microservices Architecture"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"700+ microservices"}),"\n",(0,i.jsx)(n.li,{children:"Service mesh with Zuul gateway"}),"\n",(0,i.jsx)(n.li,{children:"Hystrix for circuit breaking"}),"\n",(0,i.jsx)(n.li,{children:"Eureka for service discovery"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Video Delivery Pipeline"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// Netflix's Streaming Architecture\ninterface StreamingPipeline {\n  encoding: 'Multiple bitrates (240p-4K), VP9/H.264/AV1';\n  packaging: 'DASH/HLS adaptive streaming';\n  encryption: 'Widevine/PlayReady/FairPlay DRM';\n  delivery: 'Open Connect CDN';\n  adaptation: 'Client-side ABR algorithm';\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"d---data-model-10",children:"D - Data Model (10%)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// Netflix Content Structure\ninterface NetflixContent {\n  id: string;                    // Unique content ID\n  type: 'movie' | 'series' | 'documentary' | 'standup';\n  title: string;\n  description: string;\n  releaseYear: number;\n  duration?: number;             // For movies (minutes)\n  seasons?: Season[];            // For series\n  genres: Genre[];\n  maturityRating: string;        // G, PG, PG-13, R, etc.\n  languages: Language[];\n  subtitles: Language[];\n  audioTracks: AudioTrack[];\n  \n  // Metadata for recommendations\n  cast: Person[];\n  directors: Person[];\n  producers: Person[];\n  tags: string[];               // Internal tagging for ML\n  \n  // Streaming data\n  videoFiles: VideoFile[];      // Different quality versions\n  thumbnails: Thumbnail[];      // Various sizes and timestamps\n  trailers: VideoFile[];\n  \n  // Regional availability\n  regions: string[];            // Country codes where available\n  licensingInfo: LicensingInfo;\n}\n\n// Video File Structure\ninterface VideoFile {\n  quality: '240p' | '360p' | '480p' | '720p' | '1080p' | '4K';\n  bitrate: number;              // kbps\n  codec: 'H.264' | 'H.265' | 'VP9' | 'AV1';\n  url: string;                  // CDN URL\n  fileSize: number;             // bytes\n  checksum: string;             // For integrity verification\n  drmProtected: boolean;\n}\n\n// User Profile & Viewing Data\ninterface UserProfile {\n  id: string;\n  name: string;\n  avatar: string;\n  isKids: boolean;\n  language: string;\n  maturityLevel: string;\n  \n  // Viewing behavior\n  watchHistory: ViewingRecord[];\n  myList: string[];             // Saved content IDs\n  ratings: Rating[];            // User ratings\n  preferences: UserPreferences;\n  \n  // Recommendation data\n  genrePreferences: GenreWeight[];\n  actorPreferences: PersonWeight[];\n  viewingPatterns: ViewingPattern[];\n}\n\n// Viewing Analytics\ninterface ViewingRecord {\n  contentId: string;\n  profileId: string;\n  startTime: number;\n  endTime: number;\n  watchedDuration: number;      // seconds\n  totalDuration: number;        // seconds\n  completionRate: number;       // 0-1\n  device: DeviceInfo;\n  quality: string;\n  bandwidth: number;            // kbps\n  rebufferEvents: RebufferEvent[];\n  pauseEvents: PauseEvent[];\n}\n\n// Recommendation Engine Data\ninterface RecommendationContext {\n  userId: string;\n  profileId: string;\n  timeOfDay: number;\n  dayOfWeek: number;\n  device: string;\n  location: string;\n  recentViewing: string[];      // Last 10 watched content IDs\n  currentMood?: 'comedy' | 'drama' | 'action' | 'documentary';\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"i---interface-15",children:"I - Interface (15%)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// Netflix Player API\ninterface NetflixPlayer {\n  // Playback control\n  play(): Promise<void>;\n  pause(): void;\n  seek(time: number): void;\n  setPlaybackRate(rate: number): void;\n  \n  // Quality control\n  setQuality(quality: VideoQuality): void;\n  enableAutoQuality(): void;\n  getCurrentQuality(): VideoQuality;\n  getAvailableQualities(): VideoQuality[];\n  \n  // Audio/Subtitle control\n  setAudioTrack(trackId: string): void;\n  setSubtitleTrack(trackId: string): void;\n  toggleSubtitles(): void;\n  \n  // Events\n  onProgress(callback: (progress: PlaybackProgress) => void): void;\n  onQualityChange(callback: (quality: VideoQuality) => void): void;\n  onError(callback: (error: PlayerError) => void): void;\n  onBuffering(callback: (isBuffering: boolean) => void): void;\n}\n\n// Content Discovery API\ninterface ContentAPI {\n  // Browse content\n  getHomepage(profileId: string): Promise<ContentRow[]>;\n  getGenre(genreId: string, page: number): Promise<ContentPage>;\n  getTrending(region: string): Promise<Content[]>;\n  getNewReleases(): Promise<Content[]>;\n  \n  // Search\n  search(query: string, filters?: SearchFilters): Promise<SearchResult[]>;\n  getSearchSuggestions(query: string): Promise<string[]>;\n  \n  // Recommendations\n  getRecommendations(profileId: string, context: RecommendationContext): Promise<Content[]>;\n  getSimilarContent(contentId: string): Promise<Content[]>;\n  \n  // User data\n  getMyList(profileId: string): Promise<Content[]>;\n  addToMyList(profileId: string, contentId: string): Promise<void>;\n  rateContent(profileId: string, contentId: string, rating: number): Promise<void>;\n}\n\n// Streaming Service Interface\ninterface StreamingService {\n  getManifest(contentId: string, profileId: string): Promise<StreamingManifest>;\n  getLicense(contentId: string, challenge: Uint8Array): Promise<Uint8Array>;\n  reportPlaybackStats(stats: PlaybackStats): void;\n  \n  // Adaptive bitrate\n  selectInitialQuality(bandwidth: number, device: DeviceInfo): VideoQuality;\n  adaptQuality(currentStats: NetworkStats): VideoQuality;\n}\n\n// Component Interfaces\ninterface VideoPlayerProps {\n  contentId: string;\n  startTime?: number;\n  autoplay?: boolean;\n  onProgress: (progress: PlaybackProgress) => void;\n  onComplete: () => void;\n  onError: (error: PlayerError) => void;\n}\n\ninterface ContentRowProps {\n  title: string;\n  contents: Content[];\n  rowType: 'trending' | 'recommendations' | 'genre' | 'continue-watching';\n  onContentClick: (contentId: string) => void;\n  onSeeAll?: () => void;\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"o---optimizations-40",children:"O - Optimizations (40%)"}),"\n",(0,i.jsx)(n.h3,{id:"streaming-performance-architecture",children:"Streaming Performance Architecture"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"1. Adaptive Bitrate Algorithm"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"class NetflixABRAlgorithm {\n  private bandwidthHistory: number[] = [];\n  private bufferHealth: number = 0;\n  private currentQuality: VideoQuality;\n  \n  // Netflix's custom ABR logic\n  selectQuality(networkStats: NetworkStats, deviceCapabilities: DeviceInfo): VideoQuality {\n    const bandwidth = this.estimateBandwidth(networkStats);\n    const bufferLevel = this.getBufferLevel();\n    \n    // Conservative approach to avoid rebuffering\n    const safetyFactor = this.calculateSafetyFactor(bufferLevel);\n    const targetBitrate = bandwidth * safetyFactor;\n    \n    // Consider device capabilities\n    const maxSupportedQuality = this.getMaxQuality(deviceCapabilities);\n    \n    return this.selectOptimalQuality(targetBitrate, maxSupportedQuality);\n  }\n  \n  // Bandwidth estimation with multiple algorithms\n  private estimateBandwidth(stats: NetworkStats): number {\n    // Combine throughput-based and latency-based estimates\n    const throughputEstimate = this.calculateThroughput(stats);\n    const latencyAdjustment = this.adjustForLatency(stats.latency);\n    \n    return Math.min(throughputEstimate * latencyAdjustment, stats.maxBandwidth);\n  }\n  \n  // Buffer-aware quality selection\n  private calculateSafetyFactor(bufferLevel: number): number {\n    if (bufferLevel < 10) return 0.7;      // Conservative when buffer low\n    if (bufferLevel < 30) return 0.85;     // Moderate safety margin\n    return 0.95;                           // Aggressive when buffer healthy\n  }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"2. Predictive Caching System"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"class PredictiveCaching {\n  private viewingPatterns: Map<string, ViewingPattern>;\n  private popularContent: Set<string>;\n  \n  // Predict what user might watch next\n  async predictNextContent(profileId: string): Promise<string[]> {\n    const userHistory = await this.getUserHistory(profileId);\n    const timeContext = this.getTimeContext();\n    const deviceContext = this.getDeviceContext();\n    \n    // ML model inference for next content prediction\n    const predictions = await this.mlModel.predict({\n      userHistory,\n      timeContext,\n      deviceContext,\n      popularContent: Array.from(this.popularContent)\n    });\n    \n    return predictions.slice(0, 10); // Top 10 predictions\n  }\n  \n  // Preload content based on predictions\n  async preloadContent(contentIds: string[]): Promise<void> {\n    const preloadPromises = contentIds.map(async (contentId) => {\n      // Preload first few seconds of video\n      const manifest = await this.getStreamingManifest(contentId);\n      const initialSegments = manifest.segments.slice(0, 3); // First 30 seconds\n      \n      return this.preloadSegments(initialSegments);\n    });\n    \n    await Promise.allSettled(preloadPromises);\n  }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"3. Content Delivery Optimization"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"class ContentDeliveryOptimizer {\n  private cdnNodes: CDNNode[];\n  private userLocation: GeolocationData;\n  \n  // Select optimal CDN node\n  selectOptimalCDN(contentId: string): CDNNode {\n    const availableNodes = this.cdnNodes.filter(node => \n      node.hasContent(contentId) && node.isHealthy()\n    );\n    \n    return availableNodes.reduce((best, current) => {\n      const bestScore = this.calculateNodeScore(best);\n      const currentScore = this.calculateNodeScore(current);\n      return currentScore > bestScore ? current : best;\n    });\n  }\n  \n  // CDN node scoring algorithm\n  private calculateNodeScore(node: CDNNode): number {\n    const latencyScore = 1 / (node.latency + 1);           // Lower latency = higher score\n    const bandwidthScore = node.availableBandwidth / 1000;  // Higher bandwidth = higher score\n    const loadScore = 1 / (node.currentLoad + 0.1);        // Lower load = higher score\n    const proximityScore = 1 / (node.distance + 1);        // Closer = higher score\n    \n    return latencyScore * 0.3 + bandwidthScore * 0.3 + loadScore * 0.2 + proximityScore * 0.2;\n  }\n  \n  // Failover mechanism\n  async handleCDNFailure(failedNode: CDNNode, contentId: string): Promise<void> {\n    // Remove failed node from rotation\n    this.markNodeAsUnhealthy(failedNode);\n    \n    // Select backup node\n    const backupNode = this.selectOptimalCDN(contentId);\n    \n    // Seamlessly switch streaming source\n    await this.switchStreamingSource(backupNode);\n    \n    // Schedule health check for failed node\n    this.scheduleHealthCheck(failedNode);\n  }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"4. UI Performance Optimization"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"class NetflixUIOptimizer {\n  private intersectionObserver: IntersectionObserver;\n  private imageCache = new Map<string, HTMLImageElement>();\n  \n  // Lazy loading for content thumbnails\n  setupLazyLoading(): void {\n    this.intersectionObserver = new IntersectionObserver((entries) => {\n      entries.forEach(entry => {\n        if (entry.isIntersecting) {\n          this.loadContentThumbnail(entry.target as HTMLElement);\n        }\n      });\n    }, { rootMargin: '100px' }); // Load 100px before entering viewport\n  }\n  \n  // Progressive image loading\n  async loadContentThumbnail(element: HTMLElement): Promise<void> {\n    const contentId = element.dataset.contentId!;\n    const thumbnailUrl = element.dataset.thumbnailUrl!;\n    \n    // Show low-quality placeholder first\n    const placeholder = await this.loadLowQualityImage(contentId);\n    element.style.backgroundImage = `url(${placeholder})`;\n    \n    // Load high-quality image in background\n    const highQualityImage = await this.loadHighQualityImage(thumbnailUrl);\n    element.style.backgroundImage = `url(${highQualityImage.src})`;\n  }\n  \n  // Virtual scrolling for large content lists\n  implementVirtualScrolling(container: HTMLElement, items: Content[]): void {\n    const itemHeight = 200; // Height of each content item\n    const containerHeight = container.clientHeight;\n    const visibleItems = Math.ceil(containerHeight / itemHeight) + 2; // Buffer\n    \n    let scrollTop = 0;\n    \n    container.addEventListener('scroll', () => {\n      scrollTop = container.scrollTop;\n      const startIndex = Math.floor(scrollTop / itemHeight);\n      const endIndex = Math.min(startIndex + visibleItems, items.length);\n      \n      this.renderVisibleItems(items.slice(startIndex, endIndex), startIndex);\n    });\n  }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"5. Recommendation Engine Optimization"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"class RecommendationOptimizer {\n  private modelCache = new Map<string, MLModel>();\n  private featureStore: FeatureStore;\n  \n  // Real-time recommendation generation\n  async generateRecommendations(profileId: string, context: RecommendationContext): Promise<Content[]> {\n    // Get user features from feature store\n    const userFeatures = await this.featureStore.getUserFeatures(profileId);\n    const contextFeatures = this.extractContextFeatures(context);\n    \n    // Use cached model for inference\n    const model = await this.getOrLoadModel('recommendation-v2');\n    \n    // Generate recommendations\n    const scores = await model.predict({\n      userFeatures,\n      contextFeatures,\n      candidateContent: await this.getCandidateContent(profileId)\n    });\n    \n    // Apply business rules and diversity\n    return this.applyBusinessRules(scores, context);\n  }\n  \n  // A/B testing for recommendations\n  async getRecommendationVariant(profileId: string): Promise<RecommendationVariant> {\n    const userId = await this.getUserId(profileId);\n    const experimentConfig = await this.getExperimentConfig('rec-algorithm-test');\n    \n    // Consistent assignment based on user ID\n    const variant = this.assignVariant(userId, experimentConfig);\n    \n    return variant;\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"netflixs-real-world-performance",children:"Netflix's Real-world Performance"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Streaming Metrics"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Video Start Time"}),": <10s (95th percentile)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Rebuffering Rate"}),": <1% globally"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Quality Adaptation"}),": <2s switching time"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"CDN Hit Rate"}),": >95% from Open Connect"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Concurrent Streams"}),": 15M+ peak"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Infrastructure Scale"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"230M+ subscribers"})," globally"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"15,000+ titles"})," in catalog"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"1B+ hours"})," watched daily"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"17,000+ CDN servers"})," worldwide"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"700+ microservices"})," in production"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Mobile Optimizations"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Offline downloads"})," with encryption"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Adaptive UI"})," for different screen sizes"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Background playback"})," continuation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Data saver mode"})," for limited plans"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Smart downloads"})," based on WiFi availability"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Accessibility Features"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Audio descriptions"})," for visually impaired"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Closed captions"})," in 20+ languages"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"High contrast mode"})," support"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Keyboard navigation"})," optimization"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Screen reader"})," compatibility"]}),"\n"]})]})}function g(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);