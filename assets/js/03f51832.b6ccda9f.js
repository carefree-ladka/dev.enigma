"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[5459],{28453:(e,n,i)=>{i.d(n,{R:()=>t,x:()=>l});var a=i(96540);const s={},r=a.createContext(s);function t(e){const n=a.useContext(r);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),a.createElement(r.Provider,{value:n},e.children)}},50539:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>t,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>d});var a=i(74848),s=i(28453);const r={},t="Java Main Method & JVM Memory Model",l={id:"Java/Java Main Method & JVM Memory Model",title:"Java Main Method & JVM Memory Model",description:"Table of Contents",source:"@site/docs/Java/Java Main Method & JVM Memory Model.mdx",sourceDirName:"Java",slug:"/Java/Java Main Method & JVM Memory Model",permalink:"/dev.enigma/docs/Java/Java Main Method & JVM Memory Model",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/Java/Java Main Method & JVM Memory Model.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Java Language Basics - Execution, Memory & JVM",permalink:"/dev.enigma/docs/Java/Java Language Basics"},next:{title:"Java Microservices - Beginner's Guide",permalink:"/dev.enigma/docs/Java/Java Microservices - Beginner's Guide"}},o={},d=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"1. The main Method Deep Dive",id:"main-method",level:2},{value:"Why is main Special?",id:"why-is-main-special",level:3},{value:"Breakdown of Each Keyword",id:"breakdown-of-each-keyword",level:3},{value:"1. <code>public</code>",id:"1-public",level:4},{value:"2. <code>static</code>",id:"2-static",level:4},{value:"3. <code>void</code>",id:"3-void",level:4},{value:"4. <code>main</code>",id:"4-main",level:4},{value:"5. <code>String[] args</code>",id:"5-string-args",level:4},{value:"Method Overloading with main",id:"method-overloading-with-main",level:3},{value:"2. JVM Execution Process",id:"jvm-execution",level:2},{value:"Complete Flow: From Source to Execution",id:"complete-flow-from-source-to-execution",level:3},{value:"Step-by-Step Process",id:"step-by-step-process",level:3},{value:"Step 1: Compilation",id:"step-1-compilation",level:4},{value:"Step 2: Execution Launch",id:"step-2-execution-launch",level:4},{value:"Step 3: Class Loading",id:"step-3-class-loading",level:4},{value:"Step 4: JVM Verification",id:"step-4-jvm-verification",level:4},{value:"Step 5: Execution Engine",id:"step-5-execution-engine",level:4},{value:"Step 6: Finding &amp; Calling main",id:"step-6-finding--calling-main",level:4},{value:"3. JVM Memory Areas",id:"jvm-memory",level:2},{value:"Memory Structure Overview",id:"memory-structure-overview",level:3},{value:"Detailed Memory Areas",id:"detailed-memory-areas",level:3},{value:"1. Method Area (Metaspace in Java 8+)",id:"1-method-area-metaspace-in-java-8",level:4},{value:"2. Heap",id:"2-heap",level:4},{value:"3. Stack (Per Thread)",id:"3-stack-per-thread",level:4},{value:"Memory Example with Code",id:"memory-example-with-code",level:3},{value:"Memory Layout for Above Code",id:"memory-layout-for-above-code",level:3},{value:"Stack Frame Lifecycle",id:"stack-frame-lifecycle",level:3},{value:"4. Multithreading &amp; Memory Model",id:"multithreading",level:2},{value:"Thread Memory Isolation",id:"thread-memory-isolation",level:3},{value:"Thread Safety Example",id:"thread-safety-example",level:3},{value:"Race Condition Problem",id:"race-condition-problem",level:3},{value:"Solutions to Race Conditions",id:"solutions-to-race-conditions",level:3},{value:"Solution 1: Synchronized Block",id:"solution-1-synchronized-block",level:4},{value:"Solution 2: AtomicInteger",id:"solution-2-atomicinteger",level:4},{value:"Memory Model Summary",id:"memory-model-summary",level:3},{value:"Key Takeaways",id:"key-takeaways",level:3},{value:"Quick Reference",id:"quick-reference",level:2},{value:"Main Method Checklist",id:"main-method-checklist",level:3},{value:"Memory Areas",id:"memory-areas",level:3},{value:"Thread Safety Rules",id:"thread-safety-rules",level:3}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"java-main-method--jvm-memory-model",children:"Java Main Method & JVM Memory Model"})}),"\n",(0,a.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#main-method",children:"The main Method Deep Dive"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#jvm-execution",children:"JVM Execution Process"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#jvm-memory",children:"JVM Memory Areas"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#multithreading",children:"Multithreading & Memory Model"})}),"\n"]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"main-method",children:"1. The main Method Deep Dive"}),"\n",(0,a.jsx)(n.h3,{id:"why-is-main-special",children:"Why is main Special?"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"main"})," method is the entry point of any standalone Java application. When you run ",(0,a.jsx)(n.code,{children:"java MyClass"}),", the JVM specifically looks for this exact signature:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"public static void main(String[] args)\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"If missing:"})," JVM throws ",(0,a.jsx)(n.code,{children:"Error: Main method not found in class MyClass"})]}),"\n",(0,a.jsx)(n.h3,{id:"breakdown-of-each-keyword",children:"Breakdown of Each Keyword"}),"\n",(0,a.jsxs)(n.h4,{id:"1-public",children:["1. ",(0,a.jsx)(n.code,{children:"public"})]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Purpose:"})," JVM must access it from outside the class"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Impact:"})," If ",(0,a.jsx)(n.code,{children:"private"})," or ",(0,a.jsx)(n.code,{children:"protected"})," \u2192 runtime error"]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'// \u274c This won\'t work\nprivate static void main(String[] args) {\n    System.out.println("Hello World");\n}\n// JVM cannot access private methods\n'})}),"\n",(0,a.jsxs)(n.h4,{id:"2-static",children:["2. ",(0,a.jsx)(n.code,{children:"static"})]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Purpose:"})," JVM calls main without creating class instance"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Impact:"})," Belongs to class, not instance"]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'// \u2705 JVM can call directly\npublic class MyClass {\n    public static void main(String[] args) {\n        // No need for: MyClass obj = new MyClass();\n        System.out.println("Hello World");\n    }\n}\n'})}),"\n",(0,a.jsxs)(n.h4,{id:"3-void",children:["3. ",(0,a.jsx)(n.code,{children:"void"})]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Purpose:"})," main doesn't return anything"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Impact:"})," JVM just exits after execution"]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"// \u274c JVM wouldn't know what to do with return value\npublic static int main(String[] args) {\n    return 42; // What should JVM do with this?\n}\n"})}),"\n",(0,a.jsxs)(n.h4,{id:"4-main",children:["4. ",(0,a.jsx)(n.code,{children:"main"})]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Purpose:"})," Method name JVM is hardcoded to find"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Impact:"})," Execution always starts from main"]}),"\n"]}),"\n",(0,a.jsxs)(n.h4,{id:"5-string-args",children:["5. ",(0,a.jsx)(n.code,{children:"String[] args"})]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Purpose:"})," Holds command-line arguments"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Variations allowed:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"String args[]"})}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"String... args"})," (varargs)"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'public class Demo {\n    public static void main(String[] args) {\n        System.out.println("Args length: " + args.length);\n        if (args.length > 0) {\n            System.out.println("First arg: " + args[0]);\n        }\n    }\n}\n\n// Run: java Demo hello world\n// Output:\n// Args length: 2\n// First arg: hello\n'})}),"\n",(0,a.jsx)(n.h3,{id:"method-overloading-with-main",children:"Method Overloading with main"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'public class MainOverload {\n    // \u2705 JVM will call this one\n    public static void main(String[] args) {\n        System.out.println("Main with String[] args");\n        main("custom"); // Can call overloaded version\n    }\n\n    // \u2705 Valid overload, but JVM won\'t call it directly\n    public static void main(String arg) {\n        System.out.println("Overloaded main: " + arg);\n    }\n}\n'})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"jvm-execution",children:"2. JVM Execution Process"}),"\n",(0,a.jsx)(n.h3,{id:"complete-flow-from-source-to-execution",children:"Complete Flow: From Source to Execution"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Your Code (.java)\n    \u2193 javac (compilation)\nBytecode (.class)\n    \u2193 java (execution)\nJVM \u2192 Class Loader \u2192 Bytecode Verifier \u2192 Execution Engine\n    \u2193\nCalls public static void main(String[] args)\n    \u2193\nYour Program Runs \ud83c\udf89\n"})}),"\n",(0,a.jsx)(n.h3,{id:"step-by-step-process",children:"Step-by-Step Process"}),"\n",(0,a.jsx)(n.h4,{id:"step-1-compilation",children:"Step 1: Compilation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"javac MyClass.java\n# Creates MyClass.class (platform-independent bytecode)\n"})}),"\n",(0,a.jsx)(n.h4,{id:"step-2-execution-launch",children:"Step 2: Execution Launch"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"java MyClass hello world\n# Launches JVM with command-line arguments\n"})}),"\n",(0,a.jsx)(n.h4,{id:"step-3-class-loading",children:"Step 3: Class Loading"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"// Class Loader Subsystem loads classes in this order:\n// 1. BootStrap Loader \u2192 core Java classes (java.lang.String)\n// 2. Extension Loader \u2192 extended libraries\n// 3. Application Loader \u2192 your classes (MyClass)\n"})}),"\n",(0,a.jsx)(n.h4,{id:"step-4-jvm-verification",children:"Step 4: JVM Verification"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Bytecode Verifier checks for:","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Legal bytecode instructions"}),"\n",(0,a.jsx)(n.li,{children:"No memory access violations"}),"\n",(0,a.jsx)(n.li,{children:"Type safety compliance"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"step-5-execution-engine",children:"Step 5: Execution Engine"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Interpreter:"})," Executes instructions line by line"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"JIT Compiler:"})," Converts frequently used code to native machine code"]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"step-6-finding--calling-main",children:"Step 6: Finding & Calling main"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'// JVM searches for exact signature\npublic static void main(String[] args)\n\n// If found, JVM calls:\nMyClass.main(new String[]{"hello", "world"});\n'})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"jvm-memory",children:"3. JVM Memory Areas"}),"\n",(0,a.jsx)(n.h3,{id:"memory-structure-overview",children:"Memory Structure Overview"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    JVM Memory                           \u2502\n\u2502                                                         \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502\n\u2502  \u2502Method Area  \u2502  \u2502    Heap     \u2502  \u2502Stack(Thread)\u2502      \u2502\n\u2502  \u2502(Metaspace)  \u2502  \u2502             \u2502  \u2502             \u2502      \u2502\n\u2502  \u2502- Class Info \u2502  \u2502- Objects    \u2502  \u2502- Local Vars \u2502      \u2502\n\u2502  \u2502- Static Vars\u2502  \u2502- String Pool\u2502  \u2502- Method     \u2502      \u2502\n\u2502  \u2502- Bytecode   \u2502  \u2502- Arrays     \u2502  \u2502  Frames     \u2502      \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,a.jsx)(n.h3,{id:"detailed-memory-areas",children:"Detailed Memory Areas"}),"\n",(0,a.jsx)(n.h4,{id:"1-method-area-metaspace-in-java-8",children:"1. Method Area (Metaspace in Java 8+)"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Stores:"})," Class-level data"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Class definitions and metadata"}),"\n",(0,a.jsx)(n.li,{children:"Static variables and methods"}),"\n",(0,a.jsx)(n.li,{children:"Method bytecode"}),"\n",(0,a.jsx)(n.li,{children:"Constant pool"}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"2-heap",children:"2. Heap"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Stores:"})," Objects and instance data"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"All object instances"}),"\n",(0,a.jsx)(n.li,{children:"Instance variables"}),"\n",(0,a.jsx)(n.li,{children:"Arrays"}),"\n",(0,a.jsx)(n.li,{children:"String Pool (for string literals)"}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"3-stack-per-thread",children:"3. Stack (Per Thread)"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Stores:"})," Method execution data"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Local variables"}),"\n",(0,a.jsx)(n.li,{children:"Method parameters"}),"\n",(0,a.jsx)(n.li,{children:"Return addresses"}),"\n",(0,a.jsx)(n.li,{children:"References to heap objects"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"memory-example-with-code",children:"Memory Example with Code"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'public class MemoryDemo {\n    private static int staticVar = 100;  // Method Area\n\n    public static void main(String[] args) {\n        int x = 10;                      // Stack\n        String s1 = "Hello";             // String Pool (Heap)\n        String s2 = new String("World"); // Heap\n        Person p = new Person("John");   // Heap\n\n        processData(x, s1);\n    }\n\n    static void processData(int num, String text) {\n        // New stack frame created\n        int result = num * 2;            // Stack\n        System.out.println(text + ": " + result);\n    }\n}\n\nclass Person {\n    private String name;  // Instance variable (Heap)\n\n    public Person(String name) {\n        this.name = name;\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"memory-layout-for-above-code",children:"Memory Layout for Above Code"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:'Method Area:\n\u251c\u2500\u2500 MemoryDemo class metadata\n\u251c\u2500\u2500 Person class metadata\n\u251c\u2500\u2500 staticVar = 100\n\u2514\u2500\u2500 Method bytecodes (main, processData, Person constructor)\n\nHeap:\n\u251c\u2500\u2500 String Pool: "Hello"\n\u251c\u2500\u2500 new String("World") object\n\u251c\u2500\u2500 Person object { name: "John" }\n\u2514\u2500\u2500 String object "John" (for Person\'s name)\n\nStack (main thread):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 processData() frame \u2502\n\u2502 - num = 10          \u2502\n\u2502 - text \u2192 "Hello"    \u2502\n\u2502 - result = 20       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 main() frame        \u2502\n\u2502 - args[]            \u2502\n\u2502 - x = 10            \u2502\n\u2502 - s1 \u2192 "Hello"      \u2502\n\u2502 - s2 \u2192 new "World"  \u2502\n\u2502 - p \u2192 Person object \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n'})}),"\n",(0,a.jsx)(n.h3,{id:"stack-frame-lifecycle",children:"Stack Frame Lifecycle"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'public class StackExample {\n    public static void main(String[] args) {\n        System.out.println("1. main() starts - frame pushed");\n        methodA();\n        System.out.println("4. Back in main() - methodA frame popped");\n    }\n\n    static void methodA() {\n        System.out.println("2. methodA() starts - frame pushed");\n        methodB();\n        System.out.println("3. Back in methodA() - methodB frame popped");\n    }\n\n    static void methodB() {\n        System.out.println("3. methodB() executing - top frame");\n    }\n}\n\n// Stack Evolution:\n// Step 1: [main()]\n// Step 2: [main()] \u2192 [methodA()]\n// Step 3: [main()] \u2192 [methodA()] \u2192 [methodB()]\n// Step 4: [main()] \u2192 [methodA()]\n// Step 5: [main()]\n'})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"multithreading",children:"4. Multithreading & Memory Model"}),"\n",(0,a.jsx)(n.h3,{id:"thread-memory-isolation",children:"Thread Memory Isolation"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Key Principle:"})," Each thread gets its own stack, but all threads share the same heap and method area."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Thread-1 Stack    Thread-2 Stack    Shared Memory\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502Local vars   \u2502   \u2502Local vars   \u2502   \u2502   Heap      \u2502\n\u2502Method frames\u2502   \u2502Method frames\u2502   \u2502  Objects    \u2502\n\u2502             \u2502   \u2502             \u2502   \u2502             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n                                    \u2502Method Area  \u2502\n                                    \u2502 Static vars \u2502\n                                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,a.jsx)(n.h3,{id:"thread-safety-example",children:"Thread Safety Example"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"public class ThreadSafetyDemo {\n    private static int sharedCounter = 0;  // Shared in Method Area\n\n    public static void main(String[] args) throws InterruptedException {\n        Runnable task = () -> {\n            // Each thread has its own stack with local variables\n            for (int i = 0; i < 1000; i++) {  // 'i' is thread-local\n                sharedCounter++;  // RACE CONDITION - shared resource\n            }\n        };\n\n        Thread t1 = new Thread(task);\n        Thread t2 = new Thread(task);\n\n        t1.start();\n        t2.start();\n\n        t1.join();\n        t2.join();\n\n        // Expected: 2000, Actual: Often less due to race condition\n        System.out.println(\"Final Counter: \" + sharedCounter);\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"race-condition-problem",children:"Race Condition Problem"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"// What happens during sharedCounter++:\n// 1. READ current value from memory\n// 2. INCREMENT the value\n// 3. WRITE back to memory\n\n// If both threads execute simultaneously:\nThread-1: READ (0) \u2192 INCREMENT (1) \u2192 WRITE (1)\nThread-2: READ (0) \u2192 INCREMENT (1) \u2192 WRITE (1)\n// Result: 1 instead of 2 (lost update)\n"})}),"\n",(0,a.jsx)(n.h3,{id:"solutions-to-race-conditions",children:"Solutions to Race Conditions"}),"\n",(0,a.jsx)(n.h4,{id:"solution-1-synchronized-block",children:"Solution 1: Synchronized Block"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'public class SynchronizedDemo {\n    private static int counter = 0;\n    private static final Object lock = new Object();\n\n    public static void main(String[] args) throws InterruptedException {\n        Runnable task = () -> {\n            for (int i = 0; i < 1000; i++) {\n                synchronized (lock) {  // Only one thread at a time\n                    counter++;\n                }\n            }\n        };\n\n        Thread t1 = new Thread(task);\n        Thread t2 = new Thread(task);\n\n        t1.start();\n        t2.start();\n        t1.join();\n        t2.join();\n\n        System.out.println("Final Counter: " + counter); // Always 2000\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h4,{id:"solution-2-atomicinteger",children:"Solution 2: AtomicInteger"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'import java.util.concurrent.atomic.AtomicInteger;\n\npublic class AtomicDemo {\n    private static AtomicInteger counter = new AtomicInteger(0);\n\n    public static void main(String[] args) throws InterruptedException {\n        Runnable task = () -> {\n            for (int i = 0; i < 1000; i++) {\n                counter.incrementAndGet();  // Atomic operation\n            }\n        };\n\n        Thread t1 = new Thread(task);\n        Thread t2 = new Thread(task);\n\n        t1.start();\n        t2.start();\n        t1.join();\n        t2.join();\n\n        System.out.println("Final Counter: " + counter.get()); // Always 2000\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"memory-model-summary",children:"Memory Model Summary"}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Memory Area"}),(0,a.jsx)(n.th,{children:"Access"}),(0,a.jsx)(n.th,{children:"Thread Safety"}),(0,a.jsx)(n.th,{children:"Contains"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.strong,{children:"Stack"})}),(0,a.jsx)(n.td,{children:"Per-thread"}),(0,a.jsx)(n.td,{children:"Thread-safe"}),(0,a.jsx)(n.td,{children:"Local variables, method parameters"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.strong,{children:"Heap"})}),(0,a.jsx)(n.td,{children:"Shared"}),(0,a.jsx)(n.td,{children:"Needs synchronization"}),(0,a.jsx)(n.td,{children:"Objects, instance variables"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.strong,{children:"Method Area"})}),(0,a.jsx)(n.td,{children:"Shared"}),(0,a.jsx)(n.td,{children:"Needs synchronization"}),(0,a.jsx)(n.td,{children:"Static variables, class metadata"})]})]})]}),"\n",(0,a.jsx)(n.h3,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Local variables"})," are automatically thread-safe (stored in individual stacks)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Shared objects"})," in heap require synchronization"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Static variables"})," are shared across all threads"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Race conditions"})," occur when multiple threads access shared mutable state"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Synchronization mechanisms"})," (synchronized, atomic classes) ensure thread safety"]}),"\n"]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"quick-reference",children:"Quick Reference"}),"\n",(0,a.jsx)(n.h3,{id:"main-method-checklist",children:"Main Method Checklist"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\u2705 ",(0,a.jsx)(n.code,{children:"public static void main(String[] args)"})]}),"\n",(0,a.jsx)(n.li,{children:"\u2705 Exact signature required by JVM"}),"\n",(0,a.jsx)(n.li,{children:"\u2705 Entry point of application"}),"\n",(0,a.jsx)(n.li,{children:"\u2705 Can be overloaded but JVM calls String[] version"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"memory-areas",children:"Memory Areas"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\ud83c\udfd7\ufe0f ",(0,a.jsx)(n.strong,{children:"Method Area:"})," Class definitions, static variables"]}),"\n",(0,a.jsxs)(n.li,{children:["\ud83c\udfe0 ",(0,a.jsx)(n.strong,{children:"Heap:"})," Objects, instance variables (shared)"]}),"\n",(0,a.jsxs)(n.li,{children:["\ud83d\udcda ",(0,a.jsx)(n.strong,{children:"Stack:"})," Local variables, method frames (per-thread)"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"thread-safety-rules",children:"Thread Safety Rules"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\ud83d\udd12 ",(0,a.jsx)(n.strong,{children:"Stack variables:"})," Thread-safe automatically"]}),"\n",(0,a.jsxs)(n.li,{children:["\u26a0\ufe0f ",(0,a.jsx)(n.strong,{children:"Heap objects:"})," Need synchronization"]}),"\n",(0,a.jsxs)(n.li,{children:["\ud83d\udea8 ",(0,a.jsx)(n.strong,{children:"Static variables:"})," Need synchronization"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}}}]);