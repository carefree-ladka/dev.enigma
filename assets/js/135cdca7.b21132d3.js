"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[1192],{28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>a});var r=t(96540);const i={},o=r.createContext(i);function s(e){const n=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(o.Provider,{value:n},e.children)}},30950:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>o,metadata:()=>a,toc:()=>d});var r=t(74848),i=t(28453);const o={},s="TreeSet",a={id:"DSA/DSA with JavaScript/TreeSet",title:"TreeSet",description:"A self-balancing binary search tree implementation that stores unique values in sorted order.",source:"@site/docs/DSA/DSA with JavaScript/TreeSet.mdx",sourceDirName:"DSA/DSA with JavaScript",slug:"/DSA/DSA with JavaScript/TreeSet",permalink:"/dev.enigma/docs/DSA/DSA with JavaScript/TreeSet",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with JavaScript/TreeSet.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"TreeMap",permalink:"/dev.enigma/docs/DSA/DSA with JavaScript/TreeMap"},next:{title:"Trie Data Structure",permalink:"/dev.enigma/docs/DSA/DSA with JavaScript/Trie"}},l={},d=[{value:"Purpose",id:"purpose",level:3},{value:"Common Methods",id:"common-methods",level:3},{value:"Example Usage",id:"example-usage",level:3},{value:"When to Use Each",id:"when-to-use-each",level:3},{value:"Performance Comparison",id:"performance-comparison",level:3}];function h(e){const n={code:"code",h1:"h1",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"treeset",children:"TreeSet"})}),"\n",(0,r.jsx)(n.p,{children:"A self-balancing binary search tree implementation that stores unique values in sorted order."}),"\n",(0,r.jsx)(n.h3,{id:"purpose",children:"Purpose"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Maintains unique elements in sorted order"}),"\n",(0,r.jsx)(n.li,{children:"Provides efficient operations for insertion, deletion, and lookup"}),"\n",(0,r.jsx)(n.li,{children:"Guarantees O(log n) time complexity for most operations"}),"\n",(0,r.jsx)(n.li,{children:"Automatically handles duplicates"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"common-methods",children:"Common Methods"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const set = new TreeSet();\n\n// Basic Operations\nset.add(value)           // Add value to set\nset.remove(value)        // Remove value from set\nset.has(value)          // Check if value exists\nset.clear()             // Remove all values\nset.getSize()           // Get set size\nset.isEmpty()           // Check if set is empty\n\n// Navigation\nset.first()             // Get minimum value\nset.last()              // Get maximum value\nset.ceiling(value)      // Get smallest value \u2265 given value\nset.floor(value)        // Get largest value \u2264 given value\n\n// Conversion\nset.toArray()           // Convert to sorted array\n"})}),"\n",(0,r.jsx)(n.h3,{id:"example-usage",children:"Example Usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const set = new TreeSet();\nset.add(3);\nset.add(1);\nset.add(2);\n\nconsole.log(set.has(2));       // true\nconsole.log(set.ceiling(1.5)); // 2\nconsole.log(set.floor(2.5));   // 2\nconsole.log(set.toArray());    // [1, 2, 3]\n"})}),"\n",(0,r.jsx)(n.h1,{id:"treeset-implementation",children:"TreeSet Implementation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-JavaScript",children:'class TreeNode {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n    this.height = 1;\n  }\n}\n\nclass TreeSet {\n  constructor(comparator = (a, b) => a - b) {\n    this.root = null;\n    this.size = 0;\n    this.comparator = comparator;\n  }\n\n  #getHeight(node) {\n    return node ? node.height : 0;\n  }\n\n  #getBalance(node) {\n    return node ? this.#getHeight(node.left) - this.#getHeight(node.right) : 0;\n  }\n\n  #rightRotate(y) {\n    const x = y.left;\n    const T2 = x.right;\n\n    x.right = y;\n    y.left = T2;\n\n    y.height = Math.max(this.#getHeight(y.left), this.#getHeight(y.right)) + 1;\n    x.height = Math.max(this.#getHeight(x.left), this.#getHeight(x.right)) + 1;\n\n    return x;\n  }\n\n  #leftRotate(x) {\n    const y = x.right;\n    const T2 = y.left;\n\n    y.left = x;\n    x.right = T2;\n\n    x.height = Math.max(this.#getHeight(x.left), this.#getHeight(x.right)) + 1;\n    y.height = Math.max(this.#getHeight(y.left), this.#getHeight(y.right)) + 1;\n\n    return y;\n  }\n\n  // Add value to set\n  add(value) {\n    const result = !this.has(value);\n    if (result) {\n      this.root = this.#add(this.root, value);\n      this.size++;\n    }\n    return result;\n  }\n\n  #add(node, value) {\n    if (!node) return new TreeNode(value);\n\n    const cmp = this.comparator(value, node.value);\n    if (cmp < 0) {\n      node.left = this.#add(node.left, value);\n    } else if (cmp > 0) {\n      node.right = this.#add(node.right, value);\n    } else {\n      return node;\n    }\n\n    node.height = Math.max(this.#getHeight(node.left), this.#getHeight(node.right)) + 1;\n    const balance = this.#getBalance(node);\n\n    // Balance the tree\n    if (balance > 1 && this.comparator(value, node.left.value) < 0) {\n      return this.#rightRotate(node);\n    }\n    if (balance < -1 && this.comparator(value, node.right.value) > 0) {\n      return this.#leftRotate(node);\n    }\n    if (balance > 1 && this.comparator(value, node.left.value) > 0) {\n      node.left = this.#leftRotate(node.left);\n      return this.#rightRotate(node);\n    }\n    if (balance < -1 && this.comparator(value, node.right.value) < 0) {\n      node.right = this.#rightRotate(node.right);\n      return this.#leftRotate(node);\n    }\n\n    return node;\n  }\n\n  // Remove value from set\n  remove(value) {\n    const result = this.has(value);\n    if (result) {\n      this.root = this.#remove(this.root, value);\n      this.size--;\n    }\n    return result;\n  }\n\n  #remove(node, value) {\n    if (!node) return null;\n\n    const cmp = this.comparator(value, node.value);\n    if (cmp < 0) {\n      node.left = this.#remove(node.left, value);\n    } else if (cmp > 0) {\n      node.right = this.#remove(node.right, value);\n    } else {\n      if (!node.left || !node.right) {\n        return node.left || node.right;\n      }\n      const temp = this.#getMin(node.right);\n      node.value = temp.value;\n      node.right = this.#remove(node.right, temp.value);\n    }\n\n    node.height = Math.max(this.#getHeight(node.left), this.#getHeight(node.right)) + 1;\n    const balance = this.#getBalance(node);\n\n    if (balance > 1 && this.#getBalance(node.left) >= 0) {\n      return this.#rightRotate(node);\n    }\n    if (balance > 1 && this.#getBalance(node.left) < 0) {\n      node.left = this.#leftRotate(node.left);\n      return this.#rightRotate(node);\n    }\n    if (balance < -1 && this.#getBalance(node.right) <= 0) {\n      return this.#leftRotate(node);\n    }\n    if (balance < -1 && this.#getBalance(node.right) > 0) {\n      node.right = this.#rightRotate(node.right);\n      return this.#leftRotate(node);\n    }\n\n    return node;\n  }\n\n  // Check if value exists\n  has(value) {\n    return this.#find(this.root, value) !== null;\n  }\n\n  #find(node, value) {\n    if (!node) return null;\n    const cmp = this.comparator(value, node.value);\n    if (cmp === 0) return node;\n    return cmp < 0 ? this.#find(node.left, value) : this.#find(node.right, value);\n  }\n\n  #getMin(node) {\n    while (node.left) {\n      node = node.left;\n    }\n    return node;\n  }\n\n  #getMax(node) {\n    while (node.right) {\n      node = node.right;\n    }\n    return node;\n  }\n\n  // Get smallest value greater than or equal to given value\n  ceiling(value) {\n    let node = this.root;\n    let result = null;\n\n    while (node) {\n      const cmp = this.comparator(value, node.value);\n      if (cmp === 0) return node.value;\n      if (cmp < 0) {\n        result = node.value;\n        node = node.left;\n      } else {\n        node = node.right;\n      }\n    }\n\n    return result;\n  }\n\n  // Get largest value less than or equal to given value\n  floor(value) {\n    let node = this.root;\n    let result = null;\n\n    while (node) {\n      const cmp = this.comparator(value, node.value);\n      if (cmp === 0) return node.value;\n      if (cmp < 0) {\n        node = node.left;\n      } else {\n        result = node.value;\n        node = node.right;\n      }\n    }\n\n    return result;\n  }\n\n  // Get smallest value in set\n  first() {\n    return this.root ? this.#getMin(this.root).value : undefined;\n  }\n\n  // Get largest value in set\n  last() {\n    return this.root ? this.#getMax(this.root).value : undefined;\n  }\n\n  // Get set size\n  getSize() {\n    return this.size;\n  }\n\n  // Check if set is empty\n  isEmpty() {\n    return this.size === 0;\n  }\n\n  // Clear all values\n  clear() {\n    this.root = null;\n    this.size = 0;\n  }\n\n  // Convert to array (in-order traversal)\n  toArray() {\n    const result = [];\n    this.#inorderTraversal(this.root, value => result.push(value));\n    return result;\n  }\n\n  #inorderTraversal(node, callback) {\n    if (node) {\n      this.#inorderTraversal(node.left, callback);\n      callback(node.value);\n      this.#inorderTraversal(node.right, callback);\n    }\n  }\n\n  // Iterator\n  *[Symbol.iterator]() {\n    yield* this.#iterate(this.root);\n  }\n\n  *#iterate(node) {\n    if (node) {\n      yield* this.#iterate(node.left);\n      yield node.value;\n      yield* this.#iterate(node.right);\n    }\n  }\n}\n\n// TreeSet usage\nconst set = new TreeSet();\nset.add(5);\nset.add(3);\nset.add(7);\nconsole.log(set.toArray());   // [3, 5, 7]\nconsole.log(set.ceiling(4));  // 5\nconsole.log(set.floor(6));    // 5\nset.remove(5);\nconsole.log(set.toArray());   // [3, 7]\n\n// Custom comparator example\nconst strSet = new TreeSet((a, b) => a.localeCompare(b));\nstrSet.add("banana");\nstrSet.add("apple");\nstrSet.add("cherry");\nconsole.log(strSet.toArray()); // ["apple", "banana", "cherry"]\n'})}),"\n",(0,r.jsx)(n.h3,{id:"when-to-use-each",children:"When to Use Each"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"TreeSet"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Need unique values in sorted order"}),"\n",(0,r.jsx)(n.li,{children:"Large datasets with frequent modifications"}),"\n",(0,r.jsx)(n.li,{children:"Need automatic duplicate handling"}),"\n",(0,r.jsx)(n.li,{children:"Memory usage is not a primary concern"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"performance-comparison",children:"Performance Comparison"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Operation"}),(0,r.jsx)(n.th,{children:"TreeMap/Set"}),(0,r.jsx)(n.th,{children:"SortedList"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Insert"}),(0,r.jsx)(n.td,{children:"O(log n)"}),(0,r.jsx)(n.td,{children:"O(n)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Delete"}),(0,r.jsx)(n.td,{children:"O(log n)"}),(0,r.jsx)(n.td,{children:"O(n)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Search"}),(0,r.jsx)(n.td,{children:"O(log n)"}),(0,r.jsx)(n.td,{children:"O(log n)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Access"}),(0,r.jsx)(n.td,{children:"O(log n)"}),(0,r.jsx)(n.td,{children:"O(1)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Min/Max"}),(0,r.jsx)(n.td,{children:"O(log n)"}),(0,r.jsx)(n.td,{children:"O(1)"})]})]})]})]})}function c(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}}}]);