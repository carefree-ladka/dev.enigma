"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[1184],{28453:(n,e,r)=>{r.d(e,{R:()=>l,x:()=>a});var i=r(96540);const t={},s=i.createContext(t);function l(n){const e=i.useContext(s);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:l(n.components),i.createElement(s.Provider,{value:e},n.children)}},76065:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>o,contentTitle:()=>l,default:()=>u,frontMatter:()=>s,metadata:()=>a,toc:()=>d});var i=r(74848),t=r(28453);const s={},l="Divide and Conquer Technique",a={id:"DSA/DSA with JavaScript/DivideAndConquer",title:"Divide and Conquer Technique",description:"Overview",source:"@site/docs/DSA/DSA with JavaScript/DivideAndConquer.mdx",sourceDirName:"DSA/DSA with JavaScript",slug:"/DSA/DSA with JavaScript/DivideAndConquer",permalink:"/dev.enigma/docs/DSA/DSA with JavaScript/DivideAndConquer",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with JavaScript/DivideAndConquer.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Euclidean and Manhattan Distance",permalink:"/dev.enigma/docs/DSA/DSA with JavaScript/DistancesFormula"},next:{title:"Dutch National Flag Algorithm",permalink:"/dev.enigma/docs/DSA/DSA with JavaScript/DutchNationalFlag"}},o={},d=[{value:"Overview",id:"overview",level:2},{value:"Three Main Steps",id:"three-main-steps",level:2},{value:"Common Examples and Implementations",id:"common-examples-and-implementations",level:2},{value:"1. Merge Sort",id:"1-merge-sort",level:3},{value:"2. Binary Search",id:"2-binary-search",level:3},{value:"3. Maximum Subarray Sum",id:"3-maximum-subarray-sum",level:3},{value:"4. Quick Sort",id:"4-quick-sort",level:3},{value:"Time Complexity Analysis",id:"time-complexity-analysis",level:2},{value:"When to Use Divide and Conquer",id:"when-to-use-divide-and-conquer",level:2},{value:"Good Use Cases:",id:"good-use-cases",level:3},{value:"Advantages:",id:"advantages",level:3},{value:"Disadvantages:",id:"disadvantages",level:3},{value:"Implementation Template",id:"implementation-template",level:2},{value:"Count Inversions in an array",id:"count-inversions-in-an-array",level:3}];function c(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"divide-and-conquer-technique",children:"Divide and Conquer Technique"})}),"\n",(0,i.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(e.p,{children:"Divide and Conquer is an algorithmic paradigm that breaks down a problem into smaller subproblems, solves them, and then combines these solutions to create a solution to the original problem."}),"\n",(0,i.jsx)(e.h2,{id:"three-main-steps",children:"Three Main Steps"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Divide"}),": Break the problem into smaller subproblems"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Conquer"}),": Recursively solve the subproblems"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Combine"}),": Combine the solutions of subproblems to create a solution to the original problem"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"common-examples-and-implementations",children:"Common Examples and Implementations"}),"\n",(0,i.jsx)(e.h3,{id:"1-merge-sort",children:"1. Merge Sort"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function mergeSort(arr) {\n    // Base case\n    if (arr.length <= 1) return arr;\n    \n    // Divide\n    const mid = Math.floor(arr.length / 2);\n    const left = arr.slice(0, mid);\n    const right = arr.slice(mid);\n    \n    // Conquer\n    const sortedLeft = mergeSort(left);\n    const sortedRight = mergeSort(right);\n    \n    // Combine\n    return merge(sortedLeft, sortedRight);\n}\n\nfunction merge(left, right) {\n    const result = [];\n    let i = 0, j = 0;\n    \n    while (i < left.length && j < right.length) {\n        if (left[i] <= right[j]) {\n            result.push(left[i++]);\n        } else {\n            result.push(right[j++]);\n        }\n    }\n    \n    return result.concat(left.slice(i)).concat(right.slice(j));\n}\n\n// Usage\nconsole.log(mergeSort([38, 27, 43, 3, 9, 82, 10]));\n// Output: [3, 9, 10, 27, 38, 43, 82]\n"})}),"\n",(0,i.jsx)(e.h3,{id:"2-binary-search",children:"2. Binary Search"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function binarySearch(arr, target, left = 0, right = arr.length - 1) {\n    // Base case\n    if (left > right) return -1;\n    \n    // Divide\n    const mid = Math.floor((left + right) / 2);\n    \n    // Conquer\n    if (arr[mid] === target) return mid;\n    \n    if (arr[mid] > target) {\n        return binarySearch(arr, target, left, mid - 1);\n    } else {\n        return binarySearch(arr, target, mid + 1, right);\n    }\n}\n\n// Usage\nconsole.log(binarySearch([1, 2, 3, 4, 5, 6, 7], 5));\n// Output: 4\n"})}),"\n",(0,i.jsx)(e.h3,{id:"3-maximum-subarray-sum",children:"3. Maximum Subarray Sum"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function maxSubarray(arr, left = 0, right = arr.length - 1) {\n    // Base case\n    if (left === right) return arr[left];\n    \n    // Divide\n    const mid = Math.floor((left + right) / 2);\n    \n    // Conquer\n    const leftSum = maxSubarray(arr, left, mid);\n    const rightSum = maxSubarray(arr, mid + 1, right);\n    const crossSum = maxCrossingSum(arr, left, mid, right);\n    \n    // Combine\n    return Math.max(leftSum, rightSum, crossSum);\n}\n\nfunction maxCrossingSum(arr, left, mid, right) {\n    let sum = 0;\n    let leftSum = -Infinity;\n    let rightSum = -Infinity;\n    \n    // Find maximum sum for left half\n    for (let i = mid; i >= left; i--) {\n        sum += arr[i];\n        leftSum = Math.max(leftSum, sum);\n    }\n    \n    // Find maximum sum for right half\n    sum = 0;\n    for (let i = mid + 1; i <= right; i++) {\n        sum += arr[i];\n        rightSum = Math.max(rightSum, sum);\n    }\n    \n    return leftSum + rightSum;\n}\n\n// Usage\nconsole.log(maxSubarray([-2, 1, -3, 4, -1, 2, 1, -5, 4]));\n// Output: 6 (subarray [4, -1, 2, 1])\n"})}),"\n",(0,i.jsx)(e.h3,{id:"4-quick-sort",children:"4. Quick Sort"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function quickSort(arr, left = 0, right = arr.length - 1) {\n    if (left < right) {\n        // Divide\n        const pivotIndex = partition(arr, left, right);\n        \n        // Conquer\n        quickSort(arr, left, pivotIndex - 1);\n        quickSort(arr, pivotIndex + 1, right);\n    }\n    return arr;\n}\n\nfunction partition(arr, left, right) {\n    const pivot = arr[right];\n    let i = left - 1;\n    \n    for (let j = left; j < right; j++) {\n        if (arr[j] <= pivot) {\n            i++;\n            [arr[i], arr[j]] = [arr[j], arr[i]];\n        }\n    }\n    \n    [arr[i + 1], arr[right]] = [arr[right], arr[i + 1]];\n    return i + 1;\n}\n\n// Usage\nconsole.log(quickSort([64, 34, 25, 12, 22, 11, 90]));\n// Output: [11, 12, 22, 25, 34, 64, 90]\n"})}),"\n",(0,i.jsx)(e.h2,{id:"time-complexity-analysis",children:"Time Complexity Analysis"}),"\n",(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:"Algorithm"}),(0,i.jsx)(e.th,{children:"Average Case"}),(0,i.jsx)(e.th,{children:"Worst Case"}),(0,i.jsx)(e.th,{children:"Space Complexity"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"Merge Sort"}),(0,i.jsx)(e.td,{children:"O(n log n)"}),(0,i.jsx)(e.td,{children:"O(n log n)"}),(0,i.jsx)(e.td,{children:"O(n)"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"Quick Sort"}),(0,i.jsx)(e.td,{children:"O(n log n)"}),(0,i.jsx)(e.td,{children:"O(n\xb2)"}),(0,i.jsx)(e.td,{children:"O(log n)"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"Binary Search"}),(0,i.jsx)(e.td,{children:"O(log n)"}),(0,i.jsx)(e.td,{children:"O(log n)"}),(0,i.jsx)(e.td,{children:"O(1)"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"Maximum Subarray"}),(0,i.jsx)(e.td,{children:"O(n log n)"}),(0,i.jsx)(e.td,{children:"O(n log n)"}),(0,i.jsx)(e.td,{children:"O(log n)"})]})]})]}),"\n",(0,i.jsx)(e.h2,{id:"when-to-use-divide-and-conquer",children:"When to Use Divide and Conquer"}),"\n",(0,i.jsx)(e.h3,{id:"good-use-cases",children:"Good Use Cases:"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"Sorting large datasets"}),"\n",(0,i.jsx)(e.li,{children:"Searching in sorted arrays"}),"\n",(0,i.jsx)(e.li,{children:"Matrix multiplication"}),"\n",(0,i.jsx)(e.li,{children:"Finding closest pair of points"}),"\n",(0,i.jsx)(e.li,{children:"Computing Fibonacci numbers"}),"\n",(0,i.jsx)(e.li,{children:"Finding maximum/minimum"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"advantages",children:"Advantages:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Solves complex problems by breaking them down"}),"\n",(0,i.jsx)(e.li,{children:"Often leads to efficient solutions"}),"\n",(0,i.jsx)(e.li,{children:"Parallelization potential"}),"\n",(0,i.jsx)(e.li,{children:"Reusable solutions for similar problems"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"disadvantages",children:"Disadvantages:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Recursive nature can use more space"}),"\n",(0,i.jsx)(e.li,{children:"May be overkill for simple problems"}),"\n",(0,i.jsx)(e.li,{children:"Overhead in dividing and combining steps"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"implementation-template",children:"Implementation Template"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function divideAndConquer(problem) {\n    // Base case\n    if (problem is small enough) {\n        return solve(problem);\n    }\n    \n    // Divide\n    subproblems = divide(problem);\n    \n    // Conquer\n    subSolutions = subproblems.map(subproblem => \n        divideAndConquer(subproblem)\n    );\n    \n    // Combine\n    return combine(subSolutions);\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"count-inversions-in-an-array",children:"Count Inversions in an array"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-JavaScript",children:"/**\n * Problem: Count Inversions in an array\n * An inversion occurs when a[i] > a[j] where i < j\n * Uses divide and conquer approach similar to merge sort\n */\nfunction countInversions(arr) {\n    // Base case\n    if (arr.length <= 1) return { \n        sortedArr: arr, \n        count: 0 \n    };\n    \n    // Divide\n    const mid = Math.floor(arr.length / 2);\n    const left = arr.slice(0, mid);\n    const right = arr.slice(mid);\n    \n    // Conquer\n    const leftResult = countInversions(left);\n    const rightResult = countInversions(right);\n    \n    // Combine\n    return mergeAndCount(leftResult.sortedArr, rightResult.sortedArr, \n                        leftResult.count + rightResult.count);\n}\n\nfunction mergeAndCount(left, right, count) {\n    const result = [];\n    let i = 0, j = 0;\n    \n    while (i < left.length && j < right.length) {\n        if (left[i] <= right[j]) {\n            result.push(left[i++]);\n        } else {\n            // Inversion found: all elements from i to left.length are inversions\n            count += left.length - i;\n            result.push(right[j++]);\n        }\n    }\n    \n    return {\n        sortedArr: result.concat(left.slice(i)).concat(right.slice(j)),\n        count: count\n    };\n}\n\n// Example usage\nconst arr = [8, 4, 2, 1];\nconsole.log(countInversions(arr));\n// Output: { sortedArr: [1, 2, 4, 8], count: 6 }\n// Inversions are: (8,4), (8,2), (8,1), (4,2), (4,1), (2,1)\n"})})]})}function u(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(c,{...n})}):c(n)}}}]);