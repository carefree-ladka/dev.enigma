"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[38961],{28453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>t});var a=r(96540);const l={},i=a.createContext(l);function s(e){const n=a.useContext(i);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:s(e.components),a.createElement(i.Provider,{value:n},e.children)}},97098:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>h,frontMatter:()=>i,metadata:()=>t,toc:()=>c});var a=r(74848),l=r(28453);const i={},s="JavaScript Memory Management Guide",t={id:"Interview Prep 2026/JavaScript Memory Management Guide",title:"JavaScript Memory Management Guide",description:"Table of Contents",source:"@site/docs/08-Interview Prep 2026/JavaScript Memory Management Guide.mdx",sourceDirName:"08-Interview Prep 2026",slug:"/Interview Prep 2026/JavaScript Memory Management Guide",permalink:"/docs/Interview Prep 2026/JavaScript Memory Management Guide",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/08-Interview Prep 2026/JavaScript Memory Management Guide.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"JavaScript Execution Model: From Start to Finish",permalink:"/docs/Interview Prep 2026/JavaScript Execution Model: From Start to Finish"},next:{title:"JavaScript Meta Programming Guide",permalink:"/docs/Interview Prep 2026/JavaScript Meta Programming Guide"}},o={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Memory Life Cycle",id:"memory-life-cycle",level:2},{value:"Allocate Memory",id:"allocate-memory",level:3},{value:"Use Allocated Memory",id:"use-allocated-memory",level:3},{value:"Release Allocated Memory",id:"release-allocated-memory",level:3},{value:"Allocation in JavaScript",id:"allocation-in-javascript",level:2},{value:"Value Initialization",id:"value-initialization",level:3},{value:"Allocation via Function Calls",id:"allocation-via-function-calls",level:3},{value:"Using Values",id:"using-values",level:2},{value:"Memory Release",id:"memory-release",level:2},{value:"Garbage Collection",id:"garbage-collection",level:2},{value:"References",id:"references",level:3},{value:"Reference-Counting Garbage Collection",id:"reference-counting-garbage-collection",level:3},{value:"Mark-and-Sweep Algorithm",id:"mark-and-sweep-algorithm",level:3},{value:"Configuring an Engine&#39;s Memory Model",id:"configuring-an-engines-memory-model",level:2},{value:"Data Structures for Memory Management",id:"data-structures-for-memory-management",level:2},{value:"WeakMaps and WeakSets",id:"weakmaps-and-weaksets",level:3},{value:"WeakRefs and FinalizationRegistry",id:"weakrefs-and-finalizationregistry",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Additional Resources",id:"additional-resources",level:2},{value:"License",id:"license",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"javascript-memory-management-guide",children:"JavaScript Memory Management Guide"})}),"\n",(0,a.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#introduction",children:"Introduction"})}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"#memory-life-cycle",children:"Memory Life Cycle"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#allocate-memory",children:"Allocate Memory"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#use-allocated-memory",children:"Use Allocated Memory"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#release-allocated-memory",children:"Release Allocated Memory"})}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"#allocation-in-javascript",children:"Allocation in JavaScript"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#value-initialization",children:"Value Initialization"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#allocation-via-function-calls",children:"Allocation via Function Calls"})}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#using-values",children:"Using Values"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#memory-release",children:"Memory Release"})}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"#garbage-collection",children:"Garbage Collection"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#references",children:"References"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#reference-counting-garbage-collection",children:"Reference-Counting Garbage Collection"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#mark-and-sweep-algorithm",children:"Mark-and-Sweep Algorithm"})}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#configuring-an-engines-memory-model",children:"Configuring an Engine's Memory Model"})}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"#data-structures-for-memory-management",children:"Data Structures for Memory Management"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#weakmaps-and-weaksets",children:"WeakMaps and WeakSets"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#weakrefs-and-finalizationregistry",children:"WeakRefs and FinalizationRegistry"})}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#best-practices",children:"Best Practices"})}),"\n"]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,a.jsxs)(n.p,{children:["Low-level languages like C have manual memory management primitives such as ",(0,a.jsx)(n.code,{children:"malloc()"})," and ",(0,a.jsx)(n.code,{children:"free()"}),". In contrast, JavaScript automatically allocates memory when objects are created and frees it when they are not used anymore through ",(0,a.jsx)(n.strong,{children:"garbage collection"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"This automaticity can give developers the false impression that they don't need to worry about memory management. However, understanding how JavaScript manages memory is crucial for building efficient, performant applications and avoiding memory leaks."}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"memory-life-cycle",children:"Memory Life Cycle"}),"\n",(0,a.jsx)(n.p,{children:"Regardless of the programming language, the memory life cycle follows the same pattern:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Allocate"})," the memory you need"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Use"})," the allocated memory (read, write)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Release"})," the allocated memory when it is not needed anymore"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"The second part is explicit in all languages. The first and last parts are explicit in low-level languages but are mostly implicit in high-level languages like JavaScript."}),"\n",(0,a.jsx)(n.h3,{id:"allocate-memory",children:"Allocate Memory"}),"\n",(0,a.jsx)(n.p,{children:"In JavaScript, memory allocation happens automatically when you declare values, create objects, or call functions."}),"\n",(0,a.jsx)(n.h3,{id:"use-allocated-memory",children:"Use Allocated Memory"}),"\n",(0,a.jsx)(n.p,{children:"Using allocated memory involves reading and writing values, accessing object properties, or passing arguments to functions."}),"\n",(0,a.jsx)(n.h3,{id:"release-allocated-memory",children:"Release Allocated Memory"}),"\n",(0,a.jsx)(n.p,{children:"JavaScript automatically releases memory through garbage collection when it determines that memory is no longer needed."}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"allocation-in-javascript",children:"Allocation in JavaScript"}),"\n",(0,a.jsx)(n.h3,{id:"value-initialization",children:"Value Initialization"}),"\n",(0,a.jsx)(n.p,{children:"JavaScript automatically allocates memory when values are initially declared."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'// Allocates memory for a number\nconst n = 123;\n\n// Allocates memory for a string\nconst s = "string";\n\n// Allocates memory for an object and its contained values\nconst o = {\n  a: 1,\n  b: null,\n};\n\n// Allocates memory for an array and its contained values\nconst a = [1, null, "str2"];\n\n// Allocates a function (which is a callable object)\nfunction f(a) {\n  return a + 2;\n}\n\n// Function expressions also allocate an object\nsomeElement.addEventListener("click", () => {\n  someElement.style.backgroundColor = "blue";\n});\n'})}),"\n",(0,a.jsx)(n.h3,{id:"allocation-via-function-calls",children:"Allocation via Function Calls"}),"\n",(0,a.jsx)(n.p,{children:"Some function calls result in object allocation:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'// Allocates a Date object\nconst d = new Date();\n\n// Allocates a DOM element\nconst e = document.createElement("div");\n'})}),"\n",(0,a.jsx)(n.p,{children:"Some methods allocate new values or objects:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'const s = "string";\n// s2 is a new string\nconst s2 = s.substring(0, 3);\n// Since strings are immutable values,\n// JavaScript may decide to not allocate memory,\n// but just store the [0, 3] range.\n\nconst a = ["yeah yeah", "no no"];\nconst a2 = ["generation", "no no"];\n// New array with 4 elements being the concatenation\nconst a3 = a.concat(a2);\n'})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"using-values",children:"Using Values"}),"\n",(0,a.jsx)(n.p,{children:"Using values means reading and writing in allocated memory. This can be done by:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Reading or writing the value of a variable"}),"\n",(0,a.jsx)(n.li,{children:"Accessing object properties"}),"\n",(0,a.jsx)(n.li,{children:"Passing arguments to a function"}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'const obj = { name: "John" };\nconsole.log(obj.name); // Reading\nobj.name = "Jane";     // Writing\n'})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"memory-release",children:"Memory Release"}),"\n",(0,a.jsx)(n.p,{children:"The majority of memory management issues occur during the release phase. The most difficult aspect is determining when allocated memory is no longer needed."}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Low-level languages"})," require developers to manually determine when memory is no longer needed and release it explicitly."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"High-level languages"})," like JavaScript use automatic memory management known as ",(0,a.jsx)(n.strong,{children:"garbage collection (GC)"}),". The garbage collector monitors memory allocation and determines when memory is no longer needed, then reclaims it automatically."]}),"\n",(0,a.jsx)(n.p,{children:"This automatic process is an approximation because the general problem of determining whether specific memory is still needed is undecidable."}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"garbage-collection",children:"Garbage Collection"}),"\n",(0,a.jsx)(n.h3,{id:"references",children:"References"}),"\n",(0,a.jsxs)(n.p,{children:["Garbage collection algorithms rely on the concept of ",(0,a.jsx)(n.strong,{children:"reference"}),". An object is said to reference another object if the former has access to the latter (either implicitly or explicitly)."]}),"\n",(0,a.jsx)(n.p,{children:"For example:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["A JavaScript object has a reference to its ",(0,a.jsx)(n.strong,{children:"prototype"})," (implicit reference)"]}),"\n",(0,a.jsxs)(n.li,{children:["A JavaScript object has references to its ",(0,a.jsx)(n.strong,{children:"property values"})," (explicit reference)"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:'In this context, "object" extends beyond regular JavaScript objects to include function scopes and the global lexical scope.'}),"\n",(0,a.jsx)(n.h3,{id:"reference-counting-garbage-collection",children:"Reference-Counting Garbage Collection"}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Note:"})," No modern JavaScript engine uses reference-counting for garbage collection anymore."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:'This is the most na\xefve garbage collection algorithm. It reduces the problem to determining if an object has any other objects referencing it. An object is considered "garbage" if there are zero references pointing to it.'}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Example:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"let x = {\n  a: {\n    b: 2,\n  },\n};\n// 2 objects are created. One is referenced by the other as a property.\n// The other is referenced by being assigned to the 'x' variable.\n// Neither can be garbage-collected.\n\nlet y = x;\n// The 'y' variable is the second reference to the object.\n\nx = 1;\n// Now, the object originally in 'x' has a unique reference via 'y'.\n\nlet z = y.a;\n// Reference to 'a' property of the object.\n// This object now has 2 references: one as a property,\n// the other as the 'z' variable.\n\ny = \"mozilla\";\n// The object originally in 'x' now has zero references.\n// It can be garbage-collected.\n// However, its 'a' property is still referenced by 'z',\n// so it cannot be freed.\n\nz = null;\n// The 'a' property now has zero references.\n// It can be garbage collected.\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Limitation: Circular References"})}),"\n",(0,a.jsx)(n.p,{children:"Reference-counting cannot handle circular references properly:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'function f() {\n  const x = {};\n  const y = {};\n  x.a = y; // x references y\n  y.a = x; // y references x\n\n  return "azerty";\n}\n\nf();\n// After the function call, both objects go out of scope\n// but each has a reference from the other,\n// so they won\'t be garbage-collected (memory leak).\n'})}),"\n",(0,a.jsx)(n.h3,{id:"mark-and-sweep-algorithm",children:"Mark-and-Sweep Algorithm"}),"\n",(0,a.jsxs)(n.p,{children:['This algorithm reduces the definition of "an object is no longer needed" to "',(0,a.jsx)(n.strong,{children:"an object is unreachable"}),'".']}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"How it works:"})}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["The algorithm assumes knowledge of a set of objects called ",(0,a.jsx)(n.strong,{children:"roots"})," (in JavaScript, the root is the global object)"]}),"\n",(0,a.jsx)(n.li,{children:"Periodically, the garbage collector starts from these roots"}),"\n",(0,a.jsx)(n.li,{children:"It finds all objects referenced from the roots"}),"\n",(0,a.jsx)(n.li,{children:"Then finds all objects referenced from those objects, and so on"}),"\n",(0,a.jsx)(n.li,{children:"All reachable objects are marked as active"}),"\n",(0,a.jsx)(n.li,{children:"All non-reachable objects are collected"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Advantages:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"An object with zero references is effectively unreachable"}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Circular references are no longer a problem"})," \u2014 if two objects reference each other but are unreachable from the root, they will be garbage-collected"]}),"\n",(0,a.jsx)(n.li,{children:"All modern JavaScript engines use variations of this algorithm"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Example with circular references:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'function f() {\n  const x = {};\n  const y = {};\n  x.a = y;\n  y.a = x;\n  return "azerty";\n}\n\nf();\n// After the function returns, both objects are unreachable\n// from the global object, so they will be garbage-collected\n// despite the circular reference.\n'})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Limitations:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"No manual control"})," \u2014 you cannot manually trigger garbage collection or decide when memory is released"]}),"\n",(0,a.jsx)(n.li,{children:"To release an object's memory, you must make it explicitly unreachable"}),"\n",(0,a.jsx)(n.li,{children:"No programmatic way to trigger garbage collection in core JavaScript"}),"\n"]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"configuring-an-engines-memory-model",children:"Configuring an Engine's Memory Model"}),"\n",(0,a.jsx)(n.p,{children:"JavaScript engines typically offer flags that expose the memory model. For example, Node.js offers additional options for configuring and debugging memory issues. This configuration may not be available in browsers."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Increase max heap memory:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"node --max-old-space-size=6000 index.js\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Expose garbage collector for debugging:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"node --expose-gc --inspect index.js\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"data-structures-for-memory-management",children:"Data Structures for Memory Management"}),"\n",(0,a.jsx)(n.p,{children:"Although JavaScript doesn't directly expose the garbage collector API, it offers several data structures that indirectly observe garbage collection and can be used to manage memory usage."}),"\n",(0,a.jsx)(n.h3,{id:"weakmaps-and-weaksets",children:"WeakMaps and WeakSets"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"WeakMap"})," and ",(0,a.jsx)(n.code,{children:"WeakSet"})," are data structures whose APIs mirror their non-weak counterparts: ",(0,a.jsx)(n.code,{children:"Map"})," and ",(0,a.jsx)(n.code,{children:"Set"}),"."]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"WeakMap:"})," Maintains a collection of key-value pairs"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"WeakSet:"})," Maintains a collection of unique values"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Key Characteristics:"})}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Weakly held values:"})," If ",(0,a.jsx)(n.code,{children:"x"})," is weakly held by ",(0,a.jsx)(n.code,{children:"y"}),", the mark-and-sweep algorithm won't consider ",(0,a.jsx)(n.code,{children:"x"})," reachable if nothing else strongly holds to it"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Keys can only be objects or symbols"})," (not primitives)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Not iterable"})," \u2014 prevents observing object liveliness"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Example:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const wm = new WeakMap();\nconst key = {};\nwm.set(key, { data: \"value\" });\n\n// When 'key' is no longer referenced elsewhere,\n// both the key and value become eligible for garbage collection\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Circular reference handling:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const wm = new WeakMap();\nconst key = {};\nwm.set(key, { key });\n// The value references the key, but this doesn't prevent\n// garbage collection thanks to ephemerons mechanism\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Mental model (conceptual, not actual implementation):"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'class MyWeakMap {\n  #marker = Symbol("MyWeakMapData");\n\n  get(key) {\n    return key[this.#marker];\n  }\n\n  set(key, value) {\n    key[this.#marker] = value;\n  }\n\n  has(key) {\n    return this.#marker in key;\n  }\n\n  delete(key) {\n    delete key[this.#marker];\n  }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"weakrefs-and-finalizationregistry",children:"WeakRefs and FinalizationRegistry"}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Note:"})," ",(0,a.jsx)(n.code,{children:"WeakRef"})," and ",(0,a.jsx)(n.code,{children:"FinalizationRegistry"})," offer direct introspection into garbage collection machinery. Avoid using them where possible as runtime semantics are almost completely unguaranteed."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"WeakRef:"})}),"\n",(0,a.jsxs)(n.p,{children:["A ",(0,a.jsx)(n.code,{children:"WeakRef"})," is a weak reference to an object that allows the object to be garbage collected while still retaining the ability to read the object's content during its lifetime."]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Use case: Cache system"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"function cached(getter) {\n  // A Map from string URLs to WeakRefs of results\n  const cache = new Map();\n\n  return async (key) => {\n    if (cache.has(key)) {\n      const dereferencedValue = cache.get(key).deref();\n      if (dereferencedValue !== undefined) {\n        return dereferencedValue;\n      }\n    }\n    const value = await getter(key);\n    cache.set(key, new WeakRef(value));\n    return value;\n  };\n}\n\nconst getImage = cached((url) => fetch(url).then((res) => res.blob()));\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"FinalizationRegistry:"})}),"\n",(0,a.jsx)(n.p,{children:"Allows you to register objects and be notified when they are garbage collected."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Example with cleanup:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"function cached(getter) {\n  const cache = new Map();\n\n  // Callback is called with the key after value is garbage collected\n  const registry = new FinalizationRegistry((key) => {\n    // Important: test that the WeakRef is indeed empty\n    if (!cache.get(key)?.deref()) {\n      cache.delete(key);\n    }\n  });\n\n  return async (key) => {\n    if (cache.has(key)) {\n      return cache.get(key).deref();\n    }\n    const value = await getter(key);\n    cache.set(key, new WeakRef(value));\n    registry.register(value, key);\n    return value;\n  };\n}\n\nconst getImage = cached((url) => fetch(url).then((res) => res.blob()));\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Important considerations:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Due to performance and security concerns, there's ",(0,a.jsx)(n.strong,{children:"no guarantee when the callback will be called"}),", or if it will be called at all"]}),"\n",(0,a.jsx)(n.li,{children:"Should only be used for cleanup \u2014 and non-critical cleanup"}),"\n",(0,a.jsxs)(n.li,{children:["For more deterministic resource management, use ",(0,a.jsx)(n.code,{children:"try...finally"})]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"WeakRef"})," and ",(0,a.jsx)(n.code,{children:"FinalizationRegistry"})," exist solely for optimization of memory usage in long-running programs"]}),"\n"]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Avoid circular references"})," when possible, though modern engines handle them"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Nullify references"})," to large objects when no longer needed to make them explicitly unreachable"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Use WeakMap/WeakSet"})," for caches and metadata that shouldn't prevent garbage collection"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Avoid global variables"})," as they're always reachable and never garbage collected"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Be cautious with closures"})," as they can inadvertently keep references to outer scope variables"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Use event listener cleanup"})," \u2014 remove event listeners when elements are removed from DOM"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Monitor memory usage"})," in long-running applications using browser DevTools"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Avoid WeakRef/FinalizationRegistry"})," unless absolutely necessary for optimization"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Example of proper cleanup:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// Bad: memory leak\nelement.addEventListener('click', handler);\nelement.remove(); // handler still referenced\n\n// Good: proper cleanup\nelement.addEventListener('click', handler);\nelement.removeEventListener('click', handler);\nelement.remove();\n\n// Better: use AbortController for automatic cleanup\nconst controller = new AbortController();\nelement.addEventListener('click', handler, { signal: controller.signal });\ncontroller.abort(); // automatically removes listener\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"additional-resources",children:"Additional Resources"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_management",children:"MDN Web Docs - Memory Management"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://v8.dev/blog/trash-talk",children:"V8 Garbage Collection Documentation"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://nodejs.org/en/docs/guides/diagnostics/memory/",children:"Node.js Memory Management"})}),"\n"]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"license",children:"License"}),"\n",(0,a.jsx)(n.p,{children:"This content is derived from MDN Web Docs and is available under a Creative Commons license."})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);