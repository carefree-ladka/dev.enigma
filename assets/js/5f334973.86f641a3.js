"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[515],{9304:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>l,toc:()=>c});var r=t(4848),i=t(8453);const a={},o="Tree Recursion Patterns",l={id:"DSA/DSA Cheatsheets/Tree Recursion",title:"Tree Recursion Patterns",description:"Table of Contents",source:"@site/docs/DSA/DSA Cheatsheets/Tree Recursion.mdx",sourceDirName:"DSA/DSA Cheatsheets",slug:"/DSA/DSA Cheatsheets/Tree Recursion",permalink:"/js.enigma/docs/DSA/DSA Cheatsheets/Tree Recursion",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA Cheatsheets/Tree Recursion.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Strings",permalink:"/js.enigma/docs/DSA/DSA Cheatsheets/Strings"},next:{title:"Binary Tree",permalink:"/js.enigma/docs/DSA/DSA Cheatsheets/Tree"}},s={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Basic Tree Structure",id:"basic-tree-structure",level:2},{value:"Fundamental Recursion Patterns",id:"fundamental-recursion-patterns",level:2},{value:"1. Basic Traversal Template",id:"1-basic-traversal-template",level:3},{value:"2. Value Returning Template",id:"2-value-returning-template",level:3},{value:"Top-Down Recursion",id:"top-down-recursion",level:2},{value:"Example: Maximum Depth",id:"example-maximum-depth",level:3},{value:"Example: Path Sum",id:"example-path-sum",level:3},{value:"Example: Root to Leaf Paths",id:"example-root-to-leaf-paths",level:3},{value:"Bottom-Up Recursion",id:"bottom-up-recursion",level:2},{value:"Example: Maximum Depth (Bottom-Up)",id:"example-maximum-depth-bottom-up",level:3},{value:"Example: Diameter of Binary Tree",id:"example-diameter-of-binary-tree",level:3},{value:"Example: Balanced Binary Tree",id:"example-balanced-binary-tree",level:3},{value:"Divide and Conquer",id:"divide-and-conquer",level:2},{value:"Example: Merge Two Binary Trees",id:"example-merge-two-binary-trees",level:3},{value:"Example: Lowest Common Ancestor",id:"example-lowest-common-ancestor",level:3},{value:"Backtracking in Trees",id:"backtracking-in-trees",level:2},{value:"Example: All Root-to-Leaf Paths with Sum",id:"example-all-root-to-leaf-paths-with-sum",level:3},{value:"Example: Binary Tree Maximum Path Sum",id:"example-binary-tree-maximum-path-sum",level:3},{value:"Common Problem Types",id:"common-problem-types",level:2},{value:"1. Tree Validation",id:"1-tree-validation",level:3},{value:"2. Tree Construction",id:"2-tree-construction",level:3},{value:"3. Tree Serialization",id:"3-tree-serialization",level:3},{value:"Time &amp; Space Complexity",id:"time--space-complexity",level:2},{value:"Common Patterns:",id:"common-patterns",level:3},{value:"Optimization Tips:",id:"optimization-tips",level:3},{value:"Key Takeaways",id:"key-takeaways",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"tree-recursion-patterns",children:"Tree Recursion Patterns"})}),"\n",(0,r.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#basic-tree-structure",children:"Basic Tree Structure"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#fundamental-recursion-patterns",children:"Fundamental Recursion Patterns"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#top-down-recursion",children:"Top-Down Recursion"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#bottom-up-recursion",children:"Bottom-Up Recursion"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#divide-and-conquer",children:"Divide and Conquer"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#backtracking-in-trees",children:"Backtracking in Trees"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#common-problem-types",children:"Common Problem Types"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#time--space-complexity",children:"Time & Space Complexity"})}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"basic-tree-structure",children:"Basic Tree Structure"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// Binary Tree Node\nclass TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\n// N-ary Tree Node\nclass NaryNode {\n    constructor(val, children = []) {\n        this.val = val;\n        this.children = children;\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"fundamental-recursion-patterns",children:"Fundamental Recursion Patterns"}),"\n",(0,r.jsx)(n.h3,{id:"1-basic-traversal-template",children:"1. Basic Traversal Template"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function traverse(root) {\n    // Base case\n    if (!root) return;\n\n    // Process current node (preorder)\n    console.log(root.val);\n\n    // Recursive calls\n    traverse(root.left);\n    traverse(root.right);\n\n    // Process current node (postorder)\n    // console.log(root.val);\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-value-returning-template",children:"2. Value Returning Template"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function processTree(root) {\n    // Base case\n    if (!root) return null; // or appropriate default value\n\n    // Get results from children\n    const leftResult = processTree(root.left);\n    const rightResult = processTree(root.right);\n\n    // Combine results with current node\n    return combineResults(root.val, leftResult, rightResult);\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"top-down-recursion",children:"Top-Down Recursion"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Pattern"}),": Pass information down from parent to children. Good for path-based problems."]}),"\n",(0,r.jsx)(n.h3,{id:"example-maximum-depth",children:"Example: Maximum Depth"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function maxDepth(root) {\n    function dfs(node, depth) {\n        if (!node) return depth;\n\n        const leftDepth = dfs(node.left, depth + 1);\n        const rightDepth = dfs(node.right, depth + 1);\n\n        return Math.max(leftDepth, rightDepth);\n    }\n\n    return dfs(root, 0);\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"example-path-sum",children:"Example: Path Sum"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function hasPathSum(root, targetSum) {\n    function dfs(node, currentSum) {\n        if (!node) return false;\n\n        currentSum += node.val;\n\n        // Leaf node check\n        if (!node.left && !node.right) {\n            return currentSum === targetSum;\n        }\n\n        return dfs(node.left, currentSum) || dfs(node.right, currentSum);\n    }\n\n    return dfs(root, 0);\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"example-root-to-leaf-paths",children:"Example: Root to Leaf Paths"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function binaryTreePaths(root) {\n    const result = [];\n\n    function dfs(node, path) {\n        if (!node) return;\n\n        path.push(node.val);\n\n        // Leaf node\n        if (!node.left && !node.right) {\n            result.push(path.join('->'));\n        } else {\n            dfs(node.left, [...path]); // Create new array\n            dfs(node.right, [...path]);\n        }\n    }\n\n    dfs(root, []);\n    return result;\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"bottom-up-recursion",children:"Bottom-Up Recursion"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Pattern"}),": Gather information from children and bubble up. Good for tree property problems."]}),"\n",(0,r.jsx)(n.h3,{id:"example-maximum-depth-bottom-up",children:"Example: Maximum Depth (Bottom-Up)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function maxDepth(root) {\n    if (!root) return 0;\n\n    const leftDepth = maxDepth(root.left);\n    const rightDepth = maxDepth(root.right);\n\n    return Math.max(leftDepth, rightDepth) + 1;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"example-diameter-of-binary-tree",children:"Example: Diameter of Binary Tree"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function diameterOfBinaryTree(root) {\n    let maxDiameter = 0;\n\n    function height(node) {\n        if (!node) return 0;\n\n        const leftHeight = height(node.left);\n        const rightHeight = height(node.right);\n\n        // Update diameter at current node\n        maxDiameter = Math.max(maxDiameter, leftHeight + rightHeight);\n\n        return Math.max(leftHeight, rightHeight) + 1;\n    }\n\n    height(root);\n    return maxDiameter;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"example-balanced-binary-tree",children:"Example: Balanced Binary Tree"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function isBalanced(root) {\n    function checkBalance(node) {\n        if (!node) return { balanced: true, height: 0 };\n\n        const left = checkBalance(node.left);\n        const right = checkBalance(node.right);\n\n        const balanced = left.balanced &&\n                        right.balanced &&\n                        Math.abs(left.height - right.height) <= 1;\n\n        return {\n            balanced,\n            height: Math.max(left.height, right.height) + 1\n        };\n    }\n\n    return checkBalance(root).balanced;\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"divide-and-conquer",children:"Divide and Conquer"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Pattern"}),": Split problem into subproblems, solve independently, then combine."]}),"\n",(0,r.jsx)(n.h3,{id:"example-merge-two-binary-trees",children:"Example: Merge Two Binary Trees"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function mergeTrees(root1, root2) {\n    // Base cases\n    if (!root1) return root2;\n    if (!root2) return root1;\n\n    // Combine current nodes\n    root1.val += root2.val;\n\n    // Recursively merge subtrees\n    root1.left = mergeTrees(root1.left, root2.left);\n    root1.right = mergeTrees(root1.right, root2.right);\n\n    return root1;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"example-lowest-common-ancestor",children:"Example: Lowest Common Ancestor"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function lowestCommonAncestor(root, p, q) {\n    if (!root || root === p || root === q) {\n        return root;\n    }\n\n    const left = lowestCommonAncestor(root.left, p, q);\n    const right = lowestCommonAncestor(root.right, p, q);\n\n    // If both sides return non-null, current node is LCA\n    if (left && right) return root;\n\n    // Return whichever side found a target\n    return left || right;\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"backtracking-in-trees",children:"Backtracking in Trees"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Pattern"}),": Explore paths and undo choices. Good for finding all solutions."]}),"\n",(0,r.jsx)(n.h3,{id:"example-all-root-to-leaf-paths-with-sum",children:"Example: All Root-to-Leaf Paths with Sum"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function pathSumII(root, targetSum) {\n    const result = [];\n\n    function backtrack(node, path, currentSum) {\n        if (!node) return;\n\n        // Add current node to path\n        path.push(node.val);\n        currentSum += node.val;\n\n        // Check if we found a valid path\n        if (!node.left && !node.right && currentSum === targetSum) {\n            result.push([...path]); // Create copy\n        }\n\n        // Explore children\n        backtrack(node.left, path, currentSum);\n        backtrack(node.right, path, currentSum);\n\n        // Backtrack: remove current node\n        path.pop();\n    }\n\n    backtrack(root, [], 0);\n    return result;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"example-binary-tree-maximum-path-sum",children:"Example: Binary Tree Maximum Path Sum"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function maxPathSum(root) {\n    let maxSum = -Infinity;\n\n    function maxGain(node) {\n        if (!node) return 0;\n\n        // Get maximum gain from left and right subtrees\n        const leftGain = Math.max(maxGain(node.left), 0);\n        const rightGain = Math.max(maxGain(node.right), 0);\n\n        // Current path sum including this node as highest point\n        const currentMax = node.val + leftGain + rightGain;\n        maxSum = Math.max(maxSum, currentMax);\n\n        // Return max gain if we continue path through this node\n        return node.val + Math.max(leftGain, rightGain);\n    }\n\n    maxGain(root);\n    return maxSum;\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"common-problem-types",children:"Common Problem Types"}),"\n",(0,r.jsx)(n.h3,{id:"1-tree-validation",children:"1. Tree Validation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function isValidBST(root) {\n    function validate(node, min, max) {\n        if (!node) return true;\n\n        if (node.val <= min || node.val >= max) return false;\n\n        return validate(node.left, min, node.val) &&\n               validate(node.right, node.val, max);\n    }\n\n    return validate(root, -Infinity, Infinity);\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-tree-construction",children:"2. Tree Construction"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function buildTree(preorder, inorder) {\n    if (!preorder.length || !inorder.length) return null;\n\n    const rootVal = preorder[0];\n    const root = new TreeNode(rootVal);\n\n    const rootIndex = inorder.indexOf(rootVal);\n\n    root.left = buildTree(\n        preorder.slice(1, rootIndex + 1),\n        inorder.slice(0, rootIndex)\n    );\n\n    root.right = buildTree(\n        preorder.slice(rootIndex + 1),\n        inorder.slice(rootIndex + 1)\n    );\n\n    return root;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"3-tree-serialization",children:"3. Tree Serialization"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function serialize(root) {\n    const result = [];\n\n    function preorder(node) {\n        if (!node) {\n            result.push('null');\n            return;\n        }\n\n        result.push(node.val.toString());\n        preorder(node.left);\n        preorder(node.right);\n    }\n\n    preorder(root);\n    return result.join(',');\n}\n\nfunction deserialize(data) {\n    const values = data.split(',');\n    let index = 0;\n\n    function buildTree() {\n        if (values[index] === 'null') {\n            index++;\n            return null;\n        }\n\n        const node = new TreeNode(parseInt(values[index]));\n        index++;\n\n        node.left = buildTree();\n        node.right = buildTree();\n\n        return node;\n    }\n\n    return buildTree();\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"time--space-complexity",children:"Time & Space Complexity"}),"\n",(0,r.jsx)(n.h3,{id:"common-patterns",children:"Common Patterns:"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Time Complexity:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Simple Traversal"}),": O(n) - visit each node once"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Path Finding"}),": O(n) - might visit all nodes"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Tree Construction"}),": O(n) - process each element once"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Validation"}),": O(n) - check all nodes"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Space Complexity:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Recursive Stack"}),": O(h) where h is tree height","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Balanced tree: O(log n)"}),"\n",(0,r.jsx)(n.li,{children:"Skewed tree: O(n)"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Result Storage"}),": Depends on problem (paths, values, etc.)"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"optimization-tips",children:"Optimization Tips:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Early Termination"}),": Return immediately when answer is found"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Memoization"}),": Cache results for overlapping subproblems"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Iterative Alternatives"}),": Use stack/queue to avoid recursion stack"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"In-place Modifications"}),": Modify existing tree instead of creating new one"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// Example: Early termination in search\nfunction findTarget(root, target) {\n    if (!root) return false;\n    if (root.val === target) return true; // Found it!\n\n    return findTarget(root.left, target) || findTarget(root.right, target);\n}\n\n// Example: Iterative traversal to save space\nfunction maxDepthIterative(root) {\n    if (!root) return 0;\n\n    const stack = [[root, 1]];\n    let maxDepth = 0;\n\n    while (stack.length) {\n        const [node, depth] = stack.pop();\n        maxDepth = Math.max(maxDepth, depth);\n\n        if (node.left) stack.push([node.left, depth + 1]);\n        if (node.right) stack.push([node.right, depth + 1]);\n    }\n\n    return maxDepth;\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Identify the pattern"}),": Top-down vs Bottom-up vs Divide & Conquer"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Define base cases"}),": What happens with null nodes?"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Recursive relation"}),": How do you combine results from children?"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"State management"}),": What information needs to be passed down or up?"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Optimization"}),": Can you terminate early or avoid redundant work?"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Remember: Most tree problems follow these fundamental patterns. Master these templates and you can solve a wide variety of tree-related challenges!"})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>l});var r=t(6540);const i={},a=r.createContext(i);function o(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);