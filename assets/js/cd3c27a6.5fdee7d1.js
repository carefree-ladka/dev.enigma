"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[59312],{28413:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>d});var r=t(74848),i=t(28453);const s={title:"Trie Data Structure"},o=void 0,a={id:"DSA/DSA/DSA with JavaScript/Trie",title:"Trie Data Structure",description:"Trie Data Structure",source:"@site/docs/05-DSA/DSA/DSA with JavaScript/Trie.mdx",sourceDirName:"05-DSA/DSA/DSA with JavaScript",slug:"/DSA/DSA/DSA with JavaScript/Trie",permalink:"/docs/DSA/DSA/DSA with JavaScript/Trie",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/05-DSA/DSA/DSA with JavaScript/Trie.mdx",tags:[],version:"current",frontMatter:{title:"Trie Data Structure"},sidebar:"tutorialSidebar",previous:{title:"TreeSet",permalink:"/docs/DSA/DSA/DSA with JavaScript/TreeSet"},next:{title:"Two Pointers Technique",permalink:"/docs/DSA/DSA/DSA with JavaScript/TwoPointers"}},c={},d=[{value:"Trie Data Structure",id:"trie-data-structure",level:2},{value:"Key Concepts",id:"key-concepts",level:3},{value:"Operations",id:"operations",level:3},{value:"Code Implementation",id:"code-implementation",level:3},{value:"XOR Trie",id:"xor-trie",level:2},{value:"File System",id:"file-system",level:2}];function l(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"trie-data-structure",children:"Trie Data Structure"}),"\n",(0,r.jsx)(n.p,{children:"A Trie, also known as a prefix tree or digital tree, is a specialized tree used to store associative data structures. It is commonly used for storing strings or sequences where it can efficiently support operations like insertion, deletion, and prefix search."}),"\n",(0,r.jsx)(n.h3,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Nodes"}),": Each node represents a character of the stored strings."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Edges"}),": The edges between nodes represent the transitions from one character to the next."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Root"}),": The root node represents the starting point of the Trie and does not store any character."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"operations",children:"Operations"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Insertion"}),": Add a new string to the Trie."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Search"}),": Check if a string exists in the Trie."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Prefix Search"}),": Find all strings that share a common prefix."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Deletion"}),": Remove a string from the Trie."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"code-implementation",children:"Code Implementation"}),"\n",(0,r.jsx)(n.p,{children:"Here's a basic implementation of a Trie in JavaScript:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-JavaScript",children:"class TrieNode {\n  children = {};\n  isEnd = false;\n}\n\nclass Trie {\n  root = new TrieNode();\n\n  // Inserts a word into the trie\n  insert = (word) => {\n    let node = this.root;\n\n    for (const char of word) {\n      node = node.children[char] ??= new TrieNode();\n    }\n    node.isEnd = true; // Mark the word as complete\n  };\n\n  search = (word) => {\n    let node = this.root;\n\n    for (const char of word) {\n      if (!node.children[char]) return false; // If the character doesn't exist, return false\n      node = node.children[char];\n    }\n    return node.isEnd; // Check if this is the end of a complete word\n  };\n\n  startsWith = (prefix) => {\n    let node = this.root;\n\n    for (const char of prefix) {\n      if (!node.children[char]) return false;\n      node = node.children[char];\n    }\n    return true;\n  };\n\n  remove = (word) => {\n    let root = this.root;\n    const path = [];\n\n    // Search and track path\n    for (const c of word) {\n      path.push([root, c]);\n      if (!root.children[c]) return false;\n      root = root.children[c];\n    }\n\n    // Check if word exists\n    if (!root.isEnd) return false;\n    root.isEnd = false;\n\n    // Keep node if has children\n    if (Object.keys(root.children).length > 0) return true;\n\n    // Backtrack and trim branches\n    while (path.length) {\n      const [node, c] = path.pop();\n      delete node.children[c];\n      if (Object.keys(node.children).length > 0) break;\n    }\n\n    return true;\n  };\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"xor-trie",children:"XOR Trie"}),"\n",(0,r.jsx)(n.p,{children:"A XOR Trie is a data structure specifically designed for efficiently solving problems related to finding the maximum XOR of numbers in an array, subarray XOR queries, or other XOR-related tasks."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-JavaScript",children:"class XORTrie {\n  root = {};\n\n  // Insert a number into the trie\n  insert = (num) => {\n    let node = this.root;\n    for (let i = 31; i >= 0; i--) {\n      const bit = (num >> i) & 1; // Extract the i-th bit\n      if (!node[bit]) {\n        node[bit] = {}; // Create a new branch if it doesn't exist\n      }\n      node = node[bit];\n    }\n  }\n\n  // Find the maximum XOR of a given number with the trie\n  findMaxXOR = (num) => {\n    let node = this.root;\n    let maxXOR = 0;\n    for (let i = 31; i >= 0; i--) {\n      const bit = (num >> i) & 1; // Extract the i-th bit\n      const oppositeBit = 1 - bit; // XOR maximization prefers the opposite bit\n      if (node[oppositeBit]) {\n        maxXOR = (maxXOR << 1) | 1; // Add 1 to maxXOR (prefer opposite bit)\n        node = node[oppositeBit];\n      } else {\n        maxXOR = maxXOR << 1; // Add 0 to maxXOR\n        node = node[bit];\n      }\n    }\n    return maxXOR;\n  }\n}\n\n// Example usage\nconst nums = [3, 10, 5, 25, 2, 8];\nconst xorTrie = new XORTrie();\n\n// Insert all numbers into the trie\nnums.forEach(num => xorTrie.insert(num));\n\n// Find the maximum XOR of any pair in the array\nconsole.log(nums.reduce((maxXor, num) => Math.max(maxXor, xorTrie.findMaxXOR(num)), 0)); // Output: 28\n"})}),"\n",(0,r.jsx)(n.h2,{id:"file-system",children:"File System"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-JavaScript",children:"class TrieNode {\n  constructor() {\n    this.children = {}; // Stores directories/files\n    this.isFile = false;\n  }\n}\n\nclass FileSystemTrie {\n  constructor() {\n    this.root = new TrieNode();\n  }\n\n  // Insert a file or directory\n  insert(path, isFile = false) {\n    const parts = path.split('/').filter(Boolean);\n    let node = this.root;\n\n    for (const part of parts) {\n      if (!node.children[part]) {\n        node.children[part] = new TrieNode();\n      }\n      node = node.children[part];\n    }\n    node.isFile = isFile;\n  }\n\n  // Search files with a given pattern (backtracking)\n  searchFiles(pattern, node = this.root, path = '', results = []) {\n    for (const [key, child] of Object.entries(node.children)) {\n      const newPath = path ? `${path}/${key}` : key;\n\n      if (child.isFile && key.includes(pattern)) {\n        results.push(newPath);\n      }\n      this.searchFiles(pattern, child, newPath, results);\n    }\n    return results;\n  }\n}\n\n// Example Usage\nconst fs = new FileSystemTrie();\n\nfs.insert('/home/user/documents', false);\nfs.insert('/home/user/documents/resume.pdf', true);\nfs.insert('/home/user/documents/report.docx', true);\nfs.insert('/home/user/photos/vacation.jpg', true);\nfs.insert('/home/user/photos/selfie.png', true);\nfs.insert('/home/user/notes.txt', true);\n\nconsole.log(fs.searchFiles('doc'));  // Finds \"report.docx\"\nconsole.log(fs.searchFiles('res'));  // Finds \"resume.pdf\"\nconsole.log(fs.searchFiles('.jpg')); // Finds \"vacation.jpg\"\n"})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var r=t(96540);const i={},s=r.createContext(i);function o(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);