"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[34837],{14289:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>o,contentTitle:()=>a,default:()=>u,frontMatter:()=>s,metadata:()=>l,toc:()=>c});var t=i(74848),r=i(28453);const s={},a="Sorting Algorithms Guide",l={id:"DSA/DSA with Java/Sorting Algorithms",title:"Sorting Algorithms Guide",description:"A comprehensive guide to essential sorting algorithms for Data Structures and Algorithms interviews, implemented in Java.",source:"@site/docs/DSA/DSA with Java/Sorting Algorithms.mdx",sourceDirName:"DSA/DSA with Java",slug:"/DSA/DSA with Java/Sorting Algorithms",permalink:"/docs/DSA/DSA with Java/Sorting Algorithms",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with Java/Sorting Algorithms.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Sliding Window",permalink:"/docs/DSA/DSA with Java/Sliding Window"},next:{title:"Stack",permalink:"/docs/DSA/DSA with Java/Stack Patterns"}},o={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Merge Sort",id:"merge-sort",level:2},{value:"Overview",id:"overview",level:3},{value:"When to Use Merge Sort",id:"when-to-use-merge-sort",level:3},{value:"Basic Implementation",id:"basic-implementation",level:3},{value:"Iterative Merge Sort (Bottom-Up)",id:"iterative-merge-sort-bottom-up",level:3},{value:"Merge Sort for Linked Lists",id:"merge-sort-for-linked-lists",level:3},{value:"Merge Sort Applications",id:"merge-sort-applications",level:3},{value:"1. Count Inversions",id:"1-count-inversions",level:4},{value:"2. Merge K Sorted Arrays",id:"2-merge-k-sorted-arrays",level:4},{value:"Quick Sort",id:"quick-sort",level:2},{value:"Overview",id:"overview-1",level:3},{value:"When to Use Quick Sort",id:"when-to-use-quick-sort",level:3},{value:"Basic Implementation (Lomuto Partition)",id:"basic-implementation-lomuto-partition",level:3},{value:"Hoare Partition Scheme",id:"hoare-partition-scheme",level:3},{value:"Randomized Quick Sort",id:"randomized-quick-sort",level:3},{value:"3-Way Quick Sort (Dutch National Flag)",id:"3-way-quick-sort-dutch-national-flag",level:3},{value:"Iterative Quick Sort",id:"iterative-quick-sort",level:3},{value:"Quick Sort Applications",id:"quick-sort-applications",level:3},{value:"1. Quick Select (Find Kth Smallest Element)",id:"1-quick-select-find-kth-smallest-element",level:4},{value:"2. Find Top K Elements",id:"2-find-top-k-elements",level:4},{value:"3. Sort Colors (3-Way Partitioning)",id:"3-sort-colors-3-way-partitioning",level:4},{value:"Optimizations",id:"optimizations",level:3},{value:"1. Hybrid Quick Sort (with Insertion Sort for small arrays)",id:"1-hybrid-quick-sort-with-insertion-sort-for-small-arrays",level:4},{value:"2. Median-of-Three Pivot Selection",id:"2-median-of-three-pivot-selection",level:4},{value:"Cyclic Sort",id:"cyclic-sort",level:2},{value:"Overview",id:"overview-2",level:3},{value:"When to Use Cyclic Sort",id:"when-to-use-cyclic-sort",level:3},{value:"Core Algorithm",id:"core-algorithm",level:3},{value:"Cyclic Sort Variations",id:"cyclic-sort-variations",level:3},{value:"For 0-indexed arrays (numbers 0 to n-1)",id:"for-0-indexed-arrays-numbers-0-to-n-1",level:4},{value:"Cyclic Sort Problems",id:"cyclic-sort-problems",level:3},{value:"1. Find Missing Number",id:"1-find-missing-number",level:4},{value:"2. Find All Missing Numbers",id:"2-find-all-missing-numbers",level:4},{value:"3. Find Duplicate Number",id:"3-find-duplicate-number",level:4},{value:"4. First Missing Positive",id:"4-first-missing-positive",level:4},{value:"Counting Sort",id:"counting-sort",level:2},{value:"Overview",id:"overview-3",level:3},{value:"When to Use Counting Sort",id:"when-to-use-counting-sort",level:3},{value:"Basic Implementation",id:"basic-implementation-1",level:3},{value:"Counting Sort for Negative Numbers",id:"counting-sort-for-negative-numbers",level:3},{value:"Counting Sort Problems",id:"counting-sort-problems",level:3},{value:"1. Sort Colors (Dutch National Flag)",id:"1-sort-colors-dutch-national-flag",level:4},{value:"2. Character Frequency Sort",id:"2-character-frequency-sort",level:4},{value:"Bucket Sort",id:"bucket-sort",level:2},{value:"Overview",id:"overview-4",level:3},{value:"When to Use Bucket Sort",id:"when-to-use-bucket-sort",level:3},{value:"Basic Implementation",id:"basic-implementation-2",level:3},{value:"Bucket Sort for Integers",id:"bucket-sort-for-integers",level:3},{value:"Bucket Sort Problems",id:"bucket-sort-problems",level:3},{value:"1. Top K Frequent Elements",id:"1-top-k-frequent-elements",level:4},{value:"2. Maximum Gap",id:"2-maximum-gap",level:4},{value:"Problem Patterns &amp; Applications",id:"problem-patterns--applications",level:2},{value:"Cyclic Sort Pattern Problems",id:"cyclic-sort-pattern-problems",level:3},{value:"Counting Sort Pattern Problems",id:"counting-sort-pattern-problems",level:3},{value:"Bucket Sort Pattern Problems",id:"bucket-sort-pattern-problems",level:3},{value:"Comparison &amp; When to Use",id:"comparison--when-to-use",level:2},{value:"Decision Framework",id:"decision-framework",level:3},{value:"Advanced Problems",id:"advanced-problems",level:2},{value:"1. Find Corrupt Pair (Cyclic Sort)",id:"1-find-corrupt-pair-cyclic-sort",level:3},{value:"2. Radix Sort (Using Counting Sort)",id:"2-radix-sort-using-counting-sort",level:3},{value:"3. Merge Intervals (Merge Sort Application)",id:"3-merge-intervals-merge-sort-application",level:3},{value:"4. Kth Largest Element in Array (Quick Select)",id:"4-kth-largest-element-in-array-quick-select",level:3},{value:"5. Sort Array by Increasing Frequency (Bucket Sort)",id:"5-sort-array-by-increasing-frequency-bucket-sort",level:3},{value:"Implementation Tips",id:"implementation-tips",level:2},{value:"Merge Sort Tips",id:"merge-sort-tips",level:3},{value:"Quick Sort Tips",id:"quick-sort-tips",level:3},{value:"Cyclic Sort Tips",id:"cyclic-sort-tips",level:3},{value:"Counting Sort Tips",id:"counting-sort-tips",level:3},{value:"Bucket Sort Tips",id:"bucket-sort-tips",level:3}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"sorting-algorithms-guide",children:"Sorting Algorithms Guide"})}),"\n",(0,t.jsx)(e.p,{children:"A comprehensive guide to essential sorting algorithms for Data Structures and Algorithms interviews, implemented in Java."}),"\n",(0,t.jsx)(e.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#merge-sort",children:"Merge Sort"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#quick-sort",children:"Quick Sort"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#cyclic-sort",children:"Cyclic Sort"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#counting-sort",children:"Counting Sort"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#bucket-sort",children:"Bucket Sort"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#problem-patterns--applications",children:"Problem Patterns & Applications"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#comparison--when-to-use",children:"Comparison & When to Use"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#advanced-problems",children:"Advanced Problems"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#implementation-tips",children:"Implementation Tips"})}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"merge-sort",children:"Merge Sort"}),"\n",(0,t.jsx)(e.h3,{id:"overview",children:"Overview"}),"\n",(0,t.jsxs)(e.p,{children:["Merge Sort is a stable, divide-and-conquer sorting algorithm that consistently performs in ",(0,t.jsx)(e.strong,{children:"O(n log n)"})," time. It recursively divides the array into smaller subarrays, sorts them, and merges them back together in sorted order."]}),"\n",(0,t.jsx)(e.h3,{id:"when-to-use-merge-sort",children:"When to Use Merge Sort"}),"\n",(0,t.jsxs)(e.p,{children:["\u2705 ",(0,t.jsx)(e.strong,{children:"Perfect for:"})]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"When stability is required (maintains relative order of equal elements)"}),"\n",(0,t.jsx)(e.li,{children:"Large datasets where worst-case performance matters"}),"\n",(0,t.jsx)(e.li,{children:"Linked lists (no random access needed)"}),"\n",(0,t.jsx)(e.li,{children:"External sorting (data that doesn't fit in memory)"}),"\n",(0,t.jsx)(e.li,{children:"Guaranteed O(n log n) performance requirement"}),"\n",(0,t.jsx)(e.li,{children:"Parallel processing scenarios"}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:["\u274c ",(0,t.jsx)(e.strong,{children:"Not suitable for:"})]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Small arrays (overhead of recursion)"}),"\n",(0,t.jsx)(e.li,{children:"Memory-constrained environments (requires O(n) extra space)"}),"\n",(0,t.jsx)(e.li,{children:"When in-place sorting is mandatory"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"basic-implementation",children:"Basic Implementation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"public class MergeSort {\n\n    public static void mergeSort(int[] arr) {\n        if (arr.length <= 1) return;\n\n        int[] temp = new int[arr.length];\n        mergeSortHelper(arr, temp, 0, arr.length - 1);\n    }\n\n    private static void mergeSortHelper(int[] arr, int[] temp, int left, int right) {\n        if (left < right) {\n            int mid = left + (right - left) / 2;\n\n            // Recursively sort both halves\n            mergeSortHelper(arr, temp, left, mid);\n            mergeSortHelper(arr, temp, mid + 1, right);\n\n            // Merge sorted halves\n            merge(arr, temp, left, mid, right);\n        }\n    }\n\n    private static void merge(int[] arr, int[] temp, int left, int mid, int right) {\n        // Copy data to temp array\n        for (int i = left; i <= right; i++) {\n            temp[i] = arr[i];\n        }\n\n        int i = left;      // Left subarray index\n        int j = mid + 1;   // Right subarray index\n        int k = left;      // Merged array index\n\n        // Merge the temp arrays back into arr[left..right]\n        while (i <= mid && j <= right) {\n            if (temp[i] <= temp[j]) {\n                arr[k] = temp[i];\n                i++;\n            } else {\n                arr[k] = temp[j];\n                j++;\n            }\n            k++;\n        }\n\n        // Copy remaining elements\n        while (i <= mid) {\n            arr[k] = temp[i];\n            i++;\n            k++;\n        }\n\n        while (j <= right) {\n            arr[k] = temp[j];\n            j++;\n            k++;\n        }\n    }\n}\n"})}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Time Complexity:"})," O(n log n) - all cases | ",(0,t.jsx)(e.strong,{children:"Space Complexity:"})," O(n)"]}),"\n",(0,t.jsx)(e.h3,{id:"iterative-merge-sort-bottom-up",children:"Iterative Merge Sort (Bottom-Up)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"public static void mergeSortIterative(int[] arr) {\n    int n = arr.length;\n    int[] temp = new int[n];\n\n    // Start with subarrays of size 1, then 2, 4, 8, ...\n    for (int size = 1; size < n; size *= 2) {\n        for (int start = 0; start < n - 1; start += 2 * size) {\n            int mid = Math.min(start + size - 1, n - 1);\n            int end = Math.min(start + 2 * size - 1, n - 1);\n\n            if (mid < end) {\n                merge(arr, temp, start, mid, end);\n            }\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"merge-sort-for-linked-lists",children:"Merge Sort for Linked Lists"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"class ListNode {\n    int val;\n    ListNode next;\n    ListNode() {}\n    ListNode(int val) { this.val = val; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}\n\npublic class LinkedListMergeSort {\n\n    public ListNode sortList(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n\n        // Find middle and split\n        ListNode middle = getMiddle(head);\n        ListNode rightHalf = middle.next;\n        middle.next = null;\n\n        // Recursively sort both halves\n        ListNode left = sortList(head);\n        ListNode right = sortList(rightHalf);\n\n        // Merge sorted halves\n        return mergeTwoLists(left, right);\n    }\n\n    private ListNode getMiddle(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        ListNode prev = null;\n\n        while (fast != null && fast.next != null) {\n            prev = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n\n        return prev;\n    }\n\n    private ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        ListNode dummy = new ListNode(0);\n        ListNode current = dummy;\n\n        while (l1 != null && l2 != null) {\n            if (l1.val <= l2.val) {\n                current.next = l1;\n                l1 = l1.next;\n            } else {\n                current.next = l2;\n                l2 = l2.next;\n            }\n            current = current.next;\n        }\n\n        current.next = (l1 != null) ? l1 : l2;\n        return dummy.next;\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"merge-sort-applications",children:"Merge Sort Applications"}),"\n",(0,t.jsx)(e.h4,{id:"1-count-inversions",children:"1. Count Inversions"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"public class InversionCount {\n\n    public static long countInversions(int[] arr) {\n        int[] temp = new int[arr.length];\n        return mergeSortAndCount(arr, temp, 0, arr.length - 1);\n    }\n\n    private static long mergeSortAndCount(int[] arr, int[] temp, int left, int right) {\n        long invCount = 0;\n\n        if (left < right) {\n            int mid = left + (right - left) / 2;\n\n            invCount += mergeSortAndCount(arr, temp, left, mid);\n            invCount += mergeSortAndCount(arr, temp, mid + 1, right);\n            invCount += mergeAndCount(arr, temp, left, mid, right);\n        }\n\n        return invCount;\n    }\n\n    private static long mergeAndCount(int[] arr, int[] temp, int left, int mid, int right) {\n        // Copy data to temp array\n        for (int i = left; i <= right; i++) {\n            temp[i] = arr[i];\n        }\n\n        int i = left;\n        int j = mid + 1;\n        int k = left;\n        long invCount = 0;\n\n        while (i <= mid && j <= right) {\n            if (temp[i] <= temp[j]) {\n                arr[k++] = temp[i++];\n            } else {\n                arr[k++] = temp[j++];\n                invCount += (mid - i + 1); // All elements from i to mid are greater than arr[j]\n            }\n        }\n\n        while (i <= mid) arr[k++] = temp[i++];\n        while (j <= right) arr[k++] = temp[j++];\n\n        return invCount;\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h4,{id:"2-merge-k-sorted-arrays",children:"2. Merge K Sorted Arrays"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"import java.util.*;\n\npublic class MergeKArrays {\n\n    public static List<Integer> mergeKSortedArrays(List<List<Integer>> arrays) {\n        if (arrays == null || arrays.isEmpty()) {\n            return new ArrayList<>();\n        }\n\n        while (arrays.size() > 1) {\n            List<List<Integer>> mergedArrays = new ArrayList<>();\n\n            for (int i = 0; i < arrays.size(); i += 2) {\n                List<Integer> arr1 = arrays.get(i);\n                List<Integer> arr2 = (i + 1 < arrays.size()) ? arrays.get(i + 1) : new ArrayList<>();\n                mergedArrays.add(mergeTwoArrays(arr1, arr2));\n            }\n\n            arrays = mergedArrays;\n        }\n\n        return arrays.get(0);\n    }\n\n    private static List<Integer> mergeTwoArrays(List<Integer> arr1, List<Integer> arr2) {\n        List<Integer> result = new ArrayList<>();\n        int i = 0, j = 0;\n\n        while (i < arr1.size() && j < arr2.size()) {\n            if (arr1.get(i) <= arr2.get(j)) {\n                result.add(arr1.get(i));\n                i++;\n            } else {\n                result.add(arr2.get(j));\n                j++;\n            }\n        }\n\n        while (i < arr1.size()) result.add(arr1.get(i++));\n        while (j < arr2.size()) result.add(arr2.get(j++));\n\n        return result;\n    }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"quick-sort",children:"Quick Sort"}),"\n",(0,t.jsx)(e.h3,{id:"overview-1",children:"Overview"}),"\n",(0,t.jsx)(e.p,{children:"Quick Sort is an efficient, in-place, divide-and-conquer sorting algorithm. It selects a 'pivot' element and partitions the array around the pivot, then recursively sorts the subarrays."}),"\n",(0,t.jsx)(e.h3,{id:"when-to-use-quick-sort",children:"When to Use Quick Sort"}),"\n",(0,t.jsxs)(e.p,{children:["\u2705 ",(0,t.jsx)(e.strong,{children:"Perfect for:"})]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"General-purpose sorting (most common choice)"}),"\n",(0,t.jsx)(e.li,{children:"In-place sorting (O(log n) space complexity)"}),"\n",(0,t.jsx)(e.li,{children:"Average case performance matters more than worst case"}),"\n",(0,t.jsx)(e.li,{children:"When randomized performance is acceptable"}),"\n",(0,t.jsx)(e.li,{children:"Large datasets with good pivot selection"}),"\n",(0,t.jsx)(e.li,{children:"Cache-efficient sorting"}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:["\u274c ",(0,t.jsx)(e.strong,{children:"Not suitable for:"})]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"When stability is required"}),"\n",(0,t.jsx)(e.li,{children:"When worst-case O(n\xb2) is unacceptable"}),"\n",(0,t.jsx)(e.li,{children:"Nearly sorted data (without randomization)"}),"\n",(0,t.jsx)(e.li,{children:"When guaranteed performance is critical"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"basic-implementation-lomuto-partition",children:"Basic Implementation (Lomuto Partition)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"public class QuickSort {\n\n    public static void quickSort(int[] arr) {\n        quickSort(arr, 0, arr.length - 1);\n    }\n\n    private static void quickSort(int[] arr, int low, int high) {\n        if (low < high) {\n            // Partition the array and get pivot index\n            int pivotIndex = partition(arr, low, high);\n\n            // Recursively sort elements before and after partition\n            quickSort(arr, low, pivotIndex - 1);\n            quickSort(arr, pivotIndex + 1, high);\n        }\n    }\n\n    private static int partition(int[] arr, int low, int high) {\n        // Choose rightmost element as pivot\n        int pivot = arr[high];\n        int i = low - 1; // Index of smaller element\n\n        for (int j = low; j < high; j++) {\n            // If current element is smaller than or equal to pivot\n            if (arr[j] <= pivot) {\n                i++;\n                swap(arr, i, j);\n            }\n        }\n\n        // Place pivot in correct position\n        swap(arr, i + 1, high);\n        return i + 1;\n    }\n\n    private static void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Time Complexity:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Average: O(n log n)"}),"\n",(0,t.jsx)(e.li,{children:"Worst: O(n\xb2)"}),"\n",(0,t.jsx)(e.li,{children:"Best: O(n log n)"}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Space Complexity:"})," O(log n) average, O(n) worst case"]}),"\n",(0,t.jsx)(e.h3,{id:"hoare-partition-scheme",children:"Hoare Partition Scheme"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"public static void quickSortHoare(int[] arr, int low, int high) {\n    if (low < high) {\n        int pivotIndex = hoarePartition(arr, low, high);\n\n        quickSortHoare(arr, low, pivotIndex);\n        quickSortHoare(arr, pivotIndex + 1, high);\n    }\n}\n\nprivate static int hoarePartition(int[] arr, int low, int high) {\n    int pivot = arr[low];\n    int i = low - 1;\n    int j = high + 1;\n\n    while (true) {\n        // Find element on left that should be on right\n        do {\n            i++;\n        } while (arr[i] < pivot);\n\n        // Find element on right that should be on left\n        do {\n            j--;\n        } while (arr[j] > pivot);\n\n        // If elements crossed, partitioning is done\n        if (i >= j) {\n            return j;\n        }\n\n        swap(arr, i, j);\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"randomized-quick-sort",children:"Randomized Quick Sort"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"import java.util.Random;\n\npublic static void randomizedQuickSort(int[] arr, int low, int high) {\n    if (low < high) {\n        // Randomly select pivot to avoid worst case\n        Random rand = new Random();\n        int randomPivot = low + rand.nextInt(high - low + 1);\n        swap(arr, randomPivot, high);\n\n        int pivotIndex = partition(arr, low, high);\n\n        randomizedQuickSort(arr, low, pivotIndex - 1);\n        randomizedQuickSort(arr, pivotIndex + 1, high);\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-way-quick-sort-dutch-national-flag",children:"3-Way Quick Sort (Dutch National Flag)"}),"\n",(0,t.jsx)(e.p,{children:"Perfect for arrays with many duplicate elements:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"public static void quickSort3Way(int[] arr, int low, int high) {\n    if (low < high) {\n        int[] pivots = partition3Way(arr, low, high);\n        int lt = pivots[0];\n        int gt = pivots[1];\n\n        quickSort3Way(arr, low, lt - 1);\n        quickSort3Way(arr, gt + 1, high);\n    }\n}\n\nprivate static int[] partition3Way(int[] arr, int low, int high) {\n    int pivot = arr[low];\n    int i = low;\n    int lt = low;      // arr[low...lt-1] < pivot\n    int gt = high + 1; // arr[gt...high] > pivot\n\n    while (i < gt) {\n        if (arr[i] < pivot) {\n            swap(arr, lt, i);\n            lt++;\n            i++;\n        } else if (arr[i] > pivot) {\n            gt--;\n            swap(arr, i, gt);\n            // Don't increment i, as we need to examine the swapped element\n        } else {\n            i++; // arr[i] == pivot\n        }\n    }\n\n    return new int[]{lt, gt};\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"iterative-quick-sort",children:"Iterative Quick Sort"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"import java.util.Stack;\n\npublic static void quickSortIterative(int[] arr) {\n    Stack<Integer> stack = new Stack<>();\n    stack.push(0);\n    stack.push(arr.length - 1);\n\n    while (!stack.isEmpty()) {\n        int high = stack.pop();\n        int low = stack.pop();\n\n        if (low < high) {\n            int pivotIndex = partition(arr, low, high);\n\n            // Push left and right subarrays to stack\n            stack.push(low);\n            stack.push(pivotIndex - 1);\n            stack.push(pivotIndex + 1);\n            stack.push(high);\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"quick-sort-applications",children:"Quick Sort Applications"}),"\n",(0,t.jsx)(e.h4,{id:"1-quick-select-find-kth-smallest-element",children:"1. Quick Select (Find Kth Smallest Element)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"public class QuickSelect {\n\n    public static int quickSelect(int[] arr, int k) {\n        // Convert to 0-indexed\n        k = k - 1;\n        return quickSelectHelper(arr, 0, arr.length - 1, k);\n    }\n\n    private static int quickSelectHelper(int[] arr, int low, int high, int k) {\n        if (low == high) {\n            return arr[low];\n        }\n\n        int pivotIndex = partition(arr, low, high);\n\n        if (k == pivotIndex) {\n            return arr[k];\n        } else if (k < pivotIndex) {\n            return quickSelectHelper(arr, low, pivotIndex - 1, k);\n        } else {\n            return quickSelectHelper(arr, pivotIndex + 1, high, k);\n        }\n    }\n\n    private static int partition(int[] arr, int low, int high) {\n        int pivot = arr[high];\n        int i = low - 1;\n\n        for (int j = low; j < high; j++) {\n            if (arr[j] <= pivot) {\n                i++;\n                swap(arr, i, j);\n            }\n        }\n\n        swap(arr, i + 1, high);\n        return i + 1;\n    }\n\n    private static void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n}\n\n// Example: Find 3rd smallest element\n// System.out.println(QuickSelect.quickSelect(new int[]{7, 10, 4, 3, 20, 15}, 3)); // Output: 7\n"})}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Time Complexity:"})," O(n) average, O(n\xb2) worst case"]}),"\n",(0,t.jsx)(e.h4,{id:"2-find-top-k-elements",children:"2. Find Top K Elements"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"public static int[] findTopKElements(int[] arr, int k) {\n    int[] result = new int[k];\n    quickSelectTopK(arr, 0, arr.length - 1, k);\n\n    // Copy top k elements\n    System.arraycopy(arr, 0, result, 0, k);\n    return result;\n}\n\nprivate static void quickSelectTopK(int[] arr, int low, int high, int k) {\n    if (low <= high) {\n        int pivotIndex = partitionDescending(arr, low, high);\n\n        if (pivotIndex == k - 1) {\n            return;\n        } else if (pivotIndex < k - 1) {\n            quickSelectTopK(arr, pivotIndex + 1, high, k);\n        } else {\n            quickSelectTopK(arr, low, pivotIndex - 1, k);\n        }\n    }\n}\n\nprivate static int partitionDescending(int[] arr, int low, int high) {\n    int pivot = arr[high];\n    int i = low - 1;\n\n    for (int j = low; j < high; j++) {\n        if (arr[j] >= pivot) { // Note: >= for descending order\n            i++;\n            swap(arr, i, j);\n        }\n    }\n\n    swap(arr, i + 1, high);\n    return i + 1;\n}\n"})}),"\n",(0,t.jsx)(e.h4,{id:"3-sort-colors-3-way-partitioning",children:"3. Sort Colors (3-Way Partitioning)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"public static void sortColors(int[] nums) {\n    int low = 0;      // Boundary for 0s\n    int mid = 0;      // Current element\n    int high = nums.length - 1; // Boundary for 2s\n\n    while (mid <= high) {\n        if (nums[mid] == 0) {\n            swap(nums, low, mid);\n            low++;\n            mid++;\n        } else if (nums[mid] == 1) {\n            mid++;\n        } else { // nums[mid] == 2\n            swap(nums, mid, high);\n            high--;\n            // Don't increment mid, as we need to examine the swapped element\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"optimizations",children:"Optimizations"}),"\n",(0,t.jsx)(e.h4,{id:"1-hybrid-quick-sort-with-insertion-sort-for-small-arrays",children:"1. Hybrid Quick Sort (with Insertion Sort for small arrays)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"private static final int INSERTION_SORT_THRESHOLD = 10;\n\npublic static void hybridQuickSort(int[] arr, int low, int high) {\n    if (low < high) {\n        if (high - low + 1 < INSERTION_SORT_THRESHOLD) {\n            insertionSort(arr, low, high);\n        } else {\n            int pivotIndex = partition(arr, low, high);\n            hybridQuickSort(arr, low, pivotIndex - 1);\n            hybridQuickSort(arr, pivotIndex + 1, high);\n        }\n    }\n}\n\nprivate static void insertionSort(int[] arr, int low, int high) {\n    for (int i = low + 1; i <= high; i++) {\n        int key = arr[i];\n        int j = i - 1;\n\n        while (j >= low && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n\n        arr[j + 1] = key;\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h4,{id:"2-median-of-three-pivot-selection",children:"2. Median-of-Three Pivot Selection"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"private static void medianOfThree(int[] arr, int low, int high) {\n    int mid = low + (high - low) / 2;\n\n    // Sort low, mid, high\n    if (arr[mid] < arr[low]) {\n        swap(arr, low, mid);\n    }\n    if (arr[high] < arr[low]) {\n        swap(arr, low, high);\n    }\n    if (arr[high] < arr[mid]) {\n        swap(arr, mid, high);\n    }\n\n    // Place median at end as pivot\n    swap(arr, mid, high);\n}\n\npublic static void quickSortMedianOfThree(int[] arr, int low, int high) {\n    if (low < high) {\n        medianOfThree(arr, low, high);\n        int pivotIndex = partition(arr, low, high);\n\n        quickSortMedianOfThree(arr, low, pivotIndex - 1);\n        quickSortMedianOfThree(arr, pivotIndex + 1, high);\n    }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"cyclic-sort",children:"Cyclic Sort"}),"\n",(0,t.jsx)(e.h3,{id:"overview-2",children:"Overview"}),"\n",(0,t.jsx)(e.p,{children:"Cyclic Sort is an in-place sorting algorithm that works perfectly when dealing with arrays containing numbers in a given range (usually 1 to n or 0 to n-1). It places each number at its correct index directly."}),"\n",(0,t.jsx)(e.h3,{id:"when-to-use-cyclic-sort",children:"When to Use Cyclic Sort"}),"\n",(0,t.jsxs)(e.p,{children:["\u2705 ",(0,t.jsx)(e.strong,{children:"Perfect for:"})]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Arrays with numbers in range [1, n] or [0, n-1]"}),"\n",(0,t.jsx)(e.li,{children:"Finding missing numbers"}),"\n",(0,t.jsx)(e.li,{children:"Finding duplicate numbers"}),"\n",(0,t.jsx)(e.li,{children:"Problems requiring O(1) space complexity"}),"\n",(0,t.jsx)(e.li,{children:"When array elements represent indices"}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:["\u274c ",(0,t.jsx)(e.strong,{children:"Not suitable for:"})]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Arrays with arbitrary ranges"}),"\n",(0,t.jsx)(e.li,{children:"Arrays with many duplicates outside the expected range"}),"\n",(0,t.jsx)(e.li,{children:"When stability is required"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"core-algorithm",children:"Core Algorithm"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"public class CyclicSort {\n\n    public static void cyclicSort(int[] nums) {\n        int i = 0;\n\n        while (i < nums.length) {\n            int correctIndex = nums[i] - 1; // For 1-indexed numbers\n\n            if (nums[i] != nums[correctIndex]) {\n                // Swap current element to its correct position\n                swap(nums, i, correctIndex);\n            } else {\n                i++;\n            }\n        }\n    }\n\n    private static void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n}\n"})}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Time Complexity:"})," O(n) | ",(0,t.jsx)(e.strong,{children:"Space Complexity:"})," O(1)"]}),"\n",(0,t.jsx)(e.h3,{id:"cyclic-sort-variations",children:"Cyclic Sort Variations"}),"\n",(0,t.jsx)(e.h4,{id:"for-0-indexed-arrays-numbers-0-to-n-1",children:"For 0-indexed arrays (numbers 0 to n-1)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"public static void cyclicSortZeroIndexed(int[] nums) {\n    int i = 0;\n\n    while (i < nums.length) {\n        int correctIndex = nums[i]; // For 0-indexed numbers\n\n        if (nums[i] != nums[correctIndex]) {\n            swap(nums, i, correctIndex);\n        } else {\n            i++;\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"cyclic-sort-problems",children:"Cyclic Sort Problems"}),"\n",(0,t.jsx)(e.h4,{id:"1-find-missing-number",children:"1. Find Missing Number"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Given an array containing n distinct numbers taken from 0 to n, find the missing number."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"public class MissingNumber {\n\n    public static int findMissingNumber(int[] nums) {\n        int i = 0;\n        int n = nums.length;\n\n        // Cyclic sort for numbers 0 to n-1\n        while (i < n) {\n            if (nums[i] < n && nums[i] != nums[nums[i]]) {\n                swap(nums, i, nums[i]);\n            } else {\n                i++;\n            }\n        }\n\n        // Find the missing number\n        for (i = 0; i < n; i++) {\n            if (nums[i] != i) {\n                return i;\n            }\n        }\n\n        return n; // If all numbers 0 to n-1 are present\n    }\n\n    private static void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n}\n\n// Example usage\n// System.out.println(MissingNumber.findMissingNumber(new int[]{3, 0, 1})); // Output: 2\n// System.out.println(MissingNumber.findMissingNumber(new int[]{0, 1})); // Output: 2\n"})}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Time Complexity:"})," O(n) | ",(0,t.jsx)(e.strong,{children:"Space Complexity:"})," O(1)"]}),"\n",(0,t.jsx)(e.h4,{id:"2-find-all-missing-numbers",children:"2. Find All Missing Numbers"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"import java.util.*;\n\npublic static List<Integer> findAllMissingNumbers(int[] nums) {\n    List<Integer> missing = new ArrayList<>();\n    int i = 0;\n\n    // Cyclic sort\n    while (i < nums.length) {\n        int correctIndex = nums[i] - 1;\n        if (nums[i] > 0 && nums[i] <= nums.length && nums[i] != nums[correctIndex]) {\n            swap(nums, i, correctIndex);\n        } else {\n            i++;\n        }\n    }\n\n    // Find all missing numbers\n    for (i = 0; i < nums.length; i++) {\n        if (nums[i] != i + 1) {\n            missing.add(i + 1);\n        }\n    }\n\n    return missing;\n}\n\n// Example usage\n// System.out.println(findAllMissingNumbers(new int[]{4, 3, 2, 7, 8, 2, 3, 1})); // Output: [5, 6]\n"})}),"\n",(0,t.jsx)(e.h4,{id:"3-find-duplicate-number",children:"3. Find Duplicate Number"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"public static int findDuplicate(int[] nums) {\n    int i = 0;\n\n    while (i < nums.length) {\n        int correctIndex = nums[i] - 1;\n        if (nums[i] != nums[correctIndex]) {\n            swap(nums, i, correctIndex);\n        } else {\n            i++;\n        }\n    }\n\n    // Find the duplicate\n    for (i = 0; i < nums.length; i++) {\n        if (nums[i] != i + 1) {\n            return nums[i];\n        }\n    }\n\n    return -1;\n}\n"})}),"\n",(0,t.jsx)(e.h4,{id:"4-first-missing-positive",children:"4. First Missing Positive"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem:"})," Find the smallest missing positive integer."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"public class FirstMissingPositive {\n\n    public static int firstMissingPositive(int[] nums) {\n        int n = nums.length;\n\n        // Cyclic sort for positive numbers\n        for (int i = 0; i < n; i++) {\n            while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) {\n                swap(nums, nums[i] - 1, i);\n            }\n        }\n\n        // Find first missing positive\n        for (int i = 0; i < n; i++) {\n            if (nums[i] != i + 1) {\n                return i + 1;\n            }\n        }\n\n        return n + 1;\n    }\n\n    private static void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n}\n\n// Example usage\n// System.out.println(FirstMissingPositive.firstMissingPositive(new int[]{1, 2, 0})); // Output: 3\n// System.out.println(FirstMissingPositive.firstMissingPositive(new int[]{3, 4, -1, 1})); // Output: 2\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"counting-sort",children:"Counting Sort"}),"\n",(0,t.jsx)(e.h3,{id:"overview-3",children:"Overview"}),"\n",(0,t.jsx)(e.p,{children:"Counting Sort is a non-comparison based sorting algorithm that works by counting the number of objects having distinct key values. It's particularly efficient when the range of potential items (k) is not significantly greater than the number of items (n)."}),"\n",(0,t.jsx)(e.h3,{id:"when-to-use-counting-sort",children:"When to Use Counting Sort"}),"\n",(0,t.jsxs)(e.p,{children:["\u2705 ",(0,t.jsx)(e.strong,{children:"Perfect for:"})]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Small range of integers (k is small)"}),"\n",(0,t.jsx)(e.li,{children:"When stability is required"}),"\n",(0,t.jsx)(e.li,{children:"Frequency counting problems"}),"\n",(0,t.jsx)(e.li,{children:"Character sorting (ASCII range)"}),"\n",(0,t.jsx)(e.li,{children:"Age sorting, grade sorting"}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:["\u274c ",(0,t.jsx)(e.strong,{children:"Not suitable for:"})]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Large range of values (k >> n)"}),"\n",(0,t.jsx)(e.li,{children:"Floating-point numbers"}),"\n",(0,t.jsx)(e.li,{children:"Objects without integer keys"}),"\n",(0,t.jsx)(e.li,{children:"Memory-constrained environments"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"basic-implementation-1",children:"Basic Implementation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"public class CountingSort {\n\n    public static int[] countingSort(int[] arr, int maxValue) {\n        int[] count = new int[maxValue + 1];\n        int[] output = new int[arr.length];\n\n        // Count occurrences\n        for (int i = 0; i < arr.length; i++) {\n            count[arr[i]]++;\n        }\n\n        // Transform count array to actual positions\n        for (int i = 1; i <= maxValue; i++) {\n            count[i] += count[i - 1];\n        }\n\n        // Build output array (stable sorting)\n        for (int i = arr.length - 1; i >= 0; i--) {\n            output[count[arr[i]] - 1] = arr[i];\n            count[arr[i]]--;\n        }\n\n        return output;\n    }\n\n    public static int[] countingSort(int[] arr) {\n        int maxValue = Arrays.stream(arr).max().orElse(0);\n        return countingSort(arr, maxValue);\n    }\n}\n\n// Example usage\n// int[] result = CountingSort.countingSort(new int[]{4, 2, 2, 8, 3, 3, 1}); // [1, 2, 2, 3, 3, 4, 8]\n"})}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Time Complexity:"})," O(n + k) | ",(0,t.jsx)(e.strong,{children:"Space Complexity:"})," O(k)\nwhere k is the range of input values."]}),"\n",(0,t.jsx)(e.h3,{id:"counting-sort-for-negative-numbers",children:"Counting Sort for Negative Numbers"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"public static int[] countingSortWithNegatives(int[] arr) {\n    int min = Arrays.stream(arr).min().orElse(0);\n    int max = Arrays.stream(arr).max().orElse(0);\n    int range = max - min + 1;\n\n    int[] count = new int[range];\n    int[] output = new int[arr.length];\n\n    // Count occurrences (shift by min)\n    for (int i = 0; i < arr.length; i++) {\n        count[arr[i] - min]++;\n    }\n\n    // Transform count array\n    for (int i = 1; i < range; i++) {\n        count[i] += count[i - 1];\n    }\n\n    // Build output array\n    for (int i = arr.length - 1; i >= 0; i--) {\n        output[count[arr[i] - min] - 1] = arr[i];\n        count[arr[i] - min]--;\n    }\n\n    return output;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"counting-sort-problems",children:"Counting Sort Problems"}),"\n",(0,t.jsx)(e.h4,{id:"1-sort-colors-dutch-national-flag",children:"1. Sort Colors (Dutch National Flag)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"public static void sortColors(int[] nums) {\n    int[] count = new int[3];\n\n    // Count colors\n    for (int num : nums) {\n        count[num]++;\n    }\n\n    // Fill array\n    int index = 0;\n    for (int color = 0; color < 3; color++) {\n        for (int i = 0; i < count[color]; i++) {\n            nums[index++] = color;\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h4,{id:"2-character-frequency-sort",children:"2. Character Frequency Sort"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"import java.util.*;\n\npublic static String frequencySort(String s) {\n    Map<Character, Integer> count = new HashMap<>();\n\n    // Count characters\n    for (char c : s.toCharArray()) {\n        count.put(c, count.getOrDefault(c, 0) + 1);\n    }\n\n    // Sort by frequency\n    List<Map.Entry<Character, Integer>> sorted = new ArrayList<>(count.entrySet());\n    sorted.sort((a, b) -> b.getValue() - a.getValue());\n\n    // Build result\n    StringBuilder result = new StringBuilder();\n    for (Map.Entry<Character, Integer> entry : sorted) {\n        char c = entry.getKey();\n        int freq = entry.getValue();\n        for (int i = 0; i < freq; i++) {\n            result.append(c);\n        }\n    }\n\n    return result.toString();\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"bucket-sort",children:"Bucket Sort"}),"\n",(0,t.jsx)(e.h3,{id:"overview-4",children:"Overview"}),"\n",(0,t.jsx)(e.p,{children:"Bucket Sort distributes elements into buckets, sorts each bucket individually, then concatenates the sorted buckets. It's most effective when input is uniformly distributed over a range."}),"\n",(0,t.jsx)(e.h3,{id:"when-to-use-bucket-sort",children:"When to Use Bucket Sort"}),"\n",(0,t.jsxs)(e.p,{children:["\u2705 ",(0,t.jsx)(e.strong,{children:"Perfect for:"})]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Uniformly distributed data"}),"\n",(0,t.jsx)(e.li,{children:"Floating-point numbers in range"}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:["\u274c ",(0,t.jsx)(e.strong,{children:"Not suitable for:"})]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Non-uniform data distribution"}),"\n",(0,t.jsx)(e.li,{children:"Unknown data range"}),"\n",(0,t.jsx)(e.li,{children:"Memory-constrained environments"}),"\n",(0,t.jsx)(e.li,{children:"Small datasets"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"basic-implementation-2",children:"Basic Implementation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"import java.util.*;\n\npublic class BucketSort {\n\n    public static void bucketSort(double[] arr) {\n        if (arr.length == 0) return;\n\n        int bucketCount = arr.length;\n        List<List<Double>> buckets = new ArrayList<>();\n\n        // Create empty buckets\n        for (int i = 0; i < bucketCount; i++) {\n            buckets.add(new ArrayList<>());\n        }\n\n        // Distribute elements into buckets\n        for (double num : arr) {\n            int bucketIndex = (int) (num * bucketCount);\n            if (bucketIndex == bucketCount) bucketIndex--; // Handle edge case\n            buckets.get(bucketIndex).add(num);\n        }\n\n        // Sort individual buckets and concatenate\n        int index = 0;\n        for (List<Double> bucket : buckets) {\n            Collections.sort(bucket);\n            for (double num : bucket) {\n                arr[index++] = num;\n            }\n        }\n    }\n}\n\n// Example usage for floating point numbers in range [0, 1)\n// double[] arr = {0.78, 0.17, 0.39, 0.26, 0.72, 0.94, 0.21, 0.12, 0.23, 0.68};\n// BucketSort.bucketSort(arr);\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Time Complexity:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Average: O(n + k)"}),"\n",(0,t.jsx)(e.li,{children:"Worst: O(n\xb2)"}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Space Complexity:"})," O(n + k)"]}),"\n",(0,t.jsx)(e.h3,{id:"bucket-sort-for-integers",children:"Bucket Sort for Integers"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"public static void bucketSortIntegers(int[] arr, int bucketSize) {\n    if (arr.length == 0) return;\n\n    int min = Arrays.stream(arr).min().orElse(0);\n    int max = Arrays.stream(arr).max().orElse(0);\n    int bucketCount = (max - min) / bucketSize + 1;\n\n    List<List<Integer>> buckets = new ArrayList<>();\n    for (int i = 0; i < bucketCount; i++) {\n        buckets.add(new ArrayList<>());\n    }\n\n    // Distribute elements\n    for (int num : arr) {\n        int bucketIndex = (num - min) / bucketSize;\n        buckets.get(bucketIndex).add(num);\n    }\n\n    // Sort and concatenate\n    int index = 0;\n    for (List<Integer> bucket : buckets) {\n        Collections.sort(bucket);\n        for (int num : bucket) {\n            arr[index++] = num;\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"bucket-sort-problems",children:"Bucket Sort Problems"}),"\n",(0,t.jsx)(e.h4,{id:"1-top-k-frequent-elements",children:"1. Top K Frequent Elements"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"import java.util.*;\n\npublic static int[] topKFrequent(int[] nums, int k) {\n    Map<Integer, Integer> count = new HashMap<>();\n\n    // Count frequencies\n    for (int num : nums) {\n        count.put(num, count.getOrDefault(num, 0) + 1);\n    }\n\n    // Create buckets based on frequency\n    List<List<Integer>> buckets = new ArrayList<>();\n    for (int i = 0; i <= nums.length; i++) {\n        buckets.add(new ArrayList<>());\n    }\n\n    for (Map.Entry<Integer, Integer> entry : count.entrySet()) {\n        int num = entry.getKey();\n        int freq = entry.getValue();\n        buckets.get(freq).add(num);\n    }\n\n    // Collect top k elements\n    List<Integer> result = new ArrayList<>();\n    for (int i = buckets.size() - 1; i >= 0 && result.size() < k; i--) {\n        result.addAll(buckets.get(i));\n    }\n\n    return result.stream().mapToInt(i -> i).toArray();\n}\n"})}),"\n",(0,t.jsx)(e.h4,{id:"2-maximum-gap",children:"2. Maximum Gap"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"public static int maximumGap(int[] nums) {\n    if (nums.length < 2) return 0;\n\n    int min = Arrays.stream(nums).min().orElse(0);\n    int max = Arrays.stream(nums).max().orElse(0);\n\n    if (min == max) return 0;\n\n    int n = nums.length;\n    int bucketSize = Math.max(1, (max - min) / (n - 1));\n    int bucketCount = (max - min) / bucketSize + 1;\n\n    int[] bucketMin = new int[bucketCount];\n    int[] bucketMax = new int[bucketCount];\n    boolean[] hasNum = new boolean[bucketCount];\n\n    Arrays.fill(bucketMin, Integer.MAX_VALUE);\n    Arrays.fill(bucketMax, Integer.MIN_VALUE);\n\n    // Fill buckets\n    for (int num : nums) {\n        int bucketIndex = (num - min) / bucketSize;\n        hasNum[bucketIndex] = true;\n        bucketMin[bucketIndex] = Math.min(bucketMin[bucketIndex], num);\n        bucketMax[bucketIndex] = Math.max(bucketMax[bucketIndex], num);\n    }\n\n    // Find maximum gap\n    int maxGap = 0;\n    int prevMax = min;\n\n    for (int i = 0; i < bucketCount; i++) {\n        if (!hasNum[i]) continue;\n\n        maxGap = Math.max(maxGap, bucketMin[i] - prevMax);\n        prevMax = bucketMax[i];\n    }\n\n    return maxGap;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"problem-patterns--applications",children:"Problem Patterns & Applications"}),"\n",(0,t.jsx)(e.h3,{id:"cyclic-sort-pattern-problems",children:"Cyclic Sort Pattern Problems"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Pattern: Array with numbers in range [1,n] or [0,n-1]\npublic class CyclicSortPatterns {\n\n    // Template for cyclic sort problems\n    public static void cyclicSortTemplate(int[] nums, boolean isOneIndexed) {\n        int i = 0;\n\n        while (i < nums.length) {\n            int correctIndex = isOneIndexed ? nums[i] - 1 : nums[i];\n\n            if (nums[i] != nums[correctIndex] &&\n                nums[i] > 0 &&\n                nums[i] <= nums.length) {\n                swap(nums, i, correctIndex);\n            } else {\n                i++;\n            }\n        }\n    }\n\n    private static void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n}\n\n/*\nCommon Cyclic Sort Problems:\n- Find Missing Number\n- Find All Missing Numbers\n- Find Duplicate Number\n- Find All Duplicates\n- First Missing Positive\n- Find Corrupt Pair\n*/\n"})}),"\n",(0,t.jsx)(e.h3,{id:"counting-sort-pattern-problems",children:"Counting Sort Pattern Problems"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"import java.util.*;\n\npublic class CountingSortPatterns {\n\n    // Template for counting sort problems\n    public static int[] countingSortTemplate(int[] arr, Function<Integer, Integer> getKey, int maxKey) {\n        int[] count = new int[maxKey + 1];\n\n        // Count frequencies\n        for (int item : arr) {\n            count[getKey.apply(item)]++;\n        }\n\n        // Optional: convert to cumulative count for stable sorting\n        for (int i = 1; i <= maxKey; i++) {\n            count[i] += count[i - 1];\n        }\n\n        return count;\n    }\n}\n\n/*\nCommon Counting Sort Problems:\n- Sort Colors\n- Relative Sort Array\n- Sort Characters by Frequency\n- Custom Sort String\n- Rank Transform of Array\n*/\n"})}),"\n",(0,t.jsx)(e.h3,{id:"bucket-sort-pattern-problems",children:"Bucket Sort Pattern Problems"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"/*\nCommon Bucket Sort Problems:\n- Top K Frequent Elements\n- Sort Array by Increasing Frequency\n- Maximum Gap\n- Contains Duplicate III\n- Group Anagrams\n*/\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"comparison--when-to-use",children:"Comparison & When to Use"}),"\n",(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{style:{textAlign:"left"},children:"Algorithm"}),(0,t.jsx)(e.th,{style:{textAlign:"left"},children:"Time Complexity"}),(0,t.jsx)(e.th,{style:{textAlign:"left"},children:"Space Complexity"}),(0,t.jsx)(e.th,{style:{textAlign:"left"},children:"Best For"})]})}),(0,t.jsxs)(e.tbody,{children:[(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:(0,t.jsx)(e.strong,{children:"Merge Sort"})}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(n log n) - all cases"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Stability, large datasets, linked lists"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:(0,t.jsx)(e.strong,{children:"Quick Sort"})}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(n log n) avg, O(n\xb2) worst"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(log n) avg"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"General purpose, in-place sorting"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:(0,t.jsx)(e.strong,{children:"Cyclic Sort"})}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(1)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Numbers in range [1,n]"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:(0,t.jsx)(e.strong,{children:"Counting Sort"})}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(n + k)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(k)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Small range integers"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:(0,t.jsx)(e.strong,{children:"Bucket Sort"})}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(n + k) avg, O(n\xb2) worst"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(n + k)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Uniformly distributed data"})]})]})]}),"\n",(0,t.jsx)(e.h3,{id:"decision-framework",children:"Decision Framework"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:'public class SortingAlgorithmSelector {\n\n    public static String chooseSortingAlgorithm(int[] data, Requirements requirements) {\n\n        // Check for cyclic sort applicability\n        if (isInRange(data, 1, data.length) || isInRange(data, 0, data.length - 1)) {\n            return "Cyclic Sort";\n        }\n\n        // Check for counting sort applicability\n        int min = Arrays.stream(data).min().orElse(0);\n        int max = Arrays.stream(data).max().orElse(0);\n        int range = max - min + 1;\n        if (range <= data.length * 2) {\n            return "Counting Sort";\n        }\n\n        // Check for bucket sort applicability\n        if (isUniformlyDistributed(data) && !requirements.inPlaceRequired) {\n            return "Bucket Sort";\n        }\n\n        // Choose between merge sort and quick sort\n        if (requirements.stabilityRequired || requirements.guaranteedPerformance) {\n            return requirements.memoryConstrained ? "Heap Sort" : "Merge Sort";\n        }\n\n        if (requirements.inPlaceRequired || !requirements.memoryConstrained) {\n            return "Quick Sort";\n        }\n\n        return "Merge Sort"; // Default safe choice\n    }\n\n    private static boolean isInRange(int[] arr, int min, int max) {\n        for (int num : arr) {\n            if (num < min || num > max) return false;\n        }\n        return true;\n    }\n\n    private static boolean isUniformlyDistributed(int[] arr) {\n        int min = Arrays.stream(arr).min().orElse(0);\n        int max = Arrays.stream(arr).max().orElse(0);\n        return (max - min) / (double) arr.length < 10;\n    }\n\n    static class Requirements {\n        boolean stabilityRequired = false;\n        boolean inPlaceRequired = false;\n        boolean guaranteedPerformance = false;\n        boolean memoryConstrained = false;\n    }\n}\n'})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"advanced-problems",children:"Advanced Problems"}),"\n",(0,t.jsx)(e.h3,{id:"1-find-corrupt-pair-cyclic-sort",children:"1. Find Corrupt Pair (Cyclic Sort)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"public static int[] findErrorNums(int[] nums) {\n    int i = 0;\n\n    // Cyclic sort\n    while (i < nums.length) {\n        int correctIndex = nums[i] - 1;\n        if (nums[i] != nums[correctIndex]) {\n            swap(nums, i, correctIndex);\n        } else {\n            i++;\n        }\n    }\n\n    // Find duplicate and missing\n    for (i = 0; i < nums.length; i++) {\n        if (nums[i] != i + 1) {\n            return new int[]{nums[i], i + 1}; // [duplicate, missing]\n        }\n    }\n\n    return new int[]{};\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-radix-sort-using-counting-sort",children:"2. Radix Sort (Using Counting Sort)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"public class RadixSort {\n\n    public static void radixSort(int[] nums) {\n        int max = Arrays.stream(nums).max().orElse(0);\n\n        // Sort by each digit\n        for (int exp = 1; max / exp > 0; exp *= 10) {\n            countingSortByDigit(nums, exp);\n        }\n    }\n\n    private static void countingSortByDigit(int[] nums, int exp) {\n        int[] count = new int[10];\n        int[] output = new int[nums.length];\n\n        // Count occurrences of digits\n        for (int i = 0; i < nums.length; i++) {\n            int digit = (nums[i] / exp) % 10;\n            count[digit]++;\n        }\n\n        // Transform to positions\n        for (int i = 1; i < 10; i++) {\n            count[i] += count[i - 1];\n        }\n\n        // Build output array\n        for (int i = nums.length - 1; i >= 0; i--) {\n            int digit = (nums[i] / exp) % 10;\n            output[count[digit] - 1] = nums[i];\n            count[digit]--;\n        }\n\n        // Copy back to original array\n        System.arraycopy(output, 0, nums, 0, nums.length);\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-merge-intervals-merge-sort-application",children:"3. Merge Intervals (Merge Sort Application)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"import java.util.*;\n\npublic static int[][] mergeIntervals(int[][] intervals) {\n    if (intervals.length <= 1) return intervals;\n\n    // Sort intervals by start time\n    Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));\n\n    List<int[]> merged = new ArrayList<>();\n    merged.add(intervals[0]);\n\n    for (int i = 1; i < intervals.length; i++) {\n        int[] current = intervals[i];\n        int[] lastMerged = merged.get(merged.size() - 1);\n\n        if (current[0] <= lastMerged[1]) {\n            // Overlapping intervals - merge them\n            lastMerged[1] = Math.max(lastMerged[1], current[1]);\n        } else {\n            // Non-overlapping interval\n            merged.add(current);\n        }\n    }\n\n    return merged.toArray(new int[merged.size()][]);\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"4-kth-largest-element-in-array-quick-select",children:"4. Kth Largest Element in Array (Quick Select)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"public static int findKthLargest(int[] nums, int k) {\n    // Convert to finding (n-k)th smallest (0-indexed)\n    int targetIndex = nums.length - k;\n    return quickSelect(nums, 0, nums.length - 1, targetIndex);\n}\n\nprivate static int quickSelect(int[] nums, int low, int high, int targetIndex) {\n    int pivotIndex = partition(nums, low, high);\n\n    if (pivotIndex == targetIndex) {\n        return nums[pivotIndex];\n    } else if (pivotIndex < targetIndex) {\n        return quickSelect(nums, pivotIndex + 1, high, targetIndex);\n    } else {\n        return quickSelect(nums, low, pivotIndex - 1, targetIndex);\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"5-sort-array-by-increasing-frequency-bucket-sort",children:"5. Sort Array by Increasing Frequency (Bucket Sort)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"import java.util.*;\n\npublic static int[] frequencySort(int[] nums) {\n    Map<Integer, Integer> count = new HashMap<>();\n\n    // Count frequencies\n    for (int num : nums) {\n        count.put(num, count.getOrDefault(num, 0) + 1);\n    }\n\n    // Create frequency buckets\n    int maxFreq = Collections.max(count.values());\n    List<List<Integer>> buckets = new ArrayList<>();\n    for (int i = 0; i <= maxFreq; i++) {\n        buckets.add(new ArrayList<>());\n    }\n\n    // Group numbers by frequency\n    for (Map.Entry<Integer, Integer> entry : count.entrySet()) {\n        int num = entry.getKey();\n        int freq = entry.getValue();\n        buckets.get(freq).add(num);\n    }\n\n    // Sort numbers within each frequency bucket (descending for same frequency)\n    for (List<Integer> bucket : buckets) {\n        bucket.sort((a, b) -> b - a);\n    }\n\n    // Build result\n    List<Integer> result = new ArrayList<>();\n    for (int freq = 1; freq <= maxFreq; freq++) {\n        for (int num : buckets.get(freq)) {\n            for (int i = 0; i < freq; i++) {\n                result.add(num);\n            }\n        }\n    }\n\n    return result.stream().mapToInt(i -> i).toArray();\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"implementation-tips",children:"Implementation Tips"}),"\n",(0,t.jsx)(e.h3,{id:"merge-sort-tips",children:"Merge Sort Tips"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Base case handling"}),": Always check for arrays of size \u2264 1"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Merge optimization"}),": Use sentinel values to avoid boundary checks"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Memory optimization"}),": Reuse temporary arrays when possible"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Stability"}),": Ensure equal elements maintain relative order in merge step"]}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Optimized merge with single temporary array\nprivate static void mergeOptimized(int[] arr, int left, int mid, int right, int[] temp) {\n    int i = left, j = mid + 1, k = left;\n\n    // Copy to temp array\n    for (int idx = left; idx <= right; idx++) {\n        temp[idx] = arr[idx];\n    }\n\n    // Merge back to original array\n    while (i <= mid && j <= right) {\n        if (temp[i] <= temp[j]) {\n            arr[k++] = temp[i++];\n        } else {\n            arr[k++] = temp[j++];\n        }\n    }\n\n    while (i <= mid) arr[k++] = temp[i++];\n    while (j <= right) arr[k++] = temp[j++];\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"quick-sort-tips",children:"Quick Sort Tips"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Pivot selection"}),": Use median-of-three or randomization to avoid worst case"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Small arrays"}),": Switch to insertion sort for arrays < 10 elements"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Duplicate handling"}),": Use 3-way partitioning for arrays with many duplicates"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Tail recursion"}),": Optimize recursion for larger partition first"]}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Tail recursion optimized quicksort\npublic static void quickSortTailRecursive(int[] arr, int low, int high) {\n    while (low < high) {\n        int pivotIndex = partition(arr, low, high);\n\n        // Recur for smaller partition and iterate for larger\n        if (pivotIndex - low < high - pivotIndex) {\n            quickSortTailRecursive(arr, low, pivotIndex - 1);\n            low = pivotIndex + 1;\n        } else {\n            quickSortTailRecursive(arr, pivotIndex + 1, high);\n            high = pivotIndex - 1;\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"cyclic-sort-tips",children:"Cyclic Sort Tips"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Always validate range"}),": Ensure numbers are in expected range before swapping"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Handle edge cases"}),": Empty arrays, single elements"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Use while loop"}),": More intuitive than for loop for this pattern"]}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Safe cyclic sort template\npublic static void cyclicSortSafe(int[] nums) {\n    int i = 0;\n\n    while (i < nums.length) {\n        int correctIndex = nums[i] - 1;\n\n        // Validate before swapping\n        if (nums[i] > 0 &&\n            nums[i] <= nums.length &&\n            nums[i] != nums[correctIndex]) {\n            swap(nums, i, correctIndex);\n        } else {\n            i++;\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"counting-sort-tips",children:"Counting Sort Tips"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Consider negative numbers"}),": Shift indices appropriately"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Memory optimization"}),": Use bit manipulation for boolean counting"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Stability matters"}),": Iterate backwards when building output"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"bucket-sort-tips",children:"Bucket Sort Tips"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Choose bucket size wisely"}),": Balance between memory and performance"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Handle empty buckets"}),": Check before processing"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Secondary sort"}),": Choose appropriate algorithm for individual buckets"]}),"\n"]})]})}function u(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}},28453:(n,e,i)=>{i.d(e,{R:()=>a,x:()=>l});var t=i(96540);const r={},s=t.createContext(r);function a(n){const e=t.useContext(s);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:a(n.components),t.createElement(s.Provider,{value:e},n.children)}}}]);