"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[4850],{370:(n,r,e)=>{e.r(r),e.d(r,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>c,toc:()=>o});var t=e(4848),i=e(8453);const s={},a="Recursion Patterns Cheatsheet",c={id:"DSA/Recursion",title:"Recursion Patterns Cheatsheet",description:"Core Concepts",source:"@site/docs/DSA/Recursion.mdx",sourceDirName:"DSA",slug:"/DSA/Recursion",permalink:"/js.enigma/docs/DSA/Recursion",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/Recursion.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Quick Sort",permalink:"/js.enigma/docs/DSA/QuickSort"},next:{title:"10. Regular Expression Matching",permalink:"/js.enigma/docs/DSA/RegexMatching"}},l={},o=[{value:"Core Concepts",id:"core-concepts",level:2},{value:"1. Base Cases",id:"1-base-cases",level:3},{value:"2. Recursive Structure",id:"2-recursive-structure",level:3},{value:"Common Patterns",id:"common-patterns",level:2},{value:"1. Linear Recursion",id:"1-linear-recursion",level:3},{value:"2. Binary Recursion",id:"2-binary-recursion",level:3},{value:"3. Tail Recursion",id:"3-tail-recursion",level:3},{value:"4. Multiple Recursion",id:"4-multiple-recursion",level:3},{value:"5. Backtracking",id:"5-backtracking",level:3},{value:"6. Divide and Conquer",id:"6-divide-and-conquer",level:3},{value:"Optimization Techniques",id:"optimization-techniques",level:2},{value:"1. Memoization",id:"1-memoization",level:3},{value:"2. Path Recording",id:"2-path-recording",level:3},{value:"3. State Management",id:"3-state-management",level:3},{value:"Common Pitfalls and Solutions",id:"common-pitfalls-and-solutions",level:2},{value:"1. Stack Overflow",id:"1-stack-overflow",level:3},{value:"2. Redundant Calculations",id:"2-redundant-calculations",level:3},{value:"3. Incorrect Base Case",id:"3-incorrect-base-case",level:3},{value:"Testing Recursive Functions",id:"testing-recursive-functions",level:2}];function u(n){const r={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,i.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.header,{children:(0,t.jsx)(r.h1,{id:"recursion-patterns-cheatsheet",children:"Recursion Patterns Cheatsheet"})}),"\n",(0,t.jsx)(r.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,t.jsx)(r.h3,{id:"1-base-cases",children:"1. Base Cases"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"function factorial(n) {\r\n    // Base case\r\n    if (n <= 1) return 1;\r\n    \r\n    // Recursive case\r\n    return n * factorial(n - 1);\r\n}\n"})}),"\n",(0,t.jsx)(r.h3,{id:"2-recursive-structure",children:"2. Recursive Structure"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"function recursiveFunction(input) {\r\n    // 1. Base cases\r\n    if (baseCase) return baseValue;\r\n    \r\n    // 2. Process current level\r\n    let current = processCurrentLevel(input);\r\n    \r\n    // 3. Recursive call with smaller input\r\n    let subResult = recursiveFunction(smallerInput);\r\n    \r\n    // 4. Combine results\r\n    return combineResults(current, subResult);\r\n}\n"})}),"\n",(0,t.jsx)(r.h2,{id:"common-patterns",children:"Common Patterns"}),"\n",(0,t.jsx)(r.h3,{id:"1-linear-recursion",children:"1. Linear Recursion"}),"\n",(0,t.jsx)(r.p,{children:"Direct recursive call with smaller input."}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Sum array elements\r\nfunction sum(arr, index = 0) {\r\n    if (index === arr.length) return 0;\r\n    return arr[index] + sum(arr, index + 1);\r\n}\r\n\r\n// String reversal\r\nfunction reverse(str) {\r\n    if (str.length <= 1) return str;\r\n    return reverse(str.slice(1)) + str[0];\r\n}\n"})}),"\n",(0,t.jsx)(r.h3,{id:"2-binary-recursion",children:"2. Binary Recursion"}),"\n",(0,t.jsx)(r.p,{children:"Two recursive calls in each function."}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Fibonacci sequence\r\nfunction fibonacci(n) {\r\n    if (n <= 1) return n;\r\n    return fibonacci(n - 1) + fibonacci(n - 2);\r\n}\r\n\r\n// Binary tree traversal\r\nfunction traverse(node) {\r\n    if (!node) return;\r\n    traverse(node.left);\r\n    traverse(node.right);\r\n}\n"})}),"\n",(0,t.jsx)(r.h3,{id:"3-tail-recursion",children:"3. Tail Recursion"}),"\n",(0,t.jsx)(r.p,{children:"Recursive call is the last operation."}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Factorial with tail recursion\r\nfunction factorialTail(n, acc = 1) {\r\n    if (n <= 1) return acc;\r\n    return factorialTail(n - 1, n * acc);\r\n}\r\n\r\n// Sum with tail recursion\r\nfunction sumTail(arr, index = 0, acc = 0) {\r\n    if (index === arr.length) return acc;\r\n    return sumTail(arr, index + 1, acc + arr[index]);\r\n}\n"})}),"\n",(0,t.jsx)(r.h3,{id:"4-multiple-recursion",children:"4. Multiple Recursion"}),"\n",(0,t.jsx)(r.p,{children:"Multiple recursive calls at different positions."}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Generate all permutations\r\nfunction permutations(arr) {\r\n    if (arr.length <= 1) return [arr];\r\n    \r\n    const result = [];\r\n    for (let i = 0; i < arr.length; i++) {\r\n        const current = arr[i];\r\n        const remaining = [...arr.slice(0, i), ...arr.slice(i + 1)];\r\n        const perms = permutations(remaining);\r\n        \r\n        for (let perm of perms) {\r\n            result.push([current, ...perm]);\r\n        }\r\n    }\r\n    \r\n    return result;\r\n}\r\n\r\n// Generate all subsets\r\nfunction subsets(arr) {\r\n    if (arr.length === 0) return [[]];\r\n    \r\n    const first = arr[0];\r\n    const rest = arr.slice(1);\r\n    const subsWithoutFirst = subsets(rest);\r\n    const subsWithFirst = subsWithoutFirst.map(sub => [first, ...sub]);\r\n    \r\n    return [...subsWithoutFirst, ...subsWithFirst];\r\n}\n"})}),"\n",(0,t.jsx)(r.h3,{id:"5-backtracking",children:"5. Backtracking"}),"\n",(0,t.jsx)(r.p,{children:"Try different paths and undo if not valid."}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// N-Queens Problem\r\nfunction solveNQueens(n) {\r\n    const board = Array(n).fill().map(() => Array(n).fill('.'));\r\n    const result = [];\r\n    \r\n    function isValid(row, col) {\r\n        // Check column\r\n        for (let i = 0; i < row; i++) {\r\n            if (board[i][col] === 'Q') return false;\r\n        }\r\n        \r\n        // Check diagonal\r\n        for (let i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\r\n            if (board[i][j] === 'Q') return false;\r\n        }\r\n        \r\n        // Check anti-diagonal\r\n        for (let i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {\r\n            if (board[i][j] === 'Q') return false;\r\n        }\r\n        \r\n        return true;\r\n    }\r\n    \r\n    function backtrack(row) {\r\n        if (row === n) {\r\n            result.push(board.map(row => row.join('')));\r\n            return;\r\n        }\r\n        \r\n        for (let col = 0; col < n; col++) {\r\n            if (isValid(row, col)) {\r\n                board[row][col] = 'Q';\r\n                backtrack(row + 1);\r\n                board[row][col] = '.';\r\n            }\r\n        }\r\n    }\r\n    \r\n    backtrack(0);\r\n    return result;\r\n}\n"})}),"\n",(0,t.jsx)(r.h3,{id:"6-divide-and-conquer",children:"6. Divide and Conquer"}),"\n",(0,t.jsx)(r.p,{children:"Split problem into smaller subproblems."}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Merge Sort\r\nfunction mergeSort(arr) {\r\n    if (arr.length <= 1) return arr;\r\n    \r\n    const mid = Math.floor(arr.length / 2);\r\n    const left = mergeSort(arr.slice(0, mid));\r\n    const right = mergeSort(arr.slice(mid));\r\n    \r\n    return merge(left, right);\r\n}\r\n\r\nfunction merge(left, right) {\r\n    const result = [];\r\n    let i = 0, j = 0;\r\n    \r\n    while (i < left.length && j < right.length) {\r\n        if (left[i] <= right[j]) {\r\n            result.push(left[i++]);\r\n        } else {\r\n            result.push(right[j++]);\r\n        }\r\n    }\r\n    \r\n    return [...result, ...left.slice(i), ...right.slice(j)];\r\n}\n"})}),"\n",(0,t.jsx)(r.h2,{id:"optimization-techniques",children:"Optimization Techniques"}),"\n",(0,t.jsx)(r.h3,{id:"1-memoization",children:"1. Memoization"}),"\n",(0,t.jsx)(r.p,{children:"Cache results to avoid redundant calculations."}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Fibonacci with memoization\r\nfunction fibMemo(n, memo = new Map()) {\r\n    if (n <= 1) return n;\r\n    if (memo.has(n)) return memo.get(n);\r\n    \r\n    const result = fibMemo(n - 1, memo) + fibMemo(n - 2, memo);\r\n    memo.set(n, result);\r\n    return result;\r\n}\n"})}),"\n",(0,t.jsx)(r.h3,{id:"2-path-recording",children:"2. Path Recording"}),"\n",(0,t.jsx)(r.p,{children:"Keep track of path during recursion."}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Find all paths in binary tree\r\nfunction findPaths(root) {\r\n    const paths = [];\r\n    \r\n    function dfs(node, path) {\r\n        if (!node) return;\r\n        \r\n        path.push(node.val);\r\n        \r\n        if (!node.left && !node.right) {\r\n            paths.push([...path]);\r\n        }\r\n        \r\n        dfs(node.left, path);\r\n        dfs(node.right, path);\r\n        path.pop();\r\n    }\r\n    \r\n    dfs(root, []);\r\n    return paths;\r\n}\n"})}),"\n",(0,t.jsx)(r.h3,{id:"3-state-management",children:"3. State Management"}),"\n",(0,t.jsx)(r.p,{children:"Pass state through recursive calls."}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Tree max path sum\r\nfunction maxPathSum(root) {\r\n    let maxSum = -Infinity;\r\n    \r\n    function dfs(node) {\r\n        if (!node) return 0;\r\n        \r\n        const left = Math.max(0, dfs(node.left));\r\n        const right = Math.max(0, dfs(node.right));\r\n        \r\n        maxSum = Math.max(maxSum, node.val + left + right);\r\n        \r\n        return node.val + Math.max(left, right);\r\n    }\r\n    \r\n    dfs(root);\r\n    return maxSum;\r\n}\n"})}),"\n",(0,t.jsx)(r.h2,{id:"common-pitfalls-and-solutions",children:"Common Pitfalls and Solutions"}),"\n",(0,t.jsx)(r.h3,{id:"1-stack-overflow",children:"1. Stack Overflow"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Problem\r\nfunction infinity(n) {\r\n    return infinity(n + 1); // Will cause stack overflow\r\n}\r\n\r\n// Solution: Add base case\r\nfunction safe(n, limit = 1000) {\r\n    if (n >= limit) return n;\r\n    return safe(n + 1, limit);\r\n}\n"})}),"\n",(0,t.jsx)(r.h3,{id:"2-redundant-calculations",children:"2. Redundant Calculations"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Problem\r\nfunction slowFib(n) {\r\n    if (n <= 1) return n;\r\n    return slowFib(n - 1) + slowFib(n - 2); // Many redundant calls\r\n}\r\n\r\n// Solution: Use memoization\r\nconst fastFib = (n, memo = new Map()) => {\r\n    if (n <= 1) return n;\r\n    if (memo.has(n)) return memo.get(n);\r\n    \r\n    const result = fastFib(n - 1, memo) + fastFib(n - 2, memo);\r\n    memo.set(n, result);\r\n    return result;\r\n};\n"})}),"\n",(0,t.jsx)(r.h3,{id:"3-incorrect-base-case",children:"3. Incorrect Base Case"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Problem\r\nfunction factorial(n) {\r\n    if (n == 0) return 0; // Wrong base case\r\n    return n * factorial(n - 1);\r\n}\r\n\r\n// Solution\r\nfunction factorial(n) {\r\n    if (n <= 1) return 1; // Correct base case\r\n    return n * factorial(n - 1);\r\n}\n"})}),"\n",(0,t.jsx)(r.h2,{id:"testing-recursive-functions",children:"Testing Recursive Functions"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:'// Unit tests for recursive functions\r\nfunction testRecursion() {\r\n    // Test base cases\r\n    console.assert(factorial(0) === 1, "factorial(0) should be 1");\r\n    console.assert(factorial(1) === 1, "factorial(1) should be 1");\r\n    \r\n    // Test recursive cases\r\n    console.assert(factorial(5) === 120, "factorial(5) should be 120");\r\n    \r\n    // Test edge cases\r\n    console.assert(factorial(-1) === 1, "factorial(-1) should be 1");\r\n}\n'})})]})}function d(n={}){const{wrapper:r}={...(0,i.R)(),...n.components};return r?(0,t.jsx)(r,{...n,children:(0,t.jsx)(u,{...n})}):u(n)}},8453:(n,r,e)=>{e.d(r,{R:()=>a,x:()=>c});var t=e(6540);const i={},s=t.createContext(i);function a(n){const r=t.useContext(s);return t.useMemo((function(){return"function"==typeof n?n(r):{...r,...n}}),[r,n])}function c(n){let r;return r=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:a(n.components),t.createElement(s.Provider,{value:r},n.children)}}}]);