"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[7262],{28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>c});var s=t(96540);const r={},o=s.createContext(r);function a(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(o.Provider,{value:n},e.children)}},92551:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>c,toc:()=>l});var s=t(74848),r=t(28453);const o={title:"Handling Race Conditions in React",tags:["react","javascript","async","performance"]},a=void 0,c={id:"WebDev/React/RaceCondition",title:"Handling Race Conditions in React",description:"What are Race Conditions?",source:"@site/docs/WebDev/React/RaceCondition.mdx",sourceDirName:"WebDev/React",slug:"/WebDev/React/RaceCondition",permalink:"/dev.enigma/docs/WebDev/React/RaceCondition",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/WebDev/React/RaceCondition.mdx",tags:[{inline:!0,label:"react",permalink:"/dev.enigma/docs/tags/react"},{inline:!0,label:"javascript",permalink:"/dev.enigma/docs/tags/javascript"},{inline:!0,label:"async",permalink:"/dev.enigma/docs/tags/async"},{inline:!0,label:"performance",permalink:"/dev.enigma/docs/tags/performance"}],version:"current",frontMatter:{title:"Handling Race Conditions in React",tags:["react","javascript","async","performance"]},sidebar:"tutorialSidebar",previous:{title:"PropTypes Validation",permalink:"/dev.enigma/docs/WebDev/React/PropTyped"},next:{title:"Jest & React Testing Library Cheatsheet",permalink:"/dev.enigma/docs/WebDev/React/ReactJestRTL"}},i={},l=[{value:"What are Race Conditions?",id:"what-are-race-conditions",level:2},{value:"Common Scenarios Where Race Conditions Occur",id:"common-scenarios-where-race-conditions-occur",level:2},{value:"Solutions and Best Practices",id:"solutions-and-best-practices",level:2},{value:"1. Cleanup Functions in useEffect",id:"1-cleanup-functions-in-useeffect",level:3},{value:"2. AbortController for Network Requests",id:"2-abortcontroller-for-network-requests",level:3},{value:"3. Request IDs for Multiple Requests",id:"3-request-ids-for-multiple-requests",level:3},{value:"4. Debouncing for Frequent Updates",id:"4-debouncing-for-frequent-updates",level:3},{value:"5. Safe State Updates",id:"5-safe-state-updates",level:3},{value:"6. Custom Hook for Safe Dispatches",id:"6-custom-hook-for-safe-dispatches",level:3},{value:"Best Practices Checklist",id:"best-practices-checklist",level:2},{value:"Common Pitfalls",id:"common-pitfalls",level:2},{value:"Testing for Race Conditions",id:"testing-for-race-conditions",level:2},{value:"Conclusion",id:"conclusion",level:2}];function u(e){const n={br:"br",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"what-are-race-conditions",children:"What are Race Conditions?"}),"\n",(0,s.jsx)(n.p,{children:"A race condition is a software bug that occurs when the timing or ordering of events affects the correctness of a program. In React applications, race conditions typically happen when dealing with asynchronous operations like:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"API calls"}),"\n",(0,s.jsx)(n.li,{children:"Data fetching"}),"\n",(0,s.jsx)(n.li,{children:"State updates"}),"\n",(0,s.jsx)(n.li,{children:"Event handlers"}),"\n",(0,s.jsx)(n.li,{children:"Timeouts and intervals"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"These issues often manifest when a component is unmounted before an async operation completes, or when multiple async operations complete in an unexpected order."}),"\n",(0,s.jsx)(n.h2,{id:"common-scenarios-where-race-conditions-occur",children:"Common Scenarios Where Race Conditions Occur"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Multiple API Calls"}),": When making successive API calls (e.g., search functionality)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Component Unmounting"}),": When async operations complete after a component unmounts"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"State Updates"}),": When multiple setState calls happen concurrently"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Event Handlers"}),": When multiple events trigger async operations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Network Requests"}),": When responses arrive in a different order than requested"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"solutions-and-best-practices",children:"Solutions and Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"1-cleanup-functions-in-useeffect",children:"1. Cleanup Functions in useEffect"}),"\n",(0,s.jsxs)(n.p,{children:["The most basic protection against race conditions is using cleanup functions in ",(0,s.jsx)(n.code,{children:"useEffect"}),". This ensures that we don't update state after a component unmounts."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"function SearchComponent() {\n  const [data, setData] = useState(null);\n\n  useEffect(() => {\n    let isSubscribed = true;\n\n    async function fetchData() {\n      try {\n        const response = await fetch('https://api.example.com/data');\n        const result = await response.json();\n\n        if (isSubscribed) {\n          setData(result);\n        }\n      } catch (error) {\n        if (isSubscribed) {\n          console.error(error);\n        }\n      }\n    }\n\n    fetchData();\n\n    return () => {\n      isSubscribed = false;\n    };\n  }, []);\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-abortcontroller-for-network-requests",children:"2. AbortController for Network Requests"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"AbortController"})," allows you to cancel pending fetch requests when a component unmounts or when dependencies change."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"function DataFetcher() {\n  useEffect(() => {\n    const abortController = new AbortController();\n\n    async function fetchData() {\n      try {\n        const response = await fetch('https://api.example.com/data', {\n          signal: abortController.signal,\n        });\n        const data = await response.json();\n        // Process data\n      } catch (error) {\n        if (error.name === 'AbortError') {\n          // Handle abort\n        }\n      }\n    }\n\n    fetchData();\n\n    return () => {\n      abortController.abort();\n    };\n  }, []);\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"3-request-ids-for-multiple-requests",children:"3. Request IDs for Multiple Requests"}),"\n",(0,s.jsx)(n.p,{children:"When dealing with multiple sequential requests, use request IDs to ensure only the latest request's response is processed."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"function SearchWithRequestId() {\n  const [results, setResults] = useState([]);\n  const [search, setSearch] = useState('');\n  const requestIdRef = useRef(0);\n\n  useEffect(() => {\n    const currentRequestId = ++requestIdRef.current;\n\n    async function performSearch() {\n      try {\n        const response = await fetch(`/api/search?q=${search}`);\n        const data = await response.json();\n\n        if (currentRequestId === requestIdRef.current) {\n          setResults(data);\n        }\n      } catch (error) {\n        console.error(error);\n      }\n    }\n\n    performSearch();\n  }, [search]);\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"4-debouncing-for-frequent-updates",children:"4. Debouncing for Frequent Updates"}),"\n",(0,s.jsx)(n.p,{children:"Debouncing helps prevent race conditions by limiting the rate of async operations."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"import { debounce } from 'lodash';\n\nfunction DebouncedSearch() {\n  const [searchTerm, setSearchTerm] = useState('');\n\n  const debouncedSearch = useCallback(\n    debounce(term => {\n      // Perform search\n      console.log('Searching for:', term);\n    }, 500),\n    []\n  );\n\n  useEffect(() => {\n    if (searchTerm) {\n      debouncedSearch(searchTerm);\n    }\n  }, [searchTerm, debouncedSearch]);\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"5-safe-state-updates",children:"5. Safe State Updates"}),"\n",(0,s.jsx)(n.p,{children:"Always use functional updates when new state depends on previous state to avoid race conditions in state updates."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"// Bad\nsetCount(count + 1);\n\n// Good\nsetCount(prevCount => prevCount + 1);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"6-custom-hook-for-safe-dispatches",children:"6. Custom Hook for Safe Dispatches"}),"\n",(0,s.jsx)(n.p,{children:"Create a custom hook to ensure state updates only occur when a component is mounted."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"function useSafeDispatch(dispatch) {\n  const mounted = useRef(false);\n\n  useEffect(() => {\n    mounted.current = true;\n    return () => {\n      mounted.current = false;\n    };\n  }, []);\n\n  return useCallback(\n    (...args) => {\n      if (mounted.current) {\n        dispatch(...args);\n      }\n    },\n    [dispatch]\n  );\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices-checklist",children:"Best Practices Checklist"}),"\n",(0,s.jsxs)(n.p,{children:["\u2705 Always implement cleanup functions in useEffect",(0,s.jsx)(n.br,{}),"\n","\u2705 Cancel network requests on component unmount",(0,s.jsx)(n.br,{}),"\n","\u2705 Use request IDs for multiple async operations",(0,s.jsx)(n.br,{}),"\n","\u2705 Implement debouncing for frequent updates",(0,s.jsx)(n.br,{}),"\n","\u2705 Use functional updates for state that depends on previous state",(0,s.jsx)(n.br,{}),"\n","\u2705 Track component mounted state with refs",(0,s.jsx)(n.br,{}),"\n","\u2705 Consider custom hooks for complex async operations"]}),"\n",(0,s.jsx)(n.h2,{id:"common-pitfalls",children:"Common Pitfalls"}),"\n",(0,s.jsxs)(n.p,{children:["\u274c Not cleaning up subscriptions or timers",(0,s.jsx)(n.br,{}),"\n","\u274c Using stale closures in async operations",(0,s.jsx)(n.br,{}),"\n","\u274c Not handling component unmounting",(0,s.jsx)(n.br,{}),"\n","\u274c Directly updating state without checking if component is mounted",(0,s.jsx)(n.br,{}),"\n","\u274c Not cancelling pending requests when dependencies change"]}),"\n",(0,s.jsx)(n.h2,{id:"testing-for-race-conditions",children:"Testing for Race Conditions"}),"\n",(0,s.jsx)(n.p,{children:"Here's a simple test case to verify race condition handling:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"test('handles race conditions in async operations', async () => {\n  const { result } = renderHook(() => useAsyncOperation());\n\n  // Trigger multiple async operations\n  act(() => {\n    result.current.trigger();\n    result.current.trigger();\n  });\n\n  // Wait for operations to complete\n  await waitFor(() => {\n    expect(result.current.isComplete).toBe(true);\n  });\n\n  // Verify only the latest operation's result is used\n  expect(result.current.data).toBe('latest result');\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsx)(n.p,{children:"Race conditions are a common source of bugs in React applications, but they can be effectively managed with proper techniques and patterns. By following the best practices outlined in this guide and implementing appropriate safeguards, you can build more reliable and robust React applications."}),"\n",(0,s.jsx)(n.p,{children:"Remember that preventing race conditions is not just about fixing bugs\u2014it's about designing your application's architecture to handle asynchronous operations safely from the start."})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}}}]);