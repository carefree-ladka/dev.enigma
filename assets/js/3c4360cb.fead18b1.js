"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[4543],{6088:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>c,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var t=r(4848),i=r(8453);const o={},l="Binary Tree",s={id:"DSA/DSA with JavaScript/DSA Cheatsheets/Tree",title:"Binary Tree",description:"A comprehensive guide to tree algorithms and techniques for Data Structures and Algorithms.",source:"@site/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Tree.mdx",sourceDirName:"DSA/DSA with JavaScript/DSA Cheatsheets",slug:"/DSA/DSA with JavaScript/DSA Cheatsheets/Tree",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Tree",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Tree.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Tree Recursion Patterns",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Tree Recursion"},next:{title:"Trie",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Trie"}},a={},d=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Basic Tree Node Structure",id:"basic-tree-node-structure",level:2},{value:"Helper Function: Create Sample Tree",id:"helper-function-create-sample-tree",level:3},{value:"Tree Traversal Techniques",id:"tree-traversal-techniques",level:2},{value:"Depth-First Search (DFS) Traversals",id:"depth-first-search-dfs-traversals",level:3},{value:"1. Pre-order Traversal: Root \u2192 Left \u2192 Right",id:"1-pre-order-traversal-root--left--right",level:4},{value:"2. In-order Traversal: Left \u2192 Root \u2192 Right",id:"2-in-order-traversal-left--root--right",level:4},{value:"3. Post-order Traversal: Left \u2192 Right \u2192 Root",id:"3-post-order-traversal-left--right--root",level:4},{value:"Breadth-First Search (BFS)",id:"breadth-first-search-bfs",level:3},{value:"Level Order Traversal",id:"level-order-traversal",level:4},{value:"Level Order with Level Separation",id:"level-order-with-level-separation",level:4},{value:"Tree Properties and Measurements",id:"tree-properties-and-measurements",level:2},{value:"Calculate Tree Height/Depth",id:"calculate-tree-heightdepth",level:3},{value:"Calculate Minimum Depth",id:"calculate-minimum-depth",level:3},{value:"Count Total Nodes",id:"count-total-nodes",level:3},{value:"Check if Tree is Balanced",id:"check-if-tree-is-balanced",level:3},{value:"Tree Search Techniques",id:"tree-search-techniques",level:2},{value:"Search in Binary Tree",id:"search-in-binary-tree",level:3},{value:"Search in Binary Search Tree (Optimized)",id:"search-in-binary-search-tree-optimized",level:3},{value:"Path Finding Techniques",id:"path-finding-techniques",level:2},{value:"Find Path from Root to Target",id:"find-path-from-root-to-target",level:3},{value:"Find All Root-to-Leaf Paths",id:"find-all-root-to-leaf-paths",level:3},{value:"Check Path Sum",id:"check-path-sum",level:3},{value:"Tree Modification Techniques",id:"tree-modification-techniques",level:2},{value:"Invert/Mirror Binary Tree",id:"invertmirror-binary-tree",level:3},{value:"Flatten Binary Tree to Linked List",id:"flatten-binary-tree-to-linked-list",level:3},{value:"Binary Search Tree Operations",id:"binary-search-tree-operations",level:2},{value:"Insert into BST",id:"insert-into-bst",level:3},{value:"Find Minimum Value",id:"find-minimum-value",level:3},{value:"Delete from BST",id:"delete-from-bst",level:3},{value:"Validate BST",id:"validate-bst",level:3},{value:"Advanced Tree Techniques",id:"advanced-tree-techniques",level:2},{value:"Lowest Common Ancestor (LCA)",id:"lowest-common-ancestor-lca",level:3},{value:"Tree Diameter",id:"tree-diameter",level:3},{value:"Serialize and Deserialize",id:"serialize-and-deserialize",level:3},{value:"Serialize Tree",id:"serialize-tree",level:4},{value:"Deserialize Tree",id:"deserialize-tree",level:4},{value:"Usage Examples",id:"usage-examples",level:2},{value:"Time Complexity Summary",id:"time-complexity-summary",level:2},{value:"Key Patterns to Remember",id:"key-patterns-to-remember",level:2}];function h(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"binary-tree",children:"Binary Tree"})}),"\n",(0,t.jsx)(n.p,{children:"A comprehensive guide to tree algorithms and techniques for Data Structures and Algorithms."}),"\n",(0,t.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#basic-tree-node-structure",children:"Basic Tree Node Structure"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#tree-traversal-techniques",children:"Tree Traversal Techniques"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#tree-properties-and-measurements",children:"Tree Properties and Measurements"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#tree-search-techniques",children:"Tree Search Techniques"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#path-finding-techniques",children:"Path Finding Techniques"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#tree-modification-techniques",children:"Tree Modification Techniques"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#binary-search-tree-operations",children:"Binary Search Tree Operations"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#advanced-tree-techniques",children:"Advanced Tree Techniques"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#usage-examples",children:"Usage Examples"})}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"basic-tree-node-structure",children:"Basic Tree Node Structure"}),"\n",(0,t.jsx)(n.p,{children:"The foundation of all tree operations starts with a simple node structure:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"class TreeNode {\n    constructor(val, left = null, right = null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"helper-function-create-sample-tree",children:"Helper Function: Create Sample Tree"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function createSampleTree() {\n    //       1\n    //      / \\\n    //     2   3\n    //    / \\   \\\n    //   4   5   6\n    const root = new TreeNode(1);\n    root.left = new TreeNode(2);\n    root.right = new TreeNode(3);\n    root.left.left = new TreeNode(4);\n    root.left.right = new TreeNode(5);\n    root.right.right = new TreeNode(6);\n    return root;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"tree-traversal-techniques",children:"Tree Traversal Techniques"}),"\n",(0,t.jsxs)(n.p,{children:["Tree traversal is fundamental to most tree operations. There are two main categories: ",(0,t.jsx)(n.strong,{children:"Depth-First Search (DFS)"})," and ",(0,t.jsx)(n.strong,{children:"Breadth-First Search (BFS)"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"depth-first-search-dfs-traversals",children:"Depth-First Search (DFS) Traversals"}),"\n",(0,t.jsx)(n.h4,{id:"1-pre-order-traversal-root--left--right",children:"1. Pre-order Traversal: Root \u2192 Left \u2192 Right"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function preorderTraversal(root) {\n    const result = [];\n\n    function dfs(node) {\n        if (!node) return;\n        result.push(node.val);  // Process root first\n        dfs(node.left);         // Then left subtree\n        dfs(node.right);        // Then right subtree\n    }\n\n    dfs(root);\n    return result;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Time Complexity:"})," O(n) | ",(0,t.jsx)(n.strong,{children:"Space Complexity:"})," O(h) where h is height"]}),"\n",(0,t.jsx)(n.h4,{id:"2-in-order-traversal-left--root--right",children:"2. In-order Traversal: Left \u2192 Root \u2192 Right"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function inorderTraversal(root) {\n    const result = [];\n\n    function dfs(node) {\n        if (!node) return;\n        dfs(node.left);         // Left subtree first\n        result.push(node.val);  // Then process root\n        dfs(node.right);        // Then right subtree\n    }\n\n    dfs(root);\n    return result;\n}\n"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"\ud83d\udca1 Pro Tip:"})," In-order traversal gives sorted order for Binary Search Trees!"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"3-post-order-traversal-left--right--root",children:"3. Post-order Traversal: Left \u2192 Right \u2192 Root"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function postorderTraversal(root) {\n    const result = [];\n\n    function dfs(node) {\n        if (!node) return;\n        dfs(node.left);         // Left subtree first\n        dfs(node.right);        // Then right subtree\n        result.push(node.val);  // Process root last\n    }\n\n    dfs(root);\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"breadth-first-search-bfs",children:"Breadth-First Search (BFS)"}),"\n",(0,t.jsx)(n.h4,{id:"level-order-traversal",children:"Level Order Traversal"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function levelOrderTraversal(root) {\n    if (!root) return [];\n\n    const result = [];\n    const queue = [root];\n\n    while (queue.length > 0) {\n        const node = queue.shift();\n        result.push(node.val);\n\n        if (node.left) queue.push(node.left);\n        if (node.right) queue.push(node.right);\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.h4,{id:"level-order-with-level-separation",children:"Level Order with Level Separation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function levelOrderByLevels(root) {\n    if (!root) return [];\n\n    const result = [];\n    const queue = [root];\n\n    while (queue.length > 0) {\n        const levelSize = queue.length;\n        const currentLevel = [];\n\n        for (let i = 0; i < levelSize; i++) {\n            const node = queue.shift();\n            currentLevel.push(node.val);\n\n            if (node.left) queue.push(node.left);\n            if (node.right) queue.push(node.right);\n        }\n\n        result.push(currentLevel);\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"tree-properties-and-measurements",children:"Tree Properties and Measurements"}),"\n",(0,t.jsx)(n.h3,{id:"calculate-tree-heightdepth",children:"Calculate Tree Height/Depth"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function maxDepth(root) {\n    if (!root) return 0;\n    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"calculate-minimum-depth",children:"Calculate Minimum Depth"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function minDepth(root) {\n    if (!root) return 0;\n    if (!root.left && !root.right) return 1;\n\n    let minLeft = root.left ? minDepth(root.left) : Infinity;\n    let minRight = root.right ? minDepth(root.right) : Infinity;\n\n    return 1 + Math.min(minLeft, minRight);\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"count-total-nodes",children:"Count Total Nodes"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function countNodes(root) {\n    if (!root) return 0;\n    return 1 + countNodes(root.left) + countNodes(root.right);\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"check-if-tree-is-balanced",children:"Check if Tree is Balanced"}),"\n",(0,t.jsx)(n.p,{children:"A tree is balanced if the height difference between left and right subtrees is \u2264 1."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function isBalanced(root) {\n    function checkBalance(node) {\n        if (!node) return 0;\n\n        const leftHeight = checkBalance(node.left);\n        if (leftHeight === -1) return -1;\n\n        const rightHeight = checkBalance(node.right);\n        if (rightHeight === -1) return -1;\n\n        if (Math.abs(leftHeight - rightHeight) > 1) return -1;\n\n        return 1 + Math.max(leftHeight, rightHeight);\n    }\n\n    return checkBalance(root) !== -1;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"tree-search-techniques",children:"Tree Search Techniques"}),"\n",(0,t.jsx)(n.h3,{id:"search-in-binary-tree",children:"Search in Binary Tree"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function searchBinaryTree(root, target) {\n    if (!root) return false;\n    if (root.val === target) return true;\n\n    return searchBinaryTree(root.left, target) || searchBinaryTree(root.right, target);\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Time Complexity:"})," O(n)"]}),"\n",(0,t.jsx)(n.h3,{id:"search-in-binary-search-tree-optimized",children:"Search in Binary Search Tree (Optimized)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function searchBST(root, target) {\n    if (!root) return null;\n\n    if (root.val === target) return root;\n\n    if (target < root.val) {\n        return searchBST(root.left, target);\n    } else {\n        return searchBST(root.right, target);\n    }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Time Complexity:"})," O(log n) average, O(n) worst case"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"path-finding-techniques",children:"Path Finding Techniques"}),"\n",(0,t.jsx)(n.h3,{id:"find-path-from-root-to-target",children:"Find Path from Root to Target"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function findPath(root, target) {\n    const path = [];\n\n    function dfs(node) {\n        if (!node) return false;\n\n        path.push(node.val);\n\n        if (node.val === target) return true;\n\n        if (dfs(node.left) || dfs(node.right)) return true;\n\n        path.pop(); // Backtrack\n        return false;\n    }\n\n    return dfs(root) ? path : [];\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"find-all-root-to-leaf-paths",children:"Find All Root-to-Leaf Paths"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function allRootToLeafPaths(root) {\n    const paths = [];\n\n    function dfs(node, currentPath) {\n        if (!node) return;\n\n        currentPath.push(node.val);\n\n        // If it's a leaf node, add the path\n        if (!node.left && !node.right) {\n            paths.push([...currentPath]);\n        } else {\n            dfs(node.left, currentPath);\n            dfs(node.right, currentPath);\n        }\n\n        currentPath.pop(); // Backtrack\n    }\n\n    dfs(root, []);\n    return paths;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"check-path-sum",children:"Check Path Sum"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function hasPathSum(root, targetSum) {\n    if (!root) return false;\n\n    if (!root.left && !root.right) {\n        return root.val === targetSum;\n    }\n\n    const remainingSum = targetSum - root.val;\n    return hasPathSum(root.left, remainingSum) || hasPathSum(root.right, remainingSum);\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"tree-modification-techniques",children:"Tree Modification Techniques"}),"\n",(0,t.jsx)(n.h3,{id:"invertmirror-binary-tree",children:"Invert/Mirror Binary Tree"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function invertTree(root) {\n    if (!root) return null;\n\n    // Swap left and right children\n    const temp = root.left;\n    root.left = root.right;\n    root.right = temp;\n\n    // Recursively invert subtrees\n    invertTree(root.left);\n    invertTree(root.right);\n\n    return root;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"flatten-binary-tree-to-linked-list",children:"Flatten Binary Tree to Linked List"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function flattenToLinkedList(root) {\n    if (!root) return;\n\n    flattenToLinkedList(root.left);\n    flattenToLinkedList(root.right);\n\n    const tempRight = root.right;\n    root.right = root.left;\n    root.left = null;\n\n    // Find the rightmost node\n    let current = root;\n    while (current.right) {\n        current = current.right;\n    }\n    current.right = tempRight;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"binary-search-tree-operations",children:"Binary Search Tree Operations"}),"\n",(0,t.jsx)(n.h3,{id:"insert-into-bst",children:"Insert into BST"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function insertIntoBST(root, val) {\n    if (!root) return new TreeNode(val);\n\n    if (val < root.val) {\n        root.left = insertIntoBST(root.left, val);\n    } else {\n        root.right = insertIntoBST(root.right, val);\n    }\n\n    return root;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"find-minimum-value",children:"Find Minimum Value"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function findMin(root) {\n    while (root && root.left) {\n        root = root.left;\n    }\n    return root ? root.val : null;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"delete-from-bst",children:"Delete from BST"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function deleteFromBST(root, key) {\n    if (!root) return null;\n\n    if (key < root.val) {\n        root.left = deleteFromBST(root.left, key);\n    } else if (key > root.val) {\n        root.right = deleteFromBST(root.right, key);\n    } else {\n        // Node to delete found\n        if (!root.left) return root.right;\n        if (!root.right) return root.left;\n\n        // Node has two children\n        const minRight = findMin(root.right);\n        root.val = minRight;\n        root.right = deleteFromBST(root.right, minRight);\n    }\n\n    return root;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"validate-bst",children:"Validate BST"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function isValidBST(root) {\n    function validate(node, min, max) {\n        if (!node) return true;\n\n        if (node.val <= min || node.val >= max) return false;\n\n        return validate(node.left, min, node.val) &&\n               validate(node.right, node.val, max);\n    }\n\n    return validate(root, -Infinity, Infinity);\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"advanced-tree-techniques",children:"Advanced Tree Techniques"}),"\n",(0,t.jsx)(n.h3,{id:"lowest-common-ancestor-lca",children:"Lowest Common Ancestor (LCA)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function lowestCommonAncestor(root, p, q) {\n    if (!root || root === p || root === q) return root;\n\n    const left = lowestCommonAncestor(root.left, p, q);\n    const right = lowestCommonAncestor(root.right, p, q);\n\n    if (left && right) return root;\n    return left || right;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"tree-diameter",children:"Tree Diameter"}),"\n",(0,t.jsx)(n.p,{children:"Find the longest path between any two nodes:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function diameterOfBinaryTree(root) {\n    let maxDiameter = 0;\n\n    function height(node) {\n        if (!node) return 0;\n\n        const leftHeight = height(node.left);\n        const rightHeight = height(node.right);\n\n        // Update diameter if current path is longer\n        maxDiameter = Math.max(maxDiameter, leftHeight + rightHeight);\n\n        return 1 + Math.max(leftHeight, rightHeight);\n    }\n\n    height(root);\n    return maxDiameter;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"serialize-and-deserialize",children:"Serialize and Deserialize"}),"\n",(0,t.jsx)(n.h4,{id:"serialize-tree",children:"Serialize Tree"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function serialize(root) {\n    const result = [];\n\n    function preorder(node) {\n        if (!node) {\n            result.push('null');\n            return;\n        }\n        result.push(node.val.toString());\n        preorder(node.left);\n        preorder(node.right);\n    }\n\n    preorder(root);\n    return result.join(',');\n}\n"})}),"\n",(0,t.jsx)(n.h4,{id:"deserialize-tree",children:"Deserialize Tree"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function deserialize(data) {\n    const values = data.split(',');\n    let index = 0;\n\n    function buildTree() {\n        if (values[index] === 'null') {\n            index++;\n            return null;\n        }\n\n        const node = new TreeNode(parseInt(values[index]));\n        index++;\n        node.left = buildTree();\n        node.right = buildTree();\n        return node;\n    }\n\n    return buildTree();\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,t.jsx)(n.p,{children:"Here's how to use these techniques:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'console.log("=== Tree Techniques Demo ===");\n\nconst tree = createSampleTree();\n\nconsole.log("Pre-order:", preorderTraversal(tree));\nconsole.log("In-order:", inorderTraversal(tree));\nconsole.log("Post-order:", postorderTraversal(tree));\nconsole.log("Level-order:", levelOrderTraversal(tree));\nconsole.log("Level-order by levels:", levelOrderByLevels(tree));\n\nconsole.log("Max depth:", maxDepth(tree));\nconsole.log("Min depth:", minDepth(tree));\nconsole.log("Total nodes:", countNodes(tree));\nconsole.log("Is balanced:", isBalanced(tree));\n\nconsole.log("Search for 5:", searchBinaryTree(tree, 5));\nconsole.log("Path to 5:", findPath(tree, 5));\nconsole.log("All root-to-leaf paths:", allRootToLeafPaths(tree));\n\nconsole.log("Tree diameter:", diameterOfBinaryTree(tree));\n\nconst serialized = serialize(tree);\nconsole.log("Serialized:", serialized);\nconst deserialized = deserialize(serialized);\nconsole.log("Deserialized pre-order:", preorderTraversal(deserialized));\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"time-complexity-summary",children:"Time Complexity Summary"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Operation"}),(0,t.jsx)(n.th,{children:"Time Complexity"}),(0,t.jsx)(n.th,{children:"Space Complexity"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Traversal"}),(0,t.jsx)(n.td,{children:"O(n)"}),(0,t.jsx)(n.td,{children:"O(h)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Search (Binary Tree)"}),(0,t.jsx)(n.td,{children:"O(n)"}),(0,t.jsx)(n.td,{children:"O(h)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Search (BST)"}),(0,t.jsx)(n.td,{children:"O(log n) avg, O(n) worst"}),(0,t.jsx)(n.td,{children:"O(h)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Insert (BST)"}),(0,t.jsx)(n.td,{children:"O(log n) avg, O(n) worst"}),(0,t.jsx)(n.td,{children:"O(h)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Delete (BST)"}),(0,t.jsx)(n.td,{children:"O(log n) avg, O(n) worst"}),(0,t.jsx)(n.td,{children:"O(h)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Height Calculation"}),(0,t.jsx)(n.td,{children:"O(n)"}),(0,t.jsx)(n.td,{children:"O(h)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"LCA"}),(0,t.jsx)(n.td,{children:"O(n)"}),(0,t.jsx)(n.td,{children:"O(h)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Serialize/Deserialize"}),(0,t.jsx)(n.td,{children:"O(n)"}),(0,t.jsx)(n.td,{children:"O(n)"})]})]})]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Note:"})," h represents the height of the tree. In a balanced tree, h = log n."]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"key-patterns-to-remember",children:"Key Patterns to Remember"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Recursive Pattern"}),": Most tree problems use recursion naturally"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Base Case"}),": Always handle null nodes first"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Divide and Conquer"}),": Break problem into left and right subtrees"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Backtracking"}),": Use for path-finding problems"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Level Order"}),": Use queue for BFS traversal"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"BST Property"}),": Left < Root < Right for optimization"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This comprehensive guide covers the essential tree techniques you'll need for coding interviews and competitive programming!"})]})}function c(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>s});var t=r(6540);const i={},o=t.createContext(i);function l(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);