"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[5672],{12815:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>i,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>c});var s=t(74848),o=t(28453);const r={},i="Complete Guide to Dexie.js & Offline-First Apps",a={id:"WebDev/React/Complete Guide to Dexie.js & Offline-First Apps",title:"Complete Guide to Dexie.js & Offline-First Apps",description:"Table of Contents",source:"@site/docs/WebDev/React/Complete Guide to Dexie.js & Offline-First Apps.mdx",sourceDirName:"WebDev/React",slug:"/WebDev/React/Complete Guide to Dexie.js & Offline-First Apps",permalink:"/docs/WebDev/React/Complete Guide to Dexie.js & Offline-First Apps",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/WebDev/React/Complete Guide to Dexie.js & Offline-First Apps.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Atomic Design in React",permalink:"/docs/WebDev/React/ATOMICDesign"},next:{title:"React Compound Components",permalink:"/docs/WebDev/React/CompoundComponents"}},d={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Introduction to Dexie.js",id:"introduction",level:2},{value:"Why Dexie.js for Offline-First Apps?",id:"why-dexie",level:2},{value:"Getting Started",id:"getting-started",level:2},{value:"Installation",id:"installation",level:3},{value:"Step 1: Define Your Database Schema",id:"step-1-define-your-database-schema",level:3},{value:"Basic CRUD Operations",id:"crud-operations",level:2},{value:"Create (Add Data)",id:"create-add-data",level:3},{value:"Read (Query Data)",id:"read-query-data",level:3},{value:"Update",id:"update",level:3},{value:"Delete",id:"delete",level:3},{value:"Queries and Filtering",id:"queries",level:2},{value:"Basic Queries",id:"basic-queries",level:3},{value:"Advanced Queries",id:"advanced-queries",level:3},{value:"Full-Text Search Pattern",id:"full-text-search-pattern",level:3},{value:"Transactions",id:"transactions",level:2},{value:"Basic Transaction",id:"basic-transaction",level:3},{value:"Transaction Modes",id:"transaction-modes",level:3},{value:"Error Handling in Transactions",id:"error-handling-in-transactions",level:3},{value:"Offline-First Sync Pattern",id:"sync-pattern",level:2},{value:"Pattern Overview",id:"pattern-overview",level:3},{value:"Implementation",id:"implementation",level:3},{value:"Manual Sync Trigger",id:"manual-sync-trigger",level:3},{value:"React Integration",id:"react-integration",level:2},{value:"Using useLiveQuery",id:"using-uselivequery",level:3},{value:"Advanced React Patterns",id:"advanced-react-patterns",level:3},{value:"Service Worker Setup",id:"service-worker",level:2},{value:"Register Service Worker",id:"register-service-worker",level:3},{value:"Basic Service Worker Structure",id:"basic-service-worker-structure",level:3},{value:"Background Sync Implementation",id:"background-sync",level:2},{value:"App-Side Sync Trigger",id:"app-side-sync-trigger",level:3},{value:"Service Worker Sync Handler",id:"service-worker-sync-handler",level:3},{value:"Complete Integration Example",id:"complete-example",level:2},{value:"Full App Structure",id:"full-app-structure",level:3},{value:"Conflict Resolution Strategies",id:"conflict-resolution",level:2},{value:"Why Conflicts Happen",id:"why-conflicts-happen",level:3},{value:"Strategy 1: Last-Write-Wins (LWW)",id:"strategy-1-last-write-wins-lww",level:3},{value:"Strategy 2: Client-Wins or Server-Wins",id:"strategy-2-client-wins-or-server-wins",level:3},{value:"Strategy 3: Field-Level Merge",id:"strategy-3-field-level-merge",level:3},{value:"Strategy 4: Manual Resolution",id:"strategy-4-manual-resolution",level:3},{value:"Complete Conflict-Aware Sync",id:"complete-conflict-aware-sync",level:3},{value:"Production Best Practices",id:"best-practices",level:2},{value:"1. Database Versioning",id:"1-database-versioning",level:3},{value:"2. Error Handling",id:"2-error-handling",level:3},{value:"3. Performance Optimization",id:"3-performance-optimization",level:3},{value:"4. Security Considerations",id:"4-security-considerations",level:3},{value:"5. Testing",id:"5-testing",level:3},{value:"6. Monitoring and Debugging",id:"6-monitoring-and-debugging",level:3},{value:"7. Cleanup and Maintenance",id:"7-cleanup-and-maintenance",level:3},{value:"8. Network Detection and Smart Sync",id:"8-network-detection-and-smart-sync",level:3},{value:"9. Batch Sync for Performance",id:"9-batch-sync-for-performance",level:3},{value:"10. Progressive Web App Integration",id:"10-progressive-web-app-integration",level:3},{value:"Advanced Patterns",id:"advanced-patterns",level:2},{value:"Optimistic UI Updates",id:"optimistic-ui-updates",level:3},{value:"Delta Sync (Only Sync Changes)",id:"delta-sync-only-sync-changes",level:3},{value:"Real-Time Sync with WebSockets",id:"real-time-sync-with-websockets",level:3},{value:"Troubleshooting Common Issues",id:"troubleshooting-common-issues",level:2},{value:"Issue 1: Service Worker Not Updating",id:"issue-1-service-worker-not-updating",level:3},{value:"Issue 2: IndexedDB Quota Exceeded",id:"issue-2-indexeddb-quota-exceeded",level:3},{value:"Issue 3: Sync Not Triggering",id:"issue-3-sync-not-triggering",level:3},{value:"Issue 4: Data Not Persisting",id:"issue-4-data-not-persisting",level:3},{value:"Performance Metrics and Monitoring",id:"performance-metrics-and-monitoring",level:2},{value:"Summary",id:"summary",level:2},{value:"Key Takeaways",id:"key-takeaways",level:3},{value:"Next Steps",id:"next-steps",level:3},{value:"Additional Resources",id:"additional-resources",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"complete-guide-to-dexiejs--offline-first-apps",children:"Complete Guide to Dexie.js & Offline-First Apps"})}),"\n",(0,s.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#introduction",children:"Introduction to Dexie.js"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#why-dexie",children:"Why Dexie.js for Offline-First Apps"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getting-started",children:"Getting Started"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#crud-operations",children:"Basic CRUD Operations"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#queries",children:"Queries and Filtering"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#transactions",children:"Transactions"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#sync-pattern",children:"Offline-First Sync Pattern"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#react-integration",children:"React Integration"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#service-worker",children:"Service Worker Setup"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#background-sync",children:"Background Sync Implementation"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#complete-example",children:"Complete Integration Example"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#conflict-resolution",children:"Conflict Resolution Strategies"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#best-practices",children:"Production Best Practices"})}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"introduction",children:"Introduction to Dexie.js"}),"\n",(0,s.jsx)(n.p,{children:"Dexie.js is a lightweight wrapper around IndexedDB, the browser's built-in database. It simplifies working with IndexedDB's async API and provides a more intuitive interface for transactions, queries, and syncing."}),"\n",(0,s.jsx)(n.p,{children:"IndexedDB is a powerful client-side storage solution that allows you to store significant amounts of structured data in the browser, making it ideal for offline-first applications."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"why-dexie",children:"Why Dexie.js for Offline-First Apps?"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Key Benefits:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"IndexedDB Powered"})," \u2192 Persists data locally, survives page reloads and offline scenarios"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Promise-Based API"})," \u2192 Cleaner, more modern code compared to raw IndexedDB"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Rich Queries"})," \u2192 SQL-like methods such as ",(0,s.jsx)(n.code,{children:".where()"}),", ",(0,s.jsx)(n.code,{children:".equals()"}),", ",(0,s.jsx)(n.code,{children:".between()"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Atomic Transactions"})," \u2192 Ensures data consistency with atomic reads and writes"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Sync Support"})," \u2192 Easily integrates with server synchronization strategies"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"React Hooks"})," \u2192 First-class support for React with live queries"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getting-started",children:"Getting Started"}),"\n",(0,s.jsx)(n.h3,{id:"installation",children:"Installation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"npm install dexie\n"})}),"\n",(0,s.jsx)(n.p,{children:"For React projects, also install:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"npm install dexie-react-hooks\n"})}),"\n",(0,s.jsx)(n.p,{children:"For Service Worker integration:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"npm install idb\n"})}),"\n",(0,s.jsx)(n.h3,{id:"step-1-define-your-database-schema",children:"Step 1: Define Your Database Schema"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'import Dexie from \'dexie\';\n\n// Create database instance\nconst db = new Dexie("MyOfflineAppDB");\n\n// Define schema with version\ndb.version(1).stores({\n  todos: "++id, title, completed, updatedAt, synced",\n  users: "++id, name, email",\n  notes: "++id, content, createdAt, tags"\n});\n\nexport default db;\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Schema Syntax:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"++id"})," \u2192 Auto-increment primary key"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"id"})," \u2192 Custom primary key (you manage the values)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"title, completed"})," \u2192 Indexed fields for faster queries"]}),"\n",(0,s.jsx)(n.li,{children:"Non-indexed fields can still be stored, they just won't be optimized for queries"}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"crud-operations",children:"Basic CRUD Operations"}),"\n",(0,s.jsx)(n.h3,{id:"create-add-data",children:"Create (Add Data)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Add single record\nawait db.todos.add({\n  title: "Learn Dexie.js",\n  completed: false,\n  updatedAt: Date.now()\n});\n\n// Add multiple records\nawait db.todos.bulkAdd([\n  { title: "Task 1", completed: false, updatedAt: Date.now() },\n  { title: "Task 2", completed: true, updatedAt: Date.now() }\n]);\n'})}),"\n",(0,s.jsx)(n.h3,{id:"read-query-data",children:"Read (Query Data)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Get all records\nconst allTodos = await db.todos.toArray();\n\n// Get by primary key\nconst todo = await db.todos.get(1);\n\n// Get first matching record\nconst firstCompleted = await db.todos\n  .where("completed")\n  .equals(true)\n  .first();\n\n// Count records\nconst totalTodos = await db.todos.count();\n'})}),"\n",(0,s.jsx)(n.h3,{id:"update",children:"Update"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Update by primary key\nawait db.todos.update(1, {\n  completed: true,\n  updatedAt: Date.now()\n});\n\n// Update multiple records\nawait db.todos\n  .where("completed")\n  .equals(false)\n  .modify({ completed: true });\n'})}),"\n",(0,s.jsx)(n.h3,{id:"delete",children:"Delete"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Delete by primary key\nawait db.todos.delete(1);\n\n// Delete multiple records\nawait db.todos\n  .where("completed")\n  .equals(true)\n  .delete();\n\n// Clear entire table\nawait db.todos.clear();\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"queries",children:"Queries and Filtering"}),"\n",(0,s.jsx)(n.p,{children:"Dexie provides powerful SQL-like query capabilities:"}),"\n",(0,s.jsx)(n.h3,{id:"basic-queries",children:"Basic Queries"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Exact match\nconst completed = await db.todos\n  .where("completed")\n  .equals(true)\n  .toArray();\n\n// Range queries\nconst recent = await db.todos\n  .where("updatedAt")\n  .above(Date.now() - 86400000) // Last 24 hours\n  .toArray();\n\nconst range = await db.todos\n  .where("updatedAt")\n  .between(startDate, endDate)\n  .toArray();\n'})}),"\n",(0,s.jsx)(n.h3,{id:"advanced-queries",children:"Advanced Queries"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Search by email\nconst user = await db.users\n  .where("email")\n  .equals("john@example.com")\n  .first();\n\n// Multiple conditions with filter\nconst important = await db.todos\n  .where("completed")\n  .equals(false)\n  .filter(todo => todo.priority === "high")\n  .toArray();\n\n// Sorting\nconst sorted = await db.todos\n  .orderBy("updatedAt")\n  .reverse()\n  .toArray();\n\n// Pagination\nconst page = await db.todos\n  .orderBy("createdAt")\n  .offset(20)\n  .limit(10)\n  .toArray();\n'})}),"\n",(0,s.jsx)(n.h3,{id:"full-text-search-pattern",children:"Full-Text Search Pattern"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// Search in title (case-insensitive)\nconst results = await db.todos\n  .filter(todo =>\n    todo.title.toLowerCase().includes(searchTerm.toLowerCase())\n  )\n  .toArray();\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"transactions",children:"Transactions"}),"\n",(0,s.jsx)(n.p,{children:"Transactions ensure that multiple operations either all succeed or all fail together, maintaining data consistency."}),"\n",(0,s.jsx)(n.h3,{id:"basic-transaction",children:"Basic Transaction"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'await db.transaction(\'rw\', db.todos, db.users, async () => {\n  const user = await db.users.add({\n    name: "Alice",\n    email: "alice@mail.com"\n  });\n\n  await db.todos.add({\n    title: "Welcome Alice",\n    userId: user,\n    completed: false,\n    updatedAt: Date.now()\n  });\n});\n'})}),"\n",(0,s.jsx)(n.h3,{id:"transaction-modes",children:"Transaction Modes"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"'r'"})," \u2192 Read-only"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"'rw'"})," \u2192 Read-write"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"'rw!'"})," \u2192 Read-write with explicit commit"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"error-handling-in-transactions",children:"Error Handling in Transactions"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'try {\n  await db.transaction(\'rw\', db.todos, async () => {\n    await db.todos.add({ title: "Task 1" });\n    await db.todos.add({ title: "Task 2" });\n    // If any operation fails, all changes are rolled back\n  });\n} catch (error) {\n  console.error("Transaction failed:", error);\n}\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"sync-pattern",children:"Offline-First Sync Pattern"}),"\n",(0,s.jsxs)(n.p,{children:["The key principle: ",(0,s.jsx)(n.strong,{children:"Write locally first, sync to server later."})]}),"\n",(0,s.jsx)(n.h3,{id:"pattern-overview",children:"Pattern Overview"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Write Locally First"})," \u2192 Save all changes immediately to Dexie"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Mark as Unsynced"})," \u2192 Track which records need server sync with a ",(0,s.jsx)(n.code,{children:"synced"})," flag"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Queue Changes"})," \u2192 Keep unsynced items in the database"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Sync on Reconnect"})," \u2192 Push changes to server when online"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Update Status"})," \u2192 Mark items as synced after successful upload"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"implementation",children:"Implementation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Add offline task\nasync function addTodo(title) {\n  await db.todos.add({\n    title,\n    completed: false,\n    synced: false,\n    updatedAt: Date.now(),\n    createdAt: Date.now()\n  });\n}\n\n// Sync function\nasync function syncTodos() {\n  const unsynced = await db.todos\n    .where("synced")\n    .equals(false)\n    .toArray();\n\n  for (const todo of unsynced) {\n    try {\n      // Send to server\n      const response = await fetch("/api/todos", {\n        method: "POST",\n        body: JSON.stringify(todo),\n        headers: { "Content-Type": "application/json" }\n      });\n\n      if (response.ok) {\n        const serverData = await response.json();\n        // Update with server response\n        await db.todos.update(todo.id, {\n          synced: true,\n          serverId: serverData.id,\n          serverVersion: serverData.version\n        });\n      }\n    } catch (err) {\n      console.log("Sync failed, will retry later", err);\n    }\n  }\n}\n\n// Trigger sync on connection change\nwindow.addEventListener(\'online\', syncTodos);\n'})}),"\n",(0,s.jsx)(n.h3,{id:"manual-sync-trigger",children:"Manual Sync Trigger"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'async function triggerManualSync() {\n  if (navigator.onLine) {\n    await syncTodos();\n    console.log("Sync completed");\n  } else {\n    console.log("Offline - sync will happen when connection is restored");\n  }\n}\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"react-integration",children:"React Integration"}),"\n",(0,s.jsx)(n.p,{children:"Dexie provides excellent React integration through hooks that automatically update your components when data changes."}),"\n",(0,s.jsx)(n.h3,{id:"using-uselivequery",children:"Using useLiveQuery"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'import React, { useState } from "react";\nimport { useLiveQuery } from "dexie-react-hooks";\nimport db from "./db";\n\nfunction TodoList() {\n  const [newTitle, setNewTitle] = useState("");\n\n  // Automatically updates when database changes\n  const todos = useLiveQuery(() => db.todos.toArray(), []);\n\n  const addTodo = async () => {\n    await db.todos.add({\n      title: newTitle,\n      completed: false,\n      synced: false,\n      updatedAt: Date.now()\n    });\n    setNewTitle("");\n  };\n\n  const toggleTodo = async (id, completed) => {\n    await db.todos.update(id, {\n      completed: !completed,\n      synced: false,\n      updatedAt: Date.now()\n    });\n  };\n\n  const deleteTodo = async (id) => {\n    await db.todos.delete(id);\n  };\n\n  return (\n    <div>\n      <input\n        value={newTitle}\n        onChange={(e) => setNewTitle(e.target.value)}\n        placeholder="Add new todo"\n      />\n      <button onClick={addTodo}>Add</button>\n\n      <ul>\n        {todos?.map(todo => (\n          <li key={todo.id}>\n            <input\n              type="checkbox"\n              checked={todo.completed}\n              onChange={() => toggleTodo(todo.id, todo.completed)}\n            />\n            {todo.title}\n            {todo.synced ? " \u2705" : " \u23f3"}\n            <button onClick={() => deleteTodo(todo.id)}>Delete</button>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\nexport default TodoList;\n'})}),"\n",(0,s.jsx)(n.h3,{id:"advanced-react-patterns",children:"Advanced React Patterns"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Filtered query with live updates\nfunction CompletedTodos() {\n  const completed = useLiveQuery(\n    () => db.todos.where("completed").equals(true).toArray(),\n    []\n  );\n\n  return (\n    <div>\n      <h2>Completed Tasks ({completed?.length || 0})</h2>\n      {/* ... */}\n    </div>\n  );\n}\n\n// With dependencies\nfunction UserTodos({ userId }) {\n  const todos = useLiveQuery(\n    () => db.todos.where("userId").equals(userId).toArray(),\n    [userId] // Re-run query when userId changes\n  );\n\n  return <div>{/* ... */}</div>;\n}\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"service-worker",children:"Service Worker Setup"}),"\n",(0,s.jsx)(n.p,{children:"Service Workers enable background sync and offline functionality even when your app is closed."}),"\n",(0,s.jsx)(n.h3,{id:"register-service-worker",children:"Register Service Worker"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"src/index.js"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"if ('serviceWorker' in navigator) {\n  navigator.serviceWorker\n    .register('/sw.js')\n    .then(registration => {\n      console.log('[App] SW registered:', registration.scope);\n    })\n    .catch(err => {\n      console.error('[App] SW registration failed:', err);\n    });\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"basic-service-worker-structure",children:"Basic Service Worker Structure"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"public/sw.js"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// Import idb for cleaner IndexedDB access\nimportScripts(\"https://cdn.jsdelivr.net/npm/idb@7/build/iife/index-min.js\");\n\nconst { openDB } = self.idb;\n\n// Install event\nself.addEventListener('install', event => {\n  console.log('[SW] Installed');\n  self.skipWaiting(); // Activate immediately\n});\n\n// Activate event\nself.addEventListener('activate', event => {\n  console.log('[SW] Activated');\n  event.waitUntil(clients.claim()); // Take control of all clients\n});\n\n// Fetch event (for caching)\nself.addEventListener('fetch', event => {\n  // Handle fetch requests\n  event.respondWith(\n    caches.match(event.request)\n      .then(response => response || fetch(event.request))\n  );\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"background-sync",children:"Background Sync Implementation"}),"\n",(0,s.jsx)(n.p,{children:"Background Sync allows your app to defer actions until the user has stable connectivity."}),"\n",(0,s.jsx)(n.h3,{id:"app-side-sync-trigger",children:"App-Side Sync Trigger"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"src/db.js"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'import Dexie from "dexie";\n\nexport const db = new Dexie("MyOfflineAppDB");\n\ndb.version(1).stores({\n  todos: "++id, title, completed, updatedAt, synced, serverVersion"\n});\n\n// Add todo offline-first\nexport async function addTodo(title) {\n  const id = await db.todos.add({\n    title,\n    completed: false,\n    synced: false,\n    updatedAt: Date.now(),\n    createdAt: Date.now()\n  });\n\n  await triggerSync();\n  return id;\n}\n\n// Request background sync\nexport async function triggerSync() {\n  if ("serviceWorker" in navigator && "SyncManager" in window) {\n    try {\n      const registration = await navigator.serviceWorker.ready;\n      await registration.sync.register("sync-todos");\n      console.log("[App] Background sync registered");\n    } catch (err) {\n      console.error("[App] Sync registration failed:", err);\n      // Fallback to immediate sync\n      await manualSync();\n    }\n  } else {\n    console.log("[App] SyncManager not supported, using manual sync");\n    await manualSync();\n  }\n}\n\n// Fallback manual sync\nasync function manualSync() {\n  const unsynced = await db.todos.where("synced").equals(false).toArray();\n  // Implement sync logic here\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"service-worker-sync-handler",children:"Service Worker Sync Handler"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"public/sw.js"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'importScripts("https://cdn.jsdelivr.net/npm/idb@7/build/iife/index-min.js");\n\nconst { openDB } = self.idb;\nconst DB_NAME = "MyOfflineAppDB";\nconst DB_VERSION = 1;\n\n// Background Sync event\nself.addEventListener("sync", event => {\n  console.log("[SW] Sync event triggered:", event.tag);\n\n  if (event.tag === "sync-todos") {\n    event.waitUntil(syncTodos());\n  }\n});\n\nasync function syncTodos() {\n  console.log("[SW] Starting sync...");\n\n  try {\n    const db = await openDB(DB_NAME, DB_VERSION);\n    const tx = db.transaction("todos", "readwrite");\n    const store = tx.objectStore("todos");\n\n    const allTodos = await store.getAll();\n    const unsynced = allTodos.filter(todo => !todo.synced);\n\n    console.log(`[SW] Found ${unsynced.length} items to sync`);\n\n    for (const todo of unsynced) {\n      try {\n        const response = await fetch("/api/todos", {\n          method: "POST",\n          headers: { "Content-Type": "application/json" },\n          body: JSON.stringify({\n            title: todo.title,\n            completed: todo.completed,\n            updatedAt: todo.updatedAt\n          })\n        });\n\n        if (response.ok) {\n          const serverData = await response.json();\n\n          // Update local record\n          todo.synced = true;\n          todo.serverId = serverData.id;\n          todo.serverVersion = serverData.version || Date.now();\n\n          await store.put(todo);\n          console.log(`[SW] Synced: ${todo.title}`);\n        } else {\n          console.warn("[SW] Server rejected:", response.status);\n        }\n      } catch (err) {\n        console.error("[SW] Sync failed for item:", todo.id, err);\n        // Will retry on next sync event\n      }\n    }\n\n    await tx.done;\n    console.log("[SW] Sync completed");\n\n  } catch (err) {\n    console.error("[SW] Sync process failed:", err);\n    throw err; // Rethrow to trigger retry\n  }\n}\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"complete-example",children:"Complete Integration Example"}),"\n",(0,s.jsx)(n.h3,{id:"full-app-structure",children:"Full App Structure"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"src/db.js"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'import Dexie from "dexie";\n\nexport const db = new Dexie("TodoAppDB");\n\ndb.version(1).stores({\n  todos: "++id, title, completed, updatedAt, synced, serverVersion"\n});\n\nexport async function addTodo(title) {\n  const id = await db.todos.add({\n    title,\n    completed: false,\n    synced: false,\n    updatedAt: Date.now(),\n    serverVersion: null\n  });\n  await triggerSync();\n  return id;\n}\n\nexport async function updateTodo(id, updates) {\n  await db.todos.update(id, {\n    ...updates,\n    synced: false,\n    updatedAt: Date.now()\n  });\n  await triggerSync();\n}\n\nexport async function deleteTodo(id) {\n  await db.todos.delete(id);\n  // Optionally sync deletion to server\n}\n\nexport async function triggerSync() {\n  if ("serviceWorker" in navigator && "SyncManager" in window) {\n    const registration = await navigator.serviceWorker.ready;\n    await registration.sync.register("sync-todos");\n  }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"src/App.jsx"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'import React, { useState, useEffect } from "react";\nimport { useLiveQuery } from "dexie-react-hooks";\nimport { db, addTodo, updateTodo, deleteTodo, triggerSync } from "./db";\n\nfunction App() {\n  const [newTitle, setNewTitle] = useState("");\n  const [isOnline, setIsOnline] = useState(navigator.onLine);\n\n  const todos = useLiveQuery(() => db.todos.toArray(), []);\n  const unsyncedCount = useLiveQuery(\n    () => db.todos.where("synced").equals(false).count(),\n    []\n  );\n\n  useEffect(() => {\n    const handleOnline = () => {\n      setIsOnline(true);\n      triggerSync();\n    };\n\n    const handleOffline = () => {\n      setIsOnline(false);\n    };\n\n    window.addEventListener("online", handleOnline);\n    window.addEventListener("offline", handleOffline);\n\n    return () => {\n      window.removeEventListener("online", handleOnline);\n      window.removeEventListener("offline", handleOffline);\n    };\n  }, []);\n\n  const handleAdd = async (e) => {\n    e.preventDefault();\n    if (newTitle.trim()) {\n      await addTodo(newTitle);\n      setNewTitle("");\n    }\n  };\n\n  const handleToggle = async (todo) => {\n    await updateTodo(todo.id, { completed: !todo.completed });\n  };\n\n  const handleDelete = async (id) => {\n    await deleteTodo(id);\n  };\n\n  return (\n    <div className="app">\n      <header>\n        <h1>Offline-First Todo App</h1>\n        <div className="status">\n          {isOnline ? "\ud83d\udfe2 Online" : "\ud83d\udd34 Offline"}\n          {unsyncedCount > 0 && ` (${unsyncedCount} unsynced)`}\n        </div>\n      </header>\n\n      <form onSubmit={handleAdd}>\n        <input\n          type="text"\n          value={newTitle}\n          onChange={(e) => setNewTitle(e.target.value)}\n          placeholder="Add new todo"\n        />\n        <button type="submit">Add</button>\n      </form>\n\n      <ul className="todo-list">\n        {todos?.map(todo => (\n          <li key={todo.id} className={todo.completed ? "completed" : ""}>\n            <input\n              type="checkbox"\n              checked={todo.completed}\n              onChange={() => handleToggle(todo)}\n            />\n            <span>{todo.title}</span>\n            <span className="sync-status">\n              {todo.synced ? "\u2705" : "\u23f3"}\n            </span>\n            <button onClick={() => handleDelete(todo.id)}>Delete</button>\n          </li>\n        ))}\n      </ul>\n\n      {todos?.length === 0 && (\n        <p className="empty">No todos yet. Add one above!</p>\n      )}\n    </div>\n  );\n}\n\nexport default App;\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"src/index.js"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'import React from "react";\nimport ReactDOM from "react-dom/client";\nimport App from "./App";\nimport "./index.css";\n\n// Register Service Worker\nif ("serviceWorker" in navigator) {\n  window.addEventListener("load", () => {\n    navigator.serviceWorker\n      .register("/sw.js")\n      .then(registration => {\n        console.log("SW registered:", registration.scope);\n      })\n      .catch(err => {\n        console.error("SW registration failed:", err);\n      });\n  });\n}\n\nconst root = ReactDOM.createRoot(document.getElementById("root"));\nroot.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>\n);\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"conflict-resolution",children:"Conflict Resolution Strategies"}),"\n",(0,s.jsx)(n.p,{children:"Conflicts occur when the same record is modified both offline and on the server."}),"\n",(0,s.jsx)(n.h3,{id:"why-conflicts-happen",children:"Why Conflicts Happen"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Scenario:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"User goes offline"}),"\n",(0,s.jsxs)(n.li,{children:["User updates a todo: ",(0,s.jsx)(n.code,{children:"completed = false \u2192 true"})]}),"\n",(0,s.jsxs)(n.li,{children:["Meanwhile, another device updates the server: ",(0,s.jsx)(n.code,{children:'title = "Buy milk" \u2192 "Buy milk + bread"'})]}),"\n",(0,s.jsx)(n.li,{children:"When sync happens \u2192 two versions exist"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"strategy-1-last-write-wins-lww",children:"Strategy 1: Last-Write-Wins (LWW)"}),"\n",(0,s.jsx)(n.p,{children:"Compare timestamps and keep the most recent version."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Pros:"})," Simple, fast\n",(0,s.jsx)(n.strong,{children:"Cons:"})," May lose important changes"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'async function syncWithLWW(todo) {\n  try {\n    // Fetch server version\n    const response = await fetch(`/api/todos/${todo.serverId}`);\n    const serverTodo = await response.json();\n\n    // Compare timestamps\n    if (todo.updatedAt > serverTodo.updatedAt) {\n      // Client is newer \u2192 send to server\n      await fetch(`/api/todos/${todo.serverId}`, {\n        method: "PUT",\n        headers: { "Content-Type": "application/json" },\n        body: JSON.stringify(todo)\n      });\n    } else {\n      // Server is newer \u2192 update local\n      await db.todos.update(todo.id, {\n        ...serverTodo,\n        synced: true,\n        serverVersion: serverTodo.version\n      });\n    }\n  } catch (err) {\n    console.error("Sync failed:", err);\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"strategy-2-client-wins-or-server-wins",children:"Strategy 2: Client-Wins or Server-Wins"}),"\n",(0,s.jsx)(n.p,{children:"Always prefer one side."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Client-Wins: Always push local changes\nasync function syncClientWins(todo) {\n  await fetch(`/api/todos/${todo.serverId}`, {\n    method: "PUT",\n    body: JSON.stringify(todo)\n  });\n  await db.todos.update(todo.id, { synced: true });\n}\n\n// Server-Wins: Always pull server changes\nasync function syncServerWins(todo) {\n  const response = await fetch(`/api/todos/${todo.serverId}`);\n  const serverTodo = await response.json();\n  await db.todos.update(todo.id, { ...serverTodo, synced: true });\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"strategy-3-field-level-merge",children:"Strategy 3: Field-Level Merge"}),"\n",(0,s.jsx)(n.p,{children:"Merge non-conflicting fields intelligently."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'async function syncWithMerge(todo) {\n  const response = await fetch(`/api/todos/${todo.serverId}`);\n  const serverTodo = await response.json();\n\n  if (serverTodo.version > todo.serverVersion) {\n    // Merge strategy: keep local completion status, server title\n    const merged = {\n      id: todo.id,\n      serverId: serverTodo.id,\n      title: serverTodo.title, // From server\n      completed: todo.completed, // From client\n      updatedAt: Math.max(todo.updatedAt, serverTodo.updatedAt),\n      synced: false,\n      serverVersion: serverTodo.version\n    };\n\n    // Push merged version to server\n    await fetch(`/api/todos/${serverTodo.id}`, {\n      method: "PUT",\n      body: JSON.stringify(merged)\n    });\n\n    // Update local\n    await db.todos.update(todo.id, { ...merged, synced: true });\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"strategy-4-manual-resolution",children:"Strategy 4: Manual Resolution"}),"\n",(0,s.jsx)(n.p,{children:"Detect conflicts and let the user decide."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Mark conflict in database\nawait db.todos.update(todo.id, {\n  conflict: true,\n  conflictData: {\n    local: todo,\n    server: serverTodo\n  }\n});\n\n// In React component\nfunction ConflictResolver({ todo }) {\n  const resolveKeepLocal = async () => {\n    await fetch(`/api/todos/${todo.serverId}`, {\n      method: "PUT",\n      body: JSON.stringify(todo)\n    });\n    await db.todos.update(todo.id, {\n      conflict: false,\n      synced: true\n    });\n  };\n\n  const resolveKeepServer = async () => {\n    await db.todos.update(todo.id, {\n      ...todo.conflictData.server,\n      conflict: false,\n      synced: true\n    });\n  };\n\n  return (\n    <div className="conflict-warning">\n      <p>\u26a0\ufe0f Conflict detected</p>\n      <button onClick={resolveKeepLocal}>Keep My Changes</button>\n      <button onClick={resolveKeepServer}>Use Server Version</button>\n    </div>\n  );\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"complete-conflict-aware-sync",children:"Complete Conflict-Aware Sync"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"public/sw.js"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'async function syncWithConflictDetection() {\n  const db = await openDB("TodoAppDB", 1);\n  const tx = db.transaction("todos", "readwrite");\n  const store = tx.objectStore("todos");\n  const todos = await store.getAll();\n\n  for (const todo of todos) {\n    if (!todo.synced && todo.serverId) {\n      try {\n        // Fetch server version\n        const res = await fetch(`/api/todos/${todo.serverId}`);\n        const serverTodo = await res.json();\n\n        // Check for conflict\n        if (serverTodo.version > todo.serverVersion) {\n          // Conflict detected\n          if (todo.updatedAt > serverTodo.updatedAt) {\n            // LWW: Client wins\n            await fetch(`/api/todos/${todo.serverId}`, {\n              method: "PUT",\n              body: JSON.stringify(todo)\n            });\n            todo.synced = true;\n            todo.serverVersion = Date.now();\n          } else {\n            // LWW: Server wins\n            Object.assign(todo, serverTodo);\n            todo.synced = true;\n          }\n        } else {\n          // No conflict, push local\n          await fetch(`/api/todos/${todo.serverId}`, {\n            method: "PUT",\n            body: JSON.stringify(todo)\n          });\n          todo.synced = true;\n        }\n\n        await store.put(todo);\n      } catch (err) {\n        console.error("Sync error:", err);\n      }\n    }\n  }\n\n  await tx.done;\n}\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Production Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"1-database-versioning",children:"1. Database Versioning"}),"\n",(0,s.jsx)(n.p,{children:"Always use proper version management when changing schema:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'const db = new Dexie("MyAppDB");\n\n// Version 1\ndb.version(1).stores({\n  todos: "++id, title, completed"\n});\n\n// Version 2: Add new fields\ndb.version(2).stores({\n  todos: "++id, title, completed, priority, tags"\n}).upgrade(tx => {\n  // Migrate existing data\n  return tx.table("todos").toCollection().modify(todo => {\n    todo.priority = "normal";\n    todo.tags = [];\n  });\n});\n\n// Version 3: Add new table\ndb.version(3).stores({\n  todos: "++id, title, completed, priority, tags",\n  categories: "++id, name, color"\n});\n'})}),"\n",(0,s.jsx)(n.h3,{id:"2-error-handling",children:"2. Error Handling"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'async function safeDbOperation() {\n  try {\n    await db.todos.add({ title: "Task" });\n  } catch (err) {\n    if (err.name === "QuotaExceededError") {\n      alert("Storage quota exceeded. Please delete some data.");\n    } else if (err.name === "ConstraintError") {\n      console.error("Constraint violation:", err);\n    } else {\n      console.error("Database error:", err);\n    }\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"3-performance-optimization",children:"3. Performance Optimization"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Use bulk operations\nawait db.todos.bulkAdd(largeArray);\nawait db.todos.bulkDelete([1, 2, 3, 4, 5]);\n\n// Limit query results\nconst recent = await db.todos\n  .orderBy("createdAt")\n  .reverse()\n  .limit(50)\n  .toArray();\n\n// Use indexes for frequently queried fields\ndb.version(1).stores({\n  todos: "++id, title, completed, [userId+completed]" // Compound index\n});\n'})}),"\n",(0,s.jsx)(n.h3,{id:"4-security-considerations",children:"4. Security Considerations"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Validate data before storing\nasync function addTodoSafe(title) {\n  // Sanitize input\n  const sanitized = title.trim().slice(0, 500);\n\n  if (!sanitized) {\n    throw new Error("Title cannot be empty");\n  }\n\n  await db.todos.add({\n    title: sanitized,\n    completed: false,\n    createdAt: Date.now()\n  });\n}\n\n// Never store sensitive data in IndexedDB\n// Use encryption if needed\n'})}),"\n",(0,s.jsx)(n.h3,{id:"5-testing",children:"5. Testing"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Clear database for testing\nasync function resetDatabase() {\n  await db.delete();\n  await db.open();\n}\n\n// Mock data for development\nasync function seedTestData() {\n  await db.todos.bulkAdd([\n    { title: "Test 1", completed: false },\n    { title: "Test 2", completed: true },\n    { title: "Test 3", completed: false }\n  ]);\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"6-monitoring-and-debugging",children:"6. Monitoring and Debugging"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Enable Dexie debug mode\nDexie.debug = true;\n\n// Monitor storage usage\nasync function checkStorageQuota() {\n  if (navigator.storage && navigator.storage.estimate) {\n    const estimate = await navigator.storage.estimate();\n    const percentUsed = (estimate.usage / estimate.quota) * 100;\n    console.log(`Storage: ${percentUsed.toFixed(2)}% used`);\n    console.log(`Used: ${(estimate.usage / 1024 / 1024).toFixed(2)} MB`);\n    console.log(`Available: ${(estimate.quota / 1024 / 1024).toFixed(2)} MB`);\n    return { usage: estimate.usage, quota: estimate.quota, percentUsed };\n  }\n}\n\n// Log all database operations\ndb.on("changes", changes => {\n  changes.forEach(change => {\n    console.log(`[DB] ${change.type} in ${change.table}:`, change);\n  });\n});\n'})}),"\n",(0,s.jsx)(n.h3,{id:"7-cleanup-and-maintenance",children:"7. Cleanup and Maintenance"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Delete old records periodically\nasync function cleanupOldTodos() {\n  const thirtyDaysAgo = Date.now() - (30 * 24 * 60 * 60 * 1000);\n\n  const deleted = await db.todos\n    .where("completed")\n    .equals(true)\n    .and(todo => todo.updatedAt < thirtyDaysAgo)\n    .delete();\n\n  console.log(`Cleaned up ${deleted} old todos`);\n}\n\n// Export data for backup\nasync function exportData() {\n  const todos = await db.todos.toArray();\n  const users = await db.users.toArray();\n\n  const backup = {\n    version: db.verno,\n    timestamp: Date.now(),\n    data: { todos, users }\n  };\n\n  const blob = new Blob([JSON.stringify(backup, null, 2)], {\n    type: "application/json"\n  });\n\n  const url = URL.createObjectURL(blob);\n  const a = document.createElement("a");\n  a.href = url;\n  a.download = `backup-${Date.now()}.json`;\n  a.click();\n}\n\n// Import data from backup\nasync function importData(jsonString) {\n  const backup = JSON.parse(jsonString);\n\n  await db.transaction("rw", db.todos, db.users, async () => {\n    await db.todos.clear();\n    await db.users.clear();\n    await db.todos.bulkAdd(backup.data.todos);\n    await db.users.bulkAdd(backup.data.users);\n  });\n\n  console.log("Data imported successfully");\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"8-network-detection-and-smart-sync",children:"8. Network Detection and Smart Sync"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Enhanced network detection\nclass NetworkMonitor {\n  constructor() {\n    this.isOnline = navigator.onLine;\n    this.connectionQuality = "unknown";\n    this.setupListeners();\n  }\n\n  setupListeners() {\n    window.addEventListener("online", () => {\n      this.isOnline = true;\n      this.onConnectionChange();\n    });\n\n    window.addEventListener("offline", () => {\n      this.isOnline = false;\n      this.onConnectionChange();\n    });\n\n    // Check connection quality\n    if ("connection" in navigator) {\n      const conn = navigator.connection;\n      conn.addEventListener("change", () => {\n        this.connectionQuality = conn.effectiveType;\n        console.log(`Connection: ${conn.effectiveType}`);\n      });\n    }\n  }\n\n  async onConnectionChange() {\n    if (this.isOnline) {\n      console.log("Back online, syncing...");\n      await triggerSync();\n    } else {\n      console.log("Gone offline, queueing changes");\n    }\n  }\n\n  shouldSync() {\n    // Only sync on good connections\n    return this.isOnline &&\n           (this.connectionQuality === "4g" ||\n            this.connectionQuality === "unknown");\n  }\n}\n\nconst networkMonitor = new NetworkMonitor();\n'})}),"\n",(0,s.jsx)(n.h3,{id:"9-batch-sync-for-performance",children:"9. Batch Sync for Performance"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Sync in batches to avoid overwhelming the server\nasync function batchSync(batchSize = 10) {\n  const unsynced = await db.todos\n    .where("synced")\n    .equals(false)\n    .toArray();\n\n  // Process in batches\n  for (let i = 0; i < unsynced.length; i += batchSize) {\n    const batch = unsynced.slice(i, i + batchSize);\n\n    try {\n      // Send batch to server\n      const response = await fetch("/api/todos/batch", {\n        method: "POST",\n        headers: { "Content-Type": "application/json" },\n        body: JSON.stringify(batch)\n      });\n\n      if (response.ok) {\n        const results = await response.json();\n\n        // Update local records\n        await db.transaction("rw", db.todos, async () => {\n          for (const result of results) {\n            await db.todos.update(result.localId, {\n              synced: true,\n              serverId: result.serverId,\n              serverVersion: result.version\n            });\n          }\n        });\n      }\n    } catch (err) {\n      console.error("Batch sync failed:", err);\n      break; // Stop on error, will retry later\n    }\n\n    // Small delay between batches\n    await new Promise(resolve => setTimeout(resolve, 100));\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"10-progressive-web-app-integration",children:"10. Progressive Web App Integration"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Cache static assets in Service Worker\nconst CACHE_NAME = "app-v1";\nconst urlsToCache = [\n  "/",\n  "/index.html",\n  "/static/js/main.js",\n  "/static/css/main.css"\n];\n\nself.addEventListener("install", event => {\n  event.waitUntil(\n    caches.open(CACHE_NAME)\n      .then(cache => cache.addAll(urlsToCache))\n  );\n});\n\n// Serve from cache, fallback to network\nself.addEventListener("fetch", event => {\n  event.respondWith(\n    caches.match(event.request)\n      .then(response => {\n        if (response) {\n          return response;\n        }\n        return fetch(event.request).then(response => {\n          // Cache successful responses\n          if (response.status === 200) {\n            const responseToCache = response.clone();\n            caches.open(CACHE_NAME)\n              .then(cache => cache.put(event.request, responseToCache));\n          }\n          return response;\n        });\n      })\n  );\n});\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"advanced-patterns",children:"Advanced Patterns"}),"\n",(0,s.jsx)(n.h3,{id:"optimistic-ui-updates",children:"Optimistic UI Updates"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'async function optimisticUpdate(todoId, updates) {\n  // Update UI immediately\n  await db.todos.update(todoId, updates);\n\n  // Sync in background\n  try {\n    await fetch(`/api/todos/${todoId}`, {\n      method: "PATCH",\n      body: JSON.stringify(updates)\n    });\n    await db.todos.update(todoId, { synced: true });\n  } catch (err) {\n    // Revert on failure (optional)\n    console.error("Update failed, marking as unsynced:", err);\n    await db.todos.update(todoId, { synced: false });\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"delta-sync-only-sync-changes",children:"Delta Sync (Only Sync Changes)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Track field-level changes\nasync function trackChanges(todoId, field, newValue) {\n  const todo = await db.todos.get(todoId);\n\n  if (!todo.changes) {\n    todo.changes = {};\n  }\n\n  todo.changes[field] = newValue;\n  todo.synced = false;\n\n  await db.todos.put(todo);\n}\n\n// Send only changed fields\nasync function deltaSyncTodos() {\n  const unsynced = await db.todos\n    .where("synced")\n    .equals(false)\n    .toArray();\n\n  for (const todo of unsynced) {\n    if (todo.changes) {\n      await fetch(`/api/todos/${todo.serverId}`, {\n        method: "PATCH",\n        body: JSON.stringify({\n          id: todo.serverId,\n          changes: todo.changes\n        })\n      });\n\n      await db.todos.update(todo.id, {\n        changes: {},\n        synced: true\n      });\n    }\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"real-time-sync-with-websockets",children:"Real-Time Sync with WebSockets"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// WebSocket integration for live updates\nclass RealtimeSync {\n  constructor() {\n    this.ws = null;\n    this.connect();\n  }\n\n  connect() {\n    this.ws = new WebSocket("wss://api.example.com/sync");\n\n    this.ws.onmessage = async (event) => {\n      const update = JSON.parse(event.data);\n\n      if (update.type === "todo.updated") {\n        // Update local database\n        await db.todos.update(update.localId, {\n          ...update.data,\n          synced: true,\n          serverVersion: update.version\n        });\n      }\n    };\n\n    this.ws.onclose = () => {\n      // Reconnect after delay\n      setTimeout(() => this.connect(), 5000);\n    };\n  }\n\n  sendUpdate(todo) {\n    if (this.ws && this.ws.readyState === WebSocket.OPEN) {\n      this.ws.send(JSON.stringify({\n        type: "todo.update",\n        data: todo\n      }));\n    }\n  }\n}\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"troubleshooting-common-issues",children:"Troubleshooting Common Issues"}),"\n",(0,s.jsx)(n.h3,{id:"issue-1-service-worker-not-updating",children:"Issue 1: Service Worker Not Updating"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Force update service worker\nself.addEventListener("message", event => {\n  if (event.data === "skipWaiting") {\n    self.skipWaiting();\n  }\n});\n\n// In app code\nnavigator.serviceWorker.ready.then(registration => {\n  registration.update();\n});\n'})}),"\n",(0,s.jsx)(n.h3,{id:"issue-2-indexeddb-quota-exceeded",children:"Issue 2: IndexedDB Quota Exceeded"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"async function handleQuotaExceeded() {\n  // Check current usage\n  const { usage, quota } = await checkStorageQuota();\n\n  if (usage / quota > 0.9) {\n    // Clean up old data\n    await cleanupOldTodos();\n\n    // Or request persistent storage\n    if (navigator.storage && navigator.storage.persist) {\n      const granted = await navigator.storage.persist();\n      console.log(`Persistent storage: ${granted}`);\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"issue-3-sync-not-triggering",children:"Issue 3: Sync Not Triggering"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Debug sync registration\nasync function debugSync() {\n  const registration = await navigator.serviceWorker.ready;\n\n  // Check if sync is registered\n  const tags = await registration.sync.getTags();\n  console.log("Registered sync tags:", tags);\n\n  // Manual trigger for testing\n  await registration.sync.register("sync-todos");\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"issue-4-data-not-persisting",children:"Issue 4: Data Not Persisting"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Verify database is open\ndb.on("ready", () => {\n  console.log("Database ready:", db.isOpen());\n});\n\n// Check if data was actually saved\nasync function verifyData(id) {\n  const todo = await db.todos.get(id);\n  console.log("Saved data:", todo);\n\n  // Check in DevTools\n  console.log("Open DevTools > Application > IndexedDB to inspect");\n}\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"performance-metrics-and-monitoring",children:"Performance Metrics and Monitoring"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Measure sync performance\nasync function measureSyncPerformance() {\n  const startTime = performance.now();\n\n  await syncTodos();\n\n  const endTime = performance.now();\n  const duration = endTime - startTime;\n\n  console.log(`Sync completed in ${duration.toFixed(2)}ms`);\n\n  // Send to analytics\n  if (window.analytics) {\n    analytics.track("Sync Completed", {\n      duration,\n      itemCount: await db.todos.count()\n    });\n  }\n}\n\n// Monitor database size\nasync function monitorDatabaseSize() {\n  const tables = ["todos", "users", "notes"];\n  const sizes = {};\n\n  for (const table of tables) {\n    const count = await db.table(table).count();\n    sizes[table] = count;\n  }\n\n  console.log("Database sizes:", sizes);\n  return sizes;\n}\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(n.p,{children:"This guide covered:"}),"\n",(0,s.jsxs)(n.p,{children:["\u2705 ",(0,s.jsx)(n.strong,{children:"Dexie.js Fundamentals"})," - Setup, CRUD operations, queries, and transactions\n\u2705 ",(0,s.jsx)(n.strong,{children:"Offline-First Architecture"})," - Local-first approach with background sync\n\u2705 ",(0,s.jsx)(n.strong,{children:"Service Worker Integration"})," - Background sync and caching strategies\n\u2705 ",(0,s.jsx)(n.strong,{children:"React Integration"})," - useLiveQuery for reactive UIs\n\u2705 ",(0,s.jsx)(n.strong,{children:"Conflict Resolution"})," - Multiple strategies for handling data conflicts\n\u2705 ",(0,s.jsx)(n.strong,{children:"Production Best Practices"})," - Performance, security, monitoring, and maintenance"]}),"\n",(0,s.jsx)(n.h3,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Always write locally first"})," - Instant feedback for users"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Mark unsynced changes"})," - Track what needs server sync"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use Background Sync API"})," - Reliable sync even when app is closed"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Handle conflicts gracefully"})," - Choose appropriate strategy for your use case"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Monitor and optimize"})," - Track storage usage and sync performance"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Implement end-to-end encryption for sensitive data"}),"\n",(0,s.jsx)(n.li,{children:"Add conflict resolution UI for user-driven decisions"}),"\n",(0,s.jsx)(n.li,{children:"Set up automated testing for offline scenarios"}),"\n",(0,s.jsx)(n.li,{children:"Implement progressive enhancement strategies"}),"\n",(0,s.jsx)(n.li,{children:"Add telemetry for monitoring sync success rates"}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"additional-resources",children:"Additional Resources"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Dexie.js Documentation"}),": ",(0,s.jsx)(n.a,{href:"https://dexie.org",children:"https://dexie.org"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Service Worker API"}),": ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API",children:"https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"IndexedDB Guide"}),": ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API",children:"https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Background Sync"}),": ",(0,s.jsx)(n.a,{href:"https://developer.chrome.com/docs/workbox/modules/workbox-background-sync/",children:"https://developer.chrome.com/docs/workbox/modules/workbox-background-sync/"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"PWA Best Practices"}),": ",(0,s.jsx)(n.a,{href:"https://web.dev/progressive-web-apps/",children:"https://web.dev/progressive-web-apps/"})]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Built with \u2764\ufe0f for offline-first applications"})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var s=t(96540);const o={},r=s.createContext(o);function i(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);