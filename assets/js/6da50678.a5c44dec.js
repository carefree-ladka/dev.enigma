"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[2732],{8174:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>h,contentTitle:()=>s,default:()=>c,frontMatter:()=>l,metadata:()=>a,toc:()=>o});var i=n(4848),t=n(8453);const l={},s="Euler Path, Hamilton Cycle, and Hierholzer's Algorithm",a={id:"tutorial-basics/EularPath",title:"Euler Path, Hamilton Cycle, and Hierholzer's Algorithm",description:"Table of Contents",source:"@site/docs/tutorial-basics/EularPath.mdx",sourceDirName:"tutorial-basics",slug:"/tutorial-basics/EularPath",permalink:"/js.enigma/docs/tutorial-basics/EularPath",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/tutorial-basics/EularPath.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Euclid's Algorithm for Greatest Common Divisor (GCD)",permalink:"/js.enigma/docs/tutorial-basics/Euclid"},next:{title:"Fenwick Tree Tutorial",permalink:"/js.enigma/docs/tutorial-basics/Fenwick"}},h={},o=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Euler Path",id:"euler-path",level:2},{value:"Key Concepts",id:"key-concepts",level:3},{value:"Hamilton Cycle",id:"hamilton-cycle",level:2},{value:"Hierholzer&#39;s Algorithm",id:"hierholzers-algorithm",level:2},{value:"LeetCode Problems",id:"leetcode-problems",level:2},{value:"1. LeetCode 332 - Reconstruct Itinerary (Hard)",id:"1-leetcode-332---reconstruct-itinerary-hard",level:3},{value:"2. LeetCode 753 - Cracking the Safe (Hard)",id:"2-leetcode-753---cracking-the-safe-hard",level:3},{value:"3. LeetCode 2097 - Valid Arrangement of Pairs (Hard)",id:"3-leetcode-2097---valid-arrangement-of-pairs-hard",level:3},{value:"Implementation Guide",id:"implementation-guide",level:2},{value:"Using Euler Path",id:"using-euler-path",level:3},{value:"Using Hamilton Cycle",id:"using-hamilton-cycle",level:3},{value:"Using Hierholzer",id:"using-hierholzer",level:3},{value:"Tips for Problem Solving",id:"tips-for-problem-solving",level:2}];function d(e){const r={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.header,{children:(0,i.jsx)(r.h1,{id:"euler-path-hamilton-cycle-and-hierholzers-algorithm",children:"Euler Path, Hamilton Cycle, and Hierholzer's Algorithm"})}),"\n",(0,i.jsx)(r.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"#introduction",children:"Introduction"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"#euler-path",children:"Euler Path"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"#hamilton-cycle",children:"Hamilton Cycle"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"#hierholzers-algorithm",children:"Hierholzer's Algorithm"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"#leetcode-problems",children:"LeetCode Problems"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"#implementation-guide",children:"Implementation Guide"})}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsx)(r.p,{children:"This guide covers three fundamental graph algorithms: Euler Path, Hamilton Cycle, and Hierholzer's Algorithm. Each has its unique use cases and applications in solving various graph-related problems."}),"\n",(0,i.jsx)(r.h2,{id:"euler-path",children:"Euler Path"}),"\n",(0,i.jsx)(r.p,{children:"An Euler path visits every edge in a graph exactly once. Here's the implementation:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-javascript",children:"class EulerPath {\r\n    constructor(n) {\r\n        this.n = n;\r\n        this.adj = Array.from({length: n}, () => []);\r\n        this.inDegree = new Array(n).fill(0);\r\n        this.outDegree = new Array(n).fill(0);\r\n    }\r\n    \r\n    addEdge(from, to) {\r\n        this.adj[from].push(to);\r\n        this.outDegree[from]++;\r\n        this.inDegree[to]++;\r\n    }\r\n    \r\n    findPath() {\r\n        if (!this.canHaveEulerPath()) return [];\r\n        \r\n        let start = 0;\r\n        for (let i = 0; i < this.n; i++) {\r\n            if (this.outDegree[i] - this.inDegree[i] === 1) {\r\n                start = i;\r\n                break;\r\n            }\r\n            if (this.outDegree[i] > 0) start = i;\r\n        }\r\n        \r\n        const path = [];\r\n        const stack = [start];\r\n        \r\n        while (stack.length > 0) {\r\n            let curr = stack[stack.length - 1];\r\n            \r\n            if (this.adj[curr].length === 0) {\r\n                path.push(curr);\r\n                stack.pop();\r\n            } else {\r\n                let next = this.adj[curr].pop();\r\n                stack.push(next);\r\n            }\r\n        }\r\n        \r\n        return path.reverse();\r\n    }\r\n    \r\n    canHaveEulerPath() {\r\n        let startNodes = 0, endNodes = 0;\r\n        \r\n        for (let i = 0; i < this.n; i++) {\r\n            let diff = this.outDegree[i] - this.inDegree[i];\r\n            if (Math.abs(diff) > 1) return false;\r\n            if (diff === 1) startNodes++;\r\n            if (diff === -1) endNodes++;\r\n        }\r\n        \r\n        return (startNodes === 0 && endNodes === 0) || \r\n               (startNodes === 1 && endNodes === 1);\r\n    }\r\n}\n"})}),"\n",(0,i.jsx)(r.h3,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Requires all vertices to have equal in-degree and out-degree (for Euler circuit)"}),"\n",(0,i.jsx)(r.li,{children:"At most one vertex can have out-degree = in-degree + 1 (for Euler path)"}),"\n",(0,i.jsx)(r.li,{children:"At most one vertex can have in-degree = out-degree + 1 (for Euler path)"}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"hamilton-cycle",children:"Hamilton Cycle"}),"\n",(0,i.jsx)(r.p,{children:"A Hamilton cycle visits every vertex exactly once and returns to the starting vertex:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-javascript",children:"class HamiltonCycle {\r\n    constructor(n) {\r\n        this.n = n;\r\n        this.adj = Array.from({length: n}, () => Array(n).fill(0));\r\n        this.path = new Array(n).fill(-1);\r\n    }\r\n    \r\n    addEdge(from, to) {\r\n        this.adj[from][to] = 1;\r\n        this.adj[to][from] = 1;\r\n    }\r\n    \r\n    findCycle() {\r\n        this.path[0] = 0;\r\n        return !this.findCycleUtil(1) ? [] : this.path;\r\n    }\r\n    \r\n    findCycleUtil(pos) {\r\n        if (pos === this.n) {\r\n            return this.adj[this.path[pos-1]][this.path[0]] === 1;\r\n        }\r\n        \r\n        for (let v = 1; v < this.n; v++) {\r\n            if (this.isSafe(v, pos)) {\r\n                this.path[pos] = v;\r\n                if (this.findCycleUtil(pos + 1)) return true;\r\n                this.path[pos] = -1;\r\n            }\r\n        }\r\n        \r\n        return false;\r\n    }\r\n    \r\n    isSafe(v, pos) {\r\n        return this.adj[this.path[pos-1]][v] === 1 && !this.path.includes(v);\r\n    }\r\n}\n"})}),"\n",(0,i.jsx)(r.h2,{id:"hierholzers-algorithm",children:"Hierholzer's Algorithm"}),"\n",(0,i.jsx)(r.p,{children:"Hierholzer's Algorithm finds Euler circuits efficiently:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-javascript",children:"class Hierholzer {\r\n    constructor(n) {\r\n        this.n = n;\r\n        this.adj = Array.from({length: n}, () => []);\r\n    }\r\n    \r\n    addEdge(from, to) {\r\n        this.adj[from].push(to);\r\n    }\r\n    \r\n    findCircuit() {\r\n        const circuit = [];\r\n        const stack = [0];\r\n        \r\n        while (stack.length > 0) {\r\n            let curr = stack[stack.length - 1];\r\n            \r\n            if (this.adj[curr].length === 0) {\r\n                circuit.push(curr);\r\n                stack.pop();\r\n            } else {\r\n                stack.push(this.adj[curr].pop());\r\n            }\r\n        }\r\n        \r\n        return circuit.reverse();\r\n    }\r\n}\n"})}),"\n",(0,i.jsx)(r.h2,{id:"leetcode-problems",children:"LeetCode Problems"}),"\n",(0,i.jsx)(r.p,{children:"Here are some LeetCode problems that can be solved using these algorithms:"}),"\n",(0,i.jsx)(r.h3,{id:"1-leetcode-332---reconstruct-itinerary-hard",children:"1. LeetCode 332 - Reconstruct Itinerary (Hard)"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Uses Hierholzer's algorithm"}),"\n",(0,i.jsx)(r.li,{children:"Find Euler path in directed graph of flight tickets"}),"\n"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-javascript",children:'Example:\r\nInput: [["MUC","LHR"],["JFK","MUC"],["SFO","SJC"],["LHR","SFO"]]\r\nOutput: ["JFK","MUC","LHR","SFO","SJC"]\n'})}),"\n",(0,i.jsx)(r.h3,{id:"2-leetcode-753---cracking-the-safe-hard",children:"2. LeetCode 753 - Cracking the Safe (Hard)"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Uses de Bruijn sequence (special case of Euler path)"}),"\n",(0,i.jsx)(r.li,{children:"Find shortest string containing all combinations"}),"\n"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-javascript",children:'Example:\r\nInput: n = 2, k = 2\r\nOutput: "00110" // Contains all 2-digit combinations of 0,1\n'})}),"\n",(0,i.jsx)(r.h3,{id:"3-leetcode-2097---valid-arrangement-of-pairs-hard",children:"3. LeetCode 2097 - Valid Arrangement of Pairs (Hard)"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Find Euler path in graph of number pairs"}),"\n"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-javascript",children:"Example:\r\nInput: pairs = [[5,1],[4,5],[11,9],[9,4]]\r\nOutput: [[11,9],[9,4],[4,5],[5,1]]\n"})}),"\n",(0,i.jsx)(r.h2,{id:"implementation-guide",children:"Implementation Guide"}),"\n",(0,i.jsx)(r.h3,{id:"using-euler-path",children:"Using Euler Path"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-javascript",children:'const eulerGraph = new EulerPath(4);\r\neulerGraph.addEdge(0, 1);\r\neulerGraph.addEdge(1, 2);\r\neulerGraph.addEdge(2, 3);\r\neulerGraph.addEdge(3, 0);\r\nconsole.log("Euler Path:", eulerGraph.findPath());\n'})}),"\n",(0,i.jsx)(r.h3,{id:"using-hamilton-cycle",children:"Using Hamilton Cycle"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-javascript",children:'const hamiltonGraph = new HamiltonCycle(5);\r\nhamiltonGraph.addEdge(0, 1);\r\nhamiltonGraph.addEdge(1, 2);\r\nhamiltonGraph.addEdge(2, 3);\r\nhamiltonGraph.addEdge(3, 4);\r\nhamiltonGraph.addEdge(4, 0);\r\nconsole.log("Hamilton Cycle:", hamiltonGraph.findCycle());\n'})}),"\n",(0,i.jsx)(r.h3,{id:"using-hierholzer",children:"Using Hierholzer"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-javascript",children:'const hierholzerGraph = new Hierholzer(4);\r\nhierholzerGraph.addEdge(0, 1);\r\nhierholzerGraph.addEdge(1, 2);\r\nhierholzerGraph.addEdge(2, 3);\r\nhierholzerGraph.addEdge(3, 0);\r\nconsole.log("Hierholzer Circuit:", hierholzerGraph.findCircuit());\n'})}),"\n",(0,i.jsx)(r.h2,{id:"tips-for-problem-solving",children:"Tips for Problem Solving"}),"\n",(0,i.jsxs)(r.ol,{children:["\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.strong,{children:"Graph Representation"})}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Choose appropriate representation (adjacency list/matrix)"}),"\n",(0,i.jsx)(r.li,{children:"Consider directed vs undirected edges"}),"\n",(0,i.jsx)(r.li,{children:"Handle special cases (multiple edges, self-loops)"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.strong,{children:"Algorithm Selection"})}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Euler Path: When need to traverse all edges once"}),"\n",(0,i.jsx)(r.li,{children:"Hamilton Cycle: When need to visit all vertices once"}),"\n",(0,i.jsx)(r.li,{children:"Hierholzer: When finding Euler circuit efficiently"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.strong,{children:"Common Patterns"})}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Check existence conditions first"}),"\n",(0,i.jsx)(r.li,{children:"Handle edge cases (empty graph, disconnected components)"}),"\n",(0,i.jsx)(r.li,{children:"Consider lexicographical ordering if required"}),"\n"]}),"\n"]}),"\n"]})]})}function c(e={}){const{wrapper:r}={...(0,t.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>s,x:()=>a});var i=n(6540);const t={},l=i.createContext(t);function s(e){const r=i.useContext(l);return i.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),i.createElement(l.Provider,{value:r},e.children)}}}]);