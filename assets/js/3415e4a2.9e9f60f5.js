"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[2110],{28453:(n,e,i)=>{i.d(e,{R:()=>l,x:()=>s});var r=i(96540);const t={},a=r.createContext(t);function l(n){const e=r.useContext(a);return r.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:l(n.components),r.createElement(a.Provider,{value:e},n.children)}},74483:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>d,contentTitle:()=>l,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>o});var r=i(74848),t=i(28453);const a={},l="Java DSA Fundamentals",s={id:"DSA/DSA with Java/Java DSA Fundamentals",title:"Java DSA Fundamentals",description:"Table of Contents",source:"@site/docs/DSA/DSA with Java/Java DSA Fundamentals.mdx",sourceDirName:"DSA/DSA with Java",slug:"/DSA/DSA with Java/Java DSA Fundamentals",permalink:"/js.enigma/docs/DSA/DSA with Java/Java DSA Fundamentals",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with Java/Java DSA Fundamentals.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Intervals",permalink:"/js.enigma/docs/DSA/DSA with Java/Intervals Patterns"},next:{title:"Knapsack Problems",permalink:"/js.enigma/docs/DSA/DSA with Java/Knapsack Patterns"}},d={},o=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Arrays",id:"arrays",level:2},{value:"Declaration and Initialization",id:"declaration-and-initialization",level:3},{value:"Common Operations",id:"common-operations",level:3},{value:"Time Complexities",id:"time-complexities",level:3},{value:"Strings",id:"strings",level:2},{value:"String Class (Immutable)",id:"string-class-immutable",level:3},{value:"StringBuilder (Mutable)",id:"stringbuilder-mutable",level:3},{value:"Time Complexities",id:"time-complexities-1",level:3},{value:"ArrayList",id:"arraylist",level:2},{value:"Declaration and Operations",id:"declaration-and-operations",level:3},{value:"Time Complexities",id:"time-complexities-2",level:3},{value:"LinkedList",id:"linkedlist",level:2},{value:"Declaration and Operations",id:"declaration-and-operations-1",level:3},{value:"Time Complexities",id:"time-complexities-3",level:3},{value:"Stack (ArrayDeque)",id:"stack-arraydeque",level:2},{value:"Why ArrayDeque over Stack?",id:"why-arraydeque-over-stack",level:3},{value:"Declaration and Operations",id:"declaration-and-operations-2",level:3},{value:"Stack Implementation Examples",id:"stack-implementation-examples",level:3},{value:"Time Complexities",id:"time-complexities-4",level:3},{value:"Queue (ArrayDeque)",id:"queue-arraydeque",level:2},{value:"Why ArrayDeque over LinkedList?",id:"why-arraydeque-over-linkedlist",level:3},{value:"Declaration and Operations",id:"declaration-and-operations-3",level:3},{value:"Queue Implementation Examples",id:"queue-implementation-examples",level:3},{value:"Time Complexities",id:"time-complexities-5",level:3},{value:"Deque (ArrayDeque)",id:"deque-arraydeque",level:2},{value:"Full Deque Operations",id:"full-deque-operations",level:3},{value:"Declaration and Operations",id:"declaration-and-operations-4",level:3},{value:"Deque as Stack and Queue",id:"deque-as-stack-and-queue",level:3},{value:"Deque Implementation Examples",id:"deque-implementation-examples",level:3},{value:"Method Comparison Table",id:"method-comparison-table",level:3},{value:"Time Complexities",id:"time-complexities-6",level:3},{value:"PriorityQueue (Heap)",id:"priorityqueue-heap",level:2},{value:"Declaration and Operations",id:"declaration-and-operations-5",level:3},{value:"Custom Objects in PriorityQueue",id:"custom-objects-in-priorityqueue",level:3},{value:"Time Complexities",id:"time-complexities-7",level:3},{value:"HashMap",id:"hashmap",level:2},{value:"Declaration and Operations",id:"declaration-and-operations-6",level:3},{value:"Time Complexities",id:"time-complexities-8",level:3},{value:"HashSet",id:"hashset",level:2},{value:"Declaration and Operations",id:"declaration-and-operations-7",level:3},{value:"Time Complexities",id:"time-complexities-9",level:3},{value:"LinkedHashMap",id:"linkedhashmap",level:2},{value:"Time Complexities",id:"time-complexities-10",level:3},{value:"LinkedHashSet",id:"linkedhashset",level:2},{value:"Time Complexities",id:"time-complexities-11",level:3},{value:"TreeMap",id:"treemap",level:2},{value:"Time Complexities",id:"time-complexities-12",level:3},{value:"TreeSet",id:"treeset",level:2},{value:"Time Complexities",id:"time-complexities-13",level:3},{value:"Sorting Algorithms",id:"sorting-algorithms",level:2},{value:"Bubble Sort",id:"bubble-sort",level:3},{value:"Selection Sort",id:"selection-sort",level:3},{value:"Insertion Sort",id:"insertion-sort",level:3},{value:"Merge Sort",id:"merge-sort",level:3},{value:"Quick Sort",id:"quick-sort",level:3},{value:"Heap Sort",id:"heap-sort",level:3},{value:"Counting Sort",id:"counting-sort",level:3},{value:"Searching Algorithms",id:"searching-algorithms",level:2},{value:"Linear Search",id:"linear-search",level:3},{value:"Binary Search",id:"binary-search",level:3},{value:"Binary Search Variations",id:"binary-search-variations",level:3},{value:"Recursion",id:"recursion",level:2},{value:"Basic Recursion",id:"basic-recursion",level:3},{value:"Advanced Recursion",id:"advanced-recursion",level:3},{value:"Backtracking",id:"backtracking",level:2},{value:"Permutations",id:"permutations",level:3},{value:"Combinations",id:"combinations",level:3},{value:"Subsets",id:"subsets",level:3},{value:"N-Queens",id:"n-queens",level:3},{value:"Sudoku Solver",id:"sudoku-solver",level:3},{value:"Rat in a Maze",id:"rat-in-a-maze",level:3},{value:"Dynamic Programming",id:"dynamic-programming",level:2},{value:"1D DP",id:"1d-dp",level:3},{value:"Fibonacci",id:"fibonacci",level:4},{value:"Climbing Stairs",id:"climbing-stairs",level:4},{value:"House Robber",id:"house-robber",level:4},{value:"Coin Change",id:"coin-change",level:4},{value:"2D DP",id:"2d-dp",level:3},{value:"Longest Common Subsequence",id:"longest-common-subsequence",level:4},{value:"0/1 Knapsack",id:"01-knapsack",level:4},{value:"Edit Distance",id:"edit-distance",level:4},{value:"Longest Palindromic Subsequence",id:"longest-palindromic-subsequence",level:4},{value:"Matrix Chain Multiplication",id:"matrix-chain-multiplication",level:4},{value:"Graph Algorithms",id:"graph-algorithms",level:2},{value:"Graph Representation",id:"graph-representation",level:3},{value:"Adjacency List",id:"adjacency-list",level:4},{value:"Adjacency Matrix",id:"adjacency-matrix",level:4},{value:"BFS (Breadth-First Search)",id:"bfs-breadth-first-search",level:3},{value:"DFS (Depth-First Search)",id:"dfs-depth-first-search",level:3},{value:"Dijkstra&#39;s Algorithm",id:"dijkstras-algorithm",level:3},{value:"Bellman-Ford Algorithm",id:"bellman-ford-algorithm",level:3},{value:"Floyd-Warshall Algorithm",id:"floyd-warshall-algorithm",level:3},{value:"Topological Sort (DFS)",id:"topological-sort-dfs",level:3},{value:"Topological Sort (Kahn&#39;s Algorithm - BFS)",id:"topological-sort-kahns-algorithm---bfs",level:3},{value:"Detect Cycle (Undirected Graph)",id:"detect-cycle-undirected-graph",level:3},{value:"Detect Cycle (Directed Graph)",id:"detect-cycle-directed-graph",level:3},{value:"Prim&#39;s MST",id:"prims-mst",level:3},{value:"Kruskal&#39;s MST",id:"kruskals-mst",level:3},{value:"Union-Find (Disjoint Set)",id:"union-find-disjoint-set",level:3},{value:"Trees",id:"trees",level:2},{value:"Binary Tree Node",id:"binary-tree-node",level:3},{value:"Binary Tree Traversals",id:"binary-tree-traversals",level:3},{value:"Inorder (Left, Root, Right)",id:"inorder-left-root-right",level:4},{value:"Preorder (Root, Left, Right)",id:"preorder-root-left-right",level:4},{value:"Postorder (Left, Right, Root)",id:"postorder-left-right-root",level:4},{value:"Level Order (BFS)",id:"level-order-bfs",level:4},{value:"Binary Tree Operations",id:"binary-tree-operations",level:3},{value:"Height of Tree",id:"height-of-tree",level:4},{value:"Diameter of Tree",id:"diameter-of-tree",level:4},{value:"Check if Balanced",id:"check-if-balanced",level:4},{value:"Lowest Common Ancestor",id:"lowest-common-ancestor",level:4},{value:"Maximum Path Sum",id:"maximum-path-sum",level:4},{value:"Binary Search Tree (BST)",id:"binary-search-tree-bst",level:3},{value:"Search in BST",id:"search-in-bst",level:4},{value:"Insert in BST",id:"insert-in-bst",level:4},{value:"Delete from BST",id:"delete-from-bst",level:4},{value:"Validate BST",id:"validate-bst",level:4},{value:"Kth Smallest in BST",id:"kth-smallest-in-bst",level:4},{value:"Segment Tree",id:"segment-tree",level:3},{value:"Tries",id:"tries",level:2},{value:"Trie Implementation",id:"trie-implementation",level:3},{value:"Bit Manipulation",id:"bit-manipulation",level:2},{value:"Basic Operations",id:"basic-operations",level:3},{value:"Advanced Bit Manipulation",id:"advanced-bit-manipulation",level:3},{value:"Math &amp; Number Theory",id:"math--number-theory",level:2},{value:"GCD and LCM",id:"gcd-and-lcm",level:3},{value:"Prime Numbers",id:"prime-numbers",level:3},{value:"Check Prime",id:"check-prime",level:4},{value:"Sieve of Eratosthenes",id:"sieve-of-eratosthenes",level:4},{value:"Modular Arithmetic",id:"modular-arithmetic",level:3},{value:"Combinatorics",id:"combinatorics",level:3},{value:"Number Theory",id:"number-theory",level:3},{value:"Count Digits",id:"count-digits",level:4},{value:"Reverse Number",id:"reverse-number",level:4},{value:"Check Palindrome Number",id:"check-palindrome-number",level:4},{value:"Armstrong Number",id:"armstrong-number",level:4},{value:"Sum of Divisors",id:"sum-of-divisors",level:4},{value:"Time Complexity Quick Reference",id:"time-complexity-quick-reference",level:2},{value:"Sorting Algorithm Comparison",id:"sorting-algorithm-comparison",level:2},{value:"Important Tips",id:"important-tips",level:2}];function c(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"java-dsa-fundamentals",children:"Java DSA Fundamentals"})}),"\n",(0,r.jsx)(e.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#arrays",children:"Arrays"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#strings",children:"Strings"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#arraylist",children:"ArrayList"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#linkedlist",children:"LinkedList"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#stack-arraydeque",children:"Stack (ArrayDeque)"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#queue-arraydeque",children:"Queue (ArrayDeque)"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#deque-arraydeque",children:"Deque (ArrayDeque)"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#priorityqueue-heap",children:"PriorityQueue (Heap)"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#hashmap",children:"HashMap"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#hashset",children:"HashSet"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#linkedhashmap",children:"LinkedHashMap"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#linkedhashset",children:"LinkedHashSet"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#treemap",children:"TreeMap"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#treeset",children:"TreeSet"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#sorting-algorithms",children:"Sorting Algorithms"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#searching-algorithms",children:"Searching Algorithms"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#recursion",children:"Recursion"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#backtracking",children:"Backtracking"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#dynamic-programming",children:"Dynamic Programming"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#graph-algorithms",children:"Graph Algorithms"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#trees",children:"Trees"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#tries",children:"Tries"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#bit-manipulation",children:"Bit Manipulation"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#math-number-theory",children:"Math & Number Theory"})}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"arrays",children:"Arrays"}),"\n",(0,r.jsx)(e.h3,{id:"declaration-and-initialization",children:"Declaration and Initialization"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"// Declaration\nint[] arr = new int[5];\nint[] arr2 = {1, 2, 3, 4, 5};\nint[][] matrix = new int[3][4];\n\n// 2D Array\nint[][] matrix2 = {\n    {1, 2, 3},\n    {4, 5, 6}\n};\n"})}),"\n",(0,r.jsx)(e.h3,{id:"common-operations",children:"Common Operations"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"// Length\nint len = arr.length;\n\n// Copy array\nint[] copy = Arrays.copyOf(arr, arr.length);\nint[] rangeCopy = Arrays.copyOfRange(arr, 0, 3);\n\n// Fill array\nArrays.fill(arr, 0);\n\n// Sort\nArrays.sort(arr);\nArrays.sort(arr, Collections.reverseOrder()); // For Integer[]\n\n// Binary Search (array must be sorted)\nint index = Arrays.binarySearch(arr, 5);\n\n// Compare arrays\nboolean isEqual = Arrays.equals(arr1, arr2);\n\n// Convert to String\nString str = Arrays.toString(arr);\n"})}),"\n",(0,r.jsx)(e.h3,{id:"time-complexities",children:"Time Complexities"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Access: O(1)"}),"\n",(0,r.jsx)(e.li,{children:"Search: O(n)"}),"\n",(0,r.jsx)(e.li,{children:"Insert/Delete: O(n)"}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"strings",children:"Strings"}),"\n",(0,r.jsx)(e.h3,{id:"string-class-immutable",children:"String Class (Immutable)"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:'String s = "hello";\nString s2 = new String("world");\n\n// Common methods\nint len = s.length();\nchar ch = s.charAt(0);\nString sub = s.substring(1, 3);\nString concat = s.concat(" world");\nString upper = s.toUpperCase();\nString lower = s.toLowerCase();\nboolean contains = s.contains("ell");\nboolean starts = s.startsWith("he");\nboolean ends = s.endsWith("lo");\nint index = s.indexOf("l");\nint lastIdx = s.lastIndexOf("l");\nString replaced = s.replace(\'l\', \'x\');\nString[] split = s.split(" ");\nString trimmed = s.trim();\nboolean empty = s.isEmpty();\nchar[] charArray = s.toCharArray();\n\n// String comparison\nboolean equal = s.equals(s2);\nboolean equalIgnoreCase = s.equalsIgnoreCase(s2);\nint compare = s.compareTo(s2);\n'})}),"\n",(0,r.jsx)(e.h3,{id:"stringbuilder-mutable",children:"StringBuilder (Mutable)"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:'StringBuilder sb = new StringBuilder();\nsb.append("hello");\nsb.append(" world");\nsb.insert(5, "!");\nsb.delete(5, 6);\nsb.deleteCharAt(5);\nsb.reverse();\nsb.setCharAt(0, \'H\');\nString result = sb.toString();\n'})}),"\n",(0,r.jsx)(e.h3,{id:"time-complexities-1",children:"Time Complexities"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"String concatenation with +: O(n\xb2)"}),"\n",(0,r.jsx)(e.li,{children:"StringBuilder append: O(1) amortized"}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"arraylist",children:"ArrayList"}),"\n",(0,r.jsx)(e.h3,{id:"declaration-and-operations",children:"Declaration and Operations"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"import java.util.ArrayList;\nimport java.util.Collections;\n\nArrayList<Integer> list = new ArrayList<>();\nArrayList<Integer> list2 = new ArrayList<>(Arrays.asList(1, 2, 3));\n\n// Add elements\nlist.add(10);\nlist.add(0, 5); // Add at index\n\n// Access\nint val = list.get(0);\nlist.set(0, 20); // Update\n\n// Remove\nlist.remove(0); // Remove by index\nlist.remove(Integer.valueOf(20)); // Remove by value\n\n// Size and checks\nint size = list.size();\nboolean isEmpty = list.isEmpty();\nboolean contains = list.contains(10);\nint index = list.indexOf(10);\n\n// Clear\nlist.clear();\n\n// Sorting\nCollections.sort(list);\nCollections.sort(list, Collections.reverseOrder());\n\n// Convert to array\nInteger[] arr = list.toArray(new Integer[0]);\n"})}),"\n",(0,r.jsx)(e.h3,{id:"time-complexities-2",children:"Time Complexities"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Access: O(1)"}),"\n",(0,r.jsx)(e.li,{children:"Add (end): O(1) amortized"}),"\n",(0,r.jsx)(e.li,{children:"Add (beginning): O(n)"}),"\n",(0,r.jsx)(e.li,{children:"Remove (end): O(1)"}),"\n",(0,r.jsx)(e.li,{children:"Remove (beginning): O(n)"}),"\n",(0,r.jsx)(e.li,{children:"Search: O(n)"}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"linkedlist",children:"LinkedList"}),"\n",(0,r.jsx)(e.h3,{id:"declaration-and-operations-1",children:"Declaration and Operations"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"import java.util.LinkedList;\n\nLinkedList<Integer> list = new LinkedList<>();\n\n// Add elements\nlist.add(10);\nlist.addFirst(5);\nlist.addLast(15);\nlist.add(1, 7); // Add at index\n\n// Access\nint first = list.getFirst();\nint last = list.getLast();\nint val = list.get(1);\n\n// Remove\nint removedFirst = list.removeFirst();\nint removedLast = list.removeLast();\nlist.remove(1); // Remove by index\nlist.remove(Integer.valueOf(10)); // Remove by value\n\n// Size and checks\nint size = list.size();\nboolean isEmpty = list.isEmpty();\nboolean contains = list.contains(10);\n"})}),"\n",(0,r.jsx)(e.h3,{id:"time-complexities-3",children:"Time Complexities"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Access: O(n)"}),"\n",(0,r.jsx)(e.li,{children:"Add (beginning/end): O(1)"}),"\n",(0,r.jsx)(e.li,{children:"Add (middle): O(n)"}),"\n",(0,r.jsx)(e.li,{children:"Remove (beginning/end): O(1)"}),"\n",(0,r.jsx)(e.li,{children:"Remove (middle): O(n)"}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"stack-arraydeque",children:"Stack (ArrayDeque)"}),"\n",(0,r.jsx)(e.h3,{id:"why-arraydeque-over-stack",children:"Why ArrayDeque over Stack?"}),"\n",(0,r.jsx)(e.p,{children:"ArrayDeque is faster than the legacy Stack class and should be preferred for stack operations. It's not thread-safe but more efficient."}),"\n",(0,r.jsx)(e.h3,{id:"declaration-and-operations-2",children:"Declaration and Operations"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"import java.util.ArrayDeque;\nimport java.util.Deque;\n\n// Use ArrayDeque as Stack\nDeque<Integer> stack = new ArrayDeque<>();\n\n// Push elements (add to top)\nstack.push(10);\nstack.push(20);\nstack.push(30);\n\n// Peek (view top without removing)\nint top = stack.peek();        // 30 (returns null if empty)\nint top2 = stack.peekFirst();  // 30 (same as peek)\n\n// Pop (remove and return top)\nint popped = stack.pop();      // 30 (throws exception if empty)\nint popped2 = stack.pollFirst(); // Returns null if empty\n\n// Check if empty\nboolean isEmpty = stack.isEmpty();\n\n// Size\nint size = stack.size();\n\n// Search (returns distance from top, 1-indexed)\n// Note: Not directly available in ArrayDeque\n// Use contains() instead\nboolean exists = stack.contains(20);\n\n// Clear\nstack.clear();\n\n// Iterate (bottom to top)\nfor (Integer num : stack) {\n    System.out.println(num);\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"stack-implementation-examples",children:"Stack Implementation Examples"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"// Example 1: Balanced Parentheses\npublic boolean isValid(String s) {\n    Deque<Character> stack = new ArrayDeque<>();\n    for (char c : s.toCharArray()) {\n        if (c == '(' || c == '{' || c == '[') {\n            stack.push(c);\n        } else {\n            if (stack.isEmpty()) return false;\n            char top = stack.pop();\n            if (c == ')' && top != '(') return false;\n            if (c == '}' && top != '{') return false;\n            if (c == ']' && top != '[') return false;\n        }\n    }\n    return stack.isEmpty();\n}\n\n// Example 2: Next Greater Element\npublic int[] nextGreaterElement(int[] nums) {\n    int n = nums.length;\n    int[] result = new int[n];\n    Deque<Integer> stack = new ArrayDeque<>();\n\n    for (int i = n - 1; i >= 0; i--) {\n        while (!stack.isEmpty() && stack.peek() <= nums[i]) {\n            stack.pop();\n        }\n        result[i] = stack.isEmpty() ? -1 : stack.peek();\n        stack.push(nums[i]);\n    }\n    return result;\n}\n\n// Example 3: Evaluate Postfix Expression\npublic int evalRPN(String[] tokens) {\n    Deque<Integer> stack = new ArrayDeque<>();\n    for (String token : tokens) {\n        if (token.equals(\"+\") || token.equals(\"-\") ||\n            token.equals(\"*\") || token.equals(\"/\")) {\n            int b = stack.pop();\n            int a = stack.pop();\n            if (token.equals(\"+\")) stack.push(a + b);\n            else if (token.equals(\"-\")) stack.push(a - b);\n            else if (token.equals(\"*\")) stack.push(a * b);\n            else stack.push(a / b);\n        } else {\n            stack.push(Integer.parseInt(token));\n        }\n    }\n    return stack.pop();\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"time-complexities-4",children:"Time Complexities"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Push: O(1)"}),"\n",(0,r.jsx)(e.li,{children:"Pop: O(1)"}),"\n",(0,r.jsx)(e.li,{children:"Peek: O(1)"}),"\n",(0,r.jsx)(e.li,{children:"Search: O(n)"}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"queue-arraydeque",children:"Queue (ArrayDeque)"}),"\n",(0,r.jsx)(e.h3,{id:"why-arraydeque-over-linkedlist",children:"Why ArrayDeque over LinkedList?"}),"\n",(0,r.jsx)(e.p,{children:"ArrayDeque is generally faster than LinkedList for queue operations and has better cache locality."}),"\n",(0,r.jsx)(e.h3,{id:"declaration-and-operations-3",children:"Declaration and Operations"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"import java.util.ArrayDeque;\nimport java.util.Queue;\n\n// Use ArrayDeque as Queue\nQueue<Integer> queue = new ArrayDeque<>();\n\n// Enqueue (add to rear)\nqueue.offer(10);    // Returns false if fails\nqueue.add(20);      // Throws exception if fails\n\n// Peek (view front without removing)\nint front = queue.peek();   // Returns null if empty\nint front2 = queue.element(); // Throws exception if empty\n\n// Dequeue (remove and return front)\nint removed = queue.poll();   // Returns null if empty\nint removed2 = queue.remove(); // Throws exception if empty\n\n// Check if empty\nboolean isEmpty = queue.isEmpty();\n\n// Size\nint size = queue.size();\n\n// Check if contains\nboolean exists = queue.contains(10);\n\n// Clear\nqueue.clear();\n\n// Iterate (front to rear)\nfor (Integer num : queue) {\n    System.out.println(num);\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"queue-implementation-examples",children:"Queue Implementation Examples"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"// Example 1: BFS in Binary Tree\npublic List<List<Integer>> levelOrder(TreeNode root) {\n    List<List<Integer>> result = new ArrayList<>();\n    if (root == null) return result;\n\n    Queue<TreeNode> queue = new ArrayDeque<>();\n    queue.offer(root);\n\n    while (!queue.isEmpty()) {\n        int size = queue.size();\n        List<Integer> level = new ArrayList<>();\n\n        for (int i = 0; i < size; i++) {\n            TreeNode node = queue.poll();\n            level.add(node.val);\n\n            if (node.left != null) queue.offer(node.left);\n            if (node.right != null) queue.offer(node.right);\n        }\n        result.add(level);\n    }\n    return result;\n}\n\n// Example 2: Sliding Window Maximum\npublic int[] maxSlidingWindow(int[] nums, int k) {\n    Deque<Integer> deque = new ArrayDeque<>();\n    int[] result = new int[nums.length - k + 1];\n\n    for (int i = 0; i < nums.length; i++) {\n        // Remove elements outside window\n        while (!deque.isEmpty() && deque.peekFirst() < i - k + 1) {\n            deque.pollFirst();\n        }\n\n        // Remove smaller elements\n        while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {\n            deque.pollLast();\n        }\n\n        deque.offerLast(i);\n\n        if (i >= k - 1) {\n            result[i - k + 1] = nums[deque.peekFirst()];\n        }\n    }\n    return result;\n}\n\n// Example 3: Implement Stack using Queues\nclass MyStack {\n    Queue<Integer> q1;\n    Queue<Integer> q2;\n\n    public MyStack() {\n        q1 = new ArrayDeque<>();\n        q2 = new ArrayDeque<>();\n    }\n\n    public void push(int x) {\n        q2.offer(x);\n        while (!q1.isEmpty()) {\n            q2.offer(q1.poll());\n        }\n        Queue<Integer> temp = q1;\n        q1 = q2;\n        q2 = temp;\n    }\n\n    public int pop() {\n        return q1.poll();\n    }\n\n    public int top() {\n        return q1.peek();\n    }\n\n    public boolean empty() {\n        return q1.isEmpty();\n    }\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"time-complexities-5",children:"Time Complexities"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Enqueue: O(1)"}),"\n",(0,r.jsx)(e.li,{children:"Dequeue: O(1)"}),"\n",(0,r.jsx)(e.li,{children:"Peek: O(1)"}),"\n",(0,r.jsx)(e.li,{children:"Search: O(n)"}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"deque-arraydeque",children:"Deque (ArrayDeque)"}),"\n",(0,r.jsx)(e.h3,{id:"full-deque-operations",children:"Full Deque Operations"}),"\n",(0,r.jsx)(e.p,{children:"ArrayDeque implements the Deque interface and provides double-ended queue functionality."}),"\n",(0,r.jsx)(e.h3,{id:"declaration-and-operations-4",children:"Declaration and Operations"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"import java.util.ArrayDeque;\nimport java.util.Deque;\n\nDeque<Integer> deque = new ArrayDeque<>();\n\n// Add to front\ndeque.addFirst(10);    // Throws exception if fails\ndeque.offerFirst(5);   // Returns false if fails\n\n// Add to rear\ndeque.addLast(20);     // Throws exception if fails\ndeque.offerLast(25);   // Returns false if fails\n\n// Peek front\nint front = deque.peekFirst();   // Returns null if empty\nint front2 = deque.getFirst();   // Throws exception if empty\n\n// Peek rear\nint rear = deque.peekLast();     // Returns null if empty\nint rear2 = deque.getLast();     // Throws exception if empty\n\n// Remove from front\nint removed = deque.pollFirst();  // Returns null if empty\nint removed2 = deque.removeFirst(); // Throws exception if empty\n\n// Remove from rear\nint removed3 = deque.pollLast();   // Returns null if empty\nint removed4 = deque.removeLast(); // Throws exception if empty\n\n// Size and checks\nint size = deque.size();\nboolean isEmpty = deque.isEmpty();\nboolean contains = deque.contains(10);\n\n// Remove specific element\ndeque.removeFirstOccurrence(10);\ndeque.removeLastOccurrence(20);\n\n// Clear\ndeque.clear();\n\n// Iterate forward\nfor (Integer num : deque) {\n    System.out.println(num);\n}\n\n// Iterate backward\nIterator<Integer> it = deque.descendingIterator();\nwhile (it.hasNext()) {\n    System.out.println(it.next());\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"deque-as-stack-and-queue",children:"Deque as Stack and Queue"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"// As Stack (LIFO)\ndeque.push(10);      // Same as addFirst()\ndeque.pop();         // Same as removeFirst()\ndeque.peek();        // Same as peekFirst()\n\n// As Queue (FIFO)\ndeque.offer(10);     // Same as offerLast()\ndeque.poll();        // Same as pollFirst()\ndeque.peek();        // Same as peekFirst()\n"})}),"\n",(0,r.jsx)(e.h3,{id:"deque-implementation-examples",children:"Deque Implementation Examples"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"// Example 1: Sliding Window Maximum using Deque\npublic int[] maxSlidingWindow(int[] nums, int k) {\n    Deque<Integer> deque = new ArrayDeque<>();\n    int[] result = new int[nums.length - k + 1];\n\n    for (int i = 0; i < nums.length; i++) {\n        // Remove indices outside window\n        while (!deque.isEmpty() && deque.peekFirst() < i - k + 1) {\n            deque.pollFirst();\n        }\n\n        // Remove smaller elements from rear\n        while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {\n            deque.pollLast();\n        }\n\n        deque.offerLast(i);\n\n        if (i >= k - 1) {\n            result[i - k + 1] = nums[deque.peekFirst()];\n        }\n    }\n    return result;\n}\n\n// Example 2: Max of all subarrays of size k\npublic ArrayList<Integer> maxOfSubarrays(int[] arr, int k) {\n    ArrayList<Integer> result = new ArrayList<>();\n    Deque<Integer> deque = new ArrayDeque<>();\n\n    for (int i = 0; i < arr.length; i++) {\n        // Remove elements outside window\n        if (!deque.isEmpty() && deque.peekFirst() <= i - k) {\n            deque.pollFirst();\n        }\n\n        // Remove smaller elements\n        while (!deque.isEmpty() && arr[deque.peekLast()] <= arr[i]) {\n            deque.pollLast();\n        }\n\n        deque.offerLast(i);\n\n        if (i >= k - 1) {\n            result.add(arr[deque.peekFirst()]);\n        }\n    }\n    return result;\n}\n\n// Example 3: First negative in every window of size k\npublic long[] printFirstNegativeInteger(long[] arr, int k) {\n    long[] result = new long[arr.length - k + 1];\n    Deque<Integer> deque = new ArrayDeque<>();\n\n    for (int i = 0; i < arr.length; i++) {\n        // Add negative numbers to deque\n        if (arr[i] < 0) {\n            deque.offerLast(i);\n        }\n\n        // Remove elements outside window\n        while (!deque.isEmpty() && deque.peekFirst() < i - k + 1) {\n            deque.pollFirst();\n        }\n\n        if (i >= k - 1) {\n            if (!deque.isEmpty()) {\n                result[i - k + 1] = arr[deque.peekFirst()];\n            } else {\n                result[i - k + 1] = 0;\n            }\n        }\n    }\n    return result;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"method-comparison-table",children:"Method Comparison Table"}),"\n",(0,r.jsxs)(e.table,{children:[(0,r.jsx)(e.thead,{children:(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.th,{children:"Operation"}),(0,r.jsx)(e.th,{children:"First Element"}),(0,r.jsx)(e.th,{children:"Last Element"}),(0,r.jsx)(e.th,{children:"Throws Exception"}),(0,r.jsx)(e.th,{children:"Returns Special Value"})]})}),(0,r.jsxs)(e.tbody,{children:[(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Insert"}),(0,r.jsx)(e.td,{children:"addFirst(e)"}),(0,r.jsx)(e.td,{children:"addLast(e)"}),(0,r.jsx)(e.td,{children:"offerFirst(e)"}),(0,r.jsx)(e.td,{children:"offerLast(e)"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Remove"}),(0,r.jsx)(e.td,{children:"removeFirst()"}),(0,r.jsx)(e.td,{children:"removeLast()"}),(0,r.jsx)(e.td,{children:"pollFirst()"}),(0,r.jsx)(e.td,{children:"pollLast()"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Examine"}),(0,r.jsx)(e.td,{children:"getFirst()"}),(0,r.jsx)(e.td,{children:"getLast()"}),(0,r.jsx)(e.td,{children:"peekFirst()"}),(0,r.jsx)(e.td,{children:"peekLast()"})]})]})]}),"\n",(0,r.jsx)(e.h3,{id:"time-complexities-6",children:"Time Complexities"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Add (both ends): O(1)"}),"\n",(0,r.jsx)(e.li,{children:"Remove (both ends): O(1)"}),"\n",(0,r.jsx)(e.li,{children:"Peek (both ends): O(1)"}),"\n",(0,r.jsx)(e.li,{children:"Search: O(n)"}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"priorityqueue-heap",children:"PriorityQueue (Heap)"}),"\n",(0,r.jsx)(e.h3,{id:"declaration-and-operations-5",children:"Declaration and Operations"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"import java.util.PriorityQueue;\nimport java.util.Collections;\n\n// Min Heap (default)\nPriorityQueue<Integer> minHeap = new PriorityQueue<>();\n\n// Max Heap\nPriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\n\n// Custom comparator\nPriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\n\n// Add elements\npq.offer(10);\npq.add(20);\n\n// Peek (view top)\nint top = pq.peek();\n\n// Poll (remove and return top)\nint removed = pq.poll();\n\n// Size\nint size = pq.size();\nboolean isEmpty = pq.isEmpty();\n\n// Contains\nboolean exists = pq.contains(10);\n\n// Remove specific element\npq.remove(10);\n\n// Clear\npq.clear();\n"})}),"\n",(0,r.jsx)(e.h3,{id:"custom-objects-in-priorityqueue",children:"Custom Objects in PriorityQueue"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"class Student implements Comparable<Student> {\n    String name;\n    int marks;\n\n    public Student(String name, int marks) {\n        this.name = name;\n        this.marks = marks;\n    }\n\n    @Override\n    public int compareTo(Student other) {\n        return this.marks - other.marks; // Min heap by marks\n    }\n}\n\nPriorityQueue<Student> pq = new PriorityQueue<>();\n\n// Or use comparator\nPriorityQueue<Student> pq2 = new PriorityQueue<>((a, b) -> b.marks - a.marks);\n"})}),"\n",(0,r.jsx)(e.h3,{id:"time-complexities-7",children:"Time Complexities"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Insert: O(log n)"}),"\n",(0,r.jsx)(e.li,{children:"Remove top: O(log n)"}),"\n",(0,r.jsx)(e.li,{children:"Peek: O(1)"}),"\n",(0,r.jsx)(e.li,{children:"Remove specific: O(n)"}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"hashmap",children:"HashMap"}),"\n",(0,r.jsx)(e.h3,{id:"declaration-and-operations-6",children:"Declaration and Operations"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:'import java.util.HashMap;\nimport java.util.Map;\n\nHashMap<String, Integer> map = new HashMap<>();\n\n// Put key-value pairs\nmap.put("apple", 5);\nmap.put("banana", 3);\nmap.putIfAbsent("apple", 10); // Only puts if key doesn\'t exist\n\n// Get value\nint val = map.get("apple");\nint valOrDefault = map.getOrDefault("grape", 0);\n\n// Check if key/value exists\nboolean hasKey = map.containsKey("apple");\nboolean hasValue = map.containsValue(5);\n\n// Remove\nint removed = map.remove("apple");\n\n// Size\nint size = map.size();\nboolean isEmpty = map.isEmpty();\n\n// Clear\nmap.clear();\n\n// Iterate\nfor (Map.Entry<String, Integer> entry : map.entrySet()) {\n    System.out.println(entry.getKey() + ": " + entry.getValue());\n}\n\n// Iterate keys\nfor (String key : map.keySet()) {\n    System.out.println(key);\n}\n\n// Iterate values\nfor (Integer value : map.values()) {\n    System.out.println(value);\n}\n\n// Update value\nmap.put("banana", map.get("banana") + 1);\nmap.merge("banana", 1, Integer::sum);\nmap.computeIfPresent("banana", (k, v) -> v + 1);\n'})}),"\n",(0,r.jsx)(e.h3,{id:"time-complexities-8",children:"Time Complexities"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Get: O(1) average, O(n) worst"}),"\n",(0,r.jsx)(e.li,{children:"Put: O(1) average, O(n) worst"}),"\n",(0,r.jsx)(e.li,{children:"Remove: O(1) average, O(n) worst"}),"\n",(0,r.jsx)(e.li,{children:"ContainsKey: O(1) average, O(n) worst"}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"hashset",children:"HashSet"}),"\n",(0,r.jsx)(e.h3,{id:"declaration-and-operations-7",children:"Declaration and Operations"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"import java.util.HashSet;\n\nHashSet<Integer> set = new HashSet<>();\n\n// Add elements\nset.add(10);\nset.add(20);\n\n// Remove\nset.remove(10);\n\n// Contains\nboolean exists = set.contains(20);\n\n// Size\nint size = set.size();\nboolean isEmpty = set.isEmpty();\n\n// Clear\nset.clear();\n\n// Iterate\nfor (Integer num : set) {\n    System.out.println(num);\n}\n\n// Convert to array\nInteger[] arr = set.toArray(new Integer[0]);\n"})}),"\n",(0,r.jsx)(e.h3,{id:"time-complexities-9",children:"Time Complexities"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Add: O(1) average"}),"\n",(0,r.jsx)(e.li,{children:"Remove: O(1) average"}),"\n",(0,r.jsx)(e.li,{children:"Contains: O(1) average"}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"linkedhashmap",children:"LinkedHashMap"}),"\n",(0,r.jsx)(e.p,{children:"Maintains insertion order."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:'import java.util.LinkedHashMap;\n\nLinkedHashMap<String, Integer> map = new LinkedHashMap<>();\n\n// All HashMap operations apply\nmap.put("first", 1);\nmap.put("second", 2);\nmap.put("third", 3);\n\n// Maintains insertion order during iteration\nfor (Map.Entry<String, Integer> entry : map.entrySet()) {\n    System.out.println(entry.getKey() + ": " + entry.getValue());\n}\n// Output: first: 1, second: 2, third: 3\n'})}),"\n",(0,r.jsx)(e.h3,{id:"time-complexities-10",children:"Time Complexities"}),"\n",(0,r.jsx)(e.p,{children:"Same as HashMap."}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"linkedhashset",children:"LinkedHashSet"}),"\n",(0,r.jsx)(e.p,{children:"Maintains insertion order."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"import java.util.LinkedHashSet;\n\nLinkedHashSet<Integer> set = new LinkedHashSet<>();\n\n// All HashSet operations apply\nset.add(30);\nset.add(10);\nset.add(20);\n\n// Maintains insertion order\nfor (Integer num : set) {\n    System.out.println(num);\n}\n// Output: 30, 10, 20\n"})}),"\n",(0,r.jsx)(e.h3,{id:"time-complexities-11",children:"Time Complexities"}),"\n",(0,r.jsx)(e.p,{children:"Same as HashSet."}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"treemap",children:"TreeMap"}),"\n",(0,r.jsx)(e.p,{children:"Maintains keys in sorted order (Red-Black Tree)."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:'import java.util.TreeMap;\n\nTreeMap<Integer, String> map = new TreeMap<>();\n\n// Put\nmap.put(3, "three");\nmap.put(1, "one");\nmap.put(2, "two");\n\n// Get\nString val = map.get(1);\n\n// First and last keys\nint firstKey = map.firstKey();\nint lastKey = map.lastKey();\n\n// First and last entries\nMap.Entry<Integer, String> firstEntry = map.firstEntry();\nMap.Entry<Integer, String> lastEntry = map.lastEntry();\n\n// Floor and ceiling\nInteger floor = map.floorKey(2); // Largest key <= 2\nInteger ceiling = map.ceilingKey(2); // Smallest key >= 2\n\n// Lower and higher\nInteger lower = map.lowerKey(2); // Largest key < 2\nInteger higher = map.higherKey(2); // Smallest key > 2\n\n// Submap\nTreeMap<Integer, String> subMap = new TreeMap<>(map.subMap(1, 3));\n\n// Remove first/last\nmap.pollFirstEntry();\nmap.pollLastEntry();\n'})}),"\n",(0,r.jsx)(e.h3,{id:"time-complexities-12",children:"Time Complexities"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Get: O(log n)"}),"\n",(0,r.jsx)(e.li,{children:"Put: O(log n)"}),"\n",(0,r.jsx)(e.li,{children:"Remove: O(log n)"}),"\n",(0,r.jsx)(e.li,{children:"ContainsKey: O(log n)"}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"treeset",children:"TreeSet"}),"\n",(0,r.jsx)(e.p,{children:"Maintains elements in sorted order (Red-Black Tree)."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"import java.util.TreeSet;\n\nTreeSet<Integer> set = new TreeSet<>();\n\n// Add\nset.add(30);\nset.add(10);\nset.add(20);\n\n// First and last\nint first = set.first();\nint last = set.last();\n\n// Floor and ceiling\nInteger floor = set.floor(25); // Largest element <= 25\nInteger ceiling = set.ceiling(25); // Smallest element >= 25\n\n// Lower and higher\nInteger lower = set.lower(20); // Largest element < 20\nInteger higher = set.higher(20); // Smallest element > 20\n\n// Subset\nTreeSet<Integer> subset = new TreeSet<>(set.subSet(10, 30));\n\n// Remove first/last\nset.pollFirst();\nset.pollLast();\n\n// Descending set\nTreeSet<Integer> descSet = new TreeSet<>(set.descendingSet());\n"})}),"\n",(0,r.jsx)(e.h3,{id:"time-complexities-13",children:"Time Complexities"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Add: O(log n)"}),"\n",(0,r.jsx)(e.li,{children:"Remove: O(log n)"}),"\n",(0,r.jsx)(e.li,{children:"Contains: O(log n)"}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"sorting-algorithms",children:"Sorting Algorithms"}),"\n",(0,r.jsx)(e.h3,{id:"bubble-sort",children:"Bubble Sort"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"void bubbleSort(int[] arr) {\n    int n = arr.length;\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}\n// Time: O(n\xb2), Space: O(1)\n"})}),"\n",(0,r.jsx)(e.h3,{id:"selection-sort",children:"Selection Sort"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"void selectionSort(int[] arr) {\n    int n = arr.length;\n    for (int i = 0; i < n - 1; i++) {\n        int minIdx = i;\n        for (int j = i + 1; j < n; j++) {\n            if (arr[j] < arr[minIdx]) {\n                minIdx = j;\n            }\n        }\n        int temp = arr[i];\n        arr[i] = arr[minIdx];\n        arr[minIdx] = temp;\n    }\n}\n// Time: O(n\xb2), Space: O(1)\n"})}),"\n",(0,r.jsx)(e.h3,{id:"insertion-sort",children:"Insertion Sort"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"void insertionSort(int[] arr) {\n    int n = arr.length;\n    for (int i = 1; i < n; i++) {\n        int key = arr[i];\n        int j = i - 1;\n        while (j >= 0 && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n        arr[j + 1] = key;\n    }\n}\n// Time: O(n\xb2), Space: O(1)\n"})}),"\n",(0,r.jsx)(e.h3,{id:"merge-sort",children:"Merge Sort"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"void mergeSort(int[] arr, int left, int right) {\n    if (left < right) {\n        int mid = left + (right - left) / 2;\n        mergeSort(arr, left, mid);\n        mergeSort(arr, mid + 1, right);\n        merge(arr, left, mid, right);\n    }\n}\n\nvoid merge(int[] arr, int left, int mid, int right) {\n    int n1 = mid - left + 1;\n    int n2 = right - mid;\n\n    int[] L = new int[n1];\n    int[] R = new int[n2];\n\n    for (int i = 0; i < n1; i++) L[i] = arr[left + i];\n    for (int j = 0; j < n2; j++) R[j] = arr[mid + 1 + j];\n\n    int i = 0, j = 0, k = left;\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) {\n            arr[k++] = L[i++];\n        } else {\n            arr[k++] = R[j++];\n        }\n    }\n\n    while (i < n1) arr[k++] = L[i++];\n    while (j < n2) arr[k++] = R[j++];\n}\n// Time: O(n log n), Space: O(n)\n"})}),"\n",(0,r.jsx)(e.h3,{id:"quick-sort",children:"Quick Sort"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"void quickSort(int[] arr, int low, int high) {\n    if (low < high) {\n        int pi = partition(arr, low, high);\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\n\nint partition(int[] arr, int low, int high) {\n    int pivot = arr[high];\n    int i = low - 1;\n\n    for (int j = low; j < high; j++) {\n        if (arr[j] < pivot) {\n            i++;\n            int temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n        }\n    }\n\n    int temp = arr[i + 1];\n    arr[i + 1] = arr[high];\n    arr[high] = temp;\n\n    return i + 1;\n}\n// Time: O(n log n) average, O(n\xb2) worst, Space: O(log n)\n"})}),"\n",(0,r.jsx)(e.h3,{id:"heap-sort",children:"Heap Sort"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"void heapSort(int[] arr) {\n    int n = arr.length;\n\n    // Build heap\n    for (int i = n / 2 - 1; i >= 0; i--) {\n        heapify(arr, i, 0);\n    }\n}\n\nvoid heapify(int[] arr, int n, int i) {\n    int largest = i;\n    int left = 2 * i + 1;\n    int right = 2 * i + 2;\n\n    if (left < n && arr[left] > arr[largest]) {\n        largest = left;\n    }\n    if (right < n && arr[right] > arr[largest]) {\n        largest = right;\n    }\n\n    if (largest != i) {\n        int temp = arr[i];\n        arr[i] = arr[largest];\n        arr[largest] = temp;\n        heapify(arr, n, largest);\n    }\n}\n// Time: O(n log n), Space: O(1)\n"})}),"\n",(0,r.jsx)(e.h3,{id:"counting-sort",children:"Counting Sort"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"void countingSort(int[] arr) {\n    int max = Arrays.stream(arr).max().getAsInt();\n    int min = Arrays.stream(arr).min().getAsInt();\n    int range = max - min + 1;\n\n    int[] count = new int[range];\n    int[] output = new int[arr.length];\n\n    for (int num : arr) {\n        count[num - min]++;\n    }\n\n    for (int i = 1; i < range; i++) {\n        count[i] += count[i - 1];\n    }\n\n    for (int i = arr.length - 1; i >= 0; i--) {\n        output[count[arr[i] - min] - 1] = arr[i];\n        count[arr[i] - min]--;\n    }\n\n    System.arraycopy(output, 0, arr, 0, arr.length);\n}\n// Time: O(n + k), Space: O(n + k), where k is range\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"searching-algorithms",children:"Searching Algorithms"}),"\n",(0,r.jsx)(e.h3,{id:"linear-search",children:"Linear Search"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"int linearSearch(int[] arr, int target) {\n    for (int i = 0; i < arr.length; i++) {\n        if (arr[i] == target) {\n            return i;\n        }\n    }\n    return -1;\n}\n// Time: O(n), Space: O(1)\n"})}),"\n",(0,r.jsx)(e.h3,{id:"binary-search",children:"Binary Search"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"int binarySearch(int[] arr, int target) {\n    int left = 0, right = arr.length - 1;\n\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n\n        if (arr[mid] == target) {\n            return mid;\n        } else if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return -1;\n}\n// Time: O(log n), Space: O(1)\n\n// Recursive\nint binarySearchRecursive(int[] arr, int target, int left, int right) {\n    if (left > right) return -1;\n\n    int mid = left + (right - left) / 2;\n\n    if (arr[mid] == target) return mid;\n    else if (arr[mid] < target) return binarySearchRecursive(arr, target, mid + 1, right);\n    else return binarySearchRecursive(arr, target, left, mid - 1);\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"binary-search-variations",children:"Binary Search Variations"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"// Find first occurrence\nint findFirst(int[] arr, int target) {\n    int left = 0, right = arr.length - 1;\n    int result = -1;\n\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) {\n            result = mid;\n            right = mid - 1; // Continue searching left\n        } else if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return result;\n}\n\n// Find last occurrence\nint findLast(int[] arr, int target) {\n    int left = 0, right = arr.length - 1;\n    int result = -1;\n\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) {\n            result = mid;\n            left = mid + 1; // Continue searching right\n        } else if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return result;\n}\n\n// Find insertion position (lower_bound)\nint lowerBound(int[] arr, int target) {\n    int left = 0, right = arr.length;\n\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return left;\n}\n\n// Find upper bound\nint upperBound(int[] arr, int target) {\n    int left = 0, right = arr.length;\n\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] <= target) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return left;\n}\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"recursion",children:"Recursion"}),"\n",(0,r.jsx)(e.h3,{id:"basic-recursion",children:"Basic Recursion"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"// Factorial\nint factorial(int n) {\n    if (n <= 1) return 1;\n    return n * factorial(n - 1);\n}\n\n// Fibonacci\nint fibonacci(int n) {\n    if (n <= 1) return n;\n    return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\n// Power\nint power(int base, int exp) {\n    if (exp == 0) return 1;\n    return base * power(base, exp - 1);\n}\n\n// Sum of digits\nint sumOfDigits(int n) {\n    if (n == 0) return 0;\n    return n % 10 + sumOfDigits(n / 10);\n}\n\n// Print 1 to N\nvoid print1ToN(int n) {\n    if (n == 0) return;\n    print1ToN(n - 1);\n    System.out.println(n);\n}\n\n// Print N to 1\nvoid printNTo1(int n) {\n    if (n == 0) return;\n    System.out.println(n);\n    printNTo1(n - 1);\n}\n\n// Array sum\nint arraySum(int[] arr, int n) {\n    if (n <= 0) return 0;\n    return arr[n - 1] + arraySum(arr, n - 1);\n}\n\n// Check if array is sorted\nboolean isSorted(int[] arr, int n) {\n    if (n == 1) return true;\n    return arr[n - 1] >= arr[n - 2] && isSorted(arr, n - 1);\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"advanced-recursion",children:"Advanced Recursion"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:'// Tower of Hanoi\nvoid towerOfHanoi(int n, char from, char to, char aux) {\n    if (n == 1) {\n        System.out.println("Move disk 1 from " + from + " to " + to);\n        return;\n    }\n    towerOfHanoi(n - 1, from, aux, to);\n    System.out.println("Move disk " + n + " from " + from + " to " + to);\n    towerOfHanoi(n - 1, aux, to, from);\n}\n\n// Generate all binary strings\nvoid generateBinaryStrings(int n, String current) {\n    if (current.length() == n) {\n        System.out.println(current);\n        return;\n    }\n    generateBinaryStrings(n, current + "0");\n    generateBinaryStrings(n, current + "1");\n}\n\n// Josephus problem\nint josephus(int n, int k) {\n    if (n == 1) return 0;\n    return (josephus(n - 1, k) + k) % n;\n}\n'})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"backtracking",children:"Backtracking"}),"\n",(0,r.jsx)(e.h3,{id:"permutations",children:"Permutations"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"void permute(int[] arr, int start, List<List<Integer>> result) {\n    if (start == arr.length) {\n        List<Integer> list = new ArrayList<>();\n        for (int num : arr) list.add(num);\n        result.add(list);\n        return;\n    }\n\n    for (int i = start; i < arr.length; i++) {\n        swap(arr, start, i);\n        permute(arr, start + 1, result);\n        swap(arr, start, i); // Backtrack\n    }\n}\n\nvoid swap(int[] arr, int i, int j) {\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"combinations",children:"Combinations"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"void combine(int n, int k, int start, List<Integer> current, List<List<Integer>> result) {\n    if (current.size() == k) {\n        result.add(new ArrayList<>(current));\n        return;\n    }\n\n    for (int i = start; i <= n; i++) {\n        current.add(i);\n        combine(n, k, i + 1, current, result);\n        current.remove(current.size() - 1); // Backtrack\n    }\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"subsets",children:"Subsets"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"void subsets(int[] arr, int index, List<Integer> current, List<List<Integer>> result) {\n    result.add(new ArrayList<>(current));\n\n    for (int i = index; i < arr.length; i++) {\n        current.add(arr[i]);\n        subsets(arr, i + 1, current, result);\n        current.remove(current.size() - 1); // Backtrack\n    }\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"n-queens",children:"N-Queens"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"void solveNQueens(int n, int row, boolean[] cols, boolean[] diag1, boolean[] diag2,\n                  List<Integer> board, List<List<String>> result) {\n    if (row == n) {\n        result.add(constructBoard(board, n));\n        return;\n    }\n\n    for (int col = 0; col < n; col++) {\n        int d1 = row - col + n - 1;\n        int d2 = row + col;\n\n        if (!cols[col] && !diag1[d1] && !diag2[d2]) {\n            cols[col] = diag1[d1] = diag2[d2] = true;\n            board.add(col);\n\n            solveNQueens(n, row + 1, cols, diag1, diag2, board, result);\n\n            board.remove(board.size() - 1);\n            cols[col] = diag1[d1] = diag2[d2] = false;\n        }\n    }\n}\n\nList<String> constructBoard(List<Integer> board, int n) {\n    List<String> result = new ArrayList<>();\n    for (int col : board) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < n; i++) {\n            sb.append(i == col ? 'Q' : '.');\n        }\n        result.add(sb.toString());\n    }\n    return result;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"sudoku-solver",children:"Sudoku Solver"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"boolean solveSudoku(char[][] board) {\n    for (int row = 0; row < 9; row++) {\n        for (int col = 0; col < 9; col++) {\n            if (board[row][col] == '.') {\n                for (char num = '1'; num <= '9'; num++) {\n                    if (isValid(board, row, col, num)) {\n                        board[row][col] = num;\n\n                        if (solveSudoku(board)) return true;\n\n                        board[row][col] = '.'; // Backtrack\n                    }\n                }\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nboolean isValid(char[][] board, int row, int col, char num) {\n    for (int i = 0; i < 9; i++) {\n        if (board[row][i] == num) return false;\n        if (board[i][col] == num) return false;\n        if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == num) return false;\n    }\n    return true;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"rat-in-a-maze",children:"Rat in a Maze"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"boolean solveMaze(int[][] maze, int x, int y, int[][] sol) {\n    int n = maze.length;\n\n    if (x == n - 1 && y == n - 1 && maze[x][y] == 1) {\n        sol[x][y] = 1;\n        return true;\n    }\n\n    if (isSafe(maze, x, y, n)) {\n        sol[x][y] = 1;\n\n        if (solveMaze(maze, x + 1, y, sol)) return true;\n        if (solveMaze(maze, x, y + 1, sol)) return true;\n\n        sol[x][y] = 0; // Backtrack\n    }\n\n    return false;\n}\n\nboolean isSafe(int[][] maze, int x, int y, int n) {\n    return x >= 0 && x < n && y >= 0 && y < n && maze[x][y] == 1;\n}\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"dynamic-programming",children:"Dynamic Programming"}),"\n",(0,r.jsx)(e.h3,{id:"1d-dp",children:"1D DP"}),"\n",(0,r.jsx)(e.h4,{id:"fibonacci",children:"Fibonacci"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"int fib(int n) {\n    if (n <= 1) return n;\n    int[] dp = new int[n + 1];\n    dp[0] = 0;\n    dp[1] = 1;\n\n    for (int i = 2; i <= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2];\n    }\n    return dp[n];\n}\n"})}),"\n",(0,r.jsx)(e.h4,{id:"climbing-stairs",children:"Climbing Stairs"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"int climbStairs(int n) {\n    if (n <= 2) return n;\n    int[] dp = new int[n + 1];\n    dp[1] = 1;\n    dp[2] = 2;\n\n    for (int i = 3; i <= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2];\n    }\n    return dp[n];\n}\n"})}),"\n",(0,r.jsx)(e.h4,{id:"house-robber",children:"House Robber"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"int rob(int[] nums) {\n    if (nums.length == 0) return 0;\n    if (nums.length == 1) return nums[0];\n\n    int[] dp = new int[nums.length];\n    dp[0] = nums[0];\n    dp[1] = Math.max(nums[0], nums[1]);\n\n    for (int i = 2; i < nums.length; i++) {\n        dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);\n    }\n    return dp[nums.length - 1];\n}\n"})}),"\n",(0,r.jsx)(e.h4,{id:"coin-change",children:"Coin Change"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"int coinChange(int[] coins, int amount) {\n    int[] dp = new int[amount + 1];\n    Arrays.fill(dp, amount + 1);\n    dp[0] = 0;\n\n    for (int i = 1; i <= amount; i++) {\n        for (int coin : coins) {\n            if (i >= coin) {\n                dp[i] = Math.min(dp[i], dp[i - coin] + 1);\n            }\n        }\n    }\n    return dp[amount] > amount ? -1 : dp[amount];\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"2d-dp",children:"2D DP"}),"\n",(0,r.jsx)(e.h4,{id:"longest-common-subsequence",children:"Longest Common Subsequence"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"int lcs(String s1, String s2) {\n    int m = s1.length(), n = s2.length();\n    int[][] dp = new int[m + 1][n + 1];\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (s1.charAt(i - 1) == s2.charAt(j - 1)) {\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            } else {\n                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[m][n];\n}\n"})}),"\n",(0,r.jsx)(e.h4,{id:"01-knapsack",children:"0/1 Knapsack"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"int knapsack(int[] weights, int[] values, int W) {\n    int n = weights.length;\n    int[][] dp = new int[n + 1][W + 1];\n\n    for (int i = 1; i <= n; i++) {\n        for (int w = 1; w <= W; w++) {\n            if (weights[i - 1] <= w) {\n                dp[i][w] = Math.max(dp[i - 1][w],\n                                    dp[i - 1][w - weights[i - 1]] + values[i - 1]);\n            } else {\n                dp[i][w] = dp[i - 1][w];\n            }\n        }\n    }\n    return dp[n][W];\n}\n"})}),"\n",(0,r.jsx)(e.h4,{id:"edit-distance",children:"Edit Distance"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"int editDistance(String s1, String s2) {\n    int m = s1.length(), n = s2.length();\n    int[][] dp = new int[m + 1][n + 1];\n\n    for (int i = 0; i <= m; i++) dp[i][0] = i;\n    for (int j = 0; j <= n; j++) dp[0][j] = j;\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (s1.charAt(i - 1) == s2.charAt(j - 1)) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = 1 + Math.min(dp[i - 1][j - 1],\n                                        Math.min(dp[i - 1][j], dp[i][j - 1]));\n            }\n        }\n    }\n    return dp[m][n];\n}\n"})}),"\n",(0,r.jsx)(e.h4,{id:"longest-palindromic-subsequence",children:"Longest Palindromic Subsequence"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"int longestPalindromeSubseq(String s) {\n    int n = s.length();\n    int[][] dp = new int[n][n];\n\n    for (int i = 0; i < n; i++) dp[i][i] = 1;\n\n    for (int len = 2; len <= n; len++) {\n        for (int i = 0; i < n - len + 1; i++) {\n            int j = i + len - 1;\n            if (s.charAt(i) == s.charAt(j)) {\n                dp[i][j] = dp[i + 1][j - 1] + 2;\n            } else {\n                dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\n"})}),"\n",(0,r.jsx)(e.h4,{id:"matrix-chain-multiplication",children:"Matrix Chain Multiplication"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"int matrixChainOrder(int[] dims) {\n    int n = dims.length - 1;\n    int[][] dp = new int[n][n];\n\n    for (int len = 2; len <= n; len++) {\n        for (int i = 0; i < n - len + 1; i++) {\n            int j = i + len - 1;\n            dp[i][j] = Integer.MAX_VALUE;\n\n            for (int k = i; k < j; k++) {\n                int cost = dp[i][k] + dp[k + 1][j] +\n                          dims[i] * dims[k + 1] * dims[j + 1];\n                dp[i][j] = Math.min(dp[i][j], cost);\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"graph-algorithms",children:"Graph Algorithms"}),"\n",(0,r.jsx)(e.h3,{id:"graph-representation",children:"Graph Representation"}),"\n",(0,r.jsx)(e.h4,{id:"adjacency-list",children:"Adjacency List"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"class Graph {\n    int V;\n    ArrayList<ArrayList<Integer>> adj;\n\n    Graph(int v) {\n        V = v;\n        adj = new ArrayList<>();\n        for (int i = 0; i < v; i++) {\n            adj.add(new ArrayList<>());\n        }\n    }\n\n    void addEdge(int u, int v) {\n        adj.get(u).add(v);\n        adj.get(v).add(u); // For undirected graph\n    }\n}\n"})}),"\n",(0,r.jsx)(e.h4,{id:"adjacency-matrix",children:"Adjacency Matrix"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"class Graph {\n    int[][] adj;\n    int V;\n\n    Graph(int v) {\n        V = v;\n        adj = new int[v][v];\n    }\n\n    void addEdge(int u, int v) {\n        adj[u][v] = 1;\n        adj[v][u] = 1; // For undirected graph\n    }\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"bfs-breadth-first-search",children:"BFS (Breadth-First Search)"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:'void BFS(int start) {\n    boolean[] visited = new boolean[V];\n    Queue<Integer> queue = new ArrayDeque<>();\n\n    visited[start] = true;\n    queue.offer(start);\n\n    while (!queue.isEmpty()) {\n        int u = queue.poll();\n        System.out.print(u + " ");\n\n        for (int v : adj.get(u)) {\n            if (!visited[v]) {\n                visited[v] = true;\n                queue.offer(v);\n            }\n        }\n    }\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"dfs-depth-first-search",children:"DFS (Depth-First Search)"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:'void DFS(int start) {\n    boolean[] visited = new boolean[V];\n    DFSUtil(start, visited);\n}\n\nvoid DFSUtil(int u, boolean[] visited) {\n    visited[u] = true;\n    System.out.print(u + " ");\n\n    for (int v : adj.get(u)) {\n        if (!visited[v]) {\n            DFSUtil(v, visited);\n        }\n    }\n}\n\n// Iterative DFS\nvoid DFSIterative(int start) {\n    boolean[] visited = new boolean[V];\n    Deque<Integer> stack = new ArrayDeque<>();\n\n    stack.push(start);\n\n    while (!stack.isEmpty()) {\n        int u = stack.pop();\n\n        if (!visited[u]) {\n            visited[u] = true;\n            System.out.print(u + " ");\n\n            for (int v : adj.get(u)) {\n                if (!visited[v]) {\n                    stack.push(v);\n                }\n            }\n        }\n    }\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"dijkstras-algorithm",children:"Dijkstra's Algorithm"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"int[] dijkstra(int src) {\n    int[] dist = new int[V];\n    Arrays.fill(dist, Integer.MAX_VALUE);\n    dist[src] = 0;\n\n    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\n    pq.offer(new int[]{src, 0});\n\n    while (!pq.isEmpty()) {\n        int[] curr = pq.poll();\n        int u = curr[0];\n\n        for (int[] edge : adjWeighted.get(u)) {\n            int v = edge[0];\n            int weight = edge[1];\n\n            if (dist[u] + weight < dist[v]) {\n                dist[v] = dist[u] + weight;\n                pq.offer(new int[]{v, dist[v]});\n            }\n        }\n    }\n    return dist;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"bellman-ford-algorithm",children:"Bellman-Ford Algorithm"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:'int[] bellmanFord(int src, List<int[]> edges) {\n    int[] dist = new int[V];\n    Arrays.fill(dist, Integer.MAX_VALUE);\n    dist[src] = 0;\n\n    for (int i = 0; i < V - 1; i++) {\n        for (int[] edge : edges) {\n            int u = edge[0], v = edge[1], w = edge[2];\n            if (dist[u] != Integer.MAX_VALUE && dist[u] + w < dist[v]) {\n                dist[v] = dist[u] + w;\n            }\n        }\n    }\n\n    // Check for negative cycle\n    for (int[] edge : edges) {\n        int u = edge[0], v = edge[1], w = edge[2];\n        if (dist[u] != Integer.MAX_VALUE && dist[u] + w < dist[v]) {\n            System.out.println("Negative cycle detected");\n            return null;\n        }\n    }\n    return dist;\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"floyd-warshall-algorithm",children:"Floyd-Warshall Algorithm"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"int[][] floydWarshall() {\n    int[][] dist = new int[V][V];\n\n    for (int i = 0; i < V; i++) {\n        Arrays.fill(dist[i], Integer.MAX_VALUE);\n        dist[i][i] = 0;\n    }\n\n    // Initialize with edge weights\n    for (int u = 0; u < V; u++) {\n        for (int[] edge : adjWeighted.get(u)) {\n            int v = edge[0];\n            int w = edge[1];\n            dist[u][v] = w;\n        }\n    }\n\n    for (int k = 0; k < V; k++) {\n        for (int i = 0; i < V; i++) {\n            for (int j = 0; j < V; j++) {\n                if (dist[i][k] != Integer.MAX_VALUE &&\n                    dist[k][j] != Integer.MAX_VALUE &&\n                    dist[i][k] + dist[k][j] < dist[i][j]) {\n                    dist[i][j] = dist[i][k] + dist[k][j];\n                }\n            }\n        }\n    }\n    return dist;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"topological-sort-dfs",children:"Topological Sort (DFS)"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:'void topologicalSort() {\n    boolean[] visited = new boolean[V];\n    Deque<Integer> stack = new ArrayDeque<>();\n\n    for (int i = 0; i < V; i++) {\n        if (!visited[i]) {\n            topologicalSortUtil(i, visited, stack);\n        }\n    }\n\n    while (!stack.isEmpty()) {\n        System.out.print(stack.pop() + " ");\n    }\n}\n\nvoid topologicalSortUtil(int u, boolean[] visited, Deque<Integer> stack) {\n    visited[u] = true;\n\n    for (int v : adj.get(u)) {\n        if (!visited[v]) {\n            topologicalSortUtil(v, visited, stack);\n        }\n    }\n\n    stack.push(u);\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"topological-sort-kahns-algorithm---bfs",children:"Topological Sort (Kahn's Algorithm - BFS)"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:'void topologicalSortBFS() {\n    int[] indegree = new int[V];\n\n    for (int u = 0; u < V; u++) {\n        for (int v : adj.get(u)) {\n            indegree[v]++;\n        }\n    }\n\n    Queue<Integer> queue = new ArrayDeque<>();\n    for (int i = 0; i < V; i++) {\n        if (indegree[i] == 0) {\n            queue.offer(i);\n        }\n    }\n\n    while (!queue.isEmpty()) {\n        int u = queue.poll();\n        System.out.print(u + " ");\n\n        for (int v : adj.get(u)) {\n            indegree[v]--;\n            if (indegree[v] == 0) {\n                queue.offer(v);\n            }\n        }\n    }\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"detect-cycle-undirected-graph",children:"Detect Cycle (Undirected Graph)"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"boolean hasCycle() {\n    boolean[] visited = new boolean[V];\n\n    for (int i = 0; i < V; i++) {\n        if (!visited[i]) {\n            if (hasCycleUtil(i, visited, -1)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nboolean hasCycleUtil(int u, boolean[] visited, int parent) {\n    visited[u] = true;\n\n    for (int v : adj.get(u)) {\n        if (!visited[v]) {\n            if (hasCycleUtil(v, visited, u)) {\n                return true;\n            }\n        } else if (v != parent) {\n            return true;\n        }\n    }\n    return false;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"detect-cycle-directed-graph",children:"Detect Cycle (Directed Graph)"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"boolean hasCycleDirected() {\n    boolean[] visited = new boolean[V];\n    boolean[] recStack = new boolean[V];\n\n    for (int i = 0; i < V; i++) {\n        if (hasCycleDirectedUtil(i, visited, recStack)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nboolean hasCycleDirectedUtil(int u, boolean[] visited, boolean[] recStack) {\n    if (recStack[u]) return true;\n    if (visited[u]) return false;\n\n    visited[u] = true;\n    recStack[u] = true;\n\n    for (int v : adj.get(u)) {\n        if (hasCycleDirectedUtil(v, visited, recStack)) {\n            return true;\n        }\n    }\n\n    recStack[u] = false;\n    return false;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"prims-mst",children:"Prim's MST"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"int primMST() {\n    boolean[] inMST = new boolean[V];\n    int[] key = new int[V];\n    Arrays.fill(key, Integer.MAX_VALUE);\n    key[0] = 0;\n\n    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\n    pq.offer(new int[]{0, 0});\n\n    int mstWeight = 0;\n\n    while (!pq.isEmpty()) {\n        int[] curr = pq.poll();\n        int u = curr[0];\n\n        if (inMST[u]) continue;\n\n        inMST[u] = true;\n        mstWeight += curr[1];\n\n        for (int[] edge : adjWeighted.get(u)) {\n            int v = edge[0];\n            int weight = edge[1];\n\n            if (!inMST[v] && weight < key[v]) {\n                key[v] = weight;\n                pq.offer(new int[]{v, weight});\n            }\n        }\n    }\n    return mstWeight;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"kruskals-mst",children:"Kruskal's MST"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"class Edge implements Comparable<Edge> {\n    int src, dest, weight;\n\n    Edge(int s, int d, int w) {\n        src = s;\n        dest = d;\n        weight = w;\n    }\n\n    public int compareTo(Edge other) {\n        return this.weight - other.weight;\n    }\n}\n\nint kruskalMST(List<Edge> edges) {\n    Collections.sort(edges);\n\n    int[] parent = new int[V];\n    for (int i = 0; i < V; i++) parent[i] = i;\n\n    int mstWeight = 0;\n    int edgeCount = 0;\n\n    for (Edge edge : edges) {\n        int x = find(parent, edge.src);\n        int y = find(parent, edge.dest);\n\n        if (x != y) {\n            mstWeight += edge.weight;\n            union(parent, x, y);\n            edgeCount++;\n\n            if (edgeCount == V - 1) break;\n        }\n    }\n    return mstWeight;\n}\n\nint find(int[] parent, int i) {\n    if (parent[i] != i) {\n        parent[i] = find(parent, parent[i]);\n    }\n    return parent[i];\n}\n\nvoid union(int[] parent, int x, int y) {\n    parent[x] = y;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"union-find-disjoint-set",children:"Union-Find (Disjoint Set)"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"class UnionFind {\n    int[] parent;\n    int[] rank;\n\n    UnionFind(int n) {\n        parent = new int[n];\n        rank = new int[n];\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n    }\n\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]); // Path compression\n        }\n        return parent[x];\n    }\n\n    void union(int x, int y) {\n        int px = find(x);\n        int py = find(y);\n\n        if (px == py) return;\n\n        // Union by rank\n        if (rank[px] < rank[py]) {\n            parent[px] = py;\n        } else if (rank[px] > rank[py]) {\n            parent[py] = px;\n        } else {\n            parent[py] = px;\n            rank[px]++;\n        }\n    }\n\n    boolean connected(int x, int y) {\n        return find(x) == find(y);\n    }\n}\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"trees",children:"Trees"}),"\n",(0,r.jsx)(e.h3,{id:"binary-tree-node",children:"Binary Tree Node"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    TreeNode(int val) {\n        this.val = val;\n    }\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"binary-tree-traversals",children:"Binary Tree Traversals"}),"\n",(0,r.jsx)(e.h4,{id:"inorder-left-root-right",children:"Inorder (Left, Root, Right)"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:'void inorder(TreeNode root) {\n    if (root == null) return;\n    inorder(root.left);\n    System.out.print(root.val + " ");\n    inorder(root.right);\n}\n\n// Iterative\nvoid inorderIterative(TreeNode root) {\n    Deque<TreeNode> stack = new ArrayDeque<>();\n    TreeNode curr = root;\n\n    while (curr != null || !stack.isEmpty()) {\n        while (curr != null) {\n            stack.push(curr);\n            curr = curr.left;\n        }\n        curr = stack.pop();\n        System.out.print(curr.val + " ");\n        curr = curr.right;\n    }\n}\n'})}),"\n",(0,r.jsx)(e.h4,{id:"preorder-root-left-right",children:"Preorder (Root, Left, Right)"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:'void preorder(TreeNode root) {\n    if (root == null) return;\n    System.out.print(root.val + " ");\n    preorder(root.left);\n    preorder(root.right);\n}\n\n// Iterative\nvoid preorderIterative(TreeNode root) {\n    if (root == null) return;\n    Deque<TreeNode> stack = new ArrayDeque<>();\n    stack.push(root);\n\n    while (!stack.isEmpty()) {\n        TreeNode node = stack.pop();\n        System.out.print(node.val + " ");\n\n        if (node.right != null) stack.push(node.right);\n        if (node.left != null) stack.push(node.left);\n    }\n}\n'})}),"\n",(0,r.jsx)(e.h4,{id:"postorder-left-right-root",children:"Postorder (Left, Right, Root)"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:'void postorder(TreeNode root) {\n    if (root == null) return;\n    postorder(root.left);\n    postorder(root.right);\n    System.out.print(root.val + " ");\n}\n\n// Iterative (2 stacks)\nvoid postorderIterative(TreeNode root) {\n    if (root == null) return;\n    Deque<TreeNode> stack1 = new ArrayDeque<>();\n    Deque<TreeNode> stack2 = new ArrayDeque<>();\n\n    stack1.push(root);\n\n    while (!stack1.isEmpty()) {\n        TreeNode node = stack1.pop();\n        stack2.push(node);\n\n        if (node.left != null) stack1.push(node.left);\n        if (node.right != null) stack1.push(node.right);\n    }\n\n    while (!stack2.isEmpty()) {\n        System.out.print(stack2.pop().val + " ");\n    }\n}\n'})}),"\n",(0,r.jsx)(e.h4,{id:"level-order-bfs",children:"Level Order (BFS)"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:'void levelOrder(TreeNode root) {\n    if (root == null) return;\n    Queue<TreeNode> queue = new ArrayDeque<>();\n    queue.offer(root);\n\n    while (!queue.isEmpty()) {\n        TreeNode node = queue.poll();\n        System.out.print(node.val + " ");\n\n        if (node.left != null) queue.offer(node.left);\n        if (node.right != null) queue.offer(node.right);\n    }\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"binary-tree-operations",children:"Binary Tree Operations"}),"\n",(0,r.jsx)(e.h4,{id:"height-of-tree",children:"Height of Tree"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"int height(TreeNode root) {\n    if (root == null) return 0;\n    return 1 + Math.max(height(root.left), height(root.right));\n}\n"})}),"\n",(0,r.jsx)(e.h4,{id:"diameter-of-tree",children:"Diameter of Tree"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"int diameter(TreeNode root) {\n    int[] dia = new int[1];\n    diameterHelper(root, dia);\n    return dia[0];\n}\n\nint diameterHelper(TreeNode root, int[] dia) {\n    if (root == null) return 0;\n\n    int left = diameterHelper(root.left, dia);\n    int right = diameterHelper(root.right, dia);\n\n    dia[0] = Math.max(dia[0], left + right);\n\n    return 1 + Math.max(left, right);\n}\n"})}),"\n",(0,r.jsx)(e.h4,{id:"check-if-balanced",children:"Check if Balanced"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"boolean isBalanced(TreeNode root) {\n    return checkBalance(root) != -1;\n}\n\nint checkBalance(TreeNode root) {\n    if (root == null) return 0;\n\n    int left = checkBalance(root.left);\n    if (left == -1) return -1;\n\n    int right = checkBalance(root.right);\n    if (right == -1) return -1;\n\n    if (Math.abs(left - right) > 1) return -1;\n\n    return 1 + Math.max(left, right);\n}\n"})}),"\n",(0,r.jsx)(e.h4,{id:"lowest-common-ancestor",children:"Lowest Common Ancestor"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n    if (root == null || root == p || root == q) return root;\n\n    TreeNode left = lowestCommonAncestor(root.left, p, q);\n    TreeNode right = lowestCommonAncestor(root.right, p, q);\n\n    if (left != null && right != null) return root;\n    return left != null ? left : right;\n}\n"})}),"\n",(0,r.jsx)(e.h4,{id:"maximum-path-sum",children:"Maximum Path Sum"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"int maxPathSum(TreeNode root) {\n    int[] max = new int[]{Integer.MIN_VALUE};\n    maxPathSumHelper(root, max);\n    return max[0];\n}\n\nint maxPathSumHelper(TreeNode root, int[] max) {\n    if (root == null) return 0;\n\n    int left = Math.max(0, maxPathSumHelper(root.left, max));\n    int right = Math.max(0, maxPathSumHelper(root.right, max));\n\n    max[0] = Math.max(max[0], left + right + root.val);\n\n    return root.val + Math.max(left, right);\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"binary-search-tree-bst",children:"Binary Search Tree (BST)"}),"\n",(0,r.jsx)(e.h4,{id:"search-in-bst",children:"Search in BST"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"TreeNode search(TreeNode root, int val) {\n    if (root == null || root.val == val) return root;\n\n    if (val < root.val) {\n        return search(root.left, val);\n    }\n    return search(root.right, val);\n}\n"})}),"\n",(0,r.jsx)(e.h4,{id:"insert-in-bst",children:"Insert in BST"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"TreeNode insert(TreeNode root, int val) {\n    if (root == null) return new TreeNode(val);\n\n    if (val < root.val) {\n        root.left = insert(root.left, val);\n    } else {\n        root.right = insert(root.right, val);\n    }\n    return root;\n}\n"})}),"\n",(0,r.jsx)(e.h4,{id:"delete-from-bst",children:"Delete from BST"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"TreeNode delete(TreeNode root, int val) {\n    if (root == null) return null;\n\n    if (val < root.val) {\n        root.left = delete(root.left, val);\n    } else if (val > root.val) {\n        root.right = delete(root.right, val);\n    } else {\n        if (root.left == null) return root.right;\n        if (root.right == null) return root.left;\n\n        TreeNode minNode = findMin(root.right);\n        root.val = minNode.val;\n        root.right = delete(root.right, minNode.val);\n    }\n    return root;\n}\n\nTreeNode findMin(TreeNode root) {\n    while (root.left != null) root = root.left;\n    return root;\n}\n"})}),"\n",(0,r.jsx)(e.h4,{id:"validate-bst",children:"Validate BST"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"boolean isValidBST(TreeNode root) {\n    return validate(root, null, null);\n}\n\nboolean validate(TreeNode root, Integer min, Integer max) {\n    if (root == null) return true;\n\n    if ((min != null && root.val <= min) || (max != null && root.val >= max)) {\n        return false;\n    }\n\n    return validate(root.left, min, root.val) && validate(root.right, root.val, max);\n}\n"})}),"\n",(0,r.jsx)(e.h4,{id:"kth-smallest-in-bst",children:"Kth Smallest in BST"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"int kthSmallest(TreeNode root, int k) {\n    Deque<TreeNode> stack = new ArrayDeque<>();\n    TreeNode curr = root;\n\n    while (curr != null || !stack.isEmpty()) {\n        while (curr != null) {\n            stack.push(curr);\n            curr = curr.left;\n        }\n        curr = stack.pop();\n        k--;\n        if (k == 0) return curr.val;\n        curr = curr.right;\n    }\n    return -1;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"segment-tree",children:"Segment Tree"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"class SegmentTree {\n    int[] tree;\n    int n;\n\n    SegmentTree(int[] arr) {\n        n = arr.length;\n        tree = new int[4 * n];\n        build(arr, 0, 0, n - 1);\n    }\n\n    void build(int[] arr, int node, int start, int end) {\n        if (start == end) {\n            tree[node] = arr[start];\n            return;\n        }\n\n        int mid = (start + end) / 2;\n        build(arr, 2 * node + 1, start, mid);\n        build(arr, 2 * node + 2, mid + 1, end);\n        tree[node] = tree[2 * node + 1] + tree[2 * node + 2];\n    }\n\n    int query(int l, int r) {\n        return query(0, 0, n - 1, l, r);\n    }\n\n    int query(int node, int start, int end, int l, int r) {\n        if (r < start || l > end) return 0;\n        if (l <= start && end <= r) return tree[node];\n\n        int mid = (start + end) / 2;\n        return query(2 * node + 1, start, mid, l, r) +\n               query(2 * node + 2, mid + 1, end, l, r);\n    }\n\n    void update(int idx, int val) {\n        update(0, 0, n - 1, idx, val);\n    }\n\n    void update(int node, int start, int end, int idx, int val) {\n        if (start == end) {\n            tree[node] = val;\n            return;\n        }\n\n        int mid = (start + end) / 2;\n        if (idx <= mid) {\n            update(2 * node + 1, start, mid, idx, val);\n        } else {\n            update(2 * node + 2, mid + 1, end, idx, val);\n        }\n        tree[node] = tree[2 * node + 1] + tree[2 * node + 2];\n    }\n}\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"tries",children:"Tries"}),"\n",(0,r.jsx)(e.h3,{id:"trie-implementation",children:"Trie Implementation"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"class TrieNode {\n    TrieNode[] children;\n    boolean isEndOfWord;\n\n    TrieNode() {\n        children = new TrieNode[26];\n        isEndOfWord = false;\n    }\n}\n\nclass Trie {\n    TrieNode root;\n\n    Trie() {\n        root = new TrieNode();\n    }\n\n    void insert(String word) {\n        TrieNode node = root;\n\n        for (char c : word.toCharArray()) {\n            int idx = c - 'a';\n            if (node.children[idx] == null) {\n                node.children[idx] = new TrieNode();\n            }\n            node = node.children[idx];\n        }\n        node.isEndOfWord = true;\n    }\n\n    boolean search(String word) {\n        TrieNode node = root;\n\n        for (char c : word.toCharArray()) {\n            int idx = c - 'a';\n            if (node.children[idx] == null) {\n                return false;\n            }\n            node = node.children[idx];\n        }\n        return node.isEndOfWord;\n    }\n\n    boolean startsWith(String prefix) {\n        TrieNode node = root;\n\n        for (char c : prefix.toCharArray()) {\n            int idx = c - 'a';\n            if (node.children[idx] == null) {\n                return false;\n            }\n            node = node.children[idx];\n        }\n        return true;\n    }\n\n    void delete(String word) {\n        delete(root, word, 0);\n    }\n\n    boolean delete(TrieNode node, String word, int idx) {\n        if (idx == word.length()) {\n            if (!node.isEndOfWord) return false;\n            node.isEndOfWord = false;\n            return isEmpty(node);\n        }\n\n        int charIdx = word.charAt(idx) - 'a';\n        TrieNode child = node.children[charIdx];\n        if (child == null) return false;\n\n        boolean shouldDeleteChild = delete(child, word, idx + 1);\n\n        if (shouldDeleteChild) {\n            node.children[charIdx] = null;\n            return !node.isEndOfWord && isEmpty(node);\n        }\n        return false;\n    }\n\n    boolean isEmpty(TrieNode node) {\n        for (TrieNode child : node.children) {\n            if (child != null) return false;\n        }\n        return true;\n    }\n}\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"bit-manipulation",children:"Bit Manipulation"}),"\n",(0,r.jsx)(e.h3,{id:"basic-operations",children:"Basic Operations"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"// Check if kth bit is set\nboolean isSet(int n, int k) {\n    return (n & (1 << k)) != 0;\n}\n\n// Set kth bit\nint setBit(int n, int k) {\n    return n | (1 << k);\n}\n\n// Clear kth bit\nint clearBit(int n, int k) {\n    return n & ~(1 << k);\n}\n\n// Toggle kth bit\nint toggleBit(int n, int k) {\n    return n ^ (1 << k);\n}\n\n// Count set bits\nint countSetBits(int n) {\n    int count = 0;\n    while (n > 0) {\n        count += n & 1;\n        n >>= 1;\n    }\n    return count;\n}\n\n// Brian Kernighan's Algorithm (count set bits)\nint countSetBitsFast(int n) {\n    int count = 0;\n    while (n > 0) {\n        n &= (n - 1);\n        count++;\n    }\n    return count;\n}\n\n// Check if power of 2\nboolean isPowerOfTwo(int n) {\n    return n > 0 && (n & (n - 1)) == 0;\n}\n\n// Find rightmost set bit\nint rightmostSetBit(int n) {\n    return n & -n;\n}\n\n// Turn off rightmost set bit\nint turnOffRightmost(int n) {\n    return n & (n - 1);\n}\n\n// XOR of numbers from 1 to n\nint xorFrom1ToN(int n) {\n    int mod = n % 4;\n    if (mod == 0) return n;\n    if (mod == 1) return 1;\n    if (mod == 2) return n + 1;\n    return 0;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"advanced-bit-manipulation",children:"Advanced Bit Manipulation"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:'// Single number (all others appear twice)\nint singleNumber(int[] nums) {\n    int result = 0;\n    for (int num : nums) {\n        result ^= num;\n    }\n    return result;\n}\n\n// Two numbers appear once, rest twice\nint[] singleNumberII(int[] nums) {\n    int xor = 0;\n    for (int num : nums) xor ^= num;\n\n    int rightmostBit = xor & -xor;\n    int num1 = 0, num2 = 0;\n\n    for (int num : nums) {\n        if ((num & rightmostBit) != 0) {\n            num1 ^= num;\n        } else {\n            num2 ^= num;\n        }\n    }\n    return new int[]{num1, num2};\n}\n\n// Generate all subsets using bits\nvoid generateSubsets(int[] arr) {\n    int n = arr.length;\n    for (int i = 0; i < (1 << n); i++) {\n        for (int j = 0; j < n; j++) {\n            if ((i & (1 << j)) != 0) {\n                System.out.print(arr[j] + " ");\n            }\n        }\n        System.out.println();\n    }\n}\n\n// Swap two numbers without temp\nvoid swap(int a, int b) {\n    a = a ^ b;\n    b = a ^ b;\n    a = a ^ b;\n}\n'})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"math--number-theory",children:"Math & Number Theory"}),"\n",(0,r.jsx)(e.h3,{id:"gcd-and-lcm",children:"GCD and LCM"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"int gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\nint lcm(int a, int b) {\n    return (a * b) / gcd(a, b);\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"prime-numbers",children:"Prime Numbers"}),"\n",(0,r.jsx)(e.h4,{id:"check-prime",children:"Check Prime"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"boolean isPrime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n"})}),"\n",(0,r.jsx)(e.h4,{id:"sieve-of-eratosthenes",children:"Sieve of Eratosthenes"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"boolean[] sieve(int n) {\n    boolean[] isPrime = new boolean[n + 1];\n    Arrays.fill(isPrime, true);\n    isPrime[0] = isPrime[1] = false;\n\n    for (int i = 2; i * i <= n; i++) {\n        if (isPrime[i]) {\n            for (int j = i * i; j <= n; j += i) {\n                isPrime[j] = false;\n            }\n        }\n    }\n    return isPrime;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"modular-arithmetic",children:"Modular Arithmetic"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"// Modular exponentiation\nlong modPow(long base, long exp, long mod) {\n    long result = 1;\n    base %= mod;\n\n    while (exp > 0) {\n        if (exp % 2 == 1) {\n            result = (result * base) % mod;\n        }\n        base = (base * base) % mod;\n        exp /= 2;\n    }\n    return result;\n}\n\n// Modular inverse (Fermat's theorem)\nlong modInverse(long a, long mod) {\n    return modPow(a, mod - 2, mod);\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"combinatorics",children:"Combinatorics"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"// Factorial\nlong factorial(int n) {\n    long result = 1;\n    for (int i = 2; i <= n; i++) {\n        result *= i;\n    }\n    return result;\n}\n\n// nCr (Combinations)\nlong nCr(int n, int r) {\n    if (r > n) return 0;\n    if (r == 0 || r == n) return 1;\n\n    long result = 1;\n    for (int i = 0; i < r; i++) {\n        result = result * (n - i) / (i + 1);\n    }\n    return result;\n}\n\n// Pascal's Triangle for nCr\nint[][] pascalTriangle(int n) {\n    int[][] triangle = new int[n][];\n\n    for (int i = 0; i < n; i++) {\n        triangle[i] = new int[i + 1];\n        triangle[i][0] = triangle[i][i] = 1;\n\n        for (int j = 1; j < i; j++) {\n            triangle[i][j] = triangle[i - 1][j - 1] + triangle[i - 1][j];\n        }\n    }\n    return triangle;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"number-theory",children:"Number Theory"}),"\n",(0,r.jsx)(e.h4,{id:"count-digits",children:"Count Digits"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"int countDigits(int n) {\n    if (n == 0) return 1;\n    int count = 0;\n    while (n > 0) {\n        count++;\n        n /= 10;\n    }\n    return count;\n}\n"})}),"\n",(0,r.jsx)(e.h4,{id:"reverse-number",children:"Reverse Number"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"int reverse(int n) {\n    int result = 0;\n    while (n > 0) {\n        result = result * 10 + n % 10;\n        n /= 10;\n    }\n    return result;\n}\n"})}),"\n",(0,r.jsx)(e.h4,{id:"check-palindrome-number",children:"Check Palindrome Number"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"boolean isPalindrome(int n) {\n    int original = n;\n    int reversed = 0;\n\n    while (n > 0) {\n        reversed = reversed * 10 + n % 10;\n        n /= 10;\n    }\n    return original == reversed;\n}\n"})}),"\n",(0,r.jsx)(e.h4,{id:"armstrong-number",children:"Armstrong Number"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"boolean isArmstrong(int n) {\n    int original = n;\n    int sum = 0;\n    int digits = String.valueOf(n).length();\n\n    while (n > 0) {\n        int digit = n % 10;\n        sum += Math.pow(digit, digits);\n        n /= 10;\n    }\n    return sum == original;\n}\n"})}),"\n",(0,r.jsx)(e.h4,{id:"sum-of-divisors",children:"Sum of Divisors"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"int sumOfDivisors(int n) {\n    int sum = 0;\n    for (int i = 1; i * i <= n; i++) {\n        if (n % i == 0) {\n            sum += i;\n            if (i != n / i) {\n                sum += n / i;\n            }\n        }\n    }\n    return sum;\n}\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"time-complexity-quick-reference",children:"Time Complexity Quick Reference"}),"\n",(0,r.jsxs)(e.table,{children:[(0,r.jsx)(e.thead,{children:(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.th,{children:"Data Structure"}),(0,r.jsx)(e.th,{children:"Access"}),(0,r.jsx)(e.th,{children:"Search"}),(0,r.jsx)(e.th,{children:"Insert"}),(0,r.jsx)(e.th,{children:"Delete"})]})}),(0,r.jsxs)(e.tbody,{children:[(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Array"}),(0,r.jsx)(e.td,{children:"O(1)"}),(0,r.jsx)(e.td,{children:"O(n)"}),(0,r.jsx)(e.td,{children:"O(n)"}),(0,r.jsx)(e.td,{children:"O(n)"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"ArrayList"}),(0,r.jsx)(e.td,{children:"O(1)"}),(0,r.jsx)(e.td,{children:"O(n)"}),(0,r.jsx)(e.td,{children:"O(1)*"}),(0,r.jsx)(e.td,{children:"O(n)"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"LinkedList"}),(0,r.jsx)(e.td,{children:"O(n)"}),(0,r.jsx)(e.td,{children:"O(n)"}),(0,r.jsx)(e.td,{children:"O(1)"}),(0,r.jsx)(e.td,{children:"O(1)"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Stack"}),(0,r.jsx)(e.td,{children:"O(n)"}),(0,r.jsx)(e.td,{children:"O(n)"}),(0,r.jsx)(e.td,{children:"O(1)"}),(0,r.jsx)(e.td,{children:"O(1)"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Queue"}),(0,r.jsx)(e.td,{children:"O(n)"}),(0,r.jsx)(e.td,{children:"O(n)"}),(0,r.jsx)(e.td,{children:"O(1)"}),(0,r.jsx)(e.td,{children:"O(1)"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"HashMap"}),(0,r.jsx)(e.td,{children:"-"}),(0,r.jsx)(e.td,{children:"O(1)*"}),(0,r.jsx)(e.td,{children:"O(1)*"}),(0,r.jsx)(e.td,{children:"O(1)*"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"TreeMap"}),(0,r.jsx)(e.td,{children:"-"}),(0,r.jsx)(e.td,{children:"O(log n)"}),(0,r.jsx)(e.td,{children:"O(log n)"}),(0,r.jsx)(e.td,{children:"O(log n)"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"HashSet"}),(0,r.jsx)(e.td,{children:"-"}),(0,r.jsx)(e.td,{children:"O(1)*"}),(0,r.jsx)(e.td,{children:"O(1)*"}),(0,r.jsx)(e.td,{children:"O(1)*"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"TreeSet"}),(0,r.jsx)(e.td,{children:"-"}),(0,r.jsx)(e.td,{children:"O(log n)"}),(0,r.jsx)(e.td,{children:"O(log n)"}),(0,r.jsx)(e.td,{children:"O(log n)"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"PriorityQueue"}),(0,r.jsx)(e.td,{children:"-"}),(0,r.jsx)(e.td,{children:"O(n)"}),(0,r.jsx)(e.td,{children:"O(log n)"}),(0,r.jsx)(e.td,{children:"O(log n)"})]})]})]}),"\n",(0,r.jsx)(e.p,{children:"*Amortized time complexity"}),"\n",(0,r.jsx)(e.h2,{id:"sorting-algorithm-comparison",children:"Sorting Algorithm Comparison"}),"\n",(0,r.jsxs)(e.table,{children:[(0,r.jsx)(e.thead,{children:(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.th,{children:"Algorithm"}),(0,r.jsx)(e.th,{children:"Best"}),(0,r.jsx)(e.th,{children:"Average"}),(0,r.jsx)(e.th,{children:"Worst"}),(0,r.jsx)(e.th,{children:"Space"})]})}),(0,r.jsxs)(e.tbody,{children:[(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Bubble Sort"}),(0,r.jsx)(e.td,{children:"O(n)"}),(0,r.jsx)(e.td,{children:"O(n\xb2)"}),(0,r.jsx)(e.td,{children:"O(n\xb2)"}),(0,r.jsx)(e.td,{children:"O(1)"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Selection Sort"}),(0,r.jsx)(e.td,{children:"O(n\xb2)"}),(0,r.jsx)(e.td,{children:"O(n\xb2)"}),(0,r.jsx)(e.td,{children:"O(n\xb2)"}),(0,r.jsx)(e.td,{children:"O(1)"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Insertion Sort"}),(0,r.jsx)(e.td,{children:"O(n)"}),(0,r.jsx)(e.td,{children:"O(n\xb2)"}),(0,r.jsx)(e.td,{children:"O(n\xb2)"}),(0,r.jsx)(e.td,{children:"O(1)"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Merge Sort"}),(0,r.jsx)(e.td,{children:"O(n log n)"}),(0,r.jsx)(e.td,{children:"O(n log n)"}),(0,r.jsx)(e.td,{children:"O(n log n)"}),(0,r.jsx)(e.td,{children:"O(n)"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Quick Sort"}),(0,r.jsx)(e.td,{children:"O(n log n)"}),(0,r.jsx)(e.td,{children:"O(n log n)"}),(0,r.jsx)(e.td,{children:"O(n\xb2)"}),(0,r.jsx)(e.td,{children:"O(log n)"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Heap Sort"}),(0,r.jsx)(e.td,{children:"O(n log n)"}),(0,r.jsx)(e.td,{children:"O(n log n)"}),(0,r.jsx)(e.td,{children:"O(n log n)"}),(0,r.jsx)(e.td,{children:"O(1)"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Counting Sort"}),(0,r.jsx)(e.td,{children:"O(n+k)"}),(0,r.jsx)(e.td,{children:"O(n+k)"}),(0,r.jsx)(e.td,{children:"O(n+k)"}),(0,r.jsx)(e.td,{children:"O(k)"})]})]})]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"important-tips",children:"Important Tips"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"Use ArrayDeque instead of Stack and LinkedList for stack/queue operations"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"HashMap/HashSet for O(1) lookups"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"TreeMap/TreeSet when you need sorted order"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"PriorityQueue for heap operations"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"StringBuilder for string concatenation in loops"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"Arrays.sort() uses Dual-Pivot Quicksort (O(n log n) average)"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"Collections.sort() uses TimSort (O(n log n))"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"Use binary search on sorted arrays"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"Two pointers technique for sorted arrays"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"Sliding window for subarray problems"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"Use bit manipulation for space optimization"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"Dynamic Programming for overlapping subproblems"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"Backtracking for generating all possibilities"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"BFS for shortest path in unweighted graphs"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"DFS for cycle detection and topological sort"})}),"\n"]}),"\n",(0,r.jsx)(e.hr,{})]})}function u(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(c,{...n})}):c(n)}}}]);