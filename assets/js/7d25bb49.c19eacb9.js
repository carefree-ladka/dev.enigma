"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[72788],{28453:(n,t,e)=>{e.d(t,{R:()=>a,x:()=>l});var r=e(96540);const i={},s=r.createContext(i);function a(n){const t=r.useContext(s);return r.useMemo(function(){return"function"==typeof n?n(t):{...t,...n}},[t,n])}function l(n){let t;return t=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:a(n.components),r.createElement(s.Provider,{value:t},n.children)}},72947:(n,t,e)=>{e.r(t),e.d(t,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>l,toc:()=>c});var r=e(74848),i=e(28453);const s={},a="String",l={id:"DSA/DSA with Java/String Patterns",title:"String",description:"Table of Contents",source:"@site/docs/DSA/DSA with Java/String Patterns.mdx",sourceDirName:"DSA/DSA with Java",slug:"/DSA/DSA with Java/String Patterns",permalink:"/docs/DSA/DSA with Java/String Patterns",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with Java/String Patterns.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Stack",permalink:"/docs/DSA/DSA with Java/Stack Patterns"},next:{title:"Trie Patterns",permalink:"/docs/DSA/DSA with Java/Trie Patterns"}},o={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"String Fundamentals",id:"string-fundamentals",level:2},{value:"Core String Operations",id:"core-string-operations",level:3},{value:"Pattern 1: Two Pointers for Strings",id:"pattern-1-two-pointers-for-strings",level:2},{value:"1.1 Palindrome Validation[3]",id:"11-palindrome-validation3",level:3},{value:"1.2 String Comparison and Matching",id:"12-string-comparison-and-matching",level:3},{value:"Pattern 2: Sliding Window for Strings",id:"pattern-2-sliding-window-for-strings",level:2},{value:"2.1 Variable Length Sliding Window",id:"21-variable-length-sliding-window",level:3},{value:"2.2 Fixed Length Sliding Window",id:"22-fixed-length-sliding-window",level:3},{value:"Pattern 3: String Matching Algorithms",id:"pattern-3-string-matching-algorithms",level:2},{value:"3.1 KMP Algorithm",id:"31-kmp-algorithm",level:3},{value:"3.2 Rabin-Karp Algorithm",id:"32-rabin-karp-algorithm",level:3},{value:"3.3 String Matching Applications",id:"33-string-matching-applications",level:3},{value:"Pattern 4: Palindrome Problems",id:"pattern-4-palindrome-problems",level:2},{value:"4.1 Palindrome Detection and Construction",id:"41-palindrome-detection-and-construction",level:3},{value:"4.2 Advanced Palindrome Problems",id:"42-advanced-palindrome-problems",level:3},{value:"Pattern 5: Anagram &amp; Permutation",id:"pattern-5-anagram--permutation",level:2},{value:"5.1 Anagram Detection",id:"51-anagram-detection",level:3},{value:"5.2 String Permutations",id:"52-string-permutations",level:3},{value:"Pattern 6: Subsequence &amp; Substring",id:"pattern-6-subsequence--substring",level:2},{value:"6.1 Longest Common Subsequence Problems",id:"61-longest-common-subsequence-problems",level:3},{value:"6.2 Distinct Subsequences",id:"62-distinct-subsequences",level:3},{value:"Pattern 7: String Transformation",id:"pattern-7-string-transformation",level:2},{value:"7.1 Edit Distance Problems",id:"71-edit-distance-problems",level:3},{value:"7.2 String Rotation and Reversal",id:"72-string-rotation-and-reversal",level:3},{value:"Pattern 8: Parsing &amp; Validation",id:"pattern-8-parsing--validation",level:2},{value:"8.1 Number Validation",id:"81-number-validation",level:3},{value:"8.2 Expression Validation",id:"82-expression-validation",level:3},{value:"Pattern 9: Trie-based String Problems",id:"pattern-9-trie-based-string-problems",level:2},{value:"9.1 Trie Implementation",id:"91-trie-implementation",level:3},{value:"9.2 Trie Applications",id:"92-trie-applications",level:3},{value:"Pattern 10: String DP Problems",id:"pattern-10-string-dp-problems",level:2},{value:"10.1 Advanced DP on Strings",id:"101-advanced-dp-on-strings",level:3},{value:"Pattern 11: Advanced String Algorithms",id:"pattern-11-advanced-string-algorithms",level:2},{value:"11.1 Suffix Array and LCP",id:"111-suffix-array-and-lcp",level:3},{value:"11.2 Rolling Hash Applications",id:"112-rolling-hash-applications",level:3},{value:"Pattern 12: String Compression &amp; Encoding",id:"pattern-12-string-compression--encoding",level:2},{value:"12.1 String Compression",id:"121-string-compression",level:3},{value:"12.2 String Encoding Problems",id:"122-string-encoding-problems",level:3},{value:"Time &amp; Space Complexity Reference",id:"time--space-complexity-reference",level:2},{value:"Best Practices &amp; Optimization Tips",id:"best-practices--optimization-tips",level:2},{value:"String Algorithm Guidelines",id:"string-algorithm-guidelines",level:3},{value:"Common Pitfalls to Avoid",id:"common-pitfalls-to-avoid",level:3},{value:"Interview Tips[8][3]",id:"interview-tips83",level:3}];function d(n){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"string",children:"String"})}),"\n",(0,r.jsx)(t.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#string-fundamentals",children:"String Fundamentals"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#pattern-1-two-pointers-for-strings",children:"Pattern 1: Two Pointers for Strings"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#pattern-2-sliding-window-for-strings",children:"Pattern 2: Sliding Window for Strings"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#pattern-3-string-matching-algorithms",children:"Pattern 3: String Matching Algorithms"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#pattern-4-palindrome-problems",children:"Pattern 4: Palindrome Problems"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#pattern-5-anagram--permutation",children:"Pattern 5: Anagram & Permutation"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#pattern-6-subsequence--substring",children:"Pattern 6: Subsequence & Substring"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#pattern-7-string-transformation",children:"Pattern 7: String Transformation"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#pattern-8-parsing--validation",children:"Pattern 8: Parsing & Validation"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#pattern-9-trie-based-string-problems",children:"Pattern 9: Trie-based String Problems"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#pattern-10-string-dp-problems",children:"Pattern 10: String DP Problems"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#pattern-11-advanced-string-algorithms",children:"Pattern 11: Advanced String Algorithms"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"#pattern-12-string-compression--encoding",children:"Pattern 12: String Compression & Encoding"})}),"\n"]}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"string-fundamentals",children:"String Fundamentals"}),"\n",(0,r.jsx)(t.h3,{id:"core-string-operations",children:"Core String Operations"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:'// String Basics and Common Operations\nclass StringFundamentals {\n\n    // String Creation Methods\n    public static void stringCreation() {\n        // Literal (stored in string pool)\n        String s1 = "Hello";\n        String s2 = "Hello"; // s1 == s2 is true\n\n        // Constructor (creates new object)\n        String s3 = new String("Hello");\n        String s4 = new String("Hello"); // s3 == s4 is false\n\n        // From character array\n        char[] chars = {\'H\', \'e\', \'l\', \'l\', \'o\'};\n        String s5 = new String(chars);\n\n        // From StringBuilder/StringBuffer\n        StringBuilder sb = new StringBuilder("Hello");\n        String s6 = sb.toString();\n    }\n\n    // Common String Methods\n    public static void stringMethods() {\n        String str = "Hello World";\n\n        // Length and character access\n        int length = str.length();\n        char ch = str.charAt(0);\n\n        // Comparison\n        boolean equals = str.equals("hello world");       // false\n        boolean equalsIgnoreCase = str.equalsIgnoreCase("hello world"); // true\n        int comparison = str.compareTo("Hello World");    // 0\n\n        // Searching\n        int index = str.indexOf(\'o\');           // 4\n        int lastIndex = str.lastIndexOf(\'o\');   // 7\n        boolean contains = str.contains("World"); // true\n        boolean startsWith = str.startsWith("Hello"); // true\n        boolean endsWith = str.endsWith("World");     // true\n\n        // Substrings\n        String sub1 = str.substring(6);     // "World"\n        String sub2 = str.substring(0, 5);  // "Hello"\n\n        // Modification (returns new strings)\n        String upper = str.toUpperCase();   // "HELLO WORLD"\n        String lower = str.toLowerCase();   // "hello world"\n        String trimmed = str.trim();        // removes leading/trailing whitespace\n        String replaced = str.replace(\'l\', \'L\'); // "HeLLo WorLd"\n\n        // Splitting\n        String[] words = str.split(" ");    // ["Hello", "World"]\n        String[] chars = str.split("");     // ["H", "e", "l", "l", "o", " ", "W", "o", "r", "l", "d"]\n    }\n\n    // StringBuilder vs StringBuffer\n    public static void stringBuilders() {\n        // StringBuilder (not thread-safe, faster)\n        StringBuilder sb = new StringBuilder();\n        sb.append("Hello");\n        sb.append(" ");\n        sb.append("World");\n        sb.insert(5, ",");      // "Hello, World"\n        sb.delete(5, 6);        // "Hello World"\n        sb.reverse();           // "dlroW olleH"\n        String result = sb.toString();\n\n        // StringBuffer (thread-safe, slower)\n        StringBuffer sbf = new StringBuffer("Hello");\n        sbf.append(" World");\n        String result2 = sbf.toString();\n    }\n}\n\n// Custom String Utilities\nclass StringUtils {\n\n    // Convert string to character frequency map\n    public static Map<Character, Integer> getCharFrequency(String s) {\n        Map<Character, Integer> freq = new HashMap<>();\n        for (char c : s.toCharArray()) {\n            freq.put(c, freq.getOrDefault(c, 0) + 1);\n        }\n        return freq;\n    }\n\n    // Convert character array to string\n    public static String charArrayToString(char[] chars) {\n        return new String(chars);\n    }\n\n    // Reverse string\n    public static String reverse(String s) {\n        return new StringBuilder(s).reverse().toString();\n    }\n\n    // Check if string is numeric\n    public static boolean isNumeric(String s) {\n        try {\n            Double.parseDouble(s);\n            return true;\n        } catch (NumberFormatException e) {\n            return false;\n        }\n    }\n\n    // Remove all whitespaces\n    public static String removeSpaces(String s) {\n        return s.replaceAll("\\\\s+", "");\n    }\n\n    // Count words in string\n    public static int countWords(String s) {\n        if (s == null || s.trim().isEmpty()) return 0;\n        return s.trim().split("\\\\s+").length;\n    }\n}\n'})}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"pattern-1-two-pointers-for-strings",children:"Pattern 1: Two Pointers for Strings"}),"\n",(0,r.jsx)(t.h3,{id:"11-palindrome-validation3",children:"1.1 Palindrome Validation[3]"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:'// Valid Palindrome\npublic boolean isPalindrome(String s) {\n    int left = 0, right = s.length() - 1;\n\n    while (left < right) {\n        // Skip non-alphanumeric characters\n        while (left < right && !Character.isLetterOrDigit(s.charAt(left))) {\n            left++;\n        }\n        while (left < right && !Character.isLetterOrDigit(s.charAt(right))) {\n            right--;\n        }\n\n        // Compare characters (case insensitive)\n        if (Character.toLowerCase(s.charAt(left)) !=\n            Character.toLowerCase(s.charAt(right))) {\n            return false;\n        }\n\n        left++;\n        right--;\n    }\n\n    return true;\n}\n\n// Valid Palindrome II (Remove at most one character)\npublic boolean validPalindrome(String s) {\n    int left = 0, right = s.length() - 1;\n\n    while (left < right) {\n        if (s.charAt(left) != s.charAt(right)) {\n            // Try removing left character or right character\n            return isPalindromeRange(s, left + 1, right) ||\n                   isPalindromeRange(s, left, right - 1);\n        }\n        left++;\n        right--;\n    }\n\n    return true;\n}\n\nprivate boolean isPalindromeRange(String s, int left, int right) {\n    while (left < right) {\n        if (s.charAt(left) != s.charAt(right)) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n\n// Longest Palindromic Substring (Expand Around Centers)\npublic String longestPalindrome(String s) {\n    if (s == null || s.length() < 1) return "";\n\n    int start = 0, end = 0;\n\n    for (int i = 0; i < s.length(); i++) {\n        // Check for odd length palindromes (center at i)\n        int len1 = expandAroundCenter(s, i, i);\n        // Check for even length palindromes (center between i and i+1)\n        int len2 = expandAroundCenter(s, i, i + 1);\n\n        int maxLen = Math.max(len1, len2);\n        if (maxLen > end - start) {\n            start = i - (maxLen - 1) / 2;\n            end = i + maxLen / 2;\n        }\n    }\n\n    return s.substring(start, end + 1);\n}\n\nprivate int expandAroundCenter(String s, int left, int right) {\n    while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\n        left--;\n        right++;\n    }\n    return right - left - 1;\n}\n'})}),"\n",(0,r.jsx)(t.h3,{id:"12-string-comparison-and-matching",children:"1.2 String Comparison and Matching"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:'// Compare Version Numbers\npublic int compareVersion(String version1, String version2) {\n    String[] v1Parts = version1.split("\\\\.");\n    String[] v2Parts = version2.split("\\\\.");\n\n    int i = 0, j = 0;\n    while (i < v1Parts.length || j < v2Parts.length) {\n        int num1 = i < v1Parts.length ? Integer.parseInt(v1Parts[i]) : 0;\n        int num2 = j < v2Parts.length ? Integer.parseInt(v2Parts[j]) : 0;\n\n        if (num1 < num2) return -1;\n        if (num1 > num2) return 1;\n\n        i++;\n        j++;\n    }\n\n    return 0;\n}\n\n// Is Subsequence\npublic boolean isSubsequence(String s, String t) {\n    int i = 0, j = 0;\n\n    while (i < s.length() && j < t.length()) {\n        if (s.charAt(i) == t.charAt(j)) {\n            i++;\n        }\n        j++;\n    }\n\n    return i == s.length();\n}\n\n// Merge Strings Alternately\npublic String mergeAlternately(String word1, String word2) {\n    StringBuilder result = new StringBuilder();\n    int i = 0, j = 0;\n\n    while (i < word1.length() && j < word2.length()) {\n        result.append(word1.charAt(i++));\n        result.append(word2.charAt(j++));\n    }\n\n    // Append remaining characters\n    while (i < word1.length()) {\n        result.append(word1.charAt(i++));\n    }\n    while (j < word2.length()) {\n        result.append(word2.charAt(j++));\n    }\n\n    return result.toString();\n}\n'})}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"pattern-2-sliding-window-for-strings",children:"Pattern 2: Sliding Window for Strings"}),"\n",(0,r.jsx)(t.h3,{id:"21-variable-length-sliding-window",children:"2.1 Variable Length Sliding Window"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:'// Longest Substring Without Repeating Characters\npublic int lengthOfLongestSubstring(String s) {\n    Set<Character> window = new HashSet<>();\n    int left = 0, maxLength = 0;\n\n    for (int right = 0; right < s.length(); right++) {\n        // Shrink window until no duplicates\n        while (window.contains(s.charAt(right))) {\n            window.remove(s.charAt(left));\n            left++;\n        }\n\n        window.add(s.charAt(right));\n        maxLength = Math.max(maxLength, right - left + 1);\n    }\n\n    return maxLength;\n}\n\n// Longest Substring with At Most K Distinct Characters\npublic int lengthOfLongestSubstringKDistinct(String s, int k) {\n    if (k == 0) return 0;\n\n    Map<Character, Integer> charCount = new HashMap<>();\n    int left = 0, maxLength = 0;\n\n    for (int right = 0; right < s.length(); right++) {\n        char rightChar = s.charAt(right);\n        charCount.put(rightChar, charCount.getOrDefault(rightChar, 0) + 1);\n\n        // Shrink window if more than k distinct characters\n        while (charCount.size() > k) {\n            char leftChar = s.charAt(left);\n            charCount.put(leftChar, charCount.get(leftChar) - 1);\n            if (charCount.get(leftChar) == 0) {\n                charCount.remove(leftChar);\n            }\n            left++;\n        }\n\n        maxLength = Math.max(maxLength, right - left + 1);\n    }\n\n    return maxLength;\n}\n\n// Minimum Window Substring\npublic String minWindow(String s, String t) {\n    if (s.length() < t.length()) return "";\n\n    Map<Character, Integer> targetCount = new HashMap<>();\n    for (char c : t.toCharArray()) {\n        targetCount.put(c, targetCount.getOrDefault(c, 0) + 1);\n    }\n\n    Map<Character, Integer> windowCount = new HashMap<>();\n    int left = 0, formed = 0;\n    int minLength = Integer.MAX_VALUE, minStart = 0;\n    int required = targetCount.size();\n\n    for (int right = 0; right < s.length(); right++) {\n        char rightChar = s.charAt(right);\n        windowCount.put(rightChar, windowCount.getOrDefault(rightChar, 0) + 1);\n\n        if (targetCount.containsKey(rightChar) &&\n            windowCount.get(rightChar).intValue() == targetCount.get(rightChar).intValue()) {\n            formed++;\n        }\n\n        // Shrink window while it\'s valid\n        while (left <= right && formed == required) {\n            if (right - left + 1 < minLength) {\n                minLength = right - left + 1;\n                minStart = left;\n            }\n\n            char leftChar = s.charAt(left);\n            windowCount.put(leftChar, windowCount.get(leftChar) - 1);\n            if (targetCount.containsKey(leftChar) &&\n                windowCount.get(leftChar) < targetCount.get(leftChar)) {\n                formed--;\n            }\n            left++;\n        }\n    }\n\n    return minLength == Integer.MAX_VALUE ? "" : s.substring(minStart, minStart + minLength);\n}\n'})}),"\n",(0,r.jsx)(t.h3,{id:"22-fixed-length-sliding-window",children:"2.2 Fixed Length Sliding Window"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:"// Find All Anagrams in a String\npublic List<Integer> findAnagrams(String s, String p) {\n    List<Integer> result = new ArrayList<>();\n    if (s.length() < p.length()) return result;\n\n    Map<Character, Integer> pCount = new HashMap<>();\n    Map<Character, Integer> windowCount = new HashMap<>();\n\n    // Count characters in pattern\n    for (char c : p.toCharArray()) {\n        pCount.put(c, pCount.getOrDefault(c, 0) + 1);\n    }\n\n    int windowSize = p.length();\n\n    // Process first window\n    for (int i = 0; i < windowSize; i++) {\n        char c = s.charAt(i);\n        windowCount.put(c, windowCount.getOrDefault(c, 0) + 1);\n    }\n\n    if (windowCount.equals(pCount)) {\n        result.add(0);\n    }\n\n    // Slide the window\n    for (int i = windowSize; i < s.length(); i++) {\n        // Add new character\n        char newChar = s.charAt(i);\n        windowCount.put(newChar, windowCount.getOrDefault(newChar, 0) + 1);\n\n        // Remove old character\n        char oldChar = s.charAt(i - windowSize);\n        windowCount.put(oldChar, windowCount.get(oldChar) - 1);\n        if (windowCount.get(oldChar) == 0) {\n            windowCount.remove(oldChar);\n        }\n\n        // Check if current window is anagram\n        if (windowCount.equals(pCount)) {\n            result.add(i - windowSize + 1);\n        }\n    }\n\n    return result;\n}\n\n// Permutation in String\npublic boolean checkInclusion(String s1, String s2) {\n    if (s1.length() > s2.length()) return false;\n\n    Map<Character, Integer> s1Count = new HashMap<>();\n    Map<Character, Integer> windowCount = new HashMap<>();\n\n    for (char c : s1.toCharArray()) {\n        s1Count.put(c, s1Count.getOrDefault(c, 0) + 1);\n    }\n\n    int windowSize = s1.length();\n\n    // Process first window\n    for (int i = 0; i < windowSize; i++) {\n        char c = s2.charAt(i);\n        windowCount.put(c, windowCount.getOrDefault(c, 0) + 1);\n    }\n\n    if (windowCount.equals(s1Count)) return true;\n\n    // Slide the window\n    for (int i = windowSize; i < s2.length(); i++) {\n        // Add new character\n        char newChar = s2.charAt(i);\n        windowCount.put(newChar, windowCount.getOrDefault(newChar, 0) + 1);\n\n        // Remove old character\n        char oldChar = s2.charAt(i - windowSize);\n        windowCount.put(oldChar, windowCount.get(oldChar) - 1);\n        if (windowCount.get(oldChar) == 0) {\n            windowCount.remove(oldChar);\n        }\n\n        if (windowCount.equals(s1Count)) return true;\n    }\n\n    return false;\n}\n"})}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"pattern-3-string-matching-algorithms",children:"Pattern 3: String Matching Algorithms"}),"\n",(0,r.jsx)(t.h3,{id:"31-kmp-algorithm",children:"3.1 KMP Algorithm"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:"// KMP Pattern Matching Algorithm\npublic class KMPAlgorithm {\n\n    // Find all occurrences of pattern in text\n    public List<Integer> KMPSearch(String text, String pattern) {\n        List<Integer> matches = new ArrayList<>();\n        if (pattern.isEmpty()) return matches;\n\n        int[] lps = computeLPSArray(pattern);\n        int textIndex = 0, patternIndex = 0;\n\n        while (textIndex < text.length()) {\n            if (text.charAt(textIndex) == pattern.charAt(patternIndex)) {\n                textIndex++;\n                patternIndex++;\n            }\n\n            if (patternIndex == pattern.length()) {\n                matches.add(textIndex - patternIndex);\n                patternIndex = lps[patternIndex - 1];\n            } else if (textIndex < text.length() &&\n                      text.charAt(textIndex) != pattern.charAt(patternIndex)) {\n                if (patternIndex != 0) {\n                    patternIndex = lps[patternIndex - 1];\n                } else {\n                    textIndex++;\n                }\n            }\n        }\n\n        return matches;\n    }\n\n    // Compute Longest Prefix Suffix (LPS) array\n    private int[] computeLPSArray(String pattern) {\n        int[] lps = new int[pattern.length()];\n        int length = 0; // Length of previous longest prefix suffix\n        int i = 1;\n\n        lps[0] = 0; // lps[0] is always 0\n\n        while (i < pattern.length()) {\n            if (pattern.charAt(i) == pattern.charAt(length)) {\n                length++;\n                lps[i] = length;\n                i++;\n            } else {\n                if (length != 0) {\n                    length = lps[length - 1];\n                } else {\n                    lps[i] = 0;\n                    i++;\n                }\n            }\n        }\n\n        return lps;\n    }\n\n    // Check if string contains pattern\n    public boolean contains(String text, String pattern) {\n        return !KMPSearch(text, pattern).isEmpty();\n    }\n\n    // Find first occurrence of pattern in text\n    public int indexOf(String text, String pattern) {\n        List<Integer> matches = KMPSearch(text, pattern);\n        return matches.isEmpty() ? -1 : matches.get(0);\n    }\n}\n"})}),"\n",(0,r.jsx)(t.h3,{id:"32-rabin-karp-algorithm",children:"3.2 Rabin-Karp Algorithm"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:"// Rabin-Karp Pattern Matching Algorithm\npublic class RabinKarpAlgorithm {\n    private static final int PRIME = 101;\n\n    public List<Integer> search(String text, String pattern) {\n        List<Integer> matches = new ArrayList<>();\n        int patternLength = pattern.length();\n        int textLength = text.length();\n\n        if (patternLength > textLength) return matches;\n\n        // Calculate hash values\n        long patternHash = calculateHash(pattern, patternLength);\n        long textHash = calculateHash(text, patternLength);\n\n        // Slide the pattern over text\n        for (int i = 0; i <= textLength - patternLength; i++) {\n            // Check if hash values match\n            if (patternHash == textHash) {\n                // Hash values match, check actual characters\n                if (text.substring(i, i + patternLength).equals(pattern)) {\n                    matches.add(i);\n                }\n            }\n\n            // Calculate hash for next window\n            if (i < textLength - patternLength) {\n                textHash = recalculateHash(text, i, i + patternLength, textHash, patternLength);\n            }\n        }\n\n        return matches;\n    }\n\n    private long calculateHash(String str, int length) {\n        long hash = 0;\n        for (int i = 0; i < length; i++) {\n            hash += str.charAt(i) * Math.pow(PRIME, i);\n        }\n        return hash;\n    }\n\n    private long recalculateHash(String str, int oldIndex, int newIndex,\n                                long oldHash, int patternLength) {\n        long newHash = oldHash - str.charAt(oldIndex);\n        newHash = newHash / PRIME;\n        newHash += str.charAt(newIndex) * Math.pow(PRIME, patternLength - 1);\n        return newHash;\n    }\n}\n"})}),"\n",(0,r.jsx)(t.h3,{id:"33-string-matching-applications",children:"3.3 String Matching Applications"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:"// Repeated Substring Pattern\npublic boolean repeatedSubstringPattern(String s) {\n    String doubled = s + s;\n    return doubled.substring(1, doubled.length() - 1).contains(s);\n}\n\n// Implement strStr() (indexOf)\npublic int strStr(String haystack, String needle) {\n    if (needle.isEmpty()) return 0;\n    if (haystack.length() < needle.length()) return -1;\n\n    KMPAlgorithm kmp = new KMPAlgorithm();\n    return kmp.indexOf(haystack, needle);\n}\n\n// Find All Occurrences of Pattern\npublic List<Integer> findAllOccurrences(String text, String pattern) {\n    KMPAlgorithm kmp = new KMPAlgorithm();\n    return kmp.KMPSearch(text, pattern);\n}\n"})}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"pattern-4-palindrome-problems",children:"Pattern 4: Palindrome Problems"}),"\n",(0,r.jsx)(t.h3,{id:"41-palindrome-detection-and-construction",children:"4.1 Palindrome Detection and Construction"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:"// Palindromic Substrings Count\npublic int countSubstrings(String s) {\n    int count = 0;\n\n    for (int i = 0; i < s.length(); i++) {\n        // Odd length palindromes (center at i)\n        count += expandAroundCenter(s, i, i);\n        // Even length palindromes (center between i and i+1)\n        count += expandAroundCenter(s, i, i + 1);\n    }\n\n    return count;\n}\n\nprivate int expandAroundCenter(String s, int left, int right) {\n    int count = 0;\n    while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\n        count++;\n        left--;\n        right++;\n    }\n    return count;\n}\n\n// Shortest Palindrome (Add characters to front)\npublic String shortestPalindrome(String s) {\n    String reversed = new StringBuilder(s).reverse().toString();\n\n    // Find the longest prefix of s that is also suffix of reversed\n    for (int i = 0; i < s.length(); i++) {\n        if (s.startsWith(reversed.substring(i))) {\n            return reversed.substring(0, i) + s;\n        }\n    }\n\n    return reversed + s;\n}\n\n// Palindrome Partitioning\npublic List<List<String>> partition(String s) {\n    List<List<String>> result = new ArrayList<>();\n    List<String> currentPartition = new ArrayList<>();\n    backtrackPartition(s, 0, currentPartition, result);\n    return result;\n}\n\nprivate void backtrackPartition(String s, int start, List<String> currentPartition,\n                               List<List<String>> result) {\n    if (start >= s.length()) {\n        result.add(new ArrayList<>(currentPartition));\n        return;\n    }\n\n    for (int end = start; end < s.length(); end++) {\n        if (isPalindrome(s, start, end)) {\n            currentPartition.add(s.substring(start, end + 1));\n            backtrackPartition(s, end + 1, currentPartition, result);\n            currentPartition.remove(currentPartition.size() - 1);\n        }\n    }\n}\n\nprivate boolean isPalindrome(String s, int left, int right) {\n    while (left < right) {\n        if (s.charAt(left) != s.charAt(right)) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n"})}),"\n",(0,r.jsx)(t.h3,{id:"42-advanced-palindrome-problems",children:"4.2 Advanced Palindrome Problems"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:"// Minimum Cuts for Palindrome Partitioning\npublic int minCut(String s) {\n    int n = s.length();\n    boolean[][] isPalindrome = new boolean[n][n];\n    int[] cuts = new int[n];\n\n    // Precompute palindrome information\n    for (int i = 0; i < n; i++) {\n        int minCuts = i; // Maximum cuts needed\n\n        for (int j = 0; j <= i; j++) {\n            if (s.charAt(j) == s.charAt(i) && (i - j < 2 || isPalindrome[j + 1][i - 1])) {\n                isPalindrome[j][i] = true;\n                minCuts = (j == 0) ? 0 : Math.min(minCuts, cuts[j - 1] + 1);\n            }\n        }\n\n        cuts[i] = minCuts;\n    }\n\n    return cuts[n - 1];\n}\n\n// Longest Palindromic Subsequence\npublic int longestPalindromeSubseq(String s) {\n    int n = s.length();\n    int[][] dp = new int[n][n];\n\n    // Single characters are palindromes of length 1\n    for (int i = 0; i < n; i++) {\n        dp[i][i] = 1;\n    }\n\n    // Fill dp table\n    for (int len = 2; len <= n; len++) {\n        for (int i = 0; i <= n - len; i++) {\n            int j = i + len - 1;\n\n            if (s.charAt(i) == s.charAt(j)) {\n                dp[i][j] = dp[i + 1][j - 1] + 2;\n            } else {\n                dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n\n    return dp[0][n - 1];\n}\n"})}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"pattern-5-anagram--permutation",children:"Pattern 5: Anagram & Permutation"}),"\n",(0,r.jsx)(t.h3,{id:"51-anagram-detection",children:"5.1 Anagram Detection"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:"// Valid Anagram\npublic boolean isAnagram(String s, String t) {\n    if (s.length() != t.length()) return false;\n\n    Map<Character, Integer> charCount = new HashMap<>();\n\n    // Count characters in first string\n    for (char c : s.toCharArray()) {\n        charCount.put(c, charCount.getOrDefault(c, 0) + 1);\n    }\n\n    // Decrement count for second string\n    for (char c : t.toCharArray()) {\n        charCount.put(c, charCount.getOrDefault(c, 0) - 1);\n        if (charCount.get(c) == 0) {\n            charCount.remove(c);\n        }\n    }\n\n    return charCount.isEmpty();\n}\n\n// Group Anagrams\npublic List<List<String>> groupAnagrams(String[] strs) {\n    Map<String, List<String>> groups = new HashMap<>();\n\n    for (String str : strs) {\n        // Create signature by sorting characters\n        char[] chars = str.toCharArray();\n        Arrays.sort(chars);\n        String signature = new String(chars);\n\n        groups.computeIfAbsent(signature, k -> new ArrayList<>()).add(str);\n    }\n\n    return new ArrayList<>(groups.values());\n}\n\n// Group Anagrams (Alternative using character frequency)\npublic List<List<String>> groupAnagramsFrequency(String[] strs) {\n    Map<String, List<String>> groups = new HashMap<>();\n\n    for (String str : strs) {\n        String signature = getFrequencySignature(str);\n        groups.computeIfAbsent(signature, k -> new ArrayList<>()).add(str);\n    }\n\n    return new ArrayList<>(groups.values());\n}\n\nprivate String getFrequencySignature(String str) {\n    int[] count = new int[26];\n    for (char c : str.toCharArray()) {\n        count[c - 'a']++;\n    }\n\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < 26; i++) {\n        if (count[i] > 0) {\n            sb.append((char) ('a' + i)).append(count[i]);\n        }\n    }\n\n    return sb.toString();\n}\n"})}),"\n",(0,r.jsx)(t.h3,{id:"52-string-permutations",children:"5.2 String Permutations"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:"// Generate All Permutations\npublic List<String> generatePermutations(String s) {\n    List<String> result = new ArrayList<>();\n    char[] chars = s.toCharArray();\n    Arrays.sort(chars); // Sort to handle duplicates\n    boolean[] used = new boolean[chars.length];\n\n    backtrackPermutations(chars, used, new StringBuilder(), result);\n    return result;\n}\n\nprivate void backtrackPermutations(char[] chars, boolean[] used,\n                                  StringBuilder current, List<String> result) {\n    if (current.length() == chars.length) {\n        result.add(current.toString());\n        return;\n    }\n\n    for (int i = 0; i < chars.length; i++) {\n        if (used[i]) continue;\n\n        // Skip duplicates: if current char is same as previous and previous is not used\n        if (i > 0 && chars[i] == chars[i - 1] && !used[i - 1]) continue;\n\n        used[i] = true;\n        current.append(chars[i]);\n        backtrackPermutations(chars, used, current, result);\n        current.deleteCharAt(current.length() - 1);\n        used[i] = false;\n    }\n}\n\n// Next Permutation for String\npublic String nextPermutation(String s) {\n    char[] chars = s.toCharArray();\n    int i = chars.length - 2;\n\n    // Find first decreasing element from right\n    while (i >= 0 && chars[i] >= chars[i + 1]) {\n        i--;\n    }\n\n    if (i == -1) {\n        // String is in descending order, return smallest permutation\n        Arrays.sort(chars);\n        return new String(chars);\n    }\n\n    // Find smallest character on right side of chars[i] that is greater than chars[i]\n    int j = chars.length - 1;\n    while (chars[j] <= chars[i]) {\n        j--;\n    }\n\n    // Swap chars[i] and chars[j]\n    swap(chars, i, j);\n\n    // Reverse suffix starting at i + 1\n    reverse(chars, i + 1, chars.length - 1);\n\n    return new String(chars);\n}\n\nprivate void swap(char[] chars, int i, int j) {\n    char temp = chars[i];\n    chars[i] = chars[j];\n    chars[j] = temp;\n}\n\nprivate void reverse(char[] chars, int start, int end) {\n    while (start < end) {\n        swap(chars, start++, end--);\n    }\n}\n"})}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"pattern-6-subsequence--substring",children:"Pattern 6: Subsequence & Substring"}),"\n",(0,r.jsx)(t.h3,{id:"61-longest-common-subsequence-problems",children:"6.1 Longest Common Subsequence Problems"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:"// Longest Common Subsequence\npublic int longestCommonSubsequence(String text1, String text2) {\n    int m = text1.length(), n = text2.length();\n    int[][] dp = new int[m + 1][n + 1];\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (text1.charAt(i - 1) == text2.charAt(j - 1)) {\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            } else {\n                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n\n// Longest Common Substring\npublic int longestCommonSubstring(String text1, String text2) {\n    int m = text1.length(), n = text2.length();\n    int[][] dp = new int[m + 1][n + 1];\n    int maxLength = 0;\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (text1.charAt(i - 1) == text2.charAt(j - 1)) {\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n                maxLength = Math.max(maxLength, dp[i][j]);\n            } else {\n                dp[i][j] = 0;\n            }\n        }\n    }\n\n    return maxLength;\n}\n\n// Longest Increasing Subsequence (String version)\npublic int lengthOfLIS(String s) {\n    if (s.isEmpty()) return 0;\n\n    List<Character> tails = new ArrayList<>();\n\n    for (char c : s.toCharArray()) {\n        int pos = Collections.binarySearch(tails, c);\n        if (pos < 0) pos = -(pos + 1);\n\n        if (pos == tails.size()) {\n            tails.add(c);\n        } else {\n            tails.set(pos, c);\n        }\n    }\n\n    return tails.size();\n}\n"})}),"\n",(0,r.jsx)(t.h3,{id:"62-distinct-subsequences",children:"6.2 Distinct Subsequences"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:"// Distinct Subsequences\npublic int numDistinct(String s, String t) {\n    int m = s.length(), n = t.length();\n    int[][] dp = new int[m + 1][n + 1];\n\n    // Empty string t can be formed in 1 way from any string s\n    for (int i = 0; i <= m; i++) {\n        dp[i][0] = 1;\n    }\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            // Don't use current character of s\n            dp[i][j] = dp[i - 1][j];\n\n            // Use current character of s if it matches\n            if (s.charAt(i - 1) == t.charAt(j - 1)) {\n                dp[i][j] += dp[i - 1][j - 1];\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n\n// Number of Distinct Subsequences II\npublic int distinctSubseqII(String s) {\n    int MOD = 1000000007;\n    int[] dp = new int[26]; // dp[i] = number of distinct subsequences ending with character i\n\n    for (char c : s.toCharArray()) {\n        int index = c - 'a';\n        int newCount = 1; // The character itself\n\n        // Add all existing subsequences + this character\n        for (int count : dp) {\n            newCount = (newCount + count) % MOD;\n        }\n\n        dp[index] = newCount;\n    }\n\n    int result = 0;\n    for (int count : dp) {\n        result = (result + count) % MOD;\n    }\n\n    return result;\n}\n"})}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"pattern-7-string-transformation",children:"Pattern 7: String Transformation"}),"\n",(0,r.jsx)(t.h3,{id:"71-edit-distance-problems",children:"7.1 Edit Distance Problems"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:"// Edit Distance (Levenshtein Distance)\npublic int minDistance(String word1, String word2) {\n    int m = word1.length(), n = word2.length();\n    int[][] dp = new int[m + 1][n + 1];\n\n    // Base cases\n    for (int i = 0; i <= m; i++) dp[i][0] = i;\n    for (int j = 0; j <= n; j++) dp[0][j] = j;\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (word1.charAt(i - 1) == word2.charAt(j - 1)) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = 1 + Math.min(\n                    Math.min(dp[i - 1][j],     // Delete\n                            dp[i][j - 1]),     // Insert\n                    dp[i - 1][j - 1]           // Replace\n                );\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n\n// One Edit Distance\npublic boolean isOneEditDistance(String s, String t) {\n    int m = s.length(), n = t.length();\n\n    // Ensure s is shorter than t\n    if (m > n) {\n        return isOneEditDistance(t, s);\n    }\n\n    if (n - m > 1) return false;\n\n    for (int i = 0; i < m; i++) {\n        if (s.charAt(i) != t.charAt(i)) {\n            if (m == n) {\n                // Replace: check if rest of strings are same\n                return s.substring(i + 1).equals(t.substring(i + 1));\n            } else {\n                // Insert: check if s[i:] equals t[i+1:]\n                return s.substring(i).equals(t.substring(i + 1));\n            }\n        }\n    }\n\n    // All characters match, check if we need one insertion\n    return m + 1 == n;\n}\n\n// Delete Operation for Two Strings\npublic int minDeleteOperations(String word1, String word2) {\n    int lcs = longestCommonSubsequence(word1, word2);\n    return word1.length() + word2.length() - 2 * lcs;\n}\n"})}),"\n",(0,r.jsx)(t.h3,{id:"72-string-rotation-and-reversal",children:"7.2 String Rotation and Reversal"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:'// Rotate String\npublic boolean rotateString(String s, String goal) {\n    return s.length() == goal.length() && (s + s).contains(goal);\n}\n\n// Reverse Words in String\npublic String reverseWords(String s) {\n    String[] words = s.trim().split("\\\\s+");\n    StringBuilder result = new StringBuilder();\n\n    for (int i = words.length - 1; i >= 0; i--) {\n        result.append(words[i]);\n        if (i > 0) result.append(" ");\n    }\n\n    return result.toString();\n}\n\n// Reverse Words in String III\npublic String reverseWordsInPlace(String s) {\n    char[] chars = s.toCharArray();\n    int start = 0;\n\n    for (int end = 0; end <= chars.length; end++) {\n        if (end == chars.length || chars[end] == \' \') {\n            reverse(chars, start, end - 1);\n            start = end + 1;\n        }\n    }\n\n    return new String(chars);\n}\n\nprivate void reverse(char[] chars, int start, int end) {\n    while (start < end) {\n        char temp = chars[start];\n        chars[start] = chars[end];\n        chars[end] = temp;\n        start++;\n        end--;\n    }\n}\n'})}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"pattern-8-parsing--validation",children:"Pattern 8: Parsing & Validation"}),"\n",(0,r.jsx)(t.h3,{id:"81-number-validation",children:"8.1 Number Validation"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:"// Valid Number\npublic boolean isNumber(String s) {\n    s = s.trim();\n    boolean numberSeen = false;\n    boolean pointSeen = false;\n    boolean eSeen = false;\n    boolean numberAfterE = true;\n\n    for (int i = 0; i < s.length(); i++) {\n        char c = s.charAt(i);\n\n        if (Character.isDigit(c)) {\n            numberSeen = true;\n            numberAfterE = true;\n        } else if (c == '.') {\n            if (eSeen || pointSeen) return false;\n            pointSeen = true;\n        } else if (c == 'e' || c == 'E') {\n            if (eSeen || !numberSeen) return false;\n            numberAfterE = false;\n            eSeen = true;\n        } else if (c == '-' || c == '+') {\n            if (i != 0 && s.charAt(i - 1) != 'e' && s.charAt(i - 1) != 'E') {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n\n    return numberSeen && numberAfterE;\n}\n\n// String to Integer (atoi)\npublic int myAtoi(String s) {\n    int i = 0, n = s.length();\n\n    // Skip whitespaces\n    while (i < n && s.charAt(i) == ' ') i++;\n\n    if (i >= n) return 0;\n\n    // Handle sign\n    int sign = 1;\n    if (s.charAt(i) == '-' || s.charAt(i) == '+') {\n        sign = s.charAt(i) == '-' ? -1 : 1;\n        i++;\n    }\n\n    // Read number\n    int result = 0;\n    while (i < n && Character.isDigit(s.charAt(i))) {\n        int digit = s.charAt(i) - '0';\n\n        // Check overflow\n        if (result > Integer.MAX_VALUE / 10 ||\n            (result == Integer.MAX_VALUE / 10 && digit > Integer.MAX_VALUE % 10)) {\n            return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n        }\n\n        result = result * 10 + digit;\n        i++;\n    }\n\n    return sign * result;\n}\n"})}),"\n",(0,r.jsx)(t.h3,{id:"82-expression-validation",children:"8.2 Expression Validation"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:"// Valid Parentheses\npublic boolean isValid(String s) {\n    Stack<Character> stack = new Stack<>();\n\n    for (char c : s.toCharArray()) {\n        if (c == '(' || c == '[' || c == '{') {\n            stack.push(c);\n        } else {\n            if (stack.isEmpty()) return false;\n\n            char top = stack.pop();\n            if ((c == ')' && top != '(') ||\n                (c == ']' && top != '[') ||\n                (c == '}' && top != '{')) {\n                return false;\n            }\n        }\n    }\n\n    return stack.isEmpty();\n}\n\n// Remove Invalid Parentheses\npublic List<String> removeInvalidParentheses(String s) {\n    Set<String> visited = new HashSet<>();\n    Queue<String> queue = new LinkedList<>();\n    List<String> result = new ArrayList<>();\n\n    queue.offer(s);\n    visited.add(s);\n    boolean found = false;\n\n    while (!queue.isEmpty()) {\n        String current = queue.poll();\n\n        if (isValidParentheses(current)) {\n            result.add(current);\n            found = true;\n        }\n\n        if (found) continue; // Only find minimum removals\n\n        // Generate all possible strings by removing one parenthesis\n        for (int i = 0; i < current.length(); i++) {\n            if (current.charAt(i) != '(' && current.charAt(i) != ')') continue;\n\n            String next = current.substring(0, i) + current.substring(i + 1);\n            if (!visited.contains(next)) {\n                visited.add(next);\n                queue.offer(next);\n            }\n        }\n    }\n\n    return result;\n}\n\nprivate boolean isValidParentheses(String s) {\n    int count = 0;\n    for (char c : s.toCharArray()) {\n        if (c == '(') count++;\n        else if (c == ')') {\n            count--;\n            if (count < 0) return false;\n        }\n    }\n    return count == 0;\n}\n"})}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"pattern-9-trie-based-string-problems",children:"Pattern 9: Trie-based String Problems"}),"\n",(0,r.jsx)(t.h3,{id:"91-trie-implementation",children:"9.1 Trie Implementation"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:"// Trie Data Structure\nclass Trie {\n    private TrieNode root;\n\n    class TrieNode {\n        Map<Character, TrieNode> children;\n        boolean isEndOfWord;\n\n        TrieNode() {\n            children = new HashMap<>();\n            isEndOfWord = false;\n        }\n    }\n\n    public Trie() {\n        root = new TrieNode();\n    }\n\n    public void insert(String word) {\n        TrieNode current = root;\n\n        for (char c : word.toCharArray()) {\n            current.children.putIfAbsent(c, new TrieNode());\n            current = current.children.get(c);\n        }\n\n        current.isEndOfWord = true;\n    }\n\n    public boolean search(String word) {\n        TrieNode current = root;\n\n        for (char c : word.toCharArray()) {\n            if (!current.children.containsKey(c)) {\n                return false;\n            }\n            current = current.children.get(c);\n        }\n\n        return current.isEndOfWord;\n    }\n\n    public boolean startsWith(String prefix) {\n        TrieNode current = root;\n\n        for (char c : prefix.toCharArray()) {\n            if (!current.children.containsKey(c)) {\n                return false;\n            }\n            current = current.children.get(c);\n        }\n\n        return true;\n    }\n\n    // Get all words with given prefix\n    public List<String> getWordsWithPrefix(String prefix) {\n        List<String> result = new ArrayList<>();\n        TrieNode prefixNode = root;\n\n        // Navigate to prefix node\n        for (char c : prefix.toCharArray()) {\n            if (!prefixNode.children.containsKey(c)) {\n                return result;\n            }\n            prefixNode = prefixNode.children.get(c);\n        }\n\n        // DFS to find all words\n        dfsCollectWords(prefixNode, prefix, result);\n        return result;\n    }\n\n    private void dfsCollectWords(TrieNode node, String prefix, List<String> result) {\n        if (node.isEndOfWord) {\n            result.add(prefix);\n        }\n\n        for (Map.Entry<Character, TrieNode> entry : node.children.entrySet()) {\n            dfsCollectWords(entry.getValue(), prefix + entry.getKey(), result);\n        }\n    }\n}\n"})}),"\n",(0,r.jsx)(t.h3,{id:"92-trie-applications",children:"9.2 Trie Applications"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:'// Word Search II\npublic List<String> findWords(char[][] board, String[] words) {\n    Trie trie = new Trie();\n    for (String word : words) {\n        trie.insert(word);\n    }\n\n    Set<String> result = new HashSet<>();\n    int m = board.length, n = board[0].length;\n    boolean[][] visited = new boolean[m][n];\n\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            dfs(board, i, j, trie.root, "", visited, result);\n        }\n    }\n\n    return new ArrayList<>(result);\n}\n\nprivate void dfs(char[][] board, int i, int j, Trie.TrieNode node,\n                String word, boolean[][] visited, Set<String> result) {\n    if (i < 0 || i >= board.length || j < 0 || j >= board[0].length ||\n        visited[i][j] || !node.children.containsKey(board[i][j])) {\n        return;\n    }\n\n    visited[i][j] = true;\n    char c = board[i][j];\n    Trie.TrieNode child = node.children.get(c);\n    String newWord = word + c;\n\n    if (child.isEndOfWord) {\n        result.add(newWord);\n    }\n\n    // Explore all directions\n    int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    for (int[] dir : directions) {\n        dfs(board, i + dir[0], j + dir[1], child, newWord, visited, result);\n    }\n\n    visited[i][j] = false; // Backtrack\n}\n\n// Replace Words\npublic String replaceWords(List<String> dictionary, String sentence) {\n    Trie trie = new Trie();\n    for (String root : dictionary) {\n        trie.insert(root);\n    }\n\n    String[] words = sentence.split(" ");\n    StringBuilder result = new StringBuilder();\n\n    for (int i = 0; i < words.length; i++) {\n        if (i > 0) result.append(" ");\n\n        String replacement = findRoot(trie, words[i]);\n        result.append(replacement != null ? replacement : words[i]);\n    }\n\n    return result.toString();\n}\n\nprivate String findRoot(Trie trie, String word) {\n    Trie.TrieNode current = trie.root;\n    StringBuilder root = new StringBuilder();\n\n    for (char c : word.toCharArray()) {\n        if (!current.children.containsKey(c)) {\n            return null;\n        }\n\n        root.append(c);\n        current = current.children.get(c);\n\n        if (current.isEndOfWord) {\n            return root.toString();\n        }\n    }\n\n    return null;\n}\n'})}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"pattern-10-string-dp-problems",children:"Pattern 10: String DP Problems"}),"\n",(0,r.jsx)(t.h3,{id:"101-advanced-dp-on-strings",children:"10.1 Advanced DP on Strings"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:"// Interleaving String\npublic boolean isInterleave(String s1, String s2, String s3) {\n    if (s1.length() + s2.length() != s3.length()) return false;\n\n    int m = s1.length(), n = s2.length();\n    boolean[][] dp = new boolean[m + 1][n + 1];\n\n    dp[0][0] = true;\n\n    // Fill first row (only s2 characters)\n    for (int j = 1; j <= n; j++) {\n        dp[0][j] = dp[0][j - 1] && s2.charAt(j - 1) == s3.charAt(j - 1);\n    }\n\n    // Fill first column (only s1 characters)\n    for (int i = 1; i <= m; i++) {\n        dp[i][0] = dp[i - 1][0] && s1.charAt(i - 1) == s3.charAt(i - 1);\n    }\n\n    // Fill rest of table\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            dp[i][j] = (dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i + j - 1)) ||\n                       (dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1));\n        }\n    }\n\n    return dp[m][n];\n}\n\n// Scramble String\npublic boolean isScramble(String s1, String s2) {\n    if (s1.length() != s2.length()) return false;\n    if (s1.equals(s2)) return true;\n\n    // Check if both strings have same characters\n    int[] count = new int[26];\n    for (int i = 0; i < s1.length(); i++) {\n        count[s1.charAt(i) - 'a']++;\n        count[s2.charAt(i) - 'a']--;\n    }\n\n    for (int c : count) {\n        if (c != 0) return false;\n    }\n\n    // Try all possible splits\n    for (int i = 1; i < s1.length(); i++) {\n        // Case 1: No swap\n        if (isScramble(s1.substring(0, i), s2.substring(0, i)) &&\n            isScramble(s1.substring(i), s2.substring(i))) {\n            return true;\n        }\n\n        // Case 2: Swap\n        if (isScramble(s1.substring(0, i), s2.substring(s2.length() - i)) &&\n            isScramble(s1.substring(i), s2.substring(0, s2.length() - i))) {\n            return true;\n        }\n    }\n\n    return false;\n}\n"})}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"pattern-11-advanced-string-algorithms",children:"Pattern 11: Advanced String Algorithms"}),"\n",(0,r.jsx)(t.h3,{id:"111-suffix-array-and-lcp",children:"11.1 Suffix Array and LCP"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:'// Longest Repeated Substring\npublic String longestRepeatedSubstring(String s) {\n    int n = s.length();\n    String longest = "";\n\n    // Generate all suffixes and sort them\n    String[] suffixes = new String[n];\n    for (int i = 0; i < n; i++) {\n        suffixes[i] = s.substring(i);\n    }\n    Arrays.sort(suffixes);\n\n    // Find longest common prefix between adjacent suffixes\n    for (int i = 0; i < n - 1; i++) {\n        String lcp = longestCommonPrefix(suffixes[i], suffixes[i + 1]);\n        if (lcp.length() > longest.length()) {\n            longest = lcp;\n        }\n    }\n\n    return longest;\n}\n\nprivate String longestCommonPrefix(String s1, String s2) {\n    int minLen = Math.min(s1.length(), s2.length());\n    for (int i = 0; i < minLen; i++) {\n        if (s1.charAt(i) != s2.charAt(i)) {\n            return s1.substring(0, i);\n        }\n    }\n    return s1.substring(0, minLen);\n}\n'})}),"\n",(0,r.jsx)(t.h3,{id:"112-rolling-hash-applications",children:"11.2 Rolling Hash Applications"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:"// Longest Duplicate Substring (Rolling Hash)\npublic String longestDupSubstring(String s) {\n    int n = s.length();\n    String result = \"\";\n\n    // Binary search on length\n    int left = 1, right = n - 1;\n\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        String duplicate = searchDuplicate(s, mid);\n\n        if (duplicate != null) {\n            result = duplicate;\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    return result;\n}\n\nprivate String searchDuplicate(String s, int len) {\n    if (len == 0) return \"\";\n\n    long base = 26;\n    long mod = (long) Math.pow(2, 32);\n\n    // Calculate hash for first window\n    long hash = 0;\n    long pow = 1;\n\n    for (int i = 0; i < len; i++) {\n        hash = (hash * base + (s.charAt(i) - 'a')) % mod;\n        if (i < len - 1) pow = (pow * base) % mod;\n    }\n\n    Set<Long> seen = new HashSet<>();\n    seen.add(hash);\n\n    // Rolling hash\n    for (int i = len; i < s.length(); i++) {\n        hash = (hash - (s.charAt(i - len) - 'a') * pow % mod + mod) % mod;\n        hash = (hash * base + (s.charAt(i) - 'a')) % mod;\n\n        if (seen.contains(hash)) {\n            return s.substring(i - len + 1, i + 1);\n        }\n        seen.add(hash);\n    }\n\n    return null;\n}\n"})}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"pattern-12-string-compression--encoding",children:"Pattern 12: String Compression & Encoding"}),"\n",(0,r.jsx)(t.h3,{id:"121-string-compression",children:"12.1 String Compression"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:"// String Compression\npublic int compress(char[] chars) {\n    int write = 0, anchor = 0;\n\n    for (int read = 0; read <= chars.length; read++) {\n        if (read == chars.length || chars[read] != chars[anchor]) {\n            chars[write++] = chars[anchor];\n\n            if (read - anchor > 1) {\n                String count = String.valueOf(read - anchor);\n                for (char c : count.toCharArray()) {\n                    chars[write++] = c;\n                }\n            }\n\n            anchor = read;\n        }\n    }\n\n    return write;\n}\n\n// Run Length Encoding\npublic String encode(String s) {\n    StringBuilder encoded = new StringBuilder();\n    int i = 0;\n\n    while (i < s.length()) {\n        char current = s.charAt(i);\n        int count = 1;\n\n        while (i + count < s.length() && s.charAt(i + count) == current) {\n            count++;\n        }\n\n        encoded.append(current);\n        if (count > 1) {\n            encoded.append(count);\n        }\n\n        i += count;\n    }\n\n    return encoded.toString();\n}\n\n// Run Length Decoding\npublic String decode(String s) {\n    StringBuilder decoded = new StringBuilder();\n    int i = 0;\n\n    while (i < s.length()) {\n        char c = s.charAt(i++);\n        int count = 1;\n\n        // Check if next characters form a number\n        if (i < s.length() && Character.isDigit(s.charAt(i))) {\n            count = 0;\n            while (i < s.length() && Character.isDigit(s.charAt(i))) {\n                count = count * 10 + (s.charAt(i) - '0');\n                i++;\n            }\n        }\n\n        for (int j = 0; j < count; j++) {\n            decoded.append(c);\n        }\n    }\n\n    return decoded.toString();\n}\n"})}),"\n",(0,r.jsx)(t.h3,{id:"122-string-encoding-problems",children:"12.2 String Encoding Problems"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:'// Encode and Decode Strings\npublic class Codec {\n\n    // Encodes a list of strings to a single string\n    public String encode(List<String> strs) {\n        StringBuilder encoded = new StringBuilder();\n\n        for (String str : strs) {\n            encoded.append(str.length()).append("#").append(str);\n        }\n\n        return encoded.toString();\n    }\n\n    // Decodes a single string to a list of strings\n    public List<String> decode(String s) {\n        List<String> decoded = new ArrayList<>();\n        int i = 0;\n\n        while (i < s.length()) {\n            // Find the delimiter\n            int delimiterPos = s.indexOf(\'#\', i);\n            int length = Integer.parseInt(s.substring(i, delimiterPos));\n\n            // Extract the string\n            String str = s.substring(delimiterPos + 1, delimiterPos + 1 + length);\n            decoded.add(str);\n\n            i = delimiterPos + 1 + length;\n        }\n\n        return decoded;\n    }\n}\n\n// Count and Say\npublic String countAndSay(int n) {\n    String current = "1";\n\n    for (int i = 2; i <= n; i++) {\n        current = getNextSequence(current);\n    }\n\n    return current;\n}\n\nprivate String getNextSequence(String s) {\n    StringBuilder next = new StringBuilder();\n    int i = 0;\n\n    while (i < s.length()) {\n        char digit = s.charAt(i);\n        int count = 1;\n\n        while (i + count < s.length() && s.charAt(i + count) == digit) {\n            count++;\n        }\n\n        next.append(count).append(digit);\n        i += count;\n    }\n\n    return next.toString();\n}\n'})}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"time--space-complexity-reference",children:"Time & Space Complexity Reference"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{style:{textAlign:"left"},children:"Pattern"}),(0,r.jsx)(t.th,{style:{textAlign:"left"},children:"Time Complexity"}),(0,r.jsx)(t.th,{style:{textAlign:"left"},children:"Space Complexity"}),(0,r.jsx)(t.th,{style:{textAlign:"left"},children:"Key Characteristics"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Two Pointers"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"O(n)"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"O(1)"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Linear scan with constant space"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Sliding Window"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"O(n)"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"O(k)"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Single pass with window state"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"KMP Algorithm"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"O(m + n)"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"O(m)"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Preprocessing pattern for efficient matching"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Palindrome (Expand)"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"O(n\xb2)"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"O(1)"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Check all possible centers"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Anagram Detection"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"O(n)"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"O(1)"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Character frequency comparison"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Edit Distance"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"O(m \xd7 n)"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"O(m \xd7 n)"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Dynamic programming approach"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Trie Operations"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"O(m)"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"O(ALPHABET_SIZE \xd7 N \xd7 M)"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"m = word length, N = number of words"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"String DP"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"O(n\xb2) to O(n\xb3)"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"O(n\xb2)"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Depends on problem complexity"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Rolling Hash"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"O(n)"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"O(1)"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Polynomial hash for pattern matching"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"String Compression"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"O(n)"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"O(1)"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Single pass compression"})]})]})]}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"best-practices--optimization-tips",children:"Best Practices & Optimization Tips"}),"\n",(0,r.jsx)(t.h3,{id:"string-algorithm-guidelines",children:"String Algorithm Guidelines"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:'// 1. Choose appropriate string representation\nStringBuilder sb = new StringBuilder(); // For multiple concatenations\nStringBuffer sbf = new StringBuffer();  // For thread-safe operations\nString str = "constant";                // For immutable strings\n\n// 2. Use character arrays for in-place modifications\npublic void processString(String s) {\n    char[] chars = s.toCharArray();\n    // Modify chars array\n    String result = new String(chars);\n}\n\n// 3. Optimize character frequency counting\npublic Map<Character, Integer> optimizedFrequency(String s) {\n    // For ASCII characters only\n    int[] freq = new int[128];\n    for (char c : s.toCharArray()) {\n        freq[c]++;\n    }\n\n    // Convert back to map if needed\n    Map<Character, Integer> map = new HashMap<>();\n    for (int i = 0; i < freq.length; i++) {\n        if (freq[i] > 0) {\n            map.put((char) i, freq[i]);\n        }\n    }\n    return map;\n}\n\n// 4. Use appropriate algorithms for string matching\npublic boolean containsPattern(String text, String pattern) {\n    // For single search: built-in indexOf is optimized\n    return text.contains(pattern);\n\n    // For multiple searches: use KMP or build suffix array\n    // For approximate matching: use edit distance\n}\n'})}),"\n",(0,r.jsx)(t.h3,{id:"common-pitfalls-to-avoid",children:"Common Pitfalls to Avoid"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"String immutability"}),": Remember strings are immutable in Java"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Character encoding"}),": Be careful with Unicode vs ASCII"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Null checks"}),": Always validate input strings"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Case sensitivity"}),": Use appropriate comparison methods"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Memory usage"}),": Avoid creating unnecessary string objects"]}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"interview-tips83",children:"Interview Tips[8][3]"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Identify the pattern"})," early: palindrome, anagram, subsequence, etc."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Consider edge cases"}),": empty strings, single characters, special characters"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Choose optimal algorithms"}),": KMP for pattern matching, sliding window for substrings"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Think about space optimization"}),": in-place vs extra space trade-offs"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Practice string manipulation"}),": StringBuilder usage, character arrays"]}),"\n"]})]})}function h(n={}){const{wrapper:t}={...(0,i.R)(),...n.components};return t?(0,r.jsx)(t,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}}}]);