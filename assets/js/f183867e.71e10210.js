"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[6133],{2340:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>l});var i=t(4848),r=t(8453);const s={},o="Shortest Paths Problems",a={id:"DSA/ShortestPaths",title:"Shortest Paths Problems",description:"Problem: Shortest Path with Maximum Distance from Fire",source:"@site/docs/DSA/ShortestPaths.mdx",sourceDirName:"DSA",slug:"/DSA/ShortestPaths",permalink:"/js.enigma/docs/DSA/ShortestPaths",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/ShortestPaths.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Segment Tree Tutorial",permalink:"/js.enigma/docs/DSA/SegmentTree"},next:{title:"Sieve of Eratosthenes",permalink:"/js.enigma/docs/DSA/SieveOfEratosthenes"}},c={},l=[{value:"Problem: Shortest Path with Maximum Distance from Fire",id:"problem-shortest-path-with-maximum-distance-from-fire",level:2},{value:"Constraints",id:"constraints",level:2},{value:"Input",id:"input",level:2},{value:"Output",id:"output",level:2},{value:"Problem: Optimal Apartment Location",id:"problem-optimal-apartment-location",level:2},{value:"Description",id:"description",level:2},{value:"Constraints",id:"constraints-1",level:2},{value:"Input",id:"input-1",level:2},{value:"Output",id:"output-1",level:2},{value:"Minimum Combined Travel Cost for Alice and Bob",id:"minimum-combined-travel-cost-for-alice-and-bob",level:2},{value:"Example",id:"example",level:2},{value:"Explanation:",id:"explanation",level:3},{value:"Input",id:"input-2",level:2},{value:"Output",id:"output-2",level:2},{value:"Constraints",id:"constraints-2",level:2},{value:"Approach",id:"approach",level:2},{value:"Find the Nearest Favorite City Using Dijkstra&#39;s Algorithm with BFS",id:"find-the-nearest-favorite-city-using-dijkstras-algorithm-with-bfs",level:2},{value:"Problem Statement",id:"problem-statement",level:3},{value:"Input",id:"input-3",level:3},{value:"Output",id:"output-3",level:3}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"shortest-paths-problems",children:"Shortest Paths Problems"})}),"\n",(0,i.jsx)(e.h2,{id:"problem-shortest-path-with-maximum-distance-from-fire",children:"Problem: Shortest Path with Maximum Distance from Fire"}),"\n",(0,i.jsxs)(e.p,{children:["The ant can move in four directions: ",(0,i.jsx)(e.strong,{children:"up"}),", ",(0,i.jsx)(e.strong,{children:"down"}),", ",(0,i.jsx)(e.strong,{children:"left"}),", or ",(0,i.jsx)(e.strong,{children:"right"}),". The goal is to find the ",(0,i.jsx)(e.strong,{children:"shortest path"})," from ",(0,i.jsx)(e.code,{children:"(0, 0)"})," to ",(0,i.jsx)(e.code,{children:"(m-1, n-1)"})," while ensuring that the ant stays as far away from the fire as possible. Specifically, the path should maximize the ",(0,i.jsx)(e.strong,{children:"minimum distance"})," from any fire cell along the way."]}),"\n",(0,i.jsx)(e.h2,{id:"constraints",children:"Constraints"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:["The grid will have dimensions ",(0,i.jsx)(e.code,{children:"m x n"}),", where ",(0,i.jsx)(e.code,{children:"1 <= m, n <= 100"}),"."]}),"\n",(0,i.jsxs)(e.li,{children:["The ant cannot travel through cells with fire (",(0,i.jsx)(e.code,{children:"F"}),")."]}),"\n",(0,i.jsx)(e.li,{children:"The ant can move in four directions: up, down, left, or right."}),"\n",(0,i.jsxs)(e.li,{children:["If no valid path exists, return ",(0,i.jsx)(e.code,{children:"-1"}),"."]}),"\n",(0,i.jsx)(e.li,{children:"The distance from a cell to the fire is the Manhattan distance to the nearest fire cell."}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"input",children:"Input"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["A 2D grid of characters (",(0,i.jsx)(e.code,{children:"F"})," or ",(0,i.jsx)(e.code,{children:"."}),") representing the map."]}),"\n",(0,i.jsxs)(e.li,{children:["The starting position is ",(0,i.jsx)(e.code,{children:"(0, 0)"}),", and the destination is ",(0,i.jsx)(e.code,{children:"(m-1, n-1)"}),"."]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"output",children:"Output"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["Return the length of the shortest path from ",(0,i.jsx)(e.code,{children:"(0, 0)"})," to ",(0,i.jsx)(e.code,{children:"(m-1, n-1)"})," while maximizing the minimum distance from any fire cell."]}),"\n",(0,i.jsxs)(e.li,{children:["If no such path exists, return ",(0,i.jsx)(e.code,{children:"-1"}),"."]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-JavaScript",children:"function shortestPathWithMaxDistanceFromFire(grid) {\r\n  const m = grid.length;\r\n  const n = grid[0].length;\r\n\r\n  // Directions for moving up, down, left, right\r\n  const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];\r\n\r\n  // Step 1: Precompute the distance of each cell from the nearest fire\r\n  const fireDistance = new Array(m).fill().map(() => new Array(n).fill(Infinity));\r\n  const queue = [];\r\n\r\n  // Initialize the queue with all fire positions\r\n  for (let i = 0; i < m; i++) {\r\n    for (let j = 0; j < n; j++) {\r\n      if (grid[i][j] === 'F') {\r\n        queue.push([i, j]);\r\n        fireDistance[i][j] = 0;\r\n      }\r\n    }\r\n  }\r\n\r\n  // BFS to compute the distance from each fire\r\n  while (queue.length > 0) {\r\n    const [x, y] = queue.shift();\r\n    for (const [dx, dy] of directions) {\r\n      const nx = x + dx;\r\n      const ny = y + dy;\r\n      if (nx >= 0 && nx < m && ny >= 0 && ny < n && fireDistance[nx][ny] === Infinity) {\r\n        fireDistance[nx][ny] = fireDistance[x][y] + 1;\r\n        queue.push([nx, ny]);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Step 2: Find the shortest path with maximum distance from fire\r\n  const visited = new Array(m).fill().map(() => new Array(n).fill(false));\r\n  const priorityQueue = [];\r\n\r\n  // Start from (0, 0) with distance 0 and the distance from fire at that cell\r\n  priorityQueue.push([0, 0, 0, fireDistance[0][0]]);\r\n  visited[0][0] = true;\r\n\r\n  while (priorityQueue.length > 0) {\r\n    priorityQueue.sort((a, b) => b[3] - a[3]); // Sort by distance from fire (max first)\r\n    const [x, y, dist, fireDist] = priorityQueue.pop();\r\n\r\n    // If we reach the destination, return the distance\r\n    if (x === m - 1 && y === n - 1) {\r\n      return dist;\r\n    }\r\n\r\n    // Explore all four directions\r\n    for (const [dx, dy] of directions) {\r\n      const nx = x + dx;\r\n      const ny = y + dy;\r\n      if (nx >= 0 && nx < m && ny >= 0 && ny < n && !visited[nx][ny] && grid[nx][ny] === '.') {\r\n        visited[nx][ny] = true;\r\n        priorityQueue.push([nx, ny, dist + 1, fireDistance[nx][ny]]);\r\n      }\r\n    }\r\n  }\r\n\r\n  // If no path is found\r\n  return -1;\r\n}\r\n\r\n// Example usage:\r\nconst grid = [\r\n  ['.', 'F', '.', '.'],\r\n  ['.', '.', '.', 'F'],\r\n  ['F', '.', '.', '.'],\r\n  ['.', '.', 'F', '.']\r\n];\r\n\r\nconsole.log(shortestPathWithMaxDistanceFromFire(grid)); // Output: 6\r\n\r\nconst grid2 = [\r\n  ['.', '.', '.', '.'],\r\n  ['.', 'F', '.', '.'],\r\n  ['.', '.', '.', '.'],\r\n  ['.', '.', '.', '.']\r\n];\r\n\r\nconsole.log(shortestPathWithMaxDistanceFromFire(grid2)); // Output: 5\n"})}),"\n",(0,i.jsx)(e.h2,{id:"problem-optimal-apartment-location",children:"Problem: Optimal Apartment Location"}),"\n",(0,i.jsx)(e.h2,{id:"description",children:"Description"}),"\n",(0,i.jsx)(e.p,{children:"You are planning to move to a new city and want to find the optimal apartment location. The city is represented as a 2D grid, where each cell can be:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"A potential apartment location."}),"\n",(0,i.jsx)(e.li,{children:"A key location (e.g., gym, office, restaurant, etc.)."}),"\n",(0,i.jsx)(e.li,{children:"An obstacle (e.g., park, lake, etc.) that cannot be traversed."}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:["Your goal is to find the apartment location that is ",(0,i.jsx)(e.strong,{children:"closest to all key locations"})," (e.g., gym, office, restaurant, etc.). The optimal apartment is the one that minimizes the ",(0,i.jsx)(e.strong,{children:"total distance"})," (or travel time) to all key locations."]}),"\n",(0,i.jsx)(e.h2,{id:"constraints-1",children:"Constraints"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:["The grid will have dimensions ",(0,i.jsx)(e.code,{children:"m x n"}),", where ",(0,i.jsx)(e.code,{children:"1 <= m, n <= 100"}),"."]}),"\n",(0,i.jsxs)(e.li,{children:["You can move in four directions: ",(0,i.jsx)(e.strong,{children:"up"}),", ",(0,i.jsx)(e.strong,{children:"down"}),", ",(0,i.jsx)(e.strong,{children:"left"}),", or ",(0,i.jsx)(e.strong,{children:"right"}),"."]}),"\n",(0,i.jsxs)(e.li,{children:["Obstacles are represented by ",(0,i.jsx)(e.code,{children:"X"}),", and you cannot travel through them."]}),"\n",(0,i.jsxs)(e.li,{children:["Key locations are represented by unique identifiers (e.g., ",(0,i.jsx)(e.code,{children:"G"})," for gym, ",(0,i.jsx)(e.code,{children:"O"})," for office, ",(0,i.jsx)(e.code,{children:"R"})," for restaurant, etc.)."]}),"\n",(0,i.jsxs)(e.li,{children:["Apartment locations are represented by ",(0,i.jsx)(e.code,{children:"A"}),"."]}),"\n",(0,i.jsxs)(e.li,{children:["If no valid apartment location exists, return ",(0,i.jsx)(e.code,{children:"-1"}),"."]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"input-1",children:"Input"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["A 2D grid of characters representing the city map. The grid contains:","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"A"}),": Potential apartment locations."]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"G"}),", ",(0,i.jsx)(e.code,{children:"O"}),", ",(0,i.jsx)(e.code,{children:"R"}),", etc.: Key locations (gym, office, restaurant, etc.)."]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"X"}),": Obstacles that cannot be traversed."]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"."}),": Empty spaces that can be traversed."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"output-1",children:"Output"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["Return the coordinates ",(0,i.jsx)(e.code,{children:"(x, y)"})," of the optimal apartment location that minimizes the total distance to all key locations."]}),"\n",(0,i.jsxs)(e.li,{children:["If no valid apartment location exists, return ",(0,i.jsx)(e.code,{children:"-1"}),"."]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-JavaScript",children:"function findOptimalApartment(grid, keyLocations) {\r\n    const m = grid.length;\r\n    const n = grid[0].length;\r\n    const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]; // Up, Down, Left, Right\r\n\r\n    // Initialize distance grids for each key location\r\n    const distanceGrids = keyLocations.map(([x, y]) => {\r\n        const distanceGrid = new Array(m).fill().map(() => new Array(n).fill(Infinity));\r\n        const queue = [[x, y]];\r\n        distanceGrid[x][y] = 0;\r\n\r\n        // BFS to compute distances from this key location\r\n        while (queue.length > 0) {\r\n            const [cx, cy] = queue.shift();\r\n            for (const [dx, dy] of directions) {\r\n                const nx = cx + dx;\r\n                const ny = cy + dy;\r\n                if (nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] !== 'X' && distanceGrid[nx][ny] === Infinity) {\r\n                    distanceGrid[nx][ny] = distanceGrid[cx][cy] + 1;\r\n                    queue.push([nx, ny]);\r\n                }\r\n            }\r\n        }\r\n        return distanceGrid;\r\n    });\r\n\r\n    // Find the apartment with the smallest total distance to all key locations\r\n    let minTotalDistance = Infinity;\r\n    let optimalApartment = null;\r\n\r\n    for (let i = 0; i < m; i++) {\r\n        for (let j = 0; j < n; j++) {\r\n            if (grid[i][j] === 'A') { // 'A' represents an apartment\r\n                let totalDistance = 0;\r\n                for (const distanceGrid of distanceGrids) {\r\n                    totalDistance += distanceGrid[i][j];\r\n                }\r\n                if (totalDistance < minTotalDistance) {\r\n                    minTotalDistance = totalDistance;\r\n                    optimalApartment = [i, j];\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return optimalApartment;\r\n}\r\n\r\n// Example usage\r\nconst grid = [\r\n    ['.', '.', '.', '.', '.'],\r\n    ['.', 'G', '.', 'X', '.'],\r\n    ['.', '.', 'A', '.', '.'],\r\n    ['.', 'X', '.', 'O', '.'],\r\n    ['.', '.', '.', '.', 'R']\r\n];\r\n\r\nconst keyLocations = [\r\n    [1, 1], // Gym (G)\r\n    [3, 3], // Office (O)\r\n    [4, 4]  // Restaurant (R)\r\n];\r\n\r\nconst optimalApartment = findOptimalApartment(grid, keyLocations);\r\nconsole.log(\"Optimal Apartment Location:\", optimalApartment); // Output: [2, 2]\n"})}),"\n",(0,i.jsx)(e.h2,{id:"minimum-combined-travel-cost-for-alice-and-bob",children:"Minimum Combined Travel Cost for Alice and Bob"}),"\n",(0,i.jsxs)(e.p,{children:["You are given a graph of cities where each vertex represents a city, and the edges represent the connectivity between two cities. The cost to travel from one city to another connected by a single edge is ",(0,i.jsx)(e.strong,{children:"1 unit"}),". Two friends, Alice and Bob, live in two different cities and want to reach a destination city to attend a concert. Both Alice and Bob plan to take cabs from their respective cities to reach the destination. They may decide to share a cab at some point to minimize the total cost of traveling to the destination city."]}),"\n",(0,i.jsxs)(e.p,{children:["Your task is to find the ",(0,i.jsx)(e.strong,{children:"minimum combined cost"})," for both Alice and Bob to reach the destination city."]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"example",children:"Example"}),"\n",(0,i.jsx)(e.p,{children:"Consider the following graph:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-plaintext",children:"A - B\r\n|   |\r\nD - C\r\n|   |\r\nE - F\n"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Alice's starting city"}),": A"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Bob's starting city"}),": E"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Destination city"}),": C"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"explanation",children:"Explanation:"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:["Alice travels from ",(0,i.jsx)(e.strong,{children:"A to D"})," (cost = 1)."]}),"\n",(0,i.jsxs)(e.li,{children:["Bob travels from ",(0,i.jsx)(e.strong,{children:"E to D"})," (cost = 1)."]}),"\n",(0,i.jsxs)(e.li,{children:["Both Alice and Bob share a cab from ",(0,i.jsx)(e.strong,{children:"D to C"})," (cost = 1)."]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Total cost = 1 + 1 + 1 = 3"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"input-2",children:"Input"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"A graph represented as an adjacency list or matrix."}),"\n",(0,i.jsx)(e.li,{children:"The starting cities for Alice and Bob."}),"\n",(0,i.jsx)(e.li,{children:"The destination city."}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"output-2",children:"Output"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"The minimum combined cost for Alice and Bob to reach the destination city."}),"\n"]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"constraints-2",children:"Constraints"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"The graph is undirected and unweighted (each edge has a cost of 1 unit)."}),"\n",(0,i.jsx)(e.li,{children:"Alice and Bob can share a cab at any point during their journey."}),"\n"]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"approach",children:"Approach"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:["Use ",(0,i.jsx)(e.strong,{children:"Breadth-First Search (BFS)"})," to compute the shortest distance from Alice's starting city to all other cities."]}),"\n",(0,i.jsx)(e.li,{children:"Use BFS to compute the shortest distance from Bob's starting city to all other cities."}),"\n",(0,i.jsx)(e.li,{children:"Use BFS to compute the shortest distance from the destination city to all other cities."}),"\n",(0,i.jsx)(e.li,{children:"Iterate through all cities to find the optimal meeting point where the combined cost of Alice and Bob traveling to the meeting point and then sharing a cab to the destination is minimized."}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-JavaScript",children:"function minTravelCost(edges, alice, bob, destination) {\r\n  // Build adjacency list for the graph\r\n  let graph = new Map();\r\n\r\n  edges.forEach(([u, v]) => {\r\n    if (!graph.has(u)) graph.set(u, []);\r\n    if (!graph.has(v)) graph.set(v, []);\r\n    graph.get(u).push(v);\r\n    graph.get(v).push(u);\r\n  });\r\n\r\n  // BFS function to calculate shortest distances from a given start city\r\n  function bfs(start) {\r\n    let queue = [[start, 0]];\r\n    let distances = new Map();\r\n    distances.set(start, 0);\r\n\r\n    while (queue.length > 0) {\r\n      let [city, dist] = queue.shift();\r\n      for (let neighbor of (graph.get(city) || [])) {\r\n        if (!distances.has(neighbor)) {\r\n          distances.set(neighbor, dist + 1);\r\n          queue.push([neighbor, dist + 1]);\r\n        }\r\n      }\r\n    }\r\n    return distances;\r\n  }\r\n\r\n  // Get shortest paths from Alice, Bob, and the destination\r\n  let distFromAlice = bfs(alice);\r\n  let distFromBob = bfs(bob);\r\n  let distFromDestination = bfs(destination);\r\n\r\n  // Find the minimum cost meeting point\r\n  let minCost = Infinity;\r\n  for (let city of graph.keys()) {\r\n    if (distFromAlice.has(city) && distFromBob.has(city) && distFromDestination.has(city)) {\r\n      let totalCost = distFromAlice.get(city) + distFromBob.get(city) + distFromDestination.get(city);\r\n      minCost = Math.min(minCost, totalCost);\r\n    }\r\n  }\r\n\r\n  return minCost;\r\n}\r\n\r\n// Example usage:\r\nconst edges = [['A', 'B'], ['A', 'D'], ['B', 'C'], ['D', 'C'], ['D', 'E'], ['E', 'F'], ['F', 'C']];\r\nconsole.log(minTravelCost(edges, 'A', 'E', 'C')); // Output: 3\n"})}),"\n",(0,i.jsx)(e.h2,{id:"find-the-nearest-favorite-city-using-dijkstras-algorithm-with-bfs",children:"Find the Nearest Favorite City Using Dijkstra's Algorithm with BFS"}),"\n",(0,i.jsx)(e.h3,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,i.jsxs)(e.p,{children:["You are given a set of directed connections (weighted edges) between cities. Additionally, you have a list of favorite cities. Given a starting city, find the nearest favorite city using ",(0,i.jsx)(e.strong,{children:"Dijkstra's algorithm implemented with BFS-style traversal"}),"."]}),"\n",(0,i.jsx)(e.h3,{id:"input-3",children:"Input"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"n"}),": Number of cities."]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"edges"}),": A list of directed edges, where each edge is represented as ",(0,i.jsx)(e.code,{children:"[city1, city2, weight]"}),"."]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"favoriteCities"}),": A set containing the names (or indices) of favorite cities."]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"startCity"}),": The city from which the search begins."]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"output-3",children:"Output"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["The nearest favorite city & min distance from ",(0,i.jsx)(e.code,{children:"startCity"}),". If no favorite city is reachable, return ",(0,i.jsx)(e.code,{children:"-1"}),"."]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-JavaScript",children:"function dijkstra(graph, start, favoriteCities) {\r\n  const distances = {};\r\n  const pq = new MinPriorityQueue();\r\n\r\n  // Initialize distances\r\n  for (const city in graph) {\r\n    distances[city] = Infinity;\r\n  }\r\n  distances[start] = 0;\r\n  pq.enqueue(start, 0);\r\n\r\n  while (!pq.isEmpty()) {\r\n    const { element: currentCity, priority: currentDistance } = pq.dequeue();\r\n\r\n    if (currentDistance > distances[currentCity]) continue;\r\n\r\n    for (const neighbor in graph[currentCity]) {\r\n      const distance = currentDistance + graph[currentCity][neighbor];\r\n\r\n      if (distance < distances[neighbor]) {\r\n        distances[neighbor] = distance;\r\n        pq.enqueue(neighbor, distance);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Find the nearest favorite city\r\n  let nearestFavoriteCity = null;\r\n  let minDistance = Infinity;\r\n\r\n  for (const city of favoriteCities) {\r\n    if (distances[city] < minDistance) {\r\n      minDistance = distances[city];\r\n      nearestFavoriteCity = city;\r\n    }\r\n  }\r\n\r\n  return [nearestFavoriteCity, minDistance];\r\n}\r\n\r\n// Example usage:\r\nconst graph = {\r\n  'A': { 'B': 1, 'C': 4 },\r\n  'B': { 'A': 1, 'C': 2, 'D': 5 },\r\n  'C': { 'A': 4, 'B': 2, 'D': 1 },\r\n  'D': { 'B': 5, 'C': 1 }\r\n};\r\n\r\nconst favoriteCities = ['C', 'D'];\r\nconst startCity = 'A';\r\n\r\nconst nearestFavoriteCity = dijkstra(graph, startCity, favoriteCities);\r\nconsole.log(`The nearest favorite city from ${startCity} is ${nearestFavoriteCity}`);\r\n/* \r\nThe nearest favorite city from A is C,3\r\n*/\n"})})]})}function h(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(d,{...n})}):d(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>o,x:()=>a});var i=t(6540);const r={},s=i.createContext(r);function o(n){const e=i.useContext(s);return i.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:o(n.components),i.createElement(s.Provider,{value:e},n.children)}}}]);