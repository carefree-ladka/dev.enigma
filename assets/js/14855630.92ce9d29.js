"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[6121],{5384:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>h,contentTitle:()=>a,default:()=>c,frontMatter:()=>l,metadata:()=>s,toc:()=>o});var r=i(4848),t=i(8453);const l={},a="Euler Path, Hamilton Cycle, and Hierholzer's Algorithm",s={id:"DSA/DSA with JavaScript/EularPath",title:"Euler Path, Hamilton Cycle, and Hierholzer's Algorithm",description:"Table of Contents",source:"@site/docs/DSA/DSA with JavaScript/EularPath.mdx",sourceDirName:"DSA/DSA with JavaScript",slug:"/DSA/DSA with JavaScript/EularPath",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/EularPath",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with JavaScript/EularPath.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Euclid's Algorithm for Greatest Common Divisor (GCD)",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/Euclid"},next:{title:"Fenwick Tree Tutorial",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/Fenwick"}},h={},o=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Euler Path",id:"euler-path",level:2},{value:"Key Concepts",id:"key-concepts",level:3},{value:"Hamilton Cycle",id:"hamilton-cycle",level:2},{value:"Hierholzer&#39;s Algorithm",id:"hierholzers-algorithm",level:2},{value:"LeetCode Problems",id:"leetcode-problems",level:2},{value:"1. LeetCode 332 - Reconstruct Itinerary (Hard)",id:"1-leetcode-332---reconstruct-itinerary-hard",level:3},{value:"2. LeetCode 753 - Cracking the Safe (Hard)",id:"2-leetcode-753---cracking-the-safe-hard",level:3},{value:"3. LeetCode 2097 - Valid Arrangement of Pairs (Hard)",id:"3-leetcode-2097---valid-arrangement-of-pairs-hard",level:3},{value:"Implementation Guide",id:"implementation-guide",level:2},{value:"Using Euler Path",id:"using-euler-path",level:3},{value:"Using Hamilton Cycle",id:"using-hamilton-cycle",level:3},{value:"Using Hierholzer",id:"using-hierholzer",level:3},{value:"Tips for Problem Solving",id:"tips-for-problem-solving",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"euler-path-hamilton-cycle-and-hierholzers-algorithm",children:"Euler Path, Hamilton Cycle, and Hierholzer's Algorithm"})}),"\n",(0,r.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#introduction",children:"Introduction"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#euler-path",children:"Euler Path"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#hamilton-cycle",children:"Hamilton Cycle"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#hierholzers-algorithm",children:"Hierholzer's Algorithm"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#leetcode-problems",children:"LeetCode Problems"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#implementation-guide",children:"Implementation Guide"})}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,r.jsx)(n.p,{children:"This guide covers three fundamental graph algorithms: Euler Path, Hamilton Cycle, and Hierholzer's Algorithm. Each has its unique use cases and applications in solving various graph-related problems."}),"\n",(0,r.jsx)(n.h2,{id:"euler-path",children:"Euler Path"}),"\n",(0,r.jsx)(n.p,{children:"An Euler path visits every edge in a graph exactly once. Here's the implementation:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class EulerPath {\n    constructor(n) {\n        this.n = n;\n        this.adj = Array.from({length: n}, () => []);\n        this.inDegree = new Array(n).fill(0);\n        this.outDegree = new Array(n).fill(0);\n    }\n    \n    addEdge(from, to) {\n        this.adj[from].push(to);\n        this.outDegree[from]++;\n        this.inDegree[to]++;\n    }\n    \n    findPath() {\n        if (!this.canHaveEulerPath()) return [];\n        \n        let start = 0;\n        for (let i = 0; i < this.n; i++) {\n            if (this.outDegree[i] - this.inDegree[i] === 1) {\n                start = i;\n                break;\n            }\n            if (this.outDegree[i] > 0) start = i;\n        }\n        \n        const path = [];\n        const stack = [start];\n        \n        while (stack.length > 0) {\n            let curr = stack[stack.length - 1];\n            \n            if (this.adj[curr].length === 0) {\n                path.push(curr);\n                stack.pop();\n            } else {\n                let next = this.adj[curr].pop();\n                stack.push(next);\n            }\n        }\n        \n        return path.reverse();\n    }\n    \n    canHaveEulerPath() {\n        let startNodes = 0, endNodes = 0;\n        \n        for (let i = 0; i < this.n; i++) {\n            let diff = this.outDegree[i] - this.inDegree[i];\n            if (Math.abs(diff) > 1) return false;\n            if (diff === 1) startNodes++;\n            if (diff === -1) endNodes++;\n        }\n        \n        return (startNodes === 0 && endNodes === 0) || \n               (startNodes === 1 && endNodes === 1);\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Requires all vertices to have equal in-degree and out-degree (for Euler circuit)"}),"\n",(0,r.jsx)(n.li,{children:"At most one vertex can have out-degree = in-degree + 1 (for Euler path)"}),"\n",(0,r.jsx)(n.li,{children:"At most one vertex can have in-degree = out-degree + 1 (for Euler path)"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"hamilton-cycle",children:"Hamilton Cycle"}),"\n",(0,r.jsx)(n.p,{children:"A Hamilton cycle visits every vertex exactly once and returns to the starting vertex:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class HamiltonCycle {\n    constructor(n) {\n        this.n = n;\n        this.adj = Array.from({length: n}, () => Array(n).fill(0));\n        this.path = new Array(n).fill(-1);\n    }\n    \n    addEdge(from, to) {\n        this.adj[from][to] = 1;\n        this.adj[to][from] = 1;\n    }\n    \n    findCycle() {\n        this.path[0] = 0;\n        return !this.findCycleUtil(1) ? [] : this.path;\n    }\n    \n    findCycleUtil(pos) {\n        if (pos === this.n) {\n            return this.adj[this.path[pos-1]][this.path[0]] === 1;\n        }\n        \n        for (let v = 1; v < this.n; v++) {\n            if (this.isSafe(v, pos)) {\n                this.path[pos] = v;\n                if (this.findCycleUtil(pos + 1)) return true;\n                this.path[pos] = -1;\n            }\n        }\n        \n        return false;\n    }\n    \n    isSafe(v, pos) {\n        return this.adj[this.path[pos-1]][v] === 1 && !this.path.includes(v);\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"hierholzers-algorithm",children:"Hierholzer's Algorithm"}),"\n",(0,r.jsx)(n.p,{children:"Hierholzer's Algorithm finds Euler circuits efficiently:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class Hierholzer {\n    constructor(n) {\n        this.n = n;\n        this.adj = Array.from({length: n}, () => []);\n    }\n    \n    addEdge(from, to) {\n        this.adj[from].push(to);\n    }\n    \n    findCircuit() {\n        const circuit = [];\n        const stack = [0];\n        \n        while (stack.length > 0) {\n            let curr = stack[stack.length - 1];\n            \n            if (this.adj[curr].length === 0) {\n                circuit.push(curr);\n                stack.pop();\n            } else {\n                stack.push(this.adj[curr].pop());\n            }\n        }\n        \n        return circuit.reverse();\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"leetcode-problems",children:"LeetCode Problems"}),"\n",(0,r.jsx)(n.p,{children:"Here are some LeetCode problems that can be solved using these algorithms:"}),"\n",(0,r.jsx)(n.h3,{id:"1-leetcode-332---reconstruct-itinerary-hard",children:"1. LeetCode 332 - Reconstruct Itinerary (Hard)"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Uses Hierholzer's algorithm"}),"\n",(0,r.jsx)(n.li,{children:"Find Euler path in directed graph of flight tickets"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'Example:\nInput: [["MUC","LHR"],["JFK","MUC"],["SFO","SJC"],["LHR","SFO"]]\nOutput: ["JFK","MUC","LHR","SFO","SJC"]\n'})}),"\n",(0,r.jsx)(n.h3,{id:"2-leetcode-753---cracking-the-safe-hard",children:"2. LeetCode 753 - Cracking the Safe (Hard)"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Uses de Bruijn sequence (special case of Euler path)"}),"\n",(0,r.jsx)(n.li,{children:"Find shortest string containing all combinations"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'Example:\nInput: n = 2, k = 2\nOutput: "00110" // Contains all 2-digit combinations of 0,1\n'})}),"\n",(0,r.jsx)(n.h3,{id:"3-leetcode-2097---valid-arrangement-of-pairs-hard",children:"3. LeetCode 2097 - Valid Arrangement of Pairs (Hard)"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Find Euler path in graph of number pairs"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"Example:\nInput: pairs = [[5,1],[4,5],[11,9],[9,4]]\nOutput: [[11,9],[9,4],[4,5],[5,1]]\n"})}),"\n",(0,r.jsx)(n.h2,{id:"implementation-guide",children:"Implementation Guide"}),"\n",(0,r.jsx)(n.h3,{id:"using-euler-path",children:"Using Euler Path"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'const eulerGraph = new EulerPath(4);\neulerGraph.addEdge(0, 1);\neulerGraph.addEdge(1, 2);\neulerGraph.addEdge(2, 3);\neulerGraph.addEdge(3, 0);\nconsole.log("Euler Path:", eulerGraph.findPath());\n'})}),"\n",(0,r.jsx)(n.h3,{id:"using-hamilton-cycle",children:"Using Hamilton Cycle"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'const hamiltonGraph = new HamiltonCycle(5);\nhamiltonGraph.addEdge(0, 1);\nhamiltonGraph.addEdge(1, 2);\nhamiltonGraph.addEdge(2, 3);\nhamiltonGraph.addEdge(3, 4);\nhamiltonGraph.addEdge(4, 0);\nconsole.log("Hamilton Cycle:", hamiltonGraph.findCycle());\n'})}),"\n",(0,r.jsx)(n.h3,{id:"using-hierholzer",children:"Using Hierholzer"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'const hierholzerGraph = new Hierholzer(4);\nhierholzerGraph.addEdge(0, 1);\nhierholzerGraph.addEdge(1, 2);\nhierholzerGraph.addEdge(2, 3);\nhierholzerGraph.addEdge(3, 0);\nconsole.log("Hierholzer Circuit:", hierholzerGraph.findCircuit());\n'})}),"\n",(0,r.jsx)(n.h2,{id:"tips-for-problem-solving",children:"Tips for Problem Solving"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Graph Representation"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Choose appropriate representation (adjacency list/matrix)"}),"\n",(0,r.jsx)(n.li,{children:"Consider directed vs undirected edges"}),"\n",(0,r.jsx)(n.li,{children:"Handle special cases (multiple edges, self-loops)"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Algorithm Selection"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Euler Path: When need to traverse all edges once"}),"\n",(0,r.jsx)(n.li,{children:"Hamilton Cycle: When need to visit all vertices once"}),"\n",(0,r.jsx)(n.li,{children:"Hierholzer: When finding Euler circuit efficiently"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Common Patterns"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Check existence conditions first"}),"\n",(0,r.jsx)(n.li,{children:"Handle edge cases (empty graph, disconnected components)"}),"\n",(0,r.jsx)(n.li,{children:"Consider lexicographical ordering if required"}),"\n"]}),"\n"]}),"\n"]})]})}function c(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>s});var r=i(6540);const t={},l=r.createContext(t);function a(e){const n=r.useContext(l);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),r.createElement(l.Provider,{value:n},e.children)}}}]);