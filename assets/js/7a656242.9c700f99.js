"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[3770],{3387:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>a,contentTitle:()=>o,default:()=>c,frontMatter:()=>r,metadata:()=>l,toc:()=>h});var n=i(4848),s=i(8453);const r={title:"Floyd-Warshall Algorithm"},o=void 0,l={id:"DSA/Floyd-Warshall",title:"Floyd-Warshall Algorithm",description:"Floyd-Warshall algorithm is a classic algorithm for finding the shortest paths in a weighted graph with positive or negative edge weights (but no negative cycles). It can be used to find the shortest paths between all pairs of vertices in a graph.",source:"@site/docs/DSA/Floyd-Warshall.mdx",sourceDirName:"DSA",slug:"/DSA/Floyd-Warshall",permalink:"/js.enigma/docs/DSA/Floyd-Warshall",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/Floyd-Warshall.mdx",tags:[],version:"current",frontMatter:{title:"Floyd-Warshall Algorithm"},sidebar:"tutorialSidebar",previous:{title:"Flood Fill Algorithm",permalink:"/js.enigma/docs/DSA/FloodFill"},next:{title:"Floyd's Cycle Detection Algorithm",permalink:"/js.enigma/docs/DSA/FlyodsCycleDetection"}},a={},h=[{value:"Algorithm Overview",id:"algorithm-overview",level:3},{value:"Steps of the Algorithm",id:"steps-of-the-algorithm",level:3}];function d(e){const t={code:"code",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.p,{children:"Floyd-Warshall algorithm is a classic algorithm for finding the shortest paths in a weighted graph with positive or negative edge weights (but no negative cycles). It can be used to find the shortest paths between all pairs of vertices in a graph."}),"\n",(0,n.jsx)(t.h3,{id:"algorithm-overview",children:"Algorithm Overview"}),"\n",(0,n.jsx)(t.p,{children:"The algorithm works by considering all pairs of vertices and systematically trying all possible paths between each pair to find the shortest path. It does this using dynamic programming."}),"\n",(0,n.jsx)(t.h3,{id:"steps-of-the-algorithm",children:"Steps of the Algorithm"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:["Initialization: Create a distance matrix dist, where dist[i][j] represents the shortest distance from vertex i to vertex j. Initialize this matrix as follows:","\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["Set ",(0,n.jsx)(t.code,{children:"dist[i][j] = 0"})," if ",(0,n.jsx)(t.code,{children:"i == j"})]}),"\n",(0,n.jsxs)(t.li,{children:["Set ",(0,n.jsx)(t.code,{children:"dist[i][j] = weight of edge (i, j)"})," if there is an edge from ",(0,n.jsx)(t.code,{children:"i"})," to ",(0,n.jsx)(t.code,{children:"j"}),"."]}),"\n",(0,n.jsxs)(t.li,{children:["Set ",(0,n.jsx)(t.code,{children:"dist[i][j] = \u221e (infinity)"})," if there is no edge from ",(0,n.jsx)(t.code,{children:"i"})," to ",(0,n.jsx)(t.code,{children:"j"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-JavaScript",children:"/**\n * Floyd-Warshall Algorithm to find the shortest paths between all pairs of nodes.\n * @param {number[][]} graph - Adjacency matrix representing the graph.\n * @return {number[][]} - Distance matrix with the shortest paths.\n */\nfunction floydWarshall(graph) {\n  const V = graph.length;\n  const distance = Array.from({ length: V }, (_, i) => Array.from(graph[i]));\n\n  // Initialize distances based on input graph\n  for (let k = 0; k < V; k++) {\n    for (let i = 0; i < V; i++) {\n      for (let j = 0; j < V; j++) {\n        if (distance[i][k] !== Infinity && distance[k][j] !== Infinity) {\n          distance[i][j] = Math.min(distance[i][j], distance[i][k] + distance[k][j]);\n        }\n      }\n    }\n  }\n\n  return distance;\n}\n\n// Example usage:\nconst graph = [\n  [0, 3, Infinity, Infinity],\n  [2, 0, Infinity, 1],\n  [Infinity, 7, 0, 2],\n  [6, Infinity, 3, 0]\n];\n\nconst shortestPaths = floydWarshall(graph);\nconsole.log(shortestPaths); //[ [ 0, 3, 7, 4 ], [ 2, 0, 4, 1 ], [ 8, 7, 0, 2 ], [ 6, 9, 3, 0 ] ]\n\n/* \nTime Complexity: O(V^3)\nSpace Complexity: O(V^2)\n*/\n"})})]})}function c(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},8453:(e,t,i)=>{i.d(t,{R:()=>o,x:()=>l});var n=i(6540);const s={},r=n.createContext(s);function o(e){const t=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);