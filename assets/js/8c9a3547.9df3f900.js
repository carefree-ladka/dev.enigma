"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[9701],{28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var r=t(96540);const i={},s=r.createContext(i);function o(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(s.Provider,{value:n},e.children)}},56739:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>a,toc:()=>c});var r=t(74848),i=t(28453);const s={},o="Spring Security Complete Notes",a={id:"Java/Spring Security Complete Notes",title:"Spring Security Complete Notes",description:"Table of Contents",source:"@site/docs/Java/Spring Security Complete Notes.mdx",sourceDirName:"Java",slug:"/Java/Spring Security Complete Notes",permalink:"/docs/Java/Spring Security Complete Notes",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/Java/Spring Security Complete Notes.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Spring Boot Beginner Guide",permalink:"/docs/Java/Spring Boot"},next:{title:"System Design Notes",permalink:"/docs/Java/System Design Notes"}},l={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Introduction to Spring Security",id:"introduction-to-spring-security",level:2},{value:"Key Features:",id:"key-features",level:3},{value:"Core Architecture",id:"core-architecture",level:2},{value:"Security Filter Chain",id:"security-filter-chain",level:3},{value:"Key Components:",id:"key-components",level:3},{value:"Authentication vs Authorization",id:"authentication-vs-authorization",level:2},{value:"Authentication",id:"authentication",level:3},{value:"Authorization",id:"authorization",level:3},{value:"Password Encoding with BCrypt",id:"password-encoding-with-bcrypt",level:2},{value:"Theory:",id:"theory",level:3},{value:"Implementation:",id:"implementation",level:3},{value:"BCrypt Strengths:",id:"bcrypt-strengths",level:3},{value:"JWT (JSON Web Tokens)",id:"jwt-json-web-tokens",level:2},{value:"Structure:",id:"structure",level:3},{value:"Header:",id:"header",level:4},{value:"Payload:",id:"payload",level:4},{value:"JWT Implementation:",id:"jwt-implementation",level:3},{value:"JWT Filter:",id:"jwt-filter",level:3},{value:"Refresh Tokens",id:"refresh-tokens",level:2},{value:"Theory:",id:"theory-1",level:3},{value:"Implementation:",id:"implementation-1",level:3},{value:"HttpOnly Cookies",id:"httponly-cookies",level:2},{value:"Theory:",id:"theory-2",level:3},{value:"Implementation:",id:"implementation-2",level:3},{value:"Cookie Filter:",id:"cookie-filter",level:3},{value:"Role-Based Access Control (RBAC)",id:"role-based-access-control-rbac",level:2},{value:"Entity Design:",id:"entity-design",level:3},{value:"Method-Level Security:",id:"method-level-security",level:3},{value:"Custom Permission Evaluator:",id:"custom-permission-evaluator",level:3},{value:"Security Configuration",id:"security-configuration",level:2},{value:"Complete Security Configuration:",id:"complete-security-configuration",level:3},{value:"Custom Authentication Provider",id:"custom-authentication-provider",level:2},{value:"Method-Level Security",id:"method-level-security-1",level:2},{value:"CSRF Protection",id:"csrf-protection",level:2},{value:"CORS Configuration",id:"cors-configuration",level:2},{value:"Session Management",id:"session-management",level:2},{value:"OAuth2 Integration",id:"oauth2-integration",level:2},{value:"Security Best Practices",id:"security-best-practices",level:2},{value:"1. Password Security",id:"1-password-security",level:3},{value:"2. Account Lockout and Rate Limiting",id:"2-account-lockout-and-rate-limiting",level:3},{value:"3. Audit Logging",id:"3-audit-logging",level:3},{value:"4. Two-Factor Authentication (2FA)",id:"4-two-factor-authentication-2fa",level:3},{value:"5. Content Security Policy (CSP)",id:"5-content-security-policy-csp",level:3},{value:"Common Security Configurations",id:"common-security-configurations",level:2},{value:"Production Application Properties",id:"production-application-properties",level:3},{value:"Testing Security Configuration",id:"testing-security-configuration",level:3},{value:"Key Takeaways",id:"key-takeaways",level:2},{value:"Security Checklist:",id:"security-checklist",level:3},{value:"Performance Considerations:",id:"performance-considerations",level:3},{value:"Monitoring and Alerting:",id:"monitoring-and-alerting",level:3}];function u(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"spring-security-complete-notes",children:"Spring Security Complete Notes"})}),"\n",(0,r.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#introduction-to-spring-security",children:"Introduction to Spring Security"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#core-architecture",children:"Core Architecture"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#authentication-vs-authorization",children:"Authentication vs Authorization"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#password-encoding-with-bcrypt",children:"Password Encoding with BCrypt"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#jwt-json-web-tokens",children:"JWT (JSON Web Tokens)"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#refresh-tokens",children:"Refresh Tokens"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#httponly-cookies",children:"HttpOnly Cookies"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#role-based-access-control-rbac",children:"Role-Based Access Control (RBAC)"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#security-configuration",children:"Security Configuration"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#custom-authentication-provider",children:"Custom Authentication Provider"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#method-level-security",children:"Method-Level Security"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#csrf-protection",children:"CSRF Protection"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#cors-configuration",children:"CORS Configuration"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#session-management",children:"Session Management"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#oauth2-integration",children:"OAuth2 Integration"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#security-best-practices",children:"Security Best Practices"})}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"introduction-to-spring-security",children:"Introduction to Spring Security"}),"\n",(0,r.jsx)(n.p,{children:"Spring Security is a powerful and highly customizable authentication and access-control framework for Spring applications. It provides comprehensive security services for Java EE-based enterprise software applications."}),"\n",(0,r.jsx)(n.h3,{id:"key-features",children:"Key Features:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Authentication"}),": Verifying the identity of users"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Authorization"}),": Controlling access to resources"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Protection against attacks"}),": CSRF, session fixation, clickjacking, etc."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Servlet API integration"}),": Works seamlessly with Spring Boot"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Password encoding"}),": Built-in support for various encoding algorithms"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Remember-me authentication"}),": Persistent login functionality"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"core-architecture",children:"Core Architecture"}),"\n",(0,r.jsx)(n.h3,{id:"security-filter-chain",children:"Security Filter Chain"}),"\n",(0,r.jsx)(n.p,{children:"Spring Security uses a chain of filters to process security-related tasks:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        http\n            .authorizeHttpRequests(authz -> authz\n                .requestMatchers("/public/**").permitAll()\n                .requestMatchers("/admin/**").hasRole("ADMIN")\n                .anyRequest().authenticated()\n            )\n            .formLogin(form -> form\n                .loginPage("/login")\n                .permitAll()\n            )\n            .logout(logout -> logout.permitAll());\n\n        return http.build();\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"key-components",children:"Key Components:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"SecurityContext"}),": Holds security information about current user"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Authentication"}),": Represents user credentials and authorities"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"AuthenticationManager"}),": Processes authentication requests"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"UserDetailsService"}),": Loads user-specific data"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"PasswordEncoder"}),": Encodes passwords securely"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"authentication-vs-authorization",children:"Authentication vs Authorization"}),"\n",(0,r.jsx)(n.h3,{id:"authentication",children:"Authentication"}),"\n",(0,r.jsx)(n.p,{children:"Process of verifying who the user is."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Service\npublic class CustomUserDetailsService implements UserDetailsService {\n\n    @Autowired\n    private UserRepository userRepository;\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n        User user = userRepository.findByUsername(username)\n            .orElseThrow(() -> new UsernameNotFoundException("User not found: " + username));\n\n        return org.springframework.security.core.userdetails.User.builder()\n            .username(user.getUsername())\n            .password(user.getPassword())\n            .authorities(user.getRoles().stream()\n                .map(role -> new SimpleGrantedAuthority("ROLE_" + role.getName()))\n                .collect(Collectors.toList()))\n            .build();\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"authorization",children:"Authorization"}),"\n",(0,r.jsx)(n.p,{children:"Process of determining what the authenticated user is allowed to do."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@PreAuthorize("hasRole(\'ADMIN\')")\n@GetMapping("/admin/users")\npublic List<User> getAllUsers() {\n    return userService.getAllUsers();\n}\n\n@PreAuthorize("hasRole(\'USER\') and #userId == authentication.principal.id")\n@GetMapping("/user/{userId}/profile")\npublic UserProfile getUserProfile(@PathVariable Long userId) {\n    return userService.getUserProfile(userId);\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"password-encoding-with-bcrypt",children:"Password Encoding with BCrypt"}),"\n",(0,r.jsx)(n.p,{children:"BCrypt is a password hashing function designed to be slow and computationally expensive, making it resistant to brute-force attacks."}),"\n",(0,r.jsx)(n.h3,{id:"theory",children:"Theory:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Salt"}),": Random data added to password before hashing"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cost Factor"}),": Controls how slow the algorithm runs"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"One-way function"}),": Cannot be reversed to get original password"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"implementation",children:"Implementation:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"@Configuration\npublic class PasswordConfig {\n\n    @Bean\n    public PasswordEncoder passwordEncoder() {\n        return new BCryptPasswordEncoder(12); // Strength of 12\n    }\n}\n\n@Service\npublic class UserService {\n\n    @Autowired\n    private PasswordEncoder passwordEncoder;\n\n    public void createUser(String username, String rawPassword) {\n        String encodedPassword = passwordEncoder.encode(rawPassword);\n        User user = new User(username, encodedPassword);\n        userRepository.save(user);\n    }\n\n    public boolean verifyPassword(String rawPassword, String encodedPassword) {\n        return passwordEncoder.matches(rawPassword, encodedPassword);\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"bcrypt-strengths",children:"BCrypt Strengths:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"10"}),": 2^10 = 1,024 rounds (fast, for testing)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"12"}),": 2^12 = 4,096 rounds (recommended for production)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"15"}),": 2^15 = 32,768 rounds (very secure, slower)"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"jwt-json-web-tokens",children:"JWT (JSON Web Tokens)"}),"\n",(0,r.jsx)(n.p,{children:"JWT is a compact, URL-safe means of representing claims between two parties."}),"\n",(0,r.jsx)(n.h3,{id:"structure",children:"Structure:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Header.Payload.Signature\n"})}),"\n",(0,r.jsx)(n.h4,{id:"header",children:"Header:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "alg": "HS256",\n  "typ": "JWT"\n}\n'})}),"\n",(0,r.jsx)(n.h4,{id:"payload",children:"Payload:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "sub": "user123",\n  "name": "John Doe",\n  "roles": ["USER", "ADMIN"],\n  "exp": 1735689600,\n  "iat": 1735686000\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"jwt-implementation",children:"JWT Implementation:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Component\npublic class JwtUtil {\n\n    private String secret = "mySecretKey";\n    private int jwtExpiration = 86400000; // 24 hours\n\n    public String generateToken(UserDetails userDetails) {\n        Map<String, Object> claims = new HashMap<>();\n        Collection<? extends GrantedAuthority> authorities = userDetails.getAuthorities();\n        claims.put("roles", authorities.stream()\n            .map(GrantedAuthority::getAuthority)\n            .collect(Collectors.toList()));\n\n        return createToken(claims, userDetails.getUsername());\n    }\n\n    private String createToken(Map<String, Object> claims, String subject) {\n        return Jwts.builder()\n            .setClaims(claims)\n            .setSubject(subject)\n            .setIssuedAt(new Date(System.currentTimeMillis()))\n            .setExpiration(new Date(System.currentTimeMillis() + jwtExpiration))\n            .signWith(SignatureAlgorithm.HS256, secret)\n            .compact();\n    }\n\n    public Boolean validateToken(String token, UserDetails userDetails) {\n        final String username = getUsernameFromToken(token);\n        return (username.equals(userDetails.getUsername()) && !isTokenExpired(token));\n    }\n\n    public String getUsernameFromToken(String token) {\n        return getClaimFromToken(token, Claims::getSubject);\n    }\n\n    public Date getExpirationDateFromToken(String token) {\n        return getClaimFromToken(token, Claims::getExpiration);\n    }\n\n    public <T> T getClaimFromToken(String token, Function<Claims, T> claimsResolver) {\n        final Claims claims = getAllClaimsFromToken(token);\n        return claimsResolver.apply(claims);\n    }\n\n    private Claims getAllClaimsFromToken(String token) {\n        return Jwts.parser().setSigningKey(secret).parseClaimsJws(token).getBody();\n    }\n\n    private Boolean isTokenExpired(String token) {\n        final Date expiration = getExpirationDateFromToken(token);\n        return expiration.before(new Date());\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"jwt-filter",children:"JWT Filter:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Component\npublic class JwtAuthenticationFilter extends OncePerRequestFilter {\n\n    @Autowired\n    private UserDetailsService userDetailsService;\n\n    @Autowired\n    private JwtUtil jwtUtil;\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest request,\n                                  HttpServletResponse response,\n                                  FilterChain chain) throws ServletException, IOException {\n\n        final String requestTokenHeader = request.getHeader("Authorization");\n\n        String username = null;\n        String jwtToken = null;\n\n        if (requestTokenHeader != null && requestTokenHeader.startsWith("Bearer ")) {\n            jwtToken = requestTokenHeader.substring(7);\n            try {\n                username = jwtUtil.getUsernameFromToken(jwtToken);\n            } catch (IllegalArgumentException e) {\n                System.out.println("Unable to get JWT Token");\n            } catch (ExpiredJwtException e) {\n                System.out.println("JWT Token has expired");\n            }\n        }\n\n        if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {\n            UserDetails userDetails = this.userDetailsService.loadUserByUsername(username);\n\n            if (jwtUtil.validateToken(jwtToken, userDetails)) {\n                UsernamePasswordAuthenticationToken authToken =\n                    new UsernamePasswordAuthenticationToken(\n                        userDetails, null, userDetails.getAuthorities());\n                authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));\n                SecurityContextHolder.getContext().setAuthentication(authToken);\n            }\n        }\n        chain.doFilter(request, response);\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"refresh-tokens",children:"Refresh Tokens"}),"\n",(0,r.jsx)(n.p,{children:"Refresh tokens provide a secure way to obtain new access tokens without requiring users to re-authenticate."}),"\n",(0,r.jsx)(n.h3,{id:"theory-1",children:"Theory:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Access Token"}),": Short-lived (15-30 minutes)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Refresh Token"}),": Long-lived (days/weeks), stored securely"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Rotation"}),": Generate new refresh token with each use"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"implementation-1",children:"Implementation:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Entity\npublic class RefreshToken {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    @Column(nullable = false, unique = true)\n    private String token;\n\n    @Column(nullable = false)\n    private Instant expiryDate;\n\n    @OneToOne\n    @JoinColumn(name = "user_id", referencedColumnName = "id")\n    private User user;\n\n    // constructors, getters, setters\n}\n\n@Service\npublic class RefreshTokenService {\n\n    @Value("${app.jwtRefreshExpirationMs}")\n    private Long refreshTokenDurationMs;\n\n    @Autowired\n    private RefreshTokenRepository refreshTokenRepository;\n\n    public RefreshToken createRefreshToken(Long userId) {\n        RefreshToken refreshToken = new RefreshToken();\n        refreshToken.setUser(userRepository.findById(userId).get());\n        refreshToken.setExpiryDate(Instant.now().plusMillis(refreshTokenDurationMs));\n        refreshToken.setToken(UUID.randomUUID().toString());\n\n        refreshToken = refreshTokenRepository.save(refreshToken);\n        return refreshToken;\n    }\n\n    public RefreshToken verifyExpiration(RefreshToken token) {\n        if (token.getExpiryDate().compareTo(Instant.now()) < 0) {\n            refreshTokenRepository.delete(token);\n            throw new TokenRefreshException(token.getToken(),\n                "Refresh token was expired. Please make a new signin request");\n        }\n        return token;\n    }\n\n    @Transactional\n    public int deleteByUserId(Long userId) {\n        return refreshTokenRepository.deleteByUser(userRepository.findById(userId).get());\n    }\n}\n\n@RestController\n@RequestMapping("/api/auth")\npublic class AuthController {\n\n    @PostMapping("/refreshtoken")\n    public ResponseEntity<?> refreshtoken(@Valid @RequestBody TokenRefreshRequest request) {\n        String requestRefreshToken = request.getRefreshToken();\n\n        return refreshTokenService.findByToken(requestRefreshToken)\n            .map(refreshTokenService::verifyExpiration)\n            .map(RefreshToken::getUser)\n            .map(user -> {\n                String token = jwtUtils.generateTokenFromUsername(user.getUsername());\n                return ResponseEntity.ok(new TokenRefreshResponse(token, requestRefreshToken));\n            })\n            .orElseThrow(() -> new TokenRefreshException(requestRefreshToken,\n                "Refresh token is not in database!"));\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"httponly-cookies",children:"HttpOnly Cookies"}),"\n",(0,r.jsx)(n.p,{children:"HttpOnly cookies provide enhanced security by preventing JavaScript access, making them ideal for storing sensitive tokens."}),"\n",(0,r.jsx)(n.h3,{id:"theory-2",children:"Theory:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"HttpOnly Flag"}),": Prevents XSS attacks by blocking JavaScript access"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Secure Flag"}),": Ensures transmission only over HTTPS"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"SameSite"}),": Controls cross-site request behavior"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"implementation-2",children:"Implementation:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Service\npublic class CookieService {\n\n    public ResponseCookie createAccessTokenCookie(String token, Duration duration) {\n        return ResponseCookie.from("accessToken", token)\n            .maxAge(duration)\n            .httpOnly(true)\n            .secure(true)\n            .sameSite("Strict")\n            .path("/")\n            .build();\n    }\n\n    public ResponseCookie createRefreshTokenCookie(String token, Duration duration) {\n        return ResponseCookie.from("refreshToken", token)\n            .maxAge(duration)\n            .httpOnly(true)\n            .secure(true)\n            .sameSite("Strict")\n            .path("/api/auth")\n            .build();\n    }\n\n    public ResponseCookie deleteAccessTokenCookie() {\n        return ResponseCookie.from("accessToken", "")\n            .maxAge(0)\n            .httpOnly(true)\n            .secure(true)\n            .sameSite("Strict")\n            .path("/")\n            .build();\n    }\n}\n\n@RestController\n@RequestMapping("/api/auth")\npublic class AuthController {\n\n    @PostMapping("/signin")\n    public ResponseEntity<?> authenticateUser(@Valid @RequestBody LoginRequest loginRequest,\n                                            HttpServletResponse response) {\n\n        Authentication authentication = authenticationManager\n            .authenticate(new UsernamePasswordAuthenticationToken(\n                loginRequest.getUsername(),\n                loginRequest.getPassword()));\n\n        SecurityContextHolder.getContext().setAuthentication(authentication);\n\n        UserDetailsImpl userDetails = (UserDetailsImpl) authentication.getPrincipal();\n        String accessToken = jwtUtils.generateJwtToken(userDetails);\n\n        RefreshToken refreshToken = refreshTokenService.createRefreshToken(userDetails.getId());\n\n        ResponseCookie accessTokenCookie = cookieService\n            .createAccessTokenCookie(accessToken, Duration.ofMinutes(15));\n        ResponseCookie refreshTokenCookie = cookieService\n            .createRefreshTokenCookie(refreshToken.getToken(), Duration.ofDays(7));\n\n        response.addHeader(HttpHeaders.SET_COOKIE, accessTokenCookie.toString());\n        response.addHeader(HttpHeaders.SET_COOKIE, refreshTokenCookie.toString());\n\n        return ResponseEntity.ok(new MessageResponse("User signed in successfully!"));\n    }\n\n    @PostMapping("/signout")\n    public ResponseEntity<?> logoutUser(HttpServletResponse response) {\n        SecurityContextHolder.getContext().setAuthentication(null);\n\n        ResponseCookie accessTokenCookie = cookieService.deleteAccessTokenCookie();\n        ResponseCookie refreshTokenCookie = cookieService.deleteRefreshTokenCookie();\n\n        response.addHeader(HttpHeaders.SET_COOKIE, accessTokenCookie.toString());\n        response.addHeader(HttpHeaders.SET_COOKIE, refreshTokenCookie.toString());\n\n        return ResponseEntity.ok(new MessageResponse("You\'ve been signed out!"));\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"cookie-filter",children:"Cookie Filter:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Component\npublic class CookieAuthenticationFilter extends OncePerRequestFilter {\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest request,\n                                  HttpServletResponse response,\n                                  FilterChain filterChain) throws ServletException, IOException {\n\n        String jwt = getJwtFromCookies(request);\n\n        if (jwt != null && jwtUtils.validateJwtToken(jwt)) {\n            String username = jwtUtils.getUserNameFromJwtToken(jwt);\n            UserDetails userDetails = userDetailsService.loadUserByUsername(username);\n\n            UsernamePasswordAuthenticationToken authentication =\n                new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());\n            SecurityContextHolder.getContext().setAuthentication(authentication);\n        }\n\n        filterChain.doFilter(request, response);\n    }\n\n    private String getJwtFromCookies(HttpServletRequest request) {\n        Cookie[] cookies = request.getCookies();\n        if (cookies != null) {\n            for (Cookie cookie : cookies) {\n                if ("accessToken".equals(cookie.getName())) {\n                    return cookie.getValue();\n                }\n            }\n        }\n        return null;\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"role-based-access-control-rbac",children:"Role-Based Access Control (RBAC)"}),"\n",(0,r.jsx)(n.p,{children:"RBAC is a method of regulating access based on the roles of individual users within an organization."}),"\n",(0,r.jsx)(n.h3,{id:"entity-design",children:"Entity Design:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Entity\n@Table(name = "users")\npublic class User {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    @Column(unique = true)\n    private String username;\n\n    private String password;\n    private String email;\n    private boolean enabled = true;\n\n    @ManyToMany(fetch = FetchType.EAGER)\n    @JoinTable(\n        name = "user_roles",\n        joinColumns = @JoinColumn(name = "user_id"),\n        inverseJoinColumns = @JoinColumn(name = "role_id")\n    )\n    private Set<Role> roles = new HashSet<>();\n\n    // constructors, getters, setters\n}\n\n@Entity\n@Table(name = "roles")\npublic class Role {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    @Enumerated(EnumType.STRING)\n    private RoleName name;\n\n    @ManyToMany(mappedBy = "roles")\n    private Set<User> users = new HashSet<>();\n\n    @ManyToMany(fetch = FetchType.EAGER)\n    @JoinTable(\n        name = "role_permissions",\n        joinColumns = @JoinColumn(name = "role_id"),\n        inverseJoinColumns = @JoinColumn(name = "permission_id")\n    )\n    private Set<Permission> permissions = new HashSet<>();\n\n    // constructors, getters, setters\n}\n\n@Entity\n@Table(name = "permissions")\npublic class Permission {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    private String name;\n    private String description;\n\n    @ManyToMany(mappedBy = "permissions")\n    private Set<Role> roles = new HashSet<>();\n\n    // constructors, getters, setters\n}\n\npublic enum RoleName {\n    ROLE_USER,\n    ROLE_ADMIN,\n    ROLE_MODERATOR\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"method-level-security",children:"Method-Level Security:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@RestController\n@RequestMapping("/api")\n@PreAuthorize("isAuthenticated()")\npublic class UserController {\n\n    @GetMapping("/user/profile")\n    @PreAuthorize("hasRole(\'USER\')")\n    public ResponseEntity<UserProfile> getUserProfile(Authentication authentication) {\n        return ResponseEntity.ok(userService.getUserProfile(authentication.getName()));\n    }\n\n    @GetMapping("/admin/users")\n    @PreAuthorize("hasRole(\'ADMIN\')")\n    public ResponseEntity<List<User>> getAllUsers() {\n        return ResponseEntity.ok(userService.getAllUsers());\n    }\n\n    @PostMapping("/admin/users/{userId}/roles")\n    @PreAuthorize("hasRole(\'ADMIN\') and hasAuthority(\'USER_MANAGEMENT\')")\n    public ResponseEntity<?> assignRole(@PathVariable Long userId, @RequestBody RoleRequest request) {\n        userService.assignRole(userId, request.getRoleName());\n        return ResponseEntity.ok(new MessageResponse("Role assigned successfully"));\n    }\n\n    @DeleteMapping("/moderator/posts/{postId}")\n    @PreAuthorize("hasRole(\'MODERATOR\') or (hasRole(\'USER\') and @postService.isOwner(#postId, authentication.name))")\n    public ResponseEntity<?> deletePost(@PathVariable Long postId) {\n        postService.deletePost(postId);\n        return ResponseEntity.ok(new MessageResponse("Post deleted successfully"));\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"custom-permission-evaluator",children:"Custom Permission Evaluator:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Component\npublic class CustomPermissionEvaluator implements PermissionEvaluator {\n\n    @Autowired\n    private UserService userService;\n\n    @Override\n    public boolean hasPermission(Authentication auth, Object targetDomainObject, Object permission) {\n        if ((auth == null) || (targetDomainObject == null) || !(permission instanceof String)) {\n            return false;\n        }\n\n        String targetType = targetDomainObject.getClass().getSimpleName().toUpperCase();\n        return hasPrivilege(auth, targetType, permission.toString().toUpperCase());\n    }\n\n    @Override\n    public boolean hasPermission(Authentication auth, Serializable targetId, String targetType, Object permission) {\n        if ((auth == null) || (targetType == null) || !(permission instanceof String)) {\n            return false;\n        }\n        return hasPrivilege(auth, targetType.toUpperCase(), permission.toString().toUpperCase());\n    }\n\n    private boolean hasPrivilege(Authentication auth, String resourceType, String permission) {\n        UserDetailsImpl user = (UserDetailsImpl) auth.getPrincipal();\n        Set<String> userPermissions = userService.getUserPermissions(user.getUsername());\n\n        String requiredPermission = resourceType + "_" + permission;\n        return userPermissions.contains(requiredPermission) || userPermissions.contains("ALL_PERMISSIONS");\n    }\n}\n\n@Configuration\n@EnableGlobalMethodSecurity(prePostEnabled = true)\npublic class MethodSecurityConfig extends GlobalMethodSecurityConfiguration {\n\n    @Autowired\n    private CustomPermissionEvaluator permissionEvaluator;\n\n    @Override\n    protected MethodSecurityExpressionHandler createExpressionHandler() {\n        DefaultMethodSecurityExpressionHandler expressionHandler =\n            new DefaultMethodSecurityExpressionHandler();\n        expressionHandler.setPermissionEvaluator(permissionEvaluator);\n        return expressionHandler;\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"security-configuration",children:"Security Configuration"}),"\n",(0,r.jsx)(n.h3,{id:"complete-security-configuration",children:"Complete Security Configuration:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Configuration\n@EnableWebSecurity\n@EnableGlobalMethodSecurity(prePostEnabled = true)\npublic class WebSecurityConfig {\n\n    @Autowired\n    private UserDetailsService userDetailsService;\n\n    @Autowired\n    private AuthEntryPointJwt unauthorizedHandler;\n\n    @Bean\n    public JwtAuthenticationFilter authenticationJwtTokenFilter() {\n        return new JwtAuthenticationFilter();\n    }\n\n    @Bean\n    public PasswordEncoder passwordEncoder() {\n        return new BCryptPasswordEncoder(12);\n    }\n\n    @Bean\n    public AuthenticationManager authenticationManager(\n            AuthenticationConfiguration authConfig) throws Exception {\n        return authConfig.getAuthenticationManager();\n    }\n\n    @Bean\n    public DaoAuthenticationProvider authenticationProvider() {\n        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();\n        authProvider.setUserDetailsService(userDetailsService);\n        authProvider.setPasswordEncoder(passwordEncoder());\n        return authProvider;\n    }\n\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        http.cors(Customizer.withDefaults())\n            .csrf(csrf -> csrf.disable())\n            .exceptionHandling(exception -> exception.authenticationEntryPoint(unauthorizedHandler))\n            .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))\n            .authorizeHttpRequests(authz -> authz\n                .requestMatchers("/api/auth/**").permitAll()\n                .requestMatchers("/api/public/**").permitAll()\n                .requestMatchers(HttpMethod.GET, "/api/posts/**").permitAll()\n                .requestMatchers("/api/admin/**").hasRole("ADMIN")\n                .requestMatchers("/api/moderator/**").hasRole("MODERATOR")\n                .anyRequest().authenticated()\n            );\n\n        http.authenticationProvider(authenticationProvider());\n        http.addFilterBefore(authenticationJwtTokenFilter(), UsernamePasswordAuthenticationFilter.class);\n\n        return http.build();\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"custom-authentication-provider",children:"Custom Authentication Provider"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Component\npublic class CustomAuthenticationProvider implements AuthenticationProvider {\n\n    @Autowired\n    private UserDetailsService userDetailsService;\n\n    @Autowired\n    private PasswordEncoder passwordEncoder;\n\n    @Override\n    public Authentication authenticate(Authentication authentication) throws AuthenticationException {\n        String username = authentication.getName();\n        String password = authentication.getCredentials().toString();\n\n        UserDetails userDetails = userDetailsService.loadUserByUsername(username);\n\n        if (passwordEncoder.matches(password, userDetails.getPassword())) {\n            // Additional custom validation logic here\n            if (isAccountLocked(username)) {\n                throw new AccountStatusException("Account is locked") {};\n            }\n\n            if (requiresTwoFactorAuth(username) && !isTwoFactorValid(authentication)) {\n                throw new BadCredentialsException("Two-factor authentication required");\n            }\n\n            return new UsernamePasswordAuthenticationToken(\n                userDetails, password, userDetails.getAuthorities());\n        } else {\n            throw new BadCredentialsException("Authentication failed");\n        }\n    }\n\n    @Override\n    public boolean supports(Class<?> authentication) {\n        return authentication.equals(UsernamePasswordAuthenticationToken.class);\n    }\n\n    private boolean isAccountLocked(String username) {\n        // Custom logic to check if account is locked\n        return false;\n    }\n\n    private boolean requiresTwoFactorAuth(String username) {\n        // Custom logic to check if 2FA is required\n        return false;\n    }\n\n    private boolean isTwoFactorValid(Authentication authentication) {\n        // Custom logic to validate 2FA\n        return true;\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"method-level-security-1",children:"Method-Level Security"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"@Service\npublic class DocumentService {\n\n    @PreAuthorize(\"hasRole('ADMIN') or hasRole('USER')\")\n    public List<Document> getAllDocuments() {\n        return documentRepository.findAll();\n    }\n\n    @PreAuthorize(\"#username == authentication.name or hasRole('ADMIN')\")\n    public List<Document> getUserDocuments(String username) {\n        return documentRepository.findByUsername(username);\n    }\n\n    @PostAuthorize(\"returnObject.owner == authentication.name or hasRole('ADMIN')\")\n    public Document getDocument(Long id) {\n        return documentRepository.findById(id).orElse(null);\n    }\n\n    @PreFilter(\"filterObject.owner == authentication.name or hasRole('ADMIN')\")\n    public List<Document> processDocuments(List<Document> documents) {\n        // Process only documents that pass the pre-filter\n        return documents.stream()\n            .map(this::processDocument)\n            .collect(Collectors.toList());\n    }\n\n    @PostFilter(\"filterObject.confidential == false or hasRole('ADMIN')\")\n    public List<Document> getFilteredDocuments() {\n        return documentRepository.findAll();\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"csrf-protection",children:"CSRF Protection"}),"\n",(0,r.jsx)(n.p,{children:"Cross-Site Request Forgery (CSRF) protection prevents unauthorized actions on behalf of authenticated users."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Configuration\npublic class CsrfSecurityConfig {\n\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        http\n            .csrf(csrf -> csrf\n                .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())\n                .ignoringRequestMatchers("/api/public/**")\n                .csrfTokenRequestHandler(new XorCsrfTokenRequestAttributeHandler())\n            )\n            .addFilterAfter(new CsrfCookieFilter(), BasicAuthenticationFilter.class);\n\n        return http.build();\n    }\n}\n\npublic class CsrfCookieFilter implements Filter {\n\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)\n            throws IOException, ServletException {\n        CsrfToken csrfToken = (CsrfToken) request.getAttribute(CsrfToken.class.getName());\n        if (csrfToken != null) {\n            // Ensure the token is available to the client\n            csrfToken.getToken();\n        }\n        filterChain.doFilter(request, response);\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"cors-configuration",children:"CORS Configuration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Configuration\npublic class CorsConfig {\n\n    @Bean\n    public CorsConfigurationSource corsConfigurationSource() {\n        CorsConfiguration configuration = new CorsConfiguration();\n        configuration.setAllowedOriginPatterns(Arrays.asList("*"));\n        configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"));\n        configuration.setAllowedHeaders(Arrays.asList("*"));\n        configuration.setAllowCredentials(true);\n        configuration.setExposedHeaders(Arrays.asList("Authorization", "X-Total-Count"));\n\n        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\n        source.registerCorsConfiguration("/**", configuration);\n        return source;\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"session-management",children:"Session Management"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Configuration\npublic class SessionConfig {\n\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        http\n            .sessionManagement(session -> session\n                .sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED)\n                .maximumSessions(1)\n                .maxSessionsPreventsLogin(false)\n                .sessionRegistry(sessionRegistry())\n                .and()\n                .sessionFixation().migrateSession()\n                .invalidSessionUrl("/login?expired")\n            )\n            .rememberMe(remember -> remember\n                .key("uniqueAndSecret")\n                .tokenValiditySeconds(86400) // 24 hours\n                .userDetailsService(userDetailsService)\n            );\n\n        return http.build();\n    }\n\n    @Bean\n    public SessionRegistry sessionRegistry() {\n        return new SessionRegistryImpl();\n    }\n\n    @Bean\n    public HttpSessionEventPublisher httpSessionEventPublisher() {\n        return new HttpSessionEventPublisher();\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"oauth2-integration",children:"OAuth2 Integration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Configuration\n@EnableOAuth2Client\npublic class OAuth2Config {\n\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        http\n            .oauth2Login(oauth2 -> oauth2\n                .loginPage("/login")\n                .userInfoEndpoint(userInfo -> userInfo\n                    .userService(this.oauth2UserService())\n                )\n                .successHandler(oauth2AuthenticationSuccessHandler())\n                .failureHandler(oauth2AuthenticationFailureHandler())\n            )\n            .oauth2ResourceServer(oauth2 -> oauth2\n                .jwt(jwt -> jwt\n                    .decoder(jwtDecoder())\n                    .jwtAuthenticationConverter(jwtAuthenticationConverter())\n                )\n            );\n\n        return http.build();\n    }\n\n    @Bean\n    public OAuth2UserService<OAuth2UserRequest, OAuth2User> oauth2UserService() {\n        return new CustomOAuth2UserService();\n    }\n\n    @Bean\n    public JwtDecoder jwtDecoder() {\n        return NimbusJwtDecoder.withJwkSetUri("https://your-auth-server.com/.well-known/jwks.json").build();\n    }\n\n    @Bean\n    public Converter<Jwt, ? extends AbstractAuthenticationToken> jwtAuthenticationConverter() {\n        JwtAuthenticationConverter jwtConverter = new JwtAuthenticationConverter();\n        jwtConverter.setJwtGrantedAuthoritiesConverter(jwt -> {\n            Collection<String> authorities = jwt.getClaimAsStringList("authorities");\n            return authorities.stream()\n                .map(SimpleGrantedAuthority::new)\n                .collect(Collectors.toList());\n        });\n        return jwtConverter;\n    }\n}\n\n@Service\npublic class CustomOAuth2UserService extends DefaultOAuth2UserService {\n\n    @Autowired\n    private UserRepository userRepository;\n\n    @Override\n    public OAuth2User loadUser(OAuth2UserRequest userRequest) throws OAuth2AuthenticationException {\n        OAuth2User oauth2User = super.loadUser(userRequest);\n\n        try {\n            return processOAuth2User(userRequest, oauth2User);\n        } catch (AuthenticationException ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new InternalAuthenticationServiceException(ex.getMessage(), ex.getCause());\n        }\n    }\n\n    private OAuth2User processOAuth2User(OAuth2UserRequest userRequest, OAuth2User oauth2User) {\n        OAuth2UserInfo oauth2UserInfo = OAuth2UserInfoFactory\n            .getOAuth2UserInfo(userRequest.getClientRegistration().getRegistrationId(), oauth2User.getAttributes());\n\n        if (StringUtils.isEmpty(oauth2UserInfo.getEmail())) {\n            throw new OAuth2AuthenticationProcessingException("Email not found from OAuth2 provider");\n        }\n\n        Optional<User> userOptional = userRepository.findByEmail(oauth2UserInfo.getEmail());\n        User user;\n        if (userOptional.isPresent()) {\n            user = userOptional.get();\n            if (!user.getProvider().equals(AuthProvider.valueOf(userRequest.getClientRegistration().getRegistrationId()))) {\n                throw new OAuth2AuthenticationProcessingException("Looks like you\'re signed up with " +\n                    user.getProvider() + " account. Please use your " + user.getProvider() +\n                    " account to login.");\n            }\n            user = updateExistingUser(user, oauth2UserInfo);\n        } else {\n            user = registerNewUser(userRequest, oauth2UserInfo);\n        }\n\n        return UserPrincipal.create(user, oauth2User.getAttributes());\n    }\n\n    private User registerNewUser(OAuth2UserRequest userRequest, OAuth2UserInfo oauth2UserInfo) {\n        User user = new User();\n        user.setProvider(AuthProvider.valueOf(userRequest.getClientRegistration().getRegistrationId()));\n        user.setProviderId(oauth2UserInfo.getId());\n        user.setName(oauth2UserInfo.getName());\n        user.setEmail(oauth2UserInfo.getEmail());\n        user.setImageUrl(oauth2UserInfo.getImageUrl());\n        return userRepository.save(user);\n    }\n\n    private User updateExistingUser(User existingUser, OAuth2UserInfo oauth2UserInfo) {\n        existingUser.setName(oauth2UserInfo.getName());\n        existingUser.setImageUrl(oauth2UserInfo.getImageUrl());\n        return userRepository.save(existingUser);\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"security-best-practices",children:"Security Best Practices"}),"\n",(0,r.jsx)(n.h3,{id:"1-password-security",children:"1. Password Security"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Configuration\npublic class PasswordPolicyConfig {\n\n    @Bean\n    public PasswordEncoder passwordEncoder() {\n        // Use BCrypt with strength 12 for production\n        return new BCryptPasswordEncoder(12);\n    }\n\n    @Bean\n    public PasswordValidator passwordValidator() {\n        return new PasswordValidator(Arrays.asList(\n            new LengthRule(8, 128),\n            new CharacterRule(EnglishCharacterData.UpperCase, 1),\n            new CharacterRule(EnglishCharacterData.LowerCase, 1),\n            new CharacterRule(EnglishCharacterData.Digit, 1),\n            new CharacterRule(EnglishCharacterData.Special, 1),\n            new WhitespaceRule()\n        ));\n    }\n}\n\n@Service\npublic class PasswordService {\n\n    @Autowired\n    private PasswordValidator passwordValidator;\n\n    @Autowired\n    private PasswordEncoder passwordEncoder;\n\n    @Autowired\n    private PasswordHistoryRepository passwordHistoryRepository;\n\n    public void validateAndChangePassword(String username, String newPassword) {\n        // Validate password strength\n        RuleResult result = passwordValidator.validate(new PasswordData(newPassword));\n        if (!result.isValid()) {\n            throw new WeakPasswordException(passwordValidator.getMessages(result));\n        }\n\n        // Check password history (prevent reuse of last 5 passwords)\n        List<String> passwordHistory = passwordHistoryRepository.getLastPasswords(username, 5);\n        for (String oldPassword : passwordHistory) {\n            if (passwordEncoder.matches(newPassword, oldPassword)) {\n                throw new PasswordReuseException("Cannot reuse recent passwords");\n            }\n        }\n\n        // Save new password\n        String encodedPassword = passwordEncoder.encode(newPassword);\n        userService.updatePassword(username, encodedPassword);\n\n        // Store in password history\n        passwordHistoryRepository.save(new PasswordHistory(username, encodedPassword));\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"2-account-lockout-and-rate-limiting",children:"2. Account Lockout and Rate Limiting"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Service\npublic class AccountLockoutService {\n\n    private static final int MAX_ATTEMPTS = 5;\n    private static final long LOCKOUT_DURATION_MS = 30 * 60 * 1000; // 30 minutes\n\n    @Autowired\n    private RedisTemplate<String, Object> redisTemplate;\n\n    public void recordFailedAttempt(String username) {\n        String key = "failed_attempts:" + username;\n        Integer attempts = (Integer) redisTemplate.opsForValue().get(key);\n\n        if (attempts == null) {\n            attempts = 0;\n        }\n\n        attempts++;\n        redisTemplate.opsForValue().set(key, attempts, Duration.ofMinutes(30));\n\n        if (attempts >= MAX_ATTEMPTS) {\n            lockAccount(username);\n        }\n    }\n\n    public void clearFailedAttempts(String username) {\n        redisTemplate.delete("failed_attempts:" + username);\n    }\n\n    public boolean isAccountLocked(String username) {\n        String lockKey = "account_locked:" + username;\n        return redisTemplate.hasKey(lockKey);\n    }\n\n    private void lockAccount(String username) {\n        String lockKey = "account_locked:" + username;\n        redisTemplate.opsForValue().set(lockKey, "locked", Duration.ofMillis(LOCKOUT_DURATION_MS));\n    }\n\n    public int getFailedAttempts(String username) {\n        String key = "failed_attempts:" + username;\n        Integer attempts = (Integer) redisTemplate.opsForValue().get(key);\n        return attempts != null ? attempts : 0;\n    }\n}\n\n@Component\npublic class RateLimitingFilter extends OncePerRequestFilter {\n\n    @Autowired\n    private RedisTemplate<String, Object> redisTemplate;\n\n    private static final int MAX_REQUESTS_PER_MINUTE = 60;\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest request,\n                                  HttpServletResponse response,\n                                  FilterChain filterChain) throws ServletException, IOException {\n\n        String clientIp = getClientIP(request);\n        String key = "rate_limit:" + clientIp;\n\n        Integer requests = (Integer) redisTemplate.opsForValue().get(key);\n\n        if (requests == null) {\n            requests = 0;\n        }\n\n        if (requests >= MAX_REQUESTS_PER_MINUTE) {\n            response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());\n            response.getWriter().write("Rate limit exceeded");\n            return;\n        }\n\n        redisTemplate.opsForValue().increment(key);\n        redisTemplate.expire(key, Duration.ofMinutes(1));\n\n        filterChain.doFilter(request, response);\n    }\n\n    private String getClientIP(HttpServletRequest request) {\n        String xfHeader = request.getHeader("X-Forwarded-For");\n        if (xfHeader == null) {\n            return request.getRemoteAddr();\n        }\n        return xfHeader.split(",")[0];\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"3-audit-logging",children:"3. Audit Logging"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Entity\n@Table(name = "security_audit_log")\npublic class SecurityAuditLog {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    private String username;\n    private String action;\n    private String details;\n    private String ipAddress;\n    private String userAgent;\n\n    @CreationTimestamp\n    private LocalDateTime timestamp;\n\n    private boolean success;\n\n    // constructors, getters, setters\n}\n\n@Service\npublic class SecurityAuditService {\n\n    @Autowired\n    private SecurityAuditLogRepository auditLogRepository;\n\n    @Async\n    public void logSecurityEvent(String username, String action, String details,\n                                HttpServletRequest request, boolean success) {\n        SecurityAuditLog log = new SecurityAuditLog();\n        log.setUsername(username);\n        log.setAction(action);\n        log.setDetails(details);\n        log.setIpAddress(getClientIP(request));\n        log.setUserAgent(request.getHeader("User-Agent"));\n        log.setSuccess(success);\n\n        auditLogRepository.save(log);\n    }\n\n    private String getClientIP(HttpServletRequest request) {\n        String xfHeader = request.getHeader("X-Forwarded-For");\n        if (xfHeader == null) {\n            return request.getRemoteAddr();\n        }\n        return xfHeader.split(",")[0];\n    }\n}\n\n@EventListener\n@Component\npublic class SecurityEventListener {\n\n    @Autowired\n    private SecurityAuditService auditService;\n\n    @EventListener\n    public void handleAuthenticationSuccess(AuthenticationSuccessEvent event) {\n        String username = event.getAuthentication().getName();\n        HttpServletRequest request = getCurrentRequest();\n\n        auditService.logSecurityEvent(username, "LOGIN_SUCCESS",\n            "User successfully authenticated", request, true);\n    }\n\n    @EventListener\n    public void handleAuthenticationFailure(AbstractAuthenticationFailureEvent event) {\n        String username = event.getAuthentication().getName();\n        HttpServletRequest request = getCurrentRequest();\n\n        auditService.logSecurityEvent(username, "LOGIN_FAILURE",\n            "Authentication failed: " + event.getException().getMessage(), request, false);\n    }\n\n    private HttpServletRequest getCurrentRequest() {\n        RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();\n        if (requestAttributes instanceof ServletRequestAttributes) {\n            return ((ServletRequestAttributes) requestAttributes).getRequest();\n        }\n        return null;\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"4-two-factor-authentication-2fa",children:"4. Two-Factor Authentication (2FA)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Service\npublic class TwoFactorAuthService {\n\n    @Autowired\n    private UserRepository userRepository;\n\n    @Autowired\n    private RedisTemplate<String, Object> redisTemplate;\n\n    public String generateSecretKey() {\n        SecureRandom random = new SecureRandom();\n        byte[] bytes = new byte[20];\n        random.nextBytes(bytes);\n        return Base32.encode(bytes);\n    }\n\n    public String generateQRCodeImageUri(String username, String secretKey) {\n        return String.format(\n            "otpauth://totp/%s?secret=%s&issuer=MyApp",\n            username, secretKey\n        );\n    }\n\n    public boolean validateTOTP(String username, String code) {\n        User user = userRepository.findByUsername(username)\n            .orElseThrow(() -> new UserNotFoundException("User not found"));\n\n        if (!user.isTwoFactorEnabled()) {\n            return true; // 2FA not required for this user\n        }\n\n        String secretKey = user.getTwoFactorSecret();\n        long timeStep = System.currentTimeMillis() / 30000;\n\n        // Check current time step and previous/next for clock skew\n        for (int i = -1; i <= 1; i++) {\n            String expectedCode = generateTOTP(secretKey, timeStep + i);\n            if (code.equals(expectedCode)) {\n                // Check if this code was already used (prevent replay attacks)\n                String usedCodeKey = "used_totp:" + username + ":" + code;\n                if (!redisTemplate.hasKey(usedCodeKey)) {\n                    redisTemplate.opsForValue().set(usedCodeKey, "used", Duration.ofMinutes(2));\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private String generateTOTP(String secretKey, long timeStep) {\n        byte[] data = ByteBuffer.allocate(8).putLong(timeStep).array();\n        byte[] key = Base32.decode(secretKey);\n\n        try {\n            Mac mac = Mac.getInstance("HmacSHA1");\n            mac.init(new SecretKeySpec(key, "HmacSHA1"));\n            byte[] hash = mac.doFinal(data);\n\n            int offset = hash[hash.length - 1] & 0x0f;\n            int code = ((hash[offset] & 0x7f) << 24) |\n                      ((hash[offset + 1] & 0xff) << 16) |\n                      ((hash[offset + 2] & 0xff) << 8) |\n                      (hash[offset + 3] & 0xff);\n\n            return String.format("%06d", code % 1000000);\n        } catch (Exception e) {\n            throw new RuntimeException("Error generating TOTP", e);\n        }\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"5-content-security-policy-csp",children:"5. Content Security Policy (CSP)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Configuration\npublic class SecurityHeadersConfig {\n\n    @Bean\n    public FilterRegistrationBean<SecurityHeadersFilter> securityHeadersFilter() {\n        FilterRegistrationBean<SecurityHeadersFilter> registration = new FilterRegistrationBean<>();\n        registration.setFilter(new SecurityHeadersFilter());\n        registration.addUrlPatterns("/*");\n        return registration;\n    }\n}\n\npublic class SecurityHeadersFilter implements Filter {\n\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n            throws IOException, ServletException {\n\n        HttpServletResponse httpResponse = (HttpServletResponse) response;\n\n        // Content Security Policy\n        httpResponse.setHeader("Content-Security-Policy",\n            "default-src \'self\'; " +\n            "script-src \'self\' \'unsafe-inline\' https://cdnjs.cloudflare.com; " +\n            "style-src \'self\' \'unsafe-inline\'; " +\n            "img-src \'self\' data: https:; " +\n            "font-src \'self\' https:; " +\n            "connect-src \'self\'; " +\n            "frame-ancestors \'none\';");\n\n        // X-Frame-Options\n        httpResponse.setHeader("X-Frame-Options", "DENY");\n\n        // X-Content-Type-Options\n        httpResponse.setHeader("X-Content-Type-Options", "nosniff");\n\n        // X-XSS-Protection\n        httpResponse.setHeader("X-XSS-Protection", "1; mode=block");\n\n        // Strict-Transport-Security (HSTS)\n        httpResponse.setHeader("Strict-Transport-Security",\n            "max-age=31536000; includeSubDomains; preload");\n\n        // Referrer Policy\n        httpResponse.setHeader("Referrer-Policy", "strict-origin-when-cross-origin");\n\n        // Feature Policy\n        httpResponse.setHeader("Permissions-Policy",\n            "camera=(), microphone=(), geolocation=(), payment=()");\n\n        chain.doFilter(request, response);\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"common-security-configurations",children:"Common Security Configurations"}),"\n",(0,r.jsx)(n.h3,{id:"production-application-properties",children:"Production Application Properties"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-properties",children:"# Server configuration\nserver.port=8443\nserver.ssl.enabled=true\nserver.ssl.key-store=classpath:keystore.p12\nserver.ssl.key-store-password=password\nserver.ssl.key-store-type=PKCS12\nserver.ssl.key-alias=myapp\n\n# JWT Configuration\napp.jwtSecret=mySecretKey\napp.jwtExpirationMs=900000\napp.jwtRefreshExpirationMs=86400000\n\n# Database\nspring.datasource.url=jdbc:postgresql://localhost:5432/myapp\nspring.datasource.username=${DB_USERNAME}\nspring.datasource.password=${DB_PASSWORD}\n\n# Redis (for session/rate limiting)\nspring.redis.host=localhost\nspring.redis.port=6379\nspring.redis.password=${REDIS_PASSWORD}\n\n# Logging\nlogging.level.org.springframework.security=DEBUG\nlogging.level.com.myapp.security=DEBUG\n\n# Security headers\nserver.servlet.session.cookie.http-only=true\nserver.servlet.session.cookie.secure=true\nserver.servlet.session.cookie.same-site=strict\n"})}),"\n",(0,r.jsx)(n.h3,{id:"testing-security-configuration",children:"Testing Security Configuration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@SpringBootTest\n@AutoConfigureMockMvc\nclass SecurityConfigTest {\n\n    @Autowired\n    private MockMvc mockMvc;\n\n    @Test\n    void testPublicEndpointAccessible() throws Exception {\n        mockMvc.perform(get("/api/public/test"))\n            .andExpect(status().isOk());\n    }\n\n    @Test\n    void testProtectedEndpointRequiresAuthentication() throws Exception {\n        mockMvc.perform(get("/api/user/profile"))\n            .andExpect(status().isUnauthorized());\n    }\n\n    @Test\n    @WithMockUser(roles = "USER")\n    void testUserEndpointWithUserRole() throws Exception {\n        mockMvc.perform(get("/api/user/profile"))\n            .andExpected(status().isOk());\n    }\n\n    @Test\n    @WithMockUser(roles = "ADMIN")\n    void testAdminEndpointWithAdminRole() throws Exception {\n        mockMvc.perform(get("/api/admin/users"))\n            .andExpected(status().isOk());\n    }\n\n    @Test\n    @WithMockUser(roles = "USER")\n    void testAdminEndpointWithUserRoleForbidden() throws Exception {\n        mockMvc.perform(get("/api/admin/users"))\n            .andExpected(status().isForbidden());\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,r.jsx)(n.h3,{id:"security-checklist",children:"Security Checklist:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Always use HTTPS"})," in production"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Encode passwords"})," with BCrypt (strength \u2265 12)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Implement proper JWT handling"})," with refresh tokens"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use HttpOnly cookies"})," for sensitive data"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Implement role-based access control"})," appropriately"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Add security headers"})," (CSP, HSTS, etc.)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Enable audit logging"})," for security events"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Implement rate limiting"})," and account lockout"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use 2FA"})," for sensitive accounts"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Regular security testing"})," and updates"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"performance-considerations",children:"Performance Considerations:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Cache user details to reduce database calls"}),"\n",(0,r.jsx)(n.li,{children:"Use Redis for session management and rate limiting"}),"\n",(0,r.jsx)(n.li,{children:"Implement proper connection pooling"}),"\n",(0,r.jsx)(n.li,{children:"Monitor JWT token size and claims"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"monitoring-and-alerting",children:"Monitoring and Alerting:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Log all authentication failures"}),"\n",(0,r.jsx)(n.li,{children:"Monitor for suspicious patterns"}),"\n",(0,r.jsx)(n.li,{children:"Set up alerts for multiple failed logins"}),"\n",(0,r.jsx)(n.li,{children:"Track privilege escalation attempts"}),"\n",(0,r.jsx)(n.li,{children:"Monitor for unusual access patterns"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This comprehensive guide covers all major aspects of Spring Security implementation with practical examples and best practices for production applications."})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}}}]);