"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[1711],{8696:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>d,contentTitle:()=>i,default:()=>l,frontMatter:()=>o,metadata:()=>a,toc:()=>c});var s=n(4848),t=n(8453);const o={title:"DFS & BFS on Graphs",description:"A comprehensive guide to implementing Depth-First Search (DFS) & BFS (Breadth-First Search) on graphs."},i=void 0,a={id:"tutorial-basics/DFSBFSGraph",title:"DFS & BFS on Graphs",description:"A comprehensive guide to implementing Depth-First Search (DFS) & BFS (Breadth-First Search) on graphs.",source:"@site/docs/tutorial-basics/DFSBFSGraph.mdx",sourceDirName:"tutorial-basics",slug:"/tutorial-basics/DFSBFSGraph",permalink:"/js.enigma/docs/tutorial-basics/DFSBFSGraph",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/tutorial-basics/DFSBFSGraph.mdx",tags:[],version:"current",frontMatter:{title:"DFS & BFS on Graphs",description:"A comprehensive guide to implementing Depth-First Search (DFS) & BFS (Breadth-First Search) on graphs."},sidebar:"tutorialSidebar",previous:{title:"Cyclic Sort Algorithm",permalink:"/js.enigma/docs/tutorial-basics/CyclicSort"},next:{title:"Depth-First Search (DFS) for Trees",permalink:"/js.enigma/docs/tutorial-basics/DFSTree"}},d={},c=[{value:"Depth-First Search (DFS) on Graphs",id:"depth-first-search-dfs-on-graphs",level:2},{value:"How DFS Works",id:"how-dfs-works",level:2},{value:"Pseudocode",id:"pseudocode",level:3},{value:"Recusrive DFS",id:"recusrive-dfs",level:3},{value:"Iterative DFS",id:"iterative-dfs",level:3},{value:"How BFS Works",id:"how-bfs-works",level:2},{value:"Pseudocode",id:"pseudocode-1",level:3},{value:"BFS",id:"bfs",level:3}];function h(e){const r={code:"code",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.h2,{id:"depth-first-search-dfs-on-graphs",children:"Depth-First Search (DFS) on Graphs"}),"\n",(0,s.jsx)(r.p,{children:"Depth-First Search (DFS) is a fundamental algorithm for traversing or searching through graph data structures. The algorithm starts at a given node and explores as far as possible along each branch before backtracking."}),"\n",(0,s.jsx)(r.h2,{id:"how-dfs-works",children:"How DFS Works"}),"\n",(0,s.jsx)(r.p,{children:"DFS can be implemented using either a recursive approach or an iterative approach with a stack. The key idea is to start from a source node, visit its adjacent nodes, and continue this process until all nodes reachable from the source are visited."}),"\n",(0,s.jsx)(r.h3,{id:"pseudocode",children:"Pseudocode"}),"\n",(0,s.jsx)(r.p,{children:"Here's the pseudocode for a recursive DFS on an undirected graph:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-Javascript",children:"const graph = {\r\n  A: ['B', 'C'],\r\n  B: ['A', 'D', 'E'],\r\n  C: ['A', 'F'],\r\n  D: ['B'],\r\n  E: ['B'],\r\n  F: ['C'],\r\n  G: ['L'],\r\n  M: ['S']\r\n};\n"})}),"\n",(0,s.jsx)(r.h3,{id:"recusrive-dfs",children:"Recusrive DFS"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-Javascript",children:"const dfs = (graph, startNode, visited = new Set()) => {\r\n  visited.add(startNode);\r\n  console.log(startNode);\r\n\r\n  for (const neighbour of graph[startNode] || []) {\r\n    if (!visited.has(neighbour)) {\r\n      dfs(graph, neighbour, visited);\r\n    }\r\n  }\r\n};\r\n\r\nconst visited = new Set();\r\n\r\n// To handle disconnected components, loop through all nodes\r\nfor (const node of Object.keys(graph)) {\r\n  if (!visited.has(node)) {\r\n    dfs(graph, node, visited);\r\n  }\r\n}\n"})}),"\n",(0,s.jsx)(r.h3,{id:"iterative-dfs",children:"Iterative DFS"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-Javascript",children:"const dfsIterative = (graph, start, visited = new Set()) => {\r\n  const stack = [start]\r\n  visited.add(start)\r\n\r\n  while (stack.length) {\r\n    const current = stack.pop()\r\n    console.log(current);\r\n    for (const neighbour of graph[current]) {\r\n      if (!visited.has(neighbour)) {\r\n        stack.push(neighbour)\r\n        visited.add(neighbour)\r\n      }\r\n    }\r\n\r\n  }\r\n}\r\n\r\n// To handle disconnected components, loop through all nodes\r\nconst allNodes = new Set(Object.keys(graph));\r\nconst visited = new Set();\r\n\r\nfor (const node of allNodes) {\r\n  if (!visited.has(node)) {\r\n    dfsIterative(graph, node, visited);\r\n  }\r\n}\n"})}),"\n",(0,s.jsx)(r.h1,{id:"breadth-first-search-bfs-on-graphs",children:"Breadth-First Search (BFS) on Graphs"}),"\n",(0,s.jsx)(r.p,{children:"Breadth-First Search (BFS) is an algorithm used for traversing or searching through graph or tree data structures. The algorithm starts at a given node and explores all of its neighbors at the present depth before moving on to nodes at the next depth level."}),"\n",(0,s.jsx)(r.h2,{id:"how-bfs-works",children:"How BFS Works"}),"\n",(0,s.jsx)(r.p,{children:"BFS is typically implemented using a queue data structure. It starts from a source node and explores all of its neighbors first before moving on to the next layer of nodes. This ensures that nodes are visited in the order of their distance from the source node."}),"\n",(0,s.jsx)(r.h3,{id:"pseudocode-1",children:"Pseudocode"}),"\n",(0,s.jsx)(r.p,{children:"Here\u2019s the pseudocode for BFS on an undirected graph:"}),"\n",(0,s.jsx)(r.h3,{id:"bfs",children:"BFS"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-Javascript",children:"const bfs = (graph, start, visited = new Set()) => {\r\n  const queue = [start]\r\n  visited.add(start)\r\n\r\n  while (queue.length) {\r\n    const current = queue.shift()\r\n    console.log(current);\r\n    for (const neighbour of graph[current]) {\r\n      if (!visited.has(neighbour)) {\r\n        queue.push(neighbour)\r\n        visited.add(neighbour)\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// To handle disconnected components, loop through all nodes\r\nconst allNodes = new Set(Object.keys(graph));\r\nconst visited = new Set();\r\n\r\nfor (const node of allNodes) {\r\n  if (!visited.has(node)) {\r\n    bfs(graph, node, visited);\r\n  }\r\n}\n"})})]})}function l(e={}){const{wrapper:r}={...(0,t.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>i,x:()=>a});var s=n(6540);const t={},o=s.createContext(t);function i(e){const r=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),s.createElement(o.Provider,{value:r},e.children)}}}]);