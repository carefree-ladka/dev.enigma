"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[7359],{28453:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>o});var r=t(96540);const s={},a=r.createContext(s);function c(e){const n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),r.createElement(a.Provider,{value:n},e.children)}},76657:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>d,frontMatter:()=>a,metadata:()=>o,toc:()=>i});var r=t(74848),s=t(28453);const a={},c="React Hooks Polyfills",o={id:"WebDev/React/HooksPolyfills",title:"React Hooks Polyfills",description:"useState",source:"@site/docs/WebDev/React/HooksPolyfills.mdx",sourceDirName:"WebDev/React",slug:"/WebDev/React/HooksPolyfills",permalink:"/docs/WebDev/React/HooksPolyfills",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/WebDev/React/HooksPolyfills.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"React Functional Component Lifecycle",permalink:"/docs/WebDev/React/FunctionalComponentsLifeCycle"},next:{title:"React Lifecycle Methods",permalink:"/docs/WebDev/React/LifeCycleMethods"}},l={},i=[{value:"useState",id:"usestate",level:2},{value:"useEffect",id:"useeffect",level:2},{value:"useMemo",id:"usememo",level:2},{value:"useCallback",id:"usecallback",level:2},{value:"React.memo",id:"reactmemo",level:2}];function u(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",pre:"pre",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"react-hooks-polyfills",children:"React Hooks Polyfills"})}),"\n",(0,r.jsx)(n.h2,{id:"usestate",children:"useState"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-JavaScript",children:'  const useMyState = (initialValue) => {\n    const hookIdTrackerRef = React.useRef(0); // Component-specific tracker\n    const statesRef = React.useRef([]); // Component-specific state storage\n\n    const localHookId = hookIdTrackerRef.current++; // Assign unique ID for this hook\n\n    // Initialize state lazily\n    if (statesRef.current[localHookId] === undefined) {\n      statesRef.current[localHookId] =\n        typeof initialValue === "function" ? initialValue() : initialValue;\n    }\n\n    const currentState = statesRef.current[localHookId]; // Get the current state\n\n    const [, rerender] = useReducer(() => ({}), {}); // Trigger re-render\n\n    const setValue = (newValue) => {\n      // If newValue is a function, compute based on the current state\n      if (typeof newValue === "function") {\n        newValue = newValue(statesRef.current[localHookId]);\n      }\n\n      // Check for state change\n      const isValueChanged = !Object.is(newValue, statesRef.current[localHookId]);\n      if (isValueChanged) {\n        statesRef.current[localHookId] = newValue; // Update state\n        hookIdTrackerRef.current = 0;\n        rerender({}); // Trigger re-render\n      }\n    };\n\n    return [currentState, setValue];\n  };\n'})}),"\n",(0,r.jsx)(n.h2,{id:"useeffect",children:"useEffect"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-JavaScript",children:'  const myEffect = (callback, depsArray) => {\n    const firstRenderRef = React.useRef(true); // Tracks if it\'s the first render\n    const prevDepsRef = React.useRef([]); // Stores the previous dependencies\n    const cleanupRef = React.useRef(null); // Stores the cleanup function\n\n    // Handle first render\n    if (firstRenderRef.current) {\n      firstRenderRef.current = false;\n      cleanupRef.current = callback(); // Call effect\n      prevDepsRef.current = depsArray ?? []; // Store dependencies\n      return;\n    }\n\n    // Check if dependencies have changed\n    const haveDepsChanged =\n      !depsArray ||\n      depsArray.some((dep, i) => !Object.is(dep, prevDepsRef.current[i]));\n\n    // Cleanup and invoke callback if dependencies changed\n    if (haveDepsChanged) {\n      if (typeof cleanupRef.current === "function") {\n        cleanupRef.current(); // Call cleanup\n      }\n      cleanupRef.current = callback(); // Call effect\n    }\n\n    prevDepsRef.current = depsArray || []; // Update dependencies\n  };\n'})}),"\n",(0,r.jsx)(n.h2,{id:"usememo",children:"useMemo"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-JavaScript",children:"function useMemo(factory, deps) {\n  const ref = React.useRef({ deps: undefined, value: undefined })\n\n  function areEqual(oldDeps, newDeps) {\n    if (!oldDeps || oldDeps.length !== newDeps.length) return false\n    return oldDeps.every((dep, i) => Object.is(dep, newDeps[i]))\n  }\n\n  if (!areEqual(ref.current.deps, deps)) {\n    ref.current.value = factory()\n    ref.current.deps = deps\n  }\n\n  return ref.current.value\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"usecallback",children:"useCallback"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-JavaScript",children:"import * as React from 'react'\n\nfunction useCallback(callback, deps) {\n  const ref = React.useRef({ deps: undefined, memoizedCallback: null });\n\n  function areDepsEqual(oldDeps, newDeps) {\n    if (!oldDeps || oldDeps.length !== newDeps.length) return false;\n    return oldDeps.every((dep, i) => Object.is(dep, newDeps[i]));\n  }\n\n  if (!areDepsEqual(ref.current.deps, deps)) {\n    ref.current.memoizedCallback = callback;\n    ref.current.deps = deps;\n  }\n\n  return ref.current.memoizedCallback;\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"reactmemo",children:"React.memo"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-JavaScript",children:'function memo(Component, areEqual) {\n  class MemoizedComponent extends React.Component {\n    static displayName = `Memo(${\n      Component.displayName || Component.name || "Component"\n    })`;\n\n    shouldComponentUpdate(nextProps) {\n      if (areEqual) {\n        return !areEqual(this.props, nextProps);\n      }\n\n      // When no areEqual is provided, do a shallow props comparison\n      const prevProps = this.props;\n      if (Object.keys(prevProps).length !== Object.keys(nextProps).length) {\n        return true;\n      }\n      for (const key in nextProps) {\n        if (prevProps[key] !== nextProps[key]) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    render() {\n      return React.createElement(Component, this.props);\n    }\n  }\n\n  return Object.assign(MemoizedComponent, Component);\n}\n'})})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}}}]);