"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[386],{28453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>o});var i=t(96540);const s={},r=i.createContext(s);function l(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),i.createElement(r.Provider,{value:n},e.children)}},68723:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>a});var i=t(74848),s=t(28453);const r={},l="SortedList",o={id:"DSA/DSA with JavaScript/SortedList",title:"SortedList",description:"An array-based implementation that maintains elements in sorted order.",source:"@site/docs/DSA/DSA with JavaScript/SortedList.mdx",sourceDirName:"DSA/DSA with JavaScript",slug:"/DSA/DSA with JavaScript/SortedList",permalink:"/dev.enigma/docs/DSA/DSA with JavaScript/SortedList",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with JavaScript/SortedList.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Fast and Slow Pointers Technique",permalink:"/dev.enigma/docs/DSA/DSA with JavaScript/SlowFastPointer"},next:{title:"Stack",permalink:"/dev.enigma/docs/DSA/DSA with JavaScript/Stack"}},d={},a=[{value:"Purpose",id:"purpose",level:3},{value:"Common Methods",id:"common-methods",level:3},{value:"Example Usage",id:"example-usage",level:3},{value:"When to Use Each",id:"when-to-use-each",level:3},{value:"Performance Comparison",id:"performance-comparison",level:3}];function c(e){const n={code:"code",h1:"h1",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"sortedlist",children:"SortedList"})}),"\n",(0,i.jsx)(n.p,{children:"An array-based implementation that maintains elements in sorted order."}),"\n",(0,i.jsx)(n.h3,{id:"purpose",children:"Purpose"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Maintains elements in sorted order using an array"}),"\n",(0,i.jsx)(n.li,{children:"Provides fast index-based access"}),"\n",(0,i.jsx)(n.li,{children:"Allows duplicates"}),"\n",(0,i.jsx)(n.li,{children:"Better for smaller collections with frequent access by index"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"common-methods",children:"Common Methods"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"const list = new SortedList();\n\n// Basic Operations\nlist.add(item); // Add item while maintaining sort order\nlist.remove(item); // Remove first occurrence of item\nlist.get(index); // Get item at index\nlist.indexOf(item); // Find index of item\nlist.clear(); // Remove all items\nlist.size(); // Get number of items\nlist.isEmpty(); // Check if list is empty\n\n// Navigation\nlist.first(); // Get first item\nlist.last(); // Get last item\nlist.ceiling(item); // Get smallest item \u2265 given item\nlist.floor(item); // Get largest item \u2264 given item\n\n// Conversion\nlist.toArray(); // Convert to array\n"})}),"\n",(0,i.jsx)(n.h3,{id:"example-usage",children:"Example Usage"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"const list = new SortedList();\nlist.add(3);\nlist.add(1);\nlist.add(2);\n\nconsole.log(list.get(1)); // 2\nconsole.log(list.ceiling(1.5)); // 2\nconsole.log(list.floor(2.5)); // 2\nconsole.log(list.toArray()); // [1, 2, 3]\n"})}),"\n",(0,i.jsx)(n.h1,{id:"sortedlist-implementation",children:"SortedList Implementation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-JavaScript",children:"class SortedList {\n  constructor(comparator = (a, b) => a - b) {\n    this.items = [];\n    this.comparator = comparator;\n  }\n\n  // Add item while maintaining sort order - O(n)\n  add(item) {\n    const index = this.#findInsertionPoint(item);\n    this.items.splice(index, 0, item);\n    return this;\n  }\n\n  // Binary search to find insertion point - O(log n)\n  #findInsertionPoint(item) {\n    let left = 0;\n    let right = this.items.length;\n\n    while (left < right) {\n      const mid = (left + right) >> 1;\n      if (this.comparator(this.items[mid], item) <= 0) {\n        left = mid + 1;\n      } else {\n        right = mid;\n      }\n    }\n    return left;\n  }\n\n  // Remove first occurrence of item - O(n)\n  remove(item) {\n    const index = this.indexOf(item);\n    if (index !== -1) {\n      this.items.splice(index, 1);\n      return true;\n    }\n    return false;\n  }\n\n  // Binary search to find item - O(log n)\n  indexOf(item) {\n    let left = 0;\n    let right = this.items.length - 1;\n\n    while (left <= right) {\n      const mid = (left + right) >> 1;\n      const cmp = this.comparator(this.items[mid], item);\n\n      if (cmp === 0) return mid;\n      if (cmp < 0) left = mid + 1;\n      else right = mid - 1;\n    }\n    return -1;\n  }\n\n  // Get item at index - O(1)\n  get(index) {\n    if (index < 0 || index >= this.items.length) return undefined;\n    return this.items[index];\n  }\n\n  // Get first item greater than or equal to given item\n  ceiling(item) {\n    const index = this.#findInsertionPoint(item);\n    return index < this.items.length ? this.items[index] : undefined;\n  }\n\n  // Get last item less than or equal to given item\n  floor(item) {\n    const index = this.#findInsertionPoint(item);\n    return index > 0 ? this.items[index - 1] : undefined;\n  }\n\n  // Get first item\n  first() {\n    return this.items[0];\n  }\n\n  // Get last item\n  last() {\n    return this.items[this.items.length - 1];\n  }\n\n  // Get size\n  size() {\n    return this.items.length;\n  }\n\n  // Check if empty\n  isEmpty() {\n    return this.items.length === 0;\n  }\n\n  // Clear all items\n  clear() {\n    this.items = [];\n  }\n\n  // Convert to array\n  toArray() {\n    return [...this.items];\n  }\n\n  // Iterator\n  *[Symbol.iterator]() {\n    yield* this.items;\n  }\n}\n\nconst list = new SortedList();\nlist.add(5);\nlist.add(3);\nlist.add(7);\nconsole.log(list.toArray());  // [3, 5, 7]\nconsole.log(list.ceiling(4)); // 5\nconsole.log(list.floor(6));   // 5\nlist.remove(5);\nconsole.log(list.toArray());  // [3, 7]\n"})}),"\n",(0,i.jsx)(n.h3,{id:"when-to-use-each",children:"When to Use Each"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"SortedList"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Need index-based access"}),"\n",(0,i.jsx)(n.li,{children:"Working with smaller datasets"}),"\n",(0,i.jsx)(n.li,{children:"Memory efficiency is important"}),"\n",(0,i.jsx)(n.li,{children:"Allow duplicates"}),"\n",(0,i.jsx)(n.li,{children:"Frequent iterations over the entire collection"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"performance-comparison",children:"Performance Comparison"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Operation"}),(0,i.jsx)(n.th,{children:"TreeMap/Set"}),(0,i.jsx)(n.th,{children:"SortedList"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Insert"}),(0,i.jsx)(n.td,{children:"O(log n)"}),(0,i.jsx)(n.td,{children:"O(n)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Delete"}),(0,i.jsx)(n.td,{children:"O(log n)"}),(0,i.jsx)(n.td,{children:"O(n)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Search"}),(0,i.jsx)(n.td,{children:"O(log n)"}),(0,i.jsx)(n.td,{children:"O(log n)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Access"}),(0,i.jsx)(n.td,{children:"O(log n)"}),(0,i.jsx)(n.td,{children:"O(1)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Min/Max"}),(0,i.jsx)(n.td,{children:"O(log n)"}),(0,i.jsx)(n.td,{children:"O(1)"})]})]})]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);