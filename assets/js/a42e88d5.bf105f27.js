"use strict";(globalThis.webpackChunkdev_enigma=globalThis.webpackChunkdev_enigma||[]).push([[76514],{28453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>l});var t=i(96540);const r={},a=t.createContext(r);function s(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),t.createElement(a.Provider,{value:n},e.children)}},96946:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>p,frontMatter:()=>a,metadata:()=>l,toc:()=>u});var t=i(74848),r=i(28453);const a={},s="Binary Heap",l={id:"DSA/DSA/DSA with Java/Binary Heap Patterns",title:"Binary Heap",description:"Table of Contents",source:"@site/docs/05-DSA/DSA/DSA with Java/Binary Heap Patterns.mdx",sourceDirName:"05-DSA/DSA/DSA with Java",slug:"/DSA/DSA/DSA with Java/Binary Heap Patterns",permalink:"/docs/DSA/DSA/DSA with Java/Binary Heap Patterns",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/05-DSA/DSA/DSA with Java/Binary Heap Patterns.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Backtracking",permalink:"/docs/DSA/DSA/DSA with Java/Backtracking Patterns"},next:{title:"Binary Search",permalink:"/docs/DSA/DSA/DSA with Java/Binary Search Patterns"}},o={},u=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Heap Fundamentals",id:"heap-fundamentals",level:2},{value:"Basic Heap Implementation",id:"basic-heap-implementation",level:3},{value:"Java PriorityQueue Usage",id:"java-priorityqueue-usage",level:3},{value:"Pattern 1: Top K Elements",id:"pattern-1-top-k-elements",level:2},{value:"1.1 Kth Largest Element in Array",id:"11-kth-largest-element-in-array",level:3},{value:"1.2 Top K Frequent Elements",id:"12-top-k-frequent-elements",level:3},{value:"1.3 K Largest Elements in Stream",id:"13-k-largest-elements-in-stream",level:3},{value:"1.4 K Smallest Elements",id:"14-k-smallest-elements",level:3},{value:"1.5 Find K Pairs with Smallest Sums",id:"15-find-k-pairs-with-smallest-sums",level:3},{value:"Pattern 2: K-Way Merge",id:"pattern-2-k-way-merge",level:2},{value:"2.1 Merge K Sorted Lists",id:"21-merge-k-sorted-lists",level:3},{value:"2.2 Merge K Sorted Arrays",id:"22-merge-k-sorted-arrays",level:3},{value:"2.3 Smallest Range Covering Elements from K Lists",id:"23-smallest-range-covering-elements-from-k-lists",level:3},{value:"2.4 Kth Smallest Element in Sorted Matrix",id:"24-kth-smallest-element-in-sorted-matrix",level:3},{value:"Pattern 3: Two Heaps (Median)",id:"pattern-3-two-heaps-median",level:2},{value:"3.1 Find Median from Data Stream",id:"31-find-median-from-data-stream",level:3},{value:"3.2 Sliding Window Median",id:"32-sliding-window-median",level:3},{value:"3.3 IPO (Initial Public Offering)",id:"33-ipo-initial-public-offering",level:3},{value:"Pattern 4: Priority Queue Scheduling",id:"pattern-4-priority-queue-scheduling",level:2},{value:"4.1 Task Scheduler",id:"41-task-scheduler",level:3},{value:"4.2 Rearrange String k Distance Apart",id:"42-rearrange-string-k-distance-apart",level:3},{value:"4.3 Meeting Rooms II",id:"43-meeting-rooms-ii",level:3},{value:"4.4 Employee Free Time",id:"44-employee-free-time",level:3},{value:"Pattern 5: Heap Sort &amp; Variations",id:"pattern-5-heap-sort--variations",level:2},{value:"5.1 Heap Sort Implementation",id:"51-heap-sort-implementation",level:3},{value:"5.2 Sort Characters by Frequency",id:"52-sort-characters-by-frequency",level:3},{value:"5.3 Sort Array by Increasing Frequency",id:"53-sort-array-by-increasing-frequency",level:3},{value:"5.4 Wiggle Sort II",id:"54-wiggle-sort-ii",level:3},{value:"Pattern 6: Stream Processing",id:"pattern-6-stream-processing",level:2},{value:"6.1 Running Median of Stream",id:"61-running-median-of-stream",level:3},{value:"6.2 Kth Largest in Stream",id:"62-kth-largest-in-stream",level:3},{value:"6.3 Maximum Average Pass Ratio",id:"63-maximum-average-pass-ratio",level:3},{value:"Pattern 7: Frequency Based Problems",id:"pattern-7-frequency-based-problems",level:2},{value:"7.1 Top K Frequent Words",id:"71-top-k-frequent-words",level:3},{value:"7.2 Reorganize String",id:"72-reorganize-string",level:3},{value:"7.3 Find K Most Frequent Elements in Array",id:"73-find-k-most-frequent-elements-in-array",level:3},{value:"Pattern 8: Distance &amp; Proximity",id:"pattern-8-distance--proximity",level:2},{value:"8.1 K Closest Points to Origin",id:"81-k-closest-points-to-origin",level:3},{value:"8.2 Find K Closest Elements",id:"82-find-k-closest-elements",level:3},{value:"8.3 Minimum Cost to Connect Sticks",id:"83-minimum-cost-to-connect-sticks",level:3},{value:"8.4 Minimum Cost to Hire K Workers",id:"84-minimum-cost-to-hire-k-workers",level:3},{value:"Pattern 9: Custom Comparator Patterns",id:"pattern-9-custom-comparator-patterns",level:2},{value:"9.1 Car Pooling",id:"91-car-pooling",level:3},{value:"9.2 Process Tasks Using Servers",id:"92-process-tasks-using-servers",level:3},{value:"9.3 Single-Threaded CPU",id:"93-single-threaded-cpu",level:3},{value:"Pattern 10: Range &amp; Window Problems",id:"pattern-10-range--window-problems",level:2},{value:"10.1 Maximum Sliding Window",id:"101-maximum-sliding-window",level:3},{value:"10.2 Sliding Window Maximum using Heap",id:"102-sliding-window-maximum-using-heap",level:3},{value:"10.3 Smallest Range Covering K Lists",id:"103-smallest-range-covering-k-lists",level:3},{value:"Pattern 11: Graph Algorithms with Heaps",id:"pattern-11-graph-algorithms-with-heaps",level:2},{value:"11.1 Dijkstra&#39;s Algorithm",id:"111-dijkstras-algorithm",level:3},{value:"11.2 Network Delay Time",id:"112-network-delay-time",level:3},{value:"11.3 Path with Maximum Minimum Value",id:"113-path-with-maximum-minimum-value",level:3},{value:"Pattern 12: Advanced Heap Patterns",id:"pattern-12-advanced-heap-patterns",level:2},{value:"12.1 Trapping Rain Water II",id:"121-trapping-rain-water-ii",level:3},{value:"12.2 Skyline Problem",id:"122-skyline-problem",level:3},{value:"12.3 Maximum Performance Team",id:"123-maximum-performance-team",level:3},{value:"12.4 Minimum Number of Refueling Stops",id:"124-minimum-number-of-refueling-stops",level:3},{value:"Time Complexity Reference",id:"time-complexity-reference",level:2},{value:"Common Heap Patterns Summary",id:"common-heap-patterns-summary",level:2}];function m(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"binary-heap",children:"Binary Heap"})}),"\n",(0,t.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#heap-fundamentals",children:"Heap Fundamentals"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-1-top-k-elements",children:"Pattern 1: Top K Elements"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-2-k-way-merge",children:"Pattern 2: K-Way Merge"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-3-two-heaps-median",children:"Pattern 3: Two Heaps (Median)"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-4-priority-queue-scheduling",children:"Pattern 4: Priority Queue Scheduling"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-5-heap-sort--variations",children:"Pattern 5: Heap Sort & Variations"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-6-stream-processing",children:"Pattern 6: Stream Processing"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-7-frequency-based-problems",children:"Pattern 7: Frequency Based Problems"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-8-distance--proximity",children:"Pattern 8: Distance & Proximity"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-9-custom-comparator-patterns",children:"Pattern 9: Custom Comparator Patterns"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-10-range--window-problems",children:"Pattern 10: Range & Window Problems"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-11-graph-algorithms-with-heaps",children:"Pattern 11: Graph Algorithms with Heaps"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-12-advanced-heap-patterns",children:"Pattern 12: Advanced Heap Patterns"})}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"heap-fundamentals",children:"Heap Fundamentals"}),"\n",(0,t.jsx)(n.h3,{id:"basic-heap-implementation",children:"Basic Heap Implementation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'class MinHeap {\n    private List<Integer> heap;\n\n    public MinHeap() {\n        heap = new ArrayList<>();\n    }\n\n    private int parent(int i) { return (i - 1) / 2; }\n    private int leftChild(int i) { return 2 * i + 1; }\n    private int rightChild(int i) { return 2 * i + 2; }\n\n    private void swap(int i, int j) {\n        int temp = heap.get(i);\n        heap.set(i, heap.get(j));\n        heap.set(j, temp);\n    }\n\n    public void insert(int val) {\n        heap.add(val);\n        int current = heap.size() - 1;\n\n        // Bubble up\n        while (current > 0 && heap.get(current) < heap.get(parent(current))) {\n            swap(current, parent(current));\n            current = parent(current);\n        }\n    }\n\n    public int extractMin() {\n        if (heap.isEmpty()) throw new RuntimeException("Heap is empty");\n\n        int min = heap.get(0);\n        int lastElement = heap.remove(heap.size() - 1);\n\n        if (!heap.isEmpty()) {\n            heap.set(0, lastElement);\n            heapifyDown(0);\n        }\n\n        return min;\n    }\n\n    private void heapifyDown(int index) {\n        while (true) {\n            int left = leftChild(index);\n            int right = rightChild(index);\n            int smallest = index;\n\n            if (left < heap.size() && heap.get(left) < heap.get(smallest)) {\n                smallest = left;\n            }\n\n            if (right < heap.size() && heap.get(right) < heap.get(smallest)) {\n                smallest = right;\n            }\n\n            if (smallest == index) break;\n\n            swap(index, smallest);\n            index = smallest;\n        }\n    }\n\n    public int peek() {\n        if (heap.isEmpty()) throw new RuntimeException("Heap is empty");\n        return heap.get(0);\n    }\n\n    public boolean isEmpty() { return heap.isEmpty(); }\n    public int size() { return heap.size(); }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"java-priorityqueue-usage",children:"Java PriorityQueue Usage"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Min heap (default)\nPriorityQueue<Integer> minHeap = new PriorityQueue<>();\n\n// Max heap\nPriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\n\n// Custom comparator\nPriorityQueue<int[]> customHeap = new PriorityQueue<>((a, b) -> a[0] - b[0]);\n\n// Common operations\nminHeap.offer(5);           // Insert\nint min = minHeap.poll();   // Extract min\nint peek = minHeap.peek();  // View min without removing\nboolean empty = minHeap.isEmpty();\nint size = minHeap.size();\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-1-top-k-elements",children:"Pattern 1: Top K Elements"}),"\n",(0,t.jsx)(n.h3,{id:"11-kth-largest-element-in-array",children:"1.1 Kth Largest Element in Array"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"int findKthLargest(int[] nums, int k) {\n    PriorityQueue<Integer> minHeap = new PriorityQueue<>();\n\n    for (int num : nums) {\n        minHeap.offer(num);\n        if (minHeap.size() > k) {\n            minHeap.poll();\n        }\n    }\n\n    return minHeap.peek();\n}\n\n// Alternative using max heap\nint findKthLargestMaxHeap(int[] nums, int k) {\n    PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\n\n    for (int num : nums) {\n        maxHeap.offer(num);\n    }\n\n    for (int i = 0; i < k - 1; i++) {\n        maxHeap.poll();\n    }\n\n    return maxHeap.peek();\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"12-top-k-frequent-elements",children:"1.2 Top K Frequent Elements"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"int[] topKFrequent(int[] nums, int k) {\n    Map<Integer, Integer> frequencyMap = new HashMap<>();\n    for (int num : nums) {\n        frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n    }\n\n    // Min heap based on frequency\n    PriorityQueue<Map.Entry<Integer, Integer>> minHeap =\n        new PriorityQueue<>((a, b) -> a.getValue() - b.getValue());\n\n    for (Map.Entry<Integer, Integer> entry : frequencyMap.entrySet()) {\n        minHeap.offer(entry);\n        if (minHeap.size() > k) {\n            minHeap.poll();\n        }\n    }\n\n    int[] result = new int[k];\n    for (int i = k - 1; i >= 0; i--) {\n        result[i] = minHeap.poll().getKey();\n    }\n\n    return result;\n}\n\n// Using bucket sort approach\nint[] topKFrequentBucket(int[] nums, int k) {\n    Map<Integer, Integer> frequencyMap = new HashMap<>();\n    for (int num : nums) {\n        frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n    }\n\n    List<Integer>[] buckets = new List[nums.length + 1];\n    for (int i = 0; i <= nums.length; i++) {\n        buckets[i] = new ArrayList<>();\n    }\n\n    for (Map.Entry<Integer, Integer> entry : frequencyMap.entrySet()) {\n        buckets[entry.getValue()].add(entry.getKey());\n    }\n\n    List<Integer> result = new ArrayList<>();\n    for (int i = buckets.length - 1; i >= 0 && result.size() < k; i--) {\n        result.addAll(buckets[i]);\n    }\n\n    return result.stream().mapToInt(i -> i).toArray();\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"13-k-largest-elements-in-stream",children:"1.3 K Largest Elements in Stream"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"class KthLargest {\n    private PriorityQueue<Integer> minHeap;\n    private int k;\n\n    public KthLargest(int k, int[] nums) {\n        this.k = k;\n        this.minHeap = new PriorityQueue<>();\n\n        for (int num : nums) {\n            add(num);\n        }\n    }\n\n    public int add(int val) {\n        minHeap.offer(val);\n        if (minHeap.size() > k) {\n            minHeap.poll();\n        }\n        return minHeap.peek();\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"14-k-smallest-elements",children:"1.4 K Smallest Elements"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"int[] kSmallest(int[] nums, int k) {\n    PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\n\n    for (int num : nums) {\n        maxHeap.offer(num);\n        if (maxHeap.size() > k) {\n            maxHeap.poll();\n        }\n    }\n\n    int[] result = new int[k];\n    for (int i = k - 1; i >= 0; i--) {\n        result[i] = maxHeap.poll();\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"15-find-k-pairs-with-smallest-sums",children:"1.5 Find K Pairs with Smallest Sums"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\n    List<List<Integer>> result = new ArrayList<>();\n    if (nums1.length == 0 || nums2.length == 0 || k == 0) return result;\n\n    PriorityQueue<int[]> minHeap = new PriorityQueue<>((a, b) ->\n        (nums1[a[0]] + nums2[a[1]]) - (nums1[b[0]] + nums2[b[1]]));\n\n    // Initialize heap with first row\n    for (int j = 0; j < Math.min(nums2.length, k); j++) {\n        minHeap.offer(new int[]{0, j});\n    }\n\n    while (k > 0 && !minHeap.isEmpty()) {\n        int[] indices = minHeap.poll();\n        int i = indices[0], j = indices[1];\n\n        result.add(Arrays.asList(nums1[i], nums2[j]));\n        k--;\n\n        if (i + 1 < nums1.length) {\n            minHeap.offer(new int[]{i + 1, j});\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-2-k-way-merge",children:"Pattern 2: K-Way Merge"}),"\n",(0,t.jsx)(n.h3,{id:"21-merge-k-sorted-lists",children:"2.1 Merge K Sorted Lists"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"class ListNode {\n    int val;\n    ListNode next;\n    ListNode() {}\n    ListNode(int val) { this.val = val; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}\n\nListNode mergeKLists(ListNode[] lists) {\n    if (lists == null || lists.length == 0) return null;\n\n    PriorityQueue<ListNode> minHeap = new PriorityQueue<>((a, b) -> a.val - b.val);\n\n    // Add first node of each list\n    for (ListNode list : lists) {\n        if (list != null) {\n            minHeap.offer(list);\n        }\n    }\n\n    ListNode dummy = new ListNode(0);\n    ListNode current = dummy;\n\n    while (!minHeap.isEmpty()) {\n        ListNode node = minHeap.poll();\n        current.next = node;\n        current = current.next;\n\n        if (node.next != null) {\n            minHeap.offer(node.next);\n        }\n    }\n\n    return dummy.next;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"22-merge-k-sorted-arrays",children:"2.2 Merge K Sorted Arrays"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"int[] mergeKSortedArrays(int[][] arrays) {\n    PriorityQueue<ArrayElement> minHeap = new PriorityQueue<>((a, b) -> a.value - b.value);\n\n    // Add first element of each array\n    for (int i = 0; i < arrays.length; i++) {\n        if (arrays[i].length > 0) {\n            minHeap.offer(new ArrayElement(arrays[i][0], i, 0));\n        }\n    }\n\n    List<Integer> result = new ArrayList<>();\n\n    while (!minHeap.isEmpty()) {\n        ArrayElement element = minHeap.poll();\n        result.add(element.value);\n\n        int nextIndex = element.index + 1;\n        if (nextIndex < arrays[element.arrayIndex].length) {\n            minHeap.offer(new ArrayElement(\n                arrays[element.arrayIndex][nextIndex],\n                element.arrayIndex,\n                nextIndex\n            ));\n        }\n    }\n\n    return result.stream().mapToInt(i -> i).toArray();\n}\n\nclass ArrayElement {\n    int value;\n    int arrayIndex;\n    int index;\n\n    ArrayElement(int value, int arrayIndex, int index) {\n        this.value = value;\n        this.arrayIndex = arrayIndex;\n        this.index = index;\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"23-smallest-range-covering-elements-from-k-lists",children:"2.3 Smallest Range Covering Elements from K Lists"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"int[] smallestRange(List<List<Integer>> nums) {\n    PriorityQueue<Element> minHeap = new PriorityQueue<>((a, b) -> a.value - b.value);\n    int max = Integer.MIN_VALUE;\n\n    // Initialize heap with first element of each list\n    for (int i = 0; i < nums.size(); i++) {\n        int value = nums.get(i).get(0);\n        minHeap.offer(new Element(value, i, 0));\n        max = Math.max(max, value);\n    }\n\n    int[] result = {0, Integer.MAX_VALUE};\n\n    while (minHeap.size() == nums.size()) {\n        Element element = minHeap.poll();\n\n        // Update result if current range is smaller\n        if (max - element.value < result[1] - result[0]) {\n            result[0] = element.value;\n            result[1] = max;\n        }\n\n        // Add next element from same list\n        if (element.index + 1 < nums.get(element.listIndex).size()) {\n            int nextValue = nums.get(element.listIndex).get(element.index + 1);\n            minHeap.offer(new Element(nextValue, element.listIndex, element.index + 1));\n            max = Math.max(max, nextValue);\n        }\n    }\n\n    return result;\n}\n\nclass Element {\n    int value;\n    int listIndex;\n    int index;\n\n    Element(int value, int listIndex, int index) {\n        this.value = value;\n        this.listIndex = listIndex;\n        this.index = index;\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"24-kth-smallest-element-in-sorted-matrix",children:"2.4 Kth Smallest Element in Sorted Matrix"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"int kthSmallest(int[][] matrix, int k) {\n    int n = matrix.length;\n    PriorityQueue<int[]> minHeap = new PriorityQueue<>((a, b) -> a[0] - b[0]);\n\n    // Add first element of each row\n    for (int i = 0; i < n; i++) {\n        minHeap.offer(new int[]{matrix[i][0], i, 0});\n    }\n\n    for (int i = 0; i < k - 1; i++) {\n        int[] element = minHeap.poll();\n        int row = element[1];\n        int col = element[2];\n\n        if (col + 1 < n) {\n            minHeap.offer(new int[]{matrix[row][col + 1], row, col + 1});\n        }\n    }\n\n    return minHeap.peek()[0];\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-3-two-heaps-median",children:"Pattern 3: Two Heaps (Median)"}),"\n",(0,t.jsx)(n.h3,{id:"31-find-median-from-data-stream",children:"3.1 Find Median from Data Stream"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"class MedianFinder {\n    private PriorityQueue<Integer> maxHeap; // left half\n    private PriorityQueue<Integer> minHeap; // right half\n\n    public MedianFinder() {\n        maxHeap = new PriorityQueue<>(Collections.reverseOrder());\n        minHeap = new PriorityQueue<>();\n    }\n\n    public void addNum(int num) {\n        if (maxHeap.isEmpty() || num <= maxHeap.peek()) {\n            maxHeap.offer(num);\n        } else {\n            minHeap.offer(num);\n        }\n\n        // Balance heaps\n        if (maxHeap.size() > minHeap.size() + 1) {\n            minHeap.offer(maxHeap.poll());\n        } else if (minHeap.size() > maxHeap.size() + 1) {\n            maxHeap.offer(minHeap.poll());\n        }\n    }\n\n    public double findMedian() {\n        if (maxHeap.size() == minHeap.size()) {\n            return (maxHeap.peek() + minHeap.peek()) / 2.0;\n        } else if (maxHeap.size() > minHeap.size()) {\n            return maxHeap.peek();\n        } else {\n            return minHeap.peek();\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"32-sliding-window-median",children:"3.2 Sliding Window Median"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"double[] medianSlidingWindow(int[] nums, int k) {\n    double[] result = new double[nums.length - k + 1];\n\n    PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\n    PriorityQueue<Integer> minHeap = new PriorityQueue<>();\n\n    for (int i = 0; i < nums.length; i++) {\n        // Add element\n        addNumber(nums[i], maxHeap, minHeap);\n\n        // Remove element going out of window\n        if (i >= k) {\n            removeNumber(nums[i - k], maxHeap, minHeap);\n        }\n\n        // Calculate median when window is full\n        if (i >= k - 1) {\n            result[i - k + 1] = getMedian(maxHeap, minHeap);\n        }\n    }\n\n    return result;\n}\n\nprivate void addNumber(int num, PriorityQueue<Integer> maxHeap, PriorityQueue<Integer> minHeap) {\n    if (maxHeap.isEmpty() || num <= maxHeap.peek()) {\n        maxHeap.offer(num);\n    } else {\n        minHeap.offer(num);\n    }\n    balanceHeaps(maxHeap, minHeap);\n}\n\nprivate void removeNumber(int num, PriorityQueue<Integer> maxHeap, PriorityQueue<Integer> minHeap) {\n    if (num <= maxHeap.peek()) {\n        maxHeap.remove(num);\n    } else {\n        minHeap.remove(num);\n    }\n    balanceHeaps(maxHeap, minHeap);\n}\n\nprivate void balanceHeaps(PriorityQueue<Integer> maxHeap, PriorityQueue<Integer> minHeap) {\n    if (maxHeap.size() > minHeap.size() + 1) {\n        minHeap.offer(maxHeap.poll());\n    } else if (minHeap.size() > maxHeap.size() + 1) {\n        maxHeap.offer(minHeap.poll());\n    }\n}\n\nprivate double getMedian(PriorityQueue<Integer> maxHeap, PriorityQueue<Integer> minHeap) {\n    if (maxHeap.size() == minHeap.size()) {\n        return ((long) maxHeap.peek() + (long) minHeap.peek()) / 2.0;\n    } else if (maxHeap.size() > minHeap.size()) {\n        return maxHeap.peek();\n    } else {\n        return minHeap.peek();\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"33-ipo-initial-public-offering",children:"3.3 IPO (Initial Public Offering)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"int findMaximizedCapital(int k, int w, int[] profits, int[] capital) {\n    PriorityQueue<int[]> minCapitalHeap = new PriorityQueue<>((a, b) -> a[0] - b[0]);\n    PriorityQueue<Integer> maxProfitHeap = new PriorityQueue<>(Collections.reverseOrder());\n\n    // Initialize with all projects\n    for (int i = 0; i < profits.length; i++) {\n        minCapitalHeap.offer(new int[]{capital[i], profits[i]});\n    }\n\n    int currentCapital = w;\n\n    for (int i = 0; i < k; i++) {\n        // Move all affordable projects to profit heap\n        while (!minCapitalHeap.isEmpty() && minCapitalHeap.peek()[0] <= currentCapital) {\n            int[] project = minCapitalHeap.poll();\n            maxProfitHeap.offer(project[1]);\n        }\n\n        // Pick most profitable project\n        if (maxProfitHeap.isEmpty()) break;\n\n        currentCapital += maxProfitHeap.poll();\n    }\n\n    return currentCapital;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-4-priority-queue-scheduling",children:"Pattern 4: Priority Queue Scheduling"}),"\n",(0,t.jsx)(n.h3,{id:"41-task-scheduler",children:"4.1 Task Scheduler"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"int leastInterval(char[] tasks, int n) {\n    Map<Character, Integer> frequencyMap = new HashMap<>();\n    for (char task : tasks) {\n        frequencyMap.put(task, frequencyMap.getOrDefault(task, 0) + 1);\n    }\n\n    PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\n    maxHeap.addAll(frequencyMap.values());\n\n    Queue<int[]> queue = new LinkedList<>(); // [frequency, availableTime]\n    int time = 0;\n\n    while (!maxHeap.isEmpty() || !queue.isEmpty()) {\n        time++;\n\n        // Add tasks back to heap if cooling period is over\n        if (!queue.isEmpty() && queue.peek()[1] == time) {\n            maxHeap.offer(queue.poll()[0]);\n        }\n\n        if (!maxHeap.isEmpty()) {\n            int frequency = maxHeap.poll() - 1;\n            if (frequency > 0) {\n                queue.offer(new int[]{frequency, time + n + 1});\n            }\n        }\n    }\n\n    return time;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"42-rearrange-string-k-distance-apart",children:"4.2 Rearrange String k Distance Apart"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'String rearrangeString(String s, int k) {\n    if (k <= 1) return s;\n\n    Map<Character, Integer> frequencyMap = new HashMap<>();\n    for (char c : s.toCharArray()) {\n        frequencyMap.put(c, frequencyMap.getOrDefault(c, 0) + 1);\n    }\n\n    PriorityQueue<Map.Entry<Character, Integer>> maxHeap =\n        new PriorityQueue<>((a, b) -> b.getValue() - a.getValue());\n    maxHeap.addAll(frequencyMap.entrySet());\n\n    Queue<Map.Entry<Character, Integer>> queue = new LinkedList<>();\n    StringBuilder result = new StringBuilder();\n\n    while (!maxHeap.isEmpty()) {\n        List<Map.Entry<Character, Integer>> temp = new ArrayList<>();\n\n        for (int i = 0; i < k && !maxHeap.isEmpty(); i++) {\n            Map.Entry<Character, Integer> entry = maxHeap.poll();\n            result.append(entry.getKey());\n            entry.setValue(entry.getValue() - 1);\n\n            if (entry.getValue() > 0) {\n                temp.add(entry);\n            }\n        }\n\n        maxHeap.addAll(temp);\n\n        if (!maxHeap.isEmpty() && temp.size() < k) {\n            return "";\n        }\n    }\n\n    return result.toString();\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"43-meeting-rooms-ii",children:"4.3 Meeting Rooms II"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"int minMeetingRooms(int[][] intervals) {\n    if (intervals == null || intervals.length == 0) return 0;\n\n    Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\n    PriorityQueue<Integer> minHeap = new PriorityQueue<>();\n\n    for (int[] interval : intervals) {\n        if (!minHeap.isEmpty() && minHeap.peek() <= interval[0]) {\n            minHeap.poll();\n        }\n        minHeap.offer(interval[1]);\n    }\n\n    return minHeap.size();\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"44-employee-free-time",children:"4.4 Employee Free Time"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"List<Interval> employeeFreeTime(List<List<Interval>> schedule) {\n    PriorityQueue<IteratorWithIndex> minHeap = new PriorityQueue<>(\n        (a, b) -> a.interval.start - b.interval.start\n    );\n\n    // Initialize heap with first interval of each employee\n    for (int i = 0; i < schedule.size(); i++) {\n        if (!schedule.get(i).isEmpty()) {\n            minHeap.offer(new IteratorWithIndex(schedule.get(i).listIterator(), i));\n        }\n    }\n\n    List<Interval> result = new ArrayList<>();\n    Interval previous = null;\n\n    while (!minHeap.isEmpty()) {\n        IteratorWithIndex entry = minHeap.poll();\n        Interval current = entry.interval;\n\n        if (previous != null && previous.end < current.start) {\n            result.add(new Interval(previous.end, current.start));\n        }\n\n        previous = previous == null || previous.end < current.end ? current : previous;\n\n        if (entry.iterator.hasNext()) {\n            entry.interval = entry.iterator.next();\n            minHeap.offer(entry);\n        }\n    }\n\n    return result;\n}\n\nclass IteratorWithIndex {\n    ListIterator<Interval> iterator;\n    Interval interval;\n    int employeeIndex;\n\n    IteratorWithIndex(ListIterator<Interval> iterator, int employeeIndex) {\n        this.iterator = iterator;\n        this.employeeIndex = employeeIndex;\n        this.interval = iterator.next();\n    }\n}\n\nclass Interval {\n    int start, end;\n    Interval(int start, int end) {\n        this.start = start;\n        this.end = end;\n    }\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-5-heap-sort--variations",children:"Pattern 5: Heap Sort & Variations"}),"\n",(0,t.jsx)(n.h3,{id:"51-heap-sort-implementation",children:"5.1 Heap Sort Implementation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"void heapSort(int[] nums) {\n    int n = nums.length;\n\n    // Build max heap\n    for (int i = n / 2 - 1; i >= 0; i--) {\n        heapify(nums, n, i);\n    }\n\n    // Extract elements one by one\n    for (int i = n - 1; i > 0; i--) {\n        swap(nums, 0, i);\n        heapify(nums, i, 0);\n    }\n}\n\nvoid heapify(int[] nums, int n, int i) {\n    int largest = i;\n    int left = 2 * i + 1;\n    int right = 2 * i + 2;\n\n    if (left < n && nums[left] > nums[largest]) {\n        largest = left;\n    }\n\n    if (right < n && nums[right] > nums[largest]) {\n        largest = right;\n    }\n\n    if (largest != i) {\n        swap(nums, i, largest);\n        heapify(nums, n, largest);\n    }\n}\n\nvoid swap(int[] nums, int i, int j) {\n    int temp = nums[i];\n    nums[i] = nums[j];\n    nums[j] = temp;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"52-sort-characters-by-frequency",children:"5.2 Sort Characters by Frequency"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"String frequencySort(String s) {\n    Map<Character, Integer> frequencyMap = new HashMap<>();\n    for (char c : s.toCharArray()) {\n        frequencyMap.put(c, frequencyMap.getOrDefault(c, 0) + 1);\n    }\n\n    PriorityQueue<Map.Entry<Character, Integer>> maxHeap =\n        new PriorityQueue<>((a, b) -> b.getValue() - a.getValue());\n    maxHeap.addAll(frequencyMap.entrySet());\n\n    StringBuilder result = new StringBuilder();\n    while (!maxHeap.isEmpty()) {\n        Map.Entry<Character, Integer> entry = maxHeap.poll();\n        for (int i = 0; i < entry.getValue(); i++) {\n            result.append(entry.getKey());\n        }\n    }\n\n    return result.toString();\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"53-sort-array-by-increasing-frequency",children:"5.3 Sort Array by Increasing Frequency"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"int[] frequencySort(int[] nums) {\n    Map<Integer, Integer> frequencyMap = new HashMap<>();\n    for (int num : nums) {\n        frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n    }\n\n    return Arrays.stream(nums)\n        .boxed()\n        .sorted((a, b) -> {\n            int freqA = frequencyMap.get(a);\n            int freqB = frequencyMap.get(b);\n            if (freqA != freqB) {\n                return freqA - freqB; // ascending by frequency\n            }\n            return b - a; // descending by value if same frequency\n        })\n        .mapToInt(Integer::intValue)\n        .toArray();\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"54-wiggle-sort-ii",children:"5.4 Wiggle Sort II"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"void wiggleSort(int[] nums) {\n    int n = nums.length;\n    int[] sorted = nums.clone();\n    Arrays.sort(sorted);\n\n    int i = (n + 1) / 2 - 1; // end of first half\n    int j = n - 1; // end of second half\n\n    for (int k = 0; k < n; k++) {\n        if (k % 2 == 0) {\n            nums[k] = sorted[i--];\n        } else {\n            nums[k] = sorted[j--];\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-6-stream-processing",children:"Pattern 6: Stream Processing"}),"\n",(0,t.jsx)(n.h3,{id:"61-running-median-of-stream",children:"6.1 Running Median of Stream"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"class RunningMedian {\n    private PriorityQueue<Integer> maxHeap;\n    private PriorityQueue<Integer> minHeap;\n\n    public RunningMedian() {\n        maxHeap = new PriorityQueue<>(Collections.reverseOrder());\n        minHeap = new PriorityQueue<>();\n    }\n\n    public void addNumber(int num) {\n        if (maxHeap.isEmpty() || num <= maxHeap.peek()) {\n            maxHeap.offer(num);\n        } else {\n            minHeap.offer(num);\n        }\n\n        rebalance();\n    }\n\n    private void rebalance() {\n        if (maxHeap.size() > minHeap.size() + 1) {\n            minHeap.offer(maxHeap.poll());\n        } else if (minHeap.size() > maxHeap.size() + 1) {\n            maxHeap.offer(minHeap.poll());\n        }\n    }\n\n    public double getMedian() {\n        if (maxHeap.size() == minHeap.size()) {\n            return (maxHeap.peek() + minHeap.peek()) / 2.0;\n        }\n        return maxHeap.size() > minHeap.size() ? maxHeap.peek() : minHeap.peek();\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"62-kth-largest-in-stream",children:"6.2 Kth Largest in Stream"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"class KthLargestInStream {\n    private PriorityQueue<Integer> minHeap;\n    private int k;\n\n    public KthLargestInStream(int k, int[] nums) {\n        this.k = k;\n        this.minHeap = new PriorityQueue<>();\n\n        for (int num : nums) {\n            add(num);\n        }\n    }\n\n    public int add(int val) {\n        minHeap.offer(val);\n        if (minHeap.size() > k) {\n            minHeap.poll();\n        }\n        return minHeap.peek();\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"63-maximum-average-pass-ratio",children:"6.3 Maximum Average Pass Ratio"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"double maxAverageRatio(int[][] classes, int extraStudents) {\n    PriorityQueue<double[]> maxHeap = new PriorityQueue<>((a, b) ->\n        Double.compare(b[0], a[0])); // max heap by gain\n\n    for (int[] cls : classes) {\n        double gain = calculateGain(cls[0], cls[1]);\n        maxHeap.offer(new double[]{gain, cls[0], cls[1]});\n    }\n\n    for (int i = 0; i < extraStudents; i++) {\n        double[] top = maxHeap.poll();\n        int pass = (int) top[1] + 1;\n        int total = (int) top[2] + 1;\n        double newGain = calculateGain(pass, total);\n        maxHeap.offer(new double[]{newGain, pass, total});\n    }\n\n    double totalRatio = 0;\n    while (!maxHeap.isEmpty()) {\n        double[] cls = maxHeap.poll();\n        totalRatio += cls[1] / cls[2];\n    }\n\n    return totalRatio / classes.length;\n}\n\nprivate double calculateGain(int pass, int total) {\n    return (double) (pass + 1) / (total + 1) - (double) pass / total;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-7-frequency-based-problems",children:"Pattern 7: Frequency Based Problems"}),"\n",(0,t.jsx)(n.h3,{id:"71-top-k-frequent-words",children:"7.1 Top K Frequent Words"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"List<String> topKFrequent(String[] words, int k) {\n    Map<String, Integer> frequencyMap = new HashMap<>();\n    for (String word : words) {\n        frequencyMap.put(word, frequencyMap.getOrDefault(word, 0) + 1);\n    }\n\n    PriorityQueue<String> minHeap = new PriorityQueue<>((a, b) -> {\n        int freqA = frequencyMap.get(a);\n        int freqB = frequencyMap.get(b);\n        if (freqA != freqB) {\n            return freqA - freqB; // min frequency first\n        }\n        return b.compareTo(a); // lexicographically larger first\n    });\n\n    for (String word : frequencyMap.keySet()) {\n        minHeap.offer(word);\n        if (minHeap.size() > k) {\n            minHeap.poll();\n        }\n    }\n\n    List<String> result = new ArrayList<>();\n    while (!minHeap.isEmpty()) {\n        result.add(0, minHeap.poll());\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"72-reorganize-string",children:"7.2 Reorganize String"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'String reorganizeString(String s) {\n    Map<Character, Integer> frequencyMap = new HashMap<>();\n    for (char c : s.toCharArray()) {\n        frequencyMap.put(c, frequencyMap.getOrDefault(c, 0) + 1);\n    }\n\n    PriorityQueue<Map.Entry<Character, Integer>> maxHeap =\n        new PriorityQueue<>((a, b) -> b.getValue() - a.getValue());\n    maxHeap.addAll(frequencyMap.entrySet());\n\n    StringBuilder result = new StringBuilder();\n    Map.Entry<Character, Integer> previous = null;\n\n    while (!maxHeap.isEmpty()) {\n        Map.Entry<Character, Integer> current = maxHeap.poll();\n        result.append(current.getKey());\n        current.setValue(current.getValue() - 1);\n\n        if (previous != null && previous.getValue() > 0) {\n            maxHeap.offer(previous);\n        }\n\n        previous = current;\n    }\n\n    return result.length() == s.length() ? result.toString() : "";\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"73-find-k-most-frequent-elements-in-array",children:"7.3 Find K Most Frequent Elements in Array"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"List<Integer> findKMostFrequent(int[] nums, int k) {\n    Map<Integer, Integer> frequencyMap = new HashMap<>();\n    for (int num : nums) {\n        frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n    }\n\n    PriorityQueue<Map.Entry<Integer, Integer>> maxHeap =\n        new PriorityQueue<>((a, b) -> b.getValue() - a.getValue());\n    maxHeap.addAll(frequencyMap.entrySet());\n\n    List<Integer> result = new ArrayList<>();\n    for (int i = 0; i < k && !maxHeap.isEmpty(); i++) {\n        result.add(maxHeap.poll().getKey());\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-8-distance--proximity",children:"Pattern 8: Distance & Proximity"}),"\n",(0,t.jsx)(n.h3,{id:"81-k-closest-points-to-origin",children:"8.1 K Closest Points to Origin"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"int[][] kClosest(int[][] points, int k) {\n    PriorityQueue<int[]> maxHeap = new PriorityQueue<>((a, b) ->\n        (b[0] * b[0] + b[1] * b[1]) - (a[0] * a[0] + a[1] * a[1]));\n\n    for (int[] point : points) {\n        maxHeap.offer(point);\n        if (maxHeap.size() > k) {\n            maxHeap.poll();\n        }\n    }\n\n    int[][] result = new int[k][2];\n    for (int i = 0; i < k; i++) {\n        result[i] = maxHeap.poll();\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"82-find-k-closest-elements",children:"8.2 Find K Closest Elements"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"List<Integer> findClosestElements(int[] arr, int k, int x) {\n    PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> {\n        int diffA = Math.abs(a - x);\n        int diffB = Math.abs(b - x);\n        if (diffA != diffB) {\n            return diffB - diffA; // max heap by distance\n        }\n        return b - a; // if same distance, larger value first\n    });\n\n    for (int num : arr) {\n        maxHeap.offer(num);\n        if (maxHeap.size() > k) {\n            maxHeap.poll();\n        }\n    }\n\n    List<Integer> result = new ArrayList<>(maxHeap);\n    Collections.sort(result);\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"83-minimum-cost-to-connect-sticks",children:"8.3 Minimum Cost to Connect Sticks"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"int connectSticks(int[] sticks) {\n    PriorityQueue<Integer> minHeap = new PriorityQueue<>();\n    for (int stick : sticks) {\n        minHeap.offer(stick);\n    }\n\n    int totalCost = 0;\n    while (minHeap.size() > 1) {\n        int first = minHeap.poll();\n        int second = minHeap.poll();\n        int cost = first + second;\n        totalCost += cost;\n        minHeap.offer(cost);\n    }\n\n    return totalCost;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"84-minimum-cost-to-hire-k-workers",children:"8.4 Minimum Cost to Hire K Workers"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"double mincostToHireWorkers(int[] quality, int[] wage, int k) {\n    int n = quality.length;\n    Worker[] workers = new Worker[n];\n\n    for (int i = 0; i < n; i++) {\n        workers[i] = new Worker(quality[i], wage[i]);\n    }\n\n    Arrays.sort(workers, (a, b) -> Double.compare(a.ratio, b.ratio));\n\n    PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\n    double result = Double.MAX_VALUE;\n    int qualitySum = 0;\n\n    for (Worker worker : workers) {\n        maxHeap.offer(worker.quality);\n        qualitySum += worker.quality;\n\n        if (maxHeap.size() > k) {\n            qualitySum -= maxHeap.poll();\n        }\n\n        if (maxHeap.size() == k) {\n            result = Math.min(result, qualitySum * worker.ratio);\n        }\n    }\n\n    return result;\n}\n\nclass Worker {\n    int quality;\n    int wage;\n    double ratio;\n\n    Worker(int quality, int wage) {\n        this.quality = quality;\n        this.wage = wage;\n        this.ratio = (double) wage / quality;\n    }\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-9-custom-comparator-patterns",children:"Pattern 9: Custom Comparator Patterns"}),"\n",(0,t.jsx)(n.h3,{id:"91-car-pooling",children:"9.1 Car Pooling"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"boolean carPooling(int[][] trips, int capacity) {\n    PriorityQueue<int[]> minHeap = new PriorityQueue<>((a, b) -> a[1] - b[1]);\n    Arrays.sort(trips, (a, b) -> a[1] - b[1]);\n\n    int currentPassengers = 0;\n\n    for (int[] trip : trips) {\n        int passengers = trip[0];\n        int start = trip[1];\n        int end = trip[2];\n\n        // Remove passengers that have reached their destination\n        while (!minHeap.isEmpty() && minHeap.peek()[1] <= start) {\n            currentPassengers -= minHeap.poll()[0];\n        }\n\n        // Add current trip passengers\n        currentPassengers += passengers;\n        minHeap.offer(new int[]{passengers, end});\n\n        if (currentPassengers > capacity) {\n            return false;\n        }\n    }\n\n    return true;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"92-process-tasks-using-servers",children:"9.2 Process Tasks Using Servers"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"int[] assignTasks(int[] servers, int[] tasks) {\n    PriorityQueue<int[]> availableServers = new PriorityQueue<>((a, b) -> {\n        if (a[0] != b[0]) return a[0] - b[0]; // weight\n        return a[1] - b[1]; // index\n    });\n\n    PriorityQueue<int[]> busyServers = new PriorityQueue<>((a, b) -> a[2] - b[2]); // free time\n\n    for (int i = 0; i < servers.length; i++) {\n        availableServers.offer(new int[]{servers[i], i, 0});\n    }\n\n    int[] result = new int[tasks.length];\n\n    for (int i = 0; i < tasks.length; i++) {\n        int currentTime = i;\n\n        // Free up servers\n        while (!busyServers.isEmpty() && busyServers.peek()[2] <= currentTime) {\n            int[] server = busyServers.poll();\n            availableServers.offer(new int[]{server[0], server[1], 0});\n        }\n\n        if (!availableServers.isEmpty()) {\n            int[] server = availableServers.poll();\n            result[i] = server[1];\n            server[2] = currentTime + tasks[i];\n            busyServers.offer(server);\n        } else {\n            // All servers busy, use earliest available\n            int[] server = busyServers.poll();\n            result[i] = server[1];\n            server[2] += tasks[i];\n            busyServers.offer(server);\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"93-single-threaded-cpu",children:"9.3 Single-Threaded CPU"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"int[] getOrder(int[][] tasks) {\n    int n = tasks.length;\n    int[][] indexedTasks = new int[n][3];\n\n    for (int i = 0; i < n; i++) {\n        indexedTasks[i] = new int[]{tasks[i][0], tasks[i][1], i};\n    }\n\n    Arrays.sort(indexedTasks, (a, b) -> a[0] - b[0]); // sort by start time\n\n    PriorityQueue<int[]> minHeap = new PriorityQueue<>((a, b) -> {\n        if (a[1] != b[1]) return a[1] - b[1]; // process time\n        return a[2] - b[2]; // index\n    });\n\n    List<Integer> result = new ArrayList<>();\n    long currentTime = 0;\n    int i = 0;\n\n    while (i < n || !minHeap.isEmpty()) {\n        // Add all available tasks\n        while (i < n && indexedTasks[i][0] <= currentTime) {\n            minHeap.offer(indexedTasks[i]);\n            i++;\n        }\n\n        if (!minHeap.isEmpty()) {\n            int[] task = minHeap.poll();\n            result.add(task[2]);\n            currentTime += task[1];\n        } else {\n            currentTime = indexedTasks[i][0];\n        }\n    }\n\n    return result.stream().mapToInt(Integer::intValue).toArray();\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-10-range--window-problems",children:"Pattern 10: Range & Window Problems"}),"\n",(0,t.jsx)(n.h3,{id:"101-maximum-sliding-window",children:"10.1 Maximum Sliding Window"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"int[] maxSlidingWindow(int[] nums, int k) {\n    Deque<Integer> deque = new ArrayDeque<>();\n    List<Integer> result = new ArrayList<>();\n\n    for (int i = 0; i < nums.length; i++) {\n        // Remove elements outside window\n        while (!deque.isEmpty() && deque.peekFirst() <= i - k) {\n            deque.pollFirst();\n        }\n\n        // Remove smaller elements\n        while (!deque.isEmpty() && nums[deque.peekLast()] <= nums[i]) {\n            deque.pollLast();\n        }\n\n        deque.offerLast(i);\n\n        if (i >= k - 1) {\n            result.add(nums[deque.peekFirst()]);\n        }\n    }\n\n    return result.stream().mapToInt(Integer::intValue).toArray();\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"102-sliding-window-maximum-using-heap",children:"10.2 Sliding Window Maximum using Heap"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"int[] maxSlidingWindowHeap(int[] nums, int k) {\n    PriorityQueue<int[]> maxHeap = new PriorityQueue<>((a, b) -> b[0] - a[0]);\n    int[] result = new int[nums.length - k + 1];\n\n    for (int i = 0; i < nums.length; i++) {\n        maxHeap.offer(new int[]{nums[i], i});\n\n        // Remove elements outside window\n        while (!maxHeap.isEmpty() && maxHeap.peek()[1] <= i - k) {\n            maxHeap.poll();\n        }\n\n        if (i >= k - 1) {\n            result[i - k + 1] = maxHeap.peek()[0];\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"103-smallest-range-covering-k-lists",children:"10.3 Smallest Range Covering K Lists"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"int[] smallestRangeCoveringKLists(List<List<Integer>> nums) {\n    PriorityQueue<Element> minHeap = new PriorityQueue<>((a, b) -> a.value - b.value);\n    int max = Integer.MIN_VALUE;\n\n    for (int i = 0; i < nums.size(); i++) {\n        if (!nums.get(i).isEmpty()) {\n            int value = nums.get(i).get(0);\n            minHeap.offer(new Element(value, i, 0));\n            max = Math.max(max, value);\n        }\n    }\n\n    int[] result = {0, Integer.MAX_VALUE};\n\n    while (minHeap.size() == nums.size()) {\n        Element element = minHeap.poll();\n\n        if (max - element.value < result[1] - result[0]) {\n            result[0] = element.value;\n            result[1] = max;\n        }\n\n        if (element.index + 1 < nums.get(element.listIndex).size()) {\n            int nextValue = nums.get(element.listIndex).get(element.index + 1);\n            minHeap.offer(new Element(nextValue, element.listIndex, element.index + 1));\n            max = Math.max(max, nextValue);\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-11-graph-algorithms-with-heaps",children:"Pattern 11: Graph Algorithms with Heaps"}),"\n",(0,t.jsx)(n.h3,{id:"111-dijkstras-algorithm",children:"11.1 Dijkstra's Algorithm"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"int[] dijkstra(int[][] graph, int start) {\n    int n = graph.length;\n    int[] distances = new int[n];\n    Arrays.fill(distances, Integer.MAX_VALUE);\n    distances[start] = 0;\n\n    PriorityQueue<int[]> minHeap = new PriorityQueue<>((a, b) -> a[1] - b[1]);\n    minHeap.offer(new int[]{start, 0});\n\n    boolean[] visited = new boolean[n];\n\n    while (!minHeap.isEmpty()) {\n        int[] current = minHeap.poll();\n        int node = current[0];\n        int distance = current[1];\n\n        if (visited[node]) continue;\n        visited[node] = true;\n\n        for (int neighbor = 0; neighbor < n; neighbor++) {\n            if (graph[node][neighbor] != 0) {\n                int newDistance = distance + graph[node][neighbor];\n                if (newDistance < distances[neighbor]) {\n                    distances[neighbor] = newDistance;\n                    minHeap.offer(new int[]{neighbor, newDistance});\n                }\n            }\n        }\n    }\n\n    return distances;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"112-network-delay-time",children:"11.2 Network Delay Time"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"int networkDelayTime(int[][] times, int n, int k) {\n    Map<Integer, List<int[]>> graph = new HashMap<>();\n    for (int[] time : times) {\n        graph.computeIfAbsent(time[0], x -> new ArrayList<>()).add(new int[]{time[1], time[2]});\n    }\n\n    PriorityQueue<int[]> minHeap = new PriorityQueue<>((a, b) -> a[1] - b[1]);\n    minHeap.offer(new int[]{k, 0});\n\n    Set<Integer> visited = new HashSet<>();\n    int maxTime = 0;\n\n    while (!minHeap.isEmpty()) {\n        int[] current = minHeap.poll();\n        int node = current[0];\n        int time = current[1];\n\n        if (visited.contains(node)) continue;\n        visited.add(node);\n        maxTime = Math.max(maxTime, time);\n\n        if (graph.containsKey(node)) {\n            for (int[] neighbor : graph.get(node)) {\n                if (!visited.contains(neighbor[0])) {\n                    minHeap.offer(new int[]{neighbor[0], time + neighbor[1]});\n                }\n            }\n        }\n    }\n\n    return visited.size() == n ? maxTime : -1;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"113-path-with-maximum-minimum-value",children:"11.3 Path with Maximum Minimum Value"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"int maximumMinimumPath(int[][] grid) {\n    int m = grid.length, n = grid[0].length;\n    PriorityQueue<int[]> maxHeap = new PriorityQueue<>((a, b) -> b[2] - a[2]);\n    boolean[][] visited = new boolean[m][n];\n\n    maxHeap.offer(new int[]{0, 0, grid[0][0]});\n    int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n    while (!maxHeap.isEmpty()) {\n        int[] current = maxHeap.poll();\n        int row = current[0], col = current[1], minVal = current[2];\n\n        if (row == m - 1 && col == n - 1) {\n            return minVal;\n        }\n\n        if (visited[row][col]) continue;\n        visited[row][col] = true;\n\n        for (int[] dir : directions) {\n            int newRow = row + dir[0];\n            int newCol = col + dir[1];\n\n            if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && !visited[newRow][newCol]) {\n                maxHeap.offer(new int[]{newRow, newCol, Math.min(minVal, grid[newRow][newCol])});\n            }\n        }\n    }\n\n    return -1;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-12-advanced-heap-patterns",children:"Pattern 12: Advanced Heap Patterns"}),"\n",(0,t.jsx)(n.h3,{id:"121-trapping-rain-water-ii",children:"12.1 Trapping Rain Water II"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"int trapRainWater(int[][] heightMap) {\n    if (heightMap == null || heightMap.length == 0) return 0;\n\n    int m = heightMap.length, n = heightMap[0].length;\n    PriorityQueue<int[]> minHeap = new PriorityQueue<>((a, b) -> a[2] - b[2]);\n    boolean[][] visited = new boolean[m][n];\n\n    // Add boundary cells\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i == 0 || i == m - 1 || j == 0 || j == n - 1) {\n                minHeap.offer(new int[]{i, j, heightMap[i][j]});\n                visited[i][j] = true;\n            }\n        }\n    }\n\n    int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    int waterTrapped = 0;\n\n    while (!minHeap.isEmpty()) {\n        int[] current = minHeap.poll();\n        int row = current[0], col = current[1], height = current[2];\n\n        for (int[] dir : directions) {\n            int newRow = row + dir[0];\n            int newCol = col + dir[1];\n\n            if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && !visited[newRow][newCol]) {\n                waterTrapped += Math.max(0, height - heightMap[newRow][newCol]);\n                minHeap.offer(new int[]{newRow, newCol, Math.max(height, heightMap[newRow][newCol])});\n                visited[newRow][newCol] = true;\n            }\n        }\n    }\n\n    return waterTrapped;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"122-skyline-problem",children:"12.2 Skyline Problem"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"List<List<Integer>> getSkyline(int[][] buildings) {\n    List<int[]> events = new ArrayList<>();\n\n    for (int[] building : buildings) {\n        events.add(new int[]{building[0], building[2], 1}); // start\n        events.add(new int[]{building[1], building[2], -1}); // end\n    }\n\n    events.sort((a, b) -> {\n        if (a[0] != b[0]) return a[0] - b[0];\n        if (a[2] != b[2]) return b[2] - a[2]; // start before end\n        return a[2] == 1 ? b[1] - a[1] : a[1] - b[1]; // taller first for start, shorter first for end\n    });\n\n    List<List<Integer>> result = new ArrayList<>();\n    PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\n    maxHeap.offer(0);\n\n    for (int[] event : events) {\n        int x = event[0], height = event[1], type = event[2];\n\n        if (type == 1) {\n            maxHeap.offer(height);\n        } else {\n            maxHeap.remove(height);\n        }\n\n        int maxHeight = maxHeap.peek();\n        if (result.isEmpty() || result.get(result.size() - 1).get(1) != maxHeight) {\n            result.add(Arrays.asList(x, maxHeight));\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"123-maximum-performance-team",children:"12.3 Maximum Performance Team"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"int maxPerformance(int n, int[] speed, int[] efficiency, int k) {\n    final int MOD = 1000000007;\n\n    int[][] engineers = new int[n][2];\n    for (int i = 0; i < n; i++) {\n        engineers[i] = new int[]{efficiency[i], speed[i]};\n    }\n\n    Arrays.sort(engineers, (a, b) -> b[0] - a[0]); // sort by efficiency desc\n\n    PriorityQueue<Integer> minHeap = new PriorityQueue<>();\n    long maxPerformance = 0;\n    long speedSum = 0;\n\n    for (int[] engineer : engineers) {\n        int eff = engineer[0];\n        int spd = engineer[1];\n\n        minHeap.offer(spd);\n        speedSum += spd;\n\n        if (minHeap.size() > k) {\n            speedSum -= minHeap.poll();\n        }\n\n        maxPerformance = Math.max(maxPerformance, speedSum * eff);\n    }\n\n    return (int) (maxPerformance % MOD);\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"124-minimum-number-of-refueling-stops",children:"12.4 Minimum Number of Refueling Stops"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"int minRefuelStops(int target, int startFuel, int[][] stations) {\n    PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\n    int fuel = startFuel;\n    int position = 0;\n    int refuels = 0;\n    int stationIndex = 0;\n\n    while (fuel < target) {\n        // Add all reachable stations to heap\n        while (stationIndex < stations.length && stations[stationIndex][0] <= fuel) {\n            maxHeap.offer(stations[stationIndex][1]);\n            stationIndex++;\n        }\n\n        if (maxHeap.isEmpty()) {\n            return -1; // Cannot reach target\n        }\n\n        fuel += maxHeap.poll();\n        refuels++;\n    }\n\n    return refuels;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"time-complexity-reference",children:"Time Complexity Reference"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{style:{textAlign:"left"},children:"Operation"}),(0,t.jsx)(n.th,{style:{textAlign:"left"},children:"Min Heap"}),(0,t.jsx)(n.th,{style:{textAlign:"left"},children:"Max Heap"}),(0,t.jsx)(n.th,{style:{textAlign:"left"},children:"PriorityQueue"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Insert"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(log n)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(log n)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(log n)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Extract Min/Max"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(log n)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(log n)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(log n)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Peek"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(1)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(1)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(1)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Delete"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(log n)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(log n)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(log n)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Build Heap"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(n)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Heapify"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(log n)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(log n)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(log n)"})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"common-heap-patterns-summary",children:"Common Heap Patterns Summary"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Top K Elements"}),": Use min heap of size K for K largest, max heap of size K for K smallest[2][3]"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"K-Way Merge"}),": Use min heap to merge multiple sorted structures[4]"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Two Heaps"}),": Use max heap for smaller half, min heap for larger half (median problems)[5]"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Scheduling"}),": Use priority queue for task scheduling based on priority[6]"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Distance Problems"}),": Use heap to maintain K closest/farthest elements[7]"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Frequency Problems"}),": Use heap with custom comparator for frequency-based sorting[8]"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Stream Processing"}),": Maintain running statistics using heaps[9]"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Graph Algorithms"}),": Use min heap for shortest path algorithms[10]"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(m,{...e})}):m(e)}}}]);