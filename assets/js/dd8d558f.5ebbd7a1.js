"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[2367],{28453:(n,e,r)=>{r.d(e,{R:()=>s,x:()=>c});var t=r(96540);const i={},a=t.createContext(i);function s(n){const e=t.useContext(a);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function c(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:s(n.components),t.createElement(a.Provider,{value:e},n.children)}},73066:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>a,metadata:()=>c,toc:()=>o});var t=r(74848),i=r(28453);const a={},s="Recursion Patterns Cheatsheet",c={id:"DSA/DSA with JavaScript/Recursion",title:"Recursion Patterns Cheatsheet",description:"Core Concepts",source:"@site/docs/DSA/DSA with JavaScript/Recursion.mdx",sourceDirName:"DSA/DSA with JavaScript",slug:"/DSA/DSA with JavaScript/Recursion",permalink:"/dev.enigma/docs/DSA/DSA with JavaScript/Recursion",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with JavaScript/Recursion.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Quick Sort",permalink:"/dev.enigma/docs/DSA/DSA with JavaScript/QuickSort"},next:{title:"10. Regular Expression Matching",permalink:"/dev.enigma/docs/DSA/DSA with JavaScript/RegexMatching"}},l={},o=[{value:"Core Concepts",id:"core-concepts",level:2},{value:"1. Base Cases",id:"1-base-cases",level:3},{value:"2. Recursive Structure",id:"2-recursive-structure",level:3},{value:"Common Patterns",id:"common-patterns",level:2},{value:"1. Linear Recursion",id:"1-linear-recursion",level:3},{value:"2. Binary Recursion",id:"2-binary-recursion",level:3},{value:"3. Tail Recursion",id:"3-tail-recursion",level:3},{value:"4. Multiple Recursion",id:"4-multiple-recursion",level:3},{value:"5. Backtracking",id:"5-backtracking",level:3},{value:"6. Divide and Conquer",id:"6-divide-and-conquer",level:3},{value:"Optimization Techniques",id:"optimization-techniques",level:2},{value:"1. Memoization",id:"1-memoization",level:3},{value:"2. Path Recording",id:"2-path-recording",level:3},{value:"3. State Management",id:"3-state-management",level:3},{value:"Common Pitfalls and Solutions",id:"common-pitfalls-and-solutions",level:2},{value:"1. Stack Overflow",id:"1-stack-overflow",level:3},{value:"2. Redundant Calculations",id:"2-redundant-calculations",level:3},{value:"3. Incorrect Base Case",id:"3-incorrect-base-case",level:3},{value:"Testing Recursive Functions",id:"testing-recursive-functions",level:2}];function u(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,i.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"recursion-patterns-cheatsheet",children:"Recursion Patterns Cheatsheet"})}),"\n",(0,t.jsx)(e.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,t.jsx)(e.h3,{id:"1-base-cases",children:"1. Base Cases"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function factorial(n) {\n  // Base case\n  if (n <= 1) return 1;\n\n  // Recursive case\n  return n * factorial(n - 1);\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-recursive-structure",children:"2. Recursive Structure"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function recursiveFunction(input) {\n  // 1. Base cases\n  if (baseCase) return baseValue;\n\n  // 2. Process current level\n  let current = processCurrentLevel(input);\n\n  // 3. Recursive call with smaller input\n  let subResult = recursiveFunction(smallerInput);\n\n  // 4. Combine results\n  return combineResults(current, subResult);\n}\n"})}),"\n",(0,t.jsx)(e.h2,{id:"common-patterns",children:"Common Patterns"}),"\n",(0,t.jsx)(e.h3,{id:"1-linear-recursion",children:"1. Linear Recursion"}),"\n",(0,t.jsx)(e.p,{children:"Direct recursive call with smaller input."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Sum array elements\nfunction sum(arr, index = 0) {\n  if (index === arr.length) return 0;\n  return arr[index] + sum(arr, index + 1);\n}\n\n// String reversal\nfunction reverse(str) {\n  if (str.length <= 1) return str;\n  return reverse(str.slice(1)) + str[0];\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-binary-recursion",children:"2. Binary Recursion"}),"\n",(0,t.jsx)(e.p,{children:"Two recursive calls in each function."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Fibonacci sequence\nfunction fibonacci(n) {\n  if (n <= 1) return n;\n  return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\n// Binary tree traversal\nfunction traverse(node) {\n  if (!node) return;\n  traverse(node.left);\n  traverse(node.right);\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-tail-recursion",children:"3. Tail Recursion"}),"\n",(0,t.jsx)(e.p,{children:"Recursive call is the last operation."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Factorial with tail recursion\nfunction factorialTail(n, acc = 1) {\n  if (n <= 1) return acc;\n  return factorialTail(n - 1, n * acc);\n}\n\n// Sum with tail recursion\nfunction sumTail(arr, index = 0, acc = 0) {\n  if (index === arr.length) return acc;\n  return sumTail(arr, index + 1, acc + arr[index]);\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"4-multiple-recursion",children:"4. Multiple Recursion"}),"\n",(0,t.jsx)(e.p,{children:"Multiple recursive calls at different positions."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Generate all permutations\nfunction permutations(arr) {\n  if (arr.length <= 1) return [arr];\n\n  const result = [];\n  for (let i = 0; i < arr.length; i++) {\n    const current = arr[i];\n    const remaining = [...arr.slice(0, i), ...arr.slice(i + 1)];\n    const perms = permutations(remaining);\n\n    for (let perm of perms) {\n      result.push([current, ...perm]);\n    }\n  }\n\n  return result;\n}\n\n// Generate all subsets\nfunction subsets(arr) {\n  if (arr.length === 0) return [[]];\n\n  const first = arr[0];\n  const rest = arr.slice(1);\n  const subsWithoutFirst = subsets(rest);\n  const subsWithFirst = subsWithoutFirst.map(sub => [first, ...sub]);\n\n  return [...subsWithoutFirst, ...subsWithFirst];\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"5-backtracking",children:"5. Backtracking"}),"\n",(0,t.jsx)(e.p,{children:"Try different paths and undo if not valid."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// N-Queens Problem\nfunction solveNQueens(n) {\n  const board = Array(n)\n    .fill()\n    .map(() => Array(n).fill('.'));\n  const result = [];\n\n  function isValid(row, col) {\n    // Check column\n    for (let i = 0; i < row; i++) {\n      if (board[i][col] === 'Q') return false;\n    }\n\n    // Check diagonal\n    for (let i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\n      if (board[i][j] === 'Q') return false;\n    }\n\n    // Check anti-diagonal\n    for (let i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {\n      if (board[i][j] === 'Q') return false;\n    }\n\n    return true;\n  }\n\n  function backtrack(row) {\n    if (row === n) {\n      result.push(board.map(row => row.join('')));\n      return;\n    }\n\n    for (let col = 0; col < n; col++) {\n      if (isValid(row, col)) {\n        board[row][col] = 'Q';\n        backtrack(row + 1);\n        board[row][col] = '.';\n      }\n    }\n  }\n\n  backtrack(0);\n  return result;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"6-divide-and-conquer",children:"6. Divide and Conquer"}),"\n",(0,t.jsx)(e.p,{children:"Split problem into smaller subproblems."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Merge Sort\nfunction mergeSort(arr) {\n  if (arr.length <= 1) return arr;\n\n  const mid = Math.floor(arr.length / 2);\n  const left = mergeSort(arr.slice(0, mid));\n  const right = mergeSort(arr.slice(mid));\n\n  return merge(left, right);\n}\n\nfunction merge(left, right) {\n  const result = [];\n  let i = 0,\n    j = 0;\n\n  while (i < left.length && j < right.length) {\n    if (left[i] <= right[j]) {\n      result.push(left[i++]);\n    } else {\n      result.push(right[j++]);\n    }\n  }\n\n  return [...result, ...left.slice(i), ...right.slice(j)];\n}\n"})}),"\n",(0,t.jsx)(e.h2,{id:"optimization-techniques",children:"Optimization Techniques"}),"\n",(0,t.jsx)(e.h3,{id:"1-memoization",children:"1. Memoization"}),"\n",(0,t.jsx)(e.p,{children:"Cache results to avoid redundant calculations."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Fibonacci with memoization\nfunction fibMemo(n, memo = new Map()) {\n  if (n <= 1) return n;\n  if (memo.has(n)) return memo.get(n);\n\n  const result = fibMemo(n - 1, memo) + fibMemo(n - 2, memo);\n  memo.set(n, result);\n  return result;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-path-recording",children:"2. Path Recording"}),"\n",(0,t.jsx)(e.p,{children:"Keep track of path during recursion."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Find all paths in binary tree\nfunction findPaths(root) {\n  const paths = [];\n\n  function dfs(node, path) {\n    if (!node) return;\n\n    path.push(node.val);\n\n    if (!node.left && !node.right) {\n      paths.push([...path]);\n    }\n\n    dfs(node.left, path);\n    dfs(node.right, path);\n    path.pop();\n  }\n\n  dfs(root, []);\n  return paths;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-state-management",children:"3. State Management"}),"\n",(0,t.jsx)(e.p,{children:"Pass state through recursive calls."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Tree max path sum\nfunction maxPathSum(root) {\n  let maxSum = -Infinity;\n\n  function dfs(node) {\n    if (!node) return 0;\n\n    const left = Math.max(0, dfs(node.left));\n    const right = Math.max(0, dfs(node.right));\n\n    maxSum = Math.max(maxSum, node.val + left + right);\n\n    return node.val + Math.max(left, right);\n  }\n\n  dfs(root);\n  return maxSum;\n}\n"})}),"\n",(0,t.jsx)(e.h2,{id:"common-pitfalls-and-solutions",children:"Common Pitfalls and Solutions"}),"\n",(0,t.jsx)(e.h3,{id:"1-stack-overflow",children:"1. Stack Overflow"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Problem\nfunction infinity(n) {\n  return infinity(n + 1); // Will cause stack overflow\n}\n\n// Solution: Add base case\nfunction safe(n, limit = 1000) {\n  if (n >= limit) return n;\n  return safe(n + 1, limit);\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-redundant-calculations",children:"2. Redundant Calculations"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Problem\nfunction slowFib(n) {\n  if (n <= 1) return n;\n  return slowFib(n - 1) + slowFib(n - 2); // Many redundant calls\n}\n\n// Solution: Use memoization\nconst fastFib = (n, memo = new Map()) => {\n  if (n <= 1) return n;\n  if (memo.has(n)) return memo.get(n);\n\n  const result = fastFib(n - 1, memo) + fastFib(n - 2, memo);\n  memo.set(n, result);\n  return result;\n};\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-incorrect-base-case",children:"3. Incorrect Base Case"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Problem\nfunction factorial(n) {\n  if (n == 0) return 0; // Wrong base case\n  return n * factorial(n - 1);\n}\n\n// Solution\nfunction factorial(n) {\n  if (n <= 1) return 1; // Correct base case\n  return n * factorial(n - 1);\n}\n"})}),"\n",(0,t.jsx)(e.h2,{id:"testing-recursive-functions",children:"Testing Recursive Functions"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Unit tests for recursive functions\nfunction testRecursion() {\n  // Test base cases\n  console.assert(factorial(0) === 1, 'factorial(0) should be 1');\n  console.assert(factorial(1) === 1, 'factorial(1) should be 1');\n\n  // Test recursive cases\n  console.assert(factorial(5) === 120, 'factorial(5) should be 120');\n\n  // Test edge cases\n  console.assert(factorial(-1) === 1, 'factorial(-1) should be 1');\n}\n"})})]})}function d(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(u,{...n})}):u(n)}}}]);