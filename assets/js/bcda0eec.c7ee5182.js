"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[8798],{4965:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>a,contentTitle:()=>l,default:()=>d,frontMatter:()=>t,metadata:()=>o,toc:()=>c});var i=r(4848),s=r(8453);const t={},l="Cantor's Diagonalization and Knuth's Algorithms Guide",o={id:"DSA/Cantor",title:"Cantor's Diagonalization and Knuth's Algorithms Guide",description:"Cantor's Diagonalization",source:"@site/docs/DSA/Cantor.mdx",sourceDirName:"DSA",slug:"/DSA/Cantor",permalink:"/js.enigma/docs/DSA/Cantor",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/Cantor.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Bucket Sort",permalink:"/js.enigma/docs/DSA/BucketSort"},next:{title:"Circular Buffer",permalink:"/js.enigma/docs/DSA/CircularBuffer"}},a={},c=[{value:"Cantor&#39;s Diagonalization",id:"cantors-diagonalization",level:2},{value:"Theory",id:"theory",level:3},{value:"Implementation (Basic Concept)",id:"implementation-basic-concept",level:3},{value:"Applications",id:"applications",level:3},{value:"Knuth&#39;s Essential Algorithms",id:"knuths-essential-algorithms",level:2},{value:"1. Dancing Links (Algorithm X)",id:"1-dancing-links-algorithm-x",level:3},{value:"2. Knuth-Morris-Pratt (String Matching)",id:"2-knuth-morris-pratt-string-matching",level:3},{value:"3. MMIX Assembly Language",id:"3-mmix-assembly-language",level:3},{value:"4. Combinatorial Algorithms",id:"4-combinatorial-algorithms",level:3},{value:"Time Complexity Analysis",id:"time-complexity-analysis",level:3},{value:"Common Applications",id:"common-applications",level:3},{value:"Implementation Tips",id:"implementation-tips",level:3}];function h(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"cantors-diagonalization-and-knuths-algorithms-guide",children:"Cantor's Diagonalization and Knuth's Algorithms Guide"})}),"\n",(0,i.jsx)(e.h2,{id:"cantors-diagonalization",children:"Cantor's Diagonalization"}),"\n",(0,i.jsx)(e.h3,{id:"theory",children:"Theory"}),"\n",(0,i.jsx)(e.p,{children:'Cantor\'s Diagonalization is a mathematical technique used to prove that some infinite sets are "bigger" than others. Most famously used to prove that real numbers are uncountable.'}),"\n",(0,i.jsx)(e.h3,{id:"implementation-basic-concept",children:"Implementation (Basic Concept)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function cantorDiagonalization(sequences, n) {\r\n    // Create a new sequence different from all given sequences\r\n    let newSequence = '';\r\n    \r\n    for (let i = 0; i < n; i++) {\r\n        // Get the i-th digit of the i-th sequence\r\n        const digit = sequences[i][i];\r\n        \r\n        // Make this digit different\r\n        newSequence += digit === '0' ? '1' : '0';\r\n    }\r\n    \r\n    return newSequence;\r\n}\r\n\r\n// Example usage\r\nconst sequences = [\r\n    \"01010101\",\r\n    \"11111111\",\r\n    \"00000000\",\r\n    \"10101010\"\r\n];\r\n\r\nconsole.log(cantorDiagonalization(sequences, 4));\n"})}),"\n",(0,i.jsx)(e.h3,{id:"applications",children:"Applications"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"Proving uncountability of real numbers"}),"\n",(0,i.jsx)(e.li,{children:"Halting problem proof"}),"\n",(0,i.jsx)(e.li,{children:"Set theory arguments"}),"\n",(0,i.jsx)(e.li,{children:"Computational complexity theory"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"knuths-essential-algorithms",children:"Knuth's Essential Algorithms"}),"\n",(0,i.jsx)(e.h3,{id:"1-dancing-links-algorithm-x",children:"1. Dancing Links (Algorithm X)"}),"\n",(0,i.jsx)(e.p,{children:"Used for exact cover problems, particularly in solving Sudoku and pentomino puzzles."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"class DLX {\r\n    constructor() {\r\n        this.header = new Node('header');\r\n        this.solution = [];\r\n    }\r\n    \r\n    addColumn(name) {\r\n        const node = new Node(name);\r\n        node.right = this.header.right;\r\n        node.left = this.header;\r\n        this.header.right.left = node;\r\n        this.header.right = node;\r\n        return node;\r\n    }\r\n    \r\n    search(k) {\r\n        if (this.header.right === this.header) {\r\n            return this.solution;\r\n        }\r\n        \r\n        // Choose column with minimum size\r\n        let column = this.chooseColumn();\r\n        this.cover(column);\r\n        \r\n        // Try each row\r\n        let row = column.down;\r\n        while (row !== column) {\r\n            this.solution[k] = row;\r\n            \r\n            // Cover columns\r\n            let j = row.right;\r\n            while (j !== row) {\r\n                this.cover(j.column);\r\n                j = j.right;\r\n            }\r\n            \r\n            this.search(k + 1);\r\n            \r\n            // Uncover columns\r\n            j = row.left;\r\n            while (j !== row) {\r\n                this.uncover(j.column);\r\n                j = j.left;\r\n            }\r\n            \r\n            row = row.down;\r\n        }\r\n        \r\n        this.uncover(column);\r\n        return null;\r\n    }\r\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"2-knuth-morris-pratt-string-matching",children:"2. Knuth-Morris-Pratt (String Matching)"}),"\n",(0,i.jsx)(e.p,{children:"Efficient pattern matching algorithm."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function computeLPS(pattern) {\r\n    const lps = new Array(pattern.length).fill(0);\r\n    let len = 0;\r\n    let i = 1;\r\n    \r\n    while (i < pattern.length) {\r\n        if (pattern[i] === pattern[len]) {\r\n            len++;\r\n            lps[i] = len;\r\n            i++;\r\n        } else {\r\n            if (len !== 0) {\r\n                len = lps[len - 1];\r\n            } else {\r\n                lps[i] = 0;\r\n                i++;\r\n            }\r\n        }\r\n    }\r\n    \r\n    return lps;\r\n}\r\n\r\nfunction KMP(text, pattern) {\r\n    const lps = computeLPS(pattern);\r\n    const matches = [];\r\n    let i = 0;  // text index\r\n    let j = 0;  // pattern index\r\n    \r\n    while (i < text.length) {\r\n        if (pattern[j] === text[i]) {\r\n            i++;\r\n            j++;\r\n        }\r\n        \r\n        if (j === pattern.length) {\r\n            matches.push(i - j);\r\n            j = lps[j - 1];\r\n        } else if (i < text.length && pattern[j] !== text[i]) {\r\n            if (j !== 0) {\r\n                j = lps[j - 1];\r\n            } else {\r\n                i++;\r\n            }\r\n        }\r\n    }\r\n    \r\n    return matches;\r\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"3-mmix-assembly-language",children:"3. MMIX Assembly Language"}),"\n",(0,i.jsx)(e.p,{children:"Knuth's ideal computer architecture. Key concepts:"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"Registers:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"256 general-purpose registers"}),"\n",(0,i.jsx)(e.li,{children:"Special registers (rA, rB, rC, rD, rE, rF, rG, rH)"}),"\n",(0,i.jsx)(e.li,{children:"Local registers (l0-l7)"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"Basic Operations:"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// MMIX simulator (basic operations)\r\nclass MMIX {\r\n    constructor() {\r\n        this.registers = new Array(256).fill(0n);\r\n        this.memory = new Map();\r\n    }\r\n\r\n    ADD(x, y, z) {\r\n        this.registers[x] = (this.registers[y] + this.registers[z]) & ((1n << 64n) - 1n);\r\n    }\r\n\r\n    MUL(x, y, z) {\r\n        this.registers[x] = (this.registers[y] * this.registers[z]) & ((1n << 64n) - 1n);\r\n    }\r\n\r\n    LOAD(x, y, z) {\r\n        const address = Number(this.registers[y] + this.registers[z]);\r\n        this.registers[x] = this.memory.get(address) || 0n;\r\n    }\r\n\r\n    STORE(x, y, z) {\r\n        const address = Number(this.registers[y] + this.registers[z]);\r\n        this.memory.set(address, this.registers[x]);\r\n    }\r\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"4-combinatorial-algorithms",children:"4. Combinatorial Algorithms"}),"\n",(0,i.jsx)(e.p,{children:"Key techniques from TAOCP Volume 4:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// Algorithm L: Lexicographic Combinations\r\nfunction nextCombination(arr, n) {\r\n    const j = arr.length - 1;\r\n    if (arr[j] < n) {\r\n        arr[j]++;\r\n        return true;\r\n    }\r\n    \r\n    let i = j - 1;\r\n    while (i >= 0 && arr[i] + 1 === arr[i + 1]) {\r\n        i--;\r\n    }\r\n    \r\n    if (i < 0) return false;\r\n    \r\n    arr[i]++;\r\n    for (let k = i + 1; k <= j; k++) {\r\n        arr[k] = arr[i] + (k - i);\r\n    }\r\n    return true;\r\n}\r\n\r\n// Algorithm P: Plain Changes (Gray Code)\r\nfunction grayCode(n) {\r\n    const codes = [];\r\n    const size = 1 << n;\r\n    \r\n    for (let i = 0; i < size; i++) {\r\n        codes.push(i ^ (i >> 1));\r\n    }\r\n    \r\n    return codes;\r\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"time-complexity-analysis",children:"Time Complexity Analysis"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"Dancing Links"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Time: O(branches^depth)"}),"\n",(0,i.jsx)(e.li,{children:"Space: O(n^2)"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"KMP Algorithm"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Preprocessing: O(m)"}),"\n",(0,i.jsx)(e.li,{children:"Search: O(n)"}),"\n",(0,i.jsx)(e.li,{children:"Space: O(m)"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"Combinatorial Algorithms"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Next Combination: O(n)"}),"\n",(0,i.jsx)(e.li,{children:"Gray Code: O(2^n)"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"common-applications",children:"Common Applications"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"Dancing Links"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Sudoku solving"}),"\n",(0,i.jsx)(e.li,{children:"Exact cover problems"}),"\n",(0,i.jsx)(e.li,{children:"Pentomino puzzles"}),"\n",(0,i.jsx)(e.li,{children:"N-Queens problem"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"KMP"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Text processing"}),"\n",(0,i.jsx)(e.li,{children:"Pattern matching"}),"\n",(0,i.jsx)(e.li,{children:"DNA sequence matching"}),"\n",(0,i.jsx)(e.li,{children:"Log file analysis"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"Combinatorial Algorithms"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Permutation generation"}),"\n",(0,i.jsx)(e.li,{children:"Combination enumeration"}),"\n",(0,i.jsx)(e.li,{children:"Gray code generation"}),"\n",(0,i.jsx)(e.li,{children:"Backtracking problems"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"implementation-tips",children:"Implementation Tips"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"Dancing Links"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Use circular doubly-linked lists"}),"\n",(0,i.jsx)(e.li,{children:"Implement column headers with size counters"}),"\n",(0,i.jsx)(e.li,{children:"Consider sparse matrix representation"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"KMP"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Preprocess pattern first"}),"\n",(0,i.jsx)(e.li,{children:"Handle pattern length > text length"}),"\n",(0,i.jsx)(e.li,{children:"Consider multiple pattern matching"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"MMIX"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Use BigInt for 64-bit operations"}),"\n",(0,i.jsx)(e.li,{children:"Implement proper overflow handling"}),"\n",(0,i.jsx)(e.li,{children:"Consider pipeline effects"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"Combinatorial Algorithms"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Use iterative over recursive when possible"}),"\n",(0,i.jsx)(e.li,{children:"Implement efficient bit operations"}),"\n",(0,i.jsx)(e.li,{children:"Consider memory usage for large sets"}),"\n"]}),"\n"]}),"\n"]})]})}function d(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(h,{...n})}):h(n)}},8453:(n,e,r)=>{r.d(e,{R:()=>l,x:()=>o});var i=r(6540);const s={},t=i.createContext(s);function l(n){const e=i.useContext(t);return i.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:l(n.components),i.createElement(t.Provider,{value:e},n.children)}}}]);