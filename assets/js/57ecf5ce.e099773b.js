"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[7572],{5176:(n,r,e)=>{e.r(r),e.d(r,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>t,metadata:()=>a,toc:()=>d});var o=e(4848),i=e(8453);const t={},s="Combinations and Modular Inverse",a={id:"DSA/Combinatrix",title:"Combinations and Modular Inverse",description:"1. Combinations",source:"@site/docs/DSA/Combinatrix.mdx",sourceDirName:"DSA",slug:"/DSA/Combinatrix",permalink:"/js.enigma/docs/DSA/Combinatrix",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/Combinatrix.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Circular Buffer",permalink:"/js.enigma/docs/DSA/CircularBuffer"},next:{title:"Counting Sort",permalink:"/js.enigma/docs/DSA/CountingSort"}},l={},d=[{value:"1. Combinations",id:"1-combinations",level:2},{value:"2. Modular Inverse:",id:"2-modular-inverse",level:2},{value:"For Big Numbers",id:"for-big-numbers",level:2}];function m(n){const r={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(r.header,{children:(0,o.jsx)(r.h1,{id:"combinations-and-modular-inverse",children:"Combinations and Modular Inverse"})}),"\n",(0,o.jsx)(r.h2,{id:"1-combinations",children:"1. Combinations"}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Purpose:"})," Calculates the number of ways to choose r items from n items, where order doesn't matter"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Example:"})," If you have 5 colors and want to pick 2, ",(0,o.jsx)(r.code,{children:"nCr(5,2)"})," tells you how many different color pairs are possible"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Formula:"})," ",(0,o.jsx)(r.code,{children:"C(n,r) = n!/(r! * (n-r)!)"})]}),"\n"]}),"\n",(0,o.jsx)(r.h2,{id:"2-modular-inverse",children:"2. Modular Inverse:"}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Purpose:"})," Used when we need to perform division in modular arithmetic"]}),"\n",(0,o.jsx)(r.li,{children:"When we calculate large combinations, we often need to take modulo to prevent overflow"}),"\n",(0,o.jsx)(r.li,{children:"Division in modular arithmetic isn't straightforward, so we use modular multiplicative inverse"}),"\n",(0,o.jsxs)(r.li,{children:["For ",(0,o.jsx)(r.code,{children:"(a/b) % m"}),", we calculate ",(0,o.jsx)(r.code,{children:"(a * modInverse(b,m)) % m"})]}),"\n"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-JavaScript",children:"// Calculate combinations C(n,r) using modular arithmetic\r\nfunction modInverse(a, m) {\r\n  // Extended Euclidean Algorithm to find modular multiplicative inverse\r\n  let m0 = m;\r\n  let x0 = 0;\r\n  let x1 = 1;\r\n\r\n  if (m === 1) return 0;\r\n\r\n  while (a > 1) {\r\n    const q = Math.floor(a / m);\r\n    let t = m;\r\n\r\n    m = a % m;\r\n    a = t;\r\n    t = x0;\r\n\r\n    x0 = x1 - q * x0;\r\n    x1 = t;\r\n  }\r\n\r\n  return x1 < 0 ? x1 + m0 : x1;\r\n}\r\n\r\nfunction nCr(n, r, mod = 1e9 + 7) {\r\n  if (r > n) return 0;\r\n  if (r === 0 || r === n) return 1;\r\n\r\n  // Calculate using formula: C(n,r) = n!/(r! * (n-r)!)\r\n  let numerator = 1;\r\n  let denominator = 1;\r\n\r\n  for (let i = 0; i < r; i++) {\r\n    numerator = (numerator * (n - i)) % mod;\r\n    denominator = (denominator * (i + 1)) % mod;\r\n  }\r\n\r\n  // Use modular inverse for division\r\n  return (numerator * modInverse(denominator, mod)) % mod;\r\n}\r\n\r\n// Example usage\r\nconsole.log(nCr(5, 2));  // Calculates 5C2 = 10\r\nconsole.log(nCr(10, 3)); // Calculates 10C3 = 120\n"})}),"\n",(0,o.jsx)(r.h2,{id:"for-big-numbers",children:"For Big Numbers"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-JavaScript",children:"const kMod = BigInt(1e9 + 7); // Modulo 10^9+7\r\n\r\n// Modular exponentiation\r\nconst modPow = (base, exp, mod) => {\r\n  let result = BigInt(1);\r\n  while (exp > 0) {\r\n    if (exp % BigInt(2) === BigInt(1)) result = (result * base) % mod;\r\n    base = (base * base) % mod;\r\n    exp >>= BigInt(1); // Bitwise shift for efficiency\r\n  }\r\n  return result;\r\n};\r\n\r\n// Compute (nCr) % mod using modular inverse\r\nconst comb = (n, r, mod = kMod) => {\r\n  if (r > n) return BigInt(0);\r\n\r\n  let numerator = BigInt(1), denominator = BigInt(1);\r\n  for (let i = BigInt(0); i < r; i++) {\r\n    numerator = (numerator * (n - i)) % mod;\r\n    denominator = (denominator * (i + BigInt(1))) % mod;\r\n  }\r\n\r\n  // Compute modular inverse of denominator using Fermat\u2019s theorem\r\n  return (numerator * modPow(denominator, mod - BigInt(2), mod)) % mod;\r\n};\r\n\r\n// Example usage\r\nconsole.log(comb(BigInt(5), BigInt(2)));  // 10\r\nconsole.log(comb(BigInt(10), BigInt(3))); // 120\r\nconsole.log(comb(BigInt(1000), BigInt(500))); // Large nCr % 10^9+7\r\n/* \r\n10n\r\n120n\r\n159835829n\r\n*/\n"})})]})}function c(n={}){const{wrapper:r}={...(0,i.R)(),...n.components};return r?(0,o.jsx)(r,{...n,children:(0,o.jsx)(m,{...n})}):m(n)}},8453:(n,r,e)=>{e.d(r,{R:()=>s,x:()=>a});var o=e(6540);const i={},t=o.createContext(i);function s(n){const r=o.useContext(t);return o.useMemo((function(){return"function"==typeof n?n(r):{...r,...n}}),[r,n])}function a(n){let r;return r=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:s(n.components),o.createElement(t.Provider,{value:r},n.children)}}}]);