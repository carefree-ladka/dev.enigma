"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[7133],{251:(n,r,e)=>{e.r(r),e.d(r,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>t,metadata:()=>i,toc:()=>c});var o=e(4848),s=e(8453);const t={},a="Async Await",i={id:"WebDev/JavaScript/AsyncAwait",title:"Async Await",description:"Print Numbers after num Seconds",source:"@site/docs/WebDev/JavaScript/AsyncAwait.mdx",sourceDirName:"WebDev/JavaScript",slug:"/WebDev/JavaScript/AsyncAwait",permalink:"/js.enigma/docs/WebDev/JavaScript/AsyncAwait",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/WebDev/JavaScript/AsyncAwait.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"DOM Methods & Selectors Cheatsheet",permalink:"/js.enigma/docs/WebDev/HTMLDOM/DOMCheatSheet"},next:{title:"Closures",permalink:"/js.enigma/docs/WebDev/JavaScript/Closure"}},l={},c=[{value:"Print Numbers after num Seconds",id:"print-numbers-after-num-seconds",level:2},{value:"Print Numbers after num Seconds : Async Await",id:"print-numbers-after-num-seconds--async-await",level:2}];function u(n){const r={code:"code",h1:"h1",h2:"h2",header:"header",pre:"pre",...(0,s.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(r.header,{children:(0,o.jsx)(r.h1,{id:"async-await",children:"Async Await"})}),"\n",(0,o.jsx)(r.h2,{id:"print-numbers-after-num-seconds",children:"Print Numbers after num Seconds"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-JavaScript",children:"const nums = [1, 2, 3, 4, 5];\r\n\r\nfunction printAfterNumber(nums) {\r\n  let cumulativeDelay = 0;\r\n\r\n  for (let i = 0; i < nums.length; i++) {\r\n    cumulativeDelay += nums[i] * 1000; // Add the delay for the current number\r\n    setTimeout(() => {\r\n      console.log(nums[i]);\r\n    }, cumulativeDelay);\r\n  }\r\n}\r\n\r\nprintAfterNumber(nums);\r\n/* \r\n1 // After 1s\r\n2 // After 2s\r\n3 //...\r\n4\r\n5\r\n*/\n"})}),"\n",(0,o.jsx)(r.h2,{id:"print-numbers-after-num-seconds--async-await",children:"Print Numbers after num Seconds : Async Await"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-JavaScript",children:"const nums = [1, 2, 3, 4, 5];\r\n\r\nconst sleep = (ms) => new Promise((res) => setTimeout(res, ms));\r\n\r\nasync function printAfterNumber(nums) {\r\n  for (let i = 0; i < nums.length; i++) {\r\n    await sleep(nums[i] * 1000);\r\n    console.log(nums[i]);\r\n  }\r\n}\r\n\r\nprintAfterNumber(nums);\n"})}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-JavaScript",children:"// Problem 1: Mixing Promises and setTimeout\r\nconsole.log('\ud83d\ude80 Problem 1: Promise vs setTimeout');\r\n\r\nasync function asyncOrder() {\r\n    console.log('1');\r\n    \r\n    setTimeout(() => {\r\n        console.log('2');\r\n    }, 0);\r\n    \r\n    await Promise.resolve().then(() => console.log('3'));\r\n    \r\n    console.log('4');\r\n}\r\n\r\nasyncOrder();\r\nconsole.log('5');\r\n\r\n/* Output:\r\n1\r\n5\r\n3\r\n4\r\n2\r\nExplanation: \r\n- Microtasks (Promises) have priority over macrotasks (setTimeout)\r\n- Even with 0ms timeout, setTimeout callback goes to macrotask queue\r\n*/\r\n\r\n// Problem 2: Multiple Awaits\r\nconsole.log('\\n\ud83d\ude80 Problem 2: Multiple Awaits');\r\n\r\nasync function parallel() {\r\n    const promise1 = Promise.resolve('First');\r\n    const promise2 = Promise.resolve('Second');\r\n    \r\n    const promise3 = await promise1;\r\n    console.log(promise3);\r\n    \r\n    const promise4 = await promise2;\r\n    console.log(promise4);\r\n}\r\n\r\nasync function concurrent() {\r\n    const [first, second] = await Promise.all([\r\n        Promise.resolve('First'),\r\n        Promise.resolve('Second')\r\n    ]);\r\n    \r\n    console.log(first);\r\n    console.log(second);\r\n}\r\n\r\nconsole.log('Start');\r\nparallel();\r\nconsole.log('End');\r\n\r\n/* Output:\r\nStart\r\nEnd\r\nFirst\r\nSecond\r\n\r\nExplanation:\r\n- sequential execution of awaits\r\n- Promise.all would be more efficient for concurrent execution\r\n*/\r\n\r\n// Problem 3: Error Handling\r\nconsole.log('\\n\ud83d\ude80 Problem 3: Error Handling');\r\n\r\nasync function errorHandling() {\r\n    try {\r\n        console.log('1');\r\n        await Promise.reject('Error!');\r\n        console.log('2'); // Never reached\r\n    } catch (error) {\r\n        console.log('3');\r\n    } finally {\r\n        console.log('4');\r\n    }\r\n    console.log('5');\r\n}\r\n\r\nerrorHandling();\r\nconsole.log('6');\r\n\r\n/* Output:\r\n1\r\n6\r\n3\r\n4\r\n5\r\n\r\nExplanation:\r\n- Error causes jump to catch block\r\n- finally always executes\r\n- async function continues after try-catch\r\n*/\r\n\r\n// Problem 4: Promise Race Conditions\r\nconsole.log('\\n\ud83d\ude80 Problem 4: Race Conditions');\r\n\r\nasync function raceCondition() {\r\n    const getData = () => new Promise(resolve => \r\n        setTimeout(() => resolve('Data'), Math.random() * 100)\r\n    );\r\n    \r\n    const results = [];\r\n    \r\n    // Wrong way - race condition\r\n    for (let i = 0; i < 3; i++) {\r\n        getData().then(result => results.push(result));\r\n    }\r\n    \r\n    await Promise.all(results); // This won't work as expected!\r\n    console.log(results); // May not have all results\r\n    \r\n    // Correct way\r\n    const correctResults = await Promise.all(\r\n        Array(3).fill(null).map(() => getData())\r\n    );\r\n    console.log(correctResults); // Guaranteed to have all results\r\n}\r\n\r\nraceCondition();\r\n\r\n// Problem 5: Async Loop Trap\r\nconsole.log('\\n\ud83d\ude80 Problem 5: Async Loop Trap');\r\n\r\nasync function asyncLoop() {\r\n    const items = [1, 2, 3];\r\n    \r\n    // Wrong way - all requests fire at once\r\n    items.forEach(async (item) => {\r\n        const result = await Promise.resolve(item * 2);\r\n        console.log(result);\r\n    });\r\n    \r\n    console.log('Done forEach');\r\n    \r\n    // Correct way - sequential processing\r\n    for (const item of items) {\r\n        const result = await Promise.resolve(item * 2);\r\n        console.log(result);\r\n    }\r\n    \r\n    console.log('Done for...of');\r\n}\r\n\r\nasyncLoop();\r\n\r\n/* Output:\r\nDone forEach\r\n2\r\n4\r\n6\r\n2\r\n4\r\n6\r\nDone for...of\r\n\r\nExplanation:\r\n- forEach doesn't wait for async operations\r\n- for...of allows proper sequential processing\r\n*/\r\n\r\n// Problem 6: Return Value Trap\r\nconsole.log('\\n\ud83d\ude80 Problem 6: Return Value Trap');\r\n\r\nasync function returnValue() {\r\n    return await Promise.resolve('Done');\r\n}\r\n\r\nasync function unnecessaryAwait() {\r\n    // Unnecessary await - just return the promise\r\n    return await Promise.resolve('Done');\r\n}\r\n\r\nconst result1 = returnValue();\r\nconst result2 = unnecessaryAwait();\r\n\r\nconsole.log(result1); // Promise { 'Done' }\r\nconsole.log(result2); // Promise { 'Done' }\r\n\r\n/* Explanation:\r\n- Both functions return a Promise\r\n- await in return is usually unnecessary\r\n- Need to await the function call to get the value\r\n*/\r\n\r\n// Problem 7: Async IIFE Confusion\r\nconsole.log('\\n\ud83d\ude80 Problem 7: Async IIFE');\r\n\r\n(async () => {\r\n    console.log('1');\r\n    await Promise.resolve();\r\n    console.log('2');\r\n})();\r\n\r\nconsole.log('3');\r\n\r\n/* Output:\r\n1\r\n3\r\n2\r\n\r\nExplanation:\r\n- Async IIFE is still async\r\n- Code outside continues executing\r\n*/\r\n\r\n// Problem 8: Promise Chain vs Async/Await\r\nconsole.log('\\n\ud83d\ude80 Problem 8: Promise Chain vs Async/Await');\r\n\r\n// Promise chain\r\nPromise.resolve('Start')\r\n    .then(result => {\r\n        console.log(result);\r\n        return 'Middle';\r\n    })\r\n    .then(result => {\r\n        console.log(result);\r\n        return 'End';\r\n    })\r\n    .then(result => {\r\n        console.log(result);\r\n    });\r\n\r\n// Equivalent async/await\r\nasync function asyncChain() {\r\n    const start = await Promise.resolve('Start');\r\n    console.log(start);\r\n    \r\n    const middle = await Promise.resolve('Middle');\r\n    console.log(middle);\r\n    \r\n    const end = await Promise.resolve('End');\r\n    console.log(end);\r\n}\r\n\r\n/* Output (both produce):\r\nStart\r\nMiddle\r\nEnd\r\n\r\nExplanation:\r\n- Both approaches are equivalent\r\n- Async/await is more readable for complex chains\r\n*/\r\n\r\n// Problem 9: Concurrent vs Sequential\r\nconsole.log('\\n\ud83d\ude80 Problem 9: Concurrent vs Sequential');\r\n\r\nasync function sequential() {\r\n    console.time('sequential');\r\n    const first = await new Promise(r => setTimeout(() => r('first'), 1000));\r\n    const second = await new Promise(r => setTimeout(() => r('second'), 1000));\r\n    console.timeEnd('sequential'); // ~2000ms\r\n    return [first, second];\r\n}\r\n\r\nasync function concurrent() {\r\n    console.time('concurrent');\r\n    const [first, second] = await Promise.all([\r\n        new Promise(r => setTimeout(() => r('first'), 1000)),\r\n        new Promise(r => setTimeout(() => r('second'), 1000))\r\n    ]);\r\n    console.timeEnd('concurrent'); // ~1000ms\r\n    return [first, second];\r\n}\r\n\r\n/* Explanation:\r\n- Sequential: Each promise waits for previous\r\n- Concurrent: All promises run at the same time\r\n- Promise.all is more efficient for independent operations\r\n*/\r\n\r\n// Problem 10: Event Loop Order\r\nconsole.log('\\n\ud83d\ude80 Problem 10: Event Loop Order');\r\n\r\nasync function eventLoop() {\r\n    console.log('1'); // Synchronous\r\n    \r\n    setTimeout(() => {\r\n        console.log('2'); // Macrotask\r\n    }, 0);\r\n    \r\n    new Promise(resolve => resolve('3'))\r\n        .then(console.log); // Microtask\r\n    \r\n    await Promise.resolve('4');\r\n    console.log('5'); // After await\r\n    \r\n    queueMicrotask(() => {\r\n        console.log('6'); // Microtask\r\n    });\r\n}\r\n\r\neventLoop();\r\nconsole.log('7'); // Synchronous\r\n\r\n/* Output:\r\n1\r\n7\r\n3\r\n4\r\n5\r\n6\r\n2\r\n\r\nExplanation:\r\n1. Synchronous code executes first\r\n2. Microtasks (Promises, queueMicrotask) execute next\r\n3. Macrotasks (setTimeout, setInterval) execute last\r\n4. Each await creates a new microtask\r\n*/\n"})})]})}function m(n={}){const{wrapper:r}={...(0,s.R)(),...n.components};return r?(0,o.jsx)(r,{...n,children:(0,o.jsx)(u,{...n})}):u(n)}},8453:(n,r,e)=>{e.d(r,{R:()=>a,x:()=>i});var o=e(6540);const s={},t=o.createContext(s);function a(n){const r=o.useContext(t);return o.useMemo((function(){return"function"==typeof n?n(r):{...r,...n}}),[r,n])}function i(n){let r;return r=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:a(n.components),o.createElement(t.Provider,{value:r},n.children)}}}]);