"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[3643],{7514:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>a});var t=i(4848),s=i(8453);const r={},l="Queue",o={id:"DSA/DSA with JavaScript/DSA Cheatsheets/Queue Techniques",title:"Queue",description:"A comprehensive guide to mastering queue patterns and techniques for Data Structures and Algorithms interviews and competitive programming.",source:"@site/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Queue Techniques.mdx",sourceDirName:"DSA/DSA with JavaScript/DSA Cheatsheets",slug:"/DSA/DSA with JavaScript/DSA Cheatsheets/Queue Techniques",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Queue Techniques",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Queue Techniques.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Prefix Sum",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Prefix Sum"},next:{title:"Complete Recursion",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Recursion"}},d={},a=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Introduction",id:"introduction",level:2},{value:"When to Use Queues",id:"when-to-use-queues",level:3},{value:"Basic Queue Operations",id:"basic-queue-operations",level:2},{value:"Standard Queue Interface",id:"standard-queue-interface",level:3},{value:"Queue Implementations",id:"queue-implementations",level:2},{value:"1. Array-Based Queue (Circular Buffer)",id:"1-array-based-queue-circular-buffer",level:3},{value:"2. Linked List-Based Queue",id:"2-linked-list-based-queue",level:3},{value:"3. Two-Stack Queue Implementation",id:"3-two-stack-queue-implementation",level:3},{value:"BFS and Level-Order Traversal",id:"bfs-and-level-order-traversal",level:2},{value:"1. Binary Tree Level-Order Traversal",id:"1-binary-tree-level-order-traversal",level:3},{value:"2. Zigzag Level Order Traversal",id:"2-zigzag-level-order-traversal",level:3},{value:"3. Binary Tree Right Side View",id:"3-binary-tree-right-side-view",level:3},{value:"4. Graph BFS (Shortest Path)",id:"4-graph-bfs-shortest-path",level:3},{value:"5. Word Ladder (BFS Application)",id:"5-word-ladder-bfs-application",level:3},{value:"Sliding Window Techniques",id:"sliding-window-techniques",level:2},{value:"1. Sliding Window Maximum (Deque)",id:"1-sliding-window-maximum-deque",level:3},{value:"2. First Negative in Window",id:"2-first-negative-in-window",level:3},{value:"3. Generate Binary Numbers",id:"3-generate-binary-numbers",level:3},{value:"Deque (Double-Ended Queue)",id:"deque-double-ended-queue",level:2},{value:"JavaScript Deque Implementation",id:"javascript-deque-implementation",level:3},{value:"Palindrome Checker with Deque",id:"palindrome-checker-with-deque",level:3},{value:"Priority Queue Applications",id:"priority-queue-applications",level:2},{value:"1. Priority Queue with Heap",id:"1-priority-queue-with-heap",level:3},{value:"2. Task Scheduler",id:"2-task-scheduler",level:3},{value:"3. Top K Frequent Elements",id:"3-top-k-frequent-elements",level:3},{value:"Monotonic Queue",id:"monotonic-queue",level:2},{value:"1. Largest Rectangle in Histogram",id:"1-largest-rectangle-in-histogram",level:3},{value:"2. Sliding Window Minimum",id:"2-sliding-window-minimum",level:3},{value:"Queue-Based Algorithms",id:"queue-based-algorithms",level:2},{value:"1. Breadth-First Search Template",id:"1-breadth-first-search-template",level:3},{value:"2. Multi-Source BFS",id:"2-multi-source-bfs",level:3},{value:"3. Rotting Oranges",id:"3-rotting-oranges",level:3},{value:"Advanced Patterns",id:"advanced-patterns",level:2},{value:"1. Queue Reconstruction by Height",id:"1-queue-reconstruction-by-height",level:3},{value:"2. Design Hit Counter",id:"2-design-hit-counter",level:3},{value:"3. Shortest Bridge (BFS + DFS)",id:"3-shortest-bridge-bfs--dfs",level:3},{value:"4. Design Circular Queue",id:"4-design-circular-queue",level:3},{value:"5. Moving Average from Data Stream",id:"5-moving-average-from-data-stream",level:3},{value:"Problem-Solving Framework",id:"problem-solving-framework",level:2},{value:"Queue Pattern Recognition",id:"queue-pattern-recognition",level:3},{value:"Step-by-Step Approach",id:"step-by-step-approach",level:3},{value:"Practice Problems",id:"practice-problems",level:2},{value:"Beginner Level",id:"beginner-level",level:3},{value:"Intermediate Level",id:"intermediate-level",level:3},{value:"Advanced Level",id:"advanced-level",level:3},{value:"Expert Level",id:"expert-level",level:3},{value:"Time Complexity Summary",id:"time-complexity-summary",level:2},{value:"Common Patterns Summary",id:"common-patterns-summary",level:2},{value:"1. <strong>BFS Template</strong>",id:"1-bfs-template",level:3},{value:"2. <strong>Level Processing Template</strong>",id:"2-level-processing-template",level:3},{value:"3. <strong>Sliding Window with Deque</strong>",id:"3-sliding-window-with-deque",level:3},{value:"4. <strong>Multi-source BFS</strong>",id:"4-multi-source-bfs",level:3},{value:"Key Takeaways",id:"key-takeaways",level:2},{value:"\u2705 <strong>Advantages of Queues</strong>",id:"-advantages-of-queues",level:3},{value:"\u26a0\ufe0f <strong>Common Pitfalls</strong>",id:"\ufe0f-common-pitfalls",level:3},{value:"\ud83c\udfaf <strong>Best Practices</strong>",id:"-best-practices",level:3},{value:"\ud83e\udde0 <strong>Memory Tricks</strong>",id:"-memory-tricks",level:3},{value:"Quick Reference Cheat Sheet",id:"quick-reference-cheat-sheet",level:2}];function u(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"queue",children:"Queue"})}),"\n",(0,t.jsx)(n.p,{children:"A comprehensive guide to mastering queue patterns and techniques for Data Structures and Algorithms interviews and competitive programming."}),"\n",(0,t.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#introduction",children:"Introduction"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#basic-queue-operations",children:"Basic Queue Operations"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#queue-implementations",children:"Queue Implementations"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#bfs-and-level-order-traversal",children:"BFS and Level-Order Traversal"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#sliding-window-techniques",children:"Sliding Window Techniques"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#deque-double-ended-queue",children:"Deque (Double-Ended Queue)"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#priority-queue-applications",children:"Priority Queue Applications"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#monotonic-queue",children:"Monotonic Queue"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#queue-based-algorithms",children:"Queue-Based Algorithms"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#advanced-patterns",children:"Advanced Patterns"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#problem-solving-framework",children:"Problem-Solving Framework"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#practice-problems",children:"Practice Problems"})}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Queues"})," follow the ",(0,t.jsx)(n.strong,{children:"FIFO (First In, First Out)"})," principle and are fundamental for many algorithmic patterns. They're essential for:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Breadth-First Search (BFS)"})," traversals"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Level-order processing"})," in trees and graphs"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Sliding window"})," problems with deque optimization"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Task scheduling"})," and buffering"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Stream processing"})," and real-time systems"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"when-to-use-queues",children:"When to Use Queues"}),"\n",(0,t.jsxs)(n.p,{children:["\u2705 ",(0,t.jsx)(n.strong,{children:"Use when you need:"})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Process elements in order of arrival"}),"\n",(0,t.jsx)(n.li,{children:"Level-by-level traversal (BFS)"}),"\n",(0,t.jsx)(n.li,{children:"Sliding window with efficient add/remove from both ends"}),"\n",(0,t.jsx)(n.li,{children:"Task scheduling or buffering"}),"\n",(0,t.jsx)(n.li,{children:"Finding shortest paths in unweighted graphs"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["\u274c ",(0,t.jsx)(n.strong,{children:"Avoid when:"})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Need random access to elements"}),"\n",(0,t.jsx)(n.li,{children:"LIFO behavior is required (use stack instead)"}),"\n",(0,t.jsx)(n.li,{children:"Need frequent middle insertions/deletions"}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"basic-queue-operations",children:"Basic Queue Operations"}),"\n",(0,t.jsx)(n.h3,{id:"standard-queue-interface",children:"Standard Queue Interface"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"class Queue {\n    constructor() {\n        this.items = [];\n        this.front = 0;\n        this.rear = 0;\n    }\n\n    // Add element to rear\n    enqueue(item) {\n        this.items[this.rear] = item;\n        this.rear++;\n    }\n\n    // Remove element from front\n    dequeue() {\n        if (this.isEmpty()) return undefined;\n\n        const item = this.items[this.front];\n        this.items[this.front] = undefined; // Clean up\n        this.front++;\n\n        // Reset when queue becomes empty\n        if (this.front === this.rear) {\n            this.front = 0;\n            this.rear = 0;\n        }\n\n        return item;\n    }\n\n    // Peek at front element\n    peek() {\n        if (this.isEmpty()) return undefined;\n        return this.items[this.front];\n    }\n\n    // Check if queue is empty\n    isEmpty() {\n        return this.front === this.rear;\n    }\n\n    // Get queue size\n    size() {\n        return this.rear - this.front;\n    }\n\n    // Clear the queue\n    clear() {\n        this.items = [];\n        this.front = 0;\n        this.rear = 0;\n    }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Time Complexities:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Enqueue: O(1)"}),"\n",(0,t.jsx)(n.li,{children:"Dequeue: O(1)"}),"\n",(0,t.jsx)(n.li,{children:"Peek: O(1)"}),"\n",(0,t.jsx)(n.li,{children:"Size: O(1)"}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"queue-implementations",children:"Queue Implementations"}),"\n",(0,t.jsx)(n.h3,{id:"1-array-based-queue-circular-buffer",children:"1. Array-Based Queue (Circular Buffer)"}),"\n",(0,t.jsx)(n.p,{children:"Efficient implementation avoiding array shifting:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'class CircularQueue {\n    constructor(capacity = 10) {\n        this.items = new Array(capacity);\n        this.front = 0;\n        this.rear = 0;\n        this.size = 0;\n        this.capacity = capacity;\n    }\n\n    enqueue(item) {\n        if (this.isFull()) {\n            throw new Error("Queue is full");\n        }\n\n        this.items[this.rear] = item;\n        this.rear = (this.rear + 1) % this.capacity;\n        this.size++;\n    }\n\n    dequeue() {\n        if (this.isEmpty()) return undefined;\n\n        const item = this.items[this.front];\n        this.items[this.front] = undefined;\n        this.front = (this.front + 1) % this.capacity;\n        this.size--;\n\n        return item;\n    }\n\n    isFull() {\n        return this.size === this.capacity;\n    }\n\n    isEmpty() {\n        return this.size === 0;\n    }\n\n    peek() {\n        return this.isEmpty() ? undefined : this.items[this.front];\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"2-linked-list-based-queue",children:"2. Linked List-Based Queue"}),"\n",(0,t.jsx)(n.p,{children:"Dynamic size with efficient operations:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"class QueueNode {\n    constructor(val) {\n        this.val = val;\n        this.next = null;\n    }\n}\n\nclass LinkedQueue {\n    constructor() {\n        this.front = null;\n        this.rear = null;\n        this.size = 0;\n    }\n\n    enqueue(val) {\n        const newNode = new QueueNode(val);\n\n        if (this.rear) {\n            this.rear.next = newNode;\n        } else {\n            this.front = newNode; // First element\n        }\n\n        this.rear = newNode;\n        this.size++;\n    }\n\n    dequeue() {\n        if (!this.front) return undefined;\n\n        const val = this.front.val;\n        this.front = this.front.next;\n\n        if (!this.front) {\n            this.rear = null; // Queue became empty\n        }\n\n        this.size--;\n        return val;\n    }\n\n    peek() {\n        return this.front ? this.front.val : undefined;\n    }\n\n    isEmpty() {\n        return this.front === null;\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"3-two-stack-queue-implementation",children:"3. Two-Stack Queue Implementation"}),"\n",(0,t.jsx)(n.p,{children:"Queue using two stacks (interview favorite):"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"class TwoStackQueue {\n    constructor() {\n        this.inStack = [];   // For enqueue operations\n        this.outStack = [];  // For dequeue operations\n    }\n\n    enqueue(item) {\n        this.inStack.push(item);\n    }\n\n    dequeue() {\n        this._moveElements();\n        return this.outStack.pop();\n    }\n\n    peek() {\n        this._moveElements();\n        return this.outStack[this.outStack.length - 1];\n    }\n\n    isEmpty() {\n        return this.inStack.length === 0 && this.outStack.length === 0;\n    }\n\n    size() {\n        return this.inStack.length + this.outStack.length;\n    }\n\n    // Move elements from inStack to outStack when needed\n    _moveElements() {\n        if (this.outStack.length === 0) {\n            while (this.inStack.length > 0) {\n                this.outStack.push(this.inStack.pop());\n            }\n        }\n    }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Amortized Analysis:"})," Each element is moved at most twice, so average O(1) per operation."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"bfs-and-level-order-traversal",children:"BFS and Level-Order Traversal"}),"\n",(0,t.jsx)(n.h3,{id:"1-binary-tree-level-order-traversal",children:"1. Binary Tree Level-Order Traversal"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Problem:"})," Traverse tree level by level, returning each level as a separate array."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function levelOrder(root) {\n    if (!root) return [];\n\n    const result = [];\n    const queue = [root];\n\n    while (queue.length > 0) {\n        const levelSize = queue.length;\n        const currentLevel = [];\n\n        // Process all nodes at current level\n        for (let i = 0; i < levelSize; i++) {\n            const node = queue.shift();\n            currentLevel.push(node.val);\n\n            // Add children to queue for next level\n            if (node.left) queue.push(node.left);\n            if (node.right) queue.push(node.right);\n        }\n\n        result.push(currentLevel);\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Time Complexity:"})," O(n) | ",(0,t.jsx)(n.strong,{children:"Space Complexity:"})," O(w) where w is maximum width"]}),"\n",(0,t.jsx)(n.h3,{id:"2-zigzag-level-order-traversal",children:"2. Zigzag Level Order Traversal"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Problem:"})," Traverse tree in zigzag pattern (left-to-right, then right-to-left alternately)."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function zigzagLevelOrder(root) {\n    if (!root) return [];\n\n    const result = [];\n    const queue = [root];\n    let leftToRight = true;\n\n    while (queue.length > 0) {\n        const levelSize = queue.length;\n        const currentLevel = [];\n\n        for (let i = 0; i < levelSize; i++) {\n            const node = queue.shift();\n\n            // Add to front or back based on direction\n            if (leftToRight) {\n                currentLevel.push(node.val);\n            } else {\n                currentLevel.unshift(node.val);\n            }\n\n            if (node.left) queue.push(node.left);\n            if (node.right) queue.push(node.right);\n        }\n\n        result.push(currentLevel);\n        leftToRight = !leftToRight; // Flip direction\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"3-binary-tree-right-side-view",children:"3. Binary Tree Right Side View"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Problem:"})," Return values of nodes you can see from the right side of tree."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function rightSideView(root) {\n    if (!root) return [];\n\n    const result = [];\n    const queue = [root];\n\n    while (queue.length > 0) {\n        const levelSize = queue.length;\n\n        for (let i = 0; i < levelSize; i++) {\n            const node = queue.shift();\n\n            // Last node in level is visible from right\n            if (i === levelSize - 1) {\n                result.push(node.val);\n            }\n\n            if (node.left) queue.push(node.left);\n            if (node.right) queue.push(node.right);\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"4-graph-bfs-shortest-path",children:"4. Graph BFS (Shortest Path)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Problem:"})," Find shortest path in unweighted graph."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function shortestPath(graph, start, target) {\n    if (start === target) return 0;\n\n    const queue = [[start, 0]]; // [node, distance]\n    const visited = new Set([start]);\n\n    while (queue.length > 0) {\n        const [node, distance] = queue.shift();\n\n        // Check all neighbors\n        for (const neighbor of graph[node] || []) {\n            if (neighbor === target) {\n                return distance + 1;\n            }\n\n            if (!visited.has(neighbor)) {\n                visited.add(neighbor);\n                queue.push([neighbor, distance + 1]);\n            }\n        }\n    }\n\n    return -1; // Path not found\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"5-word-ladder-bfs-application",children:"5. Word Ladder (BFS Application)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Problem:"})," Find minimum transformation sequence from start word to end word."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function ladderLength(beginWord, endWord, wordList) {\n    const wordSet = new Set(wordList);\n    if (!wordSet.has(endWord)) return 0;\n\n    const queue = [[beginWord, 1]]; // [word, transformations]\n    const visited = new Set([beginWord]);\n\n    while (queue.length > 0) {\n        const [word, steps] = queue.shift();\n\n        if (word === endWord) {\n            return steps;\n        }\n\n        // Try all possible one-letter transformations\n        for (let i = 0; i < word.length; i++) {\n            for (let c = 97; c <= 122; c++) { // 'a' to 'z'\n                const newChar = String.fromCharCode(c);\n                if (newChar === word[i]) continue;\n\n                const newWord = word.slice(0, i) + newChar + word.slice(i + 1);\n\n                if (wordSet.has(newWord) && !visited.has(newWord)) {\n                    visited.add(newWord);\n                    queue.push([newWord, steps + 1]);\n                }\n            }\n        }\n    }\n\n    return 0; // No transformation possible\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"sliding-window-techniques",children:"Sliding Window Techniques"}),"\n",(0,t.jsx)(n.h3,{id:"1-sliding-window-maximum-deque",children:"1. Sliding Window Maximum (Deque)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Problem:"})," Find maximum in each sliding window of size k."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function maxSlidingWindow(nums, k) {\n    const result = [];\n    const deque = []; // Stores indices\n\n    for (let i = 0; i < nums.length; i++) {\n        // Remove indices outside current window\n        while (deque.length > 0 && deque[0] <= i - k) {\n            deque.shift();\n        }\n\n        // Remove indices with smaller values (maintain decreasing order)\n        while (deque.length > 0 && nums[deque[deque.length - 1]] <= nums[i]) {\n            deque.pop();\n        }\n\n        deque.push(i);\n\n        // Add maximum to result when window is complete\n        if (i >= k - 1) {\n            result.push(nums[deque[0]]);\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Time Complexity:"})," O(n) | ",(0,t.jsx)(n.strong,{children:"Space Complexity:"})," O(k)"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"\ud83d\udca1 Key Insight:"})," Deque maintains indices in decreasing order of their values, so front always has the maximum."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"2-first-negative-in-window",children:"2. First Negative in Window"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Problem:"})," Find first negative number in each sliding window."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function firstNegativeInWindow(arr, k) {\n    const result = [];\n    const queue = []; // Stores indices of negative numbers\n\n    for (let i = 0; i < arr.length; i++) {\n        // Remove indices outside current window\n        while (queue.length > 0 && queue[0] <= i - k) {\n            queue.shift();\n        }\n\n        // Add current index if number is negative\n        if (arr[i] < 0) {\n            queue.push(i);\n        }\n\n        // Add result when window is complete\n        if (i >= k - 1) {\n            if (queue.length > 0) {\n                result.push(arr[queue[0]]);\n            } else {\n                result.push(0); // No negative number in window\n            }\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"3-generate-binary-numbers",children:"3. Generate Binary Numbers"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Problem:"})," Generate binary representations of numbers 1 to n using queue."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'function generateBinary(n) {\n    if (n <= 0) return [];\n\n    const result = [];\n    const queue = ["1"];\n\n    for (let i = 0; i < n; i++) {\n        const current = queue.shift();\n        result.push(current);\n\n        // Generate next binary numbers by appending 0 and 1\n        queue.push(current + "0");\n        queue.push(current + "1");\n    }\n\n    return result;\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Pattern Recognition:"})," Each binary number generates two new numbers by appending 0 and 1."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"deque-double-ended-queue",children:"Deque (Double-Ended Queue)"}),"\n",(0,t.jsx)(n.h3,{id:"javascript-deque-implementation",children:"JavaScript Deque Implementation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"class Deque {\n    constructor() {\n        this.items = [];\n        this.front = 0;\n        this.rear = 0;\n    }\n\n    // Add to front\n    addFront(item) {\n        this.front--;\n        this.items[this.front] = item;\n    }\n\n    // Add to rear\n    addRear(item) {\n        this.items[this.rear] = item;\n        this.rear++;\n    }\n\n    // Remove from front\n    removeFront() {\n        if (this.isEmpty()) return undefined;\n\n        const item = this.items[this.front];\n        this.items[this.front] = undefined;\n        this.front++;\n\n        if (this.front === this.rear) {\n            this.front = 0;\n            this.rear = 0;\n        }\n\n        return item;\n    }\n\n    // Remove from rear\n    removeRear() {\n        if (this.isEmpty()) return undefined;\n\n        this.rear--;\n        const item = this.items[this.rear];\n        this.items[this.rear] = undefined;\n\n        if (this.front === this.rear) {\n            this.front = 0;\n            this.rear = 0;\n        }\n\n        return item;\n    }\n\n    peekFront() {\n        return this.isEmpty() ? undefined : this.items[this.front];\n    }\n\n    peekRear() {\n        return this.isEmpty() ? undefined : this.items[this.rear - 1];\n    }\n\n    isEmpty() {\n        return this.front === this.rear;\n    }\n\n    size() {\n        return this.rear - this.front;\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"palindrome-checker-with-deque",children:"Palindrome Checker with Deque"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function isPalindrome(str) {\n    const deque = new Deque();\n    const cleanStr = str.toLowerCase().replace(/[^a-z0-9]/g, '');\n\n    // Add all characters to deque\n    for (const char of cleanStr) {\n        deque.addRear(char);\n    }\n\n    // Compare characters from both ends\n    while (deque.size() > 1) {\n        if (deque.removeFront() !== deque.removeRear()) {\n            return false;\n        }\n    }\n\n    return true;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"priority-queue-applications",children:"Priority Queue Applications"}),"\n",(0,t.jsx)(n.h3,{id:"1-priority-queue-with-heap",children:"1. Priority Queue with Heap"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"class PriorityQueue {\n    constructor(compareFunc = (a, b) => a - b) {\n        this.heap = [];\n        this.compare = compareFunc;\n    }\n\n    enqueue(item) {\n        this.heap.push(item);\n        this._bubbleUp(this.heap.length - 1);\n    }\n\n    dequeue() {\n        if (this.isEmpty()) return undefined;\n\n        const root = this.heap[0];\n        const last = this.heap.pop();\n\n        if (!this.isEmpty()) {\n            this.heap[0] = last;\n            this._bubbleDown(0);\n        }\n\n        return root;\n    }\n\n    peek() {\n        return this.isEmpty() ? undefined : this.heap[0];\n    }\n\n    isEmpty() {\n        return this.heap.length === 0;\n    }\n\n    size() {\n        return this.heap.length;\n    }\n\n    _bubbleUp(index) {\n        while (index > 0) {\n            const parentIndex = Math.floor((index - 1) / 2);\n\n            if (this.compare(this.heap[index], this.heap[parentIndex]) >= 0) {\n                break;\n            }\n\n            [this.heap[index], this.heap[parentIndex]] =\n            [this.heap[parentIndex], this.heap[index]];\n\n            index = parentIndex;\n        }\n    }\n\n    _bubbleDown(index) {\n        while (true) {\n            let minIndex = index;\n            const leftChild = 2 * index + 1;\n            const rightChild = 2 * index + 2;\n\n            if (leftChild < this.heap.length &&\n                this.compare(this.heap[leftChild], this.heap[minIndex]) < 0) {\n                minIndex = leftChild;\n            }\n\n            if (rightChild < this.heap.length &&\n                this.compare(this.heap[rightChild], this.heap[minIndex]) < 0) {\n                minIndex = rightChild;\n            }\n\n            if (minIndex === index) break;\n\n            [this.heap[index], this.heap[minIndex]] =\n            [this.heap[minIndex], this.heap[index]];\n\n            index = minIndex;\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"2-task-scheduler",children:"2. Task Scheduler"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Problem:"})," Schedule tasks with cooldown period to minimize idle time."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function leastInterval(tasks, n) {\n    // Count frequency of each task\n    const taskCount = new Map();\n    for (const task of tasks) {\n        taskCount.set(task, (taskCount.get(task) || 0) + 1);\n    }\n\n    // Max heap based on frequency\n    const pq = new PriorityQueue((a, b) => b - a);\n    for (const count of taskCount.values()) {\n        pq.enqueue(count);\n    }\n\n    let time = 0;\n    const queue = []; // [count, availableTime]\n\n    while (!pq.isEmpty() || queue.length > 0) {\n        time++;\n\n        // Move tasks back to priority queue when cooldown is over\n        if (queue.length > 0 && queue[0][1] === time) {\n            const count = queue.shift()[0];\n            pq.enqueue(count);\n        }\n\n        // Execute highest frequency task\n        if (!pq.isEmpty()) {\n            const count = pq.dequeue() - 1;\n            if (count > 0) {\n                queue.push([count, time + n + 1]);\n            }\n        }\n    }\n\n    return time;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"3-top-k-frequent-elements",children:"3. Top K Frequent Elements"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Problem:"})," Find k most frequent elements in array."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function topKFrequent(nums, k) {\n    // Count frequencies\n    const freqMap = new Map();\n    for (const num of nums) {\n        freqMap.set(num, (freqMap.get(num) || 0) + 1);\n    }\n\n    // Min heap of size k\n    const pq = new PriorityQueue((a, b) => a[1] - b[1]);\n\n    for (const [num, freq] of freqMap.entries()) {\n        pq.enqueue([num, freq]);\n\n        if (pq.size() > k) {\n            pq.dequeue();\n        }\n    }\n\n    const result = [];\n    while (!pq.isEmpty()) {\n        result.push(pq.dequeue()[0]);\n    }\n\n    return result.reverse();\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"monotonic-queue",children:"Monotonic Queue"}),"\n",(0,t.jsx)(n.p,{children:"A queue that maintains elements in monotonic (increasing/decreasing) order."}),"\n",(0,t.jsx)(n.h3,{id:"1-largest-rectangle-in-histogram",children:"1. Largest Rectangle in Histogram"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Problem:"})," Find area of largest rectangle in histogram."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function largestRectangleArea(heights) {\n    const stack = []; // Monotonic increasing stack (acts like queue)\n    let maxArea = 0;\n\n    for (let i = 0; i <= heights.length; i++) {\n        const currentHeight = i === heights.length ? 0 : heights[i];\n\n        while (stack.length > 0 && heights[stack[stack.length - 1]] > currentHeight) {\n            const height = heights[stack.pop()];\n            const width = stack.length === 0 ? i : i - stack[stack.length - 1] - 1;\n            maxArea = Math.max(maxArea, height * width);\n        }\n\n        stack.push(i);\n    }\n\n    return maxArea;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"2-sliding-window-minimum",children:"2. Sliding Window Minimum"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Problem:"})," Find minimum in each sliding window using monotonic deque."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function slidingWindowMinimum(nums, k) {\n    const result = [];\n    const deque = []; // Stores indices in increasing order of values\n\n    for (let i = 0; i < nums.length; i++) {\n        // Remove indices outside window\n        while (deque.length > 0 && deque[0] <= i - k) {\n            deque.shift();\n        }\n\n        // Maintain increasing order\n        while (deque.length > 0 && nums[deque[deque.length - 1]] >= nums[i]) {\n            deque.pop();\n        }\n\n        deque.push(i);\n\n        if (i >= k - 1) {\n            result.push(nums[deque[0]]);\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"queue-based-algorithms",children:"Queue-Based Algorithms"}),"\n",(0,t.jsx)(n.h3,{id:"1-breadth-first-search-template",children:"1. Breadth-First Search Template"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function bfsTemplate(start, isTarget, getNeighbors) {\n    const queue = [start];\n    const visited = new Set([start]);\n    const parent = new Map();\n    let level = 0;\n\n    while (queue.length > 0) {\n        const levelSize = queue.length;\n\n        // Process all nodes at current level\n        for (let i = 0; i < levelSize; i++) {\n            const node = queue.shift();\n\n            if (isTarget(node)) {\n                return reconstructPath(node, parent);\n            }\n\n            for (const neighbor of getNeighbors(node)) {\n                if (!visited.has(neighbor)) {\n                    visited.add(neighbor);\n                    parent.set(neighbor, node);\n                    queue.push(neighbor);\n                }\n            }\n        }\n\n        level++;\n    }\n\n    return null; // Target not found\n}\n\nfunction reconstructPath(target, parent) {\n    const path = [];\n    let current = target;\n\n    while (current !== undefined) {\n        path.unshift(current);\n        current = parent.get(current);\n    }\n\n    return path;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"2-multi-source-bfs",children:"2. Multi-Source BFS"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Problem:"})," Find distance from nearest obstacle/source for all cells."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function nearestObstacle(matrix) {\n    const rows = matrix.length;\n    const cols = matrix[0].length;\n    const queue = [];\n    const distances = Array(rows).fill().map(() => Array(cols).fill(Infinity));\n\n    // Add all obstacles to queue as starting points\n    for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n            if (matrix[i][j] === 1) { // Obstacle\n                queue.push([i, j, 0]);\n                distances[i][j] = 0;\n            }\n        }\n    }\n\n    const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];\n\n    while (queue.length > 0) {\n        const [row, col, dist] = queue.shift();\n\n        for (const [dr, dc] of directions) {\n            const newRow = row + dr;\n            const newCol = col + dc;\n\n            if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {\n                const newDist = dist + 1;\n\n                if (newDist < distances[newRow][newCol]) {\n                    distances[newRow][newCol] = newDist;\n                    queue.push([newRow, newCol, newDist]);\n                }\n            }\n        }\n    }\n\n    return distances;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"3-rotting-oranges",children:"3. Rotting Oranges"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Problem:"})," Find minimum time for all oranges to rot."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function orangesRotting(grid) {\n    const rows = grid.length;\n    const cols = grid[0].length;\n    const queue = [];\n    let freshCount = 0;\n\n    // Find initial rotten oranges and count fresh ones\n    for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n            if (grid[i][j] === 2) {\n                queue.push([i, j, 0]); // [row, col, time]\n            } else if (grid[i][j] === 1) {\n                freshCount++;\n            }\n        }\n    }\n\n    if (freshCount === 0) return 0;\n\n    const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];\n    let maxTime = 0;\n\n    while (queue.length > 0) {\n        const [row, col, time] = queue.shift();\n\n        for (const [dr, dc] of directions) {\n            const newRow = row + dr;\n            const newCol = col + dc;\n\n            if (newRow >= 0 && newRow < rows &&\n                newCol >= 0 && newCol < cols &&\n                grid[newRow][newCol] === 1) {\n\n                grid[newRow][newCol] = 2; // Rot the orange\n                freshCount--;\n                maxTime = Math.max(maxTime, time + 1);\n                queue.push([newRow, newCol, time + 1]);\n            }\n        }\n    }\n\n    return freshCount === 0 ? maxTime : -1;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"advanced-patterns",children:"Advanced Patterns"}),"\n",(0,t.jsx)(n.h3,{id:"1-queue-reconstruction-by-height",children:"1. Queue Reconstruction by Height"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Problem:"})," Reconstruct queue based on height and people in front."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function reconstructQueue(people) {\n    // Sort by height desc, then by k asc\n    people.sort((a, b) => {\n        if (a[0] !== b[0]) {\n            return b[0] - a[0]; // Taller first\n        }\n        return a[1] - b[1]; // Smaller k first\n    });\n\n    const result = [];\n\n    // Insert each person at position k\n    for (const person of people) {\n        result.splice(person[1], 0, person);\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"2-design-hit-counter",children:"2. Design Hit Counter"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Problem:"})," Count hits in the last 5 minutes using queue."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"class HitCounter {\n    constructor() {\n        this.hits = []; // Queue of timestamps\n    }\n\n    hit(timestamp) {\n        this.hits.push(timestamp);\n        this._removeOldHits(timestamp);\n    }\n\n    getHits(timestamp) {\n        this._removeOldHits(timestamp);\n        return this.hits.length;\n    }\n\n    _removeOldHits(timestamp) {\n        // Remove hits older than 5 minutes (300 seconds)\n        while (this.hits.length > 0 &&\n               this.hits[0] <= timestamp - 300) {\n            this.hits.shift();\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"3-shortest-bridge-bfs--dfs",children:"3. Shortest Bridge (BFS + DFS)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Problem:"})," Find shortest bridge between two islands."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function shortestBridge(grid) {\n    const rows = grid.length;\n    const cols = grid[0].length;\n    const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];\n\n    // Find first island using DFS\n    const firstIsland = [];\n    let found = false;\n\n    for (let i = 0; i < rows && !found; i++) {\n        for (let j = 0; j < cols && !found; j++) {\n            if (grid[i][j] === 1) {\n                dfs(i, j);\n                found = true;\n            }\n        }\n    }\n\n    function dfs(row, col) {\n        if (row < 0 || row >= rows || col < 0 || col >= cols ||\n            grid[row][col] !== 1) {\n            return;\n        }\n\n        grid[row][col] = 2; // Mark as visited\n        firstIsland.push([row, col]);\n\n        for (const [dr, dc] of directions) {\n            dfs(row + dr, col + dc);\n        }\n    }\n\n    // BFS from first island to find second island\n    const queue = [...firstIsland.map(pos => [...pos, 0])];\n\n    while (queue.length > 0) {\n        const [row, col, distance] = queue.shift();\n\n        for (const [dr, dc] of directions) {\n            const newRow = row + dr;\n            const newCol = col + dc;\n\n            if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {\n                if (grid[newRow][newCol] === 1) {\n                    return distance; // Found second island\n                } else if (grid[newRow][newCol] === 0) {\n                    grid[newRow][newCol] = 2; // Mark as visited\n                    queue.push([newRow, newCol, distance + 1]);\n                }\n            }\n        }\n    }\n\n    return -1; // Should never reach here\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"4-design-circular-queue",children:"4. Design Circular Queue"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Problem:"})," Implement a circular queue with fixed size."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"class MyCircularQueue {\n    constructor(k) {\n        this.size = k;\n        this.queue = new Array(k);\n        this.front = 0;\n        this.rear = 0;\n        this.count = 0;\n    }\n\n    enQueue(value) {\n        if (this.isFull()) return false;\n\n        this.queue[this.rear] = value;\n        this.rear = (this.rear + 1) % this.size;\n        this.count++;\n        return true;\n    }\n\n    deQueue() {\n        if (this.isEmpty()) return false;\n\n        this.queue[this.front] = undefined;\n        this.front = (this.front + 1) % this.size;\n        this.count--;\n        return true;\n    }\n\n    Front() {\n        return this.isEmpty() ? -1 : this.queue[this.front];\n    }\n\n    Rear() {\n        if (this.isEmpty()) return -1;\n        const rearIndex = (this.rear - 1 + this.size) % this.size;\n        return this.queue[rearIndex];\n    }\n\n    isEmpty() {\n        return this.count === 0;\n    }\n\n    isFull() {\n        return this.count === this.size;\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"5-moving-average-from-data-stream",children:"5. Moving Average from Data Stream"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Problem:"})," Calculate moving average of last size numbers."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"class MovingAverage {\n    constructor(size) {\n        this.size = size;\n        this.queue = [];\n        this.sum = 0;\n    }\n\n    next(val) {\n        this.queue.push(val);\n        this.sum += val;\n\n        // Remove oldest element if queue exceeds size\n        if (this.queue.length > this.size) {\n            this.sum -= this.queue.shift();\n        }\n\n        return this.sum / this.queue.length;\n    }\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"problem-solving-framework",children:"Problem-Solving Framework"}),"\n",(0,t.jsx)(n.h3,{id:"queue-pattern-recognition",children:"Queue Pattern Recognition"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Level-by-level processing"})," \u2192 BFS with queue"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Shortest path in unweighted graph"})," \u2192 BFS"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Sliding window maximum/minimum"})," \u2192 Deque"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"First/last element in window"})," \u2192 Queue with cleanup"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Multi-source shortest path"})," \u2192 Multi-source BFS"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Tree/graph traversal by levels"})," \u2192 Level-order BFS"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"step-by-step-approach",children:"Step-by-Step Approach"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function queueProblemTemplate(input) {\n    // 1. Identify the pattern\n    // - BFS traversal?\n    // - Sliding window?\n    // - Level processing?\n\n    // 2. Choose appropriate queue type\n    const queue = []; // or Deque, PriorityQueue\n\n    // 3. Initialize with starting state\n    queue.push(initialState);\n    const visited = new Set(); // if needed\n\n    // 4. Process until queue is empty\n    while (queue.length > 0) {\n        // Level processing (optional)\n        const levelSize = queue.length;\n\n        for (let i = 0; i < levelSize; i++) {\n            const current = queue.shift();\n\n            // Process current element\n            if (isTarget(current)) {\n                return result;\n            }\n\n            // Add neighbors/next states\n            for (const next of getNext(current)) {\n                if (!visited.has(next)) {\n                    visited.add(next);\n                    queue.push(next);\n                }\n            }\n        }\n    }\n\n    return defaultResult;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"practice-problems",children:"Practice Problems"}),"\n",(0,t.jsx)(n.h3,{id:"beginner-level",children:"Beginner Level"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Implement Queue using Stacks"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Binary Tree Level Order Traversal"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"First Negative Number in Window"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Generate Binary Numbers"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Design Circular Queue"})}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"intermediate-level",children:"Intermediate Level"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Sliding Window Maximum"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Rotting Oranges"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Word Ladder"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Binary Tree Zigzag Traversal"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Task Scheduler"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Moving Average from Data Stream"})}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"advanced-level",children:"Advanced Level"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Shortest Bridge"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Queue Reconstruction by Height"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Design Hit Counter"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Largest Rectangle in Histogram"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Minimum Window Substring"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Cut Off Trees for Golf Event"})}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"expert-level",children:"Expert Level"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Alien Dictionary"})," (Topological Sort + Queue)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Bus Routes"})," (BFS with queue)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Sliding Window Median"})," (Two heaps + deque)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Jump Game IV"})," (BFS optimization)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Race Car"})," (BFS state space)"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"time-complexity-summary",children:"Time Complexity Summary"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Operation/Algorithm"}),(0,t.jsx)(n.th,{children:"Time Complexity"}),(0,t.jsx)(n.th,{children:"Space Complexity"}),(0,t.jsx)(n.th,{children:"Use Case"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Queue Operations"}),(0,t.jsx)(n.td,{children:"O(1)"}),(0,t.jsx)(n.td,{children:"O(1)"}),(0,t.jsx)(n.td,{children:"Basic enqueue/dequeue"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"BFS Traversal"}),(0,t.jsx)(n.td,{children:"O(V + E)"}),(0,t.jsx)(n.td,{children:"O(V)"}),(0,t.jsx)(n.td,{children:"Graph/tree traversal"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Level Order"}),(0,t.jsx)(n.td,{children:"O(n)"}),(0,t.jsx)(n.td,{children:"O(w)"}),(0,t.jsx)(n.td,{children:"Tree level processing"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Sliding Window Max"}),(0,t.jsx)(n.td,{children:"O(n)"}),(0,t.jsx)(n.td,{children:"O(k)"}),(0,t.jsx)(n.td,{children:"Window optimization"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Priority Queue Ops"}),(0,t.jsx)(n.td,{children:"O(log n)"}),(0,t.jsx)(n.td,{children:"O(n)"}),(0,t.jsx)(n.td,{children:"Heap-based operations"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Multi-source BFS"}),(0,t.jsx)(n.td,{children:"O(V + E)"}),(0,t.jsx)(n.td,{children:"O(V)"}),(0,t.jsx)(n.td,{children:"Multiple starting points"})]})]})]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"common-patterns-summary",children:"Common Patterns Summary"}),"\n",(0,t.jsxs)(n.h3,{id:"1-bfs-template",children:["1. ",(0,t.jsx)(n.strong,{children:"BFS Template"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const queue = [start];\nconst visited = new Set([start]);\n\nwhile (queue.length > 0) {\n    const node = queue.shift();\n    // Process node\n    for (const neighbor of getNeighbors(node)) {\n        if (!visited.has(neighbor)) {\n            visited.add(neighbor);\n            queue.push(neighbor);\n        }\n    }\n}\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"2-level-processing-template",children:["2. ",(0,t.jsx)(n.strong,{children:"Level Processing Template"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"while (queue.length > 0) {\n    const levelSize = queue.length;\n    const currentLevel = [];\n\n    for (let i = 0; i < levelSize; i++) {\n        const node = queue.shift();\n        currentLevel.push(node.val);\n        // Add children\n    }\n\n    result.push(currentLevel);\n}\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"3-sliding-window-with-deque",children:["3. ",(0,t.jsx)(n.strong,{children:"Sliding Window with Deque"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const deque = [];\nfor (let i = 0; i < arr.length; i++) {\n    // Remove outside window\n    while (deque.length > 0 && deque[0] <= i - k) {\n        deque.shift();\n    }\n\n    // Maintain monotonic property\n    while (deque.length > 0 && condition) {\n        deque.pop();\n    }\n\n    deque.push(i);\n    if (i >= k - 1) result.push(arr[deque[0]]);\n}\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"4-multi-source-bfs",children:["4. ",(0,t.jsx)(n.strong,{children:"Multi-source BFS"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const queue = [];\n// Add all sources\nfor (const source of sources) {\n    queue.push([source, 0]);\n    visited.add(source);\n}\n\nwhile (queue.length > 0) {\n    const [node, distance] = queue.shift();\n    // Process and add neighbors\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,t.jsxs)(n.h3,{id:"-advantages-of-queues",children:["\u2705 ",(0,t.jsx)(n.strong,{children:"Advantages of Queues"})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"FIFO ordering"})," ensures proper sequence"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Level-by-level processing"})," for trees/graphs"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Optimal for BFS"})," and shortest path problems"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Sliding window optimization"})," with deque"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Efficient buffering"})," and task scheduling"]}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"\ufe0f-common-pitfalls",children:["\u26a0\ufe0f ",(0,t.jsx)(n.strong,{children:"Common Pitfalls"})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Forgetting to check empty queue"})," before dequeue"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Not handling edge cases"})," (empty input, single element)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Incorrect level processing"})," in BFS"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Memory leaks"})," from not cleaning up references"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Wrong queue type"})," for the problem"]}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"-best-practices",children:["\ud83c\udfaf ",(0,t.jsx)(n.strong,{children:"Best Practices"})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Use ",(0,t.jsx)(n.strong,{children:"appropriate queue implementation"})," for the problem"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Validate input"})," and handle edge cases"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Choose right data structure"}),": Array, LinkedList, or specialized queue"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Consider space optimization"})," for large datasets"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Test with various inputs"})," including edge cases"]}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"-memory-tricks",children:["\ud83e\udde0 ",(0,t.jsx)(n.strong,{children:"Memory Tricks"})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:'"Queue = Line"'})," \u2192 First come, first served"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"BFS = Queue"})," \u2192 Level by level exploration"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Deque = Double power"})," \u2192 Add/remove from both ends"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Priority Queue = VIP line"})," \u2192 Most important first"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Sliding window = Moving frame"})," \u2192 Deque for optimization"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"quick-reference-cheat-sheet",children:"Quick Reference Cheat Sheet"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// Basic Queue Operations\nqueue.push(item);      // enqueue\nqueue.shift();         // dequeue\nqueue[0];             // peek front\n\n// BFS Pattern\nwhile (queue.length > 0) {\n    const node = queue.shift();\n    // process node\n    // add neighbors to queue\n}\n\n// Level Order Pattern\nwhile (queue.length > 0) {\n    const size = queue.length;\n    for (let i = 0; i < size; i++) {\n        const node = queue.shift();\n        // process level\n    }\n}\n\n// Sliding Window Maximum (Deque)\nwhile (deque[0] <= i - k) deque.shift();\nwhile (nums[deque[deque.length-1]] <= nums[i]) deque.pop();\ndeque.push(i);\n\n// Priority Queue (Min Heap)\nconst pq = new PriorityQueue((a, b) => a - b);\npq.enqueue(item);\npq.dequeue(); // returns minimum\n"})}),"\n",(0,t.jsx)(n.hr,{})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>o});var t=i(6540);const s={},r=t.createContext(s);function l(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);