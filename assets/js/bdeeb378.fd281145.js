"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[2575],{3883:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>a,toc:()=>u});var r=t(4848),o=t(8453);const i={title:"Counting Sort",description:"A detailed guide to understanding and implementing Counting Sort."},s="Counting Sort",a={id:"DSA/CountingSort",title:"Counting Sort",description:"A detailed guide to understanding and implementing Counting Sort.",source:"@site/docs/DSA/CountingSort.mdx",sourceDirName:"DSA",slug:"/DSA/CountingSort",permalink:"/js.enigma/docs/DSA/CountingSort",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/CountingSort.mdx",tags:[],version:"current",frontMatter:{title:"Counting Sort",description:"A detailed guide to understanding and implementing Counting Sort."},sidebar:"tutorialSidebar",previous:{title:"Combinations and Modular Inverse",permalink:"/js.enigma/docs/DSA/Combinatrix"},next:{title:"Cycle Detection in Graphs",permalink:"/js.enigma/docs/DSA/CycleDetectionGraph"}},c={},u=[{value:"How Counting Sort Works",id:"how-counting-sort-works",level:2},{value:"Algorithm Steps",id:"algorithm-steps",level:3},{value:"Pseudocode",id:"pseudocode",level:3}];function l(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"counting-sort",children:"Counting Sort"})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Counting Sort"})," is an integer sorting algorithm that is particularly efficient when the range of input values (i.e., the range of possible values) is known and relatively small. It works by counting the occurrences of each unique value and then using these counts to determine the positions of each value in the sorted output."]}),"\n",(0,r.jsx)(e.h2,{id:"how-counting-sort-works",children:"How Counting Sort Works"}),"\n",(0,r.jsxs)(e.p,{children:["Counting Sort is a non-comparison-based sorting algorithm that operates in ",(0,r.jsx)(e.code,{children:"O(n + k)"})," time complexity, where ",(0,r.jsx)(e.code,{children:"n"})," is the number of elements in the input array and ",(0,r.jsx)(e.code,{children:"k"})," is the range of the input values. It is useful for sorting integers or categorical data."]}),"\n",(0,r.jsx)(e.h3,{id:"algorithm-steps",children:"Algorithm Steps"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Find the Range:"})," Determine the maximum and minimum values in the input array."]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Create a Count Array:"})," Create an array ",(0,r.jsx)(e.code,{children:"count"})," where the index represents the value and the value at that index represents the count of occurrences."]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Accumulate Counts:"})," Modify the ",(0,r.jsx)(e.code,{children:"count"})," array such that each element at index ",(0,r.jsx)(e.code,{children:"i"})," contains the sum of counts up to index ",(0,r.jsx)(e.code,{children:"i"}),"."]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Build the Output Array:"})," Use the accumulated counts to place each element in its correct position in the output array."]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"pseudocode",children:"Pseudocode"}),"\n",(0,r.jsx)(e.p,{children:"Here\u2019s the pseudocode for Counting Sort:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-Javascript",children:"function countingSort(arr) {\r\n  if (arr.length === 0) return arr;\r\n\r\n  const max = Math.max(...arr);\r\n  const min = Math.min(...arr);\r\n  const range = max - min + 1;\r\n\r\n  const count = new Array(range).fill(0);\r\n  const output = new Array(arr.length);\r\n\r\n  // Step 1: Populate the count array\r\n  for (let i = 0; i < arr.length; i++) {\r\n    count[arr[i] - min]++;\r\n  }\r\n\r\n  // Step 2: Modify the count array to store the cumulative sum\r\n  for (let i = 1; i < count.length; i++) {\r\n    count[i] += count[i - 1];\r\n  }\r\n\r\n  // Step 3: Build the output array\r\n  for (let i = arr.length - 1; i >= 0; i--) {\r\n    output[--count[arr[i] - min]] = arr[i];\r\n  }\r\n\r\n  // Step 4: Copy the sorted elements back to the original array\r\n  for (let i = 0; i < arr.length; i++) {\r\n    arr[i] = output[i];\r\n  }\r\n\r\n  return arr;\r\n}\r\n\r\n// Example usage\r\nconst arr = [4, 2, 2, 8, 3, 3, 1];\r\nconsole.log(countingSort(arr)); // Output: [1, 2, 2, 3, 3, 4, 8]\n"})})]})}function d(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(l,{...n})}):l(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>s,x:()=>a});var r=t(6540);const o={},i=r.createContext(o);function s(n){const e=r.useContext(i);return r.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:s(n.components),r.createElement(i.Provider,{value:e},n.children)}}}]);