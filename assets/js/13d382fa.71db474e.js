"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[1673],{28453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>d});var t=r(96540);const i={},l=t.createContext(i);function o(e){const n=t.useContext(l);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(l.Provider,{value:n},e.children)}},54742:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>u,frontMatter:()=>l,metadata:()=>d,toc:()=>s});var t=r(74848),i=r(28453);const l={},o="N-ary Tree",d={id:"DSA/DSA with Java/Nary Tree Patterns",title:"N-ary Tree",description:"Table of Contents",source:"@site/docs/DSA/DSA with Java/Nary Tree Patterns.mdx",sourceDirName:"DSA/DSA with Java",slug:"/DSA/DSA with Java/Nary Tree Patterns",permalink:"/dev.enigma/docs/DSA/DSA with Java/Nary Tree Patterns",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with Java/Nary Tree Patterns.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"LinkedList",permalink:"/dev.enigma/docs/DSA/DSA with Java/LinkedList Patterns"},next:{title:"Prefix Sum",permalink:"/dev.enigma/docs/DSA/DSA with Java/Prefix Sum Patterns"}},a={},s=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"N-ary Tree Fundamentals",id:"n-ary-tree-fundamentals",level:2},{value:"Core Node Definitions",id:"core-node-definitions",level:3},{value:"Basic N-ary Tree Operations Template",id:"basic-n-ary-tree-operations-template",level:3},{value:"Pattern 1: Tree Traversal",id:"pattern-1-tree-traversal",level:2},{value:"1.1 Preorder Traversal",id:"11-preorder-traversal",level:3},{value:"1.2 Postorder Traversal",id:"12-postorder-traversal",level:3},{value:"1.3 Level Order Traversal",id:"13-level-order-traversal",level:3},{value:"Pattern 2: Tree Properties &amp; Metrics",id:"pattern-2-tree-properties--metrics",level:2},{value:"2.1 Maximum Depth",id:"21-maximum-depth",level:3},{value:"2.2 Tree Size &amp; Node Count",id:"22-tree-size--node-count",level:3},{value:"2.3 Tree Balance &amp; Properties",id:"23-tree-balance--properties",level:3},{value:"Pattern 3: Tree Construction &amp; Serialization",id:"pattern-3-tree-construction--serialization",level:2},{value:"3.1 Serialize and Deserialize",id:"31-serialize-and-deserialize",level:3},{value:"3.2 Clone N-ary Tree",id:"32-clone-n-ary-tree",level:3},{value:"3.3 Build Tree from Traversals",id:"33-build-tree-from-traversals",level:3},{value:"Pattern 4: Path &amp; Sum Problems",id:"pattern-4-path--sum-problems",level:2},{value:"4.1 Root to Leaf Paths",id:"41-root-to-leaf-paths",level:3},{value:"4.2 Path Sum Problems",id:"42-path-sum-problems",level:3},{value:"4.3 Distance &amp; Path Queries",id:"43-distance--path-queries",level:3},{value:"Pattern 5: Level Order Operations",id:"pattern-5-level-order-operations",level:2},{value:"5.1 Level-wise Processing",id:"51-level-wise-processing",level:3},{value:"5.2 Level-based Modifications",id:"52-level-based-modifications",level:3},{value:"Pattern 6: Tree Modification",id:"pattern-6-tree-modification",level:2},{value:"6.1 Node Insertion &amp; Deletion",id:"61-node-insertion--deletion",level:3},{value:"6.2 Tree Transformation",id:"62-tree-transformation",level:3},{value:"Pattern 7: Validation &amp; Verification",id:"pattern-7-validation--verification",level:2},{value:"7.1 Tree Structure Validation",id:"71-tree-structure-validation",level:3},{value:"7.2 Property Validation",id:"72-property-validation",level:3},{value:"Pattern 8: Tree Comparison",id:"pattern-8-tree-comparison",level:2},{value:"8.1 Same Tree",id:"81-same-tree",level:3},{value:"8.2 Subtree Problems",id:"82-subtree-problems",level:3},{value:"Pattern 9: Ancestor &amp; Descendant",id:"pattern-9-ancestor--descendant",level:2},{value:"9.1 Lowest Common Ancestor",id:"91-lowest-common-ancestor",level:3},{value:"9.2 Ancestor Queries",id:"92-ancestor-queries",level:3},{value:"Pattern 10: Tree DP Problems",id:"pattern-10-tree-dp-problems",level:2},{value:"10.1 Dynamic Programming on Trees",id:"101-dynamic-programming-on-trees",level:3},{value:"10.2 Tree Statistics",id:"102-tree-statistics",level:3},{value:"Pattern 11: Multi-Tree Operations",id:"pattern-11-multi-tree-operations",level:2},{value:"11.1 Tree Merging",id:"111-tree-merging",level:3},{value:"11.2 Tree Set Operations",id:"112-tree-set-operations",level:3},{value:"Pattern 12: Advanced Tree Problems",id:"pattern-12-advanced-tree-problems",level:2},{value:"12.1 Tree Isomorphism",id:"121-tree-isomorphism",level:3},{value:"12.2 Tree Hashing",id:"122-tree-hashing",level:3},{value:"Time &amp; Space Complexity Reference[11]",id:"time--space-complexity-reference11",level:2},{value:"Best Practices &amp; Optimization Tips",id:"best-practices--optimization-tips",level:2},{value:"Implementation Guidelines",id:"implementation-guidelines",level:3},{value:"Common Optimizations",id:"common-optimizations",level:3},{value:"Interview Tips",id:"interview-tips",level:3}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"n-ary-tree",children:"N-ary Tree"})}),"\n",(0,t.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#n-ary-tree-fundamentals",children:"N-ary Tree Fundamentals"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-1-tree-traversal",children:"Pattern 1: Tree Traversal"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-2-tree-properties--metrics",children:"Pattern 2: Tree Properties & Metrics"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-3-tree-construction--serialization",children:"Pattern 3: Tree Construction & Serialization"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-4-path--sum-problems",children:"Pattern 4: Path & Sum Problems"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-5-level-order-operations",children:"Pattern 5: Level Order Operations"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-6-tree-modification",children:"Pattern 6: Tree Modification"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-7-validation--verification",children:"Pattern 7: Validation & Verification"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-8-tree-comparison",children:"Pattern 8: Tree Comparison"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-9-ancestor--descendant",children:"Pattern 9: Ancestor & Descendant"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-10-tree-dp-problems",children:"Pattern 10: Tree DP Problems"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-11-multi-tree-operations",children:"Pattern 11: Multi-Tree Operations"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-12-advanced-tree-problems",children:"Pattern 12: Advanced Tree Problems"})}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"n-ary-tree-fundamentals",children:"N-ary Tree Fundamentals"}),"\n",(0,t.jsx)(n.h3,{id:"core-node-definitions",children:"Core Node Definitions"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Standard N-ary Tree Node\nclass Node {\n    public int val;\n    public List<Node> children;\n\n    public Node() {}\n\n    public Node(int val) {\n        this.val = val;\n    }\n\n    public Node(int val, List<Node> children) {\n        this.val = val;\n        this.children = children;\n    }\n}\n\n// Alternative Implementation with Dynamic Arrays\nclass NaryNode {\n    int val;\n    List<NaryNode> children;\n\n    NaryNode(int val) {\n        this.val = val;\n        this.children = new ArrayList<>();\n    }\n\n    void addChild(NaryNode child) {\n        children.add(child);\n    }\n\n    boolean isLeaf() {\n        return children == null || children.isEmpty();\n    }\n}\n\n// First Child/Next Sibling Representation (Memory Efficient)\nclass OptimizedNode {\n    int val;\n    OptimizedNode firstChild;\n    OptimizedNode nextSibling;\n\n    OptimizedNode(int val) {\n        this.val = val;\n    }\n\n    void addChild(OptimizedNode child) {\n        if (firstChild == null) {\n            firstChild = child;\n        } else {\n            OptimizedNode current = firstChild;\n            while (current.nextSibling != null) {\n                current = current.nextSibling;\n            }\n            current.nextSibling = child;\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"basic-n-ary-tree-operations-template",children:"Basic N-ary Tree Operations Template"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"class NaryTreeOperations {\n    // Generic traversal template\n    void traverseNary(Node root, List<Integer> result, TraversalType type) {\n        if (root == null) return;\n\n        switch (type) {\n            case PREORDER:\n                result.add(root.val);\n                if (root.children != null) {\n                    for (Node child : root.children) {\n                        traverseNary(child, result, type);\n                    }\n                }\n                break;\n\n            case POSTORDER:\n                if (root.children != null) {\n                    for (Node child : root.children) {\n                        traverseNary(child, result, type);\n                    }\n                }\n                result.add(root.val);\n                break;\n        }\n    }\n\n    enum TraversalType {\n        PREORDER, POSTORDER, LEVELORDER\n    }\n\n    // Recursive template for tree problems\n    int processNode(Node node) {\n        if (node == null) return baseCase();\n\n        // Process current node\n        int currentResult = processCurrentNode(node);\n\n        // Process children\n        int childrenResult = 0;\n        if (node.children != null) {\n            for (Node child : node.children) {\n                childrenResult = combineResults(childrenResult, processNode(child));\n            }\n        }\n\n        return combineWithCurrent(currentResult, childrenResult);\n    }\n\n    // Template methods to be implemented\n    int baseCase() { return 0; }\n    int processCurrentNode(Node node) { return 1; }\n    int combineResults(int accumulated, int current) { return accumulated + current; }\n    int combineWithCurrent(int current, int children) { return current + children; }\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-1-tree-traversal",children:"Pattern 1: Tree Traversal"}),"\n",(0,t.jsx)(n.h3,{id:"11-preorder-traversal",children:"1.1 Preorder Traversal"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Recursive Preorder\nList<Integer> preorder(Node root) {\n    List<Integer> result = new ArrayList<>();\n    preorderHelper(root, result);\n    return result;\n}\n\nvoid preorderHelper(Node root, List<Integer> result) {\n    if (root == null) return;\n\n    result.add(root.val);\n\n    if (root.children != null) {\n        for (Node child : root.children) {\n            preorderHelper(child, result);\n        }\n    }\n}\n\n// Iterative Preorder\nList<Integer> preorderIterative(Node root) {\n    List<Integer> result = new ArrayList<>();\n    if (root == null) return result;\n\n    Stack<Node> stack = new Stack<>();\n    stack.push(root);\n\n    while (!stack.isEmpty()) {\n        Node current = stack.pop();\n        result.add(current.val);\n\n        // Add children in reverse order for correct processing\n        if (current.children != null) {\n            for (int i = current.children.size() - 1; i >= 0; i--) {\n                stack.push(current.children.get(i));\n            }\n        }\n    }\n\n    return result;\n}\n\n// Generic Preorder with Visitor Pattern\nvoid preorderWithVisitor(Node root, Visitor<Integer> visitor) {\n    if (root == null) return;\n\n    visitor.visit(root.val);\n\n    if (root.children != null) {\n        for (Node child : root.children) {\n            preorderWithVisitor(child, visitor);\n        }\n    }\n}\n\ninterface Visitor<T> {\n    void visit(T item);\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"12-postorder-traversal",children:"1.2 Postorder Traversal"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Recursive Postorder\nList<Integer> postorder(Node root) {\n    List<Integer> result = new ArrayList<>();\n    postorderHelper(root, result);\n    return result;\n}\n\nvoid postorderHelper(Node root, List<Integer> result) {\n    if (root == null) return;\n\n    if (root.children != null) {\n        for (Node child : root.children) {\n            postorderHelper(child, result);\n        }\n    }\n\n    result.add(root.val);\n}\n\n// Iterative Postorder (Using Two Stacks)\nList<Integer> postorderIterative(Node root) {\n    List<Integer> result = new ArrayList<>();\n    if (root == null) return result;\n\n    Stack<Node> stack1 = new Stack<>();\n    Stack<Node> stack2 = new Stack<>();\n\n    stack1.push(root);\n\n    while (!stack1.isEmpty()) {\n        Node current = stack1.pop();\n        stack2.push(current);\n\n        if (current.children != null) {\n            for (Node child : current.children) {\n                stack1.push(child);\n            }\n        }\n    }\n\n    while (!stack2.isEmpty()) {\n        result.add(stack2.pop().val);\n    }\n\n    return result;\n}\n\n// Iterative Postorder (Single Stack with State)\nList<Integer> postorderIterativeSingleStack(Node root) {\n    List<Integer> result = new ArrayList<>();\n    if (root == null) return result;\n\n    Stack<NodeState> stack = new Stack<>();\n    stack.push(new NodeState(root, 0));\n\n    while (!stack.isEmpty()) {\n        NodeState current = stack.peek();\n\n        if (current.node.children == null ||\n            current.childIndex >= current.node.children.size()) {\n            result.add(current.node.val);\n            stack.pop();\n        } else {\n            Node child = current.node.children.get(current.childIndex);\n            current.childIndex++;\n            stack.push(new NodeState(child, 0));\n        }\n    }\n\n    return result;\n}\n\nclass NodeState {\n    Node node;\n    int childIndex;\n\n    NodeState(Node node, int childIndex) {\n        this.node = node;\n        this.childIndex = childIndex;\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"13-level-order-traversal",children:"1.3 Level Order Traversal"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Basic Level Order\nList<List<Integer>> levelOrder(Node root) {\n    List<List<Integer>> result = new ArrayList<>();\n    if (root == null) return result;\n\n    Queue<Node> queue = new LinkedList<>();\n    queue.offer(root);\n\n    while (!queue.isEmpty()) {\n        int levelSize = queue.size();\n        List<Integer> currentLevel = new ArrayList<>();\n\n        for (int i = 0; i < levelSize; i++) {\n            Node current = queue.poll();\n            currentLevel.add(current.val);\n\n            if (current.children != null) {\n                for (Node child : current.children) {\n                    queue.offer(child);\n                }\n            }\n        }\n\n        result.add(currentLevel);\n    }\n\n    return result;\n}\n\n// Level Order with Node Tracking\nList<List<Node>> levelOrderNodes(Node root) {\n    List<List<Node>> result = new ArrayList<>();\n    if (root == null) return result;\n\n    Queue<Node> queue = new LinkedList<>();\n    queue.offer(root);\n\n    while (!queue.isEmpty()) {\n        int levelSize = queue.size();\n        List<Node> currentLevel = new ArrayList<>();\n\n        for (int i = 0; i < levelSize; i++) {\n            Node current = queue.poll();\n            currentLevel.add(current);\n\n            if (current.children != null) {\n                queue.addAll(current.children);\n            }\n        }\n\n        result.add(currentLevel);\n    }\n\n    return result;\n}\n\n// Reverse Level Order\nList<List<Integer>> levelOrderReverse(Node root) {\n    List<List<Integer>> result = levelOrder(root);\n    Collections.reverse(result);\n    return result;\n}\n\n// Zigzag Level Order\nList<List<Integer>> zigzagLevelOrder(Node root) {\n    List<List<Integer>> result = new ArrayList<>();\n    if (root == null) return result;\n\n    Queue<Node> queue = new LinkedList<>();\n    queue.offer(root);\n    boolean leftToRight = true;\n\n    while (!queue.isEmpty()) {\n        int levelSize = queue.size();\n        List<Integer> currentLevel = new ArrayList<>();\n\n        for (int i = 0; i < levelSize; i++) {\n            Node current = queue.poll();\n\n            if (leftToRight) {\n                currentLevel.add(current.val);\n            } else {\n                currentLevel.add(0, current.val);\n            }\n\n            if (current.children != null) {\n                for (Node child : current.children) {\n                    queue.offer(child);\n                }\n            }\n        }\n\n        result.add(currentLevel);\n        leftToRight = !leftToRight;\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-2-tree-properties--metrics",children:"Pattern 2: Tree Properties & Metrics"}),"\n",(0,t.jsx)(n.h3,{id:"21-maximum-depth",children:"2.1 Maximum Depth"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Recursive Maximum Depth\nint maxDepth(Node root) {\n    if (root == null) return 0;\n\n    int maxChildDepth = 0;\n    if (root.children != null) {\n        for (Node child : root.children) {\n            maxChildDepth = Math.max(maxChildDepth, maxDepth(child));\n        }\n    }\n\n    return 1 + maxChildDepth;\n}\n\n// Iterative Maximum Depth (BFS)\nint maxDepthIterative(Node root) {\n    if (root == null) return 0;\n\n    Queue<Node> queue = new LinkedList<>();\n    queue.offer(root);\n    int depth = 0;\n\n    while (!queue.isEmpty()) {\n        int levelSize = queue.size();\n        depth++;\n\n        for (int i = 0; i < levelSize; i++) {\n            Node current = queue.poll();\n\n            if (current.children != null) {\n                for (Node child : current.children) {\n                    queue.offer(child);\n                }\n            }\n        }\n    }\n\n    return depth;\n}\n\n// Depth with Path Tracking\nclass DepthResult {\n    int maxDepth;\n    List<Integer> deepestPath;\n\n    DepthResult(int depth, List<Integer> path) {\n        this.maxDepth = depth;\n        this.deepestPath = new ArrayList<>(path);\n    }\n}\n\nDepthResult maxDepthWithPath(Node root) {\n    return maxDepthWithPathHelper(root, new ArrayList<>());\n}\n\nDepthResult maxDepthWithPathHelper(Node root, List<Integer> currentPath) {\n    if (root == null) {\n        return new DepthResult(0, currentPath);\n    }\n\n    currentPath.add(root.val);\n\n    DepthResult maxResult = new DepthResult(1, new ArrayList<>(currentPath));\n\n    if (root.children != null) {\n        for (Node child : root.children) {\n            DepthResult childResult = maxDepthWithPathHelper(child, currentPath);\n            if (childResult.maxDepth + 1 > maxResult.maxDepth) {\n                maxResult = new DepthResult(childResult.maxDepth + 1, childResult.deepestPath);\n            }\n        }\n    }\n\n    currentPath.remove(currentPath.size() - 1);\n    return maxResult;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"22-tree-size--node-count",children:"2.2 Tree Size & Node Count"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Count Total Nodes\nint countNodes(Node root) {\n    if (root == null) return 0;\n\n    int count = 1; // Current node\n\n    if (root.children != null) {\n        for (Node child : root.children) {\n            count += countNodes(child);\n        }\n    }\n\n    return count;\n}\n\n// Count Leaf Nodes\nint countLeaves(Node root) {\n    if (root == null) return 0;\n\n    if (root.children == null || root.children.isEmpty()) {\n        return 1; // Leaf node\n    }\n\n    int leafCount = 0;\n    for (Node child : root.children) {\n        leafCount += countLeaves(child);\n    }\n\n    return leafCount;\n}\n\n// Count Internal Nodes\nint countInternalNodes(Node root) {\n    if (root == null) return 0;\n\n    if (root.children == null || root.children.isEmpty()) {\n        return 0; // Leaf node\n    }\n\n    int internalCount = 1; // Current internal node\n    for (Node child : root.children) {\n        internalCount += countInternalNodes(child);\n    }\n\n    return internalCount;\n}\n\n// Count Nodes at Specific Level\nint countNodesAtLevel(Node root, int targetLevel) {\n    if (root == null) return 0;\n    if (targetLevel == 0) return 1;\n\n    int count = 0;\n    if (root.children != null) {\n        for (Node child : root.children) {\n            count += countNodesAtLevel(child, targetLevel - 1);\n        }\n    }\n\n    return count;\n}\n\n// Width of Tree (Maximum nodes at any level)\nint maxWidth(Node root) {\n    if (root == null) return 0;\n\n    Queue<Node> queue = new LinkedList<>();\n    queue.offer(root);\n    int maxWidth = 0;\n\n    while (!queue.isEmpty()) {\n        int levelSize = queue.size();\n        maxWidth = Math.max(maxWidth, levelSize);\n\n        for (int i = 0; i < levelSize; i++) {\n            Node current = queue.poll();\n\n            if (current.children != null) {\n                for (Node child : current.children) {\n                    queue.offer(child);\n                }\n            }\n        }\n    }\n\n    return maxWidth;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"23-tree-balance--properties",children:"2.3 Tree Balance & Properties"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Check if tree is balanced (difference in depths of subtrees <= 1)\nboolean isBalanced(Node root) {\n    return checkBalance(root) != -1;\n}\n\nint checkBalance(Node root) {\n    if (root == null) return 0;\n\n    if (root.children == null || root.children.isEmpty()) {\n        return 1;\n    }\n\n    int minDepth = Integer.MAX_VALUE;\n    int maxDepth = 0;\n\n    for (Node child : root.children) {\n        int childDepth = checkBalance(child);\n        if (childDepth == -1) return -1; // Subtree is not balanced\n\n        minDepth = Math.min(minDepth, childDepth);\n        maxDepth = Math.max(maxDepth, childDepth);\n    }\n\n    // Check if current subtree is balanced\n    if (maxDepth - minDepth > 1) return -1;\n\n    return 1 + maxDepth;\n}\n\n// Diameter of N-ary Tree\nint diameter(Node root) {\n    int[] maxDiameter = {0};\n    diameterHelper(root, maxDiameter);\n    return maxDiameter[0];\n}\n\nint diameterHelper(Node root, int[] maxDiameter) {\n    if (root == null) return 0;\n\n    if (root.children == null || root.children.isEmpty()) {\n        return 1;\n    }\n\n    // Get depths of all children\n    List<Integer> childDepths = new ArrayList<>();\n    for (Node child : root.children) {\n        childDepths.add(diameterHelper(child, maxDiameter));\n    }\n\n    // Sort to get two largest depths\n    Collections.sort(childDepths, Collections.reverseOrder());\n\n    // Update diameter (path through current node)\n    int currentDiameter = childDepths.size() >= 2 ?\n        childDepths.get(0) + childDepths.get(1) + 1 :\n        childDepths.get(0) + 1;\n\n    maxDiameter[0] = Math.max(maxDiameter[0], currentDiameter);\n\n    return 1 + childDepths.get(0);\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-3-tree-construction--serialization",children:"Pattern 3: Tree Construction & Serialization"}),"\n",(0,t.jsx)(n.h3,{id:"31-serialize-and-deserialize",children:"3.1 Serialize and Deserialize"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// Serialize N-ary Tree to String\nString serialize(Node root) {\n    StringBuilder sb = new StringBuilder();\n    serializeHelper(root, sb);\n    return sb.toString();\n}\n\nvoid serializeHelper(Node root, StringBuilder sb) {\n    if (root == null) {\n        sb.append("null,");\n        return;\n    }\n\n    sb.append(root.val).append(",");\n\n    if (root.children == null) {\n        sb.append("0,"); // No children\n    } else {\n        sb.append(root.children.size()).append(",");\n        for (Node child : root.children) {\n            serializeHelper(child, sb);\n        }\n    }\n}\n\n// Deserialize String to N-ary Tree\nNode deserialize(String data) {\n    String[] tokens = data.split(",");\n    int[] index = {0};\n    return deserializeHelper(tokens, index);\n}\n\nNode deserializeHelper(String[] tokens, int[] index) {\n    if (index[0] >= tokens.length || "null".equals(tokens[index[0]])) {\n        index[0]++;\n        return null;\n    }\n\n    int val = Integer.parseInt(tokens[index[0]++]);\n    int childrenCount = Integer.parseInt(tokens[index[0]++]);\n\n    Node root = new Node(val);\n    root.children = new ArrayList<>();\n\n    for (int i = 0; i < childrenCount; i++) {\n        Node child = deserializeHelper(tokens, index);\n        if (child != null) {\n            root.children.add(child);\n        }\n    }\n\n    return root;\n}\n\n// Level Order Serialization (Leetcode Style)\nString serializeLevelOrder(Node root) {\n    if (root == null) return "";\n\n    StringBuilder sb = new StringBuilder();\n    Queue<Node> queue = new LinkedList<>();\n    queue.offer(root);\n\n    while (!queue.isEmpty()) {\n        Node current = queue.poll();\n\n        if (current == null) {\n            sb.append("null,");\n        } else {\n            sb.append(current.val).append(",");\n\n            if (current.children != null) {\n                for (Node child : current.children) {\n                    queue.offer(child);\n                }\n                queue.offer(null); // Separator for children group\n            }\n        }\n    }\n\n    return sb.toString();\n}\n\nNode deserializeLevelOrder(String data) {\n    if (data.isEmpty()) return null;\n\n    String[] tokens = data.split(",");\n    Node root = new Node(Integer.parseInt(tokens[0]));\n    Queue<Node> queue = new LinkedList<>();\n    queue.offer(root);\n\n    int i = 1;\n    while (!queue.isEmpty() && i < tokens.length) {\n        Node parent = queue.poll();\n        parent.children = new ArrayList<>();\n\n        // Read children until null separator\n        while (i < tokens.length && !tokens[i].equals("null")) {\n            Node child = new Node(Integer.parseInt(tokens[i]));\n            parent.children.add(child);\n            queue.offer(child);\n            i++;\n        }\n        i++; // Skip null separator\n    }\n\n    return root;\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"32-clone-n-ary-tree",children:"3.2 Clone N-ary Tree"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Deep Clone N-ary Tree\nNode cloneTree(Node root) {\n    if (root == null) return null;\n\n    Node clone = new Node(root.val);\n\n    if (root.children != null) {\n        clone.children = new ArrayList<>();\n        for (Node child : root.children) {\n            clone.children.add(cloneTree(child));\n        }\n    }\n\n    return clone;\n}\n\n// Clone with HashMap (for trees with references)\nNode cloneTreeWithMap(Node root) {\n    Map<Node, Node> cloneMap = new HashMap<>();\n    return cloneHelper(root, cloneMap);\n}\n\nNode cloneHelper(Node root, Map<Node, Node> cloneMap) {\n    if (root == null) return null;\n\n    if (cloneMap.containsKey(root)) {\n        return cloneMap.get(root);\n    }\n\n    Node clone = new Node(root.val);\n    cloneMap.put(root, clone);\n\n    if (root.children != null) {\n        clone.children = new ArrayList<>();\n        for (Node child : root.children) {\n            clone.children.add(cloneHelper(child, cloneMap));\n        }\n    }\n\n    return clone;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"33-build-tree-from-traversals",children:"3.3 Build Tree from Traversals"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Build N-ary Tree from Preorder and Postorder\nNode buildTree(int[] preorder, int[] postorder) {\n    Map<Integer, Integer> postMap = new HashMap<>();\n    for (int i = 0; i < postorder.length; i++) {\n        postMap.put(postorder[i], i);\n    }\n\n    return buildTreeHelper(preorder, 0, preorder.length - 1,\n                          postorder, 0, postorder.length - 1, postMap);\n}\n\nNode buildTreeHelper(int[] preorder, int preStart, int preEnd,\n                    int[] postorder, int postStart, int postEnd,\n                    Map<Integer, Integer> postMap) {\n    if (preStart > preEnd) return null;\n\n    Node root = new Node(preorder[preStart]);\n    if (preStart == preEnd) return root;\n\n    root.children = new ArrayList<>();\n\n    int childStart = preStart + 1;\n    for (int i = postStart; i < postEnd; i++) {\n        int childRootVal = postorder[i];\n\n        // Find this child in preorder\n        int childEnd = findChildEnd(preorder, childStart, preEnd,\n                                   postorder, postStart, i, postMap);\n\n        if (childEnd >= childStart) {\n            Node child = buildTreeHelper(preorder, childStart, childEnd,\n                                        postorder, postStart, i, postMap);\n            root.children.add(child);\n            childStart = childEnd + 1;\n        }\n    }\n\n    return root;\n}\n\nint findChildEnd(int[] preorder, int start, int end,\n                int[] postorder, int postStart, int postEnd,\n                Map<Integer, Integer> postMap) {\n    // Implementation depends on specific constraints\n    // This is a simplified version\n    return start;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-4-path--sum-problems",children:"Pattern 4: Path & Sum Problems"}),"\n",(0,t.jsx)(n.h3,{id:"41-root-to-leaf-paths",children:"4.1 Root to Leaf Paths"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// All Root-to-Leaf Paths\nList<String> binaryTreePaths(Node root) {\n    List<String> result = new ArrayList<>();\n    if (root != null) {\n        findPaths(root, "", result);\n    }\n    return result;\n}\n\nvoid findPaths(Node root, String path, List<String> result) {\n    if (root.children == null || root.children.isEmpty()) {\n        result.add(path + root.val);\n        return;\n    }\n\n    for (Node child : root.children) {\n        findPaths(child, path + root.val + "->", result);\n    }\n}\n\n// Paths as Lists\nList<List<Integer>> allPaths(Node root) {\n    List<List<Integer>> result = new ArrayList<>();\n    if (root != null) {\n        findPathsAsList(root, new ArrayList<>(), result);\n    }\n    return result;\n}\n\nvoid findPathsAsList(Node root, List<Integer> currentPath,\n                    List<List<Integer>> result) {\n    currentPath.add(root.val);\n\n    if (root.children == null || root.children.isEmpty()) {\n        result.add(new ArrayList<>(currentPath));\n    } else {\n        for (Node child : root.children) {\n            findPathsAsList(child, currentPath, result);\n        }\n    }\n\n    currentPath.remove(currentPath.size() - 1); // Backtrack\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"42-path-sum-problems",children:"4.2 Path Sum Problems"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Path Sum (Root to Leaf)\nboolean hasPathSum(Node root, int targetSum) {\n    if (root == null) return false;\n\n    if (root.children == null || root.children.isEmpty()) {\n        return root.val == targetSum;\n    }\n\n    for (Node child : root.children) {\n        if (hasPathSum(child, targetSum - root.val)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n// All Paths with Target Sum\nList<List<Integer>> pathSum(Node root, int targetSum) {\n    List<List<Integer>> result = new ArrayList<>();\n    if (root != null) {\n        findPathSum(root, targetSum, new ArrayList<>(), result);\n    }\n    return result;\n}\n\nvoid findPathSum(Node root, int remainingSum, List<Integer> currentPath,\n                List<List<Integer>> result) {\n    currentPath.add(root.val);\n\n    // Check if leaf node with target sum\n    if (root.children == null || root.children.isEmpty()) {\n        if (remainingSum == root.val) {\n            result.add(new ArrayList<>(currentPath));\n        }\n    } else {\n        for (Node child : root.children) {\n            findPathSum(child, remainingSum - root.val, currentPath, result);\n        }\n    }\n\n    currentPath.remove(currentPath.size() - 1); // Backtrack\n}\n\n// Sum of All Leaf Values\nint sumOfLeaves(Node root) {\n    if (root == null) return 0;\n\n    if (root.children == null || root.children.isEmpty()) {\n        return root.val;\n    }\n\n    int sum = 0;\n    for (Node child : root.children) {\n        sum += sumOfLeaves(child);\n    }\n\n    return sum;\n}\n\n// Maximum Path Sum (Any Path)\nint maxPathSum(Node root) {\n    int[] maxSum = {Integer.MIN_VALUE};\n    maxPathSumHelper(root, maxSum);\n    return maxSum[0];\n}\n\nint maxPathSumHelper(Node root, int[] maxSum) {\n    if (root == null) return 0;\n\n    if (root.children == null || root.children.isEmpty()) {\n        maxSum[0] = Math.max(maxSum[0], root.val);\n        return root.val;\n    }\n\n    // Get positive contributions from children\n    List<Integer> childSums = new ArrayList<>();\n    for (Node child : root.children) {\n        int childSum = maxPathSumHelper(child, maxSum);\n        if (childSum > 0) {\n            childSums.add(childSum);\n        }\n    }\n\n    // Sort to get largest contributions\n    Collections.sort(childSums, Collections.reverseOrder());\n\n    // Current path sum through this node\n    int currentPathSum = root.val;\n    for (int childSum : childSums) {\n        currentPathSum += childSum;\n    }\n\n    maxSum[0] = Math.max(maxSum[0], currentPathSum);\n\n    // Return max sum path ending at this node\n    return root.val + (childSums.isEmpty() ? 0 : childSums.get(0));\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"43-distance--path-queries",children:"4.3 Distance & Path Queries"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Find Distance Between Two Nodes\nint findDistance(Node root, int val1, int val2) {\n    Node lca = findLCA(root, val1, val2);\n    if (lca == null) return -1;\n\n    int dist1 = findDistanceFromNode(lca, val1, 0);\n    int dist2 = findDistanceFromNode(lca, val2, 0);\n\n    return dist1 + dist2;\n}\n\nint findDistanceFromNode(Node root, int target, int depth) {\n    if (root == null) return -1;\n    if (root.val == target) return depth;\n\n    if (root.children != null) {\n        for (Node child : root.children) {\n            int childDist = findDistanceFromNode(child, target, depth + 1);\n            if (childDist != -1) return childDist;\n        }\n    }\n\n    return -1;\n}\n\n// Find Path Between Two Nodes\nList<Integer> findPath(Node root, int val1, int val2) {\n    Node lca = findLCA(root, val1, val2);\n    if (lca == null) return new ArrayList<>();\n\n    List<Integer> path1 = new ArrayList<>();\n    List<Integer> path2 = new ArrayList<>();\n\n    findPathFromNode(lca, val1, new ArrayList<>(), path1);\n    findPathFromNode(lca, val2, new ArrayList<>(), path2);\n\n    // Combine paths\n    Collections.reverse(path1);\n    path1.addAll(path2.subList(1, path2.size())); // Skip LCA duplication\n\n    return path1;\n}\n\nboolean findPathFromNode(Node root, int target, List<Integer> currentPath,\n                        List<Integer> result) {\n    if (root == null) return false;\n\n    currentPath.add(root.val);\n\n    if (root.val == target) {\n        result.addAll(currentPath);\n        return true;\n    }\n\n    if (root.children != null) {\n        for (Node child : root.children) {\n            if (findPathFromNode(child, target, currentPath, result)) {\n                return true;\n            }\n        }\n    }\n\n    currentPath.remove(currentPath.size() - 1);\n    return false;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-5-level-order-operations",children:"Pattern 5: Level Order Operations"}),"\n",(0,t.jsx)(n.h3,{id:"51-level-wise-processing",children:"5.1 Level-wise Processing"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Level Order Values\nList<List<Integer>> levelOrder(Node root) {\n    List<List<Integer>> result = new ArrayList<>();\n    if (root == null) return result;\n\n    Queue<Node> queue = new LinkedList<>();\n    queue.offer(root);\n\n    while (!queue.isEmpty()) {\n        int levelSize = queue.size();\n        List<Integer> level = new ArrayList<>();\n\n        for (int i = 0; i < levelSize; i++) {\n            Node current = queue.poll();\n            level.add(current.val);\n\n            if (current.children != null) {\n                queue.addAll(current.children);\n            }\n        }\n\n        result.add(level);\n    }\n\n    return result;\n}\n\n// Average of Each Level\nList<Double> averageOfLevels(Node root) {\n    List<Double> result = new ArrayList<>();\n    if (root == null) return result;\n\n    Queue<Node> queue = new LinkedList<>();\n    queue.offer(root);\n\n    while (!queue.isEmpty()) {\n        int levelSize = queue.size();\n        long sum = 0;\n\n        for (int i = 0; i < levelSize; i++) {\n            Node current = queue.poll();\n            sum += current.val;\n\n            if (current.children != null) {\n                queue.addAll(current.children);\n            }\n        }\n\n        result.add((double) sum / levelSize);\n    }\n\n    return result;\n}\n\n// Largest Value in Each Level\nList<Integer> largestValues(Node root) {\n    List<Integer> result = new ArrayList<>();\n    if (root == null) return result;\n\n    Queue<Node> queue = new LinkedList<>();\n    queue.offer(root);\n\n    while (!queue.isEmpty()) {\n        int levelSize = queue.size();\n        int maxVal = Integer.MIN_VALUE;\n\n        for (int i = 0; i < levelSize; i++) {\n            Node current = queue.poll();\n            maxVal = Math.max(maxVal, current.val);\n\n            if (current.children != null) {\n                queue.addAll(current.children);\n            }\n        }\n\n        result.add(maxVal);\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"52-level-based-modifications",children:"5.2 Level-based Modifications"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Connect Nodes at Same Level (if next pointer exists)\nclass NodeWithNext {\n    int val;\n    List<NodeWithNext> children;\n    NodeWithNext next;\n\n    NodeWithNext(int val) {\n        this.val = val;\n        this.children = new ArrayList<>();\n    }\n}\n\nNodeWithNext connect(NodeWithNext root) {\n    if (root == null) return null;\n\n    Queue<NodeWithNext> queue = new LinkedList<>();\n    queue.offer(root);\n\n    while (!queue.isEmpty()) {\n        int levelSize = queue.size();\n        NodeWithNext prev = null;\n\n        for (int i = 0; i < levelSize; i++) {\n            NodeWithNext current = queue.poll();\n\n            if (prev != null) {\n                prev.next = current;\n            }\n            prev = current;\n\n            if (current.children != null) {\n                queue.addAll(current.children);\n            }\n        }\n    }\n\n    return root;\n}\n\n// Add One Row at Specific Depth\nNode addOneRow(Node root, int val, int depth) {\n    if (depth == 1) {\n        Node newRoot = new Node(val);\n        newRoot.children = Arrays.asList(root);\n        return newRoot;\n    }\n\n    addOneRowHelper(root, val, depth, 1);\n    return root;\n}\n\nvoid addOneRowHelper(Node root, int val, int targetDepth, int currentDepth) {\n    if (root == null) return;\n\n    if (currentDepth == targetDepth - 1) {\n        List<Node> oldChildren = root.children == null ?\n            new ArrayList<>() : new ArrayList<>(root.children);\n        root.children = new ArrayList<>();\n\n        for (Node oldChild : oldChildren) {\n            Node newNode = new Node(val);\n            newNode.children = Arrays.asList(oldChild);\n            root.children.add(newNode);\n        }\n        return;\n    }\n\n    if (root.children != null) {\n        for (Node child : root.children) {\n            addOneRowHelper(child, val, targetDepth, currentDepth + 1);\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-6-tree-modification",children:"Pattern 6: Tree Modification"}),"\n",(0,t.jsx)(n.h3,{id:"61-node-insertion--deletion",children:"6.1 Node Insertion & Deletion"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Insert Node as Child\nvoid insertAsChild(Node parent, Node child) {\n    if (parent.children == null) {\n        parent.children = new ArrayList<>();\n    }\n    parent.children.add(child);\n}\n\n// Insert Node at Specific Position\nvoid insertAtPosition(Node parent, Node child, int position) {\n    if (parent.children == null) {\n        parent.children = new ArrayList<>();\n    }\n\n    if (position < 0 || position > parent.children.size()) {\n        parent.children.add(child);\n    } else {\n        parent.children.add(position, child);\n    }\n}\n\n// Delete Node by Value\nboolean deleteNode(Node root, int val) {\n    if (root == null) return false;\n\n    if (root.children != null) {\n        for (int i = 0; i < root.children.size(); i++) {\n            Node child = root.children.get(i);\n\n            if (child.val == val) {\n                // Add child's children to current node\n                List<Node> grandChildren = child.children;\n                root.children.remove(i);\n\n                if (grandChildren != null) {\n                    root.children.addAll(i, grandChildren);\n                }\n                return true;\n            }\n\n            if (deleteNode(child, val)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\n// Delete All Nodes with Value\nvoid deleteAllNodes(Node root, int val) {\n    if (root == null || root.children == null) return;\n\n    for (int i = root.children.size() - 1; i >= 0; i--) {\n        Node child = root.children.get(i);\n\n        if (child.val == val) {\n            root.children.remove(i);\n        } else {\n            deleteAllNodes(child, val);\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"62-tree-transformation",children:"6.2 Tree Transformation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Mirror N-ary Tree\nNode mirror(Node root) {\n    if (root == null) return null;\n\n    if (root.children != null) {\n        Collections.reverse(root.children);\n        for (Node child : root.children) {\n            mirror(child);\n        }\n    }\n\n    return root;\n}\n\n// Convert to Binary Tree (First Child/Next Sibling)\nclass BinaryNode {\n    int val;\n    BinaryNode left;  // First child\n    BinaryNode right; // Next sibling\n\n    BinaryNode(int val) {\n        this.val = val;\n    }\n}\n\nBinaryNode convertToBinary(Node root) {\n    if (root == null) return null;\n\n    BinaryNode binaryRoot = new BinaryNode(root.val);\n\n    if (root.children != null && !root.children.isEmpty()) {\n        binaryRoot.left = convertToBinary(root.children.get(0));\n\n        BinaryNode current = binaryRoot.left;\n        for (int i = 1; i < root.children.size(); i++) {\n            current.right = convertToBinary(root.children.get(i));\n            current = current.right;\n        }\n    }\n\n    return binaryRoot;\n}\n\n// Convert Binary Tree back to N-ary\nNode convertFromBinary(BinaryNode root) {\n    if (root == null) return null;\n\n    Node naryRoot = new Node(root.val);\n    naryRoot.children = new ArrayList<>();\n\n    BinaryNode child = root.left;\n    while (child != null) {\n        naryRoot.children.add(convertFromBinary(child));\n        child = child.right;\n    }\n\n    return naryRoot;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-7-validation--verification",children:"Pattern 7: Validation & Verification"}),"\n",(0,t.jsx)(n.h3,{id:"71-tree-structure-validation",children:"7.1 Tree Structure Validation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Validate N-ary Tree Structure\nboolean validateNaryTree(Node root, int maxChildren) {\n    if (root == null) return true;\n\n    if (root.children != null && root.children.size() > maxChildren) {\n        return false;\n    }\n\n    // Check for cycles using DFS\n    Set<Node> visited = new HashSet<>();\n    Set<Node> recursionStack = new HashSet<>();\n\n    return !hasCycle(root, visited, recursionStack) &&\n           validateStructure(root, maxChildren);\n}\n\nboolean hasCycle(Node root, Set<Node> visited, Set<Node> recursionStack) {\n    if (root == null) return false;\n\n    if (recursionStack.contains(root)) return true;\n    if (visited.contains(root)) return false;\n\n    visited.add(root);\n    recursionStack.add(root);\n\n    if (root.children != null) {\n        for (Node child : root.children) {\n            if (hasCycle(child, visited, recursionStack)) {\n                return true;\n            }\n        }\n    }\n\n    recursionStack.remove(root);\n    return false;\n}\n\nboolean validateStructure(Node root, int maxChildren) {\n    if (root == null) return true;\n\n    if (root.children != null) {\n        if (root.children.size() > maxChildren) return false;\n\n        for (Node child : root.children) {\n            if (!validateStructure(child, maxChildren)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\n// Check if tree is complete (all levels filled except possibly last)\nboolean isCompleteTree(Node root) {\n    if (root == null) return true;\n\n    Queue<Node> queue = new LinkedList<>();\n    queue.offer(root);\n    boolean foundNonFull = false;\n\n    while (!queue.isEmpty()) {\n        Node current = queue.poll();\n\n        if (current.children == null || current.children.isEmpty()) {\n            foundNonFull = true;\n        } else {\n            if (foundNonFull) return false; // Found non-leaf after leaf level\n\n            for (Node child : current.children) {\n                queue.offer(child);\n            }\n        }\n    }\n\n    return true;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"72-property-validation",children:"7.2 Property Validation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Validate Binary Search Tree Property (for ordered n-ary tree)\nboolean isValidBST(Node root) {\n    return isValidBSTHelper(root, null, null);\n}\n\nboolean isValidBSTHelper(Node root, Integer min, Integer max) {\n    if (root == null) return true;\n\n    if ((min != null && root.val <= min) ||\n        (max != null && root.val >= max)) {\n        return false;\n    }\n\n    if (root.children != null) {\n        for (int i = 0; i < root.children.size(); i++) {\n            Node child = root.children.get(i);\n\n            // For n-ary BST, left children < root < right children\n            Integer newMin = (i < root.children.size() / 2) ? min : root.val;\n            Integer newMax = (i < root.children.size() / 2) ? root.val : max;\n\n            if (!isValidBSTHelper(child, newMin, newMax)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\n// Check if all paths have same sum\nboolean hasUniformPathSum(Node root) {\n    if (root == null) return true;\n\n    Set<Integer> pathSums = new HashSet<>();\n    collectPathSums(root, 0, pathSums);\n\n    return pathSums.size() <= 1;\n}\n\nvoid collectPathSums(Node root, int currentSum, Set<Integer> pathSums) {\n    if (root == null) return;\n\n    currentSum += root.val;\n\n    if (root.children == null || root.children.isEmpty()) {\n        pathSums.add(currentSum);\n        return;\n    }\n\n    for (Node child : root.children) {\n        collectPathSums(child, currentSum, pathSums);\n    }\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-8-tree-comparison",children:"Pattern 8: Tree Comparison"}),"\n",(0,t.jsx)(n.h3,{id:"81-same-tree",children:"8.1 Same Tree"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Check if two N-ary trees are identical\nboolean isSameTree(Node p, Node q) {\n    if (p == null && q == null) return true;\n    if (p == null || q == null) return false;\n    if (p.val != q.val) return false;\n\n    // Check children count\n    int pChildCount = (p.children == null) ? 0 : p.children.size();\n    int qChildCount = (q.children == null) ? 0 : q.children.size();\n\n    if (pChildCount != qChildCount) return false;\n\n    // Compare each child\n    for (int i = 0; i < pChildCount; i++) {\n        if (!isSameTree(p.children.get(i), q.children.get(i))) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n// Check if two trees are isomorphic (same structure, different values allowed)\nboolean isIsomorphic(Node p, Node q) {\n    if (p == null && q == null) return true;\n    if (p == null || q == null) return false;\n\n    int pChildCount = (p.children == null) ? 0 : p.children.size();\n    int qChildCount = (q.children == null) ? 0 : q.children.size();\n\n    if (pChildCount != qChildCount) return false;\n\n    for (int i = 0; i < pChildCount; i++) {\n        if (!isIsomorphic(p.children.get(i), q.children.get(i))) {\n            return false;\n        }\n    }\n\n    return true;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"82-subtree-problems",children:"8.2 Subtree Problems"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Check if one tree is subtree of another\nboolean isSubtree(Node root, Node subRoot) {\n    if (subRoot == null) return true;\n    if (root == null) return false;\n\n    return isSameTree(root, subRoot) ||\n           hasSubtreeInChildren(root, subRoot);\n}\n\nboolean hasSubtreeInChildren(Node root, Node subRoot) {\n    if (root.children == null) return false;\n\n    for (Node child : root.children) {\n        if (isSubtree(child, subRoot)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n// Find all occurrences of subtree\nList<Node> findAllSubtrees(Node root, Node target) {\n    List<Node> result = new ArrayList<>();\n    findSubtreesHelper(root, target, result);\n    return result;\n}\n\nvoid findSubtreesHelper(Node root, Node target, List<Node> result) {\n    if (root == null) return;\n\n    if (isSameTree(root, target)) {\n        result.add(root);\n    }\n\n    if (root.children != null) {\n        for (Node child : root.children) {\n            findSubtreesHelper(child, target, result);\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-9-ancestor--descendant",children:"Pattern 9: Ancestor & Descendant"}),"\n",(0,t.jsx)(n.h3,{id:"91-lowest-common-ancestor",children:"9.1 Lowest Common Ancestor"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Find LCA of two nodes\nNode findLCA(Node root, int val1, int val2) {\n    if (root == null) return null;\n\n    if (root.val == val1 || root.val == val2) {\n        return root;\n    }\n\n    List<Node> foundAncestors = new ArrayList<>();\n\n    if (root.children != null) {\n        for (Node child : root.children) {\n            Node lca = findLCA(child, val1, val2);\n            if (lca != null) {\n                foundAncestors.add(lca);\n            }\n        }\n    }\n\n    // If found in multiple subtrees, current node is LCA\n    if (foundAncestors.size() >= 2) {\n        return root;\n    }\n\n    // If found in one subtree, return that result\n    return foundAncestors.isEmpty() ? null : foundAncestors.get(0);\n}\n\n// Find LCA with parent pointers\nNode findLCAWithParent(Node node1, Node node2) {\n    Set<Node> ancestors = new HashSet<>();\n\n    // Collect all ancestors of node1\n    Node current = node1;\n    while (current != null) {\n        ancestors.add(current);\n        current = getParent(current); // Assuming parent pointer exists\n    }\n\n    // Find first common ancestor\n    current = node2;\n    while (current != null) {\n        if (ancestors.contains(current)) {\n            return current;\n        }\n        current = getParent(current);\n    }\n\n    return null;\n}\n\n// Helper method (assuming parent pointer exists)\nNode getParent(Node node) {\n    // Implementation depends on whether parent pointer is available\n    return null; // Placeholder\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"92-ancestor-queries",children:"9.2 Ancestor Queries"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Find all ancestors of a node\nList<Integer> findAncestors(Node root, int target) {\n    List<Integer> ancestors = new ArrayList<>();\n    findAncestorsHelper(root, target, ancestors);\n    return ancestors;\n}\n\nboolean findAncestorsHelper(Node root, int target, List<Integer> ancestors) {\n    if (root == null) return false;\n\n    if (root.val == target) return true;\n\n    if (root.children != null) {\n        for (Node child : root.children) {\n            if (findAncestorsHelper(child, target, ancestors)) {\n                ancestors.add(root.val);\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\n// Find all descendants at specific distance\nList<Integer> findDescendantsAtDistance(Node root, int distance) {\n    List<Integer> result = new ArrayList<>();\n    if (root == null) return result;\n\n    if (distance == 0) {\n        result.add(root.val);\n        return result;\n    }\n\n    if (root.children != null) {\n        for (Node child : root.children) {\n            result.addAll(findDescendantsAtDistance(child, distance - 1));\n        }\n    }\n\n    return result;\n}\n\n// Check if one node is ancestor of another\nboolean isAncestor(Node root, int ancestor, int descendant) {\n    Node ancestorNode = findNode(root, ancestor);\n    if (ancestorNode == null) return false;\n\n    return findNode(ancestorNode, descendant) != null;\n}\n\nNode findNode(Node root, int val) {\n    if (root == null) return null;\n    if (root.val == val) return root;\n\n    if (root.children != null) {\n        for (Node child : root.children) {\n            Node found = findNode(child, val);\n            if (found != null) return found;\n        }\n    }\n\n    return null;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-10-tree-dp-problems",children:"Pattern 10: Tree DP Problems"}),"\n",(0,t.jsx)(n.h3,{id:"101-dynamic-programming-on-trees",children:"10.1 Dynamic Programming on Trees"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Maximum sum of non-adjacent nodes (House Robber on Tree)\nint rob(Node root) {\n    int[] result = robHelper(root);\n    return Math.max(result[0], result[1]);\n}\n\nint[] robHelper(Node root) {\n    if (root == null) return new int[]{0, 0};\n\n    // result[0] = max money when root is not robbed\n    // result[1] = max money when root is robbed\n    int[] result = new int[2];\n\n    if (root.children == null || root.children.isEmpty()) {\n        result[0] = 0;\n        result[1] = root.val;\n        return result;\n    }\n\n    for (Node child : root.children) {\n        int[] childResult = robHelper(child);\n        result[0] += Math.max(childResult[0], childResult[1]);\n        result[1] += childResult[0];\n    }\n\n    result[1] += root.val;\n    return result;\n}\n\n// Minimum cameras to cover tree\nint minCameraCover(Node root) {\n    int[] cameras = {0};\n    int state = dfsCamera(root, cameras);\n    return cameras[0] + (state == 0 ? 1 : 0);\n}\n\nint dfsCamera(Node root, int[] cameras) {\n    if (root == null) return 1; // Null nodes are covered\n\n    // States: 0 = not covered, 1 = covered, 2 = has camera\n    int minState = 1; // Assume covered initially\n    boolean needCamera = false;\n\n    if (root.children != null) {\n        for (Node child : root.children) {\n            int childState = dfsCamera(child, cameras);\n            if (childState == 0) {\n                needCamera = true;\n            }\n            minState = Math.min(minState, childState);\n        }\n    } else {\n        minState = 0; // Leaf nodes are not covered initially\n    }\n\n    if (needCamera || minState == 0) {\n        cameras[0]++;\n        return 2;\n    }\n\n    return minState == 2 ? 1 : 0;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"102-tree-statistics",children:"10.2 Tree Statistics"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Count nodes with specific property\nint countNodesWithProperty(Node root, Predicate<Node> predicate) {\n    if (root == null) return 0;\n\n    int count = predicate.test(root) ? 1 : 0;\n\n    if (root.children != null) {\n        for (Node child : root.children) {\n            count += countNodesWithProperty(child, predicate);\n        }\n    }\n\n    return count;\n}\n\n// Example: Count nodes with even values\nint countEvenNodes(Node root) {\n    return countNodesWithProperty(root, node -> node.val % 2 == 0);\n}\n\n// Find mode (most frequent value) in tree\nList<Integer> findMode(Node root) {\n    Map<Integer, Integer> frequencyMap = new HashMap<>();\n    collectFrequencies(root, frequencyMap);\n\n    int maxFreq = Collections.max(frequencyMap.values());\n    List<Integer> modes = new ArrayList<>();\n\n    for (Map.Entry<Integer, Integer> entry : frequencyMap.entrySet()) {\n        if (entry.getValue() == maxFreq) {\n            modes.add(entry.getKey());\n        }\n    }\n\n    return modes;\n}\n\nvoid collectFrequencies(Node root, Map<Integer, Integer> frequencyMap) {\n    if (root == null) return;\n\n    frequencyMap.put(root.val, frequencyMap.getOrDefault(root.val, 0) + 1);\n\n    if (root.children != null) {\n        for (Node child : root.children) {\n            collectFrequencies(child, frequencyMap);\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-11-multi-tree-operations",children:"Pattern 11: Multi-Tree Operations"}),"\n",(0,t.jsx)(n.h3,{id:"111-tree-merging",children:"11.1 Tree Merging"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Merge two N-ary trees (add values for overlapping nodes)\nNode mergeTrees(Node t1, Node t2) {\n    if (t1 == null) return t2;\n    if (t2 == null) return t1;\n\n    Node merged = new Node(t1.val + t2.val);\n\n    // Get all children from both trees\n    List<Node> children1 = t1.children != null ? t1.children : new ArrayList<>();\n    List<Node> children2 = t2.children != null ? t2.children : new ArrayList<>();\n\n    int maxChildren = Math.max(children1.size(), children2.size());\n    merged.children = new ArrayList<>();\n\n    for (int i = 0; i < maxChildren; i++) {\n        Node child1 = i < children1.size() ? children1.get(i) : null;\n        Node child2 = i < children2.size() ? children2.get(i) : null;\n        Node mergedChild = mergeTrees(child1, child2);\n        if (mergedChild != null) {\n            merged.children.add(mergedChild);\n        }\n    }\n\n    return merged;\n}\n\n// Find common subtrees between two trees\nList<Node> findCommonSubtrees(Node root1, Node root2) {\n    List<Node> commonSubtrees = new ArrayList<>();\n    findCommonSubtreesHelper(root1, root2, commonSubtrees);\n    return commonSubtrees;\n}\n\nvoid findCommonSubtreesHelper(Node root1, Node root2, List<Node> result) {\n    if (root1 == null || root2 == null) return;\n\n    if (isSameTree(root1, root2)) {\n        result.add(root1);\n        return; // Don't check subtrees if whole tree matches\n    }\n\n    // Check all combinations of subtrees\n    if (root1.children != null && root2.children != null) {\n        for (Node child1 : root1.children) {\n            for (Node child2 : root2.children) {\n                findCommonSubtreesHelper(child1, child2, result);\n            }\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"112-tree-set-operations",children:"11.2 Tree Set Operations"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Find intersection of values in two trees\nSet<Integer> findIntersection(Node root1, Node root2) {\n    Set<Integer> values1 = collectValues(root1);\n    Set<Integer> values2 = collectValues(root2);\n\n    values1.retainAll(values2);\n    return values1;\n}\n\nSet<Integer> collectValues(Node root) {\n    Set<Integer> values = new HashSet<>();\n    collectValuesHelper(root, values);\n    return values;\n}\n\nvoid collectValuesHelper(Node root, Set<Integer> values) {\n    if (root == null) return;\n\n    values.add(root.val);\n\n    if (root.children != null) {\n        for (Node child : root.children) {\n            collectValuesHelper(child, values);\n        }\n    }\n}\n\n// Find union of values in multiple trees\nSet<Integer> findUnion(List<Node> roots) {\n    Set<Integer> union = new HashSet<>();\n\n    for (Node root : roots) {\n        union.addAll(collectValues(root));\n    }\n\n    return union;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-12-advanced-tree-problems",children:"Pattern 12: Advanced Tree Problems"}),"\n",(0,t.jsx)(n.h3,{id:"121-tree-isomorphism",children:"12.1 Tree Isomorphism"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Check if two trees are isomorphic (can be made identical by swapping children)\nboolean areIsomorphic(Node root1, Node root2) {\n    if (root1 == null && root2 == null) return true;\n    if (root1 == null || root2 == null) return false;\n    if (root1.val != root2.val) return false;\n\n    int children1Count = root1.children != null ? root1.children.size() : 0;\n    int children2Count = root2.children != null ? root2.children.size() : 0;\n\n    if (children1Count != children2Count) return false;\n\n    if (children1Count == 0) return true;\n\n    // Try all permutations of children\n    List<Node> children1 = root1.children;\n    List<Node> children2 = new ArrayList<>(root2.children);\n\n    return canMatchChildren(children1, children2, 0);\n}\n\nboolean canMatchChildren(List<Node> children1, List<Node> children2, int index) {\n    if (index == children1.size()) return true;\n\n    for (int i = index; i < children2.size(); i++) {\n        Collections.swap(children2, index, i);\n\n        if (areIsomorphic(children1.get(index), children2.get(index)) &&\n            canMatchChildren(children1, children2, index + 1)) {\n            return true;\n        }\n\n        Collections.swap(children2, index, i); // Backtrack\n    }\n\n    return false;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"122-tree-hashing",children:"12.2 Tree Hashing"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// Generate hash for tree structure (for duplicate detection)\nString getTreeHash(Node root) {\n    if (root == null) return "null";\n\n    List<String> childHashes = new ArrayList<>();\n\n    if (root.children != null) {\n        for (Node child : root.children) {\n            childHashes.add(getTreeHash(child));\n        }\n    }\n\n    Collections.sort(childHashes); // For isomorphic trees\n    return root.val + "(" + String.join(",", childHashes) + ")";\n}\n\n// Find duplicate subtrees\nList<Node> findDuplicateSubtrees(Node root) {\n    Map<String, Integer> hashCount = new HashMap<>();\n    List<Node> duplicates = new ArrayList<>();\n\n    generateHashesAndFindDuplicates(root, hashCount, duplicates);\n    return duplicates;\n}\n\nString generateHashesAndFindDuplicates(Node root, Map<String, Integer> hashCount,\n                                     List<Node> duplicates) {\n    if (root == null) return "null";\n\n    String hash = getTreeHash(root);\n    hashCount.put(hash, hashCount.getOrDefault(hash, 0) + 1);\n\n    if (hashCount.get(hash) == 2) { // First time seeing duplicate\n        duplicates.add(root);\n    }\n\n    return hash;\n}\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"time--space-complexity-reference11",children:"Time & Space Complexity Reference[11]"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{style:{textAlign:"left"},children:"Pattern"}),(0,t.jsx)(n.th,{style:{textAlign:"left"},children:"Time Complexity"}),(0,t.jsx)(n.th,{style:{textAlign:"left"},children:"Space Complexity"}),(0,t.jsx)(n.th,{style:{textAlign:"left"},children:"Key Characteristics"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Traversal (DFS/BFS)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(h) to O(n)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"h = height, n = nodes"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Tree Construction"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(h)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Depends on input format"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Path Problems"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(h)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Recursion depth = height"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Level Order"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(w)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"w = maximum width"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Tree Comparison"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(min(n1, n2))"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(h)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Early termination possible"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"LCA"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(h)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Worst case visits all nodes"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Tree DP"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(h)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Each node visited once"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Serialization"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"String/array representation"})]})]})]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"best-practices--optimization-tips",children:"Best Practices & Optimization Tips"}),"\n",(0,t.jsx)(n.h3,{id:"implementation-guidelines",children:"Implementation Guidelines"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Null Safety"}),": Always check for null children lists"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"List Initialization"}),": Initialize children list when needed vs. keeping it null"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Memory Efficiency"}),": Use First Child/Next Sibling for memory-constrained scenarios"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Recursive Depth"}),": Consider iterative solutions for very deep trees"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"State Management"}),": Use helper methods to maintain clean interfaces"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"common-optimizations",children:"Common Optimizations"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// 1. Early termination in searches\nboolean findValue(Node root, int target) {\n    if (root == null) return false;\n    if (root.val == target) return true; // Early return\n\n    if (root.children != null) {\n        for (Node child : root.children) {\n            if (findValue(child, target)) return true; // Stop on first match\n        }\n    }\n    return false;\n}\n\n// 2. Memoization for expensive computations\nMap<Node, Integer> memo = new HashMap<>();\n\nint expensiveComputation(Node root) {\n    if (memo.containsKey(root)) return memo.get(root);\n\n    int result = computeValue(root);\n    memo.put(root, result);\n    return result;\n}\n\n// 3. Level-order processing for breadth-first problems\nvoid processLevelOrder(Node root) {\n    if (root == null) return;\n\n    Queue<Node> queue = new LinkedList<>();\n    queue.offer(root);\n\n    while (!queue.isEmpty()) {\n        int levelSize = queue.size();\n        // Process entire level at once\n        for (int i = 0; i < levelSize; i++) {\n            Node current = queue.poll();\n            processNode(current);\n\n            if (current.children != null) {\n                queue.addAll(current.children);\n            }\n        }\n    }\n}\n\nvoid processNode(Node node) { /* Implementation specific */ }\nint computeValue(Node root) { return 0; /* Implementation specific */ }\n"})}),"\n",(0,t.jsx)(n.h3,{id:"interview-tips",children:"Interview Tips"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Identify the pattern"})," early: traversal, path finding, tree property, etc."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Ask about constraints"}),": maximum children per node, tree height, value ranges"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Consider edge cases"}),": empty tree, single node, all nodes same value"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Choose appropriate traversal"}),": DFS for paths, BFS for level-wise processing"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Think about space optimization"}),": can you solve iteratively or with constant extra space?"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}}}]);