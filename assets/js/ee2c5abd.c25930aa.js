"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[1120],{2912:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>a,metadata:()=>o,toc:()=>c});var t=i(4848),r=i(8453);const a={},s="Mathematics DSA Tricks, Tips & Patterns",o={id:"DSA/DSA with JavaScript/DSA Cheatsheets/Mathematics DSA Tricks, Tips",title:"Mathematics DSA Tricks, Tips & Patterns",description:"A comprehensive guide to mathematical techniques and patterns essential for Data Structures and Algorithms.",source:"@site/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Mathematics DSA Tricks, Tips.mdx",sourceDirName:"DSA/DSA with JavaScript/DSA Cheatsheets",slug:"/DSA/DSA with JavaScript/DSA Cheatsheets/Mathematics DSA Tricks, Tips",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Mathematics DSA Tricks, Tips",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Mathematics DSA Tricks, Tips.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Linked List",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/DSA Cheatsheets/LinkedList"},next:{title:"N-ary Tree",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/DSA Cheatsheets/N-ary Tree"}},l={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Number Theory Fundamentals",id:"number-theory-fundamentals",level:2},{value:"1. Even/Odd Properties",id:"1-evenodd-properties",level:3},{value:"2. Divisibility Rules",id:"2-divisibility-rules",level:3},{value:"3. Digital Root &amp; Digit Manipulation",id:"3-digital-root--digit-manipulation",level:3},{value:"Modular Arithmetic",id:"modular-arithmetic",level:2},{value:"1. Basic Modular Operations",id:"1-basic-modular-operations",level:3},{value:"2. Modular Exponentiation",id:"2-modular-exponentiation",level:3},{value:"3. Modular Inverse",id:"3-modular-inverse",level:3},{value:"Prime Numbers &amp; Factorization",id:"prime-numbers--factorization",level:2},{value:"1. Prime Checking &amp; Generation",id:"1-prime-checking--generation",level:3},{value:"2. Prime Factorization",id:"2-prime-factorization",level:3},{value:"GCD &amp; LCM Techniques",id:"gcd--lcm-techniques",level:2},{value:"1. GCD Algorithms",id:"1-gcd-algorithms",level:3},{value:"2. Applications",id:"2-applications",level:3},{value:"Combinatorics &amp; Probability",id:"combinatorics--probability",level:2},{value:"1. Basic Combinatorics",id:"1-basic-combinatorics",level:3},{value:"2. Advanced Combinatorics",id:"2-advanced-combinatorics",level:3},{value:"Bit Manipulation Math",id:"bit-manipulation-math",level:2},{value:"1. Bit Counting &amp; Properties",id:"1-bit-counting--properties",level:3},{value:"2. XOR Properties",id:"2-xor-properties",level:3},{value:"Mathematical Sequences",id:"mathematical-sequences",level:2},{value:"1. Fibonacci &amp; Related",id:"1-fibonacci--related",level:3},{value:"2. Other Important Sequences",id:"2-other-important-sequences",level:3},{value:"Geometry &amp; Coordinate Math",id:"geometry--coordinate-math",level:2},{value:"1. 2D Geometry",id:"1-2d-geometry",level:3},{value:"2. Coordinate Transformations",id:"2-coordinate-transformations",level:3},{value:"Fast Exponentiation",id:"fast-exponentiation",level:2},{value:"1. Binary Exponentiation",id:"1-binary-exponentiation",level:3},{value:"Matrix Operations",id:"matrix-operations",level:2},{value:"1. Basic Matrix Operations",id:"1-basic-matrix-operations",level:3},{value:"Game Theory Basics",id:"game-theory-basics",level:2},{value:"1. Nim Game &amp; Grundy Numbers",id:"1-nim-game--grundy-numbers",level:3},{value:"Common Mathematical Patterns",id:"common-mathematical-patterns",level:2},{value:"1. Pattern Recognition",id:"1-pattern-recognition",level:3},{value:"2. Mathematical Sequences &amp; Series",id:"2-mathematical-sequences--series",level:3},{value:"3. Number Theory Applications",id:"3-number-theory-applications",level:3},{value:"4. Advanced Mathematical Tricks",id:"4-advanced-mathematical-tricks",level:3},{value:"5. Optimization Techniques",id:"5-optimization-techniques",level:3},{value:"Advanced Problem-Solving Patterns",id:"advanced-problem-solving-patterns",level:2},{value:"1. Mathematical Transformations",id:"1-mathematical-transformations",level:3},{value:"2. Mathematical Invariants",id:"2-mathematical-invariants",level:3},{value:"3. Mathematical Induction Patterns",id:"3-mathematical-induction-patterns",level:3},{value:"Contest Math Shortcuts",id:"contest-math-shortcuts",level:2},{value:"1. Quick Calculation Tricks",id:"1-quick-calculation-tricks",level:3},{value:"2. Pattern Recognition Shortcuts",id:"2-pattern-recognition-shortcuts",level:3},{value:"Usage Examples &amp; Practice Problems",id:"usage-examples--practice-problems",level:2},{value:"Time Complexity Reference",id:"time-complexity-reference",level:2},{value:"Key Problem-Solving Strategies",id:"key-problem-solving-strategies",level:2},{value:"1. <strong>Mathematical Insight Recognition</strong>",id:"1-mathematical-insight-recognition",level:3},{value:"2. <strong>Optimization Techniques</strong>",id:"2-optimization-techniques",level:3},{value:"3. <strong>Common Pitfalls to Avoid</strong>",id:"3-common-pitfalls-to-avoid",level:3},{value:"4. <strong>Contest-Specific Tips</strong>",id:"4-contest-specific-tips",level:3}];function u(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"mathematics-dsa-tricks-tips--patterns",children:"Mathematics DSA Tricks, Tips & Patterns"})}),"\n",(0,t.jsx)(e.p,{children:"A comprehensive guide to mathematical techniques and patterns essential for Data Structures and Algorithms."}),"\n",(0,t.jsx)(e.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#number-theory-fundamentals",children:"Number Theory Fundamentals"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#modular-arithmetic",children:"Modular Arithmetic"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#prime-numbers--factorization",children:"Prime Numbers & Factorization"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#gcd--lcm-techniques",children:"GCD & LCM Techniques"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#combinatorics--probability",children:"Combinatorics & Probability"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#bit-manipulation-math",children:"Bit Manipulation Math"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#mathematical-sequences",children:"Mathematical Sequences"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#geometry--coordinate-math",children:"Geometry & Coordinate Math"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#fast-exponentiation",children:"Fast Exponentiation"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#matrix-operations",children:"Matrix Operations"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#game-theory-basics",children:"Game Theory Basics"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#common-mathematical-patterns",children:"Common Mathematical Patterns"})}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"number-theory-fundamentals",children:"Number Theory Fundamentals"}),"\n",(0,t.jsx)(e.h3,{id:"1-evenodd-properties",children:"1. Even/Odd Properties"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Check if number is even/odd\nconst isEven = (n) => n % 2 === 0;\nconst isOdd = (n) => n % 2 !== 0;\n\n// Even \xb1 Even = Even\n// Odd \xb1 Odd = Even\n// Even \xb1 Odd = Odd\n// Even \xd7 Any = Even\n// Odd \xd7 Odd = Odd\n\n// Sum of first n natural numbers\nconst sumOfN = (n) => n * (n + 1) / 2;\n\n// Sum of first n odd numbers = n\xb2\nconst sumOfNOdds = (n) => n * n;\n\n// Sum of first n even numbers = n(n+1)\nconst sumOfNEvens = (n) => n * (n + 1);\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-divisibility-rules",children:"2. Divisibility Rules"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Quick divisibility checks\nfunction isDivisible(n, d) {\n    const rules = {\n        2: n => n % 2 === 0,\n        3: n => sumOfDigits(n) % 3 === 0,\n        4: n => parseInt(String(n).slice(-2)) % 4 === 0,\n        5: n => n % 10 === 0 || n % 10 === 5,\n        6: n => n % 2 === 0 && sumOfDigits(n) % 3 === 0,\n        8: n => parseInt(String(n).slice(-3)) % 8 === 0,\n        9: n => sumOfDigits(n) % 9 === 0,\n        11: n => alternatingSum(n) % 11 === 0\n    };\n    return rules[d] ? rules[d](n) : n % d === 0;\n}\n\nfunction sumOfDigits(n) {\n    let sum = 0;\n    while (n > 0) {\n        sum += n % 10;\n        n = Math.floor(n / 10);\n    }\n    return sum;\n}\n\nfunction alternatingSum(n) {\n    let sum = 0, sign = 1;\n    while (n > 0) {\n        sum += sign * (n % 10);\n        sign *= -1;\n        n = Math.floor(n / 10);\n    }\n    return sum;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-digital-root--digit-manipulation",children:"3. Digital Root & Digit Manipulation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Digital root (repeated sum until single digit)\nfunction digitalRoot(n) {\n    if (n === 0) return 0;\n    return 1 + (n - 1) % 9;\n    // Alternative: while (n >= 10) n = sumOfDigits(n);\n}\n\n// Count digits\nconst countDigits = (n) => String(Math.abs(n)).length;\n\n// Reverse number\nfunction reverseNumber(n) {\n    let result = 0;\n    while (n > 0) {\n        result = result * 10 + n % 10;\n        n = Math.floor(n / 10);\n    }\n    return result;\n}\n\n// Check palindrome number\nconst isPalindromeNumber = (n) => n === reverseNumber(n);\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"modular-arithmetic",children:"Modular Arithmetic"}),"\n",(0,t.jsx)(e.h3,{id:"1-basic-modular-operations",children:"1. Basic Modular Operations"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Modular addition/subtraction\nconst modAdd = (a, b, mod) => ((a % mod) + (b % mod)) % mod;\nconst modSub = (a, b, mod) => ((a % mod) - (b % mod) + mod) % mod;\nconst modMul = (a, b, mod) => ((a % mod) * (b % mod)) % mod;\n\n// Handle negative numbers in modulo\nconst safeMod = (a, mod) => ((a % mod) + mod) % mod;\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-modular-exponentiation",children:"2. Modular Exponentiation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Fast modular exponentiation: (base^exp) % mod\nfunction modPow(base, exp, mod) {\n    let result = 1;\n    base = base % mod;\n\n    while (exp > 0) {\n        if (exp % 2 === 1) {\n            result = (result * base) % mod;\n        }\n        exp = Math.floor(exp / 2);\n        base = (base * base) % mod;\n    }\n\n    return result;\n}\n\n// Power of 2 check using bit manipulation\nconst isPowerOfTwo = (n) => n > 0 && (n & (n - 1)) === 0;\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-modular-inverse",children:"3. Modular Inverse"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Extended Euclidean Algorithm\nfunction extendedGCD(a, b) {\n    if (a === 0) return [b, 0, 1];\n\n    const [gcd, x1, y1] = extendedGCD(b % a, a);\n    const x = y1 - Math.floor(b / a) * x1;\n    const y = x1;\n\n    return [gcd, x, y];\n}\n\n// Modular multiplicative inverse\nfunction modInverse(a, mod) {\n    const [gcd, x, y] = extendedGCD(a, mod);\n    if (gcd !== 1) return -1; // Inverse doesn't exist\n    return ((x % mod) + mod) % mod;\n}\n\n// Using Fermat's Little Theorem (when mod is prime)\nconst modInverseFermat = (a, p) => modPow(a, p - 2, p);\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"prime-numbers--factorization",children:"Prime Numbers & Factorization"}),"\n",(0,t.jsx)(e.h3,{id:"1-prime-checking--generation",children:"1. Prime Checking & Generation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Optimized prime check\nfunction isPrime(n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 === 0 || n % 3 === 0) return false;\n\n    for (let i = 5; i * i <= n; i += 6) {\n        if (n % i === 0 || n % (i + 2) === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Sieve of Eratosthenes\nfunction sieveOfEratosthenes(n) {\n    const primes = Array(n + 1).fill(true);\n    primes[0] = primes[1] = false;\n\n    for (let i = 2; i * i <= n; i++) {\n        if (primes[i]) {\n            for (let j = i * i; j <= n; j += i) {\n                primes[j] = false;\n            }\n        }\n    }\n\n    return primes.map((isPrime, num) => isPrime ? num : null)\n                 .filter(num => num !== null);\n}\n\n// Segmented Sieve for large ranges\nfunction segmentedSieve(left, right) {\n    const limit = Math.floor(Math.sqrt(right)) + 1;\n    const basePrimes = sieveOfEratosthenes(limit);\n\n    const size = right - left + 1;\n    const isPrime = Array(size).fill(true);\n\n    for (const prime of basePrimes) {\n        const start = Math.max(prime * prime, Math.ceil(left / prime) * prime);\n        for (let j = start; j <= right; j += prime) {\n            isPrime[j - left] = false;\n        }\n    }\n\n    const result = [];\n    for (let i = 0; i < size; i++) {\n        if (isPrime[i] && left + i > 1) {\n            result.push(left + i);\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-prime-factorization",children:"2. Prime Factorization"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Prime factorization\nfunction primeFactors(n) {\n    const factors = [];\n\n    // Check for 2\n    while (n % 2 === 0) {\n        factors.push(2);\n        n = Math.floor(n / 2);\n    }\n\n    // Check for odd factors\n    for (let i = 3; i * i <= n; i += 2) {\n        while (n % i === 0) {\n            factors.push(i);\n            n = Math.floor(n / i);\n        }\n    }\n\n    if (n > 2) factors.push(n);\n    return factors;\n}\n\n// Count divisors using prime factorization\nfunction countDivisors(n) {\n    let count = 1;\n\n    for (let i = 2; i * i <= n; i++) {\n        let power = 0;\n        while (n % i === 0) {\n            power++;\n            n = Math.floor(n / i);\n        }\n        count *= (power + 1);\n    }\n\n    if (n > 1) count *= 2;\n    return count;\n}\n\n// Sum of divisors\nfunction sumOfDivisors(n) {\n    let sum = 1;\n\n    for (let i = 2; i * i <= n; i++) {\n        let power = 0, temp = n;\n        while (temp % i === 0) {\n            power++;\n            temp = Math.floor(temp / i);\n        }\n\n        if (power > 0) {\n            sum *= (Math.pow(i, power + 1) - 1) / (i - 1);\n            n = temp;\n        }\n    }\n\n    if (n > 1) sum *= (n + 1);\n    return sum;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"gcd--lcm-techniques",children:"GCD & LCM Techniques"}),"\n",(0,t.jsx)(e.h3,{id:"1-gcd-algorithms",children:"1. GCD Algorithms"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Euclidean Algorithm\nfunction gcd(a, b) {\n    while (b !== 0) {\n        const temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\n// Recursive GCD\nconst gcdRecursive = (a, b) => b === 0 ? a : gcdRecursive(b, a % b);\n\n// GCD of array\nconst gcdArray = (arr) => arr.reduce(gcd);\n\n// LCM using GCD\nconst lcm = (a, b) => (a * b) / gcd(a, b);\nconst lcmArray = (arr) => arr.reduce(lcm);\n\n// Binary GCD (Stein's Algorithm) - faster for large numbers\nfunction binaryGCD(a, b) {\n    if (a === b) return a;\n    if (a === 0) return b;\n    if (b === 0) return a;\n\n    if (~a & 1) {\n        if (b & 1) return binaryGCD(a >> 1, b);\n        else return binaryGCD(a >> 1, b >> 1) << 1;\n    }\n\n    if (~b & 1) return binaryGCD(a, b >> 1);\n\n    if (a > b) return binaryGCD((a - b) >> 1, b);\n    return binaryGCD((b - a) >> 1, a);\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-applications",children:"2. Applications"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Reduce fraction to lowest terms\nfunction reduceFraction(num, den) {\n    const g = gcd(num, den);\n    return [num / g, den / g];\n}\n\n// Check if two numbers are coprime\nconst areCoprime = (a, b) => gcd(a, b) === 1;\n\n// Bezout's identity: ax + by = gcd(a,b)\nfunction extendedGCD(a, b) {\n    if (b === 0) return [a, 1, 0];\n\n    const [g, x1, y1] = extendedGCD(b, a % b);\n    return [g, y1, x1 - Math.floor(a / b) * y1];\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"combinatorics--probability",children:"Combinatorics & Probability"}),"\n",(0,t.jsx)(e.h3,{id:"1-basic-combinatorics",children:"1. Basic Combinatorics"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Factorial with memoization\nconst factorialMemo = (() => {\n    const memo = [1, 1];\n    return function(n) {\n        if (memo[n] !== undefined) return memo[n];\n        for (let i = memo.length; i <= n; i++) {\n            memo[i] = memo[i - 1] * i;\n        }\n        return memo[n];\n    };\n})();\n\n// Modular factorial\nfunction factorialMod(n, mod) {\n    let result = 1;\n    for (let i = 1; i <= n; i++) {\n        result = (result * i) % mod;\n    }\n    return result;\n}\n\n// nCr - Combinations\nfunction nCr(n, r) {\n    if (r > n || r < 0) return 0;\n    if (r === 0 || r === n) return 1;\n\n    // Optimization: nCr = nC(n-r)\n    r = Math.min(r, n - r);\n\n    let result = 1;\n    for (let i = 0; i < r; i++) {\n        result = result * (n - i) / (i + 1);\n    }\n    return Math.round(result);\n}\n\n// nCr with modular arithmetic\nfunction nCrMod(n, r, mod) {\n    if (r > n || r < 0) return 0;\n    if (r === 0 || r === n) return 1;\n\n    const num = factorialMod(n, mod);\n    const den = modMul(factorialMod(r, mod), factorialMod(n - r, mod), mod);\n\n    return modMul(num, modInverse(den, mod), mod);\n}\n\n// nPr - Permutations\nfunction nPr(n, r) {\n    if (r > n || r < 0) return 0;\n\n    let result = 1;\n    for (let i = 0; i < r; i++) {\n        result *= (n - i);\n    }\n    return result;\n}\n\n// Pascal's Triangle row\nfunction pascalRow(n) {\n    const row = [1];\n    for (let i = 1; i <= n; i++) {\n        row.push(row[i - 1] * (n - i + 1) / i);\n    }\n    return row;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-advanced-combinatorics",children:"2. Advanced Combinatorics"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Catalan Numbers: C(n) = (2n)! / ((n+1)! * n!)\nfunction catalan(n) {\n    if (n <= 1) return 1;\n    return nCr(2 * n, n) / (n + 1);\n}\n\n// Derangements: !n = n! * \u03a3((-1)^k / k!) for k=0 to n\nfunction derangements(n) {\n    if (n === 0) return 1;\n    if (n === 1) return 0;\n\n    return (n - 1) * (derangements(n - 1) + derangements(n - 2));\n}\n\n// Stirling numbers of second kind: S(n,k)\nfunction stirling2(n, k) {\n    if (k === 0) return n === 0 ? 1 : 0;\n    if (k === 1 || k === n) return 1;\n    if (k > n) return 0;\n\n    return k * stirling2(n - 1, k) + stirling2(n - 1, k - 1);\n}\n\n// Bell numbers: B(n) = \u03a3 S(n,k) for k=0 to n\nfunction bellNumber(n) {\n    let sum = 0;\n    for (let k = 0; k <= n; k++) {\n        sum += stirling2(n, k);\n    }\n    return sum;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"bit-manipulation-math",children:"Bit Manipulation Math"}),"\n",(0,t.jsx)(e.h3,{id:"1-bit-counting--properties",children:"1. Bit Counting & Properties"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Count set bits (Brian Kernighan's algorithm)\nfunction countSetBits(n) {\n    let count = 0;\n    while (n) {\n        n &= (n - 1); // Remove rightmost set bit\n        count++;\n    }\n    return count;\n}\n\n// Check if position i is set\nconst isBitSet = (n, i) => (n & (1 << i)) !== 0;\n\n// Set bit at position i\nconst setBit = (n, i) => n | (1 << i);\n\n// Clear bit at position i\nconst clearBit = (n, i) => n & ~(1 << i);\n\n// Toggle bit at position i\nconst toggleBit = (n, i) => n ^ (1 << i);\n\n// Get rightmost set bit\nconst rightmostSetBit = (n) => n & (-n);\n\n// Check if power of 2\nconst isPowerOf2 = (n) => n > 0 && (n & (n - 1)) === 0;\n\n// Next power of 2\nfunction nextPowerOf2(n) {\n    if (n <= 1) return 1;\n    n--;\n    n |= n >> 1;\n    n |= n >> 2;\n    n |= n >> 4;\n    n |= n >> 8;\n    n |= n >> 16;\n    return n + 1;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-xor-properties",children:"2. XOR Properties"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// XOR properties:\n// a ^ a = 0\n// a ^ 0 = a\n// XOR is commutative and associative\n\n// Find unique element in array where all others appear twice\nconst findUnique = (arr) => arr.reduce((xor, num) => xor ^ num, 0);\n\n// Find two unique elements in array where all others appear twice\nfunction findTwoUnique(arr) {\n    const xorAll = arr.reduce((xor, num) => xor ^ num, 0);\n    const rightmostBit = xorAll & (-xorAll);\n\n    let num1 = 0, num2 = 0;\n    for (const num of arr) {\n        if (num & rightmostBit) {\n            num1 ^= num;\n        } else {\n            num2 ^= num;\n        }\n    }\n\n    return [num1, num2];\n}\n\n// XOR of range [1, n]\nfunction xorRange(n) {\n    const mod = n % 4;\n    if (mod === 0) return n;\n    if (mod === 1) return 1;\n    if (mod === 2) return n + 1;\n    return 0;\n}\n\n// XOR of range [a, b]\nconst xorRangeAB = (a, b) => xorRange(b) ^ xorRange(a - 1);\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"mathematical-sequences",children:"Mathematical Sequences"}),"\n",(0,t.jsx)(e.h3,{id:"1-fibonacci--related",children:"1. Fibonacci & Related"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Fibonacci sequence\nfunction fibonacci(n) {\n    if (n <= 1) return n;\n\n    let a = 0, b = 1;\n    for (let i = 2; i <= n; i++) {\n        const temp = a + b;\n        a = b;\n        b = temp;\n    }\n    return b;\n}\n\n// Matrix exponentiation for Fibonacci (O(log n))\nfunction fibonacciMatrix(n) {\n    if (n <= 1) return n;\n\n    const matrix = [[1, 1], [1, 0]];\n    const result = matrixPower(matrix, n - 1);\n    return result[0][0];\n}\n\nfunction matrixMultiply(A, B) {\n    const result = [[0, 0], [0, 0]];\n    for (let i = 0; i < 2; i++) {\n        for (let j = 0; j < 2; j++) {\n            for (let k = 0; k < 2; k++) {\n                result[i][j] += A[i][k] * B[k][j];\n            }\n        }\n    }\n    return result;\n}\n\nfunction matrixPower(matrix, n) {\n    if (n === 1) return matrix;\n\n    if (n % 2 === 0) {\n        const half = matrixPower(matrix, n / 2);\n        return matrixMultiply(half, half);\n    } else {\n        return matrixMultiply(matrix, matrixPower(matrix, n - 1));\n    }\n}\n\n// Check if number is Fibonacci\nfunction isFibonacci(n) {\n    return isPerfectSquare(5 * n * n + 4) || isPerfectSquare(5 * n * n - 4);\n}\n\nfunction isPerfectSquare(n) {\n    const sqrt = Math.floor(Math.sqrt(n));\n    return sqrt * sqrt === n;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-other-important-sequences",children:"2. Other Important Sequences"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Tribonacci: T(n) = T(n-1) + T(n-2) + T(n-3)\nfunction tribonacci(n) {\n    if (n === 0) return 0;\n    if (n <= 2) return 1;\n\n    let a = 0, b = 1, c = 1;\n    for (let i = 3; i <= n; i++) {\n        const temp = a + b + c;\n        a = b;\n        b = c;\n        c = temp;\n    }\n    return c;\n}\n\n// Arithmetic sequence sum: S = n/2 * (2a + (n-1)d)\nconst arithmeticSum = (a, d, n) => n * (2 * a + (n - 1) * d) / 2;\n\n// Geometric sequence sum: S = a * (r^n - 1) / (r - 1)\nconst geometricSum = (a, r, n) => r === 1 ? a * n : a * (Math.pow(r, n) - 1) / (r - 1);\n\n// Sum of squares: 1\xb2 + 2\xb2 + ... + n\xb2 = n(n+1)(2n+1)/6\nconst sumOfSquares = (n) => n * (n + 1) * (2 * n + 1) / 6;\n\n// Sum of cubes: 1\xb3 + 2\xb3 + ... + n\xb3 = [n(n+1)/2]\xb2\nconst sumOfCubes = (n) => {\n    const sum = n * (n + 1) / 2;\n    return sum * sum;\n};\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"geometry--coordinate-math",children:"Geometry & Coordinate Math"}),"\n",(0,t.jsx)(e.h3,{id:"1-2d-geometry",children:"1. 2D Geometry"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Distance between two points\nconst distance = (x1, y1, x2, y2) => Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);\n\n// Area of triangle given three points\nfunction triangleArea(x1, y1, x2, y2, x3, y3) {\n    return Math.abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2);\n}\n\n// Check if three points are collinear\nfunction areCollinear(x1, y1, x2, y2, x3, y3) {\n    return triangleArea(x1, y1, x2, y2, x3, y3) === 0;\n}\n\n// Slope of line\nconst slope = (x1, y1, x2, y2) => x2 === x1 ? Infinity : (y2 - y1) / (x2 - x1);\n\n// Point on line check\nfunction isPointOnLine(px, py, x1, y1, x2, y2) {\n    return areCollinear(px, py, x1, y1, x2, y2) &&\n           px >= Math.min(x1, x2) && px <= Math.max(x1, x2) &&\n           py >= Math.min(y1, y2) && py <= Math.max(y1, y2);\n}\n\n// Circle properties\nconst circleArea = (r) => Math.PI * r * r;\nconst circleCircumference = (r) => 2 * Math.PI * r;\n\n// Check if point is inside circle\nfunction isPointInCircle(px, py, cx, cy, r) {\n    return distance(px, py, cx, cy) <= r;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-coordinate-transformations",children:"2. Coordinate Transformations"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Rotate point around origin\nfunction rotatePoint(x, y, angle) {\n    const cos = Math.cos(angle);\n    const sin = Math.sin(angle);\n    return [x * cos - y * sin, x * sin + y * cos];\n}\n\n// Reflect point across y = mx + b\nfunction reflectAcrossLine(px, py, m, b) {\n    const a = -m;\n    const c = -b;\n    const temp = a * a + 1;\n\n    const x = (px + a * py + a * c) / temp - a * (a * px - py - c) / temp;\n    const y = (a * px - py - c) / temp + (py + a * px + a * c) / temp;\n\n    return [x, y];\n}\n\n// Manhattan distance\nconst manhattanDistance = (x1, y1, x2, y2) => Math.abs(x1 - x2) + Math.abs(y1 - y2);\n\n// Chebyshev distance\nconst chebyshevDistance = (x1, y1, x2, y2) => Math.max(Math.abs(x1 - x2), Math.abs(y1 - y2));\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"fast-exponentiation",children:"Fast Exponentiation"}),"\n",(0,t.jsx)(e.h3,{id:"1-binary-exponentiation",children:"1. Binary Exponentiation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Fast exponentiation: a^n\nfunction fastPower(base, exp) {\n    if (exp === 0) return 1;\n    if (exp === 1) return base;\n\n    let result = 1;\n    while (exp > 0) {\n        if (exp % 2 === 1) {\n            result *= base;\n        }\n        base *= base;\n        exp = Math.floor(exp / 2);\n    }\n    return result;\n}\n\n// Matrix exponentiation for recurrence relations\nfunction matrixPowerMod(matrix, n, mod) {\n    const size = matrix.length;\n    let result = Array(size).fill().map(() => Array(size).fill(0));\n\n    // Initialize identity matrix\n    for (let i = 0; i < size; i++) {\n        result[i][i] = 1;\n    }\n\n    while (n > 0) {\n        if (n % 2 === 1) {\n            result = matrixMultiplyMod(result, matrix, mod);\n        }\n        matrix = matrixMultiplyMod(matrix, matrix, mod);\n        n = Math.floor(n / 2);\n    }\n\n    return result;\n}\n\nfunction matrixMultiplyMod(A, B, mod) {\n    const size = A.length;\n    const result = Array(size).fill().map(() => Array(size).fill(0));\n\n    for (let i = 0; i < size; i++) {\n        for (let j = 0; j < size; j++) {\n            for (let k = 0; k < size; k++) {\n                result[i][j] = (result[i][j] + A[i][k] * B[k][j]) % mod;\n            }\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"matrix-operations",children:"Matrix Operations"}),"\n",(0,t.jsx)(e.h3,{id:"1-basic-matrix-operations",children:"1. Basic Matrix Operations"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Matrix multiplication\nfunction matrixMultiply(A, B) {\n    const rows = A.length;\n    const cols = B[0].length;\n    const common = B.length;\n\n    const result = Array(rows).fill().map(() => Array(cols).fill(0));\n\n    for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n            for (let k = 0; k < common; k++) {\n                result[i][j] += A[i][k] * B[k][j];\n            }\n        }\n    }\n\n    return result;\n}\n\n// Matrix determinant (2x2)\nconst det2x2 = (matrix) => matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0];\n\n// Matrix transpose\nfunction transpose(matrix) {\n    const rows = matrix.length;\n    const cols = matrix[0].length;\n\n    return Array(cols).fill().map((_, i) =>\n        Array(rows).fill().map((_, j) => matrix[j][i])\n    );\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"game-theory-basics",children:"Game Theory Basics"}),"\n",(0,t.jsx)(e.h3,{id:"1-nim-game--grundy-numbers",children:"1. Nim Game & Grundy Numbers"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Nim game: XOR of all pile sizes\nfunction nimSum(piles) {\n    return piles.reduce((xor, pile) => xor ^ pile, 0);\n}\n\n// Winning position in Nim\nconst isWinningNim = (piles) => nimSum(piles) !== 0;\n\n// Grundy number calculation\nfunction grundyNumber(n, moves) {\n    if (n === 0) return 0;\n\n    const reachable = new Set();\n    for (const move of moves) {\n        if (n >= move) {\n            reachable.add(grundyNumber(n - move, moves));\n        }\n    }\n\n    // Find mex (minimum excludant)\n    let mex = 0;\n    while (reachable.has(mex)) {\n        mex++;\n    }\n\n    return mex;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"common-mathematical-patterns",children:"Common Mathematical Patterns"}),"\n",(0,t.jsx)(e.h3,{id:"1-pattern-recognition",children:"1. Pattern Recognition"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Sum patterns\nconst patterns = {\n    // 1 + 2 + ... + n = n(n+1)/2\n    triangular: n => n * (n + 1) / 2,\n\n    // 1\xb2 + 2\xb2 + ... + n\xb2 = n(n+1)(2n+1)/6\n    squares: n => n * (n + 1) * (2 * n + 1) / 6,\n\n    // 1\xb3 + 2\xb3 + ... + n\xb3 = [n(n+1)/2]\xb2\n    cubes: n => {\n        const sum = n * (n + 1) / 2;\n        return sum * sum;\n    },\n\n    // 1\xd72 + 2\xd73 + ... + n\xd7(n+1) = n(n+1)(n+2)/3\n    consecutive: n => n * (n + 1) * (n + 2) / 3,\n\n    // Powers of 2: 1 + 2 + 4 + ... + 2^n = 2^(n+1) - 1\n    powersOf2: n => Math.pow(2, n + 1) - 1\n};\n\n// Check if number follows pattern\nfunction isTriangular(num) {\n    // n(n+1)/2 = num => n\xb2 + n - 2num = 0\n    // n = (-1 + \u221a(1 + 8num)) / 2\n    const discriminant = 1 + 8 * num;\n    const sqrt = Math.sqrt(discriminant);\n    return sqrt === Math.floor(sqrt) && (sqrt - 1) % 2 === 0;\n}\n\nfunction isPentagonal(num) {\n    // n(3n-1)/2 = num => 3n\xb2 - n - 2num = 0\n    // n = (1 + \u221a(1 + 24num)) / 6\n    const discriminant = 1 + 24 * num;\n    const sqrt = Math.sqrt(discriminant);\n    return sqrt === Math.floor(sqrt) && (sqrt - 1) % 6 === 0;\n}\n\nfunction isHexagonal(num) {\n    // n(2n-1) = num => 2n\xb2 - n - num = 0\n    // n = (1 + \u221a(1 + 8num)) / 4\n    const discriminant = 1 + 8 * num;\n    const sqrt = Math.sqrt(discriminant);\n    return sqrt === Math.floor(sqrt) && (sqrt - 1) % 4 === 0;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-mathematical-sequences--series",children:"2. Mathematical Sequences & Series"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Harmonic series: 1 + 1/2 + 1/3 + ... + 1/n\nfunction harmonicSum(n) {\n    let sum = 0;\n    for (let i = 1; i <= n; i++) {\n        sum += 1 / i;\n    }\n    return sum;\n}\n\n// Alternating harmonic series: 1 - 1/2 + 1/3 - 1/4 + ...\nfunction alternatingHarmonicSum(n) {\n    let sum = 0;\n    for (let i = 1; i <= n; i++) {\n        sum += Math.pow(-1, i - 1) / i;\n    }\n    return sum;\n}\n\n// Sum of arithmetic-geometric series\nfunction arithmeticGeometricSum(a, d, r, n) {\n    if (r === 1) return n * a + d * n * (n - 1) / 2;\n\n    const numerator = a * (1 - Math.pow(r, n)) + d * r * (1 - n * Math.pow(r, n - 1) + (n - 1) * Math.pow(r, n));\n    const denominator = Math.pow(1 - r, 2);\n\n    return numerator / denominator;\n}\n\n// Generating functions for sequences\nfunction fibonacciGeneratingFunction(x, terms) {\n    // F(x) = x / (1 - x - x\xb2)\n    const coefficients = [];\n    coefficients[0] = 0;\n    coefficients[1] = 1;\n\n    for (let i = 2; i < terms; i++) {\n        coefficients[i] = coefficients[i - 1] + coefficients[i - 2];\n    }\n\n    return coefficients;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-number-theory-applications",children:"3. Number Theory Applications"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Euler's totient function \u03c6(n)\nfunction eulerTotient(n) {\n    let result = n;\n\n    for (let i = 2; i * i <= n; i++) {\n        if (n % i === 0) {\n            while (n % i === 0) {\n                n = Math.floor(n / i);\n            }\n            result -= Math.floor(result / i);\n        }\n    }\n\n    if (n > 1) result -= Math.floor(result / n);\n    return result;\n}\n\n// Mobius function \u03bc(n)\nfunction mobiusFunction(n) {\n    if (n === 1) return 1;\n\n    const factors = primeFactors(n);\n    const uniqueFactors = [...new Set(factors)];\n\n    // If n has squared prime factor, \u03bc(n) = 0\n    if (factors.length !== uniqueFactors.length) return 0;\n\n    // \u03bc(n) = (-1)^k where k is number of prime factors\n    return Math.pow(-1, uniqueFactors.length);\n}\n\n// Wilson's theorem: (p-1)! \u2261 -1 (mod p) for prime p\nfunction wilsonTheorem(p) {\n    if (!isPrime(p)) return false;\n\n    let factorial = 1;\n    for (let i = 1; i < p; i++) {\n        factorial = (factorial * i) % p;\n    }\n\n    return factorial === p - 1;\n}\n\n// Fermat's little theorem: a^(p-1) \u2261 1 (mod p) for prime p\nfunction fermatLittleTheorem(a, p) {\n    if (!isPrime(p) || gcd(a, p) !== 1) return false;\n    return modPow(a, p - 1, p) === 1;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"4-advanced-mathematical-tricks",children:"4. Advanced Mathematical Tricks"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Chinese Remainder Theorem\nfunction chineseRemainderTheorem(remainders, moduli) {\n    const n = remainders.length;\n    let result = 0;\n    let product = 1;\n\n    for (let i = 0; i < n; i++) {\n        product *= moduli[i];\n    }\n\n    for (let i = 0; i < n; i++) {\n        const partialProduct = Math.floor(product / moduli[i]);\n        result += remainders[i] * partialProduct * modInverse(partialProduct, moduli[i]);\n        result %= product;\n    }\n\n    return result;\n}\n\n// Miller-Rabin primality test (probabilistic)\nfunction millerRabinTest(n, k = 5) {\n    if (n === 2 || n === 3) return true;\n    if (n < 2 || n % 2 === 0) return false;\n\n    // Write n-1 as 2^r * d\n    let r = 0;\n    let d = n - 1;\n    while (d % 2 === 0) {\n        d = Math.floor(d / 2);\n        r++;\n    }\n\n    // Witness loop\n    for (let i = 0; i < k; i++) {\n        const a = 2 + Math.floor(Math.random() * (n - 4));\n        let x = modPow(a, d, n);\n\n        if (x === 1 || x === n - 1) continue;\n\n        let composite = true;\n        for (let j = 0; j < r - 1; j++) {\n            x = modPow(x, 2, n);\n            if (x === n - 1) {\n                composite = false;\n                break;\n            }\n        }\n\n        if (composite) return false;\n    }\n\n    return true;\n}\n\n// Pollard's rho algorithm for factorization\nfunction pollardRho(n) {\n    if (n % 2 === 0) return 2;\n\n    let x = 2, y = 2, d = 1;\n\n    const f = (x) => (x * x + 1) % n;\n\n    while (d === 1) {\n        x = f(x);\n        y = f(f(y));\n        d = gcd(Math.abs(x - y), n);\n    }\n\n    return d === n ? -1 : d;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"5-optimization-techniques",children:"5. Optimization Techniques"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Binary search for mathematical functions\nfunction binarySearchMath(left, right, target, func, epsilon = 1e-9) {\n    while (right - left > epsilon) {\n        const mid = (left + right) / 2;\n        const value = func(mid);\n\n        if (value < target) {\n            left = mid;\n        } else {\n            right = mid;\n        }\n    }\n\n    return (left + right) / 2;\n}\n\n// Ternary search for unimodal functions\nfunction ternarySearch(left, right, func, maximize = true, epsilon = 1e-9) {\n    while (right - left > epsilon) {\n        const m1 = left + (right - left) / 3;\n        const m2 = right - (right - left) / 3;\n\n        const val1 = func(m1);\n        const val2 = func(m2);\n\n        if (maximize) {\n            if (val1 < val2) {\n                left = m1;\n            } else {\n                right = m2;\n            }\n        } else {\n            if (val1 > val2) {\n                left = m1;\n            } else {\n                right = m2;\n            }\n        }\n    }\n\n    return (left + right) / 2;\n}\n\n// Golden section search\nfunction goldenSectionSearch(a, b, func, epsilon = 1e-9) {\n    const phi = (1 + Math.sqrt(5)) / 2;\n    const resphi = 2 - phi;\n\n    let x1 = a + resphi * (b - a);\n    let x2 = b - resphi * (b - a);\n    let f1 = func(x1);\n    let f2 = func(x2);\n\n    while (Math.abs(b - a) > epsilon) {\n        if (f1 > f2) {\n            b = x2;\n            x2 = x1;\n            f2 = f1;\n            x1 = a + resphi * (b - a);\n            f1 = func(x1);\n        } else {\n            a = x1;\n            x1 = x2;\n            f1 = f2;\n            x2 = b - resphi * (b - a);\n            f2 = func(x2);\n        }\n    }\n\n    return (a + b) / 2;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"advanced-problem-solving-patterns",children:"Advanced Problem-Solving Patterns"}),"\n",(0,t.jsx)(e.h3,{id:"1-mathematical-transformations",children:"1. Mathematical Transformations"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Transform problems to simpler forms\nconst transformations = {\n    // Sum of products: \u03a3(ai * bi) using dot product\n    dotProduct: (a, b) => a.reduce((sum, val, i) => sum + val * b[i], 0),\n\n    // Convert multiplication to addition using logs\n    logMultiply: (a, b) => Math.exp(Math.log(a) + Math.log(b)),\n\n    // Use roots of unity for cyclic problems\n    rootsOfUnity: (n) => Array.from({length: n}, (_, k) => ({\n        real: Math.cos(2 * Math.PI * k / n),\n        imag: Math.sin(2 * Math.PI * k / n)\n    })),\n\n    // Transform coordinates for rotation problems\n    rotateCoords: (points, angle) => points.map(([x, y]) => {\n        const cos = Math.cos(angle);\n        const sin = Math.sin(angle);\n        return [x * cos - y * sin, x * sin + y * cos];\n    })\n};\n\n// Inclusion-exclusion principle\nfunction inclusionExclusion(sets) {\n    const n = sets.length;\n    let result = 0;\n\n    for (let mask = 1; mask < (1 << n); mask++) {\n        let intersection = new Set(sets[0]);\n        let bits = 0;\n\n        for (let i = 0; i < n; i++) {\n            if (mask & (1 << i)) {\n                intersection = new Set([...intersection].filter(x => sets[i].has(x)));\n                bits++;\n            }\n        }\n\n        result += Math.pow(-1, bits - 1) * intersection.size;\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-mathematical-invariants",children:"2. Mathematical Invariants"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Find invariants in problems\nconst invariants = {\n    // Parity invariant\n    checkParity: (arr) => arr.reduce((sum, val) => sum + val, 0) % 2,\n\n    // Sum invariant\n    sumInvariant: (arr) => arr.reduce((sum, val) => sum + val, 0),\n\n    // Product invariant (useful in transformation problems)\n    productInvariant: (arr) => arr.reduce((prod, val) => prod * val, 1),\n\n    // Modular invariant\n    modularInvariant: (arr, mod) => arr.reduce((sum, val) => (sum + val) % mod, 0),\n\n    // XOR invariant\n    xorInvariant: (arr) => arr.reduce((xor, val) => xor ^ val, 0)\n};\n\n// Check if transformation preserves invariant\nfunction preservesInvariant(initial, final, invariantFunc) {\n    return invariantFunc(initial) === invariantFunc(final);\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-mathematical-induction-patterns",children:"3. Mathematical Induction Patterns"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Templates for induction proofs\nconst inductionPatterns = {\n    // Strong induction base cases\n    strongInductionBase: (n, baseValues) => {\n        if (n < baseValues.length) return baseValues[n];\n        return null;\n    },\n\n    // Prove divisibility by induction\n    divisibilityInduction: (n, divisor, formula) => {\n        if (n === 1) return formula(1) % divisor === 0;\n        return (formula(n) - formula(n - 1)) % divisor === 0;\n    },\n\n    // Inequality induction\n    inequalityInduction: (n, lhs, rhs) => {\n        // Base case\n        if (n === 1) return lhs(1) <= rhs(1);\n\n        // Inductive step: if P(k) then P(k+1)\n        // Usually requires proving lhs(k+1) - lhs(k) <= rhs(k+1) - rhs(k)\n        return true; // Implementation depends on specific problem\n    }\n};\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"contest-math-shortcuts",children:"Contest Math Shortcuts"}),"\n",(0,t.jsx)(e.h3,{id:"1-quick-calculation-tricks",children:"1. Quick Calculation Tricks"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Fast mental math techniques\nconst quickCalc = {\n    // Multiply by 11: (a*10 + b)*11 = a*110 + b*11 = a*100 + (a+b)*10 + b\n    multiplyBy11: (n) => {\n        const digits = String(n).split('').map(Number);\n        const result = [];\n        let carry = 0;\n\n        result.unshift((digits[digits.length - 1] + carry) % 10);\n        carry = Math.floor((digits[digits.length - 1] + carry) / 10);\n\n        for (let i = digits.length - 2; i >= 0; i--) {\n            const sum = digits[i] + digits[i + 1] + carry;\n            result.unshift(sum % 10);\n            carry = Math.floor(sum / 10);\n        }\n\n        if (carry > 0) result.unshift(carry);\n        return parseInt(result.join(''));\n    },\n\n    // Square numbers ending in 5: (10a + 5)\xb2 = 100a(a+1) + 25\n    squareEndingIn5: (n) => {\n        const a = Math.floor(n / 10);\n        return a * (a + 1) * 100 + 25;\n    },\n\n    // Divisibility by 9: sum of digits divisible by 9\n    divisibleBy9: (n) => sumOfDigits(n) % 9 === 0,\n\n    // Check if sum of digits is divisible by 3\n    divisibleBy3: (n) => sumOfDigits(n) % 3 === 0,\n\n    // Fast percentage calculations\n    percentage: (num, percent) => {\n        if (percent === 10) return num / 10;\n        if (percent === 25) return num / 4;\n        if (percent === 50) return num / 2;\n        return (num * percent) / 100;\n    }\n};\n\n// Vedic mathematics techniques\nconst vedic = {\n    // All from 9 and last from 10 (for subtraction from powers of 10)\n    allFrom9LastFrom10: (n) => {\n        const digits = String(n).split('').map(Number);\n        const result = [];\n\n        for (let i = 0; i < digits.length - 1; i++) {\n            result.push(9 - digits[i]);\n        }\n        result.push(10 - digits[digits.length - 1]);\n\n        return parseInt(result.join(''));\n    },\n\n    // Vertically and crosswise multiplication\n    verticalCrosswise: (a, b) => {\n        // For 2-digit numbers: (10x + y)(10u + v) = 100xu + 10(xv + yu) + yv\n        if (a < 100 && b < 100) {\n            const x = Math.floor(a / 10), y = a % 10;\n            const u = Math.floor(b / 10), v = b % 10;\n\n            return 100 * x * u + 10 * (x * v + y * u) + y * v;\n        }\n        return a * b;\n    }\n};\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-pattern-recognition-shortcuts",children:"2. Pattern Recognition Shortcuts"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Common contest patterns\nconst contestPatterns = {\n    // Stars and bars: distribute n identical objects into k bins\n    starsAndBars: (n, k) => nCr(n + k - 1, k - 1),\n\n    // Pigeonhole principle applications\n    pigeonhole: (objects, holes) => Math.ceil(objects / holes),\n\n    // Catalan number applications (parentheses, binary trees, etc.)\n    catalanApplications: {\n        parentheses: n => catalan(n),\n        binaryTrees: n => catalan(n),\n        triangulations: n => catalan(n - 2),\n        pathsInGrid: (n) => catalan(n) // Dyck paths\n    },\n\n    // Derangement applications\n    derangementProblems: {\n        hatCheck: n => derangements(n),\n        secretSanta: n => derangements(n)\n    }\n};\n\n// Mathematical competition formulas\nconst competitionFormulas = {\n    // Sum of first n terms of AP: S = n/2[2a + (n-1)d]\n    apSum: (n, a, d) => n * (2 * a + (n - 1) * d) / 2,\n\n    // Sum of first n terms of GP: S = a(r\u207f - 1)/(r - 1)\n    gpSum: (n, a, r) => a * (Math.pow(r, n) - 1) / (r - 1),\n\n    // Number of divisors: if n = p\u2081^a\u2081 \xd7 p\u2082^a\u2082 \xd7 ... then d(n) = (a\u2081+1)(a\u2082+1)...\n    numDivisors: (primeFactorization) => {\n        return Object.values(primeFactorization).reduce((prod, exp) => prod * (exp + 1), 1);\n    },\n\n    // Legendre's formula: highest power of prime p dividing n!\n    legendreFormula: (n, p) => {\n        let power = 0;\n        let pk = p;\n        while (pk <= n) {\n            power += Math.floor(n / pk);\n            pk *= p;\n        }\n        return power;\n    }\n};\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"usage-examples--practice-problems",children:"Usage Examples & Practice Problems"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:'console.log("=== Mathematical DSA Techniques Demo ===");\n\n// Number theory examples\nconsole.log("GCD(48, 18):", gcd(48, 18));\nconsole.log("LCM(12, 15):", lcm(12, 15));\nconsole.log("Is 17 prime?", isPrime(17));\nconsole.log("Prime factors of 60:", primeFactors(60));\n\n// Modular arithmetic\nconsole.log("2^10 mod 1000:", modPow(2, 10, 1000));\nconsole.log("Modular inverse of 3 mod 11:", modInverse(3, 11));\n\n// Combinatorics\nconsole.log("C(10, 3):", nCr(10, 3));\nconsole.log("P(10, 3):", nPr(10, 3));\nconsole.log("5th Catalan number:", catalan(5));\n\n// Sequences\nconsole.log("10th Fibonacci:", fibonacci(10));\nconsole.log("Sum of first 10 squares:", sumOfSquares(10));\nconsole.log("Is 15 triangular?", isTriangular(15));\n\n// Bit manipulation\nconsole.log("Count set bits in 25:", countSetBits(25));\nconsole.log("Is 16 power of 2?", isPowerOf2(16));\nconsole.log("XOR of [1,2,2,3,3]:", findUnique([1, 2, 2, 3, 3]));\n\n// Advanced techniques\nconsole.log("Euler\'s totient \u03c6(12):", eulerTotient(12));\nconsole.log("Digital root of 789:", digitalRoot(789));\n\n// Geometry\nconsole.log("Distance (0,0) to (3,4):", distance(0, 0, 3, 4));\nconsole.log("Triangle area (0,0), (3,0), (0,4):", triangleArea(0, 0, 3, 0, 0, 4));\n'})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"time-complexity-reference",children:"Time Complexity Reference"}),"\n",(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{children:"Algorithm"}),(0,t.jsx)(e.th,{children:"Time Complexity"}),(0,t.jsx)(e.th,{children:"Space Complexity"}),(0,t.jsx)(e.th,{children:"Notes"})]})}),(0,t.jsxs)(e.tbody,{children:[(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"GCD (Euclidean)"}),(0,t.jsx)(e.td,{children:"O(log min(a,b))"}),(0,t.jsx)(e.td,{children:"O(1)"}),(0,t.jsx)(e.td,{children:"Very efficient"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Prime Check"}),(0,t.jsx)(e.td,{children:"O(\u221an)"}),(0,t.jsx)(e.td,{children:"O(1)"}),(0,t.jsx)(e.td,{children:"Can be optimized"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Sieve of Eratosthenes"}),(0,t.jsx)(e.td,{children:"O(n log log n)"}),(0,t.jsx)(e.td,{children:"O(n)"}),(0,t.jsx)(e.td,{children:"Batch prime generation"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Modular Exponentiation"}),(0,t.jsx)(e.td,{children:"O(log n)"}),(0,t.jsx)(e.td,{children:"O(1)"}),(0,t.jsx)(e.td,{children:"Essential for large numbers"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Matrix Exponentiation"}),(0,t.jsx)(e.td,{children:"O(k\xb3 log n)"}),(0,t.jsx)(e.td,{children:"O(k\xb2)"}),(0,t.jsx)(e.td,{children:"k = matrix dimension"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Fast Fibonacci"}),(0,t.jsx)(e.td,{children:"O(log n)"}),(0,t.jsx)(e.td,{children:"O(1)"}),(0,t.jsx)(e.td,{children:"Using matrix exponentiation"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Prime Factorization"}),(0,t.jsx)(e.td,{children:"O(\u221an)"}),(0,t.jsx)(e.td,{children:"O(log n)"}),(0,t.jsx)(e.td,{children:"Can be optimized with precomputed primes"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Chinese Remainder Theorem"}),(0,t.jsx)(e.td,{children:"O(n\xb2)"}),(0,t.jsx)(e.td,{children:"O(1)"}),(0,t.jsx)(e.td,{children:"n = number of moduli"})]})]})]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"key-problem-solving-strategies",children:"Key Problem-Solving Strategies"}),"\n",(0,t.jsxs)(e.h3,{id:"1-mathematical-insight-recognition",children:["1. ",(0,t.jsx)(e.strong,{children:"Mathematical Insight Recognition"})]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Look for patterns in small cases"}),"\n",(0,t.jsx)(e.li,{children:"Consider mathematical properties (parity, divisibility, modular arithmetic)"}),"\n",(0,t.jsx)(e.li,{children:"Transform the problem into a known mathematical form"}),"\n"]}),"\n",(0,t.jsxs)(e.h3,{id:"2-optimization-techniques",children:["2. ",(0,t.jsx)(e.strong,{children:"Optimization Techniques"})]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Use precomputation when possible (factorials, primes, etc.)"}),"\n",(0,t.jsx)(e.li,{children:"Apply mathematical shortcuts and identities"}),"\n",(0,t.jsx)(e.li,{children:"Consider approximations for very large numbers"}),"\n"]}),"\n",(0,t.jsxs)(e.h3,{id:"3-common-pitfalls-to-avoid",children:["3. ",(0,t.jsx)(e.strong,{children:"Common Pitfalls to Avoid"})]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Integer overflow (use modular arithmetic)"}),"\n",(0,t.jsx)(e.li,{children:"Floating point precision errors"}),"\n",(0,t.jsx)(e.li,{children:"Off-by-one errors in combinatorial formulas"}),"\n",(0,t.jsx)(e.li,{children:"Not handling edge cases (n=0, n=1)"}),"\n"]}),"\n",(0,t.jsxs)(e.h3,{id:"4-contest-specific-tips",children:["4. ",(0,t.jsx)(e.strong,{children:"Contest-Specific Tips"})]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Memorize common formulas and constants"}),"\n",(0,t.jsx)(e.li,{children:"Practice mental math for quick calculations"}),"\n",(0,t.jsx)(e.li,{children:"Use mathematical properties to simplify problems"}),"\n",(0,t.jsx)(e.li,{children:"Always check if the answer fits in the required data type"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"This comprehensive guide covers the essential mathematical techniques and patterns you'll encounter in competitive programming and technical interviews. Master these concepts to solve complex problems efficiently!"}),"\n",(0,t.jsx)(e.hr,{})]})}function m(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(u,{...n})}):u(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>s,x:()=>o});var t=i(6540);const r={},a=t.createContext(r);function s(n){const e=t.useContext(a);return t.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:s(n.components),t.createElement(a.Provider,{value:e},n.children)}}}]);