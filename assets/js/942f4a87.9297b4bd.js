"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[1210],{5904:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>l,contentTitle:()=>a,default:()=>c,frontMatter:()=>t,metadata:()=>s,toc:()=>d});var o=r(4848),i=r(8453);const t={},a="Combinations and Modular Inverse",s={id:"DSA/DSA with JavaScript/Combinatrix",title:"Combinations and Modular Inverse",description:"1. Combinations",source:"@site/docs/DSA/DSA with JavaScript/Combinatrix.mdx",sourceDirName:"DSA/DSA with JavaScript",slug:"/DSA/DSA with JavaScript/Combinatrix",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/Combinatrix",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with JavaScript/Combinatrix.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Circular Buffer",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/CircularBuffer"},next:{title:"Graham's Scan Algorithm & Convex Hull",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/ConvexHull"}},l={},d=[{value:"1. Combinations",id:"1-combinations",level:2},{value:"2. Modular Inverse:",id:"2-modular-inverse",level:2},{value:"For Big Numbers",id:"for-big-numbers",level:2}];function m(n){const e={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"combinations-and-modular-inverse",children:"Combinations and Modular Inverse"})}),"\n",(0,o.jsx)(e.h2,{id:"1-combinations",children:"1. Combinations"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Purpose:"})," Calculates the number of ways to choose r items from n items, where order doesn't matter"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Example:"})," If you have 5 colors and want to pick 2, ",(0,o.jsx)(e.code,{children:"nCr(5,2)"})," tells you how many different color pairs are possible"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Formula:"})," ",(0,o.jsx)(e.code,{children:"C(n,r) = n!/(r! * (n-r)!)"})]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"2-modular-inverse",children:"2. Modular Inverse:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Purpose:"})," Used when we need to perform division in modular arithmetic"]}),"\n",(0,o.jsx)(e.li,{children:"When we calculate large combinations, we often need to take modulo to prevent overflow"}),"\n",(0,o.jsx)(e.li,{children:"Division in modular arithmetic isn't straightforward, so we use modular multiplicative inverse"}),"\n",(0,o.jsxs)(e.li,{children:["For ",(0,o.jsx)(e.code,{children:"(a/b) % m"}),", we calculate ",(0,o.jsx)(e.code,{children:"(a * modInverse(b,m)) % m"})]}),"\n"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-JavaScript",children:"// Calculate combinations C(n,r) using modular arithmetic\nfunction modInverse(a, m) {\n  // Extended Euclidean Algorithm to find modular multiplicative inverse\n  let m0 = m;\n  let x0 = 0;\n  let x1 = 1;\n\n  if (m === 1) return 0;\n\n  while (a > 1) {\n    const q = Math.floor(a / m);\n    let t = m;\n\n    m = a % m;\n    a = t;\n    t = x0;\n\n    x0 = x1 - q * x0;\n    x1 = t;\n  }\n\n  return x1 < 0 ? x1 + m0 : x1;\n}\n\nfunction nCr(n, r, mod = 1e9 + 7) {\n  if (r > n) return 0;\n  if (r === 0 || r === n) return 1;\n\n  // Calculate using formula: C(n,r) = n!/(r! * (n-r)!)\n  let numerator = 1;\n  let denominator = 1;\n\n  for (let i = 0; i < r; i++) {\n    numerator = (numerator * (n - i)) % mod;\n    denominator = (denominator * (i + 1)) % mod;\n  }\n\n  // Use modular inverse for division\n  return (numerator * modInverse(denominator, mod)) % mod;\n}\n\n// Example usage\nconsole.log(nCr(5, 2));  // Calculates 5C2 = 10\nconsole.log(nCr(10, 3)); // Calculates 10C3 = 120\n"})}),"\n",(0,o.jsx)(e.h2,{id:"for-big-numbers",children:"For Big Numbers"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-JavaScript",children:"const kMod = BigInt(1e9 + 7); // Modulo 10^9+7\n\n// Modular exponentiation\nconst modPow = (base, exp, mod) => {\n  let result = BigInt(1);\n  while (exp > 0) {\n    if (exp % BigInt(2) === BigInt(1)) result = (result * base) % mod;\n    base = (base * base) % mod;\n    exp >>= BigInt(1); // Bitwise shift for efficiency\n  }\n  return result;\n};\n\n// Compute (nCr) % mod using modular inverse\nconst comb = (n, r, mod = kMod) => {\n  if (r > n) return BigInt(0);\n\n  let numerator = BigInt(1), denominator = BigInt(1);\n  for (let i = BigInt(0); i < r; i++) {\n    numerator = (numerator * (n - i)) % mod;\n    denominator = (denominator * (i + BigInt(1))) % mod;\n  }\n\n  // Compute modular inverse of denominator using Fermat\u2019s theorem\n  return (numerator * modPow(denominator, mod - BigInt(2), mod)) % mod;\n};\n\n// Example usage\nconsole.log(comb(BigInt(5), BigInt(2)));  // 10\nconsole.log(comb(BigInt(10), BigInt(3))); // 120\nconsole.log(comb(BigInt(1000), BigInt(500))); // Large nCr % 10^9+7\n/* \n10n\n120n\n159835829n\n*/\n"})})]})}function c(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(m,{...n})}):m(n)}},8453:(n,e,r)=>{r.d(e,{R:()=>a,x:()=>s});var o=r(6540);const i={},t=o.createContext(i);function a(n){const e=o.useContext(t);return o.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:a(n.components),o.createElement(t.Provider,{value:e},n.children)}}}]);