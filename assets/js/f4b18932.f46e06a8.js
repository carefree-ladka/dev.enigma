"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[3480],{23091:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>o,toc:()=>h});var n=i(74848),r=i(28453);const s={title:"Floyd-Warshall Algorithm"},a=void 0,o={id:"DSA/DSA with JavaScript/Floyd-Warshall",title:"Floyd-Warshall Algorithm",description:"Floyd-Warshall algorithm is a classic algorithm for finding the shortest paths in a weighted graph with positive or negative edge weights (but no negative cycles). It can be used to find the shortest paths between all pairs of vertices in a graph.",source:"@site/docs/DSA/DSA with JavaScript/Floyd-Warshall.mdx",sourceDirName:"DSA/DSA with JavaScript",slug:"/DSA/DSA with JavaScript/Floyd-Warshall",permalink:"/dev.enigma/docs/DSA/DSA with JavaScript/Floyd-Warshall",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with JavaScript/Floyd-Warshall.mdx",tags:[],version:"current",frontMatter:{title:"Floyd-Warshall Algorithm"},sidebar:"tutorialSidebar",previous:{title:"Flood Fill Algorithm",permalink:"/dev.enigma/docs/DSA/DSA with JavaScript/FloodFill"},next:{title:"Floyd's Cycle Detection Algorithm",permalink:"/dev.enigma/docs/DSA/DSA with JavaScript/FlyodsCycleDetection"}},l={},h=[{value:"Algorithm Overview",id:"algorithm-overview",level:3},{value:"Steps of the Algorithm",id:"steps-of-the-algorithm",level:3}];function c(e){const t={code:"code",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.p,{children:"Floyd-Warshall algorithm is a classic algorithm for finding the shortest paths in a weighted graph with positive or negative edge weights (but no negative cycles). It can be used to find the shortest paths between all pairs of vertices in a graph."}),"\n",(0,n.jsx)(t.h3,{id:"algorithm-overview",children:"Algorithm Overview"}),"\n",(0,n.jsx)(t.p,{children:"The algorithm works by considering all pairs of vertices and systematically trying all possible paths between each pair to find the shortest path. It does this using dynamic programming."}),"\n",(0,n.jsx)(t.h3,{id:"steps-of-the-algorithm",children:"Steps of the Algorithm"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:["Initialization: Create a distance matrix dist, where dist[i][j] represents the shortest distance from vertex i to vertex j. Initialize this matrix as follows:","\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["Set ",(0,n.jsx)(t.code,{children:"dist[i][j] = 0"})," if ",(0,n.jsx)(t.code,{children:"i == j"})]}),"\n",(0,n.jsxs)(t.li,{children:["Set ",(0,n.jsx)(t.code,{children:"dist[i][j] = weight of edge (i, j)"})," if there is an edge from ",(0,n.jsx)(t.code,{children:"i"})," to ",(0,n.jsx)(t.code,{children:"j"}),"."]}),"\n",(0,n.jsxs)(t.li,{children:["Set ",(0,n.jsx)(t.code,{children:"dist[i][j] = \u221e (infinity)"})," if there is no edge from ",(0,n.jsx)(t.code,{children:"i"})," to ",(0,n.jsx)(t.code,{children:"j"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-JavaScript",children:"/**\n * Floyd-Warshall Algorithm to find the shortest paths between all pairs of nodes.\n * @param {number[][]} graph - Adjacency matrix representing the graph.\n * @return {number[][]} - Distance matrix with the shortest paths.\n */\nfunction floydWarshall(graph) {\n  const V = graph.length;\n  const distance = Array.from({ length: V }, (_, i) => Array.from(graph[i]));\n\n  // Initialize distances based on input graph\n  for (let k = 0; k < V; k++) {\n    for (let i = 0; i < V; i++) {\n      for (let j = 0; j < V; j++) {\n        if (distance[i][k] !== Infinity && distance[k][j] !== Infinity) {\n          distance[i][j] = Math.min(distance[i][j], distance[i][k] + distance[k][j]);\n        }\n      }\n    }\n  }\n\n  return distance;\n}\n\n// Example usage:\nconst graph = [\n  [0, 3, Infinity, Infinity],\n  [2, 0, Infinity, 1],\n  [Infinity, 7, 0, 2],\n  [6, Infinity, 3, 0]\n];\n\nconst shortestPaths = floydWarshall(graph);\nconsole.log(shortestPaths); //[ [ 0, 3, 7, 4 ], [ 2, 0, 4, 1 ], [ 8, 7, 0, 2 ], [ 6, 9, 3, 0 ] ]\n\n/*\nTime Complexity: O(V^3)\nSpace Complexity: O(V^2)\n*/\n"})})]})}function d(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},28453:(e,t,i)=>{i.d(t,{R:()=>a,x:()=>o});var n=i(96540);const r={},s=n.createContext(r);function a(e){const t=n.useContext(s);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);