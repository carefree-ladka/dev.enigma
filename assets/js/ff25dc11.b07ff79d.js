"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[5173],{7546:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>a,contentTitle:()=>o,default:()=>g,frontMatter:()=>i,metadata:()=>l,toc:()=>d});var n=t(4848),s=t(8453);t(1432);const i={title:"Merge Sort",description:"A comprehensive guide to understanding and implementing Merge Sort."},o="Merge Sort",l={id:"DSA/MergeSort",title:"Merge Sort",description:"A comprehensive guide to understanding and implementing Merge Sort.",source:"@site/docs/DSA/MergeSort.mdx",sourceDirName:"DSA",slug:"/DSA/MergeSort",permalink:"/js.enigma/docs/DSA/MergeSort",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/MergeSort.mdx",tags:[],version:"current",frontMatter:{title:"Merge Sort",description:"A comprehensive guide to understanding and implementing Merge Sort."},sidebar:"tutorialSidebar",previous:{title:"Median of Two Sorted Arrays",permalink:"/js.enigma/docs/DSA/MedianOfTwoSortedArrays"},next:{title:"Morris Traversal for Binary Trees",permalink:"/js.enigma/docs/DSA/MorrisTraversal"}},a={},d=[{value:"How Merge Sort Works",id:"how-merge-sort-works",level:2},{value:"Algorithm Steps",id:"algorithm-steps",level:3},{value:"Pseudocode",id:"pseudocode",level:3}];function h(e){const r={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(r.header,{children:(0,n.jsx)(r.h1,{id:"merge-sort",children:"Merge Sort"})}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.strong,{children:"Merge Sort"})," is a classic sorting algorithm that follows the divide-and-conquer strategy. It divides the input array into smaller sub-arrays, recursively sorts those sub-arrays, and then merges them back together to produce a sorted array. Merge Sort is known for its stability and predictable ",(0,n.jsx)(r.code,{children:"O(n log n)"})," time complexity."]}),"\n",(0,n.jsx)(r.h2,{id:"how-merge-sort-works",children:"How Merge Sort Works"}),"\n",(0,n.jsxs)(r.p,{children:["Merge Sort is a comparison-based sorting algorithm with a time complexity of ",(0,n.jsx)(r.code,{children:"O(n log n)"}),". It is particularly useful for large datasets and is a stable sorting algorithm, meaning it maintains the relative order of equal elements."]}),"\n",(0,n.jsx)(r.h3,{id:"algorithm-steps",children:"Algorithm Steps"}),"\n",(0,n.jsxs)(r.ol,{children:["\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.strong,{children:"Divide:"})," Split the array into two halves."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.strong,{children:"Conquer:"})," Recursively sort each half."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.strong,{children:"Merge:"})," Combine the sorted halves to produce the final sorted array."]}),"\n"]}),"\n",(0,n.jsx)(r.h3,{id:"pseudocode",children:"Pseudocode"}),"\n",(0,n.jsx)(r.p,{children:"Here\u2019s the pseudocode for Merge Sort:"}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-JavaScript",children:"function mergeSort(arr) {\n    if (arr.length <= 1) {\n        return arr;\n    }\n\n    const middle = Math.floor(arr.length / 2);\n    const left = arr.slice(0, middle);\n    const right = arr.slice(middle);\n\n    return merge(mergeSort(left), mergeSort(right));\n}\n\nfunction merge(left, right) {\n    let result = [];\n    let leftIndex = 0;\n    let rightIndex = 0;\n\n    // Merge the two sorted arrays into one\n    while (leftIndex < left.length && rightIndex < right.length) {\n        if (left[leftIndex] < right[rightIndex]) {\n            result.push(left[leftIndex]);\n            leftIndex++;\n        } else {\n            result.push(right[rightIndex]);\n            rightIndex++;\n        }\n    }\n\n    // If there are remaining elements in the left array\n    while (leftIndex < left.length) {\n        result.push(left[leftIndex]);\n        leftIndex++;\n    }\n\n    // If there are remaining elements in the right array\n    while (rightIndex < right.length) {\n        result.push(right[rightIndex]);\n        rightIndex++;\n    }\n\n    return result;\n}\n\n// Example usage\nconst array = [3, 6, 8, 10, 1, 2, 1];\nconst sortedArray = mergeSort(array);\nconsole.log(sortedArray);  // Output: [1, 1, 2, 3, 6, 8, 10]\n"})})]})}function g(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}}}]);