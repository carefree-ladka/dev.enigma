"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[721],{28453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>l});var t=i(96540);const a={},r=t.createContext(a);function o(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),t.createElement(r.Provider,{value:n},e.children)}},88696:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var t=i(74848),a=i(28453);const r={},o="Notification System Design",l={id:"Low Level design/Notification System Design",title:"Notification System Design",description:"Table of Contents",source:"@site/docs/Low Level design/Notification System Design.mdx",sourceDirName:"Low Level design",slug:"/Low Level design/Notification System Design",permalink:"/js.enigma/docs/Low Level design/Notification System Design",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/Low Level design/Notification System Design.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Low Level Design (LLD)",permalink:"/js.enigma/docs/Low Level design/"},next:{title:"Parking Lot System",permalink:"/js.enigma/docs/Low Level design/Parking Lot System"}},s={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Overview",id:"overview",level:2},{value:"Key Characteristics",id:"key-characteristics",level:3},{value:"Requirements Analysis",id:"requirements-analysis",level:2},{value:"Functional Requirements",id:"functional-requirements",level:3},{value:"Core Features",id:"core-features",level:4},{value:"Notification Types",id:"notification-types",level:4},{value:"Non-Functional Requirements",id:"non-functional-requirements",level:3},{value:"Constraints",id:"constraints",level:3},{value:"System Architecture",id:"system-architecture",level:2},{value:"High-Level Architecture",id:"high-level-architecture",level:3},{value:"Component Layers",id:"component-layers",level:3},{value:"Core Components",id:"core-components",level:2},{value:"1. Notification Service",id:"1-notification-service",level:3},{value:"2. Channel Interface",id:"2-channel-interface",level:3},{value:"3. Template Engine",id:"3-template-engine",level:3},{value:"4. User Preference Manager",id:"4-user-preference-manager",level:3},{value:"5. Queue Manager",id:"5-queue-manager",level:3},{value:"6. Retry Handler",id:"6-retry-handler",level:3},{value:"Class Design",id:"class-design",level:2},{value:"Core Classes",id:"core-classes",level:3},{value:"NotificationService (Facade)",id:"notificationservice-facade",level:4},{value:"Notification (Entity)",id:"notification-entity",level:4},{value:"NotificationChannel (Interface)",id:"notificationchannel-interface",level:4},{value:"NotificationTemplate",id:"notificationtemplate",level:4},{value:"UserPreference",id:"userpreference",level:4},{value:"NotificationQueue",id:"notificationqueue",level:4},{value:"NotificationStatus (Enum)",id:"notificationstatus-enum",level:4},{value:"NotificationPriority (Enum)",id:"notificationpriority-enum",level:4},{value:"UML Class Diagram",id:"uml-class-diagram",level:2},{value:"Implementation",id:"implementation",level:2},{value:"Enums",id:"enums",level:3},{value:"NotificationStatus.java",id:"notificationstatusjava",level:4},{value:"NotificationType.java",id:"notificationtypejava",level:4},{value:"NotificationPriority.java",id:"notificationpriorityjava",level:4},{value:"ChannelType.java",id:"channeltypejava",level:4},{value:"DeliveryStatus.java",id:"deliverystatusjava",level:4},{value:"Core Domain Classes",id:"core-domain-classes",level:3},{value:"Notification.java",id:"notificationjava",level:4},{value:"DeliveryResult.java",id:"deliveryresultjava",level:4},{value:"Channel Interface and Implementations",id:"channel-interface-and-implementations",level:3},{value:"NotificationChannel.java",id:"notificationchanneljava",level:4},{value:"EmailChannel.java",id:"emailchanneljava",level:4},{value:"SMSChannel.java",id:"smschanneljava",level:4},{value:"PushChannel.java",id:"pushchanneljava",level:4},{value:"InAppChannel.java",id:"inappchanneljava",level:4},{value:"WebhookChannel.java",id:"webhookchanneljava",level:4},{value:"Template Management",id:"template-management",level:3},{value:"NotificationTemplate.java",id:"notificationtemplatejava",level:4},{value:"TemplateEngine.java",id:"templateenginejava",level:4},{value:"User Preference Management",id:"user-preference-management",level:3},{value:"UserPreference.java",id:"userpreferencejava",level:4},{value:"TimeRange.java",id:"timerangejava",level:4},{value:"PreferenceManager.java",id:"preferencemanagerjava",level:4},{value:"Queue Management",id:"queue-management",level:3},{value:"NotificationQueue.java",id:"notificationqueuejava",level:4},{value:"Retry Handler",id:"retry-handler",level:3},{value:"RetryHandler.java",id:"retryhandlerjava",level:4},{value:"RetryContext.java",id:"retrycontextjava",level:4},{value:"Rate Limiter",id:"rate-limiter",level:3},{value:"RateLimiter.java",id:"ratelimiterjava",level:4},{value:"TokenBucket.java",id:"tokenbucketjava",level:4},{value:"Notification Service (Main Orchestrator)",id:"notification-service-main-orchestrator",level:3},{value:"NotificationService.java",id:"notificationservicejava",level:4},{value:"Logging and Monitoring",id:"logging-and-monitoring",level:3},{value:"NotificationLogger.java",id:"notificationloggerjava",level:4},{value:"NotificationLog.java",id:"notificationlogjava",level:4},{value:"Design Patterns",id:"design-patterns",level:2},{value:"1. <strong>Singleton Pattern</strong>",id:"1-singleton-pattern",level:3},{value:"2. <strong>Strategy Pattern</strong>",id:"2-strategy-pattern",level:3},{value:"3. <strong>Template Method Pattern</strong>",id:"3-template-method-pattern",level:3},{value:"4. <strong>Observer Pattern</strong> (Implicit)",id:"4-observer-pattern-implicit",level:3},{value:"5. <strong>Factory Pattern</strong> (Can Be Extended)",id:"5-factory-pattern-can-be-extended",level:3},{value:"6. <strong>Builder Pattern</strong> (Can Be Extended)",id:"6-builder-pattern-can-be-extended",level:3},{value:"7. <strong>Chain of Responsibility</strong> (Can Be Extended)",id:"7-chain-of-responsibility-can-be-extended",level:3},{value:"Testing &amp; Demo",id:"testing--demo",level:2},{value:"NotificationSystemDemo.java",id:"notificationsystemdemojava",level:3},{value:"Scalability Considerations",id:"scalability-considerations",level:2},{value:"Current Implementation Limitations",id:"current-implementation-limitations",level:3},{value:"Production-Ready Enhancements",id:"production-ready-enhancements",level:3},{value:"1. Database Integration",id:"1-database-integration",level:4},{value:"2. Message Queue Integration",id:"2-message-queue-integration",level:4},{value:"3. Distributed Processing",id:"3-distributed-processing",level:4},{value:"4. Caching Strategy",id:"4-caching-strategy",level:4},{value:"5. Monitoring &amp; Observability",id:"5-monitoring--observability",level:4},{value:"6. Circuit Breaker Pattern",id:"6-circuit-breaker-pattern",level:4},{value:"Advanced Features",id:"advanced-features",level:2},{value:"1. Batch Notifications",id:"1-batch-notifications",level:3},{value:"2. A/B Testing Support",id:"2-ab-testing-support",level:3},{value:"3. Localization Support",id:"3-localization-support",level:3},{value:"4. Webhook Signature Verification",id:"4-webhook-signature-verification",level:3},{value:"5. Analytics &amp; Reporting",id:"5-analytics--reporting",level:3},{value:"6. Idempotency Support",id:"6-idempotency-support",level:3},{value:"Summary",id:"summary",level:2},{value:"\u2705 <strong>Core Features</strong>",id:"-core-features",level:3},{value:"\u2705 <strong>Design Principles</strong>",id:"-design-principles",level:3},{value:"\u2705 <strong>Production Considerations</strong>",id:"-production-considerations",level:3},{value:"\ud83d\ude80 <strong>Future Enhancements</strong>",id:"-future-enhancements",level:3}];function u(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"notification-system-design",children:"Notification System Design"})}),"\n",(0,t.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#overview",children:"Overview"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#requirements-analysis",children:"Requirements Analysis"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#system-architecture",children:"System Architecture"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#core-components",children:"Core Components"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#class-design",children:"Class Design"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#uml-class-diagram",children:"UML Class Diagram"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#implementation",children:"Implementation"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#design-patterns",children:"Design Patterns"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#scalability-considerations",children:"Scalability Considerations"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#advanced-features",children:"Advanced Features"})}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(n.p,{children:"A general-purpose Notification System is a critical infrastructure component that enables applications to communicate with users through multiple channels (email, SMS, push notifications, in-app messages, etc.). This system must be scalable, reliable, and extensible to support various notification types and delivery mechanisms."}),"\n",(0,t.jsx)(n.h3,{id:"key-characteristics",children:"Key Characteristics"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Multi-Channel Support"}),": Email, SMS, Push, In-App, Webhook"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Priority-Based Delivery"}),": Critical, High, Medium, Low priority levels"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Template Management"}),": Reusable notification templates"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"User Preferences"}),": Per-user channel and frequency settings"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Retry Mechanism"}),": Automatic retry for failed deliveries"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Rate Limiting"}),": Prevent notification spam"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Analytics"}),": Track delivery status and engagement metrics"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"requirements-analysis",children:"Requirements Analysis"}),"\n",(0,t.jsx)(n.h3,{id:"functional-requirements",children:"Functional Requirements"}),"\n",(0,t.jsx)(n.h4,{id:"core-features",children:"Core Features"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Send Notifications"}),": Support multiple channels simultaneously"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Template Management"}),": Create, update, delete notification templates"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"User Preferences"}),": Manage user notification settings per channel"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Scheduling"}),": Send notifications immediately or schedule for later"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Batching"}),": Group similar notifications for efficient delivery"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Status Tracking"}),": Monitor delivery status (sent, delivered, failed, read)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Retry Logic"}),": Automatic retry with exponential backoff"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Priority Handling"}),": Process high-priority notifications first"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"notification-types",children:"Notification Types"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Transactional"}),": Account verification, password reset, receipts"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Marketing"}),": Promotional campaigns, newsletters"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Alert"}),": System alerts, security warnings"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Reminder"}),": Upcoming events, deadlines"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Social"}),": Comments, likes, mentions"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"System"}),": Service updates, maintenance notices"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"non-functional-requirements",children:"Non-Functional Requirements"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Scalability"}),": Handle millions of notifications per day"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Reliability"}),": 99.9% delivery success rate"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Performance"}),": ",(0,t.jsx)(n.code,{children:"<100ms"})," notification processing time"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Availability"}),": 99.99% uptime"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Idempotency"}),": Prevent duplicate notifications"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Compliance"}),": GDPR, CAN-SPAM, TCPA compliance"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"constraints",children:"Constraints"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Rate Limits"}),": Respect third-party API limits (Twilio, SendGrid)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Cost Optimization"}),": Minimize delivery costs"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Delivery Windows"}),": Respect user timezone and quiet hours"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Message Size"}),": Channel-specific size limitations"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"system-architecture",children:"System Architecture"}),"\n",(0,t.jsx)(n.h3,{id:"high-level-architecture",children:"High-Level Architecture"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Application \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502\n       \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Notification Service API      \u2502\n\u2502  - Send Notification            \u2502\n\u2502  - Schedule Notification        \u2502\n\u2502  - Get Status                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502\n       \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Notification Manager          \u2502\n\u2502  - Validation                   \u2502\n\u2502  - Template Processing          \u2502\n\u2502  - Priority Queue               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502\n       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n       \u25bc             \u25bc              \u25bc              \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Email   \u2502  \u2502   SMS    \u2502  \u2502   Push   \u2502  \u2502  In-App  \u2502\n\u2502 Channel  \u2502  \u2502 Channel  \u2502  \u2502 Channel  \u2502  \u2502 Channel  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502             \u2502              \u2502              \u2502\n       \u25bc             \u25bc              \u25bc              \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502SendGrid  \u2502  \u2502  Twilio  \u2502  \u2502 Firebase \u2502  \u2502 Database \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,t.jsx)(n.h3,{id:"component-layers",children:"Component Layers"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"API Layer"}),": REST/GraphQL endpoints for notification requests"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Business Logic Layer"}),": Validation, template processing, routing"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Channel Layer"}),": Channel-specific implementations"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Persistence Layer"}),": Store notifications, templates, preferences"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Queue Layer"}),": Message queue for async processing (Kafka, RabbitMQ)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Monitoring Layer"}),": Metrics, logging, alerting"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"core-components",children:"Core Components"}),"\n",(0,t.jsx)(n.h3,{id:"1-notification-service",children:"1. Notification Service"}),"\n",(0,t.jsx)(n.p,{children:"Central orchestrator that receives notification requests and coordinates delivery."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Responsibilities"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Accept notification requests"}),"\n",(0,t.jsx)(n.li,{children:"Validate input"}),"\n",(0,t.jsx)(n.li,{children:"Apply user preferences"}),"\n",(0,t.jsx)(n.li,{children:"Route to appropriate channels"}),"\n",(0,t.jsx)(n.li,{children:"Track delivery status"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"2-channel-interface",children:"2. Channel Interface"}),"\n",(0,t.jsx)(n.p,{children:"Abstract interface defining common operations for all notification channels."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Responsibilities"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Send notification"}),"\n",(0,t.jsx)(n.li,{children:"Validate channel-specific requirements"}),"\n",(0,t.jsx)(n.li,{children:"Handle delivery failures"}),"\n",(0,t.jsx)(n.li,{children:"Report delivery status"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"3-template-engine",children:"3. Template Engine"}),"\n",(0,t.jsx)(n.p,{children:"Manages notification templates with variable substitution."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Responsibilities"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Store templates"}),"\n",(0,t.jsx)(n.li,{children:"Render templates with dynamic data"}),"\n",(0,t.jsx)(n.li,{children:"Support multiple languages"}),"\n",(0,t.jsx)(n.li,{children:"Version control for templates"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"4-user-preference-manager",children:"4. User Preference Manager"}),"\n",(0,t.jsx)(n.p,{children:"Manages user notification preferences."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Responsibilities"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Store user preferences"}),"\n",(0,t.jsx)(n.li,{children:"Determine allowed channels"}),"\n",(0,t.jsx)(n.li,{children:"Respect quiet hours"}),"\n",(0,t.jsx)(n.li,{children:"Manage opt-outs"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"5-queue-manager",children:"5. Queue Manager"}),"\n",(0,t.jsx)(n.p,{children:"Handles asynchronous notification processing."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Responsibilities"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Priority-based queuing"}),"\n",(0,t.jsx)(n.li,{children:"Load balancing"}),"\n",(0,t.jsx)(n.li,{children:"Dead letter queue handling"}),"\n",(0,t.jsx)(n.li,{children:"Rate limiting"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"6-retry-handler",children:"6. Retry Handler"}),"\n",(0,t.jsx)(n.p,{children:"Manages failed notification retries."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Responsibilities"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Exponential backoff"}),"\n",(0,t.jsx)(n.li,{children:"Maximum retry attempts"}),"\n",(0,t.jsx)(n.li,{children:"Failure notifications"}),"\n",(0,t.jsx)(n.li,{children:"Circuit breaker pattern"}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"class-design",children:"Class Design"}),"\n",(0,t.jsx)(n.h3,{id:"core-classes",children:"Core Classes"}),"\n",(0,t.jsx)(n.h4,{id:"notificationservice-facade",children:"NotificationService (Facade)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Central entry point for notification operations"}),"\n",(0,t.jsx)(n.li,{children:"Coordinates between all components"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"notification-entity",children:"Notification (Entity)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Represents a notification instance"}),"\n",(0,t.jsx)(n.li,{children:"Contains recipient, content, metadata"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"notificationchannel-interface",children:"NotificationChannel (Interface)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Defines contract for all channels"}),"\n",(0,t.jsx)(n.li,{children:"Implemented by EmailChannel, SMSChannel, etc."}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"notificationtemplate",children:"NotificationTemplate"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Stores reusable templates"}),"\n",(0,t.jsx)(n.li,{children:"Supports variable substitution"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"userpreference",children:"UserPreference"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Stores user notification settings"}),"\n",(0,t.jsx)(n.li,{children:"Channel-specific preferences"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"notificationqueue",children:"NotificationQueue"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Priority queue implementation"}),"\n",(0,t.jsx)(n.li,{children:"Handles async processing"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"notificationstatus-enum",children:"NotificationStatus (Enum)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"PENDING, QUEUED, SENT, DELIVERED, FAILED, CANCELLED"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"notificationpriority-enum",children:"NotificationPriority (Enum)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"CRITICAL, HIGH, MEDIUM, LOW"}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"uml-class-diagram",children:"UML Class Diagram"}),"\n",(0,t.jsx)(n.mermaid,{value:"classDiagram\n    class NotificationService {\n        -NotificationQueue queue\n        -TemplateEngine templateEngine\n        -PreferenceManager preferenceManager\n        -Map~String, NotificationChannel~ channels\n        +sendNotification(Notification) String\n        +scheduleNotification(Notification, Date) String\n        +getNotificationStatus(String id) NotificationStatus\n        +cancelNotification(String id) boolean\n    }\n\n    class Notification {\n        -String id\n        -String recipientId\n        -NotificationType type\n        -NotificationPriority priority\n        -String subject\n        -String content\n        -Map~String, Object~ data\n        -List~ChannelType~ channels\n        -Date createdAt\n        -Date scheduledAt\n        -NotificationStatus status\n        +getId() String\n        +validate() boolean\n        +isExpired() boolean\n    }\n\n    class NotificationChannel {\n        <<interface>>\n        +send(Notification) DeliveryResult\n        +validateConfig() boolean\n        +getChannelType() ChannelType\n        +isAvailable() boolean\n    }\n\n    class EmailChannel {\n        -String smtpHost\n        -int smtpPort\n        -String apiKey\n        +send(Notification) DeliveryResult\n        +sendBatch(List~Notification~) List~DeliveryResult~\n        -formatEmailContent(Notification) EmailMessage\n    }\n\n    class SMSChannel {\n        -String apiKey\n        -String phoneNumber\n        -int maxLength\n        +send(Notification) DeliveryResult\n        -validatePhoneNumber(String) boolean\n        -truncateMessage(String) String\n    }\n\n    class PushChannel {\n        -String serverKey\n        -String appId\n        +send(Notification) DeliveryResult\n        +sendToTopic(String topic, Notification) DeliveryResult\n        -buildPushPayload(Notification) PushPayload\n    }\n\n    class InAppChannel {\n        -NotificationRepository repository\n        +send(Notification) DeliveryResult\n        +markAsRead(String notificationId) boolean\n        +getUnreadCount(String userId) int\n    }\n\n    class WebhookChannel {\n        -String webhookUrl\n        -Map~String, String~ headers\n        +send(Notification) DeliveryResult\n        -signPayload(String) String\n    }\n\n    class TemplateEngine {\n        -Map~String, NotificationTemplate~ templates\n        +registerTemplate(NotificationTemplate) void\n        +renderTemplate(String templateId, Map~String, Object~) String\n        +validateTemplate(String template) boolean\n        +getTemplate(String id) NotificationTemplate\n    }\n\n    class NotificationTemplate {\n        -String id\n        -String name\n        -ChannelType channelType\n        -String subject\n        -String body\n        -String language\n        -int version\n        +render(Map~String, Object~) String\n        +clone() NotificationTemplate\n    }\n\n    class PreferenceManager {\n        -Map~String, UserPreference~ preferences\n        +getUserPreference(String userId) UserPreference\n        +updatePreference(String userId, UserPreference) void\n        +isChannelEnabled(String userId, ChannelType) boolean\n        +isQuietHours(String userId) boolean\n    }\n\n    class UserPreference {\n        -String userId\n        -Map~ChannelType, Boolean~ enabledChannels\n        -Map~NotificationType, Boolean~ enabledTypes\n        -TimeRange quietHours\n        -String timezone\n        -String language\n        +isChannelEnabled(ChannelType) boolean\n        +canReceiveAt(Date time) boolean\n    }\n\n    class NotificationQueue {\n        -PriorityQueue~Notification~ highPriority\n        -PriorityQueue~Notification~ normalPriority\n        -ExecutorService executor\n        +enqueue(Notification) void\n        +dequeue() Notification\n        +process() void\n        +getQueueSize() int\n    }\n\n    class DeliveryResult {\n        -String notificationId\n        -ChannelType channel\n        -DeliveryStatus status\n        -String messageId\n        -Date deliveredAt\n        -String errorMessage\n        -int retryCount\n        +isSuccess() boolean\n        +shouldRetry() boolean\n    }\n\n    class RetryHandler {\n        -int maxRetries\n        -long baseDelayMs\n        -Map~String, RetryContext~ retryMap\n        +shouldRetry(DeliveryResult) boolean\n        +scheduleRetry(Notification, DeliveryResult) void\n        +getNextRetryTime(int attempt) Date\n        -calculateBackoff(int attempt) long\n    }\n\n    class NotificationLogger {\n        -LogRepository repository\n        +logSent(Notification, ChannelType) void\n        +logDelivered(String id, ChannelType) void\n        +logFailed(String id, String error) void\n        +getNotificationHistory(String userId) List~NotificationLog~\n    }\n\n    class RateLimiter {\n        -Map~String, TokenBucket~ userBuckets\n        -int maxPerHour\n        -int maxPerDay\n        +allowRequest(String userId, ChannelType) boolean\n        +getRemainingQuota(String userId) int\n        -refillBuckets() void\n    }\n\n    class NotificationStatus {\n        <<enumeration>>\n        PENDING\n        QUEUED\n        PROCESSING\n        SENT\n        DELIVERED\n        FAILED\n        CANCELLED\n        EXPIRED\n    }\n\n    class NotificationType {\n        <<enumeration>>\n        TRANSACTIONAL\n        MARKETING\n        ALERT\n        REMINDER\n        SOCIAL\n        SYSTEM\n    }\n\n    class NotificationPriority {\n        <<enumeration>>\n        CRITICAL\n        HIGH\n        MEDIUM\n        LOW\n    }\n\n    class ChannelType {\n        <<enumeration>>\n        EMAIL\n        SMS\n        PUSH\n        IN_APP\n        WEBHOOK\n    }\n\n    class DeliveryStatus {\n        <<enumeration>>\n        SUCCESS\n        FAILED\n        RETRY\n        SKIPPED\n    }\n\n    NotificationService --\x3e NotificationQueue\n    NotificationService --\x3e TemplateEngine\n    NotificationService --\x3e PreferenceManager\n    NotificationService --\x3e NotificationChannel\n    NotificationService --\x3e RetryHandler\n    NotificationService --\x3e RateLimiter\n\n    NotificationChannel <|.. EmailChannel\n    NotificationChannel <|.. SMSChannel\n    NotificationChannel <|.. PushChannel\n    NotificationChannel <|.. InAppChannel\n    NotificationChannel <|.. WebhookChannel\n\n    Notification --\x3e NotificationStatus\n    Notification --\x3e NotificationType\n    Notification --\x3e NotificationPriority\n    Notification --\x3e ChannelType\n\n    NotificationChannel --\x3e DeliveryResult\n    DeliveryResult --\x3e DeliveryStatus\n\n    TemplateEngine --\x3e NotificationTemplate\n    NotificationTemplate --\x3e ChannelType\n\n    PreferenceManager --\x3e UserPreference\n    UserPreference --\x3e ChannelType\n    UserPreference --\x3e NotificationType\n\n    RetryHandler --\x3e DeliveryResult\n    NotificationLogger --\x3e Notification"}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"implementation",children:"Implementation"}),"\n",(0,t.jsx)(n.h3,{id:"enums",children:"Enums"}),"\n",(0,t.jsx)(n.h4,{id:"notificationstatusjava",children:"NotificationStatus.java"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"public enum NotificationStatus {\n    PENDING,      // Created but not yet queued\n    QUEUED,       // In queue waiting for processing\n    PROCESSING,   // Currently being processed\n    SENT,         // Sent to provider\n    DELIVERED,    // Confirmed delivery\n    FAILED,       // Delivery failed\n    CANCELLED,    // Cancelled before delivery\n    EXPIRED       // Expired before delivery\n}\n"})}),"\n",(0,t.jsx)(n.h4,{id:"notificationtypejava",children:"NotificationType.java"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"public enum NotificationType {\n    TRANSACTIONAL,  // Account-related, high priority\n    MARKETING,      // Promotional content\n    ALERT,          // Important system alerts\n    REMINDER,       // Scheduled reminders\n    SOCIAL,         // User interactions\n    SYSTEM          // System announcements\n}\n"})}),"\n",(0,t.jsx)(n.h4,{id:"notificationpriorityjava",children:"NotificationPriority.java"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"public enum NotificationPriority {\n    CRITICAL(1),   // Must be delivered immediately\n    HIGH(2),       // Should be delivered quickly\n    MEDIUM(3),     // Normal delivery\n    LOW(4);        // Can be delayed\n\n    private final int level;\n\n    NotificationPriority(int level) {\n        this.level = level;\n    }\n\n    public int getLevel() {\n        return level;\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h4,{id:"channeltypejava",children:"ChannelType.java"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"public enum ChannelType {\n    EMAIL,\n    SMS,\n    PUSH,\n    IN_APP,\n    WEBHOOK\n}\n"})}),"\n",(0,t.jsx)(n.h4,{id:"deliverystatusjava",children:"DeliveryStatus.java"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"public enum DeliveryStatus {\n    SUCCESS,   // Successfully delivered\n    FAILED,    // Failed to deliver\n    RETRY,     // Scheduled for retry\n    SKIPPED    // Skipped due to user preferences\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"core-domain-classes",children:"Core Domain Classes"}),"\n",(0,t.jsx)(n.h4,{id:"notificationjava",children:"Notification.java"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"import java.util.*;\n\npublic class Notification {\n    private String id;\n    private String recipientId;\n    private NotificationType type;\n    private NotificationPriority priority;\n    private String subject;\n    private String content;\n    private Map<String, Object> data;\n    private List<ChannelType> channels;\n    private Date createdAt;\n    private Date scheduledAt;\n    private Date expiresAt;\n    private NotificationStatus status;\n    private String templateId;\n\n    public Notification(String recipientId, NotificationType type, NotificationPriority priority) {\n        this.id = UUID.randomUUID().toString();\n        this.recipientId = recipientId;\n        this.type = type;\n        this.priority = priority;\n        this.createdAt = new Date();\n        this.status = NotificationStatus.PENDING;\n        this.data = new HashMap<>();\n        this.channels = new ArrayList<>();\n    }\n\n    public boolean validate() {\n        if (recipientId == null || recipientId.isEmpty()) {\n            return false;\n        }\n        if (channels.isEmpty()) {\n            return false;\n        }\n        if (subject == null && content == null && templateId == null) {\n            return false;\n        }\n        return true;\n    }\n\n    public boolean isExpired() {\n        if (expiresAt == null) {\n            return false;\n        }\n        return new Date().after(expiresAt);\n    }\n\n    public boolean shouldSendNow() {\n        if (scheduledAt == null) {\n            return true;\n        }\n        return new Date().after(scheduledAt);\n    }\n\n    // Getters and Setters\n    public String getId() { return id; }\n    public String getRecipientId() { return recipientId; }\n    public NotificationType getType() { return type; }\n    public NotificationPriority getPriority() { return priority; }\n    public String getSubject() { return subject; }\n    public void setSubject(String subject) { this.subject = subject; }\n    public String getContent() { return content; }\n    public void setContent(String content) { this.content = content; }\n    public Map<String, Object> getData() { return data; }\n    public void setData(Map<String, Object> data) { this.data = data; }\n    public List<ChannelType> getChannels() { return channels; }\n    public void addChannel(ChannelType channel) { this.channels.add(channel); }\n    public NotificationStatus getStatus() { return status; }\n    public void setStatus(NotificationStatus status) { this.status = status; }\n    public Date getScheduledAt() { return scheduledAt; }\n    public void setScheduledAt(Date scheduledAt) { this.scheduledAt = scheduledAt; }\n    public Date getExpiresAt() { return expiresAt; }\n    public void setExpiresAt(Date expiresAt) { this.expiresAt = expiresAt; }\n    public String getTemplateId() { return templateId; }\n    public void setTemplateId(String templateId) { this.templateId = templateId; }\n}\n"})}),"\n",(0,t.jsx)(n.h4,{id:"deliveryresultjava",children:"DeliveryResult.java"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"import java.util.Date;\n\npublic class DeliveryResult {\n    private String notificationId;\n    private ChannelType channel;\n    private DeliveryStatus status;\n    private String messageId;\n    private Date deliveredAt;\n    private String errorMessage;\n    private int retryCount;\n    private Map<String, String> metadata;\n\n    public DeliveryResult(String notificationId, ChannelType channel) {\n        this.notificationId = notificationId;\n        this.channel = channel;\n        this.retryCount = 0;\n        this.metadata = new HashMap<>();\n    }\n\n    public boolean isSuccess() {\n        return status == DeliveryStatus.SUCCESS;\n    }\n\n    public boolean shouldRetry() {\n        return status == DeliveryStatus.FAILED && retryCount < 3;\n    }\n\n    public void markSuccess(String messageId) {\n        this.status = DeliveryStatus.SUCCESS;\n        this.messageId = messageId;\n        this.deliveredAt = new Date();\n    }\n\n    public void markFailed(String errorMessage) {\n        this.status = DeliveryStatus.FAILED;\n        this.errorMessage = errorMessage;\n    }\n\n    // Getters and Setters\n    public String getNotificationId() { return notificationId; }\n    public ChannelType getChannel() { return channel; }\n    public DeliveryStatus getStatus() { return status; }\n    public void setStatus(DeliveryStatus status) { this.status = status; }\n    public String getMessageId() { return messageId; }\n    public String getErrorMessage() { return errorMessage; }\n    public int getRetryCount() { return retryCount; }\n    public void incrementRetryCount() { this.retryCount++; }\n    public Map<String, String> getMetadata() { return metadata; }\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"channel-interface-and-implementations",children:"Channel Interface and Implementations"}),"\n",(0,t.jsx)(n.h4,{id:"notificationchanneljava",children:"NotificationChannel.java"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"public interface NotificationChannel {\n    DeliveryResult send(Notification notification);\n    boolean validateConfig();\n    ChannelType getChannelType();\n    boolean isAvailable();\n    int getMaxRetries();\n}\n"})}),"\n",(0,t.jsx)(n.h4,{id:"emailchanneljava",children:"EmailChannel.java"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'public class EmailChannel implements NotificationChannel {\n    private String smtpHost;\n    private int smtpPort;\n    private String apiKey;\n    private String fromAddress;\n    private boolean isConfigured;\n\n    public EmailChannel(String smtpHost, int smtpPort, String apiKey, String fromAddress) {\n        this.smtpHost = smtpHost;\n        this.smtpPort = smtpPort;\n        this.apiKey = apiKey;\n        this.fromAddress = fromAddress;\n        this.isConfigured = validateConfig();\n    }\n\n    @Override\n    public DeliveryResult send(Notification notification) {\n        DeliveryResult result = new DeliveryResult(notification.getId(), ChannelType.EMAIL);\n\n        try {\n            if (!isAvailable()) {\n                result.markFailed("Email channel not available");\n                return result;\n            }\n\n            // Simulate email sending\n            String emailContent = formatEmailContent(notification);\n            String messageId = sendEmail(notification.getRecipientId(),\n                                        notification.getSubject(),\n                                        emailContent);\n\n            result.markSuccess(messageId);\n            System.out.println("Email sent successfully: " + messageId);\n\n        } catch (Exception e) {\n            result.markFailed(e.getMessage());\n            System.err.println("Email sending failed: " + e.getMessage());\n        }\n\n        return result;\n    }\n\n    private String formatEmailContent(Notification notification) {\n        StringBuilder content = new StringBuilder();\n        content.append("<html><body>");\n        content.append("<h2>").append(notification.getSubject()).append("</h2>");\n        content.append("<p>").append(notification.getContent()).append("</p>");\n        content.append("</body></html>");\n        return content.toString();\n    }\n\n    private String sendEmail(String to, String subject, String content) {\n        // In production: integrate with SendGrid, AWS SES, etc.\n        return "email-" + UUID.randomUUID().toString();\n    }\n\n    @Override\n    public boolean validateConfig() {\n        return smtpHost != null && !smtpHost.isEmpty() &&\n               fromAddress != null && !fromAddress.isEmpty();\n    }\n\n    @Override\n    public ChannelType getChannelType() {\n        return ChannelType.EMAIL;\n    }\n\n    @Override\n    public boolean isAvailable() {\n        return isConfigured;\n    }\n\n    @Override\n    public int getMaxRetries() {\n        return 3;\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"smschanneljava",children:"SMSChannel.java"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'public class SMSChannel implements NotificationChannel {\n    private String apiKey;\n    private String phoneNumber;\n    private static final int MAX_LENGTH = 160;\n    private boolean isConfigured;\n\n    public SMSChannel(String apiKey, String phoneNumber) {\n        this.apiKey = apiKey;\n        this.phoneNumber = phoneNumber;\n        this.isConfigured = validateConfig();\n    }\n\n    @Override\n    public DeliveryResult send(Notification notification) {\n        DeliveryResult result = new DeliveryResult(notification.getId(), ChannelType.SMS);\n\n        try {\n            if (!isAvailable()) {\n                result.markFailed("SMS channel not available");\n                return result;\n            }\n\n            String message = truncateMessage(notification.getContent());\n            String messageId = sendSMS(notification.getRecipientId(), message);\n\n            result.markSuccess(messageId);\n            System.out.println("SMS sent successfully: " + messageId);\n\n        } catch (Exception e) {\n            result.markFailed(e.getMessage());\n            System.err.println("SMS sending failed: " + e.getMessage());\n        }\n\n        return result;\n    }\n\n    private String truncateMessage(String message) {\n        if (message.length() > MAX_LENGTH) {\n            return message.substring(0, MAX_LENGTH - 3) + "...";\n        }\n        return message;\n    }\n\n    private boolean validatePhoneNumber(String phone) {\n        return phone != null && phone.matches("^\\\\+?[1-9]\\\\d{1,14}$");\n    }\n\n    private String sendSMS(String to, String message) {\n        // In production: integrate with Twilio, AWS SNS, etc.\n        return "sms-" + UUID.randomUUID().toString();\n    }\n\n    @Override\n    public boolean validateConfig() {\n        return apiKey != null && !apiKey.isEmpty() &&\n               phoneNumber != null && !phoneNumber.isEmpty();\n    }\n\n    @Override\n    public ChannelType getChannelType() {\n        return ChannelType.SMS;\n    }\n\n    @Override\n    public boolean isAvailable() {\n        return isConfigured;\n    }\n\n    @Override\n    public int getMaxRetries() {\n        return 2;\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"pushchanneljava",children:"PushChannel.java"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'public class PushChannel implements NotificationChannel {\n    private String serverKey;\n    private String appId;\n    private boolean isConfigured;\n\n    public PushChannel(String serverKey, String appId) {\n        this.serverKey = serverKey;\n        this.appId = appId;\n        this.isConfigured = validateConfig();\n    }\n\n    @Override\n    public DeliveryResult send(Notification notification) {\n        DeliveryResult result = new DeliveryResult(notification.getId(), ChannelType.PUSH);\n\n        try {\n            if (!isAvailable()) {\n                result.markFailed("Push channel not available");\n                return result;\n            }\n\n            Map<String, Object> payload = buildPushPayload(notification);\n            String messageId = sendPushNotification(notification.getRecipientId(), payload);\n\n            result.markSuccess(messageId);\n            System.out.println("Push notification sent: " + messageId);\n\n        } catch (Exception e) {\n            result.markFailed(e.getMessage());\n            System.err.println("Push notification failed: " + e.getMessage());\n        }\n\n        return result;\n    }\n\n    private Map<String, Object> buildPushPayload(Notification notification) {\n        Map<String, Object> payload = new HashMap<>();\n        payload.put("title", notification.getSubject());\n        payload.put("body", notification.getContent());\n        payload.put("data", notification.getData());\n        payload.put("priority", notification.getPriority().name());\n        return payload;\n    }\n\n    private String sendPushNotification(String deviceToken, Map<String, Object> payload) {\n        // In production: integrate with FCM, APNS, etc.\n        return "push-" + UUID.randomUUID().toString();\n    }\n\n    @Override\n    public boolean validateConfig() {\n        return serverKey != null && !serverKey.isEmpty() &&\n               appId != null && !appId.isEmpty();\n    }\n\n    @Override\n    public ChannelType getChannelType() {\n        return ChannelType.PUSH;\n    }\n\n    @Override\n    public boolean isAvailable() {\n        return isConfigured;\n    }\n\n    @Override\n    public int getMaxRetries() {\n        return 3;\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"inappchanneljava",children:"InAppChannel.java"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'import java.util.*;\n\npublic class InAppChannel implements NotificationChannel {\n    private Map<String, List<Notification>> userNotifications;\n    private Map<String, Integer> unreadCounts;\n\n    public InAppChannel() {\n        this.userNotifications = new HashMap<>();\n        this.unreadCounts = new HashMap<>();\n    }\n\n    @Override\n    public DeliveryResult send(Notification notification) {\n        DeliveryResult result = new DeliveryResult(notification.getId(), ChannelType.IN_APP);\n\n        try {\n            String userId = notification.getRecipientId();\n\n            userNotifications.computeIfAbsent(userId, k -> new ArrayList<>())\n                           .add(notification);\n\n            unreadCounts.merge(userId, 1, Integer::sum);\n\n            result.markSuccess(notification.getId());\n            System.out.println("In-app notification stored for user: " + userId);\n\n        } catch (Exception e) {\n            result.markFailed(e.getMessage());\n            System.err.println("In-app notification failed: " + e.getMessage());\n        }\n\n        return result;\n    }\n\n    public boolean markAsRead(String notificationId, String userId) {\n        List<Notification> notifications = userNotifications.get(userId);\n        if (notifications != null) {\n            unreadCounts.merge(userId, -1, Integer::sum);\n            return true;\n        }\n        return false;\n    }\n\n    public int getUnreadCount(String userId) {\n        return unreadCounts.getOrDefault(userId, 0);\n    }\n\n    public List<Notification> getUserNotifications(String userId) {\n        return userNotifications.getOrDefault(userId, new ArrayList<>());\n    }\n\n    @Override\n    public boolean validateConfig() {\n        return true;\n    }\n\n    @Override\n    public ChannelType getChannelType() {\n        return ChannelType.IN_APP;\n    }\n\n    @Override\n    public boolean isAvailable() {\n        return true;\n    }\n\n    @Override\n    public int getMaxRetries() {\n        return 1;\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"webhookchanneljava",children:"WebhookChannel.java"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'import java.util.*;\n\npublic class WebhookChannel implements NotificationChannel {\n    private String webhookUrl;\n    private Map<String, String> headers;\n    private String secretKey;\n\n    public WebhookChannel(String webhookUrl, String secretKey) {\n        this.webhookUrl = webhookUrl;\n        this.secretKey = secretKey;\n        this.headers = new HashMap<>();\n        this.headers.put("Content-Type", "application/json");\n    }\n\n    @Override\n    public DeliveryResult send(Notification notification) {\n        DeliveryResult result = new DeliveryResult(notification.getId(), ChannelType.WEBHOOK);\n\n        try {\n            if (!isAvailable()) {\n                result.markFailed("Webhook channel not configured");\n                return result;\n            }\n\n            String payload = buildWebhookPayload(notification);\n            String signature = signPayload(payload);\n\n            String messageId = sendWebhook(payload, signature);\n            result.markSuccess(messageId);\n            System.out.println("Webhook sent successfully: " + messageId);\n\n        } catch (Exception e) {\n            result.markFailed(e.getMessage());\n            System.err.println("Webhook failed: " + e.getMessage());\n        }\n\n        return result;\n    }\n\n    private String buildWebhookPayload(Notification notification) {\n        // Build JSON payload\n        return String.format("{\\"id\\":\\"%s\\",\\"type\\":\\"%s\\",\\"content\\":\\"%s\\"}",\n                           notification.getId(),\n                           notification.getType(),\n                           notification.getContent());\n    }\n\n    private String signPayload(String payload) {\n        // In production: use HMAC-SHA256\n        return "signature-" + payload.hashCode();\n    }\n\n    private String sendWebhook(String payload, String signature) {\n        // In production: HTTP POST to webhook URL\n        return "webhook-" + UUID.randomUUID().toString();\n    }\n\n    @Override\n    public boolean validateConfig() {\n        return webhookUrl != null && !webhookUrl.isEmpty();\n    }\n\n    @Override\n    public ChannelType getChannelType() {\n        return ChannelType.WEBHOOK;\n    }\n\n    @Override\n    public boolean isAvailable() {\n        return webhookUrl != null && !webhookUrl.isEmpty();\n    }\n\n    @Override\n    public int getMaxRetries() {\n        return 3;\n    }\n}\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"template-management",children:"Template Management"}),"\n",(0,t.jsx)(n.h4,{id:"notificationtemplatejava",children:"NotificationTemplate.java"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'import java.util.*;\nimport java.util.regex.*;\n\npublic class NotificationTemplate {\n    private String id;\n    private String name;\n    private ChannelType channelType;\n    private String subject;\n    private String body;\n    private String language;\n    private int version;\n    private Date createdAt;\n    private Date updatedAt;\n\n    public NotificationTemplate(String name, ChannelType channelType, String subject, String body) {\n        this.id = UUID.randomUUID().toString();\n        this.name = name;\n        this.channelType = channelType;\n        this.subject = subject;\n        this.body = body;\n        this.language = "en";\n        this.version = 1;\n        this.createdAt = new Date();\n    }\n\n    public String render(Map<String, Object> data) {\n        String rendered = body;\n\n        // Replace variables like {{variableName}}\n        Pattern pattern = Pattern.compile("\\\\{\\\\{(\\\\w+)\\\\}\\\\}");\n        Matcher matcher = pattern.matcher(rendered);\n\n        StringBuffer sb = new StringBuffer();\n        while (matcher.find()) {\n            String variable = matcher.group(1);\n            Object value = data.get(variable);\n            matcher.appendReplacement(sb, value != null ? value.toString() : "");\n        }\n        matcher.appendTail(sb);\n\n        return sb.toString();\n    }\n\n    public String renderSubject(Map<String, Object> data) {\n        if (subject == null) return "";\n\n        String rendered = subject;\n        Pattern pattern = Pattern.compile("\\\\{\\\\{(\\\\w+)\\\\}\\\\}");\n        Matcher matcher = pattern.matcher(rendered);\n\n        StringBuffer sb = new StringBuffer();\n        while (matcher.find()) {\n            String variable = matcher.group(1);\n            Object value = data.get(variable);\n            matcher.appendReplacement(sb, value != null ? value.toString() : "");\n        }\n        matcher.appendTail(sb);\n\n        return sb.toString();\n    }\n\n    public NotificationTemplate clone() {\n        NotificationTemplate cloned = new NotificationTemplate(\n            this.name, this.channelType, this.subject, this.body\n        );\n        cloned.language = this.language;\n        cloned.version = this.version + 1;\n        return cloned;\n    }\n\n    // Getters and Setters\n    public String getId() { return id; }\n    public String getName() { return name; }\n    public ChannelType getChannelType() { return channelType; }\n    public String getSubject() { return subject; }\n    public String getBody() { return body; }\n    public void setBody(String body) {\n        this.body = body;\n        this.updatedAt = new Date();\n    }\n    public String getLanguage() { return language; }\n    public void setLanguage(String language) { this.language = language; }\n    public int getVersion() { return version; }\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"templateenginejava",children:"TemplateEngine.java"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'import java.util.*;\n\npublic class TemplateEngine {\n    private Map<String, NotificationTemplate> templates;\n    private Map<String, Map<String, NotificationTemplate>> templatesByChannel;\n\n    public TemplateEngine() {\n        this.templates = new HashMap<>();\n        this.templatesByChannel = new HashMap<>();\n    }\n\n    public void registerTemplate(NotificationTemplate template) {\n        templates.put(template.getId(), template);\n\n        ChannelType channel = template.getChannelType();\n        templatesByChannel.computeIfAbsent(channel.name(), k -> new HashMap<>())\n                         .put(template.getName(), template);\n\n        System.out.println("Template registered: " + template.getName() +\n                         " for channel: " + channel);\n    }\n\n    public String renderTemplate(String templateId, Map<String, Object> data) {\n        NotificationTemplate template = templates.get(templateId);\n        if (template == null) {\n            throw new IllegalArgumentException("Template not found: " + templateId);\n        }\n        return template.render(data);\n    }\n\n    public NotificationTemplate getTemplate(String templateId) {\n        return templates.get(templateId);\n    }\n\n    public NotificationTemplate getTemplateByName(String name, ChannelType channelType) {\n        Map<String, NotificationTemplate> channelTemplates =\n            templatesByChannel.get(channelType.name());\n\n        if (channelTemplates != null) {\n            return channelTemplates.get(name);\n        }\n        return null;\n    }\n\n    public boolean validateTemplate(String templateContent) {\n        // Check for valid variable syntax\n        Pattern pattern = Pattern.compile("\\\\{\\\\{\\\\w+\\\\}\\\\}");\n        Matcher matcher = pattern.matcher(templateContent);\n\n        // Basic validation - can be extended\n        return templateContent != null && !templateContent.isEmpty();\n    }\n\n    public List<NotificationTemplate> getAllTemplates() {\n        return new ArrayList<>(templates.values());\n    }\n\n    public void deleteTemplate(String templateId) {\n        NotificationTemplate template = templates.remove(templateId);\n        if (template != null) {\n            Map<String, NotificationTemplate> channelTemplates =\n                templatesByChannel.get(template.getChannelType().name());\n            if (channelTemplates != null) {\n                channelTemplates.remove(template.getName());\n            }\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"user-preference-management",children:"User Preference Management"}),"\n",(0,t.jsx)(n.h4,{id:"userpreferencejava",children:"UserPreference.java"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'import java.util.*;\n\npublic class UserPreference {\n    private String userId;\n    private Map<ChannelType, Boolean> enabledChannels;\n    private Map<NotificationType, Boolean> enabledTypes;\n    private TimeRange quietHours;\n    private String timezone;\n    private String language;\n    private int maxNotificationsPerDay;\n\n    public UserPreference(String userId) {\n        this.userId = userId;\n        this.enabledChannels = new HashMap<>();\n        this.enabledTypes = new HashMap<>();\n        this.timezone = "UTC";\n        this.language = "en";\n        this.maxNotificationsPerDay = 50;\n\n        // Default: all channels enabled\n        for (ChannelType channel : ChannelType.values()) {\n            enabledChannels.put(channel, true);\n        }\n\n        // Default: all types enabled\n        for (NotificationType type : NotificationType.values()) {\n            enabledTypes.put(type, true);\n        }\n    }\n\n    public boolean isChannelEnabled(ChannelType channel) {\n        return enabledChannels.getOrDefault(channel, false);\n    }\n\n    public boolean isTypeEnabled(NotificationType type) {\n        return enabledTypes.getOrDefault(type, true);\n    }\n\n    public void enableChannel(ChannelType channel) {\n        enabledChannels.put(channel, true);\n    }\n\n    public void disableChannel(ChannelType channel) {\n        enabledChannels.put(channel, false);\n    }\n\n    public void setQuietHours(int startHour, int endHour) {\n        this.quietHours = new TimeRange(startHour, endHour);\n    }\n\n    public boolean canReceiveAt(Date time) {\n        if (quietHours == null) {\n            return true;\n        }\n\n        Calendar cal = Calendar.getInstance(TimeZone.getTimeZone(timezone));\n        cal.setTime(time);\n        int hour = cal.get(Calendar.HOUR_OF_DAY);\n\n        return !quietHours.isInRange(hour);\n    }\n\n    public boolean canReceiveType(NotificationType type) {\n        // Critical notifications bypass preferences\n        if (type == NotificationType.ALERT) {\n            return true;\n        }\n        return isTypeEnabled(type);\n    }\n\n    // Getters and Setters\n    public String getUserId() { return userId; }\n    public Map<ChannelType, Boolean> getEnabledChannels() { return enabledChannels; }\n    public String getTimezone() { return timezone; }\n    public void setTimezone(String timezone) { this.timezone = timezone; }\n    public String getLanguage() { return language; }\n    public void setLanguage(String language) { this.language = language; }\n    public int getMaxNotificationsPerDay() { return maxNotificationsPerDay; }\n    public void setMaxNotificationsPerDay(int max) { this.maxNotificationsPerDay = max; }\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"timerangejava",children:"TimeRange.java"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'public class TimeRange {\n    private int startHour;\n    private int endHour;\n\n    public TimeRange(int startHour, int endHour) {\n        if (startHour < 0 || startHour > 23 || endHour < 0 || endHour > 23) {\n            throw new IllegalArgumentException("Hours must be between 0 and 23");\n        }\n        this.startHour = startHour;\n        this.endHour = endHour;\n    }\n\n    public boolean isInRange(int hour) {\n        if (startHour <= endHour) {\n            return hour >= startHour && hour < endHour;\n        } else {\n            // Handles ranges that cross midnight (e.g., 22:00 - 06:00)\n            return hour >= startHour || hour < endHour;\n        }\n    }\n\n    public int getStartHour() { return startHour; }\n    public int getEndHour() { return endHour; }\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"preferencemanagerjava",children:"PreferenceManager.java"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'import java.util.*;\n\npublic class PreferenceManager {\n    private Map<String, UserPreference> preferences;\n\n    public PreferenceManager() {\n        this.preferences = new HashMap<>();\n    }\n\n    public UserPreference getUserPreference(String userId) {\n        return preferences.computeIfAbsent(userId, UserPreference::new);\n    }\n\n    public void updatePreference(String userId, UserPreference preference) {\n        preferences.put(userId, preference);\n        System.out.println("Preferences updated for user: " + userId);\n    }\n\n    public boolean isChannelEnabled(String userId, ChannelType channel) {\n        UserPreference pref = getUserPreference(userId);\n        return pref.isChannelEnabled(channel);\n    }\n\n    public boolean canSendNotification(String userId, NotificationType type, Date time) {\n        UserPreference pref = getUserPreference(userId);\n\n        if (!pref.canReceiveType(type)) {\n            return false;\n        }\n\n        if (!pref.canReceiveAt(time)) {\n            return false;\n        }\n\n        return true;\n    }\n\n    public List<ChannelType> getEnabledChannels(String userId) {\n        UserPreference pref = getUserPreference(userId);\n        List<ChannelType> enabled = new ArrayList<>();\n\n        for (ChannelType channel : ChannelType.values()) {\n            if (pref.isChannelEnabled(channel)) {\n                enabled.add(channel);\n            }\n        }\n\n        return enabled;\n    }\n\n    public boolean isQuietHours(String userId) {\n        UserPreference pref = getUserPreference(userId);\n        return !pref.canReceiveAt(new Date());\n    }\n}\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"queue-management",children:"Queue Management"}),"\n",(0,t.jsx)(n.h4,{id:"notificationqueuejava",children:"NotificationQueue.java"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'import java.util.*;\nimport java.util.concurrent.*;\n\npublic class NotificationQueue {\n    private PriorityQueue<Notification> criticalQueue;\n    private PriorityQueue<Notification> highPriorityQueue;\n    private PriorityQueue<Notification> normalQueue;\n    private PriorityQueue<Notification> lowPriorityQueue;\n    private ExecutorService executor;\n    private volatile boolean isProcessing;\n\n    public NotificationQueue(int threadPoolSize) {\n        Comparator<Notification> comparator =\n            Comparator.comparing(Notification::getScheduledAt,\n                               Comparator.nullsFirst(Comparator.naturalOrder()));\n\n        this.criticalQueue = new PriorityQueue<>(comparator);\n        this.highPriorityQueue = new PriorityQueue<>(comparator);\n        this.normalQueue = new PriorityQueue<>(comparator);\n        this.lowPriorityQueue = new PriorityQueue<>(comparator);\n        this.executor = Executors.newFixedThreadPool(threadPoolSize);\n        this.isProcessing = false;\n    }\n\n    public void enqueue(Notification notification) {\n        notification.setStatus(NotificationStatus.QUEUED);\n\n        switch (notification.getPriority()) {\n            case CRITICAL:\n                criticalQueue.offer(notification);\n                break;\n            case HIGH:\n                highPriorityQueue.offer(notification);\n                break;\n            case MEDIUM:\n                normalQueue.offer(notification);\n                break;\n            case LOW:\n                lowPriorityQueue.offer(notification);\n                break;\n        }\n\n        System.out.println("Notification queued: " + notification.getId() +\n                         " with priority: " + notification.getPriority());\n    }\n\n    public Notification dequeue() {\n        // Process in priority order\n        if (!criticalQueue.isEmpty()) {\n            Notification n = criticalQueue.peek();\n            if (n.shouldSendNow()) {\n                return criticalQueue.poll();\n            }\n        }\n\n        if (!highPriorityQueue.isEmpty()) {\n            Notification n = highPriorityQueue.peek();\n            if (n.shouldSendNow()) {\n                return highPriorityQueue.poll();\n            }\n        }\n\n        if (!normalQueue.isEmpty()) {\n            Notification n = normalQueue.peek();\n            if (n.shouldSendNow()) {\n                return normalQueue.poll();\n            }\n        }\n\n        if (!lowPriorityQueue.isEmpty()) {\n            Notification n = lowPriorityQueue.peek();\n            if (n.shouldSendNow()) {\n                return lowPriorityQueue.poll();\n            }\n        }\n\n        return null;\n    }\n\n    public int getQueueSize() {\n        return criticalQueue.size() + highPriorityQueue.size() +\n               normalQueue.size() + lowPriorityQueue.size();\n    }\n\n    public Map<NotificationPriority, Integer> getQueueSizeByPriority() {\n        Map<NotificationPriority, Integer> sizes = new HashMap<>();\n        sizes.put(NotificationPriority.CRITICAL, criticalQueue.size());\n        sizes.put(NotificationPriority.HIGH, highPriorityQueue.size());\n        sizes.put(NotificationPriority.MEDIUM, normalQueue.size());\n        sizes.put(NotificationPriority.LOW, lowPriorityQueue.size());\n        return sizes;\n    }\n\n    public void shutdown() {\n        isProcessing = false;\n        executor.shutdown();\n        try {\n            if (!executor.awaitTermination(60, TimeUnit.SECONDS)) {\n                executor.shutdownNow();\n            }\n        } catch (InterruptedException e) {\n            executor.shutdownNow();\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"retry-handler",children:"Retry Handler"}),"\n",(0,t.jsx)(n.h4,{id:"retryhandlerjava",children:"RetryHandler.java"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'import java.util.*;\nimport java.util.concurrent.*;\n\npublic class RetryHandler {\n    private int maxRetries;\n    private long baseDelayMs;\n    private Map<String, RetryContext> retryMap;\n    private ScheduledExecutorService scheduler;\n\n    public RetryHandler(int maxRetries, long baseDelayMs) {\n        this.maxRetries = maxRetries;\n        this.baseDelayMs = baseDelayMs;\n        this.retryMap = new ConcurrentHashMap<>();\n        this.scheduler = Executors.newScheduledThreadPool(2);\n    }\n\n    public boolean shouldRetry(DeliveryResult result) {\n        if (result.isSuccess()) {\n            return false;\n        }\n\n        RetryContext context = retryMap.get(result.getNotificationId());\n        if (context == null) {\n            return true;\n        }\n\n        return context.getAttemptCount() < maxRetries;\n    }\n\n    public void scheduleRetry(Notification notification, DeliveryResult result,\n                            NotificationChannel channel) {\n        RetryContext context = retryMap.computeIfAbsent(\n            notification.getId(),\n            k -> new RetryContext(notification.getId())\n        );\n\n        context.incrementAttempt();\n        result.incrementRetryCount();\n\n        if (context.getAttemptCount() >= maxRetries) {\n            System.out.println("Max retries reached for notification: " + notification.getId());\n            notification.setStatus(NotificationStatus.FAILED);\n            retryMap.remove(notification.getId());\n            return;\n        }\n\n        long delay = calculateBackoff(context.getAttemptCount());\n        Date nextRetryTime = new Date(System.currentTimeMillis() + delay);\n        context.setNextRetryTime(nextRetryTime);\n\n        System.out.println("Scheduling retry #" + context.getAttemptCount() +\n                         " for notification: " + notification.getId() +\n                         " in " + delay + "ms");\n\n        scheduler.schedule(() -> {\n            System.out.println("Retrying notification: " + notification.getId());\n            channel.send(notification);\n        }, delay, TimeUnit.MILLISECONDS);\n    }\n\n    private long calculateBackoff(int attempt) {\n        // Exponential backoff: baseDelay * 2^attempt\n        return baseDelayMs * (long) Math.pow(2, attempt - 1);\n    }\n\n    public Date getNextRetryTime(String notificationId) {\n        RetryContext context = retryMap.get(notificationId);\n        return context != null ? context.getNextRetryTime() : null;\n    }\n\n    public int getRetryCount(String notificationId) {\n        RetryContext context = retryMap.get(notificationId);\n        return context != null ? context.getAttemptCount() : 0;\n    }\n\n    public void clearRetryContext(String notificationId) {\n        retryMap.remove(notificationId);\n    }\n\n    public void shutdown() {\n        scheduler.shutdown();\n        try {\n            if (!scheduler.awaitTermination(30, TimeUnit.SECONDS)) {\n                scheduler.shutdownNow();\n            }\n        } catch (InterruptedException e) {\n            scheduler.shutdownNow();\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"retrycontextjava",children:"RetryContext.java"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"import java.util.Date;\n\npublic class RetryContext {\n    private String notificationId;\n    private int attemptCount;\n    private Date firstAttempt;\n    private Date lastAttempt;\n    private Date nextRetryTime;\n\n    public RetryContext(String notificationId) {\n        this.notificationId = notificationId;\n        this.attemptCount = 0;\n        this.firstAttempt = new Date();\n    }\n\n    public void incrementAttempt() {\n        this.attemptCount++;\n        this.lastAttempt = new Date();\n    }\n\n    public String getNotificationId() { return notificationId; }\n    public int getAttemptCount() { return attemptCount; }\n    public Date getFirstAttempt() { return firstAttempt; }\n    public Date getLastAttempt() { return lastAttempt; }\n    public Date getNextRetryTime() { return nextRetryTime; }\n    public void setNextRetryTime(Date nextRetryTime) { this.nextRetryTime = nextRetryTime; }\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"rate-limiter",children:"Rate Limiter"}),"\n",(0,t.jsx)(n.h4,{id:"ratelimiterjava",children:"RateLimiter.java"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'import java.util.*;\nimport java.util.concurrent.*;\n\npublic class RateLimiter {\n    private Map<String, TokenBucket> userBuckets;\n    private int maxPerHour;\n    private int maxPerDay;\n    private ScheduledExecutorService refillScheduler;\n\n    public RateLimiter(int maxPerHour, int maxPerDay) {\n        this.maxPerHour = maxPerHour;\n        this.maxPerDay = maxPerDay;\n        this.userBuckets = new ConcurrentHashMap<>();\n        this.refillScheduler = Executors.newScheduledThreadPool(1);\n\n        // Refill buckets every minute\n        refillScheduler.scheduleAtFixedRate(\n            this::refillBuckets, 1, 1, TimeUnit.MINUTES\n        );\n    }\n\n    public boolean allowRequest(String userId, ChannelType channel) {\n        TokenBucket bucket = userBuckets.computeIfAbsent(\n            userId + "-" + channel,\n            k -> new TokenBucket(maxPerHour, maxPerDay)\n        );\n\n        return bucket.tryConsume();\n    }\n\n    public int getRemainingQuota(String userId, ChannelType channel) {\n        TokenBucket bucket = userBuckets.get(userId + "-" + channel);\n        return bucket != null ? bucket.getHourlyTokens() : maxPerHour;\n    }\n\n    private void refillBuckets() {\n        for (TokenBucket bucket : userBuckets.values()) {\n            bucket.refill();\n        }\n    }\n\n    public void shutdown() {\n        refillScheduler.shutdown();\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"tokenbucketjava",children:"TokenBucket.java"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"import java.util.Date;\n\npublic class TokenBucket {\n    private int hourlyTokens;\n    private int dailyTokens;\n    private int maxHourly;\n    private int maxDaily;\n    private Date lastRefill;\n    private Date dailyReset;\n\n    public TokenBucket(int maxHourly, int maxDaily) {\n        this.maxHourly = maxHourly;\n        this.maxDaily = maxDaily;\n        this.hourlyTokens = maxHourly;\n        this.dailyTokens = maxDaily;\n        this.lastRefill = new Date();\n        this.dailyReset = new Date();\n    }\n\n    public synchronized boolean tryConsume() {\n        checkAndResetDaily();\n\n        if (hourlyTokens > 0 && dailyTokens > 0) {\n            hourlyTokens--;\n            dailyTokens--;\n            return true;\n        }\n        return false;\n    }\n\n    public synchronized void refill() {\n        long now = System.currentTimeMillis();\n        long hoursSinceRefill = (now - lastRefill.getTime()) / (1000 * 60 * 60);\n\n        if (hoursSinceRefill >= 1) {\n            hourlyTokens = maxHourly;\n            lastRefill = new Date();\n        }\n\n        checkAndResetDaily();\n    }\n\n    private void checkAndResetDaily() {\n        long now = System.currentTimeMillis();\n        long daysSinceReset = (now - dailyReset.getTime()) / (1000 * 60 * 60 * 24);\n\n        if (daysSinceReset >= 1) {\n            dailyTokens = maxDaily;\n            dailyReset = new Date();\n        }\n    }\n\n    public int getHourlyTokens() { return hourlyTokens; }\n    public int getDailyTokens() { return dailyTokens; }\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"notification-service-main-orchestrator",children:"Notification Service (Main Orchestrator)"}),"\n",(0,t.jsx)(n.h4,{id:"notificationservicejava",children:"NotificationService.java"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'import java.util.*;\n\npublic class NotificationService {\n    private NotificationQueue queue;\n    private TemplateEngine templateEngine;\n    private PreferenceManager preferenceManager;\n    private Map<ChannelType, NotificationChannel> channels;\n    private RetryHandler retryHandler;\n    private RateLimiter rateLimiter;\n    private NotificationLogger logger;\n    private Map<String, Notification> notificationStore;\n\n    private static NotificationService instance;\n\n    private NotificationService() {\n        this.queue = new NotificationQueue(5);\n        this.templateEngine = new TemplateEngine();\n        this.preferenceManager = new PreferenceManager();\n        this.channels = new HashMap<>();\n        this.retryHandler = new RetryHandler(3, 1000);\n        this.rateLimiter = new RateLimiter(100, 1000);\n        this.logger = new NotificationLogger();\n        this.notificationStore = new HashMap<>();\n\n        initializeChannels();\n    }\n\n    public static synchronized NotificationService getInstance() {\n        if (instance == null) {\n            instance = new NotificationService();\n        }\n        return instance;\n    }\n\n    private void initializeChannels() {\n        // Register default channels\n        channels.put(ChannelType.EMAIL,\n            new EmailChannel("smtp.example.com", 587, "api-key", "noreply@example.com"));\n        channels.put(ChannelType.SMS,\n            new SMSChannel("sms-api-key", "+1234567890"));\n        channels.put(ChannelType.PUSH,\n            new PushChannel("push-server-key", "app-id"));\n        channels.put(ChannelType.IN_APP,\n            new InAppChannel());\n        channels.put(ChannelType.WEBHOOK,\n            new WebhookChannel("https://webhook.example.com", "secret"));\n    }\n\n    public String sendNotification(Notification notification) {\n        try {\n            // Validate notification\n            if (!notification.validate()) {\n                System.out.println("Invalid notification");\n                return null;\n            }\n\n            // Check if expired\n            if (notification.isExpired()) {\n                System.out.println("Notification expired");\n                notification.setStatus(NotificationStatus.EXPIRED);\n                return null;\n            }\n\n            // Process template if specified\n            if (notification.getTemplateId() != null) {\n                processTemplate(notification);\n            }\n\n            // Apply user preferences\n            List<ChannelType> allowedChannels = filterChannelsByPreference(notification);\n            if (allowedChannels.isEmpty()) {\n                System.out.println("No channels allowed for user");\n                notification.setStatus(NotificationStatus.CANCELLED);\n                return null;\n            }\n\n            // Store notification\n            notificationStore.put(notification.getId(), notification);\n\n            // Queue or send immediately\n            if (notification.shouldSendNow()) {\n                sendToChannels(notification, allowedChannels);\n            } else {\n                queue.enqueue(notification);\n            }\n\n            return notification.getId();\n\n        } catch (Exception e) {\n            System.err.println("Error sending notification: " + e.getMessage());\n            return null;\n        }\n    }\n\n    private void processTemplate(Notification notification) {\n        NotificationTemplate template = templateEngine.getTemplate(notification.getTemplateId());\n        if (template != null) {\n            String renderedContent = template.render(notification.getData());\n            String renderedSubject = template.renderSubject(notification.getData());\n\n            notification.setContent(renderedContent);\n            notification.setSubject(renderedSubject);\n        }\n    }\n\n    private List<ChannelType> filterChannelsByPreference(Notification notification) {\n        List<ChannelType> filtered = new ArrayList<>();\n        UserPreference pref = preferenceManager.getUserPreference(notification.getRecipientId());\n\n        for (ChannelType channel : notification.getChannels()) {\n            if (pref.isChannelEnabled(channel)) {\n                // Check rate limit\n                if (rateLimiter.allowRequest(notification.getRecipientId(), channel)) {\n                    filtered.add(channel);\n                } else {\n                    System.out.println("Rate limit exceeded for user: " +\n                                     notification.getRecipientId() + " on channel: " + channel);\n                }\n            }\n        }\n\n        return filtered;\n    }\n\n    private void sendToChannels(Notification notification, List<ChannelType> channelTypes) {\n        notification.setStatus(NotificationStatus.PROCESSING);\n\n        for (ChannelType channelType : channelTypes) {\n            NotificationChannel channel = channels.get(channelType);\n\n            if (channel == null || !channel.isAvailable()) {\n                System.out.println("Channel not available: " + channelType);\n                continue;\n            }\n\n            DeliveryResult result = channel.send(notification);\n            logger.logDelivery(notification, channelType, result);\n\n            if (!result.isSuccess() && retryHandler.shouldRetry(result)) {\n                retryHandler.scheduleRetry(notification, result, channel);\n            }\n        }\n\n        notification.setStatus(NotificationStatus.SENT);\n    }\n\n    public String scheduleNotification(Notification notification, Date scheduledTime) {\n        notification.setScheduledAt(scheduledTime);\n        queue.enqueue(notification);\n        notificationStore.put(notification.getId(), notification);\n\n        System.out.println("Notification scheduled for: " + scheduledTime);\n        return notification.getId();\n    }\n\n    public NotificationStatus getNotificationStatus(String notificationId) {\n        Notification notification = notificationStore.get(notificationId);\n        return notification != null ? notification.getStatus() : null;\n    }\n\n    public boolean cancelNotification(String notificationId) {\n        Notification notification = notificationStore.get(notificationId);\n        if (notification != null &&\n            (notification.getStatus() == NotificationStatus.PENDING ||\n             notification.getStatus() == NotificationStatus.QUEUED)) {\n            notification.setStatus(NotificationStatus.CANCELLED);\n            return true;\n        }\n        return false;\n    }\n\n    public void registerChannel(ChannelType type, NotificationChannel channel) {\n        channels.put(type, channel);\n        System.out.println("Channel registered: " + type);\n    }\n\n    public TemplateEngine getTemplateEngine() {\n        return templateEngine;\n    }\n\n    public PreferenceManager getPreferenceManager() {\n        return preferenceManager;\n    }\n\n    public NotificationQueue getQueue() {\n        return queue;\n    }\n\n    public void shutdown() {\n        queue.shutdown();\n        retryHandler.shutdown();\n        rateLimiter.shutdown();\n        System.out.println("Notification service shut down");\n    }\n}\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"logging-and-monitoring",children:"Logging and Monitoring"}),"\n",(0,t.jsx)(n.h4,{id:"notificationloggerjava",children:"NotificationLogger.java"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'import java.util.*;\n\npublic class NotificationLogger {\n    private List<NotificationLog> logs;\n    private Map<String, List<NotificationLog>> userLogs;\n\n    public NotificationLogger() {\n        this.logs = new ArrayList<>();\n        this.userLogs = new HashMap<>();\n    }\n\n    public void logDelivery(Notification notification, ChannelType channel, DeliveryResult result) {\n        NotificationLog log = new NotificationLog(\n            notification.getId(),\n            notification.getRecipientId(),\n            channel,\n            result.getStatus(),\n            result.getErrorMessage(),\n            new Date()\n        );\n\n        logs.add(log);\n        userLogs.computeIfAbsent(notification.getRecipientId(), k -> new ArrayList<>())\n               .add(log);\n\n        System.out.println("Logged: " + log);\n    }\n\n    public List<NotificationLog> getNotificationHistory(String userId) {\n        return userLogs.getOrDefault(userId, new ArrayList<>());\n    }\n\n    public List<NotificationLog> getAllLogs() {\n        return new ArrayList<>(logs);\n    }\n\n    public Map<DeliveryStatus, Integer> getDeliveryStats() {\n        Map<DeliveryStatus, Integer> stats = new HashMap<>();\n        for (NotificationLog log : logs) {\n            stats.merge(log.getStatus(), 1, Integer::sum);\n        }\n        return stats;\n    }\n\n    public Map<ChannelType, Integer> getChannelStats() {\n        Map<ChannelType, Integer> stats = new HashMap<>();\n        for (NotificationLog log : logs) {\n            stats.merge(log.getChannel(), 1, Integer::sum);\n        }\n        return stats;\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"notificationlogjava",children:"NotificationLog.java"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'import java.util.Date;\n\npublic class NotificationLog {\n    private String notificationId;\n    private String userId;\n    private ChannelType channel;\n    private DeliveryStatus status;\n    private String errorMessage;\n    private Date timestamp;\n\n    public NotificationLog(String notificationId, String userId, ChannelType channel,\n                          DeliveryStatus status, String errorMessage, Date timestamp) {\n        this.notificationId = notificationId;\n        this.userId = userId;\n        this.channel = channel;\n        this.status = status;\n        this.errorMessage = errorMessage;\n        this.timestamp = timestamp;\n    }\n\n    @Override\n    public String toString() {\n        return String.format("[%s] Notification %s to user %s via %s: %s%s",\n            timestamp, notificationId, userId, channel, status,\n            errorMessage != null ? " - " + errorMessage : "");\n    }\n\n    // Getters\n    public String getNotificationId() { return notificationId; }\n    public String getUserId() { return userId; }\n    public ChannelType getChannel() { return channel; }\n    public DeliveryStatus getStatus() { return status; }\n    public String getErrorMessage() { return errorMessage; }\n    public Date getTimestamp() { return timestamp; }\n}\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"design-patterns",children:"Design Patterns"}),"\n",(0,t.jsxs)(n.h3,{id:"1-singleton-pattern",children:["1. ",(0,t.jsx)(n.strong,{children:"Singleton Pattern"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Used In"}),": ",(0,t.jsx)(n.code,{children:"NotificationService"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Purpose"}),": Ensures single instance of the notification service across the application."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"public static synchronized NotificationService getInstance() {\n    if (instance == null) {\n        instance = new NotificationService();\n    }\n    return instance;\n}\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"2-strategy-pattern",children:["2. ",(0,t.jsx)(n.strong,{children:"Strategy Pattern"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Used In"}),": ",(0,t.jsx)(n.code,{children:"NotificationChannel"})," interface with multiple implementations"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Purpose"}),": Different delivery strategies for different channels while maintaining a common interface."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"public interface NotificationChannel {\n    DeliveryResult send(Notification notification);\n}\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"3-template-method-pattern",children:["3. ",(0,t.jsx)(n.strong,{children:"Template Method Pattern"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Used In"}),": ",(0,t.jsx)(n.code,{children:"NotificationTemplate"})," and ",(0,t.jsx)(n.code,{children:"TemplateEngine"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Purpose"}),": Define the skeleton of template rendering while allowing customization."]}),"\n",(0,t.jsxs)(n.h3,{id:"4-observer-pattern-implicit",children:["4. ",(0,t.jsx)(n.strong,{children:"Observer Pattern"})," (Implicit)"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Can Be Extended"}),": Notify subscribers when notification status changes"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Future enhancement\npublic interface NotificationObserver {\n    void onStatusChanged(Notification notification, NotificationStatus oldStatus, NotificationStatus newStatus);\n}\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"5-factory-pattern-can-be-extended",children:["5. ",(0,t.jsx)(n.strong,{children:"Factory Pattern"})," (Can Be Extended)"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Purpose"}),": Create different notification types"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"public class NotificationFactory {\n    public static Notification createTransactional(String recipientId, String templateId) {\n        Notification n = new Notification(recipientId, NotificationType.TRANSACTIONAL, NotificationPriority.HIGH);\n        n.setTemplateId(templateId);\n        return n;\n    }\n}\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"6-builder-pattern-can-be-extended",children:["6. ",(0,t.jsx)(n.strong,{children:"Builder Pattern"})," (Can Be Extended)"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Purpose"}),": Fluent API for building complex notifications"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"public class NotificationBuilder {\n    private Notification notification;\n\n    public NotificationBuilder(String recipientId) {\n        this.notification = new Notification(recipientId, NotificationType.TRANSACTIONAL, NotificationPriority.MEDIUM);\n    }\n\n    public NotificationBuilder withSubject(String subject) {\n        notification.setSubject(subject);\n        return this;\n    }\n\n    public NotificationBuilder withContent(String content) {\n        notification.setContent(content);\n        return this;\n    }\n\n    public NotificationBuilder addChannel(ChannelType channel) {\n        notification.addChannel(channel);\n        return this;\n    }\n\n    public Notification build() {\n        return notification;\n    }\n}\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"7-chain-of-responsibility-can-be-extended",children:["7. ",(0,t.jsx)(n.strong,{children:"Chain of Responsibility"})," (Can Be Extended)"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Purpose"}),": Process notifications through validation, filtering, transformation chain"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"testing--demo",children:"Testing & Demo"}),"\n",(0,t.jsx)(n.h3,{id:"notificationsystemdemojava",children:"NotificationSystemDemo.java"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'import java.util.*;\n\npublic class NotificationSystemDemo {\n    public static void main(String[] args) throws InterruptedException {\n        System.out.println("=== Notification System Demo ===\\n");\n\n        NotificationService service = NotificationService.getInstance();\n\n        // Setup templates\n        setupTemplates(service);\n\n        // Setup user preferences\n        setupUserPreferences(service);\n\n        // Demo 1: Simple Email Notification\n        System.out.println("--- Demo 1: Simple Email Notification ---");\n        demoSimpleEmail(service);\n\n        // Demo 2: Multi-Channel Notification\n        System.out.println("\\n--- Demo 2: Multi-Channel Notification ---");\n        demoMultiChannel(service);\n\n        // Demo 3: Template-Based Notification\n        System.out.println("\\n--- Demo 3: Template-Based Notification ---");\n        demoTemplateNotification(service);\n\n        // Demo 4: Scheduled Notification\n        System.out.println("\\n--- Demo 4: Scheduled Notification ---");\n        demoScheduledNotification(service);\n\n        // Demo 5: User Preferences & Quiet Hours\n        System.out.println("\\n--- Demo 5: User Preferences Test ---");\n        demoUserPreferences(service);\n\n        // Demo 6: Priority Queue\n        System.out.println("\\n--- Demo 6: Priority Queue Handling ---");\n        demoPriorityQueue(service);\n\n        // Demo 7: Rate Limiting\n        System.out.println("\\n--- Demo 7: Rate Limiting ---");\n        demoRateLimiting(service);\n\n        // Display Statistics\n        System.out.println("\\n--- Notification Statistics ---");\n        displayStatistics(service);\n\n        // Cleanup\n        System.out.println("\\n--- Shutting down ---");\n        service.shutdown();\n\n        System.out.println("\\n=== Demo Complete ===");\n    }\n\n    private static void setupTemplates(NotificationService service) {\n        TemplateEngine engine = service.getTemplateEngine();\n\n        // Welcome email template\n        NotificationTemplate welcomeEmail = new NotificationTemplate(\n            "welcome_email",\n            ChannelType.EMAIL,\n            "Welcome to {{serviceName}}!",\n            "Hi {{userName}},\\n\\nWelcome to {{serviceName}}! We\'re excited to have you on board.\\n\\nBest regards,\\nThe Team"\n        );\n        engine.registerTemplate(welcomeEmail);\n\n        // Order confirmation template\n        NotificationTemplate orderConfirm = new NotificationTemplate(\n            "order_confirmation",\n            ChannelType.EMAIL,\n            "Order #{{orderId}} Confirmed",\n            "Hi {{userName}},\\n\\nYour order #{{orderId}} has been confirmed.\\nTotal: ${{amount}}\\n\\nThank you for your purchase!"\n        );\n        engine.registerTemplate(orderConfirm);\n\n        // SMS alert template\n        NotificationTemplate smsAlert = new NotificationTemplate(\n            "sms_alert",\n            ChannelType.SMS,\n            null,\n            "ALERT: {{message}}"\n        );\n        engine.registerTemplate(smsAlert);\n\n        System.out.println("Templates registered successfully\\n");\n    }\n\n    private static void setupUserPreferences(NotificationService service) {\n        PreferenceManager prefManager = service.getPreferenceManager();\n\n        // User 1: All channels enabled\n        UserPreference user1Pref = prefManager.getUserPreference("user-001");\n\n        // User 2: Email only, with quiet hours\n        UserPreference user2Pref = prefManager.getUserPreference("user-002");\n        user2Pref.disableChannel(ChannelType.SMS);\n        user2Pref.disableChannel(ChannelType.PUSH);\n        user2Pref.setQuietHours(22, 8); // 10 PM to 8 AM\n        prefManager.updatePreference("user-002", user2Pref);\n\n        System.out.println("User preferences configured\\n");\n    }\n\n    private static void demoSimpleEmail(NotificationService service) {\n        Notification notification = new Notification(\n            "user-001",\n            NotificationType.TRANSACTIONAL,\n            NotificationPriority.HIGH\n        );\n        notification.setSubject("Account Verification");\n        notification.setContent("Please verify your email address by clicking the link below.");\n        notification.addChannel(ChannelType.EMAIL);\n\n        String notificationId = service.sendNotification(notification);\n        System.out.println("Email notification sent with ID: " + notificationId);\n    }\n\n    private static void demoMultiChannel(NotificationService service) {\n        Notification notification = new Notification(\n            "user-001",\n            NotificationType.ALERT,\n            NotificationPriority.CRITICAL\n        );\n        notification.setSubject("Security Alert");\n        notification.setContent("Unusual login detected from a new device.");\n        notification.addChannel(ChannelType.EMAIL);\n        notification.addChannel(ChannelType.SMS);\n        notification.addChannel(ChannelType.PUSH);\n        notification.addChannel(ChannelType.IN_APP);\n\n        String notificationId = service.sendNotification(notification);\n        System.out.println("Multi-channel notification sent with ID: " + notificationId);\n    }\n\n    private static void demoTemplateNotification(NotificationService service) {\n        Notification notification = new Notification(\n            "user-001",\n            NotificationType.TRANSACTIONAL,\n            NotificationPriority.HIGH\n        );\n\n        // Set template and data\n        notification.setTemplateId(service.getTemplateEngine()\n            .getTemplateByName("welcome_email", ChannelType.EMAIL).getId());\n\n        Map<String, Object> data = new HashMap<>();\n        data.put("userName", "John Doe");\n        data.put("serviceName", "NotifyHub");\n        notification.setData(data);\n        notification.addChannel(ChannelType.EMAIL);\n\n        String notificationId = service.sendNotification(notification);\n        System.out.println("Template-based notification sent with ID: " + notificationId);\n    }\n\n    private static void demoScheduledNotification(NotificationService service) {\n        Notification notification = new Notification(\n            "user-001",\n            NotificationType.REMINDER,\n            NotificationPriority.MEDIUM\n        );\n        notification.setSubject("Reminder: Meeting Tomorrow");\n        notification.setContent("Don\'t forget about your meeting tomorrow at 10 AM.");\n        notification.addChannel(ChannelType.EMAIL);\n        notification.addChannel(ChannelType.PUSH);\n\n        // Schedule for 5 seconds from now\n        Calendar cal = Calendar.getInstance();\n        cal.add(Calendar.SECOND, 5);\n        Date scheduledTime = cal.getTime();\n\n        String notificationId = service.scheduleNotification(notification, scheduledTime);\n        System.out.println("Notification scheduled for: " + scheduledTime);\n        System.out.println("Scheduled notification ID: " + notificationId);\n    }\n\n    private static void demoUserPreferences(NotificationService service) {\n        // This user has SMS disabled\n        Notification notification = new Notification(\n            "user-002",\n            NotificationType.MARKETING,\n            NotificationPriority.LOW\n        );\n        notification.setSubject("Special Offer");\n        notification.setContent("Get 20% off your next purchase!");\n        notification.addChannel(ChannelType.EMAIL);\n        notification.addChannel(ChannelType.SMS); // Will be filtered out\n\n        String notificationId = service.sendNotification(notification);\n        System.out.println("Notification with preference filtering: " + notificationId);\n        System.out.println("Note: SMS channel was filtered out based on user preferences");\n    }\n\n    private static void demoPriorityQueue(NotificationService service) {\n        // Send low priority first\n        Notification lowPriority = new Notification(\n            "user-001",\n            NotificationType.MARKETING,\n            NotificationPriority.LOW\n        );\n        lowPriority.setSubject("Newsletter");\n        lowPriority.setContent("Check out our latest articles.");\n        lowPriority.addChannel(ChannelType.EMAIL);\n\n        // Then critical priority\n        Notification criticalPriority = new Notification(\n            "user-001",\n            NotificationType.ALERT,\n            NotificationPriority.CRITICAL\n        );\n        criticalPriority.setSubject("System Down");\n        criticalPriority.setContent("Critical system failure detected!");\n        criticalPriority.addChannel(ChannelType.EMAIL);\n        criticalPriority.addChannel(ChannelType.SMS);\n\n        // Schedule both\n        Calendar future = Calendar.getInstance();\n        future.add(Calendar.SECOND, 3);\n\n        service.scheduleNotification(lowPriority, future.getTime());\n        service.scheduleNotification(criticalPriority, future.getTime());\n\n        System.out.println("Queued notifications with different priorities");\n        System.out.println("Queue size by priority: " +\n            service.getQueue().getQueueSizeByPriority());\n    }\n\n    private static void demoRateLimiting(NotificationService service) {\n        System.out.println("Sending multiple notifications to test rate limiting...");\n\n        for (int i = 0; i < 5; i++) {\n            Notification notification = new Notification(\n                "user-003",\n                NotificationType.SOCIAL,\n                NotificationPriority.LOW\n            );\n            notification.setSubject("New Message #" + (i + 1));\n            notification.setContent("You have a new message.");\n            notification.addChannel(ChannelType.PUSH);\n\n            String id = service.sendNotification(notification);\n            System.out.println("Sent notification " + (i + 1) + ": " + id);\n        }\n    }\n\n    private static void displayStatistics(NotificationService service) {\n        System.out.println("Total notifications in queue: " +\n            service.getQueue().getQueueSize());\n\n        Map<NotificationPriority, Integer> queueStats =\n            service.getQueue().getQueueSizeByPriority();\n        System.out.println("Queue breakdown by priority:");\n        for (Map.Entry<NotificationPriority, Integer> entry : queueStats.entrySet()) {\n            System.out.println("  " + entry.getKey() + ": " + entry.getValue());\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"scalability-considerations",children:"Scalability Considerations"}),"\n",(0,t.jsx)(n.h3,{id:"current-implementation-limitations",children:"Current Implementation Limitations"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"In-Memory Storage"}),": All data stored in memory (not persistent)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Single Instance"}),": No distributed processing"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Synchronous Processing"}),": Limited throughput"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"No Persistence"}),": Data lost on restart"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"production-ready-enhancements",children:"Production-Ready Enhancements"}),"\n",(0,t.jsx)(n.h4,{id:"1-database-integration",children:"1. Database Integration"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Use JPA/Hibernate for persistence\n@Entity\npublic class Notification {\n    @Id\n    private String id;\n\n    @ManyToOne\n    private User recipient;\n\n    // Other fields...\n}\n"})}),"\n",(0,t.jsx)(n.h4,{id:"2-message-queue-integration",children:"2. Message Queue Integration"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// Use Kafka, RabbitMQ, or AWS SQS\npublic class KafkaNotificationQueue {\n    private KafkaProducer<String, Notification> producer;\n\n    public void enqueue(Notification notification) {\n        ProducerRecord<String, Notification> record =\n            new ProducerRecord<>("notifications", notification);\n        producer.send(record);\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"3-distributed-processing",children:"3. Distributed Processing"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Service 1  \u2502      \u2502  Service 2  \u2502      \u2502  Service 3  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502                    \u2502                    \u2502\n       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                            \u2502\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502  Kafka Cluster \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                            \u2502\n       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n       \u2502                    \u2502                    \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Worker 1   \u2502      \u2502  Worker 2   \u2502      \u2502  Worker 3   \u2502\n\u2502  (Email)    \u2502      \u2502   (SMS)     \u2502      \u2502   (Push)    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,t.jsx)(n.h4,{id:"4-caching-strategy",children:"4. Caching Strategy"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// Use Redis for caching\npublic class RedisCacheManager {\n    private RedisTemplate<String, Object> redisTemplate;\n\n    public UserPreference getUserPreference(String userId) {\n        String key = "user:pref:" + userId;\n        UserPreference cached = (UserPreference) redisTemplate.opsForValue().get(key);\n\n        if (cached == null) {\n            cached = loadFromDatabase(userId);\n            redisTemplate.opsForValue().set(key, cached, 1, TimeUnit.HOURS);\n        }\n\n        return cached;\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"5-monitoring--observability",children:"5. Monitoring & Observability"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// Integrate with Prometheus, Grafana, ELK\npublic class MetricsCollector {\n    private MeterRegistry registry;\n\n    public void recordNotificationSent(ChannelType channel) {\n        Counter.builder("notifications.sent")\n               .tag("channel", channel.name())\n               .register(registry)\n               .increment();\n    }\n\n    public void recordDeliveryTime(ChannelType channel, long milliseconds) {\n        Timer.builder("notifications.delivery.time")\n             .tag("channel", channel.name())\n             .register(registry)\n             .record(milliseconds, TimeUnit.MILLISECONDS);\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"6-circuit-breaker-pattern",children:"6. Circuit Breaker Pattern"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// Use Resilience4j\n@CircuitBreaker(name = "emailService", fallbackMethod = "emailFallback")\npublic DeliveryResult send(Notification notification) {\n    return emailChannel.send(notification);\n}\n\npublic DeliveryResult emailFallback(Notification notification, Exception ex) {\n    // Log failure and queue for retry\n    return new DeliveryResult(notification.getId(), ChannelType.EMAIL)\n        .markFailed("Circuit breaker open: " + ex.getMessage());\n}\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"advanced-features",children:"Advanced Features"}),"\n",(0,t.jsx)(n.h3,{id:"1-batch-notifications",children:"1. Batch Notifications"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"public class BatchNotificationService {\n    public void sendBatch(List<Notification> notifications) {\n        Map<ChannelType, List<Notification>> grouped = notifications.stream()\n            .collect(Collectors.groupingBy(n -> n.getChannels().get(0)));\n\n        for (Map.Entry<ChannelType, List<Notification>> entry : grouped.entrySet()) {\n            NotificationChannel channel = channels.get(entry.getKey());\n            if (channel instanceof BatchCapable) {\n                ((BatchCapable) channel).sendBatch(entry.getValue());\n            }\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"2-ab-testing-support",children:"2. A/B Testing Support"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'public class ABTestingManager {\n    public NotificationTemplate selectTemplate(String baseTemplateId, String userId) {\n        // 50/50 split\n        int variant = Math.abs(userId.hashCode() % 2);\n        return variant == 0 ?\n            getTemplate(baseTemplateId + "_A") :\n            getTemplate(baseTemplateId + "_B");\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"3-localization-support",children:"3. Localization Support"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'public class LocalizationEngine {\n    private Map<String, Map<String, String>> translations;\n\n    public String translate(String key, String language) {\n        return translations.getOrDefault(language, new HashMap<>())\n                         .getOrDefault(key, key);\n    }\n\n    public NotificationTemplate getLocalizedTemplate(String templateId, String language) {\n        // Return language-specific template\n        return templates.get(templateId + "_" + language);\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"4-webhook-signature-verification",children:"4. Webhook Signature Verification"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'public class WebhookSecurityManager {\n    public String generateSignature(String payload, String secret) {\n        try {\n            Mac mac = Mac.getInstance("HmacSHA256");\n            SecretKeySpec secretKey = new SecretKeySpec(secret.getBytes(), "HmacSHA256");\n            mac.init(secretKey);\n            byte[] hash = mac.doFinal(payload.getBytes());\n            return Base64.getEncoder().encodeToString(hash);\n        } catch (Exception e) {\n            throw new RuntimeException("Failed to generate signature", e);\n        }\n    }\n\n    public boolean verifySignature(String payload, String signature, String secret) {\n        String computed = generateSignature(payload, secret);\n        return MessageDigest.isEqual(\n            computed.getBytes(),\n            signature.getBytes()\n        );\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"5-analytics--reporting",children:"5. Analytics & Reporting"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'public class NotificationAnalytics {\n    public NotificationReport generateReport(Date startDate, Date endDate) {\n        List<NotificationLog> logs = getLogsBetween(startDate, endDate);\n\n        return NotificationReport.builder()\n            .totalSent(logs.size())\n            .deliveryRate(calculateDeliveryRate(logs))\n            .averageDeliveryTime(calculateAverageTime(logs))\n            .channelBreakdown(getChannelBreakdown(logs))\n            .failureReasons(getFailureReasons(logs))\n            .build();\n    }\n\n    public Map<String, Double> getEngagementMetrics(String userId) {\n        // Calculate open rate, click rate, etc.\n        return Map.of(\n            "openRate", 0.45,\n            "clickRate", 0.23,\n            "unsubscribeRate", 0.02\n        );\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"6-idempotency-support",children:"6. Idempotency Support"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"public class IdempotencyManager {\n    private Map<String, String> idempotencyKeys;\n\n    public boolean isDuplicate(String idempotencyKey) {\n        return idempotencyKeys.containsKey(idempotencyKey);\n    }\n\n    public void recordRequest(String idempotencyKey, String notificationId) {\n        idempotencyKeys.put(idempotencyKey, notificationId);\n    }\n\n    public String getExistingNotificationId(String idempotencyKey) {\n        return idempotencyKeys.get(idempotencyKey);\n    }\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(n.p,{children:"This Notification System design provides:"}),"\n",(0,t.jsxs)(n.h3,{id:"-core-features",children:["\u2705 ",(0,t.jsx)(n.strong,{children:"Core Features"})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Multi-channel support (Email, SMS, Push, In-App, Webhook)"}),"\n",(0,t.jsx)(n.li,{children:"Template management with variable substitution"}),"\n",(0,t.jsx)(n.li,{children:"User preference management with quiet hours"}),"\n",(0,t.jsx)(n.li,{children:"Priority-based queue processing"}),"\n",(0,t.jsx)(n.li,{children:"Retry mechanism with exponential backoff"}),"\n",(0,t.jsx)(n.li,{children:"Rate limiting to prevent spam"}),"\n",(0,t.jsx)(n.li,{children:"Comprehensive logging and analytics"}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"-design-principles",children:["\u2705 ",(0,t.jsx)(n.strong,{children:"Design Principles"})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"SOLID Principles"}),": Single responsibility, Open/closed, Interface segregation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Design Patterns"}),": Singleton, Strategy, Template Method"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Scalability"}),": Ready for distributed processing"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Extensibility"}),": Easy to add new channels and features"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Maintainability"}),": Clean separation of concerns"]}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"-production-considerations",children:["\u2705 ",(0,t.jsx)(n.strong,{children:"Production Considerations"})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Database integration for persistence"}),"\n",(0,t.jsx)(n.li,{children:"Message queue for async processing"}),"\n",(0,t.jsx)(n.li,{children:"Caching for performance"}),"\n",(0,t.jsx)(n.li,{children:"Monitoring and observability"}),"\n",(0,t.jsx)(n.li,{children:"Circuit breaker for resilience"}),"\n",(0,t.jsx)(n.li,{children:"Security and compliance"}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"-future-enhancements",children:["\ud83d\ude80 ",(0,t.jsx)(n.strong,{children:"Future Enhancements"})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Machine learning for optimal send times"}),"\n",(0,t.jsx)(n.li,{children:"Advanced segmentation and targeting"}),"\n",(0,t.jsx)(n.li,{children:"Real-time delivery tracking"}),"\n",(0,t.jsx)(n.li,{children:"Interactive notifications"}),"\n",(0,t.jsx)(n.li,{children:"Rich media support"}),"\n",(0,t.jsx)(n.li,{children:"Cross-platform unification"}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}}}]);