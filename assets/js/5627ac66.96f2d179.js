"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[2271],{28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>d});var l=t(96540);const o={},s=l.createContext(o);function r(e){const n=l.useContext(s);return l.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),l.createElement(s.Provider,{value:n},e.children)}},42238:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>d,toc:()=>a});var l=t(74848),o=t(28453);const s={},r="DFS & BFS on HTML",d={id:"WebDev/HTML5/BFSDFS",title:"DFS & BFS on HTML",description:"Find all descendants of a given element (DFS)",source:"@site/docs/WebDev/HTML5/BFSDFS.mdx",sourceDirName:"WebDev/HTML5",slug:"/WebDev/HTML5/BFSDFS",permalink:"/dev.enigma/docs/WebDev/HTML5/BFSDFS",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/WebDev/HTML5/BFSDFS.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Tailwind CSS Cheatsheet",permalink:"/dev.enigma/docs/WebDev/CSS3/TailwindCSS"},next:{title:"Browser Hinting Guide",permalink:"/dev.enigma/docs/WebDev/HTML5/BrowserHinting"}},i={},a=[{value:"Find all descendants of a given element (DFS)",id:"find-all-descendants-of-a-given-element-dfs",level:2},{value:"Find all ancestors of a given element (DFS)",id:"find-all-ancestors-of-a-given-element-dfs",level:2},{value:"Level-order traversal of the DOM tree (BFS)",id:"level-order-traversal-of-the-dom-tree-bfs",level:2},{value:"Find all siblings of a given element (BFS/DFS)",id:"find-all-siblings-of-a-given-element-bfsdfs",level:2},{value:"Find all leaf nodes in the DOM (DFS)",id:"find-all-leaf-nodes-in-the-dom-dfs",level:2},{value:"Find the shortest path between two elements (BFS)",id:"find-the-shortest-path-between-two-elements-bfs",level:2},{value:"Detect cycles in the DOM (DFS)",id:"detect-cycles-in-the-dom-dfs",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"dfs--bfs-on-html",children:"DFS & BFS on HTML"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-JavaScript",children:"// DFS Implementation for DOM traversal\nfunction dfsTraversal(rootNode, callback) {\n    if (!rootNode) return;\n\n    // Process current node\n    callback(rootNode);\n\n    // Recursively process all child nodes\n    const children = rootNode.children;\n    for (let i = 0; i < children.length; i++) {\n        dfsTraversal(children[i], callback);\n    }\n}\n\n// BFS Implementation for DOM traversal\nfunction bfsTraversal(rootNode, callback) {\n    if (!rootNode) return;\n\n    const queue = [rootNode];\n\n    while (queue.length > 0) {\n        const currentNode = queue.shift();\n        callback(currentNode);\n\n        // Add all children to queue\n        const children = currentNode.children;\n        for (let i = 0; i < children.length; i++) {\n            queue.push(children[i]);\n        }\n    }\n}\n\n// Utility function to get element path\nfunction getElementPath(element) {\n    if (!element) return '';\n\n    let path = element.tagName.toLowerCase();\n    if (element.id) {\n        path += `#${element.id}`;\n    } else if (element.className) {\n        path += `.${element.className.split(' ').join('.')}`;\n    }\n    return path;\n}\n\n// Example usage with practical applications\n\n// 1. Find all elements with a specific class\nfunction findElementsByClass(rootNode, className) {\n    const results = [];\n\n    bfsTraversal(rootNode, (node) => {\n        if (node.classList && node.classList.contains(className)) {\n            results.push(node);\n        }\n    });\n\n    return results;\n}\n\n// 2. Create a DOM tree structure representation\nfunction createDOMTree(rootNode) {\n    let tree = '';\n    let depth = 0;\n\n    dfsTraversal(rootNode, (node) => {\n        const indent = '  '.repeat(depth);\n        tree += `${indent}${getElementPath(node)}\\n`;\n        depth++;\n\n        // Decrease depth after processing all children\n        setTimeout(() => depth--, 0);\n    });\n\n    return tree;\n}\n\n// 3. Find the deepest nested element\nfunction findDeepestElement(rootNode) {\n    let maxDepth = 0;\n    let deepestElement = null;\n\n    function dfsWithDepth(node, depth) {\n        if (depth > maxDepth) {\n            maxDepth = depth;\n            deepestElement = node;\n        }\n\n        const children = node.children;\n        for (let i = 0; i < children.length; i++) {\n            dfsWithDepth(children[i], depth + 1);\n        }\n    }\n\n    dfsWithDepth(rootNode, 0);\n    return { element: deepestElement, depth: maxDepth };\n}\n\n// 4. Find all text nodes\nfunction findTextNodes(rootNode) {\n    const textNodes = [];\n\n    function dfsText(node) {\n        // Check for text nodes\n        if (node.nodeType === 3 && node.textContent.trim().length > 0) {\n            textNodes.push(node);\n        }\n\n        // Process child nodes\n        for (let i = 0; i < node.childNodes.length; i++) {\n            dfsText(node.childNodes[i]);\n        }\n    }\n\n    dfsText(rootNode);\n    return textNodes;\n}\n\n// 5. Calculate DOM tree metrics\nfunction getDOMMetrics(rootNode) {\n    let metrics = {\n        totalElements: 0,\n        maxDepth: 0,\n        totalTextNodes: 0,\n        elementTypes: {}\n    };\n\n    function dfsMetrics(node, depth) {\n        metrics.totalElements++;\n        metrics.maxDepth = Math.max(metrics.maxDepth, depth);\n\n        // Count element types\n        const tagName = node.tagName?.toLowerCase();\n        if (tagName) {\n            metrics.elementTypes[tagName] = (metrics.elementTypes[tagName] || 0) + 1;\n        }\n\n        // Count text nodes\n        if (node.nodeType === 3 && node.textContent.trim().length > 0) {\n            metrics.totalTextNodes++;\n        }\n\n        // Process children\n        const children = node.childNodes;\n        for (let i = 0; i < children.length; i++) {\n            dfsMetrics(children[i], depth + 1);\n        }\n    }\n\n    dfsMetrics(rootNode, 0);\n    return metrics;\n}\n\n// Example Usage:\n// HTML structure for testing\nconst sampleHTML = `\n<div id=\"root\">\n    <header class=\"header\">\n        <nav>\n            <ul>\n                <li>Home</li>\n                <li>About</li>\n            </ul>\n        </nav>\n    </header>\n    <main>\n        <article>\n            <h1>Title</h1>\n            <p>Content</p>\n        </article>\n    </main>\n</div>\n`;\n\n// Create a DOM parser for testing\nconst parser = new DOMParser();\nconst doc = parser.parseFromString(sampleHTML, 'text/html');\nconst root = doc.querySelector('#root');\n\n// Test examples\nconsole.log('DFS Traversal:');\ndfsTraversal(root, node => {\n    console.log(getElementPath(node));\n});\n\nconsole.log('\\nBFS Traversal:');\nbfsTraversal(root, node => {\n    console.log(getElementPath(node));\n});\n\nconsole.log('\\nDOM Tree Structure:');\nconsole.log(createDOMTree(root));\n\nconsole.log('\\nDOM Metrics:');\nconsole.log(getDOMMetrics(root));\n\n// Find elements with class\nconst headerElements = findElementsByClass(root, 'header');\nconsole.log('\\nHeader Elements:', headerElements);\n\n// Find deepest element\nconst deepest = findDeepestElement(root);\nconsole.log('\\nDeepest Element:', getElementPath(deepest.element), 'at depth:', deepest.depth);\n\n// Find text nodes\nconst textNodes = findTextNodes(root);\nconsole.log('\\nText Nodes:', textNodes.map(node => node.textContent.trim()));\n"})}),"\n",(0,l.jsx)(n.h2,{id:"find-all-descendants-of-a-given-element-dfs",children:"Find all descendants of a given element (DFS)"}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Problem:"})," Given an element in the DOM (e.g., a div), find all its descendant elements using DFS."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-JavaScript",children:"function findDescendantsDFS(element) {\n    let result = [];\n    function dfs(node) {\n        if (!node) return;\n        result.push(node);\n        for (let child of node.children) {\n            dfs(child);\n        }\n    }\n    dfs(element);\n    return result;\n}\n\n// Example usage\nconst root = document.getElementById('root');\nconsole.log(findDescendantsDFS(root));\n"})}),"\n",(0,l.jsx)(n.h2,{id:"find-all-ancestors-of-a-given-element-dfs",children:"Find all ancestors of a given element (DFS)"}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Problem:"})," Given an element, find all its ancestor elements using DFS."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-JavaScript",children:"function findAncestorsDFS(element) {\n    let result = [];\n    function dfs(node) {\n        if (!node) return;\n        result.push(node);\n        if (node.parentElement) {\n            dfs(node.parentElement);\n        }\n    }\n    dfs(element);\n    return result.reverse(); // To list ancestors from root to the given element\n}\n\n// Example usage\nconst target = document.getElementById('targetElement');\nconsole.log(findAncestorsDFS(target));\n"})}),"\n",(0,l.jsx)(n.h2,{id:"level-order-traversal-of-the-dom-tree-bfs",children:"Level-order traversal of the DOM tree (BFS)"}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Problem:"})," Perform a level-order traversal (BFS) of the DOM tree starting from a given element."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-JavaScript",children:"function levelOrderTraversalBFS(element) {\n    let result = [];\n    let queue = [element];\n\n    while (queue.length > 0) {\n        let node = queue.shift();\n        result.push(node);\n        for (let child of node.children) {\n            queue.push(child);\n        }\n    }\n\n    return result;\n}\n\n// Example usage\nconst root = document.getElementById('root');\nconsole.log(levelOrderTraversalBFS(root));\n"})}),"\n",(0,l.jsx)(n.h2,{id:"find-all-siblings-of-a-given-element-bfsdfs",children:"Find all siblings of a given element (BFS/DFS)"}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Problem:"})," Given an element, find all its sibling elements."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-JavaScript",children:"function findSiblingsBFS(element) {\n    const parent = element.parentElement;\n    if (!parent) return [];\n    const siblings = [];\n    for (let child of parent.children) {\n        if (child !== element) {\n            siblings.push(child);\n        }\n    }\n    return siblings;\n}\n\n// Example usage\nconst target = document.getElementById('targetElement');\nconsole.log(findSiblingsBFS(target));\n"})}),"\n",(0,l.jsx)(n.h2,{id:"find-all-leaf-nodes-in-the-dom-dfs",children:"Find all leaf nodes in the DOM (DFS)"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-JavaScript",children:"function findLeafNodesDFS(element) {\n    let leafNodes = [];\n    function dfs(node) {\n        if (!node) return;\n        if (node.children.length === 0) {\n            leafNodes.push(node);\n        }\n        for (let child of node.children) {\n            dfs(child);\n        }\n    }\n    dfs(element);\n    return leafNodes;\n}\n\n// Example usage\nconst root = document.getElementById('root');\nconsole.log(findLeafNodesDFS(root));\n"})}),"\n",(0,l.jsx)(n.h2,{id:"find-the-shortest-path-between-two-elements-bfs",children:"Find the shortest path between two elements (BFS)"}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Problem:"})," Given two elements in the DOM, find the shortest path between them using BFS."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-JavaScript",children:"function findShortestPathBFS(start, end) {\n    let visited = new Set();\n    let queue = [[start]]; // Queue of paths\n\n    while (queue.length > 0) {\n        let path = queue.shift();\n        let node = path[path.length - 1];\n\n        if (node === end) return path;\n        visited.add(node);\n\n        for (let child of node.children) {\n            if (!visited.has(child)) {\n                queue.push([...path, child]);\n            }\n        }\n    }\n    return null; // No path found\n}\n\n// Example usage\nconst start = document.getElementById('startElement');\nconst end = document.getElementById('endElement');\nconsole.log(findShortestPathBFS(start, end));\n"})}),"\n",(0,l.jsx)(n.h2,{id:"detect-cycles-in-the-dom-dfs",children:"Detect cycles in the DOM (DFS)"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-JavaScript",children:"function hasCycleDFS(element) {\n    let visited = new Set();\n\n    function dfs(node) {\n        if (!node) return false;\n        if (visited.has(node)) return true;\n        visited.add(node);\n\n        for (let child of node.children) {\n            if (dfs(child)) return true;\n        }\n        return false;\n    }\n\n    return dfs(element);\n}\n\n// Example usage\nconst root = document.getElementById('root');\nconsole.log(hasCycleDFS(root));\n"})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(c,{...e})}):c(e)}}}]);