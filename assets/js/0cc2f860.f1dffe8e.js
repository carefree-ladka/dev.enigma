"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[2423],{9708:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>p,frontMatter:()=>o,metadata:()=>a,toc:()=>h});var i=t(4848),r=t(8453);const o={title:"Bipartite Graphs"},s="Checking Bipartite Property of a Graph",a={id:"DSA/DSA with JavaScript/GraphBipartile",title:"Bipartite Graphs",description:"A bipartite graph is a graph where the vertices can be divided into two sets such that no two vertices in the same set are adjacent.",source:"@site/docs/DSA/DSA with JavaScript/GraphBipartile.mdx",sourceDirName:"DSA/DSA with JavaScript",slug:"/DSA/DSA with JavaScript/GraphBipartile",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/GraphBipartile",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with JavaScript/GraphBipartile.mdx",tags:[],version:"current",frontMatter:{title:"Bipartite Graphs"},sidebar:"tutorialSidebar",previous:{title:"Gaussian Elimination",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/GaussianElimination"},next:{title:"Heap\u2019s Algorithm",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/HeapAlgorithm"}},c={},h=[{value:"Steps to Check if a Graph is Bipartite",id:"steps-to-check-if-a-graph-is-bipartite",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"checking-bipartite-property-of-a-graph",children:"Checking Bipartite Property of a Graph"})}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.strong,{children:"bipartite graph"})," is a graph where the vertices can be divided into two sets such that no two vertices in the same set are adjacent."]}),"\n",(0,i.jsx)(n.h2,{id:"steps-to-check-if-a-graph-is-bipartite",children:"Steps to Check if a Graph is Bipartite"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Define the Problem:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"A graph G = (V, E) is bipartite if the nodes V can be split into two groups where every edge (u, v) in E connects nodes in different groups."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Choose a Method:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The problem can be solved using BFS or DFS by attempting to color the graph with two colors."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Algorithm Outline:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Start at any unvisited node and assign it one of the two colors (e.g., 0 or 1)."}),"\n",(0,i.jsx)(n.li,{children:"Traverse all its neighbors and assign them the opposite color."}),"\n",(0,i.jsxs)(n.li,{children:["If a neighbor is found with the same color as the current node, the graph is ",(0,i.jsx)(n.strong,{children:"not bipartite"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Below is an implementation using ",(0,i.jsx)(n.strong,{children:"Breadth-First Search (BFS)"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-JavaScript",children:"function isBipartite(graph) {\n    const color = new Array(graph.length).fill(-1); // Initialize colors as uncolored (-1)\n    \n    for (let i = 0; i < graph.length; i++) {\n        if (color[i] === -1) {\n            if (!bfsCheck(graph, i, color)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nfunction bfsCheck(graph, start, color) {\n    const queue = [start];\n    color[start] = 0; // Assign the first color\n    \n    while (queue.length) {\n        const node = queue.shift();\n        for (const neighbor of graph[node]) {\n            if (color[neighbor] === -1) {\n                color[neighbor] = 1 - color[node]; // Assign opposite color\n                queue.push(neighbor);\n            } else if (color[neighbor] === color[node]) {\n                return false; // Found a conflict\n            }\n        }\n    }\n    return true;\n}\n\n// Example Usage\nconst graph = [\n    [1, 3],    // Node 0 is connected to 1 and 3\n    [0, 2],    // Node 1 is connected to 0 and 2\n    [1, 3],    // Node 2 is connected to 1 and 3\n    [0, 2]     // Node 3 is connected to 0 and 2\n];\n\nconsole.log(isBipartite(graph)); // Output: true\n"})})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>a});var i=t(6540);const r={},o=i.createContext(r);function s(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);