"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[6645],{28453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>l});var t=i(96540);const s={},r=t.createContext(s);function a(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(r.Provider,{value:n},e.children)}},95351:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>p,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var t=i(74848),s=i(28453);const r={},a="SOLID Principles in JavaScript and React",l={id:"WebDev/JavaScript/SOLIDPrinciples",title:"SOLID Principles in JavaScript and React",description:"1. Single Responsibility Principle (SRP)",source:"@site/docs/WebDev/JavaScript/SOLIDPrinciples.mdx",sourceDirName:"WebDev/JavaScript",slug:"/WebDev/JavaScript/SOLIDPrinciples",permalink:"/dev.enigma/docs/WebDev/JavaScript/SOLIDPrinciples",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/WebDev/JavaScript/SOLIDPrinciples.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Regular Expressions Cheatsheet",permalink:"/dev.enigma/docs/WebDev/JavaScript/Regex"},next:{title:"JavaScript Symbols",permalink:"/dev.enigma/docs/WebDev/JavaScript/Symbol"}},o={},c=[{value:"1. Single Responsibility Principle (SRP)",id:"1-single-responsibility-principle-srp",level:2},{value:"\u274c Bad Example",id:"-bad-example",level:3},{value:"\u2705 Good Example",id:"-good-example",level:3},{value:"2. Open/Closed Principle (OCP)",id:"2-openclosed-principle-ocp",level:2},{value:"\u274c Bad Example",id:"-bad-example-1",level:3},{value:"\u2705 Good Example",id:"-good-example-1",level:3},{value:"3. Liskov Substitution Principle (LSP)",id:"3-liskov-substitution-principle-lsp",level:2},{value:"\u274c Bad Example",id:"-bad-example-2",level:3},{value:"\u2705 Good Example",id:"-good-example-2",level:3},{value:"4. Interface Segregation Principle (ISP)",id:"4-interface-segregation-principle-isp",level:2},{value:"\u274c Bad Example",id:"-bad-example-3",level:3},{value:"\u2705 Good Example",id:"-good-example-3",level:3},{value:"5. Dependency Inversion Principle (DIP)",id:"5-dependency-inversion-principle-dip",level:2},{value:"\u274c Bad Example",id:"-bad-example-4",level:3},{value:"\u2705 Good Example",id:"-good-example-4",level:3},{value:"Practical React Example Combining All Principles",id:"practical-react-example-combining-all-principles",level:2},{value:"Benefits of Following SOLID Principles",id:"benefits-of-following-solid-principles",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"solid-principles-in-javascript-and-react",children:"SOLID Principles in JavaScript and React"})}),"\n",(0,t.jsx)(n.h2,{id:"1-single-responsibility-principle-srp",children:"1. Single Responsibility Principle (SRP)"}),"\n",(0,t.jsx)(n.p,{children:"A class/component should have only one reason to change."}),"\n",(0,t.jsx)(n.h3,{id:"-bad-example",children:"\u274c Bad Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"class UserProfile {\n  constructor(user) {\n    this.user = user;\n  }\n\n  saveToDatabase() {\n    // Database logic here\n  }\n\n  formatUserData() {\n    // Data formatting logic\n  }\n\n  renderUserProfile() {\n    // UI rendering logic\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"-good-example",children:"\u2705 Good Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// Data Service\nclass UserService {\n  saveUser(user) {\n    // Database logic here\n  }\n}\n\n// Data Formatter\nclass UserFormatter {\n  format(user) {\n    // Data formatting logic\n  }\n}\n\n// React Component\nconst UserProfile = ({ user }) => {\n  const userService = new UserService();\n  const userFormatter = new UserFormatter();\n\n  const handleSave = () => {\n    const formattedData = userFormatter.format(user);\n    userService.saveUser(formattedData);\n  };\n\n  return (\n    <div>\n      <h1>{user.name}</h1>\n      <button onClick={handleSave}>Save</button>\n    </div>\n  );\n};\n"})}),"\n",(0,t.jsx)(n.h2,{id:"2-openclosed-principle-ocp",children:"2. Open/Closed Principle (OCP)"}),"\n",(0,t.jsx)(n.p,{children:"Software entities should be open for extension but closed for modification."}),"\n",(0,t.jsx)(n.h3,{id:"-bad-example-1",children:"\u274c Bad Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"class Button {\n  constructor(type) {\n    this.type = type;\n  }\n\n  render() {\n    if (this.type === 'primary') {\n      return '<button class=\"primary\">Click</button>';\n    } else if (this.type === 'secondary') {\n      return '<button class=\"secondary\">Click</button>';\n    }\n    // Adding new button types requires modifying existing code\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"-good-example-1",children:"\u2705 Good Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// Abstract base class\nclass ButtonBase {\n  getStyles() {\n    throw new Error('Must implement getStyles');\n  }\n\n  render() {\n    return <button className={this.getStyles()}>{this.props.children}</button>;\n  }\n}\n\n// Extended button types\nclass PrimaryButton extends ButtonBase {\n  getStyles() {\n    return 'bg-blue-500 text-white';\n  }\n}\n\nclass SecondaryButton extends ButtonBase {\n  getStyles() {\n    return 'bg-gray-500 text-white';\n  }\n}\n\n// New button types can be added without modifying existing code\nclass DangerButton extends ButtonBase {\n  getStyles() {\n    return 'bg-red-500 text-white';\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"3-liskov-substitution-principle-lsp",children:"3. Liskov Substitution Principle (LSP)"}),"\n",(0,t.jsx)(n.p,{children:"Derived classes must be substitutable for their base classes."}),"\n",(0,t.jsx)(n.h3,{id:"-bad-example-2",children:"\u274c Bad Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'class Bird {\n  fly() {\n    return "I can fly!";\n  }\n}\n\nclass Penguin extends Bird {\n  fly() {\n    throw new Error("I can\'t fly!"); // Violates LSP\n  }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"-good-example-2",children:"\u2705 Good Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'class Bird {\n  move() {\n    throw new Error(\'Must implement move\');\n  }\n}\n\nclass FlyingBird extends Bird {\n  move() {\n    return "I can fly!";\n  }\n}\n\nclass SwimmingBird extends Bird {\n  move() {\n    return "I can swim!";\n  }\n}\n\n// React Example\nconst BirdComponent = ({ bird }) => {\n  return <div>{bird.move()}</div>;\n};\n'})}),"\n",(0,t.jsx)(n.h2,{id:"4-interface-segregation-principle-isp",children:"4. Interface Segregation Principle (ISP)"}),"\n",(0,t.jsx)(n.p,{children:"A client should not be forced to depend on interfaces it doesn't use."}),"\n",(0,t.jsx)(n.h3,{id:"-bad-example-3",children:"\u274c Bad Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"class UserActions {\n  login(user) { /* ... */ }\n  logout() { /* ... */ }\n  updateProfile(data) { /* ... */ }\n  deleteAccount() { /* ... */ }\n}\n\n// Component forced to implement all methods\nclass UserProfile extends React.Component {\n  userActions = new UserActions();\n  // Must include all methods even if not needed\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"-good-example-3",children:"\u2705 Good Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// Separate interfaces\nclass AuthService {\n  login(user) { /* ... */ }\n  logout() { /* ... */ }\n}\n\nclass ProfileService {\n  updateProfile(data) { /* ... */ }\n}\n\nclass AccountService {\n  deleteAccount() { /* ... */ }\n}\n\n// Components can use only what they need\nconst LoginComponent = () => {\n  const authService = new AuthService();\n  \n  return <button onClick={() => authService.login()}>Login</button>;\n};\n\nconst ProfileEditor = () => {\n  const profileService = new ProfileService();\n  \n  return <button onClick={() => profileService.updateProfile()}>Update</button>;\n};\n"})}),"\n",(0,t.jsx)(n.h2,{id:"5-dependency-inversion-principle-dip",children:"5. Dependency Inversion Principle (DIP)"}),"\n",(0,t.jsx)(n.p,{children:"High-level modules should not depend on low-level modules. Both should depend on abstractions."}),"\n",(0,t.jsx)(n.h3,{id:"-bad-example-4",children:"\u274c Bad Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"class NotificationService {\n  constructor() {\n    this.emailSender = new EmailSender(); // Direct dependency\n  }\n\n  sendNotification(message) {\n    this.emailSender.send(message);\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"-good-example-4",children:"\u2705 Good Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// Abstract interface\nclass NotificationSender {\n  send(message) {\n    throw new Error('Must implement send');\n  }\n}\n\n// Concrete implementations\nclass EmailSender extends NotificationSender {\n  send(message) {\n    // Send email\n  }\n}\n\nclass SMSSender extends NotificationSender {\n  send(message) {\n    // Send SMS\n  }\n}\n\n// React Component using dependency injection\nconst NotificationComponent = ({ notificationSender }) => {\n  const sendNotification = (message) => {\n    notificationSender.send(message);\n  };\n\n  return (\n    <button onClick={() => sendNotification('Hello!')}>\n      Send Notification\n    </button>\n  );\n};\n\n// Usage\nconst App = () => {\n  const emailSender = new EmailSender();\n  const smsSender = new SMSSender();\n\n  return (\n    <>\n      <NotificationComponent notificationSender={emailSender} />\n      <NotificationComponent notificationSender={smsSender} />\n    </>\n  );\n};\n"})}),"\n",(0,t.jsx)(n.h2,{id:"practical-react-example-combining-all-principles",children:"Practical React Example Combining All Principles"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'// 1. Single Responsibility Principle\nconst useUserData = () => {\n  // Data management hook\n};\n\nconst useUserValidation = () => {\n  // Validation logic hook\n};\n\n// 2. Open/Closed Principle\nconst FormField = ({ validator, renderer, ...props }) => {\n  // Extensible form field component\n};\n\n// 3. Liskov Substitution Principle\nconst Input = ({ type = \'text\', ...props }) => {\n  // Base input component\n};\n\nconst EmailInput = (props) => <Input type="email" {...props} />;\nconst PasswordInput = (props) => <Input type="password" {...props} />;\n\n// 4. Interface Segregation Principle\nconst useAuth = () => {\n  // Authentication hook\n};\n\nconst useProfile = () => {\n  // Profile management hook\n};\n\n// 5. Dependency Inversion Principle\nconst UserForm = ({ onSubmit, validation, transformation }) => {\n  const handleSubmit = async (data) => {\n    const isValid = await validation(data);\n    if (isValid) {\n      const transformed = transformation(data);\n      onSubmit(transformed);\n    }\n  };\n\n  return <form onSubmit={handleSubmit}>{/* Form fields */}</form>;\n};\n\n// Complete Example\nconst UserProfile = () => {\n  const { user, updateUser } = useUserData();\n  const { validateUser } = useUserValidation();\n  const { transformUserData } = useUserTransformation();\n\n  return (\n    <UserForm\n      onSubmit={updateUser}\n      validation={validateUser}\n      transformation={transformUserData}\n    >\n      <EmailInput name="email" />\n      <PasswordInput name="password" />\n    </UserForm>\n  );\n};\n'})}),"\n",(0,t.jsx)(n.h2,{id:"benefits-of-following-solid-principles",children:"Benefits of Following SOLID Principles"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Maintainability"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Easier to understand and modify code"}),"\n",(0,t.jsx)(n.li,{children:"Reduced technical debt"}),"\n",(0,t.jsx)(n.li,{children:"Better organization of components"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Testability"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Isolated components are easier to test"}),"\n",(0,t.jsx)(n.li,{children:"Clear dependencies make mocking simpler"}),"\n",(0,t.jsx)(n.li,{children:"Better unit test coverage"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Flexibility"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Easier to extend functionality"}),"\n",(0,t.jsx)(n.li,{children:"Better adaptation to changing requirements"}),"\n",(0,t.jsx)(n.li,{children:"Improved reusability of components"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Scalability"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Better handling of growing complexity"}),"\n",(0,t.jsx)(n.li,{children:"Easier team collaboration"}),"\n",(0,t.jsx)(n.li,{children:"More sustainable codebase"}),"\n"]}),"\n"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);