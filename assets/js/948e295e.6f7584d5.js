"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[4064],{28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>l});var r=t(96540);const s={},a=r.createContext(s);function i(e){const n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(a.Provider,{value:n},e.children)}},97118:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>i,default:()=>m,frontMatter:()=>a,metadata:()=>l,toc:()=>c});var r=t(74848),s=t(28453);const a={},i="Java Stream API",l={id:"Java/JavaStreamAPI",title:"Java Stream API",description:"Table of Contents",source:"@site/docs/Java/JavaStreamAPI.mdx",sourceDirName:"Java",slug:"/Java/JavaStreamAPI",permalink:"/dev.enigma/docs/Java/JavaStreamAPI",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/Java/JavaStreamAPI.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Java Object-Oriented Programming",permalink:"/dev.enigma/docs/Java/JavaOOP"},next:{title:"Java Stream API Cheatsheet",permalink:"/dev.enigma/docs/Java/JavaStreamAPICheatsheet"}},o={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Key Concepts",id:"key-concepts",level:3},{value:"Stream Pipeline",id:"stream-pipeline",level:3},{value:"Stream Creation",id:"stream-creation",level:2},{value:"From Collections",id:"from-collections",level:3},{value:"Builder Pattern",id:"builder-pattern",level:3},{value:"Generate and Iterate",id:"generate-and-iterate",level:3},{value:"Range Streams",id:"range-streams",level:3},{value:"From Files and Other Sources",id:"from-files-and-other-sources",level:3},{value:"Intermediate Operations",id:"intermediate-operations",level:2},{value:"filter()",id:"filter",level:3},{value:"map()",id:"map",level:3},{value:"flatMap()",id:"flatmap",level:3},{value:"distinct()",id:"distinct",level:3},{value:"sorted()",id:"sorted",level:3},{value:"peek()",id:"peek",level:3},{value:"limit() and skip()",id:"limit-and-skip",level:3},{value:"Terminal Operations",id:"terminal-operations",level:2},{value:"forEach()",id:"foreach",level:3},{value:"collect()",id:"collect",level:3},{value:"reduce()",id:"reduce",level:3},{value:"count()",id:"count",level:3},{value:"min() and max()",id:"min-and-max",level:3},{value:"anyMatch(), allMatch(), noneMatch()",id:"anymatch-allmatch-nonematch",level:3},{value:"findFirst() and findAny()",id:"findfirst-and-findany",level:3},{value:"Specialized Streams",id:"specialized-streams",level:2},{value:"IntStream, LongStream, DoubleStream",id:"intstream-longstream-doublestream",level:3},{value:"IntStream",id:"intstream",level:4},{value:"Conversion Between Stream Types",id:"conversion-between-stream-types",level:4},{value:"Collectors",id:"collectors",level:2},{value:"Basic Collectors",id:"basic-collectors",level:3},{value:"Joining",id:"joining",level:3},{value:"Grouping",id:"grouping",level:3},{value:"Partitioning",id:"partitioning",level:3},{value:"Statistical Collectors",id:"statistical-collectors",level:3},{value:"Custom Collectors",id:"custom-collectors",level:3},{value:"Advanced Patterns",id:"advanced-patterns",level:2},{value:"Optional Integration",id:"optional-integration",level:3},{value:"Stream Concatenation",id:"stream-concatenation",level:3},{value:"Conditional Processing",id:"conditional-processing",level:3},{value:"Stream with Side Effects (Debugging)",id:"stream-with-side-effects-debugging",level:3},{value:"Parallel Streams",id:"parallel-streams",level:2},{value:"When to Use Parallel Streams",id:"when-to-use-parallel-streams",level:3},{value:"Thread Safety Considerations",id:"thread-safety-considerations",level:3},{value:"Common DSA Patterns",id:"common-dsa-patterns",level:2},{value:"Two Pointers Pattern",id:"two-pointers-pattern",level:3},{value:"Sliding Window Pattern",id:"sliding-window-pattern",level:3},{value:"Frequency Counting",id:"frequency-counting",level:3},{value:"Array/List Transformations",id:"arraylist-transformations",level:3},{value:"Tree/Graph Traversal Simulation",id:"treegraph-traversal-simulation",level:3},{value:"String Processing Patterns",id:"string-processing-patterns",level:3},{value:"Number Theory Patterns",id:"number-theory-patterns",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Readability Over Performance (in most cases)",id:"1-readability-over-performance-in-most-cases",level:3},{value:"2. Prefer Method References",id:"2-prefer-method-references",level:3},{value:"3. Handle Null Values Properly",id:"3-handle-null-values-properly",level:3},{value:"4. Choose Appropriate Collection Types",id:"4-choose-appropriate-collection-types",level:3},{value:"5. Minimize Stream Operations",id:"5-minimize-stream-operations",level:3},{value:"6. Use Appropriate Terminal Operations",id:"6-use-appropriate-terminal-operations",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"1. Stream Creation Overhead",id:"1-stream-creation-overhead",level:3},{value:"2. Boxing/Unboxing",id:"2-boxingunboxing",level:3},{value:"3. Parallel Stream Considerations",id:"3-parallel-stream-considerations",level:3},{value:"4. Memory Usage",id:"4-memory-usage",level:3},{value:"Error Handling in Streams",id:"error-handling-in-streams",level:2},{value:"1. Using try-catch in Lambdas",id:"1-using-try-catch-in-lambdas",level:3},{value:"2. Custom Exception Handling",id:"2-custom-exception-handling",level:3},{value:"Debugging Streams",id:"debugging-streams",level:2},{value:"1. Using peek() for Debugging",id:"1-using-peek-for-debugging",level:3},{value:"2. Logging Stream Operations",id:"2-logging-stream-operations",level:3},{value:"Java 21+ Stream Features",id:"java-21-stream-features",level:2},{value:"1. Stream.gather() (Preview in Java 22+)",id:"1-streamgather-preview-in-java-22",level:3},{value:"2. Enhanced Pattern Matching with Streams",id:"2-enhanced-pattern-matching-with-streams",level:3},{value:"Real-World Examples",id:"real-world-examples",level:2},{value:"1. Processing CSV Data",id:"1-processing-csv-data",level:3},{value:"2. Log File Analysis",id:"2-log-file-analysis",level:3},{value:"3. API Response Processing",id:"3-api-response-processing",level:3},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"java-stream-api",children:"Java Stream API"})}),"\n",(0,r.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#introduction",children:"Introduction"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#stream-creation",children:"Stream Creation"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#intermediate-operations",children:"Intermediate Operations"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#terminal-operations",children:"Terminal Operations"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#specialized-streams",children:"Specialized Streams"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#collectors",children:"Collectors"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#advanced-patterns",children:"Advanced Patterns"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#parallel-streams",children:"Parallel Streams"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#common-dsa-patterns",children:"Common DSA Patterns"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#best-practices",children:"Best Practices"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#performance-considerations",children:"Performance Considerations"})}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Stream API"})," was introduced in Java 8 to provide a functional programming approach to process collections of data. Streams represent a sequence of elements that can be processed in a declarative way."]}),"\n",(0,r.jsx)(n.h3,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Stream"}),": A sequence of elements supporting sequential and parallel aggregate operations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Lazy Evaluation"}),": Intermediate operations are not executed until a terminal operation is invoked"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Immutable"}),": Streams don't modify the original data source"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"One-time Use"}),": A stream can only be consumed once"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"stream-pipeline",children:"Stream Pipeline"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Data Source \u2192 Intermediate Operations \u2192 Terminal Operation \u2192 Result\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"stream-creation",children:"Stream Creation"}),"\n",(0,r.jsx)(n.h3,{id:"from-collections",children:"From Collections"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'List<String> list = Arrays.asList("apple", "banana", "cherry");\n\n// From Collection\nStream<String> stream1 = list.stream();\nStream<String> parallelStream = list.parallelStream();\n\n// From Array\nString[] array = {"a", "b", "c"};\nStream<String> stream2 = Arrays.stream(array);\nStream<String> stream3 = Stream.of("x", "y", "z");\n'})}),"\n",(0,r.jsx)(n.h3,{id:"builder-pattern",children:"Builder Pattern"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'Stream<String> stream = Stream.<String>builder()\n    .add("first")\n    .add("second")\n    .add("third")\n    .build();\n'})}),"\n",(0,r.jsx)(n.h3,{id:"generate-and-iterate",children:"Generate and Iterate"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"// Generate infinite stream\nStream<Double> randomNumbers = Stream.generate(Math::random)\n    .limit(10);\n\n// Iterate with seed and function\nStream<Integer> evenNumbers = Stream.iterate(0, n -> n + 2)\n    .limit(10); // 0, 2, 4, 6, 8, 10, 12, 14, 16, 18\n\n// Java 9+ - Iterate with predicate\nStream<Integer> numbers = Stream.iterate(1, n -> n <= 100, n -> n + 1);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"range-streams",children:"Range Streams"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"// IntStream range\nIntStream.range(1, 5)          // 1, 2, 3, 4 (exclusive end)\n    .forEach(System.out::println);\n\nIntStream.rangeClosed(1, 5)    // 1, 2, 3, 4, 5 (inclusive end)\n    .forEach(System.out::println);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"from-files-and-other-sources",children:"From Files and Other Sources"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'// From file lines\ntry (Stream<String> lines = Files.lines(Paths.get("file.txt"))) {\n    lines.filter(line -> line.length() > 10)\n         .forEach(System.out::println);\n}\n\n// From string characters\n"hello".chars()\n    .mapToObj(c -> (char) c)\n    .forEach(System.out::println);\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"intermediate-operations",children:"Intermediate Operations"}),"\n",(0,r.jsxs)(n.p,{children:["Intermediate operations return a new Stream and are ",(0,r.jsx)(n.strong,{children:"lazy"})," - they're not executed until a terminal operation is called."]}),"\n",(0,r.jsx)(n.h3,{id:"filter",children:"filter()"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Signature"}),": ",(0,r.jsx)(n.code,{children:"Stream<T> filter(Predicate<? super T> predicate)"}),"\n",(0,r.jsx)(n.strong,{children:"Purpose"}),": Keep elements that match the predicate"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n\n// Filter even numbers\nList<Integer> evens = numbers.stream()\n    .filter(n -> n % 2 == 0)\n    .collect(Collectors.toList()); // [2, 4, 6, 8, 10]\n\n// Filter strings by length\nList<String> words = Arrays.asList("java", "stream", "api", "filter");\nList<String> longWords = words.stream()\n    .filter(word -> word.length() > 3)\n    .collect(Collectors.toList()); // ["java", "stream", "filter"]\n\n// Multiple filters (chaining)\nList<Integer> result = numbers.stream()\n    .filter(n -> n > 3)\n    .filter(n -> n < 8)\n    .collect(Collectors.toList()); // [4, 5, 6, 7]\n'})}),"\n",(0,r.jsx)(n.h3,{id:"map",children:"map()"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Signature"}),": ",(0,r.jsx)(n.code,{children:"<R> Stream<R> map(Function<? super T, ? extends R> mapper)"}),"\n",(0,r.jsx)(n.strong,{children:"Purpose"}),": Transform each element to another type"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'List<String> words = Arrays.asList("apple", "banana", "cherry");\n\n// Transform to uppercase\nList<String> upperWords = words.stream()\n    .map(String::toUpperCase)\n    .collect(Collectors.toList()); // ["APPLE", "BANANA", "CHERRY"]\n\n// Transform to lengths\nList<Integer> lengths = words.stream()\n    .map(String::length)\n    .collect(Collectors.toList()); // [5, 6, 6]\n\n// Transform objects\nclass Person {\n    String name; int age;\n    Person(String name, int age) { this.name = name; this.age = age; }\n    String getName() { return name; }\n    int getAge() { return age; }\n}\n\nList<Person> people = Arrays.asList(\n    new Person("Alice", 25),\n    new Person("Bob", 30),\n    new Person("Charlie", 35)\n);\n\nList<String> names = people.stream()\n    .map(Person::getName)\n    .collect(Collectors.toList()); // ["Alice", "Bob", "Charlie"]\n\n// Chain transformations\nList<String> processedNames = people.stream()\n    .map(Person::getName)\n    .map(String::toUpperCase)\n    .map(name -> "Mr/Ms " + name)\n    .collect(Collectors.toList());\n'})}),"\n",(0,r.jsx)(n.h3,{id:"flatmap",children:"flatMap()"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Signature"}),": ",(0,r.jsx)(n.code,{children:"<R> Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper)"}),"\n",(0,r.jsx)(n.strong,{children:"Purpose"}),": Flatten nested structures into a single stream"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"// Flatten list of lists\nList<List<Integer>> listOfLists = Arrays.asList(\n    Arrays.asList(1, 2, 3),\n    Arrays.asList(4, 5, 6),\n    Arrays.asList(7, 8, 9)\n);\n\nList<Integer> flattened = listOfLists.stream()\n    .flatMap(Collection::stream)\n    .collect(Collectors.toList()); // [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n// Flatten strings to characters\nList<String> words = Arrays.asList(\"hello\", \"world\");\nList<Character> chars = words.stream()\n    .flatMap(word -> word.chars().mapToObj(c -> (char) c))\n    .collect(Collectors.toList()); // ['h', 'e', 'l', 'l', 'o', 'w', 'o', 'r', 'l', 'd']\n\n// Flatten Optional values\nList<Optional<String>> optionals = Arrays.asList(\n    Optional.of(\"apple\"),\n    Optional.empty(),\n    Optional.of(\"banana\")\n);\n\nList<String> values = optionals.stream()\n    .flatMap(Optional::stream) // Java 9+\n    .collect(Collectors.toList()); // [\"apple\", \"banana\"]\n"})}),"\n",(0,r.jsx)(n.h3,{id:"distinct",children:"distinct()"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Signature"}),": ",(0,r.jsx)(n.code,{children:"Stream<T> distinct()"}),"\n",(0,r.jsx)(n.strong,{children:"Purpose"}),": Remove duplicate elements (uses equals())"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"List<Integer> numbers = Arrays.asList(1, 2, 2, 3, 3, 3, 4, 5);\nList<Integer> unique = numbers.stream()\n    .distinct()\n    .collect(Collectors.toList()); // [1, 2, 3, 4, 5]\n\n// Distinct by property\nList<Person> people = Arrays.asList(/* ... */);\nList<Person> uniqueByName = people.stream()\n    .collect(Collectors.toMap(\n        Person::getName,\n        p -> p,\n        (existing, replacement) -> existing))\n    .values()\n    .stream()\n    .collect(Collectors.toList());\n\n// Or using custom distinctBy (Java 9+ or custom utility)\npublic static <T> Predicate<T> distinctByKey(Function<? super T, ?> keyExtractor) {\n    Set<Object> seen = ConcurrentHashMap.newKeySet();\n    return t -> seen.add(keyExtractor.apply(t));\n}\n\nList<Person> uniqueByAge = people.stream()\n    .filter(distinctByKey(Person::getAge))\n    .collect(Collectors.toList());\n"})}),"\n",(0,r.jsx)(n.h3,{id:"sorted",children:"sorted()"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Signature"}),": ",(0,r.jsx)(n.code,{children:"Stream<T> sorted()"})," or ",(0,r.jsx)(n.code,{children:"Stream<T> sorted(Comparator<? super T> comparator)"}),"\n",(0,r.jsx)(n.strong,{children:"Purpose"}),": Sort elements"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'List<Integer> numbers = Arrays.asList(3, 1, 4, 1, 5, 9, 2, 6);\n\n// Natural order\nList<Integer> sorted = numbers.stream()\n    .sorted()\n    .collect(Collectors.toList()); // [1, 1, 2, 3, 4, 5, 6, 9]\n\n// Reverse order\nList<Integer> reverseSorted = numbers.stream()\n    .sorted(Collections.reverseOrder())\n    .collect(Collectors.toList()); // [9, 6, 5, 4, 3, 2, 1, 1]\n\n// Custom comparator\nList<String> words = Arrays.asList("apple", "pie", "banana", "cherry");\nList<String> sortedByLength = words.stream()\n    .sorted(Comparator.comparing(String::length))\n    .collect(Collectors.toList()); // ["pie", "apple", "banana", "cherry"]\n\n// Multiple criteria sorting\nList<Person> people = Arrays.asList(/* ... */);\nList<Person> sortedPeople = people.stream()\n    .sorted(Comparator.comparing(Person::getAge)\n                     .thenComparing(Person::getName))\n    .collect(Collectors.toList());\n'})}),"\n",(0,r.jsx)(n.h3,{id:"peek",children:"peek()"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Signature"}),": ",(0,r.jsx)(n.code,{children:"Stream<T> peek(Consumer<? super T> action)"}),"\n",(0,r.jsx)(n.strong,{children:"Purpose"}),": Debug/inspect elements without modifying the stream"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);\n\nList<Integer> result = numbers.stream()\n    .peek(n -> System.out.println("Original: " + n))\n    .filter(n -> n % 2 == 0)\n    .peek(n -> System.out.println("After filter: " + n))\n    .map(n -> n * 2)\n    .peek(n -> System.out.println("After map: " + n))\n    .collect(Collectors.toList());\n'})}),"\n",(0,r.jsx)(n.h3,{id:"limit-and-skip",children:"limit() and skip()"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Signatures"}),": ",(0,r.jsx)(n.code,{children:"Stream<T> limit(long maxSize)"}),", ",(0,r.jsx)(n.code,{children:"Stream<T> skip(long n)"}),"\n",(0,r.jsx)(n.strong,{children:"Purpose"}),": Pagination and slicing"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n\n// Take first 5 elements\nList<Integer> first5 = numbers.stream()\n    .limit(5)\n    .collect(Collectors.toList()); // [1, 2, 3, 4, 5]\n\n// Skip first 3 elements\nList<Integer> skip3 = numbers.stream()\n    .skip(3)\n    .collect(Collectors.toList()); // [4, 5, 6, 7, 8, 9, 10]\n\n// Pagination: skip 3, take 4\nList<Integer> page2 = numbers.stream()\n    .skip(3)\n    .limit(4)\n    .collect(Collectors.toList()); // [4, 5, 6, 7]\n\n// Infinite stream with limit\nList<Integer> fibonacci = Stream.iterate(new int[]{0, 1},\n                                       arr -> new int[]{arr[1], arr[0] + arr[1]})\n    .map(arr -> arr[0])\n    .limit(10)\n    .collect(Collectors.toList()); // First 10 Fibonacci numbers\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"terminal-operations",children:"Terminal Operations"}),"\n",(0,r.jsx)(n.p,{children:"Terminal operations produce a result or side effect and close the stream."}),"\n",(0,r.jsx)(n.h3,{id:"foreach",children:"forEach()"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Signature"}),": ",(0,r.jsx)(n.code,{children:"void forEach(Consumer<? super T> action)"}),"\n",(0,r.jsx)(n.strong,{children:"Purpose"}),": Perform an action on each element"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'List<String> words = Arrays.asList("hello", "stream", "world");\n\n// Print each element\nwords.stream().forEach(System.out::println);\n\n// With index (using IntStream)\nIntStream.range(0, words.size())\n    .forEach(i -> System.out.println(i + ": " + words.get(i)));\n'})}),"\n",(0,r.jsx)(n.h3,{id:"collect",children:"collect()"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Signature"}),": ",(0,r.jsx)(n.code,{children:"<R> R collect(Collector<? super T, A, R> collector)"}),"\n",(0,r.jsx)(n.strong,{children:"Purpose"}),": Convert stream to collection or other data structures"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);\n\n// To List\nList<Integer> list = numbers.stream()\n    .filter(n -> n % 2 == 0)\n    .collect(Collectors.toList());\n\n// To Set\nSet<Integer> set = numbers.stream()\n    .collect(Collectors.toSet());\n\n// To specific collection\nLinkedList<Integer> linkedList = numbers.stream()\n    .collect(Collectors.toCollection(LinkedList::new));\n\n// To Array\nInteger[] array = numbers.stream()\n    .toArray(Integer[]::new);\n\n// Join strings\nString joined = Arrays.asList("a", "b", "c").stream()\n    .collect(Collectors.joining(", ")); // "a, b, c"\n'})}),"\n",(0,r.jsx)(n.h3,{id:"reduce",children:"reduce()"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Signatures"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"Optional<T> reduce(BinaryOperator<T> accumulator)"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"T reduce(T identity, BinaryOperator<T> accumulator)"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"<U> U reduce(U identity, BiFunction<U,? super T,U> accumulator, BinaryOperator<U> combiner)"})}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Purpose"}),": Combine elements into a single result"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);\n\n// Sum\nOptional<Integer> sum = numbers.stream()\n    .reduce((a, b) -> a + b);\n\n// Sum with identity\nint sum2 = numbers.stream()\n    .reduce(0, (a, b) -> a + b);\n\n// Using Integer::sum\nint sum3 = numbers.stream()\n    .reduce(0, Integer::sum);\n\n// Product\nint product = numbers.stream()\n    .reduce(1, (a, b) -> a * b);\n\n// Find maximum\nOptional<Integer> max = numbers.stream()\n    .reduce(Integer::max);\n\n// Concatenate strings\nList<String> words = Arrays.asList("Hello", " ", "Stream", " ", "API");\nString sentence = words.stream()\n    .reduce("", (a, b) -> a + b); // "Hello Stream API"\n\n// Complex reduction\nList<Person> people = Arrays.asList(/* ... */);\nint totalAge = people.stream()\n    .map(Person::getAge)\n    .reduce(0, Integer::sum);\n'})}),"\n",(0,r.jsx)(n.h3,{id:"count",children:"count()"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Signature"}),": ",(0,r.jsx)(n.code,{children:"long count()"}),"\n",(0,r.jsx)(n.strong,{children:"Purpose"}),": Count elements"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'List<String> words = Arrays.asList("apple", "banana", "cherry", "date");\n\nlong count = words.stream()\n    .filter(word -> word.length() > 5)\n    .count(); // 2\n\n// Count distinct elements\nlong distinctCount = Arrays.asList(1, 2, 2, 3, 3, 3).stream()\n    .distinct()\n    .count(); // 3\n'})}),"\n",(0,r.jsx)(n.h3,{id:"min-and-max",children:"min() and max()"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Signatures"}),": ",(0,r.jsx)(n.code,{children:"Optional<T> min(Comparator<? super T> comparator)"}),"\n",(0,r.jsx)(n.strong,{children:"Purpose"}),": Find minimum/maximum element"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"List<Integer> numbers = Arrays.asList(3, 1, 4, 1, 5, 9, 2, 6);\n\nOptional<Integer> min = numbers.stream()\n    .min(Integer::compareTo);\n\nOptional<Integer> max = numbers.stream()\n    .max(Integer::compareTo);\n\n// Custom objects\nList<Person> people = Arrays.asList(/* ... */);\nOptional<Person> youngest = people.stream()\n    .min(Comparator.comparing(Person::getAge));\n\nOptional<Person> oldest = people.stream()\n    .max(Comparator.comparing(Person::getAge));\n"})}),"\n",(0,r.jsx)(n.h3,{id:"anymatch-allmatch-nonematch",children:"anyMatch(), allMatch(), noneMatch()"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Signatures"}),": ",(0,r.jsx)(n.code,{children:"boolean anyMatch(Predicate<? super T> predicate)"}),"\n",(0,r.jsx)(n.strong,{children:"Purpose"}),": Test stream elements against predicates"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);\n\nboolean hasEven = numbers.stream()\n    .anyMatch(n -> n % 2 == 0); // true\n\nboolean allPositive = numbers.stream()\n    .allMatch(n -> n > 0); // true\n\nboolean noneNegative = numbers.stream()\n    .noneMatch(n -> n < 0); // true\n\n// Short-circuiting behavior\nboolean hasLargeNumber = Stream.iterate(1, n -> n + 1)\n    .peek(System.out::println) // Only prints until a match is found\n    .anyMatch(n -> n > 1000);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"findfirst-and-findany",children:"findFirst() and findAny()"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Signatures"}),": ",(0,r.jsx)(n.code,{children:"Optional<T> findFirst()"}),", ",(0,r.jsx)(n.code,{children:"Optional<T> findAny()"}),"\n",(0,r.jsx)(n.strong,{children:"Purpose"}),": Find elements"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'List<String> words = Arrays.asList("apple", "banana", "cherry");\n\nOptional<String> first = words.stream()\n    .filter(word -> word.startsWith("b"))\n    .findFirst(); // Optional["banana"]\n\nOptional<String> any = words.parallelStream()\n    .filter(word -> word.length() > 5)\n    .findAny(); // Any matching element (useful in parallel streams)\n\n// With orElse\nString result = words.stream()\n    .filter(word -> word.startsWith("z"))\n    .findFirst()\n    .orElse("Not found");\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"specialized-streams",children:"Specialized Streams"}),"\n",(0,r.jsx)(n.h3,{id:"intstream-longstream-doublestream",children:"IntStream, LongStream, DoubleStream"}),"\n",(0,r.jsx)(n.p,{children:"These specialized streams avoid boxing/unboxing overhead and provide additional methods."}),"\n",(0,r.jsx)(n.h4,{id:"intstream",children:"IntStream"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'// Creation\nIntStream stream1 = IntStream.of(1, 2, 3, 4, 5);\nIntStream stream2 = IntStream.range(1, 10);      // 1 to 9\nIntStream stream3 = IntStream.rangeClosed(1, 10); // 1 to 10\n\n// From arrays\nint[] array = {1, 2, 3, 4, 5};\nIntStream stream4 = Arrays.stream(array);\n\n// Statistical operations\nIntSummaryStatistics stats = IntStream.range(1, 100)\n    .summaryStatistics();\n\nSystem.out.println("Count: " + stats.getCount());\nSystem.out.println("Sum: " + stats.getSum());\nSystem.out.println("Min: " + stats.getMin());\nSystem.out.println("Max: " + stats.getMax());\nSystem.out.println("Average: " + stats.getAverage());\n\n// Math operations\nint sum = IntStream.range(1, 10).sum();          // 45\nOptionalDouble avg = IntStream.range(1, 10).average(); // 5.0\nOptionalInt max = IntStream.of(1, 5, 3, 9, 2).max();  // 9\n\n// Converting between streams\nStream<Integer> boxed = IntStream.range(1, 5).boxed();\nIntStream fromStream = Stream.of(1, 2, 3, 4).mapToInt(Integer::intValue);\n\n// Advanced operations\nIntStream.range(1, 20)\n    .filter(n -> n % 2 == 0)        // Even numbers\n    .map(n -> n * n)                // Square them\n    .limit(5)                       // Take first 5\n    .forEach(System.out::println);  // Print: 4, 16, 36, 64, 100\n'})}),"\n",(0,r.jsx)(n.h4,{id:"conversion-between-stream-types",children:"Conversion Between Stream Types"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'List<String> numbers = Arrays.asList("1", "2", "3", "4", "5");\n\n// String to IntStream\nIntStream intStream = numbers.stream()\n    .mapToInt(Integer::parseInt);\n\n// IntStream to DoubleStream\nDoubleStream doubleStream = intStream\n    .mapToDouble(i -> i * 1.5);\n\n// Back to Stream<Double>\nStream<Double> boxedDoubles = doubleStream.boxed();\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"collectors",children:"Collectors"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"Collectors"})," utility class provides common reduction operations."]}),"\n",(0,r.jsx)(n.h3,{id:"basic-collectors",children:"Basic Collectors"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'List<String> words = Arrays.asList("apple", "banana", "cherry", "date");\n\n// toList, toSet\nList<String> list = words.stream().collect(Collectors.toList());\nSet<String> set = words.stream().collect(Collectors.toSet());\n\n// toMap\nMap<String, Integer> wordLengths = words.stream()\n    .collect(Collectors.toMap(\n        word -> word,              // key\n        String::length             // value\n    ));\n\n// Handling duplicate keys\nMap<Integer, String> lengthToWord = words.stream()\n    .collect(Collectors.toMap(\n        String::length,            // key\n        word -> word,              // value\n        (existing, replacement) -> existing + ", " + replacement // merge function\n    ));\n'})}),"\n",(0,r.jsx)(n.h3,{id:"joining",children:"Joining"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'List<String> words = Arrays.asList("apple", "banana", "cherry");\n\nString joined1 = words.stream()\n    .collect(Collectors.joining());           // "applebananacherry"\n\nString joined2 = words.stream()\n    .collect(Collectors.joining(", "));       // "apple, banana, cherry"\n\nString joined3 = words.stream()\n    .collect(Collectors.joining(", ", "[", "]")); // "[apple, banana, cherry]"\n\n// Transform then join\nString upperJoined = words.stream()\n    .map(String::toUpperCase)\n    .collect(Collectors.joining(" | "));      // "APPLE | BANANA | CHERRY"\n'})}),"\n",(0,r.jsx)(n.h3,{id:"grouping",children:"Grouping"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'class Person {\n    String name; int age; String department;\n    // constructors, getters...\n}\n\nList<Person> people = Arrays.asList(\n    new Person("Alice", 25, "IT"),\n    new Person("Bob", 30, "HR"),\n    new Person("Charlie", 35, "IT"),\n    new Person("David", 28, "HR")\n);\n\n// Group by single field\nMap<String, List<Person>> byDepartment = people.stream()\n    .collect(Collectors.groupingBy(Person::getDepartment));\n\n// Group by age range\nMap<String, List<Person>> byAgeGroup = people.stream()\n    .collect(Collectors.groupingBy(person ->\n        person.getAge() < 30 ? "Young" : "Senior"\n    ));\n\n// Group and count\nMap<String, Long> countByDepartment = people.stream()\n    .collect(Collectors.groupingBy(\n        Person::getDepartment,\n        Collectors.counting()\n    ));\n\n// Group and collect names\nMap<String, List<String>> namesByDepartment = people.stream()\n    .collect(Collectors.groupingBy(\n        Person::getDepartment,\n        Collectors.mapping(Person::getName, Collectors.toList())\n    ));\n\n// Multi-level grouping\nMap<String, Map<String, List<Person>>> byDeptAndAgeGroup = people.stream()\n    .collect(Collectors.groupingBy(\n        Person::getDepartment,\n        Collectors.groupingBy(person ->\n            person.getAge() < 30 ? "Young" : "Senior"\n        )\n    ));\n'})}),"\n",(0,r.jsx)(n.h3,{id:"partitioning",children:"Partitioning"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n\n// Partition by even/odd\nMap<Boolean, List<Integer>> partitioned = numbers.stream()\n    .collect(Collectors.partitioningBy(n -> n % 2 == 0));\n// {false=[1, 3, 5, 7, 9], true=[2, 4, 6, 8, 10]}\n\n// Partition and count\nMap<Boolean, Long> evenOddCount = numbers.stream()\n    .collect(Collectors.partitioningBy(\n        n -> n % 2 == 0,\n        Collectors.counting()\n    ));\n// {false=5, true=5}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"statistical-collectors",children:"Statistical Collectors"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'List<Person> people = Arrays.asList(/* ... */);\n\n// Summary statistics\nIntSummaryStatistics ageStats = people.stream()\n    .collect(Collectors.summarizingInt(Person::getAge));\n\nSystem.out.println("Average age: " + ageStats.getAverage());\nSystem.out.println("Max age: " + ageStats.getMax());\n\n// Average\nDouble averageAge = people.stream()\n    .collect(Collectors.averagingInt(Person::getAge));\n\n// Sum\nInteger totalAge = people.stream()\n    .collect(Collectors.summingInt(Person::getAge));\n'})}),"\n",(0,r.jsx)(n.h3,{id:"custom-collectors",children:"Custom Collectors"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'// Custom collector to create a StringBuilder\npublic static Collector<String, StringBuilder, String> toStringBuilder() {\n    return Collector.of(\n        StringBuilder::new,                    // supplier\n        StringBuilder::append,                 // accumulator\n        StringBuilder::append,                 // combiner\n        StringBuilder::toString                // finisher\n    );\n}\n\n// Usage\nString result = Stream.of("Hello", " ", "World")\n    .collect(toStringBuilder()); // "Hello World"\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"advanced-patterns",children:"Advanced Patterns"}),"\n",(0,r.jsx)(n.h3,{id:"optional-integration",children:"Optional Integration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'List<Person> people = Arrays.asList(/* ... */);\n\n// Find person and transform\nOptional<String> oldestPersonName = people.stream()\n    .max(Comparator.comparing(Person::getAge))\n    .map(Person::getName);\n\n// Chaining operations\nString result = people.stream()\n    .filter(p -> p.getAge() > 30)\n    .findFirst()\n    .map(Person::getName)\n    .map(String::toUpperCase)\n    .orElse("No person found");\n\n// flatMap with Optional\nList<Optional<String>> optionalNames = Arrays.asList(\n    Optional.of("Alice"),\n    Optional.empty(),\n    Optional.of("Bob")\n);\n\nList<String> names = optionalNames.stream()\n    .flatMap(Optional::stream)  // Java 9+\n    .collect(Collectors.toList());\n'})}),"\n",(0,r.jsx)(n.h3,{id:"stream-concatenation",children:"Stream Concatenation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'Stream<String> stream1 = Stream.of("a", "b", "c");\nStream<String> stream2 = Stream.of("d", "e", "f");\n\nStream<String> concatenated = Stream.concat(stream1, stream2);\n// Result: "a", "b", "c", "d", "e", "f"\n\n// Multiple streams\nStream<String> multiConcat = Stream.of(\n        Stream.of("1", "2"),\n        Stream.of("3", "4"),\n        Stream.of("5", "6")\n    )\n    .flatMap(s -> s); // "1", "2", "3", "4", "5", "6"\n'})}),"\n",(0,r.jsx)(n.h3,{id:"conditional-processing",children:"Conditional Processing"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'List<String> words = Arrays.asList("apple", "banana", "cherry");\nboolean processLongWords = true;\n\nStream<String> stream = words.stream();\n\nif (processLongWords) {\n    stream = stream.filter(word -> word.length() > 5);\n}\n\nList<String> result = stream\n    .map(String::toUpperCase)\n    .collect(Collectors.toList());\n'})}),"\n",(0,r.jsx)(n.h3,{id:"stream-with-side-effects-debugging",children:"Stream with Side Effects (Debugging)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n\nList<Integer> result = numbers.stream()\n    .peek(n -> System.out.println("Original: " + n))\n    .filter(n -> n % 2 == 0)\n    .peek(n -> System.out.println("After filter: " + n))\n    .map(n -> n * 2)\n    .peek(n -> System.out.println("After map: " + n))\n    .collect(Collectors.toList());\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"parallel-streams",children:"Parallel Streams"}),"\n",(0,r.jsx)(n.h3,{id:"when-to-use-parallel-streams",children:"When to Use Parallel Streams"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Large datasets (thousands of elements)"}),"\n",(0,r.jsx)(n.li,{children:"CPU-intensive operations"}),"\n",(0,r.jsx)(n.li,{children:"Independent operations (no shared state)"}),"\n",(0,r.jsx)(n.li,{children:"Stateless operations"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"List<Integer> largeList = IntStream.range(1, 1000000)\n    .boxed()\n    .collect(Collectors.toList());\n\n// Sequential processing\nlong sequentialSum = largeList.stream()\n    .mapToLong(Integer::longValue)\n    .sum();\n\n// Parallel processing\nlong parallelSum = largeList.parallelStream()\n    .mapToLong(Integer::longValue)\n    .sum();\n\n// Or convert to parallel\nlong sum = largeList.stream()\n    .parallel()\n    .mapToLong(Integer::longValue)\n    .sum();\n\n// Convert back to sequential\nList<Integer> result = largeList.parallelStream()\n    .filter(n -> n % 2 == 0)\n    .sequential()\n    .limit(10)  // Sequential operations after this\n    .collect(Collectors.toList());\n"})}),"\n",(0,r.jsx)(n.h3,{id:"thread-safety-considerations",children:"Thread Safety Considerations"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'// \u274c Not thread-safe - shared mutable state\nList<Integer> results = new ArrayList<>();\nIntStream.range(1, 1000).parallel()\n    .forEach(results::add); // Race condition!\n\n// \u2705 Thread-safe alternatives\nList<Integer> safeResults = IntStream.range(1, 1000).parallel()\n    .boxed()\n    .collect(Collectors.toList());\n\n// \u2705 Using thread-safe collections\nList<Integer> synchronizedResults = Collections.synchronizedList(new ArrayList<>());\nIntStream.range(1, 1000).parallel()\n    .forEach(synchronizedResults::add);\n\n// \u2705 Using concurrent collectors\nMap<String, List<Integer>> groupedResults = IntStream.range(1, 1000).parallel()\n    .boxed()\n    .collect(Collectors.groupingByConcurrent(\n        n -> n % 2 == 0 ? "even" : "odd"\n    ));\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"common-dsa-patterns",children:"Common DSA Patterns"}),"\n",(0,r.jsx)(n.h3,{id:"two-pointers-pattern",children:"Two Pointers Pattern"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"// Find pair with target sum\npublic boolean hasPairWithSum(int[] arr, int target) {\n    Set<Integer> seen = Arrays.stream(arr)\n        .boxed()\n        .collect(Collectors.toSet());\n\n    return Arrays.stream(arr)\n        .anyMatch(num -> seen.contains(target - num) && target - num != num);\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"sliding-window-pattern",children:"Sliding Window Pattern"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"// Find maximum sum of subarray of size k\npublic int maxSumSubarray(int[] arr, int k) {\n    return IntStream.range(0, arr.length - k + 1)\n        .map(i -> IntStream.range(i, i + k)\n                          .map(j -> arr[j])\n                          .sum())\n        .max()\n        .orElse(0);\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"frequency-counting",children:"Frequency Counting"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"// Character frequency\npublic Map<Character, Long> getCharFrequency(String str) {\n    return str.chars()\n        .mapToObj(c -> (char) c)\n        .collect(Collectors.groupingBy(\n            c -> c,\n            Collectors.counting()\n        ));\n}\n\n// Word frequency\npublic Map<String, Long> getWordFrequency(List<String> words) {\n    return words.stream()\n        .collect(Collectors.groupingBy(\n            String::toLowerCase,\n            Collectors.counting()\n        ));\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"arraylist-transformations",children:"Array/List Transformations"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"// Matrix operations\npublic List<List<Integer>> transpose(List<List<Integer>> matrix) {\n    return IntStream.range(0, matrix.get(0).size())\n        .mapToObj(col -> matrix.stream()\n                              .map(row -> row.get(col))\n                              .collect(Collectors.toList()))\n        .collect(Collectors.toList());\n}\n\n// Find all subarrays\npublic List<List<Integer>> getAllSubarrays(List<Integer> list) {\n    return IntStream.range(0, list.size())\n        .boxed()\n        .flatMap(start -> IntStream.range(start + 1, list.size() + 1)\n                                  .mapToObj(end -> list.subList(start, end)))\n        .collect(Collectors.toList());\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"treegraph-traversal-simulation",children:"Tree/Graph Traversal Simulation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"// Level order traversal simulation using streams\nclass TreeNode {\n    int val;\n    List<TreeNode> children;\n    TreeNode(int val) { this.val = val; this.children = new ArrayList<>(); }\n}\n\npublic List<List<Integer>> levelOrder(TreeNode root) {\n    if (root == null) return new ArrayList<>();\n\n    List<List<TreeNode>> levels = new ArrayList<>();\n    levels.add(Arrays.asList(root));\n\n    return levels.stream()\n        .map(level -> level.stream()\n                          .map(node -> node.val)\n                          .collect(Collectors.toList()))\n        .collect(Collectors.toList());\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"string-processing-patterns",children:"String Processing Patterns"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"// Anagram grouping\npublic List<List<String>> groupAnagrams(String[] strs) {\n    return Arrays.stream(strs)\n        .collect(Collectors.groupingBy(str -> {\n            char[] chars = str.toCharArray();\n            Arrays.sort(chars);\n            return new String(chars);\n        }))\n        .values()\n        .stream()\n        .collect(Collectors.toList());\n}\n\n// Valid parentheses check\npublic boolean isValidParentheses(String s) {\n    Map<Character, Character> pairs = Map.of(')', '(', '}', '{', ']', '[');\n\n    return s.chars()\n        .mapToObj(c -> (char) c)\n        .reduce(new ArrayDeque<Character>(),\n                (stack, ch) -> {\n                    if (pairs.containsKey(ch)) {\n                        if (stack.isEmpty() || stack.pop() != pairs.get(ch)) {\n                            stack.push('X'); // Invalid marker\n                        }\n                    } else {\n                        stack.push(ch);\n                    }\n                    return stack;\n                },\n                (stack1, stack2) -> { stack1.addAll(stack2); return stack1; })\n        .isEmpty();\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"number-theory-patterns",children:"Number Theory Patterns"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"// Prime number generation\npublic List<Integer> sieveOfEratosthenes(int n) {\n    boolean[] isPrime = new boolean[n + 1];\n    Arrays.fill(isPrime, 2, n + 1, true);\n\n    IntStream.rangeClosed(2, (int) Math.sqrt(n))\n        .filter(i -> isPrime[i])\n        .forEach(i -> IntStream.iterate(i * i, j -> j <= n, j -> j + i)\n                              .forEach(j -> isPrime[j] = false));\n\n    return IntStream.rangeClosed(2, n)\n        .filter(i -> isPrime[i])\n        .boxed()\n        .collect(Collectors.toList());\n}\n\n// Fibonacci sequence\npublic List<Integer> fibonacciSequence(int n) {\n    return Stream.iterate(new int[]{0, 1}, arr -> new int[]{arr[1], arr[0] + arr[1]})\n        .limit(n)\n        .map(arr -> arr[0])\n        .collect(Collectors.toList());\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsx)(n.h3,{id:"1-readability-over-performance-in-most-cases",children:"1. Readability Over Performance (in most cases)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"// \u2705 Clear and readable\nList<String> result = words.stream()\n    .filter(word -> word.length() > 3)\n    .map(String::toUpperCase)\n    .sorted()\n    .collect(Collectors.toList());\n\n// \u274c Trying to be too clever\nList<String> result2 = words.stream()\n    .filter(((Predicate<String>) word -> word.length() <= 3).negate())\n    .collect(Collectors.mapping(\n        String::toUpperCase,\n        Collectors.collectingAndThen(\n            Collectors.toList(),\n            list -> { Collections.sort(list); return list; }\n        )\n    ));\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-prefer-method-references",children:"2. Prefer Method References"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"// \u2705 Method references\npeople.stream()\n    .map(Person::getName)\n    .filter(Objects::nonNull)\n    .forEach(System.out::println);\n\n// \u274c Unnecessary lambdas\npeople.stream()\n    .map(person -> person.getName())\n    .filter(name -> name != null)\n    .forEach(name -> System.out.println(name));\n"})}),"\n",(0,r.jsx)(n.h3,{id:"3-handle-null-values-properly",children:"3. Handle Null Values Properly"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'List<String> words = Arrays.asList("apple", null, "banana", null, "cherry");\n\n// \u2705 Filter out nulls\nList<String> nonNulls = words.stream()\n    .filter(Objects::nonNull)\n    .collect(Collectors.toList());\n\n// \u2705 Use Optional for nullable results\nOptional<String> longest = words.stream()\n    .filter(Objects::nonNull)\n    .max(Comparator.comparing(String::length));\n'})}),"\n",(0,r.jsx)(n.h3,{id:"4-choose-appropriate-collection-types",children:"4. Choose Appropriate Collection Types"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"// \u2705 Use Set when uniqueness is required\nSet<String> uniqueWords = words.stream()\n    .collect(Collectors.toSet());\n\n// \u2705 Use LinkedHashSet to preserve order\nSet<String> orderedUniqueWords = words.stream()\n    .collect(Collectors.toCollection(LinkedHashSet::new));\n\n// \u2705 Use TreeSet for sorted unique elements\nSet<String> sortedUniqueWords = words.stream()\n    .collect(Collectors.toCollection(TreeSet::new));\n"})}),"\n",(0,r.jsx)(n.h3,{id:"5-minimize-stream-operations",children:"5. Minimize Stream Operations"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"// \u274c Multiple passes\nList<String> upperWords = words.stream()\n    .map(String::toUpperCase)\n    .collect(Collectors.toList());\n\nList<String> filteredWords = upperWords.stream()\n    .filter(word -> word.length() > 5)\n    .collect(Collectors.toList());\n\n// \u2705 Single pass\nList<String> result = words.stream()\n    .map(String::toUpperCase)\n    .filter(word -> word.length() > 5)\n    .collect(Collectors.toList());\n"})}),"\n",(0,r.jsx)(n.h3,{id:"6-use-appropriate-terminal-operations",children:"6. Use Appropriate Terminal Operations"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"// \u2705 Use anyMatch instead of filter + findAny\nboolean hasLongWord = words.stream()\n    .anyMatch(word -> word.length() > 10);\n\n// \u274c Unnecessary filtering\nboolean hasLongWord2 = words.stream()\n    .filter(word -> word.length() > 10)\n    .findAny()\n    .isPresent();\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,r.jsx)(n.h3,{id:"1-stream-creation-overhead",children:"1. Stream Creation Overhead"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"// \u274c Creating streams for small operations\nint sum = Stream.of(1, 2, 3).mapToInt(Integer::intValue).sum(); // Overkill\n\n// \u2705 Direct calculation for simple cases\nint sum = 1 + 2 + 3;\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-boxingunboxing",children:"2. Boxing/Unboxing"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"// \u274c Unnecessary boxing\nint sum = IntStream.range(1, 1000)\n    .boxed()  // Boxing to Integer\n    .mapToInt(Integer::intValue)  // Unboxing back to int\n    .sum();\n\n// \u2705 Stay with primitives\nint sum = IntStream.range(1, 1000).sum();\n"})}),"\n",(0,r.jsx)(n.h3,{id:"3-parallel-stream-considerations",children:"3. Parallel Stream Considerations"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"// \u2705 Good candidate for parallelization\nlong sum = IntStream.range(1, 10_000_000)\n    .parallel()\n    .filter(n -> isPrime(n))  // CPU-intensive\n    .count();\n\n// \u274c Poor candidate due to ordering requirement\nList<Integer> firstTen = IntStream.range(1, 1000000)\n    .parallel()\n    .limit(10)  // Requires ordering\n    .boxed()\n    .collect(Collectors.toList());\n"})}),"\n",(0,r.jsx)(n.h3,{id:"4-memory-usage",children:"4. Memory Usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"// \u274c Materializing large intermediate collections\nList<String> processed = hugeList.stream()\n    .collect(Collectors.toList())  // Unnecessary collection\n    .stream()\n    .filter(someCondition)\n    .collect(Collectors.toList());\n\n// \u2705 Single stream pipeline\nList<String> processed = hugeList.stream()\n    .filter(someCondition)\n    .collect(Collectors.toList());\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"error-handling-in-streams",children:"Error Handling in Streams"}),"\n",(0,r.jsx)(n.h3,{id:"1-using-try-catch-in-lambdas",children:"1. Using try-catch in Lambdas"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'public static <T, R> Function<T, Optional<R>> wrap(Function<T, R> function) {\n    return input -> {\n        try {\n            return Optional.of(function.apply(input));\n        } catch (Exception e) {\n            return Optional.empty();\n        }\n    };\n}\n\n// Usage\nList<String> numbers = Arrays.asList("1", "2", "invalid", "4");\nList<Integer> validNumbers = numbers.stream()\n    .map(wrap(Integer::parseInt))\n    .flatMap(Optional::stream)\n    .collect(Collectors.toList());\n'})}),"\n",(0,r.jsx)(n.h3,{id:"2-custom-exception-handling",children:"2. Custom Exception Handling"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'public static <T> Predicate<T> handleExceptions(Predicate<T> predicate) {\n    return input -> {\n        try {\n            return predicate.test(input);\n        } catch (Exception e) {\n            System.err.println("Error processing: " + input + ", " + e.getMessage());\n            return false;\n        }\n    };\n}\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"debugging-streams",children:"Debugging Streams"}),"\n",(0,r.jsx)(n.h3,{id:"1-using-peek-for-debugging",children:"1. Using peek() for Debugging"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'List<Integer> result = numbers.stream()\n    .peek(n -> System.out.println("Processing: " + n))\n    .filter(n -> n % 2 == 0)\n    .peek(n -> System.out.println("After filter: " + n))\n    .map(n -> n * 2)\n    .peek(n -> System.out.println("After map: " + n))\n    .collect(Collectors.toList());\n'})}),"\n",(0,r.jsx)(n.h3,{id:"2-logging-stream-operations",children:"2. Logging Stream Operations"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'public static <T> Stream<T> log(Stream<T> stream, String operation) {\n    return stream.peek(item ->\n        System.out.println(operation + ": " + item)\n    );\n}\n\n// Usage\nList<String> result = log(words.stream(), "Input")\n    .filter(word -> word.length() > 3)\n    .collect(Collectors.toList());\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"java-21-stream-features",children:"Java 21+ Stream Features"}),"\n",(0,r.jsx)(n.h3,{id:"1-streamgather-preview-in-java-22",children:"1. Stream.gather() (Preview in Java 22+)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"// Note: This is a preview feature\n// Gather allows custom intermediate operations\n\n// Example: Sliding window\nStream.of(1, 2, 3, 4, 5, 6)\n    .gather(Gatherers.windowSliding(3))\n    .forEach(System.out::println);\n// Output: [1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6]\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-enhanced-pattern-matching-with-streams",children:"2. Enhanced Pattern Matching with Streams"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'// Using pattern matching in filter operations\nrecord Person(String name, int age) {}\nrecord Student(String name, int age, String school) {}\n\nList<Object> people = Arrays.asList(\n    new Person("Alice", 25),\n    new Student("Bob", 20, "MIT"),\n    "Not a person"\n);\n\nList<String> names = people.stream()\n    .filter(obj -> switch (obj) {\n        case Person p -> true;\n        case Student s -> true;\n        default -> false;\n    })\n    .map(obj -> switch (obj) {\n        case Person(var name, var age) -> name;\n        case Student(var name, var age, var school) -> name;\n        default -> "";\n    })\n    .collect(Collectors.toList());\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"real-world-examples",children:"Real-World Examples"}),"\n",(0,r.jsx)(n.h3,{id:"1-processing-csv-data",children:"1. Processing CSV Data"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'public class CsvProcessor {\n\n    record Employee(String name, String department, int salary, int age) {}\n\n    public static void processCsvData(List<String> csvLines) {\n        List<Employee> employees = csvLines.stream()\n            .skip(1) // Skip header\n            .map(line -> line.split(","))\n            .map(parts -> new Employee(\n                parts[0].trim(),\n                parts[1].trim(),\n                Integer.parseInt(parts[2].trim()),\n                Integer.parseInt(parts[3].trim())\n            ))\n            .collect(Collectors.toList());\n\n        // Department-wise analysis\n        Map<String, DoubleSummaryStatistics> deptSalaryStats = employees.stream()\n            .collect(Collectors.groupingBy(\n                Employee::department,\n                Collectors.summarizingDouble(Employee::salary)\n            ));\n\n        // Top 5 highest paid employees\n        List<Employee> topEarners = employees.stream()\n            .sorted(Comparator.comparing(Employee::salary).reversed())\n            .limit(5)\n            .collect(Collectors.toList());\n\n        // Age groups\n        Map<String, Long> ageGroups = employees.stream()\n            .collect(Collectors.groupingBy(\n                emp -> emp.age() < 30 ? "Young" :\n                       emp.age() < 50 ? "Middle" : "Senior",\n                Collectors.counting()\n            ));\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"2-log-file-analysis",children:"2. Log File Analysis"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'public class LogAnalyzer {\n\n    record LogEntry(LocalDateTime timestamp, String level, String message) {}\n\n    public static void analyzeLogFile(Stream<String> logLines) {\n        List<LogEntry> entries = logLines\n            .filter(line -> !line.isEmpty())\n            .map(LogAnalyzer::parseLogLine)\n            .filter(Objects::nonNull)\n            .collect(Collectors.toList());\n\n        // Error count by hour\n        Map<Integer, Long> errorsByHour = entries.stream()\n            .filter(entry -> "ERROR".equals(entry.level()))\n            .collect(Collectors.groupingBy(\n                entry -> entry.timestamp().getHour(),\n                Collectors.counting()\n            ));\n\n        // Most common error messages\n        Map<String, Long> errorMessages = entries.stream()\n            .filter(entry -> "ERROR".equals(entry.level()))\n            .collect(Collectors.groupingBy(\n                LogEntry::message,\n                Collectors.counting()\n            ));\n\n        List<Map.Entry<String, Long>> topErrors = errorMessages.entrySet().stream()\n            .sorted(Map.Entry.<String, Long>comparingByValue().reversed())\n            .limit(10)\n            .collect(Collectors.toList());\n    }\n\n    private static LogEntry parseLogLine(String line) {\n        // Implementation depends on log format\n        return null; // Placeholder\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"3-api-response-processing",children:"3. API Response Processing"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"public class ApiResponseProcessor {\n\n    record User(String id, String name, String email, boolean active) {}\n    record Order(String userId, double amount, LocalDate date) {}\n\n    public static void processUserOrders(List<User> users, List<Order> orders) {\n        // Active users with orders\n        Set<String> usersWithOrders = orders.stream()\n            .map(Order::userId)\n            .collect(Collectors.toSet());\n\n        List<User> activeUsersWithOrders = users.stream()\n            .filter(User::active)\n            .filter(user -> usersWithOrders.contains(user.id()))\n            .collect(Collectors.toList());\n\n        // Monthly revenue\n        Map<YearMonth, Double> monthlyRevenue = orders.stream()\n            .collect(Collectors.groupingBy(\n                order -> YearMonth.from(order.date()),\n                Collectors.summingDouble(Order::amount)\n            ));\n\n        // Top customers by spending\n        Map<String, Double> userSpending = orders.stream()\n            .collect(Collectors.groupingBy(\n                Order::userId,\n                Collectors.summingDouble(Order::amount)\n            ));\n\n        List<Map.Entry<String, Double>> topCustomers = userSpending.entrySet().stream()\n            .sorted(Map.Entry.<String, Double>comparingByValue().reversed())\n            .limit(10)\n            .collect(Collectors.toList());\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h1,{id:"stream-api-practice-problems",children:"Stream API Practice Problems:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\npublic class StreamAPI {\n\n    // 1. Remove duplicates from array\n    public static List<Integer> removeDuplicates(int[] nums) {\n        return Arrays.stream(nums)\n                .distinct()\n                .boxed()\n                .collect(Collectors.toList());\n    }\n\n    // 2. Merge two arrays\n    public static List<Integer> mergeTwoLists(int[] nums1, int[] nums2) {\n        return IntStream.concat(Arrays.stream(nums1), Arrays.stream(nums2))\n                .boxed()\n                .collect(Collectors.toList());\n    }\n\n    // 3. Find maximum element\n    public static Integer findMax(int[] nums) {\n        return Arrays.stream(nums)\n                .boxed()\n                .max(Integer::compareTo)\n                .orElse(null);\n    }\n\n    // 4. Find minimum element\n    public static Integer findMin(int[] nums) {\n        return Arrays.stream(nums)\n                .boxed()\n                .min(Integer::compareTo)\n                .orElse(null);\n    }\n\n    // 5. Filter elements greater than k\n    public static List<Integer> elementsGreaterThan(int[] nums, int k) {\n        return Arrays.stream(nums)\n                .boxed()\n                .filter(num -> num > k)\n                .collect(Collectors.toList());\n    }\n\n    // 6. Convert strings to uppercase\n    public static List<String> toUpperCase(String[] words) {\n        return Arrays.stream(words)\n                .map(String::toUpperCase)\n                .collect(Collectors.toList());\n    }\n\n    // 7. Merge two arrays without duplicates\n    public static List<Integer> mergeTwoListsWithoutDuplicates(int[] nums1, int[] nums2) {\n        return IntStream.concat(Arrays.stream(nums1), Arrays.stream(nums2))\n                .distinct()\n                .boxed()\n                .collect(Collectors.toList());\n    }\n\n    // 8. Find first non-repeating character (Fixed implementation)\n    public static String firstNonRepeatingCharacter(String word) {\n        return word.chars()\n                .mapToObj(c -> (char) c)\n                .collect(Collectors.groupingBy(Function.identity(), LinkedHashMap::new, Collectors.counting()))\n                .entrySet()\n                .stream()\n                .filter(entry -> entry.getValue() == 1)\n                .map(Map.Entry::getKey)\n                .findFirst()\n                .map(String::valueOf)\n                .orElse("No non-repeating character found");\n    }\n\n    // 9. Sum of all elements\n    public static int sumOfElements(int[] nums) {\n        return Arrays.stream(nums).sum();\n    }\n\n    // 10. Average of all elements\n    public static double averageOfElements(int[] nums) {\n        return Arrays.stream(nums)\n                .average()\n                .orElse(0.0);\n    }\n\n    // 11. Count elements greater than k\n    public static long countElementsGreaterThan(int[] nums, int k) {\n        return Arrays.stream(nums)\n                .filter(num -> num > k)\n                .count();\n    }\n\n    // 12. Sort array in ascending order\n    public static List<Integer> sortAscending(int[] nums) {\n        return Arrays.stream(nums)\n                .boxed()\n                .sorted()\n                .collect(Collectors.toList());\n    }\n\n    // 13. Sort array in descending order\n    public static List<Integer> sortDescending(int[] nums) {\n        return Arrays.stream(nums)\n                .boxed()\n                .sorted(Collections.reverseOrder())\n                .collect(Collectors.toList());\n    }\n\n    // 14. Find even numbers\n    public static List<Integer> findEvenNumbers(int[] nums) {\n        return Arrays.stream(nums)\n                .boxed()\n                .filter(num -> num % 2 == 0)\n                .collect(Collectors.toList());\n    }\n\n    // 15. Find odd numbers\n    public static List<Integer> findOddNumbers(int[] nums) {\n        return Arrays.stream(nums)\n                .boxed()\n                .filter(num -> num % 2 != 0)\n                .collect(Collectors.toList());\n    }\n\n    // 16. Square of all numbers\n    public static List<Integer> squareOfNumbers(int[] nums) {\n        return Arrays.stream(nums)\n                .map(num -> num * num)\n                .boxed()\n                .collect(Collectors.toList());\n    }\n\n    // 17. Find second highest element\n    public static Integer findSecondHighest(int[] nums) {\n        return Arrays.stream(nums)\n                .boxed()\n                .distinct()\n                .sorted(Collections.reverseOrder())\n                .skip(1)\n                .findFirst()\n                .orElse(null);\n    }\n\n    // 18. Find second lowest element\n    public static Integer findSecondLowest(int[] nums) {\n        return Arrays.stream(nums)\n                .boxed()\n                .distinct()\n                .sorted()\n                .skip(1)\n                .findFirst()\n                .orElse(null);\n    }\n\n    // 19. Group strings by length\n    public static Map<Integer, List<String>> groupByLength(String[] words) {\n        return Arrays.stream(words)\n                .collect(Collectors.groupingBy(String::length));\n    }\n\n    // 20. Find frequency of each element\n    public static Map<Integer, Long> findFrequency(int[] nums) {\n        return Arrays.stream(nums)\n                .boxed()\n                .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));\n    }\n\n    // 21. Check if all elements are positive\n    public static boolean allPositive(int[] nums) {\n        return Arrays.stream(nums).allMatch(num -> num > 0);\n    }\n\n    // 22. Check if any element is negative\n    public static boolean anyNegative(int[] nums) {\n        return Arrays.stream(nums).anyMatch(num -> num < 0);\n    }\n\n    // 23. Find strings starting with specific character\n    public static List<String> stringsStartingWith(String[] words, char ch) {\n        return Arrays.stream(words)\n                .filter(word -> word.charAt(0) == ch)\n                .collect(Collectors.toList());\n    }\n\n    // 24. Join strings with delimiter\n    public static String joinStrings(String[] words, String delimiter) {\n        return Arrays.stream(words)\n                .collect(Collectors.joining(delimiter));\n    }\n\n    // 25. Find longest string\n    public static String findLongestString(String[] words) {\n        return Arrays.stream(words)\n                .max(Comparator.comparing(String::length))\n                .orElse("");\n    }\n\n    // 26. Find shortest string\n    public static String findShortestString(String[] words) {\n        return Arrays.stream(words)\n                .min(Comparator.comparing(String::length))\n                .orElse("");\n    }\n\n    // 27. Skip first n elements\n    public static List<Integer> skipFirstN(int[] nums, int n) {\n        return Arrays.stream(nums)\n                .skip(n)\n                .boxed()\n                .collect(Collectors.toList());\n    }\n\n    // 28. Take first n elements\n    public static List<Integer> takeFirstN(int[] nums, int n) {\n        return Arrays.stream(nums)\n                .limit(n)\n                .boxed()\n                .collect(Collectors.toList());\n    }\n\n    // 29. Partition even and odd numbers\n    public static Map<Boolean, List<Integer>> partitionEvenOdd(int[] nums) {\n        return Arrays.stream(nums)\n                .boxed()\n                .collect(Collectors.partitioningBy(num -> num % 2 == 0));\n    }\n\n    // 30. Convert to comma separated string\n    public static String toCommaSeparated(int[] nums) {\n        return Arrays.stream(nums)\n                .mapToObj(String::valueOf)\n                .collect(Collectors.joining(", "));\n    }\n\n    public static void main(String[] args) {\n        int[] num1 = {1, 2, 3, 3, 1, 1, 5, 7, 9, 4};\n        int[] num2 = {4, 5, 6, 8, 10, -2};\n        int[] mixedNums = {1, -2, 3, -4, 5, 6, 7, 8, 9};\n        String[] words = {"apple", "banana", "kiwi", "orange", "grape", "a"};\n\n        System.out.println("=== BASIC OPERATIONS ===");\n        System.out.println("1. Distinct Elements: " + removeDuplicates(num1));\n        System.out.println("2. Merged Lists: " + mergeTwoLists(num1, num2));\n        System.out.println("3. Max Element: " + findMax(num2));\n        System.out.println("4. Min Element: " + findMin(num2));\n        System.out.println("5. Elements > 2: " + elementsGreaterThan(num1, 2));\n        System.out.println("6. Uppercase Words: " + toUpperCase(words));\n        System.out.println("7. Merged Without Duplicates: " + mergeTwoListsWithoutDuplicates(num1, num2));\n        System.out.println("8. First Non-Repeating Char in \'hello\': " + firstNonRepeatingCharacter("hello"));\n\n        System.out.println("\\n=== MATHEMATICAL OPERATIONS ===");\n        System.out.println("9. Sum of Elements: " + sumOfElements(num1));\n        System.out.println("10. Average of Elements: " + averageOfElements(num1));\n        System.out.println("11. Count Elements > 2: " + countElementsGreaterThan(num1, 2));\n        System.out.println("16. Square of Numbers: " + squareOfNumbers(new int[]{1, 2, 3, 4}));\n\n        System.out.println("\\n=== SORTING OPERATIONS ===");\n        System.out.println("12. Sort Ascending: " + sortAscending(num1));\n        System.out.println("13. Sort Descending: " + sortDescending(num1));\n        System.out.println("17. Second Highest: " + findSecondHighest(num1));\n        System.out.println("18. Second Lowest: " + findSecondLowest(num1));\n\n        System.out.println("\\n=== FILTERING OPERATIONS ===");\n        System.out.println("14. Even Numbers: " + findEvenNumbers(num1));\n        System.out.println("15. Odd Numbers: " + findOddNumbers(num1));\n        System.out.println("23. Words starting with \'a\': " + stringsStartingWith(words, \'a\'));\n\n        System.out.println("\\n=== GROUPING & FREQUENCY ===");\n        System.out.println("19. Group by Length: " + groupByLength(words));\n        System.out.println("20. Frequency Count: " + findFrequency(num1));\n        System.out.println("29. Partition Even/Odd: " + partitionEvenOdd(num1));\n\n        System.out.println("\\n=== BOOLEAN OPERATIONS ===");\n        System.out.println("21. All Positive (num1): " + allPositive(num1));\n        System.out.println("21. All Positive (mixedNums): " + allPositive(mixedNums));\n        System.out.println("22. Any Negative (num1): " + anyNegative(num1));\n        System.out.println("22. Any Negative (mixedNums): " + anyNegative(mixedNums));\n\n        System.out.println("\\n=== STRING OPERATIONS ===");\n        System.out.println("24. Join with \' | \': " + joinStrings(words, " | "));\n        System.out.println("25. Longest String: " + findLongestString(words));\n        System.out.println("26. Shortest String: " + findShortestString(words));\n        System.out.println("30. Comma Separated: " + toCommaSeparated(new int[]{1, 2, 3, 4, 5}));\n\n        System.out.println("\\n=== LIMIT & SKIP OPERATIONS ===");\n        System.out.println("27. Skip First 3: " + skipFirstN(num1, 3));\n        System.out.println("28. Take First 5: " + takeFirstN(num1, 5));\n    }\n}\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,r.jsx)(n.p,{children:"The Java Stream API is a powerful tool for functional-style programming that can make your code more readable, maintainable, and often more efficient. Key takeaways:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Understand the pipeline"}),": Source \u2192 Intermediate Operations \u2192 Terminal Operation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Leverage method references"})," for cleaner code"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Choose the right collectors"})," for your use case"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Handle nulls and exceptions"})," gracefully"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use specialized streams"})," (IntStream, etc.) for primitives"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Consider parallel streams"})," for large datasets and CPU-intensive operations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Debug with peek()"})," and proper logging"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Optimize for readability first"}),", performance second (unless performance is critical)"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Remember that streams are not always the best solution - for simple operations or small datasets, traditional loops might be more appropriate. The key is knowing when and how to use streams effectively in your DSA problems and real-world applications."})]})}function m(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);