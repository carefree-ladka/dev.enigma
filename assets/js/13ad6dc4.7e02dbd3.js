"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[5023],{18070:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>s,metadata:()=>o,toc:()=>d});var i=t(74848),r=t(28453);const s={},a="Rate Limiter System Design",o={id:"System Design Problems/Rate Limiter System Design",title:"Rate Limiter System Design",description:"A distributed rate limiting system to protect APIs from abuse and ensure fair resource usage.",source:"@site/docs/System Design Problems/Rate Limiter System Design.mdx",sourceDirName:"System Design Problems",slug:"/System Design Problems/Rate Limiter System Design",permalink:"/js.enigma/docs/System Design Problems/Rate Limiter System Design",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/System Design Problems/Rate Limiter System Design.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Netflix System Design",permalink:"/js.enigma/docs/System Design Problems/Netflix System Design"},next:{title:"Spotify System Design",permalink:"/js.enigma/docs/System Design Problems/Spotify System Design"}},l={},d=[{value:"1. Requirements (~5 minutes)",id:"1-requirements-5-minutes",level:2},{value:"Functional Requirements",id:"functional-requirements",level:3},{value:"Non-Functional Requirements",id:"non-functional-requirements",level:3},{value:"Capacity Estimation",id:"capacity-estimation",level:3},{value:"2. Core Entities (~2 minutes)",id:"2-core-entities-2-minutes",level:2},{value:"3. API or System Interface (~5 minutes)",id:"3-api-or-system-interface-5-minutes",level:2},{value:"Protocol: REST + gRPC for internal services",id:"protocol-rest--grpc-for-internal-services",level:3},{value:"Public API Endpoints",id:"public-api-endpoints",level:3},{value:"Response Headers (Added to all API responses)",id:"response-headers-added-to-all-api-responses",level:3},{value:"4. High Level Design (~10-15 minutes)",id:"4-high-level-design-10-15-minutes",level:2},{value:"Algorithm Choice: <strong>Token Bucket Algorithm</strong>",id:"algorithm-choice-token-bucket-algorithm",level:3},{value:"Architecture Diagram",id:"architecture-diagram",level:3},{value:"Request Flow",id:"request-flow",level:3},{value:"Data Models",id:"data-models",level:3},{value:"Token Bucket Redis Lua Script",id:"token-bucket-redis-lua-script",level:3},{value:"5. Deep Dives (~10 minutes)",id:"5-deep-dives-10-minutes",level:2},{value:"5.1 Spring Boot Implementation",id:"51-spring-boot-implementation",level:3},{value:"Domain Models",id:"domain-models",level:4},{value:"Rate Limiter Service",id:"rate-limiter-service",level:4},{value:"REST Controller",id:"rest-controller",level:4},{value:"Interceptor for API Gateway",id:"interceptor-for-api-gateway",level:4},{value:"5.2 Redis Configuration",id:"52-redis-configuration",level:3},{value:"5.3 Circuit Breaker Pattern",id:"53-circuit-breaker-pattern",level:3},{value:"5.4 Redis Pipeline for Performance",id:"54-redis-pipeline-for-performance",level:3},{value:"5.5 Application Properties",id:"55-application-properties",level:3},{value:"5.6 Monitoring &amp; Metrics",id:"56-monitoring--metrics",level:3},{value:"5.7 Admin API Controller",id:"57-admin-api-controller",level:3},{value:"6. Alternative Approaches",id:"6-alternative-approaches",level:2},{value:"Approach 1: Fixed Window Counter",id:"approach-1-fixed-window-counter",level:3},{value:"Approach 2: Sliding Window Log",id:"approach-2-sliding-window-log",level:3},{value:"Approach 3: Leaky Bucket",id:"approach-3-leaky-bucket",level:3},{value:"7. Trade-offs &amp; Decisions",id:"7-trade-offs--decisions",level:2},{value:"8. Extended Features (Future Enhancements)",id:"8-extended-features-future-enhancements",level:2},{value:"8.1 Dynamic Rate Limiting Based on System Load",id:"81-dynamic-rate-limiting-based-on-system-load",level:3},{value:"8.2 User Quota Management with Rollover",id:"82-user-quota-management-with-rollover",level:3},{value:"8.3 Cost-Based Rate Limiting",id:"83-cost-based-rate-limiting",level:3},{value:"8.4 Machine Learning for Anomaly Detection",id:"84-machine-learning-for-anomaly-detection",level:3},{value:"8.5 Self-Service Dashboard API",id:"85-self-service-dashboard-api",level:3},{value:"8.6 Testing",id:"86-testing",level:3},{value:"9. Summary",id:"9-summary",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"rate-limiter-system-design",children:"Rate Limiter System Design"})}),"\n",(0,i.jsx)(n.p,{children:"A distributed rate limiting system to protect APIs from abuse and ensure fair resource usage."}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"1-requirements-5-minutes",children:"1. Requirements (~5 minutes)"}),"\n",(0,i.jsx)(n.h3,{id:"functional-requirements",children:"Functional Requirements"}),"\n",(0,i.jsxs)(n.p,{children:["\u2713 ",(0,i.jsx)(n.strong,{children:"Rate Limiting"}),": The system should limit the number of requests a user/client can make within a time window (e.g., 100 requests per minute)"]}),"\n",(0,i.jsxs)(n.p,{children:["\u2713 ",(0,i.jsx)(n.strong,{children:"Multiple Rules"}),": Support different rate limit rules based on user tiers (free: 10/min, premium: 1000/min, enterprise: custom)"]}),"\n",(0,i.jsxs)(n.p,{children:["\u2713 ",(0,i.jsx)(n.strong,{children:"Feedback"}),": When rate limit is exceeded, return clear error message with retry-after time"]}),"\n",(0,i.jsx)(n.h3,{id:"non-functional-requirements",children:"Non-Functional Requirements"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Low Latency"}),": Rate limiting check should add minimal latency (target: ",(0,i.jsx)(n.code,{children:"<5ms"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"High Availability"}),": System should be fault-tolerant; if rate limiter fails, default to allowing requests (fail-open)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Accuracy"}),": Should prevent more than 5% deviation from configured limits in distributed environment"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Scalability"}),": Handle millions of requests per second across distributed servers"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Consistency"}),": Prefer availability over strict consistency (eventual consistency acceptable)"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"capacity-estimation",children:"Capacity Estimation"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Assumptions:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"1 billion requests per day"}),"\n",(0,i.jsx)(n.li,{children:"10 million unique users"}),"\n",(0,i.jsx)(n.li,{children:"Average 100 requests per user per day"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Calculations:"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"QPS (Queries Per Second):"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Average QPS = 1B / (24 * 3600) \u2248 11,574 QPS\nPeak QPS (3x average) \u2248 35,000 QPS\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Memory Requirements (Redis):"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Per user: ~100 bytes (key + counter + metadata)\n10M users \xd7 100 bytes = 1 GB\nWith overhead and multiple time windows: ~5 GB\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Cache Hit Rate:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"80% of requests from 20% of users (power law)"}),"\n",(0,i.jsx)(n.li,{children:"Active cache size: ~1 GB for hot users"}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"2-core-entities-2-minutes",children:"2. Core Entities (~2 minutes)"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"RateLimitRule"}),": Configuration defining rate limiting behavior"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ruleId"}),": Unique identifier"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"limit"}),": Maximum requests allowed"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"window"}),": Time window (seconds)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"tier"}),": User tier (free, premium, enterprise)"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"RateLimitCounter"}),": Tracks request counts per user"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"userId/apiKey"}),": Identifier"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"requestCount"}),": Current count"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"windowStart"}),": Window start timestamp"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"expiresAt"}),": TTL for cleanup"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"RateLimitResponse"}),": Result of rate limit check"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"allowed"}),": Boolean indicating if request is allowed"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"remaining"}),": Requests remaining in window"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"resetTime"}),": When the limit resets"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"retryAfter"}),": Seconds to wait if rate limited"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"3-api-or-system-interface-5-minutes",children:"3. API or System Interface (~5 minutes)"}),"\n",(0,i.jsx)(n.h3,{id:"protocol-rest--grpc-for-internal-services",children:"Protocol: REST + gRPC for internal services"}),"\n",(0,i.jsx)(n.h3,{id:"public-api-endpoints",children:"Public API Endpoints"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Check Rate Limit (Internal)"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'POST /v1/ratelimit/check\nHeaders:\n  Authorization: Bearer <token>\nBody:\n{\n  "userId": "user123",\n  "apiKey": "key_abc",\n  "endpoint": "/api/posts",\n  "tier": "premium"\n}\n\nResponse:\n{\n  "allowed": true,\n  "limit": 1000,\n  "remaining": 847,\n  "resetTime": 1696523400,\n  "retryAfter": null\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Get User Rate Limit Status"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'GET /v1/ratelimit/status/{userId}\nHeaders:\n  Authorization: Bearer <token>\n\nResponse:\n{\n  "rules": [\n    {\n      "endpoint": "/api/posts",\n      "limit": 1000,\n      "remaining": 847,\n      "resetTime": 1696523400\n    }\n  ]\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Configure Rate Limit Rules (Admin)"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'POST /v1/admin/ratelimit/rules\nHeaders:\n  Authorization: Bearer <admin_token>\nBody:\n{\n  "tier": "premium",\n  "rules": [\n    {\n      "endpoint": "/api/*",\n      "limit": 1000,\n      "window": 60\n    }\n  ]\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"response-headers-added-to-all-api-responses",children:"Response Headers (Added to all API responses)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"X-RateLimit-Limit: 1000\nX-RateLimit-Remaining: 847\nX-RateLimit-Reset: 1696523400\nRetry-After: 30 (if rate limited)\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"4-high-level-design-10-15-minutes",children:"4. High Level Design (~10-15 minutes)"}),"\n",(0,i.jsxs)(n.h3,{id:"algorithm-choice-token-bucket-algorithm",children:["Algorithm Choice: ",(0,i.jsx)(n.strong,{children:"Token Bucket Algorithm"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Why Token Bucket?"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Allows burst traffic while maintaining average rate"}),"\n",(0,i.jsx)(n.li,{children:"Simple to implement in Redis"}),"\n",(0,i.jsx)(n.li,{children:"Memory efficient"}),"\n",(0,i.jsx)(n.li,{children:"Handles distributed systems well"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Alternative Algorithms:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Fixed Window"}),": Simple but allows burst at window boundaries"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Sliding Window Log"}),": Accurate but memory intensive"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Sliding Window Counter"}),": Good balance but more complex"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"architecture-diagram",children:"Architecture Diagram"}),"\n",(0,i.jsx)(n.mermaid,{value:"graph TB\n    Client[Client Application]\n    LB[Load Balancer]\n\n    subgraph API Gateway Layer\n        GW1[API Gateway 1]\n        GW2[API Gateway 2]\n        GW3[API Gateway 3]\n    end\n\n    subgraph Rate Limiter Service\n        RL1[Rate Limiter 1]\n        RL2[Rate Limiter 2]\n        RL3[Rate Limiter 3]\n    end\n\n    subgraph Cache Layer\n        Redis[(Redis Cluster<br/>Primary)]\n        RedisReplica[(Redis Replica<br/>Read Only)]\n    end\n\n    subgraph Configuration\n        ConfigDB[(Config DB<br/>PostgreSQL)]\n        ConfigCache[Config Cache]\n    end\n\n    subgraph Backend Services\n        API1[API Service 1]\n        API2[API Service 2]\n    end\n\n    Client --\x3e|HTTPS| LB\n    LB --\x3e GW1 & GW2 & GW3\n\n    GW1 & GW2 & GW3 --\x3e|Check Rate Limit| RL1 & RL2 & RL3\n\n    RL1 & RL2 & RL3 --\x3e|INCR/GET| Redis\n    RL1 & RL2 & RL3 -.->|Fallback Read| RedisReplica\n    Redis -.->|Replication| RedisReplica\n\n    RL1 & RL2 & RL3 --\x3e|Get Rules| ConfigCache\n    ConfigCache --\x3e|Cache Miss| ConfigDB\n\n    GW1 & GW2 & GW3 --\x3e|Forward Request| API1 & API2\n\n    style Redis fill:#ff6b6b\n    style ConfigCache fill:#4ecdc4\n    style RL1 fill:#95e1d3\n    style RL2 fill:#95e1d3\n    style RL3 fill:#95e1d3"}),"\n",(0,i.jsx)(n.h3,{id:"request-flow",children:"Request Flow"}),"\n",(0,i.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant C as Client\n    participant GW as API Gateway\n    participant RL as Rate Limiter\n    participant Redis as Redis\n    participant API as Backend API\n\n    C->>GW: HTTP Request + Auth Token\n    GW->>GW: Extract userId/apiKey\n\n    GW->>RL: checkRateLimit(userId, endpoint)\n    RL->>Redis: GET rate_limit_rules:{tier}\n    Redis--\x3e>RL: Rules Config (cached)\n\n    RL->>Redis: EVAL token_bucket_script<br/>(key, limit, window, refill_rate)\n    Redis--\x3e>RL: {allowed: true, remaining: 847}\n\n    alt Request Allowed\n        RL--\x3e>GW: {allowed: true, remaining: 847}\n        GW->>GW: Add rate limit headers\n        GW->>API: Forward request\n        API--\x3e>GW: Response\n        GW--\x3e>C: 200 OK + Rate Limit Headers\n    else Rate Limit Exceeded\n        RL--\x3e>GW: {allowed: false, retryAfter: 30}\n        GW--\x3e>C: 429 Too Many Requests<br/>Retry-After: 30\n    end"}),"\n",(0,i.jsx)(n.h3,{id:"data-models",children:"Data Models"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Redis Keys Structure:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"# Token bucket counter\nrate_limit:{userId}:{endpoint}:{window}\n  - tokens: current available tokens\n  - lastRefill: last refill timestamp\n  - TTL: window duration\n\n# Rule configuration (cached)\nrate_limit_rules:{tier}\n  - JSON blob with all rules for tier\n  - TTL: 5 minutes\n\n# User tier mapping\nuser_tier:{userId}\n  - tier name (free/premium/enterprise)\n  - TTL: 1 hour\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"PostgreSQL Schema:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Rate limit rules configuration\nCREATE TABLE rate_limit_rules (\n    id SERIAL PRIMARY KEY,\n    tier VARCHAR(50) NOT NULL,\n    endpoint_pattern VARCHAR(255) NOT NULL,\n    limit_count INTEGER NOT NULL,\n    window_seconds INTEGER NOT NULL,\n    created_at TIMESTAMP DEFAULT NOW(),\n    updated_at TIMESTAMP DEFAULT NOW()\n);\n\n-- User tier assignments\nCREATE TABLE user_tiers (\n    user_id VARCHAR(255) PRIMARY KEY,\n    tier VARCHAR(50) NOT NULL,\n    custom_limits JSONB,\n    created_at TIMESTAMP DEFAULT NOW(),\n    updated_at TIMESTAMP DEFAULT NOW()\n);\n\n-- Rate limit violations log (for analytics)\nCREATE TABLE rate_limit_violations (\n    id SERIAL PRIMARY KEY,\n    user_id VARCHAR(255) NOT NULL,\n    endpoint VARCHAR(255) NOT NULL,\n    timestamp TIMESTAMP NOT NULL,\n    attempted_count INTEGER\n);\n"})}),"\n",(0,i.jsx)(n.h3,{id:"token-bucket-redis-lua-script",children:"Token Bucket Redis Lua Script"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"-- Token Bucket Algorithm Implementation\nlocal key = KEYS[1]\nlocal limit = tonumber(ARGV[1])\nlocal window = tonumber(ARGV[2])\nlocal rate = limit / window\nlocal now = tonumber(ARGV[3])\n\nlocal bucket = redis.call('HMGET', key, 'tokens', 'lastRefill')\nlocal tokens = tonumber(bucket[1])\nlocal lastRefill = tonumber(bucket[2])\n\nif tokens == nil then\n    tokens = limit\n    lastRefill = now\nend\n\n-- Refill tokens based on time elapsed\nlocal elapsed = now - lastRefill\nlocal tokensToAdd = elapsed * rate\ntokens = math.min(limit, tokens + tokensToAdd)\nlastRefill = now\n\n-- Try to consume 1 token\nlocal allowed = 0\nif tokens >= 1 then\n    tokens = tokens - 1\n    allowed = 1\nend\n\nredis.call('HMSET', key, 'tokens', tokens, 'lastRefill', lastRefill)\nredis.call('EXPIRE', key, window)\n\nreturn {allowed, math.floor(tokens)}\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"5-deep-dives-10-minutes",children:"5. Deep Dives (~10 minutes)"}),"\n",(0,i.jsx)(n.h3,{id:"51-spring-boot-implementation",children:"5.1 Spring Boot Implementation"}),"\n",(0,i.jsx)(n.h4,{id:"domain-models",children:"Domain Models"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'// RateLimitResponse.java\n@Data\n@Builder\n@NoArgsConstructor\n@AllArgsConstructor\npublic class RateLimitResponse {\n    private boolean allowed;\n    private int limit;\n    private int remaining;\n    private long resetTime;\n    private Integer retryAfter;\n    private boolean degraded;\n}\n\n// RateLimitRule.java\n@Entity\n@Table(name = "rate_limit_rules")\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class RateLimitRule {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    @Column(nullable = false)\n    private String tier;\n\n    @Column(name = "endpoint_pattern", nullable = false)\n    private String endpointPattern;\n\n    @Column(name = "limit_count", nullable = false)\n    private Integer limitCount;\n\n    @Column(name = "window_seconds", nullable = false)\n    private Integer windowSeconds;\n\n    @CreatedDate\n    @Column(name = "created_at")\n    private LocalDateTime createdAt;\n\n    @LastModifiedDate\n    @Column(name = "updated_at")\n    private LocalDateTime updatedAt;\n}\n\n// UserTier.java\n@Entity\n@Table(name = "user_tiers")\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class UserTier {\n    @Id\n    @Column(name = "user_id")\n    private String userId;\n\n    @Column(nullable = false)\n    private String tier;\n\n    @Type(type = "jsonb")\n    @Column(name = "custom_limits", columnDefinition = "jsonb")\n    private String customLimits;\n\n    @CreatedDate\n    @Column(name = "created_at")\n    private LocalDateTime createdAt;\n\n    @LastModifiedDate\n    @Column(name = "updated_at")\n    private LocalDateTime updatedAt;\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"rate-limiter-service",children:"Rate Limiter Service"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'@Service\n@Slf4j\npublic class RateLimiterService {\n\n    @Autowired\n    private RedisTemplate<String, String> redisTemplate;\n\n    @Autowired\n    private RateLimitRuleRepository ruleRepository;\n\n    @Value("classpath:token_bucket.lua")\n    private Resource tokenBucketScript;\n\n    private RedisScript<List> script;\n\n    @PostConstruct\n    public void init() throws IOException {\n        String scriptContent = new String(\n            tokenBucketScript.getInputStream().readAllBytes()\n        );\n        script = RedisScript.of(scriptContent, List.class);\n    }\n\n    /**\n     * Check if request is allowed under rate limit\n     * Implements fail-open strategy\n     */\n    public RateLimitResponse checkRateLimit(String userId, String endpoint, String tier) {\n        try {\n            // Get rate limit rule for tier and endpoint\n            RateLimitRule rule = getRateLimitRule(tier, endpoint);\n            if (rule == null) {\n                return allowRequest(); // No rule configured, allow\n            }\n\n            // Build Redis key\n            String key = buildRateLimitKey(userId, endpoint, rule.getWindowSeconds());\n\n            // Execute token bucket algorithm\n            List<Long> result = executeTokenBucket(\n                key,\n                rule.getLimitCount(),\n                rule.getWindowSeconds()\n            );\n\n            long allowed = result.get(0);\n            long remaining = result.get(1);\n            long resetTime = System.currentTimeMillis() / 1000 + rule.getWindowSeconds();\n\n            return RateLimitResponse.builder()\n                .allowed(allowed == 1)\n                .limit(rule.getLimitCount())\n                .remaining((int) remaining)\n                .resetTime(resetTime)\n                .retryAfter(allowed == 0 ? rule.getWindowSeconds() : null)\n                .degraded(false)\n                .build();\n\n        } catch (RedisConnectionFailureException ex) {\n            log.error("Redis connection failed, failing open: {}", ex.getMessage());\n            return failOpen();\n        } catch (Exception ex) {\n            log.error("Rate limiter error: {}", ex.getMessage(), ex);\n            return failOpen();\n        }\n    }\n\n    /**\n     * Execute token bucket Lua script in Redis\n     */\n    private List<Long> executeTokenBucket(String key, int limit, int window) {\n        long now = System.currentTimeMillis() / 1000;\n\n        return redisTemplate.execute(\n            script,\n            Collections.singletonList(key),\n            String.valueOf(limit),\n            String.valueOf(window),\n            String.valueOf(now)\n        );\n    }\n\n    /**\n     * Get rate limit rule with caching\n     */\n    @Cacheable(value = "rateLimitRules", key = "#tier + \':\' + #endpoint")\n    public RateLimitRule getRateLimitRule(String tier, String endpoint) {\n        return ruleRepository.findByTierAndEndpointPattern(tier, endpoint)\n            .orElse(null);\n    }\n\n    /**\n     * Build Redis key for rate limiting\n     */\n    private String buildRateLimitKey(String userId, String endpoint, int window) {\n        return String.format("rate_limit:%s:%s:%d", userId, endpoint, window);\n    }\n\n    /**\n     * Fail-open: Allow request when rate limiter unavailable\n     */\n    private RateLimitResponse failOpen() {\n        return RateLimitResponse.builder()\n            .allowed(true)\n            .degraded(true)\n            .limit(0)\n            .remaining(0)\n            .resetTime(0)\n            .build();\n    }\n\n    private RateLimitResponse allowRequest() {\n        return RateLimitResponse.builder()\n            .allowed(true)\n            .limit(Integer.MAX_VALUE)\n            .remaining(Integer.MAX_VALUE)\n            .resetTime(0)\n            .build();\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"rest-controller",children:"REST Controller"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'@RestController\n@RequestMapping("/v1/ratelimit")\n@Slf4j\npublic class RateLimitController {\n\n    @Autowired\n    private RateLimiterService rateLimiterService;\n\n    /**\n     * Check rate limit for a request\n     */\n    @PostMapping("/check")\n    public ResponseEntity<RateLimitResponse> checkRateLimit(\n            @RequestBody RateLimitCheckRequest request) {\n\n        RateLimitResponse response = rateLimiterService.checkRateLimit(\n            request.getUserId(),\n            request.getEndpoint(),\n            request.getTier()\n        );\n\n        return ResponseEntity.ok(response);\n    }\n\n    /**\n     * Get rate limit status for a user\n     */\n    @GetMapping("/status/{userId}")\n    public ResponseEntity<RateLimitStatusResponse> getStatus(\n            @PathVariable String userId,\n            @RequestHeader("Authorization") String token) {\n\n        // Implementation here\n        return ResponseEntity.ok(new RateLimitStatusResponse());\n    }\n}\n\n@Data\nclass RateLimitCheckRequest {\n    private String userId;\n    private String apiKey;\n    private String endpoint;\n    private String tier;\n}\n\n@Data\nclass RateLimitStatusResponse {\n    private List<RuleStat us> rules;\n}\n\n@Data\nclass RuleStatus {\n    private String endpoint;\n    private int limit;\n    private int remaining;\n    private long resetTime;\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"interceptor-for-api-gateway",children:"Interceptor for API Gateway"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'@Component\n@Slf4j\npublic class RateLimitInterceptor implements HandlerInterceptor {\n\n    @Autowired\n    private RateLimiterService rateLimiterService;\n\n    @Autowired\n    private UserService userService;\n\n    @Override\n    public boolean preHandle(HttpServletRequest request,\n                           HttpServletResponse response,\n                           Object handler) throws Exception {\n\n        // Extract user information from token/session\n        String userId = extractUserId(request);\n        String endpoint = request.getRequestURI();\n        String tier = userService.getUserTier(userId);\n\n        // Check rate limit\n        RateLimitResponse rateLimitResponse = rateLimiterService.checkRateLimit(\n            userId, endpoint, tier\n        );\n\n        // Add rate limit headers\n        response.addHeader("X-RateLimit-Limit",\n            String.valueOf(rateLimitResponse.getLimit()));\n        response.addHeader("X-RateLimit-Remaining",\n            String.valueOf(rateLimitResponse.getRemaining()));\n        response.addHeader("X-RateLimit-Reset",\n            String.valueOf(rateLimitResponse.getResetTime()));\n\n        // Check if request is allowed\n        if (!rateLimitResponse.isAllowed()) {\n            response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());\n            response.addHeader("Retry-After",\n                String.valueOf(rateLimitResponse.getRetryAfter()));\n\n            response.getWriter().write(\n                "{\\"error\\": \\"Rate limit exceeded\\", \\"retryAfter\\": " +\n                rateLimitResponse.getRetryAfter() + "}"\n            );\n\n            return false;\n        }\n\n        return true;\n    }\n\n    private String extractUserId(HttpServletRequest request) {\n        // Extract from JWT token or session\n        String authHeader = request.getHeader("Authorization");\n        // Parse JWT and extract userId\n        return "user123"; // Placeholder\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"52-redis-configuration",children:"5.2 Redis Configuration"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'@Configuration\n@EnableCaching\npublic class RedisConfig {\n\n    @Value("${spring.redis.host}")\n    private String redisHost;\n\n    @Value("${spring.redis.port}")\n    private int redisPort;\n\n    @Value("${spring.redis.pool.max-active}")\n    private int maxActive;\n\n    @Value("${spring.redis.pool.max-idle}")\n    private int maxIdle;\n\n    /**\n     * Redis connection factory with connection pooling\n     */\n    @Bean\n    public RedisConnectionFactory redisConnectionFactory() {\n        JedisPoolConfig poolConfig = new JedisPoolConfig();\n        poolConfig.setMaxTotal(maxActive);\n        poolConfig.setMaxIdle(maxIdle);\n        poolConfig.setMinIdle(10);\n        poolConfig.setTestOnBorrow(true);\n        poolConfig.setTestOnReturn(true);\n        poolConfig.setTestWhileIdle(true);\n\n        JedisClientConfiguration clientConfig = JedisClientConfiguration.builder()\n            .usePooling()\n            .poolConfig(poolConfig)\n            .and()\n            .readTimeout(Duration.ofMillis(2000))\n            .connectTimeout(Duration.ofMillis(1000))\n            .build();\n\n        RedisStandaloneConfiguration serverConfig =\n            new RedisStandaloneConfiguration(redisHost, redisPort);\n\n        return new JedisConnectionFactory(serverConfig, clientConfig);\n    }\n\n    /**\n     * Redis template for operations\n     */\n    @Bean\n    public RedisTemplate<String, String> redisTemplate(\n            RedisConnectionFactory connectionFactory) {\n\n        RedisTemplate<String, String> template = new RedisTemplate<>();\n        template.setConnectionFactory(connectionFactory);\n        template.setKeySerializer(new StringRedisSerializer());\n        template.setValueSerializer(new StringRedisSerializer());\n        template.setHashKeySerializer(new StringRedisSerializer());\n        template.setHashValueSerializer(new StringRedisSerializer());\n        template.afterPropertiesSet();\n\n        return template;\n    }\n\n    /**\n     * Cache manager for Spring Cache abstraction\n     */\n    @Bean\n    public CacheManager cacheManager(RedisConnectionFactory connectionFactory) {\n        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()\n            .entryTtl(Duration.ofMinutes(5))\n            .serializeKeysWith(\n                RedisSerializationContext.SerializationPair.fromSerializer(\n                    new StringRedisSerializer()\n                )\n            )\n            .serializeValuesWith(\n                RedisSerializationContext.SerializationPair.fromSerializer(\n                    new GenericJackson2JsonRedisSerializer()\n                )\n            );\n\n        return RedisCacheManager.builder(connectionFactory)\n            .cacheDefaults(config)\n            .build();\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"53-circuit-breaker-pattern",children:"5.3 Circuit Breaker Pattern"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'@Service\n@Slf4j\npublic class RateLimiterServiceWithCircuitBreaker {\n\n    @Autowired\n    private RateLimiterService rateLimiterService;\n\n    private final CircuitBreaker circuitBreaker;\n\n    public RateLimiterServiceWithCircuitBreaker() {\n        CircuitBreakerConfig config = CircuitBreakerConfig.custom()\n            .failureRateThreshold(50)\n            .waitDurationInOpenState(Duration.ofSeconds(30))\n            .slidingWindowSize(10)\n            .build();\n\n        CircuitBreakerRegistry registry = CircuitBreakerRegistry.of(config);\n        this.circuitBreaker = registry.circuitBreaker("rateLimiter");\n    }\n\n    public RateLimitResponse checkRateLimit(String userId, String endpoint, String tier) {\n        return circuitBreaker.executeSupplier(() ->\n            rateLimiterService.checkRateLimit(userId, endpoint, tier)\n        );\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"54-redis-pipeline-for-performance",children:"5.4 Redis Pipeline for Performance"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'@Service\npublic class OptimizedRateLimiterService {\n\n    @Autowired\n    private RedisTemplate<String, String> redisTemplate;\n\n    /**\n     * Check multiple rate limits using pipeline\n     */\n    public Map<String, RateLimitResponse> checkMultipleRateLimits(\n            List<RateLimitCheckRequest> requests) {\n\n        Map<String, RateLimitResponse> results = new HashMap<>();\n\n        // Execute pipelined operations\n        List<Object> pipelineResults = redisTemplate.executePipelined(\n            (RedisCallback<Object>) connection -> {\n                for (RateLimitCheckRequest req : requests) {\n                    String key = buildKey(req);\n                    connection.get(key.getBytes());\n                }\n                return null;\n            }\n        );\n\n        // Process results\n        for (int i = 0; i < requests.size(); i++) {\n            RateLimitCheckRequest req = requests.get(i);\n            Object result = pipelineResults.get(i);\n\n            RateLimitResponse response = processResult(req, result);\n            results.put(req.getUserId(), response);\n        }\n\n        return results;\n    }\n\n    private String buildKey(RateLimitCheckRequest req) {\n        return String.format("rate_limit:%s:%s",\n            req.getUserId(), req.getEndpoint());\n    }\n\n    private RateLimitResponse processResult(RateLimitCheckRequest req, Object result) {\n        // Process and build response\n        return RateLimitResponse.builder()\n            .allowed(true)\n            .build();\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"55-application-properties",children:"5.5 Application Properties"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"# application.yml\nspring:\n  redis:\n    host: localhost\n    port: 6379\n    timeout: 2000\n    pool:\n      max-active: 100\n      max-idle: 50\n      min-idle: 10\n      max-wait: 1000\n\n  datasource:\n    url: jdbc:postgresql://localhost:5432/ratelimiter\n    username: postgres\n    password: password\n    hikari:\n      maximum-pool-size: 20\n      minimum-idle: 5\n      connection-timeout: 30000\n\n  jpa:\n    hibernate:\n      ddl-auto: validate\n    show-sql: false\n    properties:\n      hibernate:\n        dialect: org.hibernate.dialect.PostgreSQLDialect\n        format_sql: true\n\n# Rate limiter specific configs\nratelimiter:\n  fail-open: true\n  default-limit: 1000\n  default-window: 60\n  cache-ttl-minutes: 5\n"})}),"\n",(0,i.jsx)(n.h3,{id:"56-monitoring--metrics",children:"5.6 Monitoring & Metrics"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'@Service\n@Slf4j\npublic class RateLimiterMetricsService {\n\n    private final MeterRegistry meterRegistry;\n    private final Counter rateLimitExceededCounter;\n    private final Timer rateLimitCheckTimer;\n\n    public RateLimiterMetricsService(MeterRegistry meterRegistry) {\n        this.meterRegistry = meterRegistry;\n\n        this.rateLimitExceededCounter = Counter.builder("ratelimit.exceeded")\n            .description("Number of rate limit violations")\n            .tag("service", "ratelimiter")\n            .register(meterRegistry);\n\n        this.rateLimitCheckTimer = Timer.builder("ratelimit.check.duration")\n            .description("Rate limit check duration")\n            .tag("service", "ratelimiter")\n            .register(meterRegistry);\n    }\n\n    public void recordRateLimitExceeded(String userId, String endpoint) {\n        rateLimitExceededCounter.increment();\n\n        Gauge.builder("ratelimit.violations", () -> getUserViolationCount(userId))\n            .tag("userId", userId)\n            .register(meterRegistry);\n    }\n\n    public <T> T timeRateLimitCheck(Supplier<T> operation) {\n        return rateLimitCheckTimer.record(operation);\n    }\n\n    private double getUserViolationCount(String userId) {\n        // Query violation count from database or cache\n        return 0.0;\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"57-admin-api-controller",children:"5.7 Admin API Controller"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'@RestController\n@RequestMapping("/v1/admin/ratelimit")\n@Slf4j\npublic class RateLimitAdminController {\n\n    @Autowired\n    private RateLimitRuleRepository ruleRepository;\n\n    @Autowired\n    private CacheManager cacheManager;\n\n    /**\n     * Create or update rate limit rules\n     */\n    @PostMapping("/rules")\n    @PreAuthorize("hasRole(\'ADMIN\')")\n    public ResponseEntity<RateLimitRule> createRule(\n            @RequestBody @Valid RateLimitRuleDto ruleDto) {\n\n        RateLimitRule rule = new RateLimitRule();\n        rule.setTier(ruleDto.getTier());\n        rule.setEndpointPattern(ruleDto.getEndpointPattern());\n        rule.setLimitCount(ruleDto.getLimitCount());\n        rule.setWindowSeconds(ruleDto.getWindowSeconds());\n\n        RateLimitRule saved = ruleRepository.save(rule);\n\n        // Invalidate cache\n        invalidateRuleCache(ruleDto.getTier());\n\n        return ResponseEntity.ok(saved);\n    }\n\n    /**\n     * Get all rules for a tier\n     */\n    @GetMapping("/rules/{tier}")\n    @PreAuthorize("hasRole(\'ADMIN\')")\n    public ResponseEntity<List<RateLimitRule>> getRules(\n            @PathVariable String tier) {\n\n        List<RateLimitRule> rules = ruleRepository.findByTier(tier);\n        return ResponseEntity.ok(rules);\n    }\n\n    /**\n     * Delete a rule\n     */\n    @DeleteMapping("/rules/{ruleId}")\n    @PreAuthorize("hasRole(\'ADMIN\')")\n    public ResponseEntity<Void> deleteRule(@PathVariable Long ruleId) {\n        ruleRepository.deleteById(ruleId);\n        return ResponseEntity.noContent().build();\n    }\n\n    private void invalidateRuleCache(String tier) {\n        Cache cache = cacheManager.getCache("rateLimitRules");\n        if (cache != null) {\n            cache.evict(tier);\n        }\n    }\n}\n\n@Data\nclass RateLimitRuleDto {\n    @NotBlank\n    private String tier;\n\n    @NotBlank\n    private String endpointPattern;\n\n    @Min(1)\n    private Integer limitCount;\n\n    @Min(1)\n    private Integer windowSeconds;\n}\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"6-alternative-approaches",children:"6. Alternative Approaches"}),"\n",(0,i.jsx)(n.h3,{id:"approach-1-fixed-window-counter",children:"Approach 1: Fixed Window Counter"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Pros"}),": Simple, low memory\n",(0,i.jsx)(n.strong,{children:"Cons"}),": Burst at window boundaries"]}),"\n",(0,i.jsx)(n.h3,{id:"approach-2-sliding-window-log",children:"Approach 2: Sliding Window Log"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Pros"}),": Very accurate\n",(0,i.jsx)(n.strong,{children:"Cons"}),": High memory usage (store all request timestamps)"]}),"\n",(0,i.jsx)(n.h3,{id:"approach-3-leaky-bucket",children:"Approach 3: Leaky Bucket"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Pros"}),": Smooth traffic, no bursts\n",(0,i.jsx)(n.strong,{children:"Cons"}),": Less flexible, may reject valid bursts"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Chosen: Token Bucket"})," - Best balance of accuracy, flexibility, and performance"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"7-trade-offs--decisions",children:"7. Trade-offs & Decisions"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Decision"}),(0,i.jsx)(n.th,{children:"Trade-off"}),(0,i.jsx)(n.th,{children:"Rationale"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Token Bucket over Fixed Window"}),(0,i.jsx)(n.td,{children:"Complexity vs Accuracy"}),(0,i.jsx)(n.td,{children:"Allows legitimate bursts while maintaining rate"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Fail-Open on Redis failure"}),(0,i.jsx)(n.td,{children:"Availability vs Security"}),(0,i.jsx)(n.td,{children:"Business continuity over strict enforcement"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Eventual consistency in multi-region"}),(0,i.jsx)(n.td,{children:"Consistency vs Latency"}),(0,i.jsx)(n.td,{children:"Low latency more important than perfect accuracy"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"5% accuracy margin"}),(0,i.jsx)(n.td,{children:"Strictness vs Performance"}),(0,i.jsx)(n.td,{children:"Acceptable for most use cases, huge perf gain"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Redis over Database"}),(0,i.jsx)(n.td,{children:"Cost vs Performance"}),(0,i.jsx)(n.td,{children:"Sub-5ms latency requirement demands in-memory"})]})]})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"8-extended-features-future-enhancements",children:"8. Extended Features (Future Enhancements)"}),"\n",(0,i.jsx)(n.h3,{id:"81-dynamic-rate-limiting-based-on-system-load",children:"8.1 Dynamic Rate Limiting Based on System Load"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'@Service\npublic class DynamicRateLimiterService {\n\n    @Autowired\n    private RateLimiterService rateLimiterService;\n\n    @Autowired\n    private SystemLoadMonitor loadMonitor;\n\n    /**\n     * Adjust rate limits based on current system load\n     */\n    public RateLimitResponse checkWithDynamicLimit(\n            String userId, String endpoint, String tier) {\n\n        double loadFactor = loadMonitor.getCurrentLoadFactor();\n\n        // Reduce limits when system is under heavy load\n        if (loadFactor > 0.8) {\n            // Apply 50% reduction\n            return rateLimiterService.checkRateLimit(\n                userId, endpoint, tier, 0.5\n            );\n        } else if (loadFactor > 0.6) {\n            // Apply 25% reduction\n            return rateLimiterService.checkRateLimit(\n                userId, endpoint, tier, 0.75\n            );\n        }\n\n        return rateLimiterService.checkRateLimit(userId, endpoint, tier);\n    }\n}\n\n@Component\nclass SystemLoadMonitor {\n\n    @Autowired\n    private MeterRegistry meterRegistry;\n\n    public double getCurrentLoadFactor() {\n        // Monitor CPU, memory, and request queue depth\n        double cpu = getCpuUsage();\n        double memory = getMemoryUsage();\n        double queueDepth = getQueueDepth();\n\n        return Math.max(cpu, Math.max(memory, queueDepth));\n    }\n\n    private double getCpuUsage() {\n        return meterRegistry.get("system.cpu.usage").gauge().value();\n    }\n\n    private double getMemoryUsage() {\n        return meterRegistry.get("jvm.memory.used").gauge().value() /\n               meterRegistry.get("jvm.memory.max").gauge().value();\n    }\n\n    private double getQueueDepth() {\n        // Custom metric for request queue\n        return 0.0; // Placeholder\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"82-user-quota-management-with-rollover",children:"8.2 User Quota Management with Rollover"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'@Service\npublic class QuotaManagementService {\n\n    @Autowired\n    private RedisTemplate<String, String> redisTemplate;\n\n    @Autowired\n    private QuotaRepository quotaRepository;\n\n    /**\n     * Check monthly quota with rollover support\n     */\n    public QuotaResponse checkMonthlyQuota(String userId) {\n        String key = "quota:monthly:" + userId;\n        String month = getCurrentMonth();\n\n        // Get current usage\n        String usageStr = redisTemplate.opsForValue().get(key + ":" + month);\n        long currentUsage = usageStr != null ? Long.parseLong(usageStr) : 0;\n\n        // Get quota limit\n        UserQuota quota = quotaRepository.findByUserId(userId)\n            .orElse(getDefaultQuota());\n\n        long available = quota.getMonthlyLimit() + quota.getRolloverAmount() - currentUsage;\n\n        return QuotaResponse.builder()\n            .userId(userId)\n            .limit(quota.getMonthlyLimit())\n            .used(currentUsage)\n            .available(available)\n            .rollover(quota.getRolloverAmount())\n            .resetsAt(getMonthEndTimestamp())\n            .build();\n    }\n\n    /**\n     * Increment quota usage\n     */\n    public void incrementUsage(String userId, long amount) {\n        String key = "quota:monthly:" + userId + ":" + getCurrentMonth();\n        redisTemplate.opsForValue().increment(key, amount);\n        redisTemplate.expire(key, Duration.ofDays(40)); // Keep for 40 days\n    }\n\n    /**\n     * Process monthly rollover\n     */\n    @Scheduled(cron = "0 0 0 1 * ?") // First day of each month\n    public void processMonthlyRollover() {\n        List<UserQuota> allQuotas = quotaRepository.findAll();\n\n        for (UserQuota quota : allQuotas) {\n            String lastMonth = getLastMonth();\n            String key = "quota:monthly:" + quota.getUserId() + ":" + lastMonth;\n\n            String usageStr = redisTemplate.opsForValue().get(key);\n            long lastMonthUsage = usageStr != null ? Long.parseLong(usageStr) : 0;\n\n            // Calculate rollover (unused quota from last month)\n            long unused = Math.max(0, quota.getMonthlyLimit() - lastMonthUsage);\n            long rollover = Math.min(unused, quota.getMaxRollover());\n\n            // Update quota with rollover\n            quota.setRolloverAmount(rollover);\n            quotaRepository.save(quota);\n        }\n    }\n\n    private String getCurrentMonth() {\n        return LocalDate.now().format(DateTimeFormatter.ofPattern("yyyy-MM"));\n    }\n\n    private String getLastMonth() {\n        return LocalDate.now().minusMonths(1)\n            .format(DateTimeFormatter.ofPattern("yyyy-MM"));\n    }\n\n    private long getMonthEndTimestamp() {\n        return LocalDate.now().plusMonths(1).withDayOfMonth(1)\n            .atStartOfDay(ZoneId.systemDefault())\n            .toEpochSecond();\n    }\n\n    private UserQuota getDefaultQuota() {\n        return UserQuota.builder()\n            .monthlyLimit(10000)\n            .rolloverAmount(0)\n            .maxRollover(5000)\n            .build();\n    }\n}\n\n@Entity\n@Table(name = "user_quotas")\n@Data\n@Builder\n@NoArgsConstructor\n@AllArgsConstructor\nclass UserQuota {\n    @Id\n    private String userId;\n\n    @Column(name = "monthly_limit")\n    private Long monthlyLimit;\n\n    @Column(name = "rollover_amount")\n    private Long rolloverAmount;\n\n    @Column(name = "max_rollover")\n    private Long maxRollover;\n}\n\n@Data\n@Builder\nclass QuotaResponse {\n    private String userId;\n    private long limit;\n    private long used;\n    private long available;\n    private long rollover;\n    private long resetsAt;\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"83-cost-based-rate-limiting",children:"8.3 Cost-Based Rate Limiting"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'@Service\npublic class CostBasedRateLimiterService {\n\n    @Autowired\n    private RedisTemplate<String, String> redisTemplate;\n\n    @Autowired\n    private CostConfigRepository costConfigRepository;\n\n    private static final Map<String, Integer> DEFAULT_COSTS = Map.of(\n        "GET", 1,\n        "POST", 5,\n        "PUT", 5,\n        "DELETE", 10\n    );\n\n    /**\n     * Check rate limit based on operation cost\n     */\n    public RateLimitResponse checkCostBasedLimit(\n            String userId, String endpoint, String method, String tier) {\n\n        // Get cost for this operation\n        int cost = getOperationCost(endpoint, method);\n\n        // Get user\'s cost budget\n        String key = "cost_budget:" + userId + ":" + getCurrentMinute();\n        String budgetStr = redisTemplate.opsForValue().get(key);\n\n        int remainingBudget = budgetStr != null ?\n            Integer.parseInt(budgetStr) : getBudgetForTier(tier);\n\n        boolean allowed = remainingBudget >= cost;\n\n        if (allowed) {\n            // Deduct cost from budget\n            long newBudget = redisTemplate.opsForValue()\n                .decrement(key, cost);\n            redisTemplate.expire(key, Duration.ofMinutes(1));\n\n            return RateLimitResponse.builder()\n                .allowed(true)\n                .remaining((int) newBudget / cost) // Approximate remaining requests\n                .build();\n        }\n\n        return RateLimitResponse.builder()\n            .allowed(false)\n            .retryAfter(60)\n            .build();\n    }\n\n    /**\n     * Get operation cost from config or defaults\n     */\n    @Cacheable("operationCosts")\n    public int getOperationCost(String endpoint, String method) {\n        return costConfigRepository\n            .findByEndpointAndMethod(endpoint, method)\n            .map(CostConfig::getCost)\n            .orElse(DEFAULT_COSTS.getOrDefault(method, 1));\n    }\n\n    private int getBudgetForTier(String tier) {\n        return switch (tier) {\n            case "free" -> 100;\n            case "premium" -> 10000;\n            case "enterprise" -> 100000;\n            default -> 100;\n        };\n    }\n\n    private String getCurrentMinute() {\n        return LocalDateTime.now()\n            .format(DateTimeFormatter.ofPattern("yyyy-MM-dd-HH-mm"));\n    }\n}\n\n@Entity\n@Table(name = "operation_costs")\n@Data\nclass CostConfig {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    private String endpoint;\n    private String method;\n    private Integer cost;\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"84-machine-learning-for-anomaly-detection",children:"8.4 Machine Learning for Anomaly Detection"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'@Service\npublic class AnomalyDetectionService {\n\n    @Autowired\n    private RedisTemplate<String, String> redisTemplate;\n\n    @Autowired\n    private UserBehaviorRepository behaviorRepository;\n\n    /**\n     * Detect anomalous request patterns\n     */\n    public AnomalyScore analyzeRequestPattern(String userId, String endpoint) {\n        // Get recent request history\n        List<Long> requestTimestamps = getRecentRequests(userId, endpoint);\n\n        if (requestTimestamps.size() < 10) {\n            return AnomalyScore.normal();\n        }\n\n        // Calculate request rate statistics\n        double avgInterval = calculateAverageInterval(requestTimestamps);\n        double stdDev = calculateStdDev(requestTimestamps, avgInterval);\n\n        // Get user\'s historical baseline\n        UserBehavior baseline = behaviorRepository\n            .findByUserIdAndEndpoint(userId, endpoint)\n            .orElse(null);\n\n        if (baseline == null) {\n            // First time, create baseline\n            createBaseline(userId, endpoint, avgInterval, stdDev);\n            return AnomalyScore.normal();\n        }\n\n        // Calculate anomaly score (Z-score)\n        double zScore = Math.abs((avgInterval - baseline.getAvgInterval()) /\n                                  baseline.getStdDev());\n\n        if (zScore > 3.0) {\n            return AnomalyScore.builder()\n                .score(zScore)\n                .anomalous(true)\n                .reason("Request rate significantly different from baseline")\n                .action(AnomalyAction.THROTTLE)\n                .build();\n        } else if (zScore > 2.0) {\n            return AnomalyScore.builder()\n                .score(zScore)\n                .anomalous(true)\n                .reason("Request rate moderately different from baseline")\n                .action(AnomalyAction.MONITOR)\n                .build();\n        }\n\n        return AnomalyScore.normal();\n    }\n\n    /**\n     * Get recent request timestamps\n     */\n    private List<Long> getRecentRequests(String userId, String endpoint) {\n        String key = "request_history:" + userId + ":" + endpoint;\n        Set<String> timestamps = redisTemplate.opsForZSet()\n            .rangeByScore(key, System.currentTimeMillis() - 300000,\n                         System.currentTimeMillis());\n\n        return timestamps.stream()\n            .map(Long::parseLong)\n            .collect(Collectors.toList());\n    }\n\n    /**\n     * Record request timestamp\n     */\n    public void recordRequest(String userId, String endpoint) {\n        String key = "request_history:" + userId + ":" + endpoint;\n        long now = System.currentTimeMillis();\n\n        redisTemplate.opsForZSet().add(key, String.valueOf(now), now);\n\n        // Keep only last 100 requests\n        redisTemplate.opsForZSet().removeRange(key, 0, -101);\n        redisTemplate.expire(key, Duration.ofMinutes(10));\n    }\n\n    private double calculateAverageInterval(List<Long> timestamps) {\n        if (timestamps.size() < 2) return 0;\n\n        List<Long> intervals = new ArrayList<>();\n        for (int i = 1; i < timestamps.size(); i++) {\n            intervals.add(timestamps.get(i) - timestamps.get(i - 1));\n        }\n\n        return intervals.stream()\n            .mapToLong(Long::longValue)\n            .average()\n            .orElse(0.0);\n    }\n\n    private double calculateStdDev(List<Long> timestamps, double avgInterval) {\n        if (timestamps.size() < 2) return 0;\n\n        List<Long> intervals = new ArrayList<>();\n        for (int i = 1; i < timestamps.size(); i++) {\n            intervals.add(timestamps.get(i) - timestamps.get(i - 1));\n        }\n\n        double variance = intervals.stream()\n            .mapToDouble(interval -> Math.pow(interval - avgInterval, 2))\n            .average()\n            .orElse(0.0);\n\n        return Math.sqrt(variance);\n    }\n\n    private void createBaseline(String userId, String endpoint,\n                               double avgInterval, double stdDev) {\n        UserBehavior behavior = new UserBehavior();\n        behavior.setUserId(userId);\n        behavior.setEndpoint(endpoint);\n        behavior.setAvgInterval(avgInterval);\n        behavior.setStdDev(stdDev);\n        behavior.setUpdatedAt(LocalDateTime.now());\n\n        behaviorRepository.save(behavior);\n    }\n}\n\n@Entity\n@Table(name = "user_behaviors")\n@Data\nclass UserBehavior {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    @Column(name = "user_id")\n    private String userId;\n\n    private String endpoint;\n\n    @Column(name = "avg_interval")\n    private Double avgInterval;\n\n    @Column(name = "std_dev")\n    private Double stdDev;\n\n    @Column(name = "updated_at")\n    private LocalDateTime updatedAt;\n}\n\n@Data\n@Builder\nclass AnomalyScore {\n    private double score;\n    private boolean anomalous;\n    private String reason;\n    private AnomalyAction action;\n\n    public static AnomalyScore normal() {\n        return AnomalyScore.builder()\n            .score(0.0)\n            .anomalous(false)\n            .action(AnomalyAction.ALLOW)\n            .build();\n    }\n}\n\nenum AnomalyAction {\n    ALLOW,\n    MONITOR,\n    THROTTLE,\n    BLOCK\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"85-self-service-dashboard-api",children:"8.5 Self-Service Dashboard API"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'@RestController\n@RequestMapping("/v1/dashboard")\npublic class UserDashboardController {\n\n    @Autowired\n    private RateLimiterService rateLimiterService;\n\n    @Autowired\n    private QuotaManagementService quotaService;\n\n    @Autowired\n    private UsageAnalyticsService analyticsService;\n\n    /**\n     * Get user\'s current rate limit status\n     */\n    @GetMapping("/status")\n    public ResponseEntity<DashboardStatus> getDashboardStatus(\n            @AuthenticationPrincipal UserDetails user) {\n\n        String userId = user.getUsername();\n\n        // Get quota status\n        QuotaResponse quota = quotaService.checkMonthlyQuota(userId);\n\n        // Get usage analytics\n        UsageStats stats = analyticsService.getUserStats(userId);\n\n        // Get active rate limits\n        List<RateLimitStatus> rateLimits = rateLimiterService\n            .getAllRateLimitStatuses(userId);\n\n        DashboardStatus status = DashboardStatus.builder()\n            .userId(userId)\n            .quota(quota)\n            .usageStats(stats)\n            .rateLimits(rateLimits)\n            .build();\n\n        return ResponseEntity.ok(status);\n    }\n\n    /**\n     * Get usage history\n     */\n    @GetMapping("/usage/history")\n    public ResponseEntity<UsageHistory> getUsageHistory(\n            @AuthenticationPrincipal UserDetails user,\n            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate startDate,\n            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate endDate) {\n\n        String userId = user.getUsername();\n        UsageHistory history = analyticsService.getUsageHistory(userId, startDate, endDate);\n\n        return ResponseEntity.ok(history);\n    }\n\n    /**\n     * Request tier upgrade\n     */\n    @PostMapping("/tier/upgrade")\n    public ResponseEntity<UpgradeRequest> requestTierUpgrade(\n            @AuthenticationPrincipal UserDetails user,\n            @RequestBody TierUpgradeDto upgradeDto) {\n\n        String userId = user.getUsername();\n\n        UpgradeRequest request = UpgradeRequest.builder()\n            .userId(userId)\n            .currentTier(upgradeDto.getCurrentTier())\n            .requestedTier(upgradeDto.getRequestedTier())\n            .reason(upgradeDto.getReason())\n            .status("PENDING")\n            .createdAt(LocalDateTime.now())\n            .build();\n\n        // Save request for admin review\n        // Send notification to admins\n\n        return ResponseEntity.ok(request);\n    }\n}\n\n@Data\n@Builder\nclass DashboardStatus {\n    private String userId;\n    private QuotaResponse quota;\n    private UsageStats usageStats;\n    private List<RateLimitStatus> rateLimits;\n}\n\n@Data\n@Builder\nclass UsageStats {\n    private long totalRequests;\n    private long requestsToday;\n    private long requestsThisMonth;\n    private Map<String, Long> requestsByEndpoint;\n    private List<TimeSeriesPoint> hourlyUsage;\n}\n\n@Data\n@Builder\nclass TimeSeriesPoint {\n    private long timestamp;\n    private long value;\n}\n\n@Data\n@Builder\nclass RateLimitStatus {\n    private String endpoint;\n    private int limit;\n    private int remaining;\n    private long resetTime;\n}\n\n@Data\nclass TierUpgradeDto {\n    private String currentTier;\n    private String requestedTier;\n    private String reason;\n}\n\n@Data\n@Builder\nclass UpgradeRequest {\n    private String userId;\n    private String currentTier;\n    private String requestedTier;\n    private String reason;\n    private String status;\n    private LocalDateTime createdAt;\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"86-testing",children:"8.6 Testing"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'@SpringBootTest\n@AutoConfigureMockMvc\nclass RateLimiterServiceTest {\n\n    @Autowired\n    private RateLimiterService rateLimiterService;\n\n    @Autowired\n    private RedisTemplate<String, String> redisTemplate;\n\n    @BeforeEach\n    void setUp() {\n        // Clean up Redis\n        redisTemplate.getConnectionFactory()\n            .getConnection()\n            .flushAll();\n    }\n\n    @Test\n    void testRateLimitAllowsRequestsWithinLimit() {\n        String userId = "testUser";\n        String endpoint = "/api/test";\n        String tier = "free";\n\n        // Configure rule: 10 requests per minute\n        RateLimitRule rule = new RateLimitRule();\n        rule.setTier(tier);\n        rule.setEndpointPattern(endpoint);\n        rule.setLimitCount(10);\n        rule.setWindowSeconds(60);\n\n        // Make 10 requests - all should be allowed\n        for (int i = 0; i < 10; i++) {\n            RateLimitResponse response = rateLimiterService\n                .checkRateLimit(userId, endpoint, tier);\n\n            assertTrue(response.isAllowed());\n            assertEquals(10 - i - 1, response.getRemaining());\n        }\n    }\n\n    @Test\n    void testRateLimitBlocksRequestsExceedingLimit() {\n        String userId = "testUser";\n        String endpoint = "/api/test";\n        String tier = "free";\n\n        // Make 11 requests - 11th should be blocked\n        for (int i = 0; i < 10; i++) {\n            rateLimiterService.checkRateLimit(userId, endpoint, tier);\n        }\n\n        RateLimitResponse response = rateLimiterService\n            .checkRateLimit(userId, endpoint, tier);\n\n        assertFalse(response.isAllowed());\n        assertNotNull(response.getRetryAfter());\n    }\n\n    @Test\n    void testFailOpenWhenRedisUnavailable() {\n        // Stop Redis or simulate connection failure\n        RedisTemplate<String, String> mockRedis = mock(RedisTemplate.class);\n        when(mockRedis.execute(any(RedisScript.class), anyList(), any()))\n            .thenThrow(new RedisConnectionFailureException("Connection failed"));\n\n        RateLimiterService serviceWithMock = new RateLimiterService();\n        // Inject mock\n\n        RateLimitResponse response = serviceWithMock\n            .checkRateLimit("user", "/api/test", "free");\n\n        assertTrue(response.isAllowed());\n        assertTrue(response.isDegraded());\n    }\n}\n\n@SpringBootTest\n@AutoConfigureTestDatabase\nclass RateLimitIntegrationTest {\n\n    @Autowired\n    private MockMvc mockMvc;\n\n    @Test\n    void testRateLimitHeadersInResponse() throws Exception {\n        mockMvc.perform(get("/api/posts")\n                .header("Authorization", "Bearer test-token"))\n            .andExpect(status().isOk())\n            .andExpect(header().exists("X-RateLimit-Limit"))\n            .andExpect(header().exists("X-RateLimit-Remaining"))\n            .andExpect(header().exists("X-RateLimit-Reset"));\n    }\n\n    @Test\n    void testRateLimitReturns429WhenExceeded() throws Exception {\n        // Make requests until rate limited\n        for (int i = 0; i < 100; i++) {\n            mockMvc.perform(get("/api/posts")\n                    .header("Authorization", "Bearer test-token"));\n        }\n\n        mockMvc.perform(get("/api/posts")\n                .header("Authorization", "Bearer test-token"))\n            .andExpect(status().isTooManyRequests())\n            .andExpect(header().exists("Retry-After"))\n            .andExpect(jsonPath("$.error").value("Rate limit exceeded"));\n    }\n}\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"9-summary",children:"9. Summary"}),"\n",(0,i.jsx)(n.p,{children:"This rate limiter design provides:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Sub-5ms latency with Redis + Token Bucket"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 High availability with fail-open strategy"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Scalable to millions of QPS"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Flexible multi-tier support"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Distributed system friendly"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Production-ready monitoring"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Complete Spring Boot implementation"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Circuit breaker for fault tolerance"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Pipeline support for performance"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Comprehensive testing strategy"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Key Components"}),": API Gateway \u2192 Rate Limiter Service \u2192 Redis Cluster \u2192 PostgreSQL Config DB"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Maven Dependencies Required"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-xml",children:"<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-data-jpa</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-data-redis</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>redis.clients</groupId>\n        <artifactId>jedis</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.postgresql</groupId>\n        <artifactId>postgresql</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>io.github.resilience4j</groupId>\n        <artifactId>resilience4j-spring-boot2</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>io.micrometer</groupId>\n        <artifactId>micrometer-registry-prometheus</artifactId>\n    </dependency>\n</dependencies>\n"})})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var i=t(96540);const r={},s=i.createContext(r);function a(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);