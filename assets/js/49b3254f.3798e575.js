"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[778],{28453:(n,e,t)=>{t.d(e,{R:()=>a,x:()=>c});var r=t(96540);const i={},s=r.createContext(i);function a(n){const e=r.useContext(s);return r.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function c(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:a(n.components),r.createElement(s.Provider,{value:e},n.children)}},97655:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>o,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>c,toc:()=>l});var r=t(74848),i=t(28453);const s={},a="Backtracking",c={id:"DSA/DSA/DSA with JavaScript/DSA Cheatsheets/Backtracking",title:"Backtracking",description:"A comprehensive guide to backtracking algorithms and techniques for Data Structures and Algorithms.",source:"@site/docs/05-DSA/DSA/DSA with JavaScript/DSA Cheatsheets/Backtracking.mdx",sourceDirName:"05-DSA/DSA/DSA with JavaScript/DSA Cheatsheets",slug:"/DSA/DSA/DSA with JavaScript/DSA Cheatsheets/Backtracking",permalink:"/docs/DSA/DSA/DSA with JavaScript/DSA Cheatsheets/Backtracking",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/05-DSA/DSA/DSA with JavaScript/DSA Cheatsheets/Backtracking.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Array",permalink:"/docs/DSA/DSA/DSA with JavaScript/DSA Cheatsheets/Array Techniques"},next:{title:"Binary Search",permalink:"/docs/DSA/DSA/DSA with JavaScript/DSA Cheatsheets/Binary Search"}},o={},l=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Core Backtracking Concepts",id:"core-backtracking-concepts",level:2},{value:"Key Characteristics:",id:"key-characteristics",level:3},{value:"When to Use Backtracking:",id:"when-to-use-backtracking",level:3},{value:"The Backtracking Template",id:"the-backtracking-template",level:2},{value:"Generic Backtracking Framework",id:"generic-backtracking-framework",level:3},{value:"Subset Generation Patterns",id:"subset-generation-patterns",level:2},{value:"1. All Subsets (Power Set)",id:"1-all-subsets-power-set",level:3},{value:"2. Subsets with Target Sum",id:"2-subsets-with-target-sum",level:3},{value:"3. Subsets with Duplicates",id:"3-subsets-with-duplicates",level:3},{value:"Permutation Patterns",id:"permutation-patterns",level:2},{value:"1. All Permutations",id:"1-all-permutations",level:3},{value:"2. Permutations with Duplicates",id:"2-permutations-with-duplicates",level:3},{value:"3. Next Permutation",id:"3-next-permutation",level:3},{value:"Combination Patterns",id:"combination-patterns",level:2},{value:"1. Combinations of Size K",id:"1-combinations-of-size-k",level:3},{value:"2. Combination Sum",id:"2-combination-sum",level:3},{value:"3. Combination Sum II",id:"3-combination-sum-ii",level:3},{value:"Constraint Satisfaction Problems",id:"constraint-satisfaction-problems",level:2},{value:"1. N-Queens Problem",id:"1-n-queens-problem",level:3},{value:"2. Sudoku Solver",id:"2-sudoku-solver",level:3},{value:"Grid/Matrix Backtracking",id:"gridmatrix-backtracking",level:2},{value:"1. Word Search",id:"1-word-search",level:3},{value:"2. Number of Islands",id:"2-number-of-islands",level:3},{value:"3. Rat in Maze",id:"3-rat-in-maze",level:3},{value:"String Backtracking",id:"string-backtracking",level:2},{value:"1. Generate Parentheses",id:"1-generate-parentheses",level:3},{value:"2. Letter Combinations of Phone Number",id:"2-letter-combinations-of-phone-number",level:3},{value:"3. Palindrome Partitioning",id:"3-palindrome-partitioning",level:3},{value:"Tree Path Backtracking",id:"tree-path-backtracking",level:2},{value:"1. Binary Tree Paths",id:"1-binary-tree-paths",level:3},{value:"2. Path Sum II",id:"2-path-sum-ii",level:3},{value:"Game Theory Backtracking",id:"game-theory-backtracking",level:2},{value:"1. Tic-Tac-Toe Winner",id:"1-tic-tac-toe-winner",level:3},{value:"Optimization Techniques",id:"optimization-techniques",level:2},{value:"1. Memoization",id:"1-memoization",level:3},{value:"2. Early Termination",id:"2-early-termination",level:3},{value:"3. Pruning Strategies",id:"3-pruning-strategies",level:3},{value:"Common Pitfalls &amp; Best Practices",id:"common-pitfalls--best-practices",level:2},{value:"\u274c Common Mistakes",id:"-common-mistakes",level:3},{value:"\u2705 Best Practices",id:"-best-practices",level:3},{value:"Time Complexity Analysis",id:"time-complexity-analysis",level:3},{value:"Memory Optimization Tips",id:"memory-optimization-tips",level:3},{value:"Advanced Patterns &amp; Techniques",id:"advanced-patterns--techniques",level:2},{value:"1. Multi-Dimensional Backtracking",id:"1-multi-dimensional-backtracking",level:3},{value:"2. Backtracking with State Compression",id:"2-backtracking-with-state-compression",level:3},{value:"3. Iterative Backtracking",id:"3-iterative-backtracking",level:3},{value:"4. Parallel Backtracking Concepts",id:"4-parallel-backtracking-concepts",level:3},{value:"Problem-Specific Optimizations",id:"problem-specific-optimizations",level:2},{value:"1. Constraint-Specific Pruning",id:"1-constraint-specific-pruning",level:3},{value:"2. Dynamic Constraint Updates",id:"2-dynamic-constraint-updates",level:3},{value:"Testing &amp; Debugging Backtracking",id:"testing--debugging-backtracking",level:2},{value:"1. Debug Visualization",id:"1-debug-visualization",level:3},{value:"2. Performance Monitoring",id:"2-performance-monitoring",level:3},{value:"Real-World Applications",id:"real-world-applications",level:2},{value:"1. Schedule Optimization",id:"1-schedule-optimization",level:3},{value:"2. Configuration Management",id:"2-configuration-management",level:3},{value:"Quick Reference",id:"quick-reference",level:2},{value:"Common Backtracking Patterns",id:"common-backtracking-patterns",level:3},{value:"Optimization Checklist",id:"optimization-checklist",level:3},{value:"Time Complexity Quick Reference",id:"time-complexity-quick-reference",level:3}];function u(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"backtracking",children:"Backtracking"})}),"\n",(0,r.jsx)(e.p,{children:"A comprehensive guide to backtracking algorithms and techniques for Data Structures and Algorithms."}),"\n",(0,r.jsx)(e.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#core-backtracking-concepts",children:"Core Backtracking Concepts"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#the-backtracking-template",children:"The Backtracking Template"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#subset-generation-patterns",children:"Subset Generation Patterns"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#permutation-patterns",children:"Permutation Patterns"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#combination-patterns",children:"Combination Patterns"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#constraint-satisfaction-problems",children:"Constraint Satisfaction Problems"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#gridmatrix-backtracking",children:"Grid/Matrix Backtracking"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#string-backtracking",children:"String Backtracking"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#tree-path-backtracking",children:"Tree Path Backtracking"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#game-theory-backtracking",children:"Game Theory Backtracking"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#optimization-techniques",children:"Optimization Techniques"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#common-pitfalls--best-practices",children:"Common Pitfalls & Best Practices"})}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"core-backtracking-concepts",children:"Core Backtracking Concepts"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Backtracking"}),' is a systematic way to explore all possible solutions by incrementally building candidates and abandoning ("backtracking") candidates that cannot lead to valid solutions.']}),"\n",(0,r.jsx)(e.h3,{id:"key-characteristics",children:"Key Characteristics:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Recursive"}),": Explores solutions recursively"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Incremental"}),": Builds solution step by step"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Pruning"}),": Abandons invalid paths early"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Complete Search"}),": Explores all possibilities (if needed)"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"when-to-use-backtracking",children:"When to Use Backtracking:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Finding all possible solutions"}),"\n",(0,r.jsx)(e.li,{children:"Finding one valid solution"}),"\n",(0,r.jsx)(e.li,{children:"Optimization problems with constraints"}),"\n",(0,r.jsx)(e.li,{children:"Combinatorial problems (subsets, permutations, combinations)"}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"the-backtracking-template",children:"The Backtracking Template"}),"\n",(0,r.jsx)(e.p,{children:"This is the fundamental template that applies to most backtracking problems:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function backtrack(state, choices, constraints) {\n  // Base case: valid solution found\n  if (isValidSolution(state)) {\n    recordSolution(state);\n    return;\n  }\n\n  // Try all possible choices\n  for (let choice of getValidChoices(choices, state)) {\n    // Make choice\n    state.push(choice);\n\n    // Recurse with updated state\n    if (isValid(state, constraints)) {\n      backtrack(state, getNewChoices(choices, choice), constraints);\n    }\n\n    // Backtrack: undo choice\n    state.pop();\n  }\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"generic-backtracking-framework",children:"Generic Backtracking Framework"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"class BacktrackSolver {\n  constructor() {\n    this.solutions = [];\n  }\n\n  solve(problem) {\n    this.solutions = [];\n    this.backtrack([], problem.choices, problem.constraints);\n    return this.solutions;\n  }\n\n  backtrack(currentSolution, availableChoices, constraints) {\n    // Base case\n    if (this.isComplete(currentSolution, constraints)) {\n      this.solutions.push([...currentSolution]);\n      return;\n    }\n\n    // Try each valid choice\n    for (let choice of this.getValidChoices(\n      availableChoices,\n      currentSolution,\n      constraints\n    )) {\n      // Make choice\n      currentSolution.push(choice);\n\n      // Recurse if still valid\n      if (this.isValidPartial(currentSolution, constraints)) {\n        this.backtrack(\n          currentSolution,\n          this.updateChoices(availableChoices, choice),\n          constraints\n        );\n      }\n\n      // Backtrack\n      currentSolution.pop();\n    }\n  }\n\n  isComplete(solution, constraints) {\n    /* Override */\n  }\n  isValidPartial(solution, constraints) {\n    /* Override */\n  }\n  getValidChoices(choices, solution, constraints) {\n    /* Override */\n  }\n  updateChoices(choices, selectedChoice) {\n    /* Override */\n  }\n}\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"subset-generation-patterns",children:"Subset Generation Patterns"}),"\n",(0,r.jsx)(e.h3,{id:"1-all-subsets-power-set",children:"1. All Subsets (Power Set)"}),"\n",(0,r.jsx)(e.p,{children:"Generate all possible subsets of a given set."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function subsets(nums) {\n  const result = [];\n\n  function backtrack(start, currentSubset) {\n    // Every recursive call represents a valid subset\n    result.push([...currentSubset]);\n\n    // Try adding each remaining element\n    for (let i = start; i < nums.length; i++) {\n      currentSubset.push(nums[i]);\n      backtrack(i + 1, currentSubset);\n      currentSubset.pop(); // Backtrack\n    }\n  }\n\n  backtrack(0, []);\n  return result;\n}\n\n// Example: [1,2,3] \u2192 [[], [1], [2], [3], [1,2], [1,3], [2,3], [1,2,3]]\n"})}),"\n",(0,r.jsx)(e.h3,{id:"2-subsets-with-target-sum",children:"2. Subsets with Target Sum"}),"\n",(0,r.jsx)(e.p,{children:"Find all subsets that sum to a target value."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function subsetsWithTargetSum(nums, target) {\n  const result = [];\n\n  function backtrack(start, currentSubset, currentSum) {\n    if (currentSum === target) {\n      result.push([...currentSubset]);\n      return;\n    }\n\n    if (currentSum > target) return; // Pruning\n\n    for (let i = start; i < nums.length; i++) {\n      currentSubset.push(nums[i]);\n      backtrack(i + 1, currentSubset, currentSum + nums[i]);\n      currentSubset.pop();\n    }\n  }\n\n  backtrack(0, [], 0);\n  return result;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"3-subsets-with-duplicates",children:"3. Subsets with Duplicates"}),"\n",(0,r.jsx)(e.p,{children:"Handle arrays with duplicate elements."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function subsetsWithDup(nums) {\n  nums.sort(); // Important: sort to handle duplicates\n  const result = [];\n\n  function backtrack(start, currentSubset) {\n    result.push([...currentSubset]);\n\n    for (let i = start; i < nums.length; i++) {\n      // Skip duplicates: only use first occurrence at each level\n      if (i > start && nums[i] === nums[i - 1]) continue;\n\n      currentSubset.push(nums[i]);\n      backtrack(i + 1, currentSubset);\n      currentSubset.pop();\n    }\n  }\n\n  backtrack(0, []);\n  return result;\n}\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"permutation-patterns",children:"Permutation Patterns"}),"\n",(0,r.jsx)(e.h3,{id:"1-all-permutations",children:"1. All Permutations"}),"\n",(0,r.jsx)(e.p,{children:"Generate all possible arrangements of elements."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function permute(nums) {\n  const result = [];\n\n  function backtrack(currentPermutation, used) {\n    if (currentPermutation.length === nums.length) {\n      result.push([...currentPermutation]);\n      return;\n    }\n\n    for (let i = 0; i < nums.length; i++) {\n      if (used[i]) continue; // Skip used elements\n\n      // Make choice\n      currentPermutation.push(nums[i]);\n      used[i] = true;\n\n      backtrack(currentPermutation, used);\n\n      // Backtrack\n      currentPermutation.pop();\n      used[i] = false;\n    }\n  }\n\n  backtrack([], new Array(nums.length).fill(false));\n  return result;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"2-permutations-with-duplicates",children:"2. Permutations with Duplicates"}),"\n",(0,r.jsx)(e.p,{children:"Handle arrays with duplicate elements."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function permuteUnique(nums) {\n  nums.sort(); // Sort to group duplicates\n  const result = [];\n  const used = new Array(nums.length).fill(false);\n\n  function backtrack(currentPermutation) {\n    if (currentPermutation.length === nums.length) {\n      result.push([...currentPermutation]);\n      return;\n    }\n\n    for (let i = 0; i < nums.length; i++) {\n      if (used[i]) continue;\n\n      // Skip duplicates: use duplicate only if previous same element is used\n      if (i > 0 && nums[i] === nums[i - 1] && !used[i - 1]) {\n        continue;\n      }\n\n      currentPermutation.push(nums[i]);\n      used[i] = true;\n\n      backtrack(currentPermutation);\n\n      currentPermutation.pop();\n      used[i] = false;\n    }\n  }\n\n  backtrack([]);\n  return result;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"3-next-permutation",children:"3. Next Permutation"}),"\n",(0,r.jsx)(e.p,{children:"Find lexicographically next permutation."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function nextPermutation(nums) {\n  // Step 1: Find the largest index i such that nums[i] < nums[i + 1]\n  let i = nums.length - 2;\n  while (i >= 0 && nums[i] >= nums[i + 1]) {\n    i--;\n  }\n\n  if (i >= 0) {\n    // Step 2: Find the largest index j such that nums[i] < nums[j]\n    let j = nums.length - 1;\n    while (nums[j] <= nums[i]) {\n      j--;\n    }\n    // Step 3: Swap nums[i] and nums[j]\n    [nums[i], nums[j]] = [nums[j], nums[i]];\n  }\n\n  // Step 4: Reverse the suffix starting at nums[i + 1]\n  reverse(nums, i + 1);\n\n  function reverse(arr, start) {\n    let left = start,\n      right = arr.length - 1;\n    while (left < right) {\n      [arr[left], arr[right]] = [arr[right], arr[left]];\n      left++;\n      right--;\n    }\n  }\n}\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"combination-patterns",children:"Combination Patterns"}),"\n",(0,r.jsx)(e.h3,{id:"1-combinations-of-size-k",children:"1. Combinations of Size K"}),"\n",(0,r.jsx)(e.p,{children:"Generate all combinations of k elements."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function combine(n, k) {\n  const result = [];\n\n  function backtrack(start, currentCombination) {\n    if (currentCombination.length === k) {\n      result.push([...currentCombination]);\n      return;\n    }\n\n    // Optimization: only continue if we have enough elements left\n    for (let i = start; i <= n - (k - currentCombination.length) + 1; i++) {\n      currentCombination.push(i);\n      backtrack(i + 1, currentCombination);\n      currentCombination.pop();\n    }\n  }\n\n  backtrack(1, []);\n  return result;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"2-combination-sum",children:"2. Combination Sum"}),"\n",(0,r.jsx)(e.p,{children:"Find combinations that sum to target (elements can be reused)."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function combinationSum(candidates, target) {\n  const result = [];\n\n  function backtrack(start, currentCombination, currentSum) {\n    if (currentSum === target) {\n      result.push([...currentCombination]);\n      return;\n    }\n\n    if (currentSum > target) return; // Pruning\n\n    for (let i = start; i < candidates.length; i++) {\n      currentCombination.push(candidates[i]);\n      // Note: i (not i+1) because we can reuse the same element\n      backtrack(i, currentCombination, currentSum + candidates[i]);\n      currentCombination.pop();\n    }\n  }\n\n  backtrack(0, [], 0);\n  return result;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"3-combination-sum-ii",children:"3. Combination Sum II"}),"\n",(0,r.jsx)(e.p,{children:"Each element can only be used once, handle duplicates."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function combinationSum2(candidates, target) {\n  candidates.sort();\n  const result = [];\n\n  function backtrack(start, currentCombination, currentSum) {\n    if (currentSum === target) {\n      result.push([...currentCombination]);\n      return;\n    }\n\n    for (let i = start; i < candidates.length; i++) {\n      if (currentSum + candidates[i] > target) break; // Pruning\n\n      // Skip duplicates\n      if (i > start && candidates[i] === candidates[i - 1]) continue;\n\n      currentCombination.push(candidates[i]);\n      backtrack(i + 1, currentCombination, currentSum + candidates[i]);\n      currentCombination.pop();\n    }\n  }\n\n  backtrack(0, [], 0);\n  return result;\n}\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"constraint-satisfaction-problems",children:"Constraint Satisfaction Problems"}),"\n",(0,r.jsx)(e.h3,{id:"1-n-queens-problem",children:"1. N-Queens Problem"}),"\n",(0,r.jsx)(e.p,{children:"Place N queens on N\xd7N chessboard so none attack each other."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function solveNQueens(n) {\n  const result = [];\n  const board = Array(n)\n    .fill()\n    .map(() => Array(n).fill('.'));\n\n  function backtrack(row) {\n    if (row === n) {\n      result.push(board.map(row => row.join('')));\n      return;\n    }\n\n    for (let col = 0; col < n; col++) {\n      if (isValid(row, col)) {\n        board[row][col] = 'Q';\n        backtrack(row + 1);\n        board[row][col] = '.';\n      }\n    }\n  }\n\n  function isValid(row, col) {\n    // Check column\n    for (let i = 0; i < row; i++) {\n      if (board[i][col] === 'Q') return false;\n    }\n\n    // Check diagonal (top-left to bottom-right)\n    for (let i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\n      if (board[i][j] === 'Q') return false;\n    }\n\n    // Check diagonal (top-right to bottom-left)\n    for (let i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {\n      if (board[i][j] === 'Q') return false;\n    }\n\n    return true;\n  }\n\n  backtrack(0);\n  return result;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"2-sudoku-solver",children:"2. Sudoku Solver"}),"\n",(0,r.jsx)(e.p,{children:"Solve 9\xd79 Sudoku puzzle."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function solveSudoku(board) {\n  function backtrack() {\n    for (let row = 0; row < 9; row++) {\n      for (let col = 0; col < 9; col++) {\n        if (board[row][col] === '.') {\n          for (let num = '1'; num <= '9'; num++) {\n            if (isValid(board, row, col, num)) {\n              board[row][col] = num;\n\n              if (backtrack()) return true;\n\n              board[row][col] = '.'; // Backtrack\n            }\n          }\n          return false; // No valid number found\n        }\n      }\n    }\n    return true; // All cells filled\n  }\n\n  function isValid(board, row, col, num) {\n    // Check row\n    for (let j = 0; j < 9; j++) {\n      if (board[row][j] === num) return false;\n    }\n\n    // Check column\n    for (let i = 0; i < 9; i++) {\n      if (board[i][col] === num) return false;\n    }\n\n    // Check 3\xd73 box\n    const boxRow = Math.floor(row / 3) * 3;\n    const boxCol = Math.floor(col / 3) * 3;\n    for (let i = boxRow; i < boxRow + 3; i++) {\n      for (let j = boxCol; j < boxCol + 3; j++) {\n        if (board[i][j] === num) return false;\n      }\n    }\n\n    return true;\n  }\n\n  backtrack();\n}\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"gridmatrix-backtracking",children:"Grid/Matrix Backtracking"}),"\n",(0,r.jsx)(e.h3,{id:"1-word-search",children:"1. Word Search"}),"\n",(0,r.jsx)(e.p,{children:"Find if word exists in 2D grid."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function exist(board, word) {\n  const m = board.length;\n  const n = board[0].length;\n\n  function backtrack(row, col, index) {\n    if (index === word.length) return true;\n\n    if (\n      row < 0 ||\n      row >= m ||\n      col < 0 ||\n      col >= n ||\n      board[row][col] !== word[index]\n    ) {\n      return false;\n    }\n\n    // Mark as visited\n    const temp = board[row][col];\n    board[row][col] = '#';\n\n    // Explore all 4 directions\n    const found =\n      backtrack(row + 1, col, index + 1) ||\n      backtrack(row - 1, col, index + 1) ||\n      backtrack(row, col + 1, index + 1) ||\n      backtrack(row, col - 1, index + 1);\n\n    // Backtrack: restore original value\n    board[row][col] = temp;\n\n    return found;\n  }\n\n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      if (backtrack(i, j, 0)) return true;\n    }\n  }\n\n  return false;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"2-number-of-islands",children:"2. Number of Islands"}),"\n",(0,r.jsx)(e.p,{children:"Count connected components in grid."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function numIslands(grid) {\n  if (!grid || grid.length === 0) return 0;\n\n  const m = grid.length;\n  const n = grid[0].length;\n  let count = 0;\n\n  function dfs(i, j) {\n    if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] !== '1') {\n      return;\n    }\n\n    grid[i][j] = '0'; // Mark as visited\n\n    // Explore all 4 directions\n    dfs(i + 1, j);\n    dfs(i - 1, j);\n    dfs(i, j + 1);\n    dfs(i, j - 1);\n  }\n\n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      if (grid[i][j] === '1') {\n        count++;\n        dfs(i, j);\n      }\n    }\n  }\n\n  return count;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"3-rat-in-maze",children:"3. Rat in Maze"}),"\n",(0,r.jsx)(e.p,{children:"Find path from source to destination."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function ratInMaze(maze) {\n  const n = maze.length;\n  const solution = Array(n)\n    .fill()\n    .map(() => Array(n).fill(0));\n\n  function isSafe(x, y) {\n    return x >= 0 && x < n && y >= 0 && y < n && maze[x][y] === 1;\n  }\n\n  function backtrack(x, y) {\n    // Base case: reached destination\n    if (x === n - 1 && y === n - 1 && maze[x][y] === 1) {\n      solution[x][y] = 1;\n      return true;\n    }\n\n    if (isSafe(x, y)) {\n      solution[x][y] = 1;\n\n      // Move right\n      if (backtrack(x, y + 1)) return true;\n\n      // Move down\n      if (backtrack(x + 1, y)) return true;\n\n      // Backtrack\n      solution[x][y] = 0;\n    }\n\n    return false;\n  }\n\n  if (backtrack(0, 0)) {\n    return solution;\n  }\n\n  return null; // No solution\n}\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"string-backtracking",children:"String Backtracking"}),"\n",(0,r.jsx)(e.h3,{id:"1-generate-parentheses",children:"1. Generate Parentheses"}),"\n",(0,r.jsx)(e.p,{children:"Generate all valid parentheses combinations."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function generateParenthesis(n) {\n  const result = [];\n\n  function backtrack(current, open, close) {\n    if (current.length === 2 * n) {\n      result.push(current);\n      return;\n    }\n\n    // Add opening parenthesis if we haven't used all\n    if (open < n) {\n      backtrack(current + '(', open + 1, close);\n    }\n\n    // Add closing parenthesis if it won't make invalid combination\n    if (close < open) {\n      backtrack(current + ')', open, close + 1);\n    }\n  }\n\n  backtrack('', 0, 0);\n  return result;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"2-letter-combinations-of-phone-number",children:"2. Letter Combinations of Phone Number"}),"\n",(0,r.jsx)(e.p,{children:"Map phone digits to letters."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function letterCombinations(digits) {\n  if (!digits) return [];\n\n  const digitMap = {\n    2: 'abc',\n    3: 'def',\n    4: 'ghi',\n    5: 'jkl',\n    6: 'mno',\n    7: 'pqrs',\n    8: 'tuv',\n    9: 'wxyz',\n  };\n\n  const result = [];\n\n  function backtrack(index, current) {\n    if (index === digits.length) {\n      result.push(current);\n      return;\n    }\n\n    const letters = digitMap[digits[index]];\n    for (let letter of letters) {\n      backtrack(index + 1, current + letter);\n    }\n  }\n\n  backtrack(0, '');\n  return result;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"3-palindrome-partitioning",children:"3. Palindrome Partitioning"}),"\n",(0,r.jsx)(e.p,{children:"Partition string into palindromic substrings."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function partition(s) {\n  const result = [];\n\n  function isPalindrome(str, left, right) {\n    while (left < right) {\n      if (str[left] !== str[right]) return false;\n      left++;\n      right--;\n    }\n    return true;\n  }\n\n  function backtrack(start, currentPartition) {\n    if (start === s.length) {\n      result.push([...currentPartition]);\n      return;\n    }\n\n    for (let end = start; end < s.length; end++) {\n      if (isPalindrome(s, start, end)) {\n        currentPartition.push(s.substring(start, end + 1));\n        backtrack(end + 1, currentPartition);\n        currentPartition.pop();\n      }\n    }\n  }\n\n  backtrack(0, []);\n  return result;\n}\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"tree-path-backtracking",children:"Tree Path Backtracking"}),"\n",(0,r.jsx)(e.h3,{id:"1-binary-tree-paths",children:"1. Binary Tree Paths"}),"\n",(0,r.jsx)(e.p,{children:"Find all root-to-leaf paths."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function binaryTreePaths(root) {\n  const result = [];\n\n  function backtrack(node, currentPath) {\n    if (!node) return;\n\n    currentPath.push(node.val);\n\n    // If leaf node, add path to result\n    if (!node.left && !node.right) {\n      result.push(currentPath.join('->'));\n    } else {\n      backtrack(node.left, currentPath);\n      backtrack(node.right, currentPath);\n    }\n\n    currentPath.pop(); // Backtrack\n  }\n\n  backtrack(root, []);\n  return result;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"2-path-sum-ii",children:"2. Path Sum II"}),"\n",(0,r.jsx)(e.p,{children:"Find all paths with given sum."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function pathSum(root, targetSum) {\n  const result = [];\n\n  function backtrack(node, currentPath, currentSum) {\n    if (!node) return;\n\n    currentPath.push(node.val);\n    currentSum += node.val;\n\n    // If leaf and sum matches target\n    if (!node.left && !node.right && currentSum === targetSum) {\n      result.push([...currentPath]);\n    } else {\n      backtrack(node.left, currentPath, currentSum);\n      backtrack(node.right, currentPath, currentSum);\n    }\n\n    currentPath.pop(); // Backtrack\n  }\n\n  backtrack(root, [], 0);\n  return result;\n}\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"game-theory-backtracking",children:"Game Theory Backtracking"}),"\n",(0,r.jsx)(e.h3,{id:"1-tic-tac-toe-winner",children:"1. Tic-Tac-Toe Winner"}),"\n",(0,r.jsx)(e.p,{children:"Check if current player can win."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function canWin(board) {\n  function getValidMoves() {\n    const moves = [];\n    for (let i = 0; i < board.length; i++) {\n      if (board[i] === ' ') moves.push(i);\n    }\n    return moves;\n  }\n\n  function isWinning(board) {\n    const lines = [\n      [0, 1, 2],\n      [3, 4, 5],\n      [6, 7, 8], // rows\n      [0, 3, 6],\n      [1, 4, 7],\n      [2, 5, 8], // columns\n      [0, 4, 8],\n      [2, 4, 6], // diagonals\n    ];\n\n    for (let [a, b, c] of lines) {\n      if (board[a] === board[b] && board[b] === board[c] && board[a] !== ' ') {\n        return board[a];\n      }\n    }\n    return null;\n  }\n\n  function backtrack(isMaxPlayer) {\n    const winner = isWinning(board);\n    if (winner === 'X') return 1; // Max player wins\n    if (winner === 'O') return -1; // Min player wins\n\n    const validMoves = getValidMoves();\n    if (validMoves.length === 0) return 0; // Draw\n\n    if (isMaxPlayer) {\n      let maxScore = -Infinity;\n      for (let move of validMoves) {\n        board[move] = 'X';\n        const score = backtrack(false);\n        board[move] = ' ';\n        maxScore = Math.max(maxScore, score);\n      }\n      return maxScore;\n    } else {\n      let minScore = Infinity;\n      for (let move of validMoves) {\n        board[move] = 'O';\n        const score = backtrack(true);\n        board[move] = ' ';\n        minScore = Math.min(minScore, score);\n      }\n      return minScore;\n    }\n  }\n\n  return backtrack(true) > 0;\n}\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"optimization-techniques",children:"Optimization Techniques"}),"\n",(0,r.jsx)(e.h3,{id:"1-memoization",children:"1. Memoization"}),"\n",(0,r.jsx)(e.p,{children:"Cache results to avoid recomputation."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function uniquePathsWithMemo(m, n, obstacles) {\n  const memo = new Map();\n\n  function backtrack(row, col) {\n    if (row >= m || col >= n || obstacles[row][col] === 1) {\n      return 0;\n    }\n\n    if (row === m - 1 && col === n - 1) {\n      return 1;\n    }\n\n    const key = `${row},${col}`;\n    if (memo.has(key)) {\n      return memo.get(key);\n    }\n\n    const paths = backtrack(row + 1, col) + backtrack(row, col + 1);\n    memo.set(key, paths);\n\n    return paths;\n  }\n\n  return backtrack(0, 0);\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"2-early-termination",children:"2. Early Termination"}),"\n",(0,r.jsx)(e.p,{children:"Stop search when optimal solution found."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function findFirstSolution(candidates, target) {\n  function backtrack(start, current, sum) {\n    if (sum === target) {\n      return [...current]; // Return first valid solution\n    }\n\n    if (sum > target) return null;\n\n    for (let i = start; i < candidates.length; i++) {\n      current.push(candidates[i]);\n\n      const result = backtrack(i + 1, current, sum + candidates[i]);\n      if (result) return result; // Early termination\n\n      current.pop();\n    }\n\n    return null;\n  }\n\n  return backtrack(0, [], 0);\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"3-pruning-strategies",children:"3. Pruning Strategies"}),"\n",(0,r.jsx)(e.p,{children:"Eliminate invalid branches early."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function combinationSumOptimized(candidates, target) {\n  candidates.sort(); // Sort for pruning\n  const result = [];\n\n  function backtrack(start, current, sum) {\n    if (sum === target) {\n      result.push([...current]);\n      return;\n    }\n\n    for (let i = start; i < candidates.length; i++) {\n      // Pruning: if current candidate exceeds target, break\n      if (sum + candidates[i] > target) break;\n\n      current.push(candidates[i]);\n      backtrack(i, current, sum + candidates[i]);\n      current.pop();\n    }\n  }\n\n  backtrack(0, [], 0);\n  return result;\n}\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"common-pitfalls--best-practices",children:"Common Pitfalls & Best Practices"}),"\n",(0,r.jsx)(e.h3,{id:"-common-mistakes",children:"\u274c Common Mistakes"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"Forgetting to Backtrack"})}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"// Wrong: Missing backtrack\nfunction wrong(nums) {\n  const result = [];\n  const current = [];\n\n  function dfs(index) {\n    if (index === nums.length) {\n      result.push(current); // BUG: Reference to same array\n      return;\n    }\n\n    current.push(nums[index]);\n    dfs(index + 1);\n    // Missing: current.pop();\n  }\n}\n\n// Correct: Proper backtracking\nfunction correct(nums) {\n  const result = [];\n  const current = [];\n\n  function dfs(index) {\n    if (index === nums.length) {\n      result.push([...current]); // Create copy\n      return;\n    }\n\n    current.push(nums[index]);\n    dfs(index + 1);\n    current.pop(); // Backtrack\n  }\n}\n"})}),"\n",(0,r.jsxs)(e.ol,{start:"2",children:["\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"Infinite Recursion"})}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"// Wrong: No base case or improper progression\nfunction infiniteRecursion(nums) {\n  function backtrack(current) {\n    // Missing base case\n    for (let num of nums) {\n      current.push(num);\n      backtrack(current); // Same state, infinite loop\n      current.pop();\n    }\n  }\n}\n"})}),"\n",(0,r.jsxs)(e.ol,{start:"3",children:["\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"Not Handling Duplicates Properly"})}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"// Wrong: Doesn't skip duplicates\nfunction wrongDuplicates(nums) {\n  const result = [];\n\n  function backtrack(start, current) {\n    result.push([...current]);\n\n    for (let i = start; i < nums.length; i++) {\n      current.push(nums[i]);\n      backtrack(i + 1, current);\n      current.pop();\n    }\n  }\n\n  backtrack(0, []);\n  return result; // Will have duplicates\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"-best-practices",children:"\u2705 Best Practices"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"Always Make Copies When Storing Results"})}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"result.push([...currentSolution]); // Good\nresult.push(currentSolution); // Bad - stores reference\n"})}),"\n",(0,r.jsxs)(e.ol,{start:"2",children:["\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"Use Early Pruning"})}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"if (currentSum > target) return; // Stop early if invalid\n"})}),"\n",(0,r.jsxs)(e.ol,{start:"3",children:["\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"Sort Arrays When Dealing with Duplicates"})}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"nums.sort(); // Helps group duplicates together\n"})}),"\n",(0,r.jsxs)(e.ol,{start:"4",children:["\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"Use Clear Variable Names"})}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function backtrack(startIndex, currentCombination, remainingSum) {\n  // Clear parameter names make code readable\n}\n"})}),"\n",(0,r.jsxs)(e.ol,{start:"5",children:["\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"Add Comments for Complex Logic"})}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"// Skip duplicates: only use first occurrence at each level\nif (i > start && nums[i] === nums[i - 1]) continue;\n"})}),"\n",(0,r.jsx)(e.h3,{id:"time-complexity-analysis",children:"Time Complexity Analysis"}),"\n",(0,r.jsxs)(e.table,{children:[(0,r.jsx)(e.thead,{children:(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.th,{children:"Problem Type"}),(0,r.jsx)(e.th,{children:"Time Complexity"}),(0,r.jsx)(e.th,{children:"Space Complexity"})]})}),(0,r.jsxs)(e.tbody,{children:[(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"All Subsets"}),(0,r.jsx)(e.td,{children:"O(2^n)"}),(0,r.jsx)(e.td,{children:"O(n)"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"All Permutations"}),(0,r.jsx)(e.td,{children:"O(n! \xd7 n)"}),(0,r.jsx)(e.td,{children:"O(n)"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Combinations"}),(0,r.jsx)(e.td,{children:"O(C(n,k))"}),(0,r.jsx)(e.td,{children:"O(k)"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"N-Queens"}),(0,r.jsx)(e.td,{children:"O(N!)"}),(0,r.jsx)(e.td,{children:"O(N)"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Sudoku"}),(0,r.jsx)(e.td,{children:"O(9^(n\xd7n))"}),(0,r.jsx)(e.td,{children:"O(n\xd7n)"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Word Search"}),(0,r.jsx)(e.td,{children:"O(4^L) where L is word length"}),(0,r.jsx)(e.td,{children:"O(L)"})]})]})]}),"\n",(0,r.jsx)(e.h3,{id:"memory-optimization-tips",children:"Memory Optimization Tips"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"Reuse Data Structures"})}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"const used = new Array(nums.length).fill(false);\n// Reuse same boolean array instead of creating new ones\n"})}),"\n",(0,r.jsxs)(e.ol,{start:"2",children:["\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"Use Bit Manipulation for States"})}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function backtrackWithBitmask(nums) {\n  function dfs(mask, current) {\n    if (mask === (1 << nums.length) - 1) {\n      // All elements used\n      return [...current];\n    }\n\n    for (let i = 0; i < nums.length; i++) {\n      if (mask & (1 << i)) continue; // Already used\n\n      current.push(nums[i]);\n      const result = dfs(mask | (1 << i), current);\n      if (result) return result;\n      current.pop();\n    }\n  }\n\n  return dfs(0, []);\n}\n"})}),"\n",(0,r.jsxs)(e.ol,{start:"3",children:["\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"In-Place Modifications"})}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function wordSearchOptimized(board, word) {\n  function dfs(i, j, k) {\n    if (k === word.length) return true;\n    if (i < 0 || i >= board.length || j < 0 || j >= board[0].length)\n      return false;\n    if (board[i][j] !== word[k]) return false;\n\n    // In-place modification instead of separate visited array\n    const temp = board[i][j];\n    board[i][j] = '#';\n\n    const found =\n      dfs(i + 1, j, k + 1) ||\n      dfs(i - 1, j, k + 1) ||\n      dfs(i, j + 1, k + 1) ||\n      dfs(i, j - 1, k + 1);\n\n    board[i][j] = temp; // Restore\n    return found;\n  }\n}\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"advanced-patterns--techniques",children:"Advanced Patterns & Techniques"}),"\n",(0,r.jsx)(e.h3,{id:"1-multi-dimensional-backtracking",children:"1. Multi-Dimensional Backtracking"}),"\n",(0,r.jsx)(e.p,{children:"Solve problems with multiple constraints simultaneously."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function wordBreakII(s, wordDict) {\n  const wordSet = new Set(wordDict);\n  const result = [];\n\n  function backtrack(start, currentSentence) {\n    if (start === s.length) {\n      result.push(currentSentence.join(' '));\n      return;\n    }\n\n    for (let end = start + 1; end <= s.length; end++) {\n      const word = s.slice(start, end);\n      if (wordSet.has(word)) {\n        currentSentence.push(word);\n        backtrack(end, currentSentence);\n        currentSentence.pop();\n      }\n    }\n  }\n\n  backtrack(0, []);\n  return result;\n}\n\n// Expression Add Operators\nfunction addOperators(num, target) {\n  const result = [];\n\n  function backtrack(index, expression, value, prev) {\n    if (index === num.length) {\n      if (value === target) {\n        result.push(expression);\n      }\n      return;\n    }\n\n    for (let i = index; i < num.length; i++) {\n      const currentStr = num.slice(index, i + 1);\n      const currentNum = parseInt(currentStr);\n\n      // Skip numbers with leading zeros (except single digit)\n      if (currentStr.length > 1 && currentStr[0] === '0') break;\n\n      if (index === 0) {\n        // First number\n        backtrack(i + 1, currentStr, currentNum, currentNum);\n      } else {\n        // Try addition\n        backtrack(\n          i + 1,\n          expression + '+' + currentStr,\n          value + currentNum,\n          currentNum\n        );\n\n        // Try subtraction\n        backtrack(\n          i + 1,\n          expression + '-' + currentStr,\n          value - currentNum,\n          -currentNum\n        );\n\n        // Try multiplication\n        backtrack(\n          i + 1,\n          expression + '*' + currentStr,\n          value - prev + prev * currentNum,\n          prev * currentNum\n        );\n      }\n    }\n  }\n\n  backtrack(0, '', 0, 0);\n  return result;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"2-backtracking-with-state-compression",children:"2. Backtracking with State Compression"}),"\n",(0,r.jsx)(e.p,{children:"Use efficient state representation for complex problems."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function shortestPathVisitingAllNodes(graph) {\n  const n = graph.length;\n  const queue = [];\n  const visited = new Set();\n\n  // Initialize: start from each node\n  for (let i = 0; i < n; i++) {\n    const state = 1 << i; // Visited only node i\n    queue.push([i, state, 0]); // [node, visitedMask, distance]\n    visited.add(`${i},${state}`);\n  }\n\n  const targetMask = (1 << n) - 1; // All nodes visited\n\n  while (queue.length > 0) {\n    const [node, visitedMask, dist] = queue.shift();\n\n    if (visitedMask === targetMask) {\n      return dist;\n    }\n\n    for (let neighbor of graph[node]) {\n      const newMask = visitedMask | (1 << neighbor);\n      const stateKey = `${neighbor},${newMask}`;\n\n      if (!visited.has(stateKey)) {\n        visited.add(stateKey);\n        queue.push([neighbor, newMask, dist + 1]);\n      }\n    }\n  }\n\n  return -1;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"3-iterative-backtracking",children:"3. Iterative Backtracking"}),"\n",(0,r.jsx)(e.p,{children:"Convert recursive solutions to iterative for better space complexity."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function permutationsIterative(nums) {\n  const result = [];\n  const stack = [{ permutation: [], used: new Array(nums.length).fill(false) }];\n\n  while (stack.length > 0) {\n    const { permutation, used } = stack.pop();\n\n    if (permutation.length === nums.length) {\n      result.push([...permutation]);\n      continue;\n    }\n\n    for (let i = 0; i < nums.length; i++) {\n      if (used[i]) continue;\n\n      const newPermutation = [...permutation, nums[i]];\n      const newUsed = [...used];\n      newUsed[i] = true;\n\n      stack.push({ permutation: newPermutation, used: newUsed });\n    }\n  }\n\n  return result;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"4-parallel-backtracking-concepts",children:"4. Parallel Backtracking Concepts"}),"\n",(0,r.jsx)(e.p,{children:"Understanding how backtracking can be parallelized."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function parallelSubsets(nums) {\n  // Conceptual: In practice, use Web Workers or similar\n  const workers = [];\n  const results = [];\n\n  // Divide work among workers based on first choice\n  for (let i = 0; i < nums.length; i++) {\n    workers.push({\n      startsWith: nums[i],\n      remainingNums: nums.slice(i + 1),\n      task: 'generateSubsetsStartingWith',\n    });\n  }\n\n  // Each worker processes subsets starting with specific element\n  function generateSubsetsStartingWith(startElement, remaining) {\n    const localResults = [[]]; // Empty subset\n\n    function backtrack(start, current) {\n      localResults.push([...current]);\n\n      for (let j = start; j < remaining.length; j++) {\n        current.push(remaining[j]);\n        backtrack(j + 1, current);\n        current.pop();\n      }\n    }\n\n    // Generate subsets starting with startElement\n    backtrack(0, [startElement]);\n    return localResults;\n  }\n\n  return results.flat();\n}\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"problem-specific-optimizations",children:"Problem-Specific Optimizations"}),"\n",(0,r.jsx)(e.h3,{id:"1-constraint-specific-pruning",children:"1. Constraint-Specific Pruning"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function combinationSumWithConstraints(candidates, target, maxCount) {\n  candidates.sort();\n  const result = [];\n\n  function backtrack(start, current, sum, count) {\n    if (sum === target && count <= maxCount) {\n      result.push([...current]);\n      return;\n    }\n\n    // Pruning conditions\n    if (sum > target || count > maxCount) return;\n\n    for (let i = start; i < candidates.length; i++) {\n      // Skip if remaining candidates can't reach target\n      if (sum + candidates[i] * (maxCount - count) < target) continue;\n\n      // Skip if single candidate exceeds remaining target\n      if (sum + candidates[i] > target) break;\n\n      current.push(candidates[i]);\n      backtrack(i, current, sum + candidates[i], count + 1);\n      current.pop();\n    }\n  }\n\n  backtrack(0, [], 0, 0);\n  return result;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"2-dynamic-constraint-updates",children:"2. Dynamic Constraint Updates"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function solveConstraintSatisfaction(variables, domains, constraints) {\n  function backtrack(assignment) {\n    if (Object.keys(assignment).length === variables.length) {\n      return assignment; // Solution found\n    }\n\n    const unassigned = variables.filter(v => !(v in assignment));\n    const variable = selectUnassignedVariable(unassigned, assignment);\n\n    for (let value of orderDomainValues(variable, assignment)) {\n      if (isConsistent(variable, value, assignment)) {\n        assignment[variable] = value;\n\n        // Update constraints dynamically\n        const inferences = inferenceStep(variable, value, assignment);\n        if (inferences !== null) {\n          Object.assign(assignment, inferences);\n\n          const result = backtrack(assignment);\n          if (result) return result;\n\n          // Remove inferences on backtrack\n          for (let key of Object.keys(inferences)) {\n            delete assignment[key];\n          }\n        }\n\n        delete assignment[variable];\n      }\n    }\n\n    return null;\n  }\n\n  function selectUnassignedVariable(unassigned, assignment) {\n    // Most constrained variable heuristic\n    return unassigned.reduce((best, variable) => {\n      const currentDomain = getDomainSize(variable, assignment);\n      const bestDomain = getDomainSize(best, assignment);\n      return currentDomain < bestDomain ? variable : best;\n    });\n  }\n\n  function orderDomainValues(variable, assignment) {\n    // Least constraining value heuristic\n    return domains[variable].sort((a, b) => {\n      const aConstraints = countConstraints(variable, a, assignment);\n      const bConstraints = countConstraints(variable, b, assignment);\n      return aConstraints - bConstraints;\n    });\n  }\n\n  return backtrack({});\n}\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"testing--debugging-backtracking",children:"Testing & Debugging Backtracking"}),"\n",(0,r.jsx)(e.h3,{id:"1-debug-visualization",children:"1. Debug Visualization"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function debugBacktrack(nums) {\n  const result = [];\n  let callCount = 0;\n  let maxDepth = 0;\n\n  function backtrack(current, depth = 0) {\n    callCount++;\n    maxDepth = Math.max(maxDepth, depth);\n\n    console.log(\n      `${'  '.repeat(depth)}Depth ${depth}: ${JSON.stringify(current)}`\n    );\n\n    if (current.length === nums.length) {\n      console.log(\n        `${'  '.repeat(depth)}\u2713 Solution found: ${JSON.stringify(current)}`\n      );\n      result.push([...current]);\n      return;\n    }\n\n    for (let num of nums) {\n      if (current.includes(num)) continue;\n\n      console.log(`${'  '.repeat(depth)}\u2192 Trying: ${num}`);\n      current.push(num);\n      backtrack(current, depth + 1);\n      current.pop();\n      console.log(`${'  '.repeat(depth)}\u2190 Backtrack from: ${num}`);\n    }\n  }\n\n  backtrack([]);\n  console.log(`\\nTotal calls: ${callCount}, Max depth: ${maxDepth}`);\n  return result;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"2-performance-monitoring",children:"2. Performance Monitoring"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"class BacktrackProfiler {\n  constructor() {\n    this.stats = {\n      totalCalls: 0,\n      solutionsFound: 0,\n      pruningCount: 0,\n      maxDepth: 0,\n      startTime: null,\n    };\n  }\n\n  start() {\n    this.stats.startTime = Date.now();\n  }\n\n  recordCall(depth) {\n    this.stats.totalCalls++;\n    this.stats.maxDepth = Math.max(this.stats.maxDepth, depth);\n  }\n\n  recordSolution() {\n    this.stats.solutionsFound++;\n  }\n\n  recordPruning() {\n    this.stats.pruningCount++;\n  }\n\n  getReport() {\n    const duration = Date.now() - this.stats.startTime;\n    return {\n      ...this.stats,\n      duration: `${duration}ms`,\n      callsPerMs: (this.stats.totalCalls / duration).toFixed(2),\n      pruningEfficiency:\n        ((this.stats.pruningCount / this.stats.totalCalls) * 100).toFixed(1) +\n        '%',\n    };\n  }\n}\n\n// Usage example\nfunction profiledBacktrack(nums) {\n  const profiler = new BacktrackProfiler();\n  const result = [];\n\n  profiler.start();\n\n  function backtrack(current, depth = 0) {\n    profiler.recordCall(depth);\n\n    if (current.length === nums.length) {\n      profiler.recordSolution();\n      result.push([...current]);\n      return;\n    }\n\n    for (let num of nums) {\n      if (current.includes(num)) {\n        profiler.recordPruning();\n        continue;\n      }\n\n      current.push(num);\n      backtrack(current, depth + 1);\n      current.pop();\n    }\n  }\n\n  backtrack([]);\n\n  console.log('Performance Report:', profiler.getReport());\n  return result;\n}\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"real-world-applications",children:"Real-World Applications"}),"\n",(0,r.jsx)(e.h3,{id:"1-schedule-optimization",children:"1. Schedule Optimization"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function scheduleOptimization(tasks, resources, constraints) {\n  const schedule = new Map();\n\n  function backtrack(taskIndex) {\n    if (taskIndex === tasks.length) {\n      return validateSchedule(schedule);\n    }\n\n    const task = tasks[taskIndex];\n\n    for (let resource of resources) {\n      for (let timeSlot of getAvailableSlots(resource, task.duration)) {\n        if (satisfiesConstraints(task, resource, timeSlot, constraints)) {\n          schedule.set(task.id, { resource, timeSlot });\n\n          if (backtrack(taskIndex + 1)) {\n            return true;\n          }\n\n          schedule.delete(task.id);\n        }\n      }\n    }\n\n    return false;\n  }\n\n  return backtrack(0) ? schedule : null;\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"2-configuration-management",children:"2. Configuration Management"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function generateConfigurations(components, dependencies, requirements) {\n  const validConfigs = [];\n\n  function backtrack(configIndex, currentConfig) {\n    if (configIndex === components.length) {\n      if (meetsAllRequirements(currentConfig, requirements)) {\n        validConfigs.push({ ...currentConfig });\n      }\n      return;\n    }\n\n    const component = components[configIndex];\n\n    for (let option of component.options) {\n      if (isCompatible(option, currentConfig, dependencies)) {\n        currentConfig[component.name] = option;\n        backtrack(configIndex + 1, currentConfig);\n        delete currentConfig[component.name];\n      }\n    }\n  }\n\n  backtrack(0, {});\n  return validConfigs;\n}\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"quick-reference",children:"Quick Reference"}),"\n",(0,r.jsx)(e.h3,{id:"common-backtracking-patterns",children:"Common Backtracking Patterns"}),"\n",(0,r.jsxs)(e.table,{children:[(0,r.jsx)(e.thead,{children:(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.th,{children:"Pattern"}),(0,r.jsx)(e.th,{children:"Template"}),(0,r.jsx)(e.th,{children:"Use Case"})]})}),(0,r.jsxs)(e.tbody,{children:[(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Subsets"})}),(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"for i in start..n"})}),(0,r.jsx)(e.td,{children:"Generate all subsets"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Permutations"})}),(0,r.jsxs)(e.td,{children:[(0,r.jsx)(e.code,{children:"for i in 0..n"})," with ",(0,r.jsx)(e.code,{children:"used[]"})]}),(0,r.jsx)(e.td,{children:"All arrangements"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Combinations"})}),(0,r.jsxs)(e.td,{children:[(0,r.jsx)(e.code,{children:"for i in start..n"})," with size limit"]}),(0,r.jsx)(e.td,{children:"Fixed-size selections"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Constraints"})}),(0,r.jsx)(e.td,{children:"Early termination on invalid"}),(0,r.jsx)(e.td,{children:"Sudoku, N-Queens"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Paths"})}),(0,r.jsx)(e.td,{children:"DFS with visited tracking"}),(0,r.jsx)(e.td,{children:"Tree/Graph paths"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Partitioning"})}),(0,r.jsx)(e.td,{children:"Try all valid cuts"}),(0,r.jsx)(e.td,{children:"String partitioning"})]})]})]}),"\n",(0,r.jsx)(e.h3,{id:"optimization-checklist",children:"Optimization Checklist"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\u2705 ",(0,r.jsx)(e.strong,{children:"Sort input"})," when dealing with duplicates"]}),"\n",(0,r.jsxs)(e.li,{children:["\u2705 ",(0,r.jsx)(e.strong,{children:"Early pruning"})," on constraint violations"]}),"\n",(0,r.jsxs)(e.li,{children:["\u2705 ",(0,r.jsx)(e.strong,{children:"Memoization"})," for overlapping subproblems"]}),"\n",(0,r.jsxs)(e.li,{children:["\u2705 ",(0,r.jsx)(e.strong,{children:"Bit manipulation"})," for state compression"]}),"\n",(0,r.jsxs)(e.li,{children:["\u2705 ",(0,r.jsx)(e.strong,{children:"In-place modifications"})," to save space"]}),"\n",(0,r.jsxs)(e.li,{children:["\u2705 ",(0,r.jsx)(e.strong,{children:"Iterative conversion"})," for deep recursion"]}),"\n",(0,r.jsxs)(e.li,{children:["\u2705 ",(0,r.jsx)(e.strong,{children:"Profile and measure"})," performance bottlenecks"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"time-complexity-quick-reference",children:"Time Complexity Quick Reference"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"Subsets:       O(2^n)        - Each element: include or exclude\nPermutations:  O(n!)         - n choices for first, (n-1) for second, etc.\nCombinations:  O(C(n,k))     - n choose k combinations\nN-Queens:      O(N!)         - Exponential with heavy pruning\nSudoku:        O(9^(empty))  - 9 choices per empty cell\n"})})]})}function d(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(u,{...n})}):u(n)}}}]);