"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[5913],{2122:(n,o,t)=>{t.r(o),t.d(o,{assets:()=>c,contentTitle:()=>s,default:()=>p,frontMatter:()=>r,metadata:()=>a,toc:()=>d});var e=t(74848),i=t(28453);const r={title:"Union-Find (Disjoint Set Union) Tutorial",description:"A comprehensive guide to Union-Find data structure with code examples in JavaScript."},s="Union-Find (Disjoint Set Union) Tutorial",a={id:"DSA/DSA with JavaScript/UnionFind",title:"Union-Find (Disjoint Set Union) Tutorial",description:"A comprehensive guide to Union-Find data structure with code examples in JavaScript.",source:"@site/docs/DSA/DSA with JavaScript/UnionFind.mdx",sourceDirName:"DSA/DSA with JavaScript",slug:"/DSA/DSA with JavaScript/UnionFind",permalink:"/dev.enigma/docs/DSA/DSA with JavaScript/UnionFind",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with JavaScript/UnionFind.mdx",tags:[],version:"current",frontMatter:{title:"Union-Find (Disjoint Set Union) Tutorial",description:"A comprehensive guide to Union-Find data structure with code examples in JavaScript."},sidebar:"tutorialSidebar",previous:{title:"Two Pointers Technique",permalink:"/dev.enigma/docs/DSA/DSA with JavaScript/TwoPointers"},next:{title:"Unix File System",permalink:"/dev.enigma/docs/DSA/DSA with JavaScript/UnixFileSystem"}},c={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Key Operations",id:"key-operations",level:2},{value:"Implementation",id:"implementation",level:2},{value:"Union Find on 2d Grid",id:"union-find-on-2d-grid",level:2},{value:"Find all Connected Components in a Graph",id:"find-all-connected-components-in-a-graph",level:2},{value:"Find all Connected Components in a Graph: Using Union-Find",id:"find-all-connected-components-in-a-graph-using-union-find",level:2},{value:"Compute the size of Each Connected Component",id:"compute-the-size-of-each-connected-component",level:2},{value:"Find Maximum in Each Component",id:"find-maximum-in-each-component",level:2}];function h(n){const o={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...n.components};return(0,e.jsxs)(e.Fragment,{children:[(0,e.jsx)(o.header,{children:(0,e.jsx)(o.h1,{id:"union-find-disjoint-set-union-tutorial",children:"Union-Find (Disjoint Set Union) Tutorial"})}),"\n",(0,e.jsx)(o.h2,{id:"introduction",children:"Introduction"}),"\n",(0,e.jsx)(o.p,{children:"The Union-Find data structure, also known as Disjoint Set Union (DSU), is a data structure that keeps track of a partition of a set into disjoint (non-overlapping) subsets. It supports two primary operations:"}),"\n",(0,e.jsxs)(o.ol,{children:["\n",(0,e.jsxs)(o.li,{children:[(0,e.jsx)(o.strong,{children:"Union"}),": Merge two subsets into a single subset."]}),"\n",(0,e.jsxs)(o.li,{children:[(0,e.jsx)(o.strong,{children:"Find"}),": Determine which subset a particular element is in."]}),"\n"]}),"\n",(0,e.jsx)(o.p,{children:"Union-Find is particularly useful in scenarios involving network connectivity, Kruskal's algorithm for finding the Minimum Spanning Tree, and various other graph-related problems."}),"\n",(0,e.jsx)(o.h2,{id:"key-operations",children:"Key Operations"}),"\n",(0,e.jsxs)(o.ol,{children:["\n",(0,e.jsxs)(o.li,{children:["\n",(0,e.jsxs)(o.p,{children:[(0,e.jsx)(o.strong,{children:"Find"}),": This operation determines the representative or root of the set that contains the given element. Path compression is often used to speed up future queries."]}),"\n"]}),"\n",(0,e.jsxs)(o.li,{children:["\n",(0,e.jsxs)(o.p,{children:[(0,e.jsx)(o.strong,{children:"Union"}),": This operation merges two subsets into a single subset. Union by rank (or size) is commonly used to keep the tree flat and efficient."]}),"\n"]}),"\n"]}),"\n",(0,e.jsx)(o.h2,{id:"implementation",children:"Implementation"}),"\n",(0,e.jsxs)(o.ol,{children:["\n",(0,e.jsxs)(o.li,{children:[(0,e.jsx)(o.strong,{children:"Array"}),": Use when indices are small, dense, and within a fixed range."]}),"\n",(0,e.jsxs)(o.li,{children:[(0,e.jsx)(o.strong,{children:"Map"}),": Use when indices are large, sparse, dynamic, non-numeric, or complex."]}),"\n"]}),"\n",(0,e.jsx)(o.p,{children:"Here\u2019s a basic implementation of the Union-Find data structure in JavaScript:"}),"\n",(0,e.jsx)(o.pre,{children:(0,e.jsx)(o.code,{className:"language-javascript",children:"class UnionFind {\n  constructor(size) {\n    this.parent = Array.from({ length: size }, (_, i) => i);\n    this.rank = Array(size).fill(0);\n  }\n\n  // Find the root of the set containing element x with path compression\n  find(x) {\n    if (this.parent[x] !== x) {\n      this.parent[x] = this.find(this.parent[x]); // Path compression\n    }\n    return this.parent[x];\n  }\n\n  // Union the sets containing elements x and y with union by rank\n  union(x, y) {\n    const rootX = this.find(x);\n    const rootY = this.find(y);\n\n    if (rootX !== rootY) {\n      // Union by rank\n      if (this.rank[rootX] > this.rank[rootY]) {\n        this.parent[rootY] = rootX;\n      } else if (this.rank[rootX] < this.rank[rootY]) {\n        this.parent[rootX] = rootY;\n      } else {\n        this.parent[rootY] = rootX;\n        this.rank[rootX] += 1;\n      }\n    }\n  }\n}\n\n// Example Usage\nconst uf = new UnionFind(10);\n\n// Union operations\nuf.union(1, 2);\nuf.union(2, 3);\nuf.union(4, 5);\n\n// Find operations\nconsole.log(uf.find(1)); // Output: 1 (root of the set containing 1)\nconsole.log(uf.find(3)); // Output: 1 (root of the set containing 3)\nconsole.log(uf.find(5)); // Output: 5 (root of the set containing 5)\n"})}),"\n",(0,e.jsx)(o.h1,{id:"using-map",children:"Using Map"}),"\n",(0,e.jsx)(o.pre,{children:(0,e.jsx)(o.code,{className:"language-JavaScript",children:"class DSU {\n  constructor() {\n    this.parent = new Map();\n    this.rank = new Map();\n  }\n\n  find(x) {\n    if (!this.parent.has(x)) {\n      this.parent.set(x, x); // Initialize parent to itself if not present\n    }\n    if (x !== this.parent.get(x)) {\n      this.parent.set(x, this.find(this.parent.get(x))); // Path compression\n    }\n    return this.parent.get(x); // Return the root parent\n  }\n\n  union(x, y) {\n    let rootX = this.find(x);\n    let rootY = this.find(y);\n\n    if (rootX !== rootY) {\n      let rankX = this.rank.get(rootX);\n      let rankY = this.rank.get(rootY);\n\n      if (rankX > rankY) {\n        this.parent.set(rootY, rootX);\n      } else if (rankX < rankY) {\n        this.parent.set(rootX, rootY);\n      } else {\n        this.parent.set(rootY, rootX);\n        this.rank.set(rootX, rankX + 1);\n      }\n    }\n  }\n}\n"})}),"\n",(0,e.jsx)(o.h2,{id:"union-find-on-2d-grid",children:"Union Find on 2d Grid"}),"\n",(0,e.jsx)(o.pre,{children:(0,e.jsx)(o.code,{className:"language-JavaScript",children:"class UnionFind {\n    constructor(rows, cols) {\n        this.rows = rows;\n        this.cols = cols;\n        this.parent = new Array(rows * cols).fill(0)\n            .map((_, i) => i);\n        this.rank = new Array(rows * cols).fill(0);\n        this.count = rows * cols;\n    }\n\n    // Convert 2D position to 1D index\n    index(row, col) {\n        return row * this.cols + col;\n    }\n\n    find(x) {\n        if (this.parent[x] !== x) {\n            this.parent[x] = this.find(this.parent[x]); // Path compression\n        }\n        return this.parent[x];\n    }\n\n    union(x, y) {\n        let rootX = this.find(x);\n        let rootY = this.find(y);\n\n        if (rootX !== rootY) {\n            if (this.rank[rootX] < this.rank[rootY]) {\n                [rootX, rootY] = [rootY, rootX];\n            }\n            this.parent[rootY] = rootX;\n            if (this.rank[rootX] === this.rank[rootY]) {\n                this.rank[rootX]++;\n            }\n            this.count--;\n            return true;\n        }\n        return false;\n    }\n\n    connected(x, y) {\n        return this.find(x) === this.find(y);\n    }\n\n    // Union by 2D coordinates\n    unionByPosition(r1, c1, r2, c2) {\n        return this.union(this.index(r1, c1), this.index(r2, c2));\n    }\n\n    // Check if two positions are connected\n    connectedByPosition(r1, c1, r2, c2) {\n        return this.connected(this.index(r1, c1), this.index(r2, c2));\n    }\n}\n"})}),"\n",(0,e.jsx)(o.h2,{id:"find-all-connected-components-in-a-graph",children:"Find all Connected Components in a Graph"}),"\n",(0,e.jsx)(o.pre,{children:(0,e.jsx)(o.code,{className:"language-JavaScript",children:"/**\n * Finds all connected components in a graph using DFS.\n * @param {number} n - Number of nodes (0 to n-1).\n * @param {number[][]} edges - Edges of the graph [u, v].\n * @return {number[][]} - Array of connected components.\n */\nfunction findConnectedComponents(n, edges) {\n  // Build adjacency list\n  const graph = Array.from({ length: n }, () => []);\n  for (const [u, v] of edges) {\n    graph[u].push(v);\n    graph[v].push(u);\n  }\n\n  const visited = Array(n).fill(false); // Track visited nodes\n  const components = []; // List of connected components\n\n  // DFS function to collect nodes in a component\n  function dfs(node, component) {\n    visited[node] = true;\n    component.push(node);\n    for (const neighbor of graph[node]) {\n      if (!visited[neighbor]) {\n        dfs(neighbor, component);\n      }\n    }\n  }\n\n  // Traverse all nodes\n  for (let i = 0; i < n; i++) {\n    if (!visited[i]) {\n      const component = [];\n      dfs(i, component); // Find all nodes in the current component\n      components.push(component); // Save the component\n    }\n  }\n\n  return components;\n}\n\n// Example usage\nconst n = 6;\nconst edges = [\n  [0, 1],\n  [1, 2],\n  [3, 4],\n];\nconst result = findConnectedComponents(n, edges);\nconsole.log(result); // Example output: [[0, 1, 2], [3, 4], [5]]\n"})}),"\n",(0,e.jsx)(o.h2,{id:"find-all-connected-components-in-a-graph-using-union-find",children:"Find all Connected Components in a Graph: Using Union-Find"}),"\n",(0,e.jsx)(o.pre,{children:(0,e.jsx)(o.code,{className:"language-JavaScript",children:"/**\n * Finds all connected components in a graph using Union-Find.\n * @param {number} n - Number of nodes (0 to n-1).\n * @param {number[][]} edges - Edges of the graph [u, v].\n * @return {number[][]} - Array of connected components.\n */\nfunction findConnectedComponents(n, edges) {\n  const parent = Array.from({ length: n }, (_, i) => i); // Parent array\n  const rank = Array(n).fill(0); // Rank array for optimization\n\n  // Find operation with path compression\n  function find(x) {\n    if (parent[x] !== x) {\n      parent[x] = find(parent[x]); // Path compression\n    }\n    return parent[x];\n  }\n\n  // Union operation with rank optimization\n  function union(x, y) {\n    const rootX = find(x);\n    const rootY = find(y);\n    if (rootX !== rootY) {\n      if (rank[rootX] > rank[rootY]) {\n        parent[rootY] = rootX;\n      } else if (rank[rootX] < rank[rootY]) {\n        parent[rootX] = rootY;\n      } else {\n        parent[rootY] = rootX;\n        rank[rootX]++;\n      }\n    }\n  }\n\n  // Process all edges\n  for (const [u, v] of edges) {\n    union(u, v);\n  }\n\n  // Group nodes by their root\n  const componentsMap = new Map();\n  for (let i = 0; i < n; i++) {\n    const root = find(i);\n    if (!componentsMap.has(root)) {\n      componentsMap.set(root, []);\n    }\n    componentsMap.get(root).push(i);\n  }\n\n  // Convert map to an array of components\n  return Array.from(componentsMap.values());\n}\n\n// Example usage\nconst n = 6;\nconst edges = [\n  [0, 1],\n  [1, 2],\n  [3, 4],\n];\nconst result = findConnectedComponents(n, edges);\nconsole.log(result); // Example output: [[0, 1, 2], [3, 4], [5]]\n\n/*\nThis means:\n\nNodes [0, 1, 2] are connected.\nNodes [3, 4] are connected.\nNode [5] is isolated.\n */\n"})}),"\n",(0,e.jsx)(o.h2,{id:"compute-the-size-of-each-connected-component",children:"Compute the size of Each Connected Component"}),"\n",(0,e.jsx)(o.pre,{children:(0,e.jsx)(o.code,{className:"language-JavaScript",children:"class UnionFind {\n  constructor(n) {\n    this.parent = Array.from({ length: n }, (_, i) => i); // Each node is its own parent initially\n    this.size = Array(n).fill(1); // Each component initially has size 1\n  }\n\n  // Find operation with path compression\n  find(x) {\n    if (this.parent[x] !== x) {\n      this.parent[x] = this.find(this.parent[x]); // Path compression\n    }\n    return this.parent[x];\n  }\n\n  // Union operation with size tracking\n  union(x, y) {\n    const rootX = this.find(x);\n    const rootY = this.find(y);\n\n    if (rootX !== rootY) {\n      // Merge smaller tree into larger tree\n      if (this.size[rootX] > this.size[rootY]) {\n        this.parent[rootY] = rootX;\n        this.size[rootX] += this.size[rootY];\n      } else {\n        this.parent[rootX] = rootY;\n        this.size[rootY] += this.size[rootX];\n      }\n    }\n  }\n\n  // Get sizes of all components\n  getComponentSizes() {\n    const componentSizes = new Map();\n    for (let i = 0; i < this.parent.length; i++) {\n      const root = this.find(i);\n      if (!componentSizes.has(root)) {\n        componentSizes.set(root, this.size[root]);\n      }\n    }\n    return Array.from(componentSizes.values());\n  }\n}\n\n// Function to find the sizes of all connected components\nfunction connectedComponentSizes(n, edges) {\n  const uf = new UnionFind(n);\n\n  // Process all edges\n  for (const [u, v] of edges) {\n    uf.union(u, v);\n  }\n\n  // Get sizes of connected components\n  return uf.getComponentSizes();\n}\n\n// Example usage\nconst n = 6;\nconst edges = [\n  [0, 1],\n  [1, 2],\n  [3, 4],\n];\nconst result = connectedComponentSizes(n, edges);\nconsole.log(result); // Example output: [3, 2, 1]\n\n/*\nThis indicates:\n\nA component of size 3 (nodes [0, 1, 2]).\nA component of size 2 (nodes [3, 4]).\nA component of size 1 (node [5], isolated).\n*/\n"})}),"\n",(0,e.jsx)(o.h2,{id:"find-maximum-in-each-component",children:"Find Maximum in Each Component"}),"\n",(0,e.jsx)(o.pre,{children:(0,e.jsx)(o.code,{className:"language-JavaScript",children:"class UnionFind {\n  constructor(n) {\n    this.parent = Array.from({ length: n }, (_, i) => i); // Each node is its own parent initially\n    this.size = Array(n).fill(1); // Each component initially has size 1\n    this.max = Array.from({ length: n }, (_, i) => i); // Maximum value in each component\n  }\n\n  // Find operation with path compression\n  find(x) {\n    if (this.parent[x] !== x) {\n      this.parent[x] = this.find(this.parent[x]); // Path compression\n    }\n    return this.parent[x];\n  }\n\n  // Union operation with size and max tracking\n  union(x, y) {\n    const rootX = this.find(x);\n    const rootY = this.find(y);\n\n    if (rootX !== rootY) {\n      // Merge smaller tree into larger tree\n      if (this.size[rootX] > this.size[rootY]) {\n        this.parent[rootY] = rootX;\n        this.size[rootX] += this.size[rootY];\n        this.max[rootX] = Math.max(this.max[rootX], this.max[rootY]);\n      } else {\n        this.parent[rootX] = rootY;\n        this.size[rootY] += this.size[rootX];\n        this.max[rootY] = Math.max(this.max[rootX], this.max[rootY]);\n      }\n    }\n  }\n\n  // Get maximum in each component\n  getComponentMax() {\n    const componentMax = new Map();\n    for (let i = 0; i < this.parent.length; i++) {\n      const root = this.find(i);\n      if (!componentMax.has(root)) {\n        componentMax.set(root, this.max[root]);\n      }\n    }\n    return Array.from(componentMax.values());\n  }\n}\n\n// Function to find the maximum in each connected component\nfunction maxInEachComponent(n, edges) {\n  const uf = new UnionFind(n);\n\n  // Process all edges\n  for (const [u, v] of edges) {\n    uf.union(u, v);\n  }\n\n  // Get maximum in each connected component\n  return uf.getComponentMax();\n}\n\n// Example usage\nconst n = 6;\nconst edges = [\n  [0, 1],\n  [1, 2],\n  [3, 4],\n];\nconst result = maxInEachComponent(n, edges);\nconsole.log(result); // Example output: [2, 4, 5]\n\n/*\nComponent {0, 1, 2}: Maximum is 2.\nComponent {3, 4}: Maximum is 4.\nComponent {5}: Maximum is 5.\n*/\n"})})]})}function p(n={}){const{wrapper:o}={...(0,i.R)(),...n.components};return o?(0,e.jsx)(o,{...n,children:(0,e.jsx)(h,{...n})}):h(n)}},28453:(n,o,t)=>{t.d(o,{R:()=>s,x:()=>a});var e=t(96540);const i={},r=e.createContext(i);function s(n){const o=e.useContext(r);return e.useMemo(function(){return"function"==typeof n?n(o):{...o,...n}},[o,n])}function a(n){let o;return o=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:s(n.components),e.createElement(r.Provider,{value:o},n.children)}}}]);