"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[97576],{28453:(n,e,t)=>{t.d(e,{R:()=>a,x:()=>c});var s=t(96540);const i={},r=s.createContext(i);function a(n){const e=s.useContext(r);return s.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function c(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:a(n.components),s.createElement(r.Provider,{value:e},n.children)}},99433:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>r,metadata:()=>c,toc:()=>o});var s=t(74848),i=t(28453);const r={},a="Stack",c={id:"DSA/DSA/DSA with JavaScript/DSA Cheatsheets/Stack",title:"Stack",description:"A comprehensive guide to stack algorithms and techniques for Data Structures and Algorithms.",source:"@site/docs/05-DSA/DSA/DSA with JavaScript/DSA Cheatsheets/Stack.mdx",sourceDirName:"05-DSA/DSA/DSA with JavaScript/DSA Cheatsheets",slug:"/DSA/DSA/DSA with JavaScript/DSA Cheatsheets/Stack",permalink:"/docs/DSA/DSA/DSA with JavaScript/DSA Cheatsheets/Stack",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/05-DSA/DSA/DSA with JavaScript/DSA Cheatsheets/Stack.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Sorting Algorithms",permalink:"/docs/DSA/DSA/DSA with JavaScript/DSA Cheatsheets/Sorting Algorithms"},next:{title:"Strings",permalink:"/docs/DSA/DSA/DSA with JavaScript/DSA Cheatsheets/Strings"}},l={},o=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Introduction to Stacks",id:"introduction-to-stacks",level:2},{value:"Core Concepts",id:"core-concepts",level:3},{value:"Basic Template",id:"basic-template",level:3},{value:"Basic Stack Operations",id:"basic-stack-operations",level:2},{value:"1. Stack Using Array",id:"1-stack-using-array",level:3},{value:"2. Stack Using Linked List",id:"2-stack-using-linked-list",level:3},{value:"Basic Stack Problems",id:"basic-stack-problems",level:2},{value:"1. Reverse a String",id:"1-reverse-a-string",level:3},{value:"2. Check Palindrome",id:"2-check-palindrome",level:3},{value:"3. Next Greater Element",id:"3-next-greater-element",level:3},{value:"Expression Evaluation",id:"expression-evaluation",level:2},{value:"1. Infix to Postfix Conversion",id:"1-infix-to-postfix-conversion",level:3},{value:"2. Postfix Evaluation",id:"2-postfix-evaluation",level:3},{value:"3. Basic Calculator",id:"3-basic-calculator",level:3},{value:"Parentheses Problems",id:"parentheses-problems",level:2},{value:"1. Valid Parentheses",id:"1-valid-parentheses",level:3},{value:"2. Generate Parentheses",id:"2-generate-parentheses",level:3},{value:"3. Longest Valid Parentheses",id:"3-longest-valid-parentheses",level:3},{value:"4. Remove Invalid Parentheses",id:"4-remove-invalid-parentheses",level:3},{value:"Monotonic Stack",id:"monotonic-stack",level:2},{value:"1. Next Greater Element Pattern",id:"1-next-greater-element-pattern",level:3},{value:"2. Next Greater Element II (Circular Array)",id:"2-next-greater-element-ii-circular-array",level:3},{value:"3. Daily Temperatures",id:"3-daily-temperatures",level:3},{value:"4. Largest Rectangle in Histogram",id:"4-largest-rectangle-in-histogram",level:3},{value:"5. Maximal Rectangle",id:"5-maximal-rectangle",level:3},{value:"6. Trapping Rain Water",id:"6-trapping-rain-water",level:3},{value:"7. Sum of Subarray Minimums",id:"7-sum-of-subarray-minimums",level:3},{value:"Stack in Recursion",id:"stack-in-recursion",level:2},{value:"1. Binary Tree Traversal (Iterative)",id:"1-binary-tree-traversal-iterative",level:3},{value:"2. Flatten Binary Tree to Linked List",id:"2-flatten-binary-tree-to-linked-list",level:3},{value:"3. Path Sum II",id:"3-path-sum-ii",level:3},{value:"Two Stacks Problems",id:"two-stacks-problems",level:2},{value:"1. Implement Queue using Stacks",id:"1-implement-queue-using-stacks",level:3},{value:"2. Sort Stack",id:"2-sort-stack",level:3},{value:"Stack with Additional Operations",id:"stack-with-additional-operations",level:2},{value:"1. Min Stack",id:"1-min-stack",level:3},{value:"2. Max Stack",id:"2-max-stack",level:3},{value:"Advanced Stack Patterns",id:"advanced-stack-patterns",level:2},{value:"1. Asteroid Collision",id:"1-asteroid-collision",level:3},{value:"2. Decode String",id:"2-decode-string",level:3},{value:"3. Remove K Digits",id:"3-remove-k-digits",level:3},{value:"4. Valid Stack Sequences",id:"4-valid-stack-sequences",level:3},{value:"Stack in Graph Algorithms",id:"stack-in-graph-algorithms",level:2},{value:"1. Depth-First Search (DFS)",id:"1-depth-first-search-dfs",level:3},{value:"2. Topological Sort",id:"2-topological-sort",level:3},{value:"3. Find Strongly Connected Components",id:"3-find-strongly-connected-components",level:3},{value:"4. Detect Cycle in Directed Graph",id:"4-detect-cycle-in-directed-graph",level:3},{value:"Memory Management",id:"memory-management",level:2},{value:"1. Stack Overflow Prevention",id:"1-stack-overflow-prevention",level:3},{value:"2. Memory-Efficient Stack",id:"2-memory-efficient-stack",level:3},{value:"Common Optimization Tricks",id:"common-optimization-tricks",level:2},{value:"1. Stack with O(1) Min/Max Operations",id:"1-stack-with-o1-minmax-operations",level:3},{value:"2. Multiple Stacks in Single Array",id:"2-multiple-stacks-in-single-array",level:3},{value:"3. Stack with Increment Operation",id:"3-stack-with-increment-operation",level:3},{value:"4. Stack with getMiddle Operation",id:"4-stack-with-getmiddle-operation",level:3},{value:"Problem-Solving Patterns",id:"problem-solving-patterns",level:2},{value:"1. When to Use Stack",id:"1-when-to-use-stack",level:3},{value:"2. Stack Problem Templates",id:"2-stack-problem-templates",level:3},{value:"Template 1: Basic Stack Operations",id:"template-1-basic-stack-operations",level:4},{value:"Template 2: Monotonic Stack",id:"template-2-monotonic-stack",level:4},{value:"Template 3: Expression Parsing",id:"template-3-expression-parsing",level:4},{value:"Testing and Debugging",id:"testing-and-debugging",level:2},{value:"1. Stack Testing Framework",id:"1-stack-testing-framework",level:3},{value:"2. Stack Visualization",id:"2-stack-visualization",level:3},{value:"Performance Analysis",id:"performance-analysis",level:2},{value:"Time Complexity Summary",id:"time-complexity-summary",level:3},{value:"Space Complexity Considerations",id:"space-complexity-considerations",level:3},{value:"Real-World Applications",id:"real-world-applications",level:2},{value:"1. Browser History",id:"1-browser-history",level:3},{value:"2. Undo/Redo System",id:"2-undoredo-system",level:3},{value:"3. Function Call Stack Simulator",id:"3-function-call-stack-simulator",level:3},{value:"Conclusion",id:"conclusion",level:2},{value:"<strong>Essential Patterns:</strong>",id:"essential-patterns",level:3},{value:"<strong>When to Use Stacks:</strong>",id:"when-to-use-stacks",level:3},{value:"<strong>Optimization Techniques:</strong>",id:"optimization-techniques",level:3},{value:"<strong>Best Practices:</strong>",id:"best-practices",level:3}];function h(n){const e={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"stack",children:"Stack"})}),"\n",(0,s.jsx)(e.p,{children:"A comprehensive guide to stack algorithms and techniques for Data Structures and Algorithms."}),"\n",(0,s.jsx)(e.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#introduction-to-stacks",children:"Introduction to Stacks"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#basic-stack-operations",children:"Basic Stack Operations"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#stack-implementation",children:"Stack Implementation"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#basic-stack-problems",children:"Basic Stack Problems"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#expression-evaluation",children:"Expression Evaluation"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#parentheses-problems",children:"Parentheses Problems"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#monotonic-stack",children:"Monotonic Stack"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#stack-in-recursion",children:"Stack in Recursion"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#two-stacks-problems",children:"Two Stacks Problems"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#stack-with-additional-operations",children:"Stack with Additional Operations"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#advanced-stack-patterns",children:"Advanced Stack Patterns"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#stack-in-graph-algorithms",children:"Stack in Graph Algorithms"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#memory-management",children:"Memory Management"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#common-optimization-tricks",children:"Common Optimization Tricks"})}),"\n"]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"introduction-to-stacks",children:"Introduction to Stacks"}),"\n",(0,s.jsxs)(e.p,{children:["A ",(0,s.jsx)(e.strong,{children:"Stack"})," is a linear data structure that follows the ",(0,s.jsx)(e.strong,{children:"Last In First Out (LIFO)"}),' principle. Elements are added and removed from the same end, called the "top" of the stack.']}),"\n",(0,s.jsx)(e.h3,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"LIFO Principle:"})," The last element pushed onto the stack is the first one to be popped off."]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Main Operations:"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Push:"})," Add an element to the top"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Pop:"})," Remove the top element"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Peek/Top:"})," View the top element without removing it"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"isEmpty:"})," Check if stack is empty"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"basic-template",children:"Basic Template"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"class Stack {\n  constructor() {\n    this.items = [];\n  }\n\n  push(element) {\n    this.items.push(element);\n  }\n\n  pop() {\n    if (this.isEmpty()) return null;\n    return this.items.pop();\n  }\n\n  peek() {\n    if (this.isEmpty()) return null;\n    return this.items[this.items.length - 1];\n  }\n\n  isEmpty() {\n    return this.items.length === 0;\n  }\n\n  size() {\n    return this.items.length;\n  }\n}\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"basic-stack-operations",children:"Basic Stack Operations"}),"\n",(0,s.jsx)(e.h3,{id:"1-stack-using-array",children:"1. Stack Using Array"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"class ArrayStack {\n  constructor(maxSize = 1000) {\n    this.items = new Array(maxSize);\n    this.top = -1;\n    this.maxSize = maxSize;\n  }\n\n  push(element) {\n    if (this.isFull()) {\n      throw new Error('Stack Overflow');\n    }\n    this.items[++this.top] = element;\n  }\n\n  pop() {\n    if (this.isEmpty()) {\n      throw new Error('Stack Underflow');\n    }\n    return this.items[this.top--];\n  }\n\n  peek() {\n    if (this.isEmpty()) return null;\n    return this.items[this.top];\n  }\n\n  isEmpty() {\n    return this.top === -1;\n  }\n\n  isFull() {\n    return this.top === this.maxSize - 1;\n  }\n\n  size() {\n    return this.top + 1;\n  }\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"2-stack-using-linked-list",children:"2. Stack Using Linked List"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"class Node {\n  constructor(data) {\n    this.data = data;\n    this.next = null;\n  }\n}\n\nclass LinkedListStack {\n  constructor() {\n    this.head = null;\n    this.stackSize = 0;\n  }\n\n  push(element) {\n    const newNode = new Node(element);\n    newNode.next = this.head;\n    this.head = newNode;\n    this.stackSize++;\n  }\n\n  pop() {\n    if (this.isEmpty()) return null;\n\n    const poppedData = this.head.data;\n    this.head = this.head.next;\n    this.stackSize--;\n    return poppedData;\n  }\n\n  peek() {\n    return this.isEmpty() ? null : this.head.data;\n  }\n\n  isEmpty() {\n    return this.head === null;\n  }\n\n  size() {\n    return this.stackSize;\n  }\n}\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"basic-stack-problems",children:"Basic Stack Problems"}),"\n",(0,s.jsx)(e.h3,{id:"1-reverse-a-string",children:"1. Reverse a String"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function reverseString(str) {\n  const stack = new Stack();\n\n  // Push all characters\n  for (const char of str) {\n    stack.push(char);\n  }\n\n  // Pop all characters\n  let reversed = '';\n  while (!stack.isEmpty()) {\n    reversed += stack.pop();\n  }\n\n  return reversed;\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"2-check-palindrome",children:"2. Check Palindrome"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function isPalindrome(str) {\n  const stack = new Stack();\n  const n = str.length;\n\n  // Push first half\n  for (let i = 0; i < Math.floor(n / 2); i++) {\n    stack.push(str[i]);\n  }\n\n  // Compare second half with stack\n  let start = n % 2 === 0 ? Math.floor(n / 2) : Math.floor(n / 2) + 1;\n\n  for (let i = start; i < n; i++) {\n    if (stack.pop() !== str[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"3-next-greater-element",children:"3. Next Greater Element"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function nextGreaterElement(arr) {\n  const result = new Array(arr.length).fill(-1);\n  const stack = new Stack();\n\n  for (let i = 0; i < arr.length; i++) {\n    while (!stack.isEmpty() && arr[stack.peek()] < arr[i]) {\n      const index = stack.pop();\n      result[index] = arr[i];\n    }\n    stack.push(i);\n  }\n\n  return result;\n}\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"expression-evaluation",children:"Expression Evaluation"}),"\n",(0,s.jsx)(e.h3,{id:"1-infix-to-postfix-conversion",children:"1. Infix to Postfix Conversion"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function infixToPostfix(infix) {\n  const stack = new Stack();\n  let postfix = '';\n\n  const precedence = {\n    '+': 1,\n    '-': 1,\n    '*': 2,\n    '/': 2,\n    '^': 3,\n  };\n\n  const isOperator = char => precedence.hasOwnProperty(char);\n  const isOperand = char => /[a-zA-Z0-9]/.test(char);\n\n  for (const char of infix) {\n    if (isOperand(char)) {\n      postfix += char;\n    } else if (char === '(') {\n      stack.push(char);\n    } else if (char === ')') {\n      while (!stack.isEmpty() && stack.peek() !== '(') {\n        postfix += stack.pop();\n      }\n      stack.pop(); // Remove '('\n    } else if (isOperator(char)) {\n      while (\n        !stack.isEmpty() &&\n        stack.peek() !== '(' &&\n        precedence[stack.peek()] >= precedence[char]\n      ) {\n        postfix += stack.pop();\n      }\n      stack.push(char);\n    }\n  }\n\n  while (!stack.isEmpty()) {\n    postfix += stack.pop();\n  }\n\n  return postfix;\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"2-postfix-evaluation",children:"2. Postfix Evaluation"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function evaluatePostfix(postfix) {\n  const stack = new Stack();\n\n  for (const char of postfix) {\n    if (/\\d/.test(char)) {\n      stack.push(parseInt(char));\n    } else {\n      const operand2 = stack.pop();\n      const operand1 = stack.pop();\n\n      let result;\n      switch (char) {\n        case '+':\n          result = operand1 + operand2;\n          break;\n        case '-':\n          result = operand1 - operand2;\n          break;\n        case '*':\n          result = operand1 * operand2;\n          break;\n        case '/':\n          result = operand1 / operand2;\n          break;\n        case '^':\n          result = Math.pow(operand1, operand2);\n          break;\n      }\n\n      stack.push(result);\n    }\n  }\n\n  return stack.pop();\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"3-basic-calculator",children:"3. Basic Calculator"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function calculate(s) {\n  const stack = new Stack();\n  let num = 0;\n  let sign = 1; // 1 for positive, -1 for negative\n  let result = 0;\n\n  for (let i = 0; i < s.length; i++) {\n    const char = s[i];\n\n    if (/\\d/.test(char)) {\n      num = num * 10 + parseInt(char);\n    } else if (char === '+' || char === '-') {\n      result += sign * num;\n      num = 0;\n      sign = char === '+' ? 1 : -1;\n    } else if (char === '(') {\n      // Save current result and sign\n      stack.push(result);\n      stack.push(sign);\n      result = 0;\n      sign = 1;\n    } else if (char === ')') {\n      result += sign * num;\n      num = 0;\n\n      // Restore previous sign and result\n      result *= stack.pop(); // Previous sign\n      result += stack.pop(); // Previous result\n    }\n  }\n\n  return result + sign * num;\n}\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"parentheses-problems",children:"Parentheses Problems"}),"\n",(0,s.jsx)(e.h3,{id:"1-valid-parentheses",children:"1. Valid Parentheses"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function isValid(s) {\n  const stack = new Stack();\n  const mapping = {\n    ')': '(',\n    '}': '{',\n    ']': '[',\n  };\n\n  for (const char of s) {\n    if (char === '(' || char === '{' || char === '[') {\n      stack.push(char);\n    } else if (char === ')' || char === '}' || char === ']') {\n      if (stack.isEmpty() || stack.pop() !== mapping[char]) {\n        return false;\n      }\n    }\n  }\n\n  return stack.isEmpty();\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"2-generate-parentheses",children:"2. Generate Parentheses"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function generateParenthesis(n) {\n  const result = [];\n\n  function backtrack(current, open, close) {\n    if (current.length === 2 * n) {\n      result.push(current);\n      return;\n    }\n\n    if (open < n) {\n      backtrack(current + '(', open + 1, close);\n    }\n\n    if (close < open) {\n      backtrack(current + ')', open, close + 1);\n    }\n  }\n\n  backtrack('', 0, 0);\n  return result;\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"3-longest-valid-parentheses",children:"3. Longest Valid Parentheses"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function longestValidParentheses(s) {\n  const stack = new Stack();\n  stack.push(-1); // Base for calculating length\n  let maxLength = 0;\n\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === '(') {\n      stack.push(i);\n    } else {\n      stack.pop();\n\n      if (stack.isEmpty()) {\n        stack.push(i);\n      } else {\n        maxLength = Math.max(maxLength, i - stack.peek());\n      }\n    }\n  }\n\n  return maxLength;\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"4-remove-invalid-parentheses",children:"4. Remove Invalid Parentheses"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function removeInvalidParentheses(s) {\n  // Count invalid parentheses\n  let leftRemove = 0,\n    rightRemove = 0;\n\n  for (const char of s) {\n    if (char === '(') {\n      leftRemove++;\n    } else if (char === ')') {\n      if (leftRemove > 0) {\n        leftRemove--;\n      } else {\n        rightRemove++;\n      }\n    }\n  }\n\n  const result = new Set();\n\n  function dfs(index, leftCount, rightCount, leftRem, rightRem, current) {\n    if (index === s.length) {\n      if (leftRem === 0 && rightRem === 0) {\n        result.add(current);\n      }\n      return;\n    }\n\n    const char = s[index];\n\n    // Option 1: Remove current character\n    if ((char === '(' && leftRem > 0) || (char === ')' && rightRem > 0)) {\n      dfs(\n        index + 1,\n        leftCount,\n        rightCount,\n        leftRem - (char === '(' ? 1 : 0),\n        rightRem - (char === ')' ? 1 : 0),\n        current\n      );\n    }\n\n    // Option 2: Keep current character\n    if (char !== '(' && char !== ')') {\n      dfs(index + 1, leftCount, rightCount, leftRem, rightRem, current + char);\n    } else if (char === '(') {\n      dfs(\n        index + 1,\n        leftCount + 1,\n        rightCount,\n        leftRem,\n        rightRem,\n        current + char\n      );\n    } else if (rightCount < leftCount) {\n      dfs(\n        index + 1,\n        leftCount,\n        rightCount + 1,\n        leftRem,\n        rightRem,\n        current + char\n      );\n    }\n  }\n\n  dfs(0, 0, 0, leftRemove, rightRemove, '');\n  return Array.from(result);\n}\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"monotonic-stack",children:"Monotonic Stack"}),"\n",(0,s.jsxs)(e.p,{children:["A ",(0,s.jsx)(e.strong,{children:"monotonic stack"})," maintains elements in either increasing or decreasing order. It's extremely useful for finding next/previous greater/smaller elements."]}),"\n",(0,s.jsx)(e.h3,{id:"1-next-greater-element-pattern",children:"1. Next Greater Element Pattern"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"// Template for Next Greater Element problems\nfunction nextGreaterElements(arr) {\n  const result = new Array(arr.length).fill(-1);\n  const stack = []; // Monotonic decreasing stack\n\n  for (let i = 0; i < arr.length; i++) {\n    // Pop elements smaller than current\n    while (stack.length > 0 && arr[stack[stack.length - 1]] < arr[i]) {\n      const index = stack.pop();\n      result[index] = arr[i];\n    }\n    stack.push(i);\n  }\n\n  return result;\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"2-next-greater-element-ii-circular-array",children:"2. Next Greater Element II (Circular Array)"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function nextGreaterElementsII(nums) {\n  const n = nums.length;\n  const result = new Array(n).fill(-1);\n  const stack = [];\n\n  // Process array twice to handle circular nature\n  for (let i = 0; i < 2 * n; i++) {\n    const index = i % n;\n\n    while (stack.length > 0 && nums[stack[stack.length - 1]] < nums[index]) {\n      const idx = stack.pop();\n      result[idx] = nums[index];\n    }\n\n    if (i < n) {\n      stack.push(index);\n    }\n  }\n\n  return result;\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"3-daily-temperatures",children:"3. Daily Temperatures"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function dailyTemperatures(temperatures) {\n  const result = new Array(temperatures.length).fill(0);\n  const stack = []; // Store indices\n\n  for (let i = 0; i < temperatures.length; i++) {\n    while (\n      stack.length > 0 &&\n      temperatures[stack[stack.length - 1]] < temperatures[i]\n    ) {\n      const index = stack.pop();\n      result[index] = i - index;\n    }\n    stack.push(i);\n  }\n\n  return result;\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"4-largest-rectangle-in-histogram",children:"4. Largest Rectangle in Histogram"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function largestRectangleArea(heights) {\n  const stack = []; // Monotonic increasing stack\n  let maxArea = 0;\n  let index = 0;\n\n  while (index < heights.length) {\n    if (\n      stack.length === 0 ||\n      heights[index] >= heights[stack[stack.length - 1]]\n    ) {\n      stack.push(index++);\n    } else {\n      const top = stack.pop();\n      const width =\n        stack.length === 0 ? index : index - stack[stack.length - 1] - 1;\n      const area = heights[top] * width;\n      maxArea = Math.max(maxArea, area);\n    }\n  }\n\n  while (stack.length > 0) {\n    const top = stack.pop();\n    const width =\n      stack.length === 0 ? index : index - stack[stack.length - 1] - 1;\n    const area = heights[top] * width;\n    maxArea = Math.max(maxArea, area);\n  }\n\n  return maxArea;\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"5-maximal-rectangle",children:"5. Maximal Rectangle"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function maximalRectangle(matrix) {\n  if (!matrix || matrix.length === 0) return 0;\n\n  const rows = matrix.length;\n  const cols = matrix[0].length;\n  const heights = new Array(cols).fill(0);\n  let maxArea = 0;\n\n  for (let i = 0; i < rows; i++) {\n    // Update heights array\n    for (let j = 0; j < cols; j++) {\n      heights[j] = matrix[i][j] === '1' ? heights[j] + 1 : 0;\n    }\n\n    // Calculate max rectangle for current row\n    maxArea = Math.max(maxArea, largestRectangleArea(heights));\n  }\n\n  return maxArea;\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"6-trapping-rain-water",children:"6. Trapping Rain Water"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function trap(height) {\n  const stack = [];\n  let water = 0;\n\n  for (let i = 0; i < height.length; i++) {\n    while (stack.length > 0 && height[i] > height[stack[stack.length - 1]]) {\n      const bottom = stack.pop();\n\n      if (stack.length === 0) break;\n\n      const distance = i - stack[stack.length - 1] - 1;\n      const boundedHeight =\n        Math.min(height[i], height[stack[stack.length - 1]]) - height[bottom];\n      water += distance * boundedHeight;\n    }\n    stack.push(i);\n  }\n\n  return water;\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"7-sum-of-subarray-minimums",children:"7. Sum of Subarray Minimums"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function sumSubarrayMins(arr) {\n  const MOD = 1000000007;\n  const n = arr.length;\n\n  // Find previous less element\n  const prevLess = new Array(n).fill(-1);\n  let stack = [];\n\n  for (let i = 0; i < n; i++) {\n    while (stack.length > 0 && arr[stack[stack.length - 1]] >= arr[i]) {\n      stack.pop();\n    }\n    if (stack.length > 0) {\n      prevLess[i] = stack[stack.length - 1];\n    }\n    stack.push(i);\n  }\n\n  // Find next less element\n  const nextLess = new Array(n).fill(n);\n  stack = [];\n\n  for (let i = n - 1; i >= 0; i--) {\n    while (stack.length > 0 && arr[stack[stack.length - 1]] > arr[i]) {\n      stack.pop();\n    }\n    if (stack.length > 0) {\n      nextLess[i] = stack[stack.length - 1];\n    }\n    stack.push(i);\n  }\n\n  // Calculate sum\n  let result = 0;\n  for (let i = 0; i < n; i++) {\n    const left = i - prevLess[i];\n    const right = nextLess[i] - i;\n    result = (result + ((arr[i] * left * right) % MOD)) % MOD;\n  }\n\n  return result;\n}\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"stack-in-recursion",children:"Stack in Recursion"}),"\n",(0,s.jsx)(e.h3,{id:"1-binary-tree-traversal-iterative",children:"1. Binary Tree Traversal (Iterative)"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"// Preorder Traversal\nfunction preorderTraversal(root) {\n  if (!root) return [];\n\n  const result = [];\n  const stack = [root];\n\n  while (stack.length > 0) {\n    const node = stack.pop();\n    result.push(node.val);\n\n    if (node.right) stack.push(node.right);\n    if (node.left) stack.push(node.left);\n  }\n\n  return result;\n}\n\n// Inorder Traversal\nfunction inorderTraversal(root) {\n  const result = [];\n  const stack = [];\n  let current = root;\n\n  while (current || stack.length > 0) {\n    while (current) {\n      stack.push(current);\n      current = current.left;\n    }\n\n    current = stack.pop();\n    result.push(current.val);\n    current = current.right;\n  }\n\n  return result;\n}\n\n// Postorder Traversal\nfunction postorderTraversal(root) {\n  if (!root) return [];\n\n  const result = [];\n  const stack = [];\n  let lastVisited = null;\n  let current = root;\n\n  while (current || stack.length > 0) {\n    if (current) {\n      stack.push(current);\n      current = current.left;\n    } else {\n      const peekNode = stack[stack.length - 1];\n      if (peekNode.right && lastVisited !== peekNode.right) {\n        current = peekNode.right;\n      } else {\n        result.push(peekNode.val);\n        lastVisited = stack.pop();\n      }\n    }\n  }\n\n  return result;\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"2-flatten-binary-tree-to-linked-list",children:"2. Flatten Binary Tree to Linked List"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function flatten(root) {\n  if (!root) return;\n\n  const stack = [root];\n\n  while (stack.length > 0) {\n    const node = stack.pop();\n\n    if (node.right) stack.push(node.right);\n    if (node.left) stack.push(node.left);\n\n    if (stack.length > 0) {\n      node.right = stack[stack.length - 1];\n    }\n    node.left = null;\n  }\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"3-path-sum-ii",children:"3. Path Sum II"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function pathSum(root, targetSum) {\n  if (!root) return [];\n\n  const result = [];\n  const stack = [[root, [root.val], root.val]];\n\n  while (stack.length > 0) {\n    const [node, path, sum] = stack.pop();\n\n    if (!node.left && !node.right && sum === targetSum) {\n      result.push([...path]);\n    }\n\n    if (node.right) {\n      stack.push([node.right, [...path, node.right.val], sum + node.right.val]);\n    }\n\n    if (node.left) {\n      stack.push([node.left, [...path, node.left.val], sum + node.left.val]);\n    }\n  }\n\n  return result;\n}\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"two-stacks-problems",children:"Two Stacks Problems"}),"\n",(0,s.jsx)(e.h3,{id:"1-implement-queue-using-stacks",children:"1. Implement Queue using Stacks"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"class MyQueue {\n  constructor() {\n    this.stack1 = []; // For enqueue\n    this.stack2 = []; // For dequeue\n  }\n\n  push(x) {\n    this.stack1.push(x);\n  }\n\n  pop() {\n    this.moveStack1ToStack2();\n    return this.stack2.pop();\n  }\n\n  peek() {\n    this.moveStack1ToStack2();\n    return this.stack2[this.stack2.length - 1];\n  }\n\n  empty() {\n    return this.stack1.length === 0 && this.stack2.length === 0;\n  }\n\n  moveStack1ToStack2() {\n    if (this.stack2.length === 0) {\n      while (this.stack1.length > 0) {\n        this.stack2.push(this.stack1.pop());\n      }\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"2-sort-stack",children:"2. Sort Stack"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function sortStack(stack) {\n  const tempStack = [];\n\n  while (stack.length > 0) {\n    const temp = stack.pop();\n\n    while (tempStack.length > 0 && tempStack[tempStack.length - 1] > temp) {\n      stack.push(tempStack.pop());\n    }\n\n    tempStack.push(temp);\n  }\n\n  // Move back to original stack\n  while (tempStack.length > 0) {\n    stack.push(tempStack.pop());\n  }\n\n  return stack;\n}\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"stack-with-additional-operations",children:"Stack with Additional Operations"}),"\n",(0,s.jsx)(e.h3,{id:"1-min-stack",children:"1. Min Stack"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"class MinStack {\n  constructor() {\n    this.stack = [];\n    this.minStack = [];\n  }\n\n  push(val) {\n    this.stack.push(val);\n\n    if (this.minStack.length === 0 || val <= this.getMin()) {\n      this.minStack.push(val);\n    }\n  }\n\n  pop() {\n    const popped = this.stack.pop();\n\n    if (popped === this.getMin()) {\n      this.minStack.pop();\n    }\n\n    return popped;\n  }\n\n  top() {\n    return this.stack[this.stack.length - 1];\n  }\n\n  getMin() {\n    return this.minStack[this.minStack.length - 1];\n  }\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"2-max-stack",children:"2. Max Stack"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"class MaxStack {\n  constructor() {\n    this.stack = [];\n    this.maxStack = [];\n    this.id = 0;\n  }\n\n  push(x) {\n    const currentId = this.id++;\n    this.stack.push([x, currentId]);\n\n    if (\n      this.maxStack.length === 0 ||\n      x >= this.maxStack[this.maxStack.length - 1][0]\n    ) {\n      this.maxStack.push([x, currentId]);\n    }\n  }\n\n  pop() {\n    const [val, id] = this.stack.pop();\n\n    if (\n      this.maxStack.length > 0 &&\n      this.maxStack[this.maxStack.length - 1][1] === id\n    ) {\n      this.maxStack.pop();\n    }\n\n    return val;\n  }\n\n  top() {\n    return this.stack[this.stack.length - 1][0];\n  }\n\n  peekMax() {\n    return this.maxStack[this.maxStack.length - 1][0];\n  }\n\n  popMax() {\n    const [maxVal, maxId] = this.maxStack.pop();\n    const buffer = [];\n\n    // Remove elements until we find the max\n    while (this.stack[this.stack.length - 1][1] !== maxId) {\n      buffer.push(this.stack.pop());\n    }\n\n    this.stack.pop(); // Remove the max element\n\n    // Push back other elements\n    while (buffer.length > 0) {\n      const [val] = buffer.pop();\n      this.push(val);\n    }\n\n    return maxVal;\n  }\n}\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"advanced-stack-patterns",children:"Advanced Stack Patterns"}),"\n",(0,s.jsx)(e.h3,{id:"1-asteroid-collision",children:"1. Asteroid Collision"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function asteroidCollision(asteroids) {\n  const stack = [];\n\n  for (const asteroid of asteroids) {\n    let exploded = false;\n\n    while (stack.length > 0 && asteroid < 0 && stack[stack.length - 1] > 0) {\n      if (stack[stack.length - 1] < -asteroid) {\n        stack.pop();\n        continue;\n      } else if (stack[stack.length - 1] === -asteroid) {\n        stack.pop();\n      }\n      exploded = true;\n      break;\n    }\n\n    if (!exploded) {\n      stack.push(asteroid);\n    }\n  }\n\n  return stack;\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"2-decode-string",children:"2. Decode String"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function decodeString(s) {\n  const stack = [];\n  let currentString = '';\n  let currentNum = 0;\n\n  for (const char of s) {\n    if (/\\d/.test(char)) {\n      currentNum = currentNum * 10 + parseInt(char);\n    } else if (char === '[') {\n      stack.push([currentString, currentNum]);\n      currentString = '';\n      currentNum = 0;\n    } else if (char === ']') {\n      const [prevString, num] = stack.pop();\n      currentString = prevString + currentString.repeat(num);\n    } else {\n      currentString += char;\n    }\n  }\n\n  return currentString;\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"3-remove-k-digits",children:"3. Remove K Digits"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function removeKdigits(num, k) {\n  const stack = [];\n  let toRemove = k;\n\n  for (const digit of num) {\n    while (\n      stack.length > 0 &&\n      stack[stack.length - 1] > digit &&\n      toRemove > 0\n    ) {\n      stack.pop();\n      toRemove--;\n    }\n    stack.push(digit);\n  }\n\n  // Remove remaining digits from the end\n  while (toRemove > 0) {\n    stack.pop();\n    toRemove--;\n  }\n\n  // Build result and handle leading zeros\n  const result = stack.join('').replace(/^0+/, '');\n  return result === '' ? '0' : result;\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"4-valid-stack-sequences",children:"4. Valid Stack Sequences"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function validateStackSequences(pushed, popped) {\n  const stack = [];\n  let popIndex = 0;\n\n  for (const num of pushed) {\n    stack.push(num);\n\n    while (stack.length > 0 && stack[stack.length - 1] === popped[popIndex]) {\n      stack.pop();\n      popIndex++;\n    }\n  }\n\n  return stack.length === 0;\n}\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"stack-in-graph-algorithms",children:"Stack in Graph Algorithms"}),"\n",(0,s.jsx)(e.h3,{id:"1-depth-first-search-dfs",children:"1. Depth-First Search (DFS)"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function dfsIterative(graph, start) {\n  const visited = new Set();\n  const stack = [start];\n  const result = [];\n\n  while (stack.length > 0) {\n    const vertex = stack.pop();\n\n    if (!visited.has(vertex)) {\n      visited.add(vertex);\n      result.push(vertex);\n\n      // Add neighbors to stack\n      for (const neighbor of graph[vertex]) {\n        if (!visited.has(neighbor)) {\n          stack.push(neighbor);\n        }\n      }\n    }\n  }\n\n  return result;\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"2-topological-sort",children:"2. Topological Sort"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function topologicalSort(graph) {\n  const visited = new Set();\n  const stack = [];\n\n  function dfs(vertex) {\n    visited.add(vertex);\n\n    for (const neighbor of graph[vertex] || []) {\n      if (!visited.has(neighbor)) {\n        dfs(neighbor);\n      }\n    }\n\n    stack.push(vertex);\n  }\n\n  // Visit all vertices\n  for (const vertex in graph) {\n    if (!visited.has(vertex)) {\n      dfs(vertex);\n    }\n  }\n\n  return stack.reverse();\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"3-find-strongly-connected-components",children:"3. Find Strongly Connected Components"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function stronglyConnectedComponents(graph) {\n  const visited = new Set();\n  const finishOrder = [];\n\n  // First DFS to get finish order\n  function dfs1(vertex) {\n    visited.add(vertex);\n\n    for (const neighbor of graph[vertex] || []) {\n      if (!visited.has(neighbor)) {\n        dfs1(neighbor);\n      }\n    }\n    finishOrder.push(vertex);\n  }\n\n  // Get transpose graph\n  function getTranspose(graph) {\n    const transpose = {};\n    for (const vertex in graph) {\n      for (const neighbor of graph[vertex] || []) {\n        if (!transpose[neighbor]) transpose[neighbor] = [];\n        transpose[neighbor].push(vertex);\n      }\n    }\n    return transpose;\n  }\n\n  // First DFS on original graph\n  for (const vertex in graph) {\n    if (!visited.has(vertex)) {\n      dfs1(vertex);\n    }\n  }\n\n  // Second DFS on transpose graph in reverse finish order\n  const transpose = getTranspose(graph);\n  visited.clear();\n  const components = [];\n\n  function dfs2(vertex, component) {\n    visited.add(vertex);\n    component.push(vertex);\n\n    for (const neighbor of transpose[vertex] || []) {\n      if (!visited.has(neighbor)) {\n        dfs2(neighbor, component);\n      }\n    }\n  }\n\n  while (finishOrder.length > 0) {\n    const vertex = finishOrder.pop();\n    if (!visited.has(vertex)) {\n      const component = [];\n      dfs2(vertex, component);\n      components.push(component);\n    }\n  }\n\n  return components;\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"4-detect-cycle-in-directed-graph",children:"4. Detect Cycle in Directed Graph"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function hasCycle(graph) {\n  const WHITE = 0,\n    GRAY = 1,\n    BLACK = 2;\n  const colors = {};\n\n  // Initialize all vertices as WHITE\n  for (const vertex in graph) {\n    colors[vertex] = WHITE;\n  }\n\n  function dfs(vertex) {\n    colors[vertex] = GRAY;\n\n    for (const neighbor of graph[vertex] || []) {\n      if (colors[neighbor] === GRAY) {\n        return true; // Back edge found - cycle detected\n      }\n\n      if (colors[neighbor] === WHITE && dfs(neighbor)) {\n        return true;\n      }\n    }\n\n    colors[vertex] = BLACK;\n    return false;\n  }\n\n  for (const vertex in graph) {\n    if (colors[vertex] === WHITE && dfs(vertex)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"memory-management",children:"Memory Management"}),"\n",(0,s.jsx)(e.h3,{id:"1-stack-overflow-prevention",children:"1. Stack Overflow Prevention"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"class SafeStack {\n  constructor(maxSize = 1000) {\n    this.items = [];\n    this.maxSize = maxSize;\n  }\n\n  push(element) {\n    if (this.items.length >= this.maxSize) {\n      throw new Error(`Stack overflow: Cannot exceed ${this.maxSize} elements`);\n    }\n    this.items.push(element);\n  }\n\n  pop() {\n    if (this.isEmpty()) {\n      throw new Error('Stack underflow: Cannot pop from empty stack');\n    }\n    return this.items.pop();\n  }\n\n  // Rest of the methods...\n  peek() {\n    return this.items[this.items.length - 1];\n  }\n  isEmpty() {\n    return this.items.length === 0;\n  }\n  size() {\n    return this.items.length;\n  }\n  clear() {\n    this.items = [];\n  }\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"2-memory-efficient-stack",children:"2. Memory-Efficient Stack"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"class MemoryEfficientStack {\n  constructor() {\n    this.head = null;\n    this.stackSize = 0;\n  }\n\n  push(data) {\n    const newNode = { data, next: this.head };\n    this.head = newNode;\n    this.stackSize++;\n  }\n\n  pop() {\n    if (!this.head) return null;\n\n    const data = this.head.data;\n    this.head = this.head.next;\n    this.stackSize--;\n    return data;\n  }\n\n  peek() {\n    return this.head ? this.head.data : null;\n  }\n\n  isEmpty() {\n    return this.head === null;\n  }\n\n  size() {\n    return this.stackSize;\n  }\n}\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"common-optimization-tricks",children:"Common Optimization Tricks"}),"\n",(0,s.jsx)(e.h3,{id:"1-stack-with-o1-minmax-operations",children:"1. Stack with O(1) Min/Max Operations"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"class OptimizedMinMaxStack {\n  constructor() {\n    this.stack = [];\n  }\n\n  push(val) {\n    if (this.stack.length === 0) {\n      this.stack.push({ val, min: val, max: val });\n    } else {\n      const top = this.stack[this.stack.length - 1];\n      this.stack.push({\n        val,\n        min: Math.min(val, top.min),\n        max: Math.max(val, top.max),\n      });\n    }\n  }\n\n  pop() {\n    return this.stack.pop();\n  }\n\n  top() {\n    return this.stack[this.stack.length - 1].val;\n  }\n\n  getMin() {\n    return this.stack[this.stack.length - 1].min;\n  }\n\n  getMax() {\n    return this.stack[this.stack.length - 1].max;\n  }\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"2-multiple-stacks-in-single-array",children:"2. Multiple Stacks in Single Array"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"class MultiStack {\n  constructor(stackCount, capacity) {\n    this.stackCount = stackCount;\n    this.capacity = capacity;\n    this.array = new Array(stackCount * capacity);\n    this.tops = new Array(stackCount).fill(-1);\n  }\n\n  push(stackNum, value) {\n    if (this.isFull(stackNum)) {\n      throw new Error(`Stack ${stackNum} is full`);\n    }\n\n    this.tops[stackNum]++;\n    const index = stackNum * this.capacity + this.tops[stackNum];\n    this.array[index] = value;\n  }\n\n  pop(stackNum) {\n    if (this.isEmpty(stackNum)) {\n      throw new Error(`Stack ${stackNum} is empty`);\n    }\n\n    const index = stackNum * this.capacity + this.tops[stackNum];\n    const value = this.array[index];\n    this.array[index] = null;\n    this.tops[stackNum]--;\n\n    return value;\n  }\n\n  peek(stackNum) {\n    if (this.isEmpty(stackNum)) return null;\n\n    const index = stackNum * this.capacity + this.tops[stackNum];\n    return this.array[index];\n  }\n\n  isEmpty(stackNum) {\n    return this.tops[stackNum] === -1;\n  }\n\n  isFull(stackNum) {\n    return this.tops[stackNum] === this.capacity - 1;\n  }\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"3-stack-with-increment-operation",children:"3. Stack with Increment Operation"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"class CustomStack {\n  constructor(maxSize) {\n    this.maxSize = maxSize;\n    this.stack = [];\n    this.increments = []; // Lazy propagation array\n  }\n\n  push(x) {\n    if (this.stack.length < this.maxSize) {\n      this.stack.push(x);\n      this.increments.push(0);\n    }\n  }\n\n  pop() {\n    if (this.stack.length === 0) return -1;\n\n    const index = this.stack.length - 1;\n\n    // Apply increment to previous element (lazy propagation)\n    if (index > 0) {\n      this.increments[index - 1] += this.increments[index];\n    }\n\n    const result = this.stack.pop() + this.increments.pop();\n    return result;\n  }\n\n  increment(k, val) {\n    const limit = Math.min(k, this.stack.length);\n    if (limit > 0) {\n      this.increments[limit - 1] += val;\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"4-stack-with-getmiddle-operation",children:"4. Stack with getMiddle Operation"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"class StackWithMiddle {\n  constructor() {\n    this.count = 0;\n    this.head = null;\n    this.mid = null;\n  }\n\n  push(data) {\n    const newNode = { data, next: null, prev: null };\n\n    if (this.count === 0) {\n      this.head = newNode;\n      this.mid = newNode;\n    } else {\n      newNode.next = this.head;\n      this.head.prev = newNode;\n      this.head = newNode;\n\n      if (this.count % 2 === 1) {\n        this.mid = this.mid.prev;\n      }\n    }\n\n    this.count++;\n  }\n\n  pop() {\n    if (this.count === 0) return null;\n\n    const data = this.head.data;\n    this.head = this.head.next;\n\n    if (this.head) {\n      this.head.prev = null;\n    }\n\n    this.count--;\n\n    if (this.count % 2 === 0 && this.count > 0) {\n      this.mid = this.mid.next;\n    }\n\n    return data;\n  }\n\n  findMiddle() {\n    return this.mid ? this.mid.data : null;\n  }\n\n  deleteMiddle() {\n    if (this.count === 0) return null;\n\n    const data = this.mid.data;\n\n    if (this.count === 1) {\n      this.head = null;\n      this.mid = null;\n    } else {\n      if (this.mid.prev) {\n        this.mid.prev.next = this.mid.next;\n      }\n      if (this.mid.next) {\n        this.mid.next.prev = this.mid.prev;\n      }\n\n      if (this.count % 2 === 1) {\n        this.mid = this.mid.next;\n      } else {\n        this.mid = this.mid.prev;\n      }\n    }\n\n    this.count--;\n    return data;\n  }\n}\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"problem-solving-patterns",children:"Problem-Solving Patterns"}),"\n",(0,s.jsx)(e.h3,{id:"1-when-to-use-stack",children:"1. When to Use Stack"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Stack is suitable for problems involving:"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"LIFO operations:"})," Last element processed first"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Matching/Pairing:"})," Parentheses, brackets, tags"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Undo operations:"})," Editor undo, browser back"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Expression evaluation:"})," Infix to postfix, calculator"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Recursion simulation:"})," Tree traversal, DFS"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Monotonic properties:"})," Next greater/smaller element"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"2-stack-problem-templates",children:"2. Stack Problem Templates"}),"\n",(0,s.jsx)(e.h4,{id:"template-1-basic-stack-operations",children:"Template 1: Basic Stack Operations"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function basicStackProblem(input) {\n  const stack = [];\n\n  for (const element of input) {\n    // Process element based on problem logic\n    if (conditionToPush(element)) {\n      stack.push(element);\n    }\n\n    while (\n      stack.length > 0 &&\n      conditionToPop(stack[stack.length - 1], element)\n    ) {\n      const popped = stack.pop();\n      // Process popped element\n    }\n  }\n\n  // Process remaining elements in stack\n  while (stack.length > 0) {\n    processRemaining(stack.pop());\n  }\n\n  return result;\n}\n"})}),"\n",(0,s.jsx)(e.h4,{id:"template-2-monotonic-stack",children:"Template 2: Monotonic Stack"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function monotonicStackProblem(arr) {\n  const result = [];\n  const stack = []; // Stores indices or values\n\n  for (let i = 0; i < arr.length; i++) {\n    // Maintain monotonic property\n    while (\n      stack.length > 0 &&\n      compareCondition(arr[stack[stack.length - 1]], arr[i])\n    ) {\n      const index = stack.pop();\n      // Process the relationship between index and i\n      result[index] = processRelation(index, i);\n    }\n\n    stack.push(i);\n  }\n\n  // Handle remaining elements\n  while (stack.length > 0) {\n    const index = stack.pop();\n    result[index] = defaultValue;\n  }\n\n  return result;\n}\n"})}),"\n",(0,s.jsx)(e.h4,{id:"template-3-expression-parsing",children:"Template 3: Expression Parsing"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function parseExpression(expression) {\n  const operators = [];\n  const operands = [];\n\n  for (const token of tokenize(expression)) {\n    if (isOperand(token)) {\n      operands.push(token);\n    } else if (isOperator(token)) {\n      while (\n        operators.length > 0 &&\n        precedence(operators[operators.length - 1]) >= precedence(token)\n      ) {\n        applyOperator(operands, operators.pop());\n      }\n      operators.push(token);\n    } else if (token === '(') {\n      operators.push(token);\n    } else if (token === ')') {\n      while (operators.length > 0 && operators[operators.length - 1] !== '(') {\n        applyOperator(operands, operators.pop());\n      }\n      operators.pop(); // Remove '('\n    }\n  }\n\n  while (operators.length > 0) {\n    applyOperator(operands, operators.pop());\n  }\n\n  return operands[0];\n}\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"testing-and-debugging",children:"Testing and Debugging"}),"\n",(0,s.jsx)(e.h3,{id:"1-stack-testing-framework",children:"1. Stack Testing Framework"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"class StackTester {\n  static testStack(StackClass) {\n    const tests = [\n      {\n        name: 'Basic Operations',\n        test: () => {\n          const stack = new StackClass();\n          stack.push(1);\n          stack.push(2);\n          stack.push(3);\n\n          console.assert(stack.peek() === 3, 'Peek should return 3');\n          console.assert(stack.pop() === 3, 'Pop should return 3');\n          console.assert(stack.size() === 2, 'Size should be 2');\n          console.assert(!stack.isEmpty(), 'Stack should not be empty');\n\n          stack.pop();\n          stack.pop();\n          console.assert(stack.isEmpty(), 'Stack should be empty');\n        },\n      },\n      {\n        name: 'Edge Cases',\n        test: () => {\n          const stack = new StackClass();\n          console.assert(stack.isEmpty(), 'New stack should be empty');\n          console.assert(\n            stack.peek() === null || stack.peek() === undefined,\n            'Peek on empty stack'\n          );\n          console.assert(\n            stack.pop() === null || stack.pop() === undefined,\n            'Pop on empty stack'\n          );\n        },\n      },\n    ];\n\n    tests.forEach(({ name, test }) => {\n      try {\n        test();\n        console.log(`\u2705 ${name} passed`);\n      } catch (error) {\n        console.log(`\u274c ${name} failed:`, error.message);\n      }\n    });\n  }\n}\n\n// Usage\nStackTester.testStack(Stack);\n"})}),"\n",(0,s.jsx)(e.h3,{id:"2-stack-visualization",children:"2. Stack Visualization"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"class VisualStack extends Stack {\n  push(element) {\n    super.push(element);\n    this.visualize();\n  }\n\n  pop() {\n    const result = super.pop();\n    this.visualize();\n    return result;\n  }\n\n  visualize() {\n    console.log('Stack visualization:');\n    console.log('Top');\n    for (let i = this.items.length - 1; i >= 0; i--) {\n      console.log(`|  ${this.items[i]}  |`);\n    }\n    console.log('--------');\n    console.log('Bottom');\n    console.log(`Size: ${this.size()}\\n`);\n  }\n}\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"performance-analysis",children:"Performance Analysis"}),"\n",(0,s.jsx)(e.h3,{id:"time-complexity-summary",children:"Time Complexity Summary"}),"\n",(0,s.jsxs)(e.table,{children:[(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"Operation"}),(0,s.jsx)(e.th,{children:"Array-based"}),(0,s.jsx)(e.th,{children:"Linked List-based"})]})}),(0,s.jsxs)(e.tbody,{children:[(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Push"}),(0,s.jsx)(e.td,{children:"O(1)*"}),(0,s.jsx)(e.td,{children:"O(1)"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Pop"}),(0,s.jsx)(e.td,{children:"O(1)"}),(0,s.jsx)(e.td,{children:"O(1)"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Peek"}),(0,s.jsx)(e.td,{children:"O(1)"}),(0,s.jsx)(e.td,{children:"O(1)"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Search"}),(0,s.jsx)(e.td,{children:"O(n)"}),(0,s.jsx)(e.td,{children:"O(n)"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Space"}),(0,s.jsx)(e.td,{children:"O(n)"}),(0,s.jsx)(e.td,{children:"O(n)"})]})]})]}),"\n",(0,s.jsx)(e.p,{children:"*Amortized O(1) for dynamic arrays"}),"\n",(0,s.jsx)(e.h3,{id:"space-complexity-considerations",children:"Space Complexity Considerations"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"// Space-efficient stack for specific use cases\nclass CompactStack {\n  constructor() {\n    this.data = 0;\n    this.count = 0;\n  }\n\n  // Only works for small integers\n  push(val) {\n    if (val < 0 || val > 9) throw new Error('Value out of range');\n    this.data = this.data * 10 + val;\n    this.count++;\n  }\n\n  pop() {\n    if (this.count === 0) return null;\n    const result = this.data % 10;\n    this.data = Math.floor(this.data / 10);\n    this.count--;\n    return result;\n  }\n\n  peek() {\n    return this.count === 0 ? null : this.data % 10;\n  }\n\n  isEmpty() {\n    return this.count === 0;\n  }\n}\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"real-world-applications",children:"Real-World Applications"}),"\n",(0,s.jsx)(e.h3,{id:"1-browser-history",children:"1. Browser History"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"class BrowserHistory {\n  constructor(homepage) {\n    this.history = [homepage];\n    this.currentIndex = 0;\n  }\n\n  visit(url) {\n    // Remove forward history\n    this.history = this.history.slice(0, this.currentIndex + 1);\n    this.history.push(url);\n    this.currentIndex++;\n  }\n\n  back(steps) {\n    this.currentIndex = Math.max(0, this.currentIndex - steps);\n    return this.history[this.currentIndex];\n  }\n\n  forward(steps) {\n    this.currentIndex = Math.min(\n      this.history.length - 1,\n      this.currentIndex + steps\n    );\n    return this.history[this.currentIndex];\n  }\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"2-undoredo-system",children:"2. Undo/Redo System"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"class UndoRedoSystem {\n  constructor() {\n    this.undoStack = [];\n    this.redoStack = [];\n  }\n\n  executeCommand(command) {\n    command.execute();\n    this.undoStack.push(command);\n    this.redoStack = []; // Clear redo stack\n  }\n\n  undo() {\n    if (this.undoStack.length === 0) return false;\n\n    const command = this.undoStack.pop();\n    command.undo();\n    this.redoStack.push(command);\n    return true;\n  }\n\n  redo() {\n    if (this.redoStack.length === 0) return false;\n\n    const command = this.redoStack.pop();\n    command.execute();\n    this.undoStack.push(command);\n    return true;\n  }\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"3-function-call-stack-simulator",children:"3. Function Call Stack Simulator"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"class CallStack {\n  constructor() {\n    this.stack = [];\n    this.maxSize = 1000;\n  }\n\n  call(functionName, parameters = {}) {\n    if (this.stack.length >= this.maxSize) {\n      throw new Error('Stack overflow: Maximum call stack size exceeded');\n    }\n\n    const frame = {\n      function: functionName,\n      parameters,\n      timestamp: Date.now(),\n      locals: {},\n    };\n\n    this.stack.push(frame);\n    console.log(`Calling: ${functionName}(${JSON.stringify(parameters)})`);\n  }\n\n  return(value) {\n    if (this.stack.length === 0) {\n      throw new Error('No function to return from');\n    }\n\n    const frame = this.stack.pop();\n    console.log(`Returning from: ${frame.function} with value: ${value}`);\n    return value;\n  }\n\n  getCurrentFrame() {\n    return this.stack.length > 0 ? this.stack[this.stack.length - 1] : null;\n  }\n\n  getStackTrace() {\n    return this.stack.map(frame => frame.function).reverse();\n  }\n}\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsx)(e.p,{children:"Stacks are fundamental data structures with wide applications in computer science. Key takeaways:"}),"\n",(0,s.jsx)(e.h3,{id:"essential-patterns",children:(0,s.jsx)(e.strong,{children:"Essential Patterns:"})}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Basic Stack Operations"})," - LIFO principle, push/pop operations"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Monotonic Stack"})," - Maintaining order for next/previous greater/smaller problems"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Expression Evaluation"})," - Parsing and evaluating mathematical expressions"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Recursive Simulation"})," - Converting recursive algorithms to iterative using stacks"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"when-to-use-stacks",children:(0,s.jsx)(e.strong,{children:"When to Use Stacks:"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Matching problems"})," (parentheses, brackets)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Expression parsing"})," and evaluation"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Undo/Redo"})," functionality"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Function call"})," management"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Tree/Graph traversal"})," (DFS)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Monotonic relationships"})," in arrays"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"optimization-techniques",children:(0,s.jsx)(e.strong,{children:"Optimization Techniques:"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Space optimization"})," for specific constraints"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Lazy propagation"})," for bulk operations"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Multiple stacks"})," in single array"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Auxiliary stacks"})," for additional operations"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"best-practices",children:(0,s.jsx)(e.strong,{children:"Best Practices:"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["Always check for ",(0,s.jsx)(e.strong,{children:"empty stack"})," before pop/peek"]}),"\n",(0,s.jsxs)(e.li,{children:["Handle ",(0,s.jsx)(e.strong,{children:"stack overflow"})," in bounded implementations"]}),"\n",(0,s.jsxs)(e.li,{children:["Use ",(0,s.jsx)(e.strong,{children:"appropriate data structure"})," (array vs linked list)"]}),"\n",(0,s.jsxs)(e.li,{children:["Consider ",(0,s.jsx)(e.strong,{children:"space-time tradeoffs"})," for your use case"]}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"\ud83d\udca1 Pro Tip:"}),' When solving stack problems, think about what information needs to be "remembered" and accessed in LIFO order. Often, the stack stores indices rather than values to maintain relationships between elements.']}),"\n"]})]})}function d(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(h,{...n})}):h(n)}}}]);