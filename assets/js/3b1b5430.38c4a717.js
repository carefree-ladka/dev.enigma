"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[3083],{19701:(n,i,e)=>{e.r(i),e.d(i,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>s});var t=e(74848),r=e(28453);const o={},l="Grid-Based Graph",a={id:"DSA/DSA with Java/Grid Based Graph Patterns",title:"Grid-Based Graph",description:"Table of Contents",source:"@site/docs/DSA/DSA with Java/Grid Based Graph Patterns.mdx",sourceDirName:"DSA/DSA with Java",slug:"/DSA/DSA with Java/Grid Based Graph Patterns",permalink:"/docs/DSA/DSA with Java/Grid Based Graph Patterns",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with Java/Grid Based Graph Patterns.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Graph",permalink:"/docs/DSA/DSA with Java/Graph Patterns"},next:{title:"Intervals",permalink:"/docs/DSA/DSA with Java/Intervals Patterns"}},d={},s=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Grid Fundamentals &amp; Templates",id:"grid-fundamentals--templates",level:2},{value:"Core Grid Concepts[1][2]",id:"core-grid-concepts12",level:3},{value:"Universal Grid Templates",id:"universal-grid-templates",level:3},{value:"Pattern 1: Basic Grid Traversal",id:"pattern-1-basic-grid-traversal",level:2},{value:"1.1 Matrix Traversal (All Cells)",id:"11-matrix-traversal-all-cells",level:3},{value:"1.2 Grid BFS from Multiple Sources",id:"12-grid-bfs-from-multiple-sources",level:3},{value:"1.3 Grid Search Patterns",id:"13-grid-search-patterns",level:3},{value:"Pattern 2: Island &amp; Connected Components",id:"pattern-2-island--connected-components",level:2},{value:"2.1 Number of Islands",id:"21-number-of-islands",level:3},{value:"2.2 Max Area of Island",id:"22-max-area-of-island",level:3},{value:"2.3 Island Perimeter",id:"23-island-perimeter",level:3},{value:"2.4 Number of Distinct Islands",id:"24-number-of-distinct-islands",level:3},{value:"Pattern 3: Path Finding",id:"pattern-3-path-finding",level:2},{value:"3.1 Shortest Path in Binary Matrix",id:"31-shortest-path-in-binary-matrix",level:3},{value:"3.2 Path with Minimum Effort",id:"32-path-with-minimum-effort",level:3},{value:"3.3 Unique Paths with Obstacles",id:"33-unique-paths-with-obstacles",level:3},{value:"Pattern 4: Flood Fill &amp; Coloring",id:"pattern-4-flood-fill--coloring",level:2},{value:"4.1 Classic Flood Fill",id:"41-classic-flood-fill",level:3},{value:"4.2 Surrounded Regions",id:"42-surrounded-regions",level:3},{value:"4.3 Pacific Atlantic Water Flow",id:"43-pacific-atlantic-water-flow",level:3},{value:"Pattern 5: Grid Validation &amp; Constraints",id:"pattern-5-grid-validation--constraints",level:2},{value:"5.1 Valid Sudoku",id:"51-valid-sudoku",level:3},{value:"5.2 Word Search",id:"52-word-search",level:3},{value:"Pattern 6: Multi-Source BFS",id:"pattern-6-multi-source-bfs",level:2},{value:"6.1 Rotting Oranges",id:"61-rotting-oranges",level:3},{value:"6.2 Walls and Gates",id:"62-walls-and-gates",level:3},{value:"6.3 01 Matrix (Distance to Nearest 0)",id:"63-01-matrix-distance-to-nearest-0",level:3},{value:"Pattern 7: Grid DP &amp; Optimization",id:"pattern-7-grid-dp--optimization",level:2},{value:"7.1 Minimum Path Sum",id:"71-minimum-path-sum",level:3},{value:"7.2 Maximum Gold Collection",id:"72-maximum-gold-collection",level:3},{value:"Pattern 8: Binary Matrix Problems",id:"pattern-8-binary-matrix-problems",level:2},{value:"8.1 Largest Rectangle in Binary Matrix",id:"81-largest-rectangle-in-binary-matrix",level:3},{value:"8.2 Count Square Submatrices",id:"82-count-square-submatrices",level:3},{value:"Pattern 9: Grid Transformation",id:"pattern-9-grid-transformation",level:2},{value:"9.1 Game of Life",id:"91-game-of-life",level:3},{value:"9.2 Set Matrix Zeroes",id:"92-set-matrix-zeroes",level:3},{value:"Pattern 10: Pattern Matching in Grids",id:"pattern-10-pattern-matching-in-grids",level:2},{value:"10.1 Word Search in Grid",id:"101-word-search-in-grid",level:3},{value:"10.2 Count Paths in Grid",id:"102-count-paths-in-grid",level:3},{value:"Pattern 11: Game Board Problems",id:"pattern-11-game-board-problems",level:2},{value:"11.1 Tic-Tac-Toe Winner",id:"111-tic-tac-toe-winner",level:3},{value:"11.2 Valid Battleship Placement",id:"112-valid-battleship-placement",level:3},{value:"Pattern 12: Advanced Grid Problems",id:"pattern-12-advanced-grid-problems",level:2},{value:"12.1 Robot Room Cleaner",id:"121-robot-room-cleaner",level:3},{value:"12.2 Shortest Distance from All Buildings",id:"122-shortest-distance-from-all-buildings",level:3},{value:"Time &amp; Space Complexity Reference[5][2]",id:"time--space-complexity-reference52",level:2},{value:"Best Practices &amp; Optimization Tips",id:"best-practices--optimization-tips",level:2},{value:"Implementation Guidelines",id:"implementation-guidelines",level:3},{value:"Common Optimizations",id:"common-optimizations",level:3},{value:"Interview Tips",id:"interview-tips",level:3}];function c(n){const i={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.header,{children:(0,t.jsx)(i.h1,{id:"grid-based-graph",children:"Grid-Based Graph"})}),"\n",(0,t.jsx)(i.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"#grid-fundamentals--templates",children:"Grid Fundamentals & Templates"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"#pattern-1-basic-grid-traversal",children:"Pattern 1: Basic Grid Traversal"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"#pattern-2-island--connected-components",children:"Pattern 2: Island & Connected Components"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"#pattern-3-path-finding",children:"Pattern 3: Path Finding"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"#pattern-4-flood-fill--coloring",children:"Pattern 4: Flood Fill & Coloring"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"#pattern-5-grid-validation--constraints",children:"Pattern 5: Grid Validation & Constraints"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"#pattern-6-multi-source-bfs",children:"Pattern 6: Multi-Source BFS"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"#pattern-7-grid-dp--optimization",children:"Pattern 7: Grid DP & Optimization"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"#pattern-8-binary-matrix-problems",children:"Pattern 8: Binary Matrix Problems"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"#pattern-9-grid-transformation",children:"Pattern 9: Grid Transformation"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"#pattern-10-pattern-matching-in-grids",children:"Pattern 10: Pattern Matching in Grids"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"#pattern-11-game-board-problems",children:"Pattern 11: Game Board Problems"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"#pattern-12-advanced-grid-problems",children:"Pattern 12: Advanced Grid Problems"})}),"\n"]}),"\n",(0,t.jsx)(i.hr,{}),"\n",(0,t.jsx)(i.h2,{id:"grid-fundamentals--templates",children:"Grid Fundamentals & Templates"}),"\n",(0,t.jsx)(i.h3,{id:"core-grid-concepts12",children:"Core Grid Concepts[1][2]"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:"class GridTraversalFramework {\n    // Direction vectors for 4-directional movement\n    int[][] directions4 = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; // Up, Down, Left, Right\n\n    // Direction vectors for 8-directional movement\n    int[][] directions8 = {{-1,-1}, {-1,0}, {-1,1}, {0,-1}, {0,1}, {1,-1}, {1,0}, {1,1}};\n\n    // Alternative representation\n    int[] dx = {-1, 1, 0, 0}; // Row directions\n    int[] dy = {0, 0, -1, 1}; // Column directions\n\n    // Boundary check helper\n    boolean isValid(int[][] grid, int row, int col) {\n        return row >= 0 && row < grid.length &&\n               col >= 0 && col < grid[0].length;\n    }\n\n    // Boundary check with additional constraints\n    boolean isValidWithConstraints(int[][] grid, int row, int col, boolean[][] visited) {\n        return isValid(grid, row, col) &&\n               !visited[row][col] &&\n               grid[row][col] != 0; // Example: non-zero cells only\n    }\n\n    // Get all valid neighbors\n    List<int[]> getNeighbors(int[][] grid, int row, int col) {\n        List<int[]> neighbors = new ArrayList<>();\n        for (int[] dir : directions4) {\n            int newRow = row + dir[0];\n            int newCol = col + dir[1];\n            if (isValid(grid, newRow, newCol)) {\n                neighbors.add(new int[]{newRow, newCol});\n            }\n        }\n        return neighbors;\n    }\n}\n"})}),"\n",(0,t.jsx)(i.h3,{id:"universal-grid-templates",children:"Universal Grid Templates"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:"// DFS Template for Grid\nvoid dfsGrid(int[][] grid, int row, int col, boolean[][] visited) {\n    // Base case checks\n    if (!isValid(grid, row, col) || visited[row][col]) {\n        return;\n    }\n\n    // Mark current cell as visited\n    visited[row][col] = true;\n\n    // Process current cell\n    processCell(grid, row, col);\n\n    // Explore all 4 directions\n    for (int[] dir : directions4) {\n        int newRow = row + dir[0];\n        int newCol = col + dir[1];\n        dfsGrid(grid, newRow, newCol, visited);\n    }\n}\n\n// BFS Template for Grid\nvoid bfsGrid(int[][] grid, int startRow, int startCol) {\n    Queue<int[]> queue = new LinkedList<>();\n    boolean[][] visited = new boolean[grid.length][grid[0].length];\n\n    queue.offer(new int[]{startRow, startCol});\n    visited[startRow][startCol] = true;\n\n    while (!queue.isEmpty()) {\n        int[] current = queue.poll();\n        int row = current[0], col = current[1];\n\n        // Process current cell\n        processCell(grid, row, col);\n\n        // Add valid neighbors\n        for (int[] dir : directions4) {\n            int newRow = row + dir[0];\n            int newCol = col + dir[1];\n\n            if (isValid(grid, newRow, newCol) && !visited[newRow][newCol]) {\n                visited[newRow][newCol] = true;\n                queue.offer(new int[]{newRow, newCol});\n            }\n        }\n    }\n}\n\n// Multi-level BFS Template\nvoid bfsLevels(int[][] grid, int startRow, int startCol) {\n    Queue<int[]> queue = new LinkedList<>();\n    boolean[][] visited = new boolean[grid.length][grid[0].length];\n\n    queue.offer(new int[]{startRow, startCol});\n    visited[startRow][startCol] = true;\n    int level = 0;\n\n    while (!queue.isEmpty()) {\n        int size = queue.size();\n\n        // Process all nodes at current level\n        for (int i = 0; i < size; i++) {\n            int[] current = queue.poll();\n            int row = current[0], col = current[1];\n\n            processCell(grid, row, col, level);\n\n            // Add neighbors for next level\n            for (int[] dir : directions4) {\n                int newRow = row + dir[0];\n                int newCol = col + dir[1];\n\n                if (isValid(grid, newRow, newCol) && !visited[newRow][newCol]) {\n                    visited[newRow][newCol] = true;\n                    queue.offer(new int[]{newRow, newCol});\n                }\n            }\n        }\n        level++;\n    }\n}\n\n// Placeholder methods\nvoid processCell(int[][] grid, int row, int col) { /* Implementation specific */ }\nvoid processCell(int[][] grid, int row, int col, int level) { /* Implementation specific */ }\n"})}),"\n",(0,t.jsx)(i.hr,{}),"\n",(0,t.jsx)(i.h2,{id:"pattern-1-basic-grid-traversal",children:"Pattern 1: Basic Grid Traversal"}),"\n",(0,t.jsx)(i.h3,{id:"11-matrix-traversal-all-cells",children:"1.1 Matrix Traversal (All Cells)"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:'// Row-wise traversal\nvoid traverseRowWise(int[][] matrix) {\n    for (int i = 0; i < matrix.length; i++) {\n        for (int j = 0; j < matrix[0].length; j++) {\n            System.out.print(matrix[i][j] + " ");\n        }\n        System.out.println();\n    }\n}\n\n// Column-wise traversal\nvoid traverseColumnWise(int[][] matrix) {\n    for (int j = 0; j < matrix[0].length; j++) {\n        for (int i = 0; i < matrix.length; i++) {\n            System.out.print(matrix[i][j] + " ");\n        }\n        System.out.println();\n    }\n}\n\n// Diagonal traversal (main diagonal)\nvoid traverseMainDiagonal(int[][] matrix) {\n    int n = Math.min(matrix.length, matrix[0].length);\n    for (int i = 0; i < n; i++) {\n        System.out.print(matrix[i][i] + " ");\n    }\n}\n\n// Anti-diagonal traversal\nvoid traverseAntiDiagonal(int[][] matrix) {\n    int m = matrix.length, n = matrix[0].length;\n    for (int i = 0; i < m; i++) {\n        if (n - 1 - i >= 0) {\n            System.out.print(matrix[i][n - 1 - i] + " ");\n        }\n    }\n}\n\n// Spiral traversal\nList<Integer> spiralOrder(int[][] matrix) {\n    List<Integer> result = new ArrayList<>();\n    if (matrix.length == 0) return result;\n\n    int top = 0, bottom = matrix.length - 1;\n    int left = 0, right = matrix[0].length - 1;\n\n    while (top <= bottom && left <= right) {\n        // Traverse right\n        for (int col = left; col <= right; col++) {\n            result.add(matrix[top][col]);\n        }\n        top++;\n\n        // Traverse down\n        for (int row = top; row <= bottom; row++) {\n            result.add(matrix[row][right]);\n        }\n        right--;\n\n        // Traverse left (if still valid)\n        if (top <= bottom) {\n            for (int col = right; col >= left; col--) {\n                result.add(matrix[bottom][col]);\n            }\n            bottom--;\n        }\n\n        // Traverse up (if still valid)\n        if (left <= right) {\n            for (int row = bottom; row >= top; row--) {\n                result.add(matrix[row][left]);\n            }\n            left++;\n        }\n    }\n\n    return result;\n}\n'})}),"\n",(0,t.jsx)(i.h3,{id:"12-grid-bfs-from-multiple-sources",children:"1.2 Grid BFS from Multiple Sources"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:"// Level-order BFS starting from (0,0)\nList<List<Integer>> gridBFS(int[][] grid) {\n    List<List<Integer>> levels = new ArrayList<>();\n    if (grid.length == 0) return levels;\n\n    Queue<int[]> queue = new LinkedList<>();\n    boolean[][] visited = new boolean[grid.length][grid[0].length];\n\n    queue.offer(new int[]{0, 0});\n    visited[0][0] = true;\n\n    while (!queue.isEmpty()) {\n        int size = queue.size();\n        List<Integer> currentLevel = new ArrayList<>();\n\n        for (int i = 0; i < size; i++) {\n            int[] cell = queue.poll();\n            int row = cell[0], col = cell[1];\n            currentLevel.add(grid[row][col]);\n\n            for (int[] dir : directions4) {\n                int newRow = row + dir[0];\n                int newCol = col + dir[1];\n\n                if (isValid(grid, newRow, newCol) && !visited[newRow][newCol]) {\n                    visited[newRow][newCol] = true;\n                    queue.offer(new int[]{newRow, newCol});\n                }\n            }\n        }\n\n        levels.add(currentLevel);\n    }\n\n    return levels;\n}\n\n// Grid DFS with path tracking\nList<int[]> dfsPath(int[][] grid, int startRow, int startCol, int targetRow, int targetCol) {\n    List<int[]> path = new ArrayList<>();\n    boolean[][] visited = new boolean[grid.length][grid[0].length];\n\n    if (dfsPathHelper(grid, startRow, startCol, targetRow, targetCol, visited, path)) {\n        return path;\n    }\n\n    return new ArrayList<>(); // No path found\n}\n\nboolean dfsPathHelper(int[][] grid, int row, int col, int targetRow, int targetCol,\n                     boolean[][] visited, List<int[]> path) {\n    if (!isValid(grid, row, col) || visited[row][col]) {\n        return false;\n    }\n\n    visited[row][col] = true;\n    path.add(new int[]{row, col});\n\n    if (row == targetRow && col == targetCol) {\n        return true; // Found target\n    }\n\n    // Try all directions\n    for (int[] dir : directions4) {\n        int newRow = row + dir[0];\n        int newCol = col + dir[1];\n\n        if (dfsPathHelper(grid, newRow, newCol, targetRow, targetCol, visited, path)) {\n            return true;\n        }\n    }\n\n    path.remove(path.size() - 1); // Backtrack\n    return false;\n}\n"})}),"\n",(0,t.jsx)(i.h3,{id:"13-grid-search-patterns",children:"1.3 Grid Search Patterns"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:"// Find all occurrences of a value\nList<int[]> findAllOccurrences(int[][] grid, int target) {\n    List<int[]> positions = new ArrayList<>();\n\n    for (int i = 0; i < grid.length; i++) {\n        for (int j = 0; j < grid[0].length; j++) {\n            if (grid[i][j] == target) {\n                positions.add(new int[]{i, j});\n            }\n        }\n    }\n\n    return positions;\n}\n\n// Find first occurrence using BFS\nint[] findFirstBFS(int[][] grid, int target) {\n    Queue<int[]> queue = new LinkedList<>();\n    boolean[][] visited = new boolean[grid.length][grid[0].length];\n\n    // Start from all corners\n    queue.offer(new int[]{0, 0});\n    visited[0][0] = true;\n\n    while (!queue.isEmpty()) {\n        int[] cell = queue.poll();\n        int row = cell[0], col = cell[1];\n\n        if (grid[row][col] == target) {\n            return new int[]{row, col};\n        }\n\n        for (int[] dir : directions4) {\n            int newRow = row + dir[0];\n            int newCol = col + dir[1];\n\n            if (isValid(grid, newRow, newCol) && !visited[newRow][newCol]) {\n                visited[newRow][newCol] = true;\n                queue.offer(new int[]{newRow, newCol});\n            }\n        }\n    }\n\n    return new int[]{-1, -1}; // Not found\n}\n\n// Check if path exists between two points\nboolean hasPath(int[][] grid, int[] start, int[] end) {\n    if (grid[start[0]][start[1]] == 0 || grid[end[0]][end[1]] == 0) {\n        return false; // Blocked cells\n    }\n\n    Queue<int[]> queue = new LinkedList<>();\n    boolean[][] visited = new boolean[grid.length][grid[0].length];\n\n    queue.offer(start);\n    visited[start[0]][start[1]] = true;\n\n    while (!queue.isEmpty()) {\n        int[] current = queue.poll();\n\n        if (current[0] == end[0] && current[1] == end[1]) {\n            return true;\n        }\n\n        for (int[] dir : directions4) {\n            int newRow = current[0] + dir[0];\n            int newCol = current[1] + dir[1];\n\n            if (isValid(grid, newRow, newCol) &&\n                !visited[newRow][newCol] &&\n                grid[newRow][newCol] != 0) {\n\n                visited[newRow][newCol] = true;\n                queue.offer(new int[]{newRow, newCol});\n            }\n        }\n    }\n\n    return false;\n}\n"})}),"\n",(0,t.jsx)(i.hr,{}),"\n",(0,t.jsx)(i.h2,{id:"pattern-2-island--connected-components",children:"Pattern 2: Island & Connected Components"}),"\n",(0,t.jsx)(i.h3,{id:"21-number-of-islands",children:"2.1 Number of Islands"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:"int numIslands(char[][] grid) {\n    if (grid == null || grid.length == 0) return 0;\n\n    int count = 0;\n    for (int i = 0; i < grid.length; i++) {\n        for (int j = 0; j < grid[0].length; j++) {\n            if (grid[i][j] == '1') {\n                count++;\n                dfsMarkIsland(grid, i, j);\n            }\n        }\n    }\n\n    return count;\n}\n\nvoid dfsMarkIsland(char[][] grid, int row, int col) {\n    if (row < 0 || row >= grid.length ||\n        col < 0 || col >= grid[0].length ||\n        grid[row][col] != '1') {\n        return;\n    }\n\n    grid[row][col] = '0'; // Mark as visited\n\n    // Explore all 4 directions\n    dfsMarkIsland(grid, row + 1, col);\n    dfsMarkIsland(grid, row - 1, col);\n    dfsMarkIsland(grid, row, col + 1);\n    dfsMarkIsland(grid, row, col - 1);\n}\n\n// Without modifying original grid\nint numIslandsPreserveGrid(char[][] grid) {\n    if (grid == null || grid.length == 0) return 0;\n\n    boolean[][] visited = new boolean[grid.length][grid[0].length];\n    int count = 0;\n\n    for (int i = 0; i < grid.length; i++) {\n        for (int j = 0; j < grid[0].length; j++) {\n            if (grid[i][j] == '1' && !visited[i][j]) {\n                count++;\n                dfsVisitIsland(grid, i, j, visited);\n            }\n        }\n    }\n\n    return count;\n}\n\nvoid dfsVisitIsland(char[][] grid, int row, int col, boolean[][] visited) {\n    if (row < 0 || row >= grid.length ||\n        col < 0 || col >= grid[0].length ||\n        visited[row][col] || grid[row][col] != '1') {\n        return;\n    }\n\n    visited[row][col] = true;\n\n    dfsVisitIsland(grid, row + 1, col, visited);\n    dfsVisitIsland(grid, row - 1, col, visited);\n    dfsVisitIsland(grid, row, col + 1, visited);\n    dfsVisitIsland(grid, row, col - 1, visited);\n}\n"})}),"\n",(0,t.jsx)(i.h3,{id:"22-max-area-of-island",children:"2.2 Max Area of Island"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:"int maxAreaOfIsland(int[][] grid) {\n    int maxArea = 0;\n\n    for (int i = 0; i < grid.length; i++) {\n        for (int j = 0; j < grid[0].length; j++) {\n            if (grid[i][j] == 1) {\n                maxArea = Math.max(maxArea, dfsAreaCalculation(grid, i, j));\n            }\n        }\n    }\n\n    return maxArea;\n}\n\nint dfsAreaCalculation(int[][] grid, int row, int col) {\n    if (row < 0 || row >= grid.length ||\n        col < 0 || col >= grid[0].length ||\n        grid[row][col] != 1) {\n        return 0;\n    }\n\n    grid[row][col] = 0; // Mark as visited\n\n    return 1 + dfsAreaCalculation(grid, row + 1, col) +\n               dfsAreaCalculation(grid, row - 1, col) +\n               dfsAreaCalculation(grid, row, col + 1) +\n               dfsAreaCalculation(grid, row, col - 1);\n}\n\n// BFS version for area calculation\nint maxAreaOfIslandBFS(int[][] grid) {\n    int maxArea = 0;\n    boolean[][] visited = new boolean[grid.length][grid[0].length];\n\n    for (int i = 0; i < grid.length; i++) {\n        for (int j = 0; j < grid[0].length; j++) {\n            if (grid[i][j] == 1 && !visited[i][j]) {\n                maxArea = Math.max(maxArea, bfsAreaCalculation(grid, i, j, visited));\n            }\n        }\n    }\n\n    return maxArea;\n}\n\nint bfsAreaCalculation(int[][] grid, int startRow, int startCol, boolean[][] visited) {\n    Queue<int[]> queue = new LinkedList<>();\n    queue.offer(new int[]{startRow, startCol});\n    visited[startRow][startCol] = true;\n\n    int area = 0;\n\n    while (!queue.isEmpty()) {\n        int[] current = queue.poll();\n        int row = current[0], col = current[1];\n        area++;\n\n        for (int[] dir : directions4) {\n            int newRow = row + dir[0];\n            int newCol = col + dir[1];\n\n            if (isValid(grid, newRow, newCol) &&\n                !visited[newRow][newCol] &&\n                grid[newRow][newCol] == 1) {\n\n                visited[newRow][newCol] = true;\n                queue.offer(new int[]{newRow, newCol});\n            }\n        }\n    }\n\n    return area;\n}\n"})}),"\n",(0,t.jsx)(i.h3,{id:"23-island-perimeter",children:"2.3 Island Perimeter"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:"int islandPerimeter(int[][] grid) {\n    int perimeter = 0;\n\n    for (int i = 0; i < grid.length; i++) {\n        for (int j = 0; j < grid[0].length; j++) {\n            if (grid[i][j] == 1) {\n                perimeter += 4; // Each land cell contributes 4 sides\n\n                // Subtract shared edges with adjacent land cells\n                if (i > 0 && grid[i - 1][j] == 1) perimeter--;\n                if (i < grid.length - 1 && grid[i + 1][j] == 1) perimeter--;\n                if (j > 0 && grid[i][j - 1] == 1) perimeter--;\n                if (j < grid[0].length - 1 && grid[i][j + 1] == 1) perimeter--;\n            }\n        }\n    }\n\n    return perimeter;\n}\n\n// Alternative approach - count water/boundary neighbors\nint islandPerimeterAlt(int[][] grid) {\n    int perimeter = 0;\n\n    for (int i = 0; i < grid.length; i++) {\n        for (int j = 0; j < grid[0].length; j++) {\n            if (grid[i][j] == 1) {\n                // Check all 4 directions\n                for (int[] dir : directions4) {\n                    int newRow = i + dir[0];\n                    int newCol = j + dir[1];\n\n                    // Count if neighbor is water or out of bounds\n                    if (!isValid(grid, newRow, newCol) || grid[newRow][newCol] == 0) {\n                        perimeter++;\n                    }\n                }\n            }\n        }\n    }\n\n    return perimeter;\n}\n"})}),"\n",(0,t.jsx)(i.h3,{id:"24-number-of-distinct-islands",children:"2.4 Number of Distinct Islands"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:"int numDistinctIslands(int[][] grid) {\n    Set<String> distinctShapes = new HashSet<>();\n    boolean[][] visited = new boolean[grid.length][grid[0].length];\n\n    for (int i = 0; i < grid.length; i++) {\n        for (int j = 0; j < grid[0].length; j++) {\n            if (grid[i][j] == 1 && !visited[i][j]) {\n                StringBuilder shape = new StringBuilder();\n                dfsGetShape(grid, i, j, i, j, visited, shape);\n                distinctShapes.add(shape.toString());\n            }\n        }\n    }\n\n    return distinctShapes.size();\n}\n\nvoid dfsGetShape(int[][] grid, int row, int col, int baseRow, int baseCol,\n                boolean[][] visited, StringBuilder shape) {\n    if (row < 0 || row >= grid.length ||\n        col < 0 || col >= grid[0].length ||\n        visited[row][col] || grid[row][col] != 1) {\n        return;\n    }\n\n    visited[row][col] = true;\n    shape.append(row - baseRow).append(\",\").append(col - baseCol).append(\";\");\n\n    dfsGetShape(grid, row + 1, col, baseRow, baseCol, visited, shape);\n    dfsGetShape(grid, row - 1, col, baseRow, baseCol, visited, shape);\n    dfsGetShape(grid, row, col + 1, baseRow, baseCol, visited, shape);\n    dfsGetShape(grid, row, col - 1, baseRow, baseCol, visited, shape);\n}\n\n// Alternative with direction encoding\nint numDistinctIslandsDirection(int[][] grid) {\n    Set<String> shapes = new HashSet<>();\n    boolean[][] visited = new boolean[grid.length][grid[0].length];\n\n    for (int i = 0; i < grid.length; i++) {\n        for (int j = 0; j < grid[0].length; j++) {\n            if (grid[i][j] == 1 && !visited[i][j]) {\n                StringBuilder shape = new StringBuilder();\n                dfsGetShapeDirection(grid, i, j, visited, shape, 'S'); // Start\n                shapes.add(shape.toString());\n            }\n        }\n    }\n\n    return shapes.size();\n}\n\nvoid dfsGetShapeDirection(int[][] grid, int row, int col, boolean[][] visited,\n                         StringBuilder shape, char direction) {\n    if (row < 0 || row >= grid.length ||\n        col < 0 || col >= grid[0].length ||\n        visited[row][col] || grid[row][col] != 1) {\n        return;\n    }\n\n    visited[row][col] = true;\n    shape.append(direction);\n\n    dfsGetShapeDirection(grid, row + 1, col, visited, shape, 'D'); // Down\n    dfsGetShapeDirection(grid, row - 1, col, visited, shape, 'U'); // Up\n    dfsGetShapeDirection(grid, row, col + 1, visited, shape, 'R'); // Right\n    dfsGetShapeDirection(grid, row, col - 1, visited, shape, 'L'); // Left\n\n    shape.append('B'); // Back (for proper encoding)\n}\n"})}),"\n",(0,t.jsx)(i.hr,{}),"\n",(0,t.jsx)(i.h2,{id:"pattern-3-path-finding",children:"Pattern 3: Path Finding"}),"\n",(0,t.jsx)(i.h3,{id:"31-shortest-path-in-binary-matrix",children:"3.1 Shortest Path in Binary Matrix"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:"int shortestPathBinaryMatrix(int[][] grid) {\n    int n = grid.length;\n    if (grid[0][0] != 0 || grid[n-1][n-1] != 0) return -1;\n\n    Queue<int[]> queue = new LinkedList<>();\n    boolean[][] visited = new boolean[n][n];\n\n    queue.offer(new int[]{0, 0, 1}); // row, col, distance\n    visited[0][0] = true;\n\n    while (!queue.isEmpty()) {\n        int[] current = queue.poll();\n        int row = current[0], col = current[1], dist = current[2];\n\n        if (row == n-1 && col == n-1) return dist;\n\n        // Check all 8 directions\n        for (int[] dir : directions8) {\n            int newRow = row + dir[0];\n            int newCol = col + dir[1];\n\n            if (isValid(grid, newRow, newCol) &&\n                !visited[newRow][newCol] &&\n                grid[newRow][newCol] == 0) {\n\n                visited[newRow][newCol] = true;\n                queue.offer(new int[]{newRow, newCol, dist + 1});\n            }\n        }\n    }\n\n    return -1;\n}\n\n// With path reconstruction\nList<int[]> shortestPathWithRoute(int[][] grid) {\n    int n = grid.length;\n    if (grid[0][0] != 0 || grid[n-1][n-1] != 0) return new ArrayList<>();\n\n    Queue<int[]> queue = new LinkedList<>();\n    int[][][] parent = new int[n][n][2];\n    boolean[][] visited = new boolean[n][n];\n\n    queue.offer(new int[]{0, 0});\n    visited[0][0] = true;\n    parent[0][0] = new int[]{-1, -1}; // No parent for start\n\n    while (!queue.isEmpty()) {\n        int[] current = queue.poll();\n        int row = current[0], col = current[1];\n\n        if (row == n-1 && col == n-1) {\n            return reconstructPath(parent, n-1, n-1);\n        }\n\n        for (int[] dir : directions8) {\n            int newRow = row + dir[0];\n            int newCol = col + dir[1];\n\n            if (isValid(grid, newRow, newCol) &&\n                !visited[newRow][newCol] &&\n                grid[newRow][newCol] == 0) {\n\n                visited[newRow][newCol] = true;\n                parent[newRow][newCol] = new int[]{row, col};\n                queue.offer(new int[]{newRow, newCol});\n            }\n        }\n    }\n\n    return new ArrayList<>();\n}\n\nList<int[]> reconstructPath(int[][][] parent, int endRow, int endCol) {\n    List<int[]> path = new ArrayList<>();\n    int row = endRow, col = endCol;\n\n    while (row != -1 && col != -1) {\n        path.add(new int[]{row, col});\n        int[] p = parent[row][col];\n        row = p[0];\n        col = p[1];\n    }\n\n    Collections.reverse(path);\n    return path;\n}\n"})}),"\n",(0,t.jsx)(i.h3,{id:"32-path-with-minimum-effort",children:"3.2 Path with Minimum Effort"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:"int minimumEffortPath(int[][] heights) {\n    int m = heights.length, n = heights[0].length;\n    int[][] effort = new int[m][n];\n\n    // Initialize with max values\n    for (int[] row : effort) {\n        Arrays.fill(row, Integer.MAX_VALUE);\n    }\n\n    // Priority queue: {effort, row, col}\n    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);\n    pq.offer(new int[]{0, 0, 0});\n    effort[0][0] = 0;\n\n    while (!pq.isEmpty()) {\n        int[] current = pq.poll();\n        int currentEffort = current[0];\n        int row = current[1], col = current[2];\n\n        if (row == m-1 && col == n-1) return currentEffort;\n\n        if (currentEffort > effort[row][col]) continue;\n\n        for (int[] dir : directions4) {\n            int newRow = row + dir[0];\n            int newCol = col + dir[1];\n\n            if (isValid(heights, newRow, newCol)) {\n                int newEffort = Math.max(currentEffort,\n                    Math.abs(heights[newRow][newCol] - heights[row][col]));\n\n                if (newEffort < effort[newRow][newCol]) {\n                    effort[newRow][newCol] = newEffort;\n                    pq.offer(new int[]{newEffort, newRow, newCol});\n                }\n            }\n        }\n    }\n\n    return effort[m-1][n-1];\n}\n\n// Binary search approach\nint minimumEffortPathBinarySearch(int[][] heights) {\n    int left = 0, right = 1000000;\n\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n\n        if (canReachWithEffort(heights, mid)) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n\n    return left;\n}\n\nboolean canReachWithEffort(int[][] heights, int maxEffort) {\n    int m = heights.length, n = heights[0].length;\n    boolean[][] visited = new boolean[m][n];\n\n    return dfsEffortCheck(heights, 0, 0, m-1, n-1, maxEffort, visited);\n}\n\nboolean dfsEffortCheck(int[][] heights, int row, int col, int targetRow, int targetCol,\n                      int maxEffort, boolean[][] visited) {\n    if (row == targetRow && col == targetCol) return true;\n\n    visited[row][col] = true;\n\n    for (int[] dir : directions4) {\n        int newRow = row + dir[0];\n        int newCol = col + dir[1];\n\n        if (isValid(heights, newRow, newCol) && !visited[newRow][newCol]) {\n            int effort = Math.abs(heights[newRow][newCol] - heights[row][col]);\n\n            if (effort <= maxEffort &&\n                dfsEffortCheck(heights, newRow, newCol, targetRow, targetCol, maxEffort, visited)) {\n                return true;\n            }\n        }\n    }\n\n    visited[row][col] = false; // Backtrack for other paths\n    return false;\n}\n"})}),"\n",(0,t.jsx)(i.h3,{id:"33-unique-paths-with-obstacles",children:"3.3 Unique Paths with Obstacles"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:"int uniquePathsWithObstacles(int[][] obstacleGrid) {\n    int m = obstacleGrid.length, n = obstacleGrid[0].length;\n\n    if (obstacleGrid[0][0] == 1 || obstacleGrid[m-1][n-1] == 1) return 0;\n\n    int[][] dp = new int[m][n];\n    dp[0][0] = 1;\n\n    // Fill first row\n    for (int j = 1; j < n; j++) {\n        dp[0][j] = obstacleGrid[0][j] == 1 ? 0 : dp[0][j-1];\n    }\n\n    // Fill first column\n    for (int i = 1; i < m; i++) {\n        dp[i][0] = obstacleGrid[i][0] == 1 ? 0 : dp[i-1][0];\n    }\n\n    // Fill the rest\n    for (int i = 1; i < m; i++) {\n        for (int j = 1; j < n; j++) {\n            if (obstacleGrid[i][j] == 1) {\n                dp[i][j] = 0;\n            } else {\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\n            }\n        }\n    }\n\n    return dp[m-1][n-1];\n}\n\n// Space optimized\nint uniquePathsWithObstaclesOptimized(int[][] obstacleGrid) {\n    int n = obstacleGrid[0].length;\n    int[] dp = new int[n];\n\n    dp[0] = obstacleGrid[0][0] == 1 ? 0 : 1;\n\n    for (int i = 0; i < obstacleGrid.length; i++) {\n        for (int j = 0; j < n; j++) {\n            if (obstacleGrid[i][j] == 1) {\n                dp[j] = 0;\n            } else if (j > 0) {\n                dp[j] += dp[j-1];\n            }\n        }\n    }\n\n    return dp[n-1];\n}\n"})}),"\n",(0,t.jsx)(i.hr,{}),"\n",(0,t.jsx)(i.h2,{id:"pattern-4-flood-fill--coloring",children:"Pattern 4: Flood Fill & Coloring"}),"\n",(0,t.jsx)(i.h3,{id:"41-classic-flood-fill",children:"4.1 Classic Flood Fill"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:"int[][] floodFill(int[][] image, int sr, int sc, int color) {\n    int originalColor = image[sr][sc];\n    if (originalColor != color) {\n        dfsFloodFill(image, sr, sc, originalColor, color);\n    }\n    return image;\n}\n\nvoid dfsFloodFill(int[][] image, int row, int col, int originalColor, int newColor) {\n    if (row < 0 || row >= image.length ||\n        col < 0 || col >= image[0].length ||\n        image[row][col] != originalColor) {\n        return;\n    }\n\n    image[row][col] = newColor;\n\n    dfsFloodFill(image, row + 1, col, originalColor, newColor);\n    dfsFloodFill(image, row - 1, col, originalColor, newColor);\n    dfsFloodFill(image, row, col + 1, originalColor, newColor);\n    dfsFloodFill(image, row, col - 1, originalColor, newColor);\n}\n\n// BFS version\nint[][] floodFillBFS(int[][] image, int sr, int sc, int color) {\n    int originalColor = image[sr][sc];\n    if (originalColor == color) return image;\n\n    Queue<int[]> queue = new LinkedList<>();\n    queue.offer(new int[]{sr, sc});\n\n    while (!queue.isEmpty()) {\n        int[] current = queue.poll();\n        int row = current[0], col = current[1];\n\n        if (row < 0 || row >= image.length ||\n            col < 0 || col >= image[0].length ||\n            image[row][col] != originalColor) {\n            continue;\n        }\n\n        image[row][col] = color;\n\n        queue.offer(new int[]{row + 1, col});\n        queue.offer(new int[]{row - 1, col});\n        queue.offer(new int[]{row, col + 1});\n        queue.offer(new int[]{row, col - 1});\n    }\n\n    return image;\n}\n"})}),"\n",(0,t.jsx)(i.h3,{id:"42-surrounded-regions",children:"4.2 Surrounded Regions"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:"void solve(char[][] board) {\n    if (board.length == 0) return;\n\n    int m = board.length, n = board[0].length;\n\n    // Mark boundary-connected 'O's as safe\n    for (int i = 0; i < m; i++) {\n        if (board[i][0] == 'O') dfsSafeRegion(board, i, 0);\n        if (board[i][n-1] == 'O') dfsSafeRegion(board, i, n-1);\n    }\n\n    for (int j = 0; j < n; j++) {\n        if (board[0][j] == 'O') dfsSafeRegion(board, 0, j);\n        if (board[m-1][j] == 'O') dfsSafeRegion(board, m-1, j);\n    }\n\n    // Convert remaining 'O' to 'X' and restore safe regions\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (board[i][j] == 'O') {\n                board[i][j] = 'X';\n            } else if (board[i][j] == 'S') {\n                board[i][j] = 'O';\n            }\n        }\n    }\n}\n\nvoid dfsSafeRegion(char[][] board, int row, int col) {\n    if (row < 0 || row >= board.length ||\n        col < 0 || col >= board[0].length ||\n        board[row][col] != 'O') {\n        return;\n    }\n\n    board[row][col] = 'S'; // Mark as safe\n\n    dfsSafeRegion(board, row + 1, col);\n    dfsSafeRegion(board, row - 1, col);\n    dfsSafeRegion(board, row, col + 1);\n    dfsSafeRegion(board, row, col - 1);\n}\n"})}),"\n",(0,t.jsx)(i.h3,{id:"43-pacific-atlantic-water-flow",children:"4.3 Pacific Atlantic Water Flow"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:"List<List<Integer>> pacificAtlantic(int[][] heights) {\n    int m = heights.length, n = heights[0].length;\n    boolean[][] pacific = new boolean[m][n];\n    boolean[][] atlantic = new boolean[m][n];\n\n    // Start from Pacific edges (top and left)\n    for (int i = 0; i < m; i++) {\n        dfsWaterFlow(heights, i, 0, pacific, heights[i][0]);\n    }\n    for (int j = 0; j < n; j++) {\n        dfsWaterFlow(heights, 0, j, pacific, heights[0][j]);\n    }\n\n    // Start from Atlantic edges (bottom and right)\n    for (int i = 0; i < m; i++) {\n        dfsWaterFlow(heights, i, n-1, atlantic, heights[i][n-1]);\n    }\n    for (int j = 0; j < n; j++) {\n        dfsWaterFlow(heights, m-1, j, atlantic, heights[m-1][j]);\n    }\n\n    // Find cells reachable by both oceans\n    List<List<Integer>> result = new ArrayList<>();\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (pacific[i][j] && atlantic[i][j]) {\n                result.add(Arrays.asList(i, j));\n            }\n        }\n    }\n\n    return result;\n}\n\nvoid dfsWaterFlow(int[][] heights, int row, int col, boolean[][] visited, int prevHeight) {\n    if (row < 0 || row >= heights.length ||\n        col < 0 || col >= heights[0].length ||\n        visited[row][col] ||\n        heights[row][col] < prevHeight) {\n        return;\n    }\n\n    visited[row][col] = true;\n\n    for (int[] dir : directions4) {\n        dfsWaterFlow(heights, row + dir[0], col + dir[1], visited, heights[row][col]);\n    }\n}\n"})}),"\n",(0,t.jsx)(i.hr,{}),"\n",(0,t.jsx)(i.h2,{id:"pattern-5-grid-validation--constraints",children:"Pattern 5: Grid Validation & Constraints"}),"\n",(0,t.jsx)(i.h3,{id:"51-valid-sudoku",children:"5.1 Valid Sudoku"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:'boolean isValidSudoku(char[][] board) {\n    Set<String> seen = new HashSet<>();\n\n    for (int i = 0; i < 9; i++) {\n        for (int j = 0; j < 9; j++) {\n            char value = board[i][j];\n            if (value != \'.\') {\n                // Check if value already exists in row, column, or box\n                if (!seen.add(value + " in row " + i) ||\n                    !seen.add(value + " in col " + j) ||\n                    !seen.add(value + " in box " + i/3 + "-" + j/3)) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    return true;\n}\n\n// Alternative approach with separate validation\nboolean isValidSudokuAlt(char[][] board) {\n    // Validate rows\n    for (int i = 0; i < 9; i++) {\n        if (!isValidUnit(board[i])) return false;\n    }\n\n    // Validate columns\n    for (int j = 0; j < 9; j++) {\n        char[] column = new char[9];\n        for (int i = 0; i < 9; i++) {\n            column[i] = board[i][j];\n        }\n        if (!isValidUnit(column)) return false;\n    }\n\n    // Validate 3x3 boxes\n    for (int box = 0; box < 9; box++) {\n        char[] boxArray = new char[9];\n        int idx = 0;\n        int startRow = (box / 3) * 3;\n        int startCol = (box % 3) * 3;\n\n        for (int i = startRow; i < startRow + 3; i++) {\n            for (int j = startCol; j < startCol + 3; j++) {\n                boxArray[idx++] = board[i][j];\n            }\n        }\n        if (!isValidUnit(boxArray)) return false;\n    }\n\n    return true;\n}\n\nboolean isValidUnit(char[] unit) {\n    Set<Character> seen = new HashSet<>();\n    for (char ch : unit) {\n        if (ch != \'.\' && !seen.add(ch)) {\n            return false;\n        }\n    }\n    return true;\n}\n'})}),"\n",(0,t.jsx)(i.h3,{id:"52-word-search",children:"5.2 Word Search"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:"boolean exist(char[][] board, String word) {\n    for (int i = 0; i < board.length; i++) {\n        for (int j = 0; j < board[0].length; j++) {\n            if (dfsWordSearch(board, word, i, j, 0)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nboolean dfsWordSearch(char[][] board, String word, int row, int col, int index) {\n    if (index == word.length()) return true;\n\n    if (row < 0 || row >= board.length ||\n        col < 0 || col >= board[0].length ||\n        board[row][col] != word.charAt(index)) {\n        return false;\n    }\n\n    char temp = board[row][col];\n    board[row][col] = '#'; // Mark as visited\n\n    boolean found = dfsWordSearch(board, word, row + 1, col, index + 1) ||\n                   dfsWordSearch(board, word, row - 1, col, index + 1) ||\n                   dfsWordSearch(board, word, row, col + 1, index + 1) ||\n                   dfsWordSearch(board, word, row, col - 1, index + 1);\n\n    board[row][col] = temp; // Restore\n    return found;\n}\n\n// Word Search II (Multiple words)\nList<String> findWords(char[][] board, String[] words) {\n    TrieNode root = buildTrie(words);\n    List<String> result = new ArrayList<>();\n\n    for (int i = 0; i < board.length; i++) {\n        for (int j = 0; j < board[0].length; j++) {\n            dfsTrieSearch(board, i, j, root, result);\n        }\n    }\n\n    return result;\n}\n\nclass TrieNode {\n    TrieNode[] children = new TrieNode[26];\n    String word;\n}\n\nTrieNode buildTrie(String[] words) {\n    TrieNode root = new TrieNode();\n    for (String word : words) {\n        TrieNode curr = root;\n        for (char c : word.toCharArray()) {\n            int index = c - 'a';\n            if (curr.children[index] == null) {\n                curr.children[index] = new TrieNode();\n            }\n            curr = curr.children[index];\n        }\n        curr.word = word;\n    }\n    return root;\n}\n\nvoid dfsTrieSearch(char[][] board, int row, int col, TrieNode node, List<String> result) {\n    if (row < 0 || row >= board.length || col < 0 || col >= board[0].length) return;\n\n    char c = board[row][col];\n    if (c == '#' || node.children[c - 'a'] == null) return;\n\n    node = node.children[c - 'a'];\n    if (node.word != null) {\n        result.add(node.word);\n        node.word = null; // Avoid duplicates\n    }\n\n    board[row][col] = '#';\n    for (int[] dir : directions4) {\n        dfsTrieSearch(board, row + dir[0], col + dir[1], node, result);\n    }\n    board[row][col] = c;\n}\n"})}),"\n",(0,t.jsx)(i.hr,{}),"\n",(0,t.jsx)(i.h2,{id:"pattern-6-multi-source-bfs",children:"Pattern 6: Multi-Source BFS"}),"\n",(0,t.jsx)(i.h3,{id:"61-rotting-oranges",children:"6.1 Rotting Oranges"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:"int orangesRotting(int[][] grid) {\n    Queue<int[]> queue = new LinkedList<>();\n    int freshCount = 0;\n\n    // Find all initially rotten oranges and count fresh ones\n    for (int i = 0; i < grid.length; i++) {\n        for (int j = 0; j < grid[0].length; j++) {\n            if (grid[i][j] == 2) {\n                queue.offer(new int[]{i, j});\n            } else if (grid[i][j] == 1) {\n                freshCount++;\n            }\n        }\n    }\n\n    if (freshCount == 0) return 0; // No fresh oranges\n\n    int minutes = 0;\n\n    while (!queue.isEmpty() && freshCount > 0) {\n        int size = queue.size();\n\n        for (int i = 0; i < size; i++) {\n            int[] current = queue.poll();\n            int row = current[0], col = current[1];\n\n            for (int[] dir : directions4) {\n                int newRow = row + dir[0];\n                int newCol = col + dir[1];\n\n                if (isValid(grid, newRow, newCol) && grid[newRow][newCol] == 1) {\n                    grid[newRow][newCol] = 2; // Rot the orange\n                    freshCount--;\n                    queue.offer(new int[]{newRow, newCol});\n                }\n            }\n        }\n\n        minutes++;\n    }\n\n    return freshCount == 0 ? minutes : -1;\n}\n"})}),"\n",(0,t.jsx)(i.h3,{id:"62-walls-and-gates",children:"6.2 Walls and Gates"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:"void wallsAndGates(int[][] rooms) {\n    Queue<int[]> queue = new LinkedList<>();\n\n    // Find all gates\n    for (int i = 0; i < rooms.length; i++) {\n        for (int j = 0; j < rooms[0].length; j++) {\n            if (rooms[i][j] == 0) {\n                queue.offer(new int[]{i, j});\n            }\n        }\n    }\n\n    while (!queue.isEmpty()) {\n        int[] current = queue.poll();\n        int row = current[0], col = current[1];\n\n        for (int[] dir : directions4) {\n            int newRow = row + dir[0];\n            int newCol = col + dir[1];\n\n            if (isValid(rooms, newRow, newCol) &&\n                rooms[newRow][newCol] == Integer.MAX_VALUE) {\n\n                rooms[newRow][newCol] = rooms[row][col] + 1;\n                queue.offer(new int[]{newRow, newCol});\n            }\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(i.h3,{id:"63-01-matrix-distance-to-nearest-0",children:"6.3 01 Matrix (Distance to Nearest 0)"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:"int[][] updateMatrix(int[][] mat) {\n    int m = mat.length, n = mat[0].length;\n    Queue<int[]> queue = new LinkedList<>();\n\n    // Initialize distances and find all 0s\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (mat[i][j] == 0) {\n                queue.offer(new int[]{i, j});\n            } else {\n                mat[i][j] = Integer.MAX_VALUE;\n            }\n        }\n    }\n\n    while (!queue.isEmpty()) {\n        int[] current = queue.poll();\n        int row = current[0], col = current[1];\n\n        for (int[] dir : directions4) {\n            int newRow = row + dir[0];\n            int newCol = col + dir[1];\n\n            if (isValid(mat, newRow, newCol) &&\n                mat[newRow][newCol] > mat[row][col] + 1) {\n\n                mat[newRow][newCol] = mat[row][col] + 1;\n                queue.offer(new int[]{newRow, newCol});\n            }\n        }\n    }\n\n    return mat;\n}\n\n// DP approach (alternative)\nint[][] updateMatrixDP(int[][] mat) {\n    int m = mat.length, n = mat[0].length;\n    int INF = m + n; // Maximum possible distance\n\n    // Initialize\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (mat[i][j] != 0) {\n                mat[i][j] = INF;\n            }\n        }\n    }\n\n    // Top-left to bottom-right\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i > 0) mat[i][j] = Math.min(mat[i][j], mat[i-1][j] + 1);\n            if (j > 0) mat[i][j] = Math.min(mat[i][j], mat[i][j-1] + 1);\n        }\n    }\n\n    // Bottom-right to top-left\n    for (int i = m-1; i >= 0; i--) {\n        for (int j = n-1; j >= 0; j--) {\n            if (i < m-1) mat[i][j] = Math.min(mat[i][j], mat[i+1][j] + 1);\n            if (j < n-1) mat[i][j] = Math.min(mat[i][j], mat[i][j+1] + 1);\n        }\n    }\n\n    return mat;\n}\n"})}),"\n",(0,t.jsx)(i.hr,{}),"\n",(0,t.jsx)(i.h2,{id:"pattern-7-grid-dp--optimization",children:"Pattern 7: Grid DP & Optimization"}),"\n",(0,t.jsx)(i.h3,{id:"71-minimum-path-sum",children:"7.1 Minimum Path Sum"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:"int minPathSum(int[][] grid) {\n    int m = grid.length, n = grid[0].length;\n\n    // Initialize first row\n    for (int j = 1; j < n; j++) {\n        grid[0][j] += grid[0][j-1];\n    }\n\n    // Initialize first column\n    for (int i = 1; i < m; i++) {\n        grid[i][0] += grid[i-1][0];\n    }\n\n    // Fill the rest\n    for (int i = 1; i < m; i++) {\n        for (int j = 1; j < n; j++) {\n            grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);\n        }\n    }\n\n    return grid[m-1][n-1];\n}\n\n// Without modifying input\nint minPathSumPreserve(int[][] grid) {\n    int m = grid.length, n = grid[0].length;\n    int[][] dp = new int[m][n];\n\n    dp[0][0] = grid[0][0];\n\n    // First row\n    for (int j = 1; j < n; j++) {\n        dp[0][j] = dp[0][j-1] + grid[0][j];\n    }\n\n    // First column\n    for (int i = 1; i < m; i++) {\n        dp[i][0] = dp[i-1][0] + grid[i][0];\n    }\n\n    // Fill remaining cells\n    for (int i = 1; i < m; i++) {\n        for (int j = 1; j < n; j++) {\n            dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\n        }\n    }\n\n    return dp[m-1][n-1];\n}\n"})}),"\n",(0,t.jsx)(i.h3,{id:"72-maximum-gold-collection",children:"7.2 Maximum Gold Collection"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:'int getMaximumGold(int[][] grid) {\n    int maxGold = 0;\n\n    for (int i = 0; i < grid.length; i++) {\n        for (int j = 0; j < grid[0].length; j++) {\n            if (grid[i][j] != 0) {\n                maxGold = Math.max(maxGold, dfsGoldCollection(grid, i, j));\n            }\n        }\n    }\n\n    return maxGold;\n}\n\nint dfsGoldCollection(int[][] grid, int row, int col) {\n    if (row < 0 || row >= grid.length ||\n        col < 0 || col >= grid[0].length ||\n        grid[row][col] == 0) {\n        return 0;\n    }\n\n    int gold = grid[row][col];\n    grid[row][col] = 0; // Mark as visited\n\n    int maxPath = 0;\n    for (int[] dir : directions4) {\n        maxPath = Math.max(maxPath,\n            dfsGoldCollection(grid, row + dir[0], col + dir[1]));\n    }\n\n    grid[row][col] = gold; // Backtrack\n    return gold + maxPath;\n}\n\n// With memoization (if grid doesn\'t change)\nMap<String, Integer> memo = new HashMap<>();\n\nint getMaximumGoldMemo(int[][] grid) {\n    int maxGold = 0;\n\n    for (int i = 0; i < grid.length; i++) {\n        for (int j = 0; j < grid[0].length; j++) {\n            if (grid[i][j] != 0) {\n                boolean[][] visited = new boolean[grid.length][grid[0].length];\n                maxGold = Math.max(maxGold, dfsGoldMemo(grid, i, j, visited));\n            }\n        }\n    }\n\n    return maxGold;\n}\n\nint dfsGoldMemo(int[][] grid, int row, int col, boolean[][] visited) {\n    if (row < 0 || row >= grid.length ||\n        col < 0 || col >= grid[0].length ||\n        grid[row][col] == 0 || visited[row][col]) {\n        return 0;\n    }\n\n    String key = row + "," + col + "," + Arrays.deepToString(visited);\n    if (memo.containsKey(key)) return memo.get(key);\n\n    visited[row][col] = true;\n    int maxPath = 0;\n\n    for (int[] dir : directions4) {\n        maxPath = Math.max(maxPath,\n            dfsGoldMemo(grid, row + dir[0], col + dir[1], visited));\n    }\n\n    visited[row][col] = false;\n    int result = grid[row][col] + maxPath;\n    memo.put(key, result);\n    return result;\n}\n'})}),"\n",(0,t.jsx)(i.hr,{}),"\n",(0,t.jsx)(i.h2,{id:"pattern-8-binary-matrix-problems",children:"Pattern 8: Binary Matrix Problems"}),"\n",(0,t.jsx)(i.h3,{id:"81-largest-rectangle-in-binary-matrix",children:"8.1 Largest Rectangle in Binary Matrix"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:"int maximalRectangle(char[][] matrix) {\n    if (matrix.length == 0) return 0;\n\n    int n = matrix[0].length;\n    int[] heights = new int[n];\n    int maxArea = 0;\n\n    for (char[] row : matrix) {\n        // Update heights array\n        for (int j = 0; j < n; j++) {\n            heights[j] = row[j] == '1' ? heights[j] + 1 : 0;\n        }\n\n        // Find max rectangle in histogram\n        maxArea = Math.max(maxArea, largestRectangleArea(heights));\n    }\n\n    return maxArea;\n}\n\nint largestRectangleArea(int[] heights) {\n    Stack<Integer> stack = new Stack<>();\n    int maxArea = 0;\n\n    for (int i = 0; i <= heights.length; i++) {\n        int h = (i == heights.length) ? 0 : heights[i];\n\n        while (!stack.isEmpty() && h < heights[stack.peek()]) {\n            int height = heights[stack.pop()];\n            int width = stack.isEmpty() ? i : i - stack.peek() - 1;\n            maxArea = Math.max(maxArea, height * width);\n        }\n\n        stack.push(i);\n    }\n\n    return maxArea;\n}\n"})}),"\n",(0,t.jsx)(i.h3,{id:"82-count-square-submatrices",children:"8.2 Count Square Submatrices"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:"int countSquares(int[][] matrix) {\n    int m = matrix.length, n = matrix[0].length;\n    int[][] dp = new int[m][n];\n    int count = 0;\n\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (matrix[i][j] == 1) {\n                if (i == 0 || j == 0) {\n                    dp[i][j] = 1;\n                } else {\n                    dp[i][j] = Math.min(Math.min(dp[i-1][j], dp[i][j-1]), dp[i-1][j-1]) + 1;\n                }\n                count += dp[i][j];\n            }\n        }\n    }\n\n    return count;\n}\n\n// Space optimized\nint countSquaresOptimized(int[][] matrix) {\n    int n = matrix[0].length;\n    int[] dp = new int[n];\n    int count = 0, prev = 0;\n\n    for (int[] row : matrix) {\n        for (int j = 0; j < n; j++) {\n            int temp = dp[j];\n\n            if (row[j] == 1) {\n                if (j == 0) {\n                    dp[j] = 1;\n                } else {\n                    dp[j] = Math.min(Math.min(dp[j], dp[j-1]), prev) + 1;\n                }\n                count += dp[j];\n            } else {\n                dp[j] = 0;\n            }\n\n            prev = temp;\n        }\n    }\n\n    return count;\n}\n"})}),"\n",(0,t.jsx)(i.hr,{}),"\n",(0,t.jsx)(i.h2,{id:"pattern-9-grid-transformation",children:"Pattern 9: Grid Transformation"}),"\n",(0,t.jsx)(i.h3,{id:"91-game-of-life",children:"9.1 Game of Life"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:"void gameOfLife(int[][] board) {\n    int m = board.length, n = board[0].length;\n\n    // Use encoding: 0->1 (encoded as 2), 1->0 (encoded as 3)\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            int liveNeighbors = countLiveNeighbors(board, i, j);\n\n            if (board[i][j] == 1) {\n                // Live cell\n                if (liveNeighbors < 2 || liveNeighbors > 3) {\n                    board[i][j] = 3; // Dies\n                }\n            } else {\n                // Dead cell\n                if (liveNeighbors == 3) {\n                    board[i][j] = 2; // Becomes alive\n                }\n            }\n        }\n    }\n\n    // Decode\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (board[i][j] == 2) board[i][j] = 1;\n            else if (board[i][j] == 3) board[i][j] = 0;\n        }\n    }\n}\n\nint countLiveNeighbors(int[][] board, int row, int col) {\n    int count = 0;\n\n    for (int[] dir : directions8) {\n        int newRow = row + dir[0];\n        int newCol = col + dir[1];\n\n        if (isValid(board, newRow, newCol)) {\n            // Count original live cells (1 or 3)\n            if (board[newRow][newCol] == 1 || board[newRow][newCol] == 3) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n"})}),"\n",(0,t.jsx)(i.h3,{id:"92-set-matrix-zeroes",children:"9.2 Set Matrix Zeroes"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:"void setZeroes(int[][] matrix) {\n    int m = matrix.length, n = matrix[0].length;\n    boolean firstRowZero = false, firstColZero = false;\n\n    // Check if first row should be zero\n    for (int j = 0; j < n; j++) {\n        if (matrix[0][j] == 0) {\n            firstRowZero = true;\n            break;\n        }\n    }\n\n    // Check if first column should be zero\n    for (int i = 0; i < m; i++) {\n        if (matrix[i][0] == 0) {\n            firstColZero = true;\n            break;\n        }\n    }\n\n    // Use first row and column as markers\n    for (int i = 1; i < m; i++) {\n        for (int j = 1; j < n; j++) {\n            if (matrix[i][j] == 0) {\n                matrix[i][0] = 0;\n                matrix[0][j] = 0;\n            }\n        }\n    }\n\n    // Set zeros based on markers\n    for (int i = 1; i < m; i++) {\n        for (int j = 1; j < n; j++) {\n            if (matrix[i][0] == 0 || matrix[0][j] == 0) {\n                matrix[i][j] = 0;\n            }\n        }\n    }\n\n    // Handle first row and column\n    if (firstRowZero) {\n        for (int j = 0; j < n; j++) {\n            matrix[0][j] = 0;\n        }\n    }\n\n    if (firstColZero) {\n        for (int i = 0; i < m; i++) {\n            matrix[i][0] = 0;\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(i.hr,{}),"\n",(0,t.jsx)(i.h2,{id:"pattern-10-pattern-matching-in-grids",children:"Pattern 10: Pattern Matching in Grids"}),"\n",(0,t.jsx)(i.h3,{id:"101-word-search-in-grid",children:"10.1 Word Search in Grid"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:"// Already covered in Pattern 5.2, but here's an optimized version\nboolean existOptimized(char[][] board, String word) {\n    // Early termination: count characters\n    int[] boardCount = new int[128];\n    for (char[] row : board) {\n        for (char c : row) {\n            boardCount[c]++;\n        }\n    }\n\n    int[] wordCount = new int[128];\n    for (char c : word.toCharArray()) {\n        wordCount[c]++;\n        if (wordCount[c] > boardCount[c]) {\n            return false; // Not enough characters in board\n        }\n    }\n\n    // Start from less frequent character end if beneficial\n    if (boardCount[word.charAt(0)] > boardCount[word.charAt(word.length()-1)]) {\n        return existReverse(board, new StringBuilder(word).reverse().toString());\n    }\n\n    for (int i = 0; i < board.length; i++) {\n        for (int j = 0; j < board[0].length; j++) {\n            if (dfsWordSearch(board, word, i, j, 0)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nboolean existReverse(char[][] board, String word) {\n    for (int i = 0; i < board.length; i++) {\n        for (int j = 0; j < board[0].length; j++) {\n            if (dfsWordSearch(board, word, i, j, 0)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n"})}),"\n",(0,t.jsx)(i.h3,{id:"102-count-paths-in-grid",children:"10.2 Count Paths in Grid"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:"// Count all paths from top-left to bottom-right\nint uniquePaths(int m, int n) {\n    int[][] dp = new int[m][n];\n\n    // Initialize first row and column\n    for (int i = 0; i < m; i++) dp[i][0] = 1;\n    for (int j = 0; j < n; j++) dp[0][j] = 1;\n\n    for (int i = 1; i < m; i++) {\n        for (int j = 1; j < n; j++) {\n            dp[i][j] = dp[i-1][j] + dp[i][j-1];\n        }\n    }\n\n    return dp[m-1][n-1];\n}\n\n// Count paths with obstacles\nint uniquePathsWithObstacles(int[][] obstacleGrid) {\n    int m = obstacleGrid.length, n = obstacleGrid[0].length;\n    if (obstacleGrid[0][0] == 1) return 0;\n\n    int[][] dp = new int[m][n];\n    dp[0][0] = 1;\n\n    // Fill first column\n    for (int i = 1; i < m; i++) {\n        dp[i][0] = obstacleGrid[i][0] == 1 ? 0 : dp[i-1][0];\n    }\n\n    // Fill first row\n    for (int j = 1; j < n; j++) {\n        dp[0][j] = obstacleGrid[0][j] == 1 ? 0 : dp[0][j-1];\n    }\n\n    // Fill remaining cells\n    for (int i = 1; i < m; i++) {\n        for (int j = 1; j < n; j++) {\n            dp[i][j] = obstacleGrid[i][j] == 1 ? 0 : dp[i-1][j] + dp[i][j-1];\n        }\n    }\n\n    return dp[m-1][n-1];\n}\n"})}),"\n",(0,t.jsx)(i.hr,{}),"\n",(0,t.jsx)(i.h2,{id:"pattern-11-game-board-problems",children:"Pattern 11: Game Board Problems"}),"\n",(0,t.jsx)(i.h3,{id:"111-tic-tac-toe-winner",children:"11.1 Tic-Tac-Toe Winner"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:"class TicTacToe {\n    int[] rows, cols;\n    int diagonal, antiDiagonal;\n    int n;\n\n    public TicTacToe(int n) {\n        this.n = n;\n        rows = new int[n];\n        cols = new int[n];\n    }\n\n    public int move(int row, int col, int player) {\n        int toAdd = player == 1 ? 1 : -1;\n\n        rows[row] += toAdd;\n        cols[col] += toAdd;\n\n        if (row == col) diagonal += toAdd;\n        if (row + col == n - 1) antiDiagonal += toAdd;\n\n        if (Math.abs(rows[row]) == n || Math.abs(cols[col]) == n ||\n            Math.abs(diagonal) == n || Math.abs(antiDiagonal) == n) {\n            return player;\n        }\n\n        return 0;\n    }\n}\n\n// Check winner in completed board\nString tictactoe(int[][] moves) {\n    char[][] board = new char[3][3];\n\n    for (int i = 0; i < moves.length; i++) {\n        int row = moves[i][0], col = moves[i][1];\n        board[row][col] = i % 2 == 0 ? 'X' : 'O';\n    }\n\n    // Check winner\n    char winner = checkWinner(board);\n    if (winner != ' ') return String.valueOf(winner);\n\n    return moves.length == 9 ? \"Draw\" : \"Pending\";\n}\n\nchar checkWinner(char[][] board) {\n    // Check rows and columns\n    for (int i = 0; i < 3; i++) {\n        if (board[i][0] != '\\0' && board[i][0] == board[i][1] && board[i][1] == board[i][2]) {\n            return board[i][0];\n        }\n        if (board[0][i] != '\\0' && board[0][i] == board[1][i] && board[1][i] == board[2][i]) {\n            return board[0][i];\n        }\n    }\n\n    // Check diagonals\n    if (board[0][0] != '\\0' && board[0][0] == board[1][1] && board[1][1] == board[2][2]) {\n        return board[0][0];\n    }\n    if (board[0][2] != '\\0' && board[0][2] == board[1][1] && board[1][1] == board[2][0]) {\n        return board[0][2];\n    }\n\n    return ' ';\n}\n"})}),"\n",(0,t.jsx)(i.h3,{id:"112-valid-battleship-placement",children:"11.2 Valid Battleship Placement"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:"int countBattleships(char[][] board) {\n    int count = 0;\n\n    for (int i = 0; i < board.length; i++) {\n        for (int j = 0; j < board[0].length; j++) {\n            if (board[i][j] == 'X') {\n                // Only count top-left corner of each battleship\n                if ((i == 0 || board[i-1][j] == '.') &&\n                    (j == 0 || board[i][j-1] == '.')) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n\n// Validate battleship placement rules\nboolean isValidBattleshipPlacement(char[][] board) {\n    for (int i = 0; i < board.length; i++) {\n        for (int j = 0; j < board[0].length; j++) {\n            if (board[i][j] == 'X') {\n                if (!isValidBattleshipAt(board, i, j)) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n\nboolean isValidBattleshipAt(char[][] board, int row, int col) {\n    // Check that battleship is either horizontal or vertical, not diagonal\n    boolean hasUp = row > 0 && board[row-1][col] == 'X';\n    boolean hasDown = row < board.length-1 && board[row+1][col] == 'X';\n    boolean hasLeft = col > 0 && board[row][col-1] == 'X';\n    boolean hasRight = col < board[0].length-1 && board[row][col+1] == 'X';\n\n    // Invalid if diagonal connections exist\n    if ((hasUp || hasDown) && (hasLeft || hasRight)) {\n        return false;\n    }\n\n    return true;\n}\n"})}),"\n",(0,t.jsx)(i.hr,{}),"\n",(0,t.jsx)(i.h2,{id:"pattern-12-advanced-grid-problems",children:"Pattern 12: Advanced Grid Problems"}),"\n",(0,t.jsx)(i.h3,{id:"121-robot-room-cleaner",children:"12.1 Robot Room Cleaner"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:'// Interface given\ninterface Robot {\n    boolean move();\n    void turnLeft();\n    void turnRight();\n    void clean();\n}\n\nvoid cleanRoom(Robot robot) {\n    Set<String> visited = new HashSet<>();\n    dfsClean(robot, 0, 0, 0, visited); // Start at (0,0) facing up\n}\n\nvoid dfsClean(Robot robot, int row, int col, int direction, Set<String> visited) {\n    String key = row + "," + col;\n    if (visited.contains(key)) return;\n\n    visited.add(key);\n    robot.clean();\n\n    // Try all 4 directions\n    for (int i = 0; i < 4; i++) {\n        if (robot.move()) {\n            int[] newPos = getNewPosition(row, col, direction);\n            dfsClean(robot, newPos[0], newPos[1], direction, visited);\n\n            // Go back\n            robot.turnLeft();\n            robot.turnLeft();\n            robot.move();\n            robot.turnLeft();\n            robot.turnLeft();\n        }\n\n        // Turn to next direction\n        robot.turnRight();\n        direction = (direction + 1) % 4;\n    }\n}\n\nint[] getNewPosition(int row, int col, int direction) {\n    int[][] directions = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}}; // up, right, down, left\n    return new int[]{row + directions[direction][0], col + directions[direction][1]};\n}\n'})}),"\n",(0,t.jsx)(i.h3,{id:"122-shortest-distance-from-all-buildings",children:"12.2 Shortest Distance from All Buildings"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:"int shortestDistance(int[][] grid) {\n    int m = grid.length, n = grid[0].length;\n    int[][] distances = new int[m][n];\n    int[][] reachable = new int[m][n];\n    int buildings = 0;\n\n    // Count total buildings\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j] == 1) buildings++;\n        }\n    }\n\n    // BFS from each building\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j] == 1) {\n                bfsFromBuilding(grid, i, j, distances, reachable);\n            }\n        }\n    }\n\n    // Find minimum distance\n    int minDistance = Integer.MAX_VALUE;\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j] == 0 && reachable[i][j] == buildings) {\n                minDistance = Math.min(minDistance, distances[i][j]);\n            }\n        }\n    }\n\n    return minDistance == Integer.MAX_VALUE ? -1 : minDistance;\n}\n\nvoid bfsFromBuilding(int[][] grid, int startRow, int startCol,\n                    int[][] distances, int[][] reachable) {\n    Queue<int[]> queue = new LinkedList<>();\n    boolean[][] visited = new boolean[grid.length][grid[0].length];\n\n    queue.offer(new int[]{startRow, startCol, 0});\n    visited[startRow][startCol] = true;\n\n    while (!queue.isEmpty()) {\n        int[] current = queue.poll();\n        int row = current[0], col = current[1], dist = current[2];\n\n        for (int[] dir : directions4) {\n            int newRow = row + dir[0];\n            int newCol = col + dir[1];\n\n            if (isValid(grid, newRow, newCol) &&\n                !visited[newRow][newCol] &&\n                grid[newRow][newCol] == 0) {\n\n                visited[newRow][newCol] = true;\n                distances[newRow][newCol] += dist + 1;\n                reachable[newRow][newCol]++;\n                queue.offer(new int[]{newRow, newCol, dist + 1});\n            }\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(i.hr,{}),"\n",(0,t.jsx)(i.h2,{id:"time--space-complexity-reference52",children:"Time & Space Complexity Reference[5][2]"}),"\n",(0,t.jsxs)(i.table,{children:[(0,t.jsx)(i.thead,{children:(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.th,{style:{textAlign:"left"},children:"Pattern"}),(0,t.jsx)(i.th,{style:{textAlign:"left"},children:"Time Complexity"}),(0,t.jsx)(i.th,{style:{textAlign:"left"},children:"Space Complexity"}),(0,t.jsx)(i.th,{style:{textAlign:"left"},children:"Key Characteristics"})]})}),(0,t.jsxs)(i.tbody,{children:[(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{style:{textAlign:"left"},children:"Basic Traversal"}),(0,t.jsx)(i.td,{style:{textAlign:"left"},children:"O(m \xd7 n)"}),(0,t.jsx)(i.td,{style:{textAlign:"left"},children:"O(1) to O(m \xd7 n)"}),(0,t.jsx)(i.td,{style:{textAlign:"left"},children:"Visit each cell once"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{style:{textAlign:"left"},children:"DFS/BFS"}),(0,t.jsx)(i.td,{style:{textAlign:"left"},children:"O(m \xd7 n)"}),(0,t.jsx)(i.td,{style:{textAlign:"left"},children:"O(m \xd7 n)"}),(0,t.jsx)(i.td,{style:{textAlign:"left"},children:"Recursion/queue space"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{style:{textAlign:"left"},children:"Connected Components"}),(0,t.jsx)(i.td,{style:{textAlign:"left"},children:"O(m \xd7 n)"}),(0,t.jsx)(i.td,{style:{textAlign:"left"},children:"O(m \xd7 n)"}),(0,t.jsx)(i.td,{style:{textAlign:"left"},children:"Union-Find alternative: O(m \xd7 n \xd7 \u03b1(m \xd7 n))"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{style:{textAlign:"left"},children:"Flood Fill"}),(0,t.jsx)(i.td,{style:{textAlign:"left"},children:"O(m \xd7 n)"}),(0,t.jsx)(i.td,{style:{textAlign:"left"},children:"O(m \xd7 n)"}),(0,t.jsx)(i.td,{style:{textAlign:"left"},children:"Worst case: all cells same color"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{style:{textAlign:"left"},children:"Multi-source BFS"}),(0,t.jsx)(i.td,{style:{textAlign:"left"},children:"O(m \xd7 n)"}),(0,t.jsx)(i.td,{style:{textAlign:"left"},children:"O(m \xd7 n)"}),(0,t.jsx)(i.td,{style:{textAlign:"left"},children:"Process all sources simultaneously"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{style:{textAlign:"left"},children:"Path Finding"}),(0,t.jsx)(i.td,{style:{textAlign:"left"},children:"O(m \xd7 n) to O(m \xd7 n \xd7 log(m \xd7 n))"}),(0,t.jsx)(i.td,{style:{textAlign:"left"},children:"O(m \xd7 n)"}),(0,t.jsx)(i.td,{style:{textAlign:"left"},children:"Dijkstra for weighted paths"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{style:{textAlign:"left"},children:"Dynamic Programming"}),(0,t.jsx)(i.td,{style:{textAlign:"left"},children:"O(m \xd7 n)"}),(0,t.jsx)(i.td,{style:{textAlign:"left"},children:"O(m \xd7 n) to O(n)"}),(0,t.jsx)(i.td,{style:{textAlign:"left"},children:"Space can often be optimized"})]})]})]}),"\n",(0,t.jsx)(i.hr,{}),"\n",(0,t.jsx)(i.h2,{id:"best-practices--optimization-tips",children:"Best Practices & Optimization Tips"}),"\n",(0,t.jsx)(i.h3,{id:"implementation-guidelines",children:"Implementation Guidelines"}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Direction Arrays"}),": Always use consistent direction vectors for clean code"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Boundary Checking"}),": Create helper methods to avoid repetitive bounds checking"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"State Management"}),": Use visited arrays or modify input when possible"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Early Termination"}),": Add pruning conditions in DFS/BFS"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Space Optimization"}),": Consider in-place modifications vs. auxiliary space"]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"common-optimizations",children:"Common Optimizations"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:"// 1. Direction vector reuse\nprivate static final int[][] DIRS = {{-1,0}, {1,0}, {0,-1}, {0,1}};\n\n// 2. Inline boundary checking\nprivate boolean inBounds(int[][] grid, int r, int c) {\n    return r >= 0 && r < grid.length && c >= 0 && c < grid[0].length;\n}\n\n// 3. State encoding for multiple conditions\n// Use bit manipulation or encoding schemes\n\n// 4. Early pruning in backtracking\nif (currentCost > bestSoFar) return; // Prune\n\n// 5. Memoization for overlapping subproblems\nMap<String, Integer> memo = new HashMap<>();\n"})}),"\n",(0,t.jsx)(i.h3,{id:"interview-tips",children:"Interview Tips"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Draw the grid"})," and trace through examples"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Identify the pattern"})," early (BFS for shortest path, DFS for all paths)"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Consider edge cases"}),": empty grid, single cell, all same values"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Optimize space"})," when possible using rolling arrays or in-place modification"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Handle directions"})," consistently throughout the solution"]}),"\n"]})]})}function h(n={}){const{wrapper:i}={...(0,r.R)(),...n.components};return i?(0,t.jsx)(i,{...n,children:(0,t.jsx)(c,{...n})}):c(n)}},28453:(n,i,e)=>{e.d(i,{R:()=>l,x:()=>a});var t=e(96540);const r={},o=t.createContext(r);function l(n){const i=t.useContext(o);return t.useMemo(function(){return"function"==typeof n?n(i):{...i,...n}},[i,n])}function a(n){let i;return i=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:l(n.components),t.createElement(o.Provider,{value:i},n.children)}}}]);