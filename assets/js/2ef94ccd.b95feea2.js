"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[61113],{28453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>c});var t=s(96540);const r={},i=t.createContext(r);function o(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),t.createElement(i.Provider,{value:n},e.children)}},78805:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>c,toc:()=>a});var t=s(74848),r=s(28453);const i={},o="React Lifecycle Methods & Hooks - Complete Interview Guide",c={id:"Interview Prep 2026/React Lifecycle Methods & Hooks - Complete Interview Guide",title:"React Lifecycle Methods & Hooks - Complete Interview Guide",description:"Table of Contents",source:"@site/docs/08-Interview Prep 2026/React Lifecycle Methods & Hooks - Complete Interview Guide.mdx",sourceDirName:"08-Interview Prep 2026",slug:"/Interview Prep 2026/React Lifecycle Methods & Hooks - Complete Interview Guide",permalink:"/docs/Interview Prep 2026/React Lifecycle Methods & Hooks - Complete Interview Guide",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/08-Interview Prep 2026/React Lifecycle Methods & Hooks - Complete Interview Guide.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"React Internals: JSX, Reconciliation & Virtual DOM",permalink:"/docs/Interview Prep 2026/React Internals: JSX, Reconciliation & Virtual DOM"},next:{title:"React Performance Optimization",permalink:"/docs/Interview Prep 2026/React Performance Optimization"}},l={},a=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Class Component Lifecycle Methods",id:"class-component-lifecycle-methods",level:2},{value:"Mounting Phase",id:"mounting-phase",level:3},{value:"constructor()",id:"constructor",level:4},{value:"static getDerivedStateFromProps()",id:"static-getderivedstatefromprops",level:4},{value:"render()",id:"render",level:4},{value:"componentDidMount()",id:"componentdidmount",level:4},{value:"Updating Phase",id:"updating-phase",level:3},{value:"static getDerivedStateFromProps()",id:"static-getderivedstatefromprops-1",level:4},{value:"shouldComponentUpdate()",id:"shouldcomponentupdate",level:4},{value:"render()",id:"render-1",level:4},{value:"getSnapshotBeforeUpdate()",id:"getsnapshotbeforeupdate",level:4},{value:"componentDidUpdate()",id:"componentdidupdate",level:4},{value:"Unmounting Phase",id:"unmounting-phase",level:3},{value:"componentWillUnmount()",id:"componentwillunmount",level:4},{value:"Error Handling Phase",id:"error-handling-phase",level:3},{value:"static getDerivedStateFromError()",id:"static-getderivedstatefromerror",level:4},{value:"componentDidCatch()",id:"componentdidcatch",level:4},{value:"Functional Component Hooks",id:"functional-component-hooks",level:2},{value:"useState",id:"usestate",level:3},{value:"useEffect",id:"useeffect",level:3},{value:"useContext",id:"usecontext",level:3},{value:"useReducer",id:"usereducer",level:3},{value:"useCallback",id:"usecallback",level:3},{value:"useMemo",id:"usememo",level:3},{value:"useRef",id:"useref",level:3},{value:"useLayoutEffect",id:"uselayouteffect",level:3},{value:"useImperativeHandle",id:"useimperativehandle",level:3},{value:"Lifecycle to Hooks Migration",id:"lifecycle-to-hooks-migration",level:2},{value:"componentDidMount \u2192 useEffect",id:"componentdidmount--useeffect",level:3},{value:"componentDidUpdate \u2192 useEffect",id:"componentdidupdate--useeffect",level:3},{value:"componentWillUnmount \u2192 useEffect cleanup",id:"componentwillunmount--useeffect-cleanup",level:3},{value:"shouldComponentUpdate \u2192 React.memo",id:"shouldcomponentupdate--reactmemo",level:3},{value:"Common Interview Questions",id:"common-interview-questions",level:2},{value:"Q1: What is the component lifecycle in React?",id:"q1-what-is-the-component-lifecycle-in-react",level:3},{value:"Q2: What&#39;s the difference between useEffect and useLayoutEffect?",id:"q2-whats-the-difference-between-useeffect-and-uselayouteffect",level:3},{value:"Q3: Why is the dependency array important in useEffect?",id:"q3-why-is-the-dependency-array-important-in-useeffect",level:3},{value:"Q4: How do you prevent memory leaks with useEffect?",id:"q4-how-do-you-prevent-memory-leaks-with-useeffect",level:3},{value:"Q5: When should you use useReducer instead of useState?",id:"q5-when-should-you-use-usereducer-instead-of-usestate",level:3},{value:"Q6: What&#39;s the purpose of useCallback and useMemo?",id:"q6-whats-the-purpose-of-usecallback-and-usememo",level:3},{value:"Q7: Can you call hooks conditionally?",id:"q7-can-you-call-hooks-conditionally",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Keep effects focused and single-purpose",id:"1-keep-effects-focused-and-single-purpose",level:3},{value:"2. Always include dependencies",id:"2-always-include-dependencies",level:3},{value:"3. Clean up side effects",id:"3-clean-up-side-effects",level:3},{value:"4. Use custom hooks for reusable logic",id:"4-use-custom-hooks-for-reusable-logic",level:3},{value:"5. Avoid premature optimization",id:"5-avoid-premature-optimization",level:3},{value:"6. Use functional updates for state",id:"6-use-functional-updates-for-state",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"react-lifecycle-methods--hooks---complete-interview-guide",children:"React Lifecycle Methods & Hooks - Complete Interview Guide"})}),"\n",(0,t.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#introduction",children:"Introduction"})}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"#class-component-lifecycle-methods",children:"Class Component Lifecycle Methods"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#mounting-phase",children:"Mounting Phase"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#updating-phase",children:"Updating Phase"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#unmounting-phase",children:"Unmounting Phase"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#error-handling-phase",children:"Error Handling Phase"})}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"#functional-component-hooks",children:"Functional Component Hooks"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#usestate",children:"useState"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#useeffect",children:"useEffect"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#usecontext",children:"useContext"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#usereducer",children:"useReducer"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#usecallback",children:"useCallback"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#usememo",children:"useMemo"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#useref",children:"useRef"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#uselayouteffect",children:"useLayoutEffect"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#useimperativehandle",children:"useImperativeHandle"})}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#lifecycle-to-hooks-migration",children:"Lifecycle to Hooks Migration"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#common-interview-questions",children:"Common Interview Questions"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#best-practices",children:"Best Practices"})}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsx)(n.p,{children:"React components go through different phases in their lifetime. Understanding these phases and how to hook into them is crucial for building efficient React applications. Class components use lifecycle methods, while functional components use Hooks to achieve similar functionality."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"class-component-lifecycle-methods",children:"Class Component Lifecycle Methods"}),"\n",(0,t.jsx)(n.h3,{id:"mounting-phase",children:"Mounting Phase"}),"\n",(0,t.jsx)(n.p,{children:"These methods are called when an instance of a component is being created and inserted into the DOM."}),"\n",(0,t.jsx)(n.h4,{id:"constructor",children:"constructor()"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"constructor(props) {\n  super(props);\n  this.state = { count: 0 };\n  this.handleClick = this.handleClick.bind(this);\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Purpose:"})," Initialize state and bind event handlers."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Key Points:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Called before the component is mounted"}),"\n",(0,t.jsxs)(n.li,{children:["Must call ",(0,t.jsx)(n.code,{children:"super(props)"})," first"]}),"\n",(0,t.jsxs)(n.li,{children:["Don't call ",(0,t.jsx)(n.code,{children:"setState()"})," here, use ",(0,t.jsx)(n.code,{children:"this.state"})," directly"]}),"\n",(0,t.jsx)(n.li,{children:"Good place for binding methods"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"static-getderivedstatefromprops",children:"static getDerivedStateFromProps()"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"static getDerivedStateFromProps(props, state) {\n  if (props.value !== state.value) {\n    return { value: props.value };\n  }\n  return null;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Purpose:"})," Synchronize state with props before rendering."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Key Points:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Static method, no access to ",(0,t.jsx)(n.code,{children:"this"})]}),"\n",(0,t.jsx)(n.li,{children:"Called right before rendering on both mount and update"}),"\n",(0,t.jsx)(n.li,{children:"Return an object to update state, or null for no update"}),"\n",(0,t.jsx)(n.li,{children:"Rarely needed, consider alternatives first"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"render",children:"render()"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"render() {\n  return <div>{this.state.count}</div>;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Purpose:"})," Return the JSX to be rendered."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Key Points:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Only required method in class components"}),"\n",(0,t.jsx)(n.li,{children:"Must be pure (no side effects)"}),"\n",(0,t.jsx)(n.li,{children:"Should not modify component state"}),"\n",(0,t.jsx)(n.li,{children:"Can return JSX, arrays, fragments, portals, strings, numbers, booleans, or null"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"componentdidmount",children:"componentDidMount()"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"componentDidMount() {\n  // API calls\n  fetch('/api/data')\n    .then(response => response.json())\n    .then(data => this.setState({ data }));\n\n  // Event listeners\n  window.addEventListener('resize', this.handleResize);\n\n  // Timers\n  this.timer = setInterval(() => this.tick(), 1000);\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Purpose:"})," Perform side effects after component is mounted."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Key Points:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Called once after the first render"}),"\n",(0,t.jsx)(n.li,{children:"Perfect for API calls, subscriptions, and DOM manipulation"}),"\n",(0,t.jsxs)(n.li,{children:["Can call ",(0,t.jsx)(n.code,{children:"setState()"})," here (triggers re-render)"]}),"\n",(0,t.jsx)(n.li,{children:"Component and DOM nodes are available"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"updating-phase",children:"Updating Phase"}),"\n",(0,t.jsx)(n.p,{children:"These methods are called when props or state change, causing a re-render."}),"\n",(0,t.jsx)(n.h4,{id:"static-getderivedstatefromprops-1",children:"static getDerivedStateFromProps()"}),"\n",(0,t.jsx)(n.p,{children:"Same as in mounting phase, also called before every update."}),"\n",(0,t.jsx)(n.h4,{id:"shouldcomponentupdate",children:"shouldComponentUpdate()"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"shouldComponentUpdate(nextProps, nextState) {\n  // Only update if count changed\n  return nextState.count !== this.state.count;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Purpose:"})," Optimize performance by preventing unnecessary re-renders."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Key Points:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Return ",(0,t.jsx)(n.code,{children:"true"})," to proceed with update, ",(0,t.jsx)(n.code,{children:"false"})," to skip"]}),"\n",(0,t.jsx)(n.li,{children:"Default behavior is to re-render on every state/prop change"}),"\n",(0,t.jsx)(n.li,{children:"Don't do deep equality checks (use PureComponent instead)"}),"\n",(0,t.jsxs)(n.li,{children:["Not called for initial render or when ",(0,t.jsx)(n.code,{children:"forceUpdate()"})," is used"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"render-1",children:"render()"}),"\n",(0,t.jsx)(n.p,{children:"Same render method, called again with new props/state."}),"\n",(0,t.jsx)(n.h4,{id:"getsnapshotbeforeupdate",children:"getSnapshotBeforeUpdate()"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"getSnapshotBeforeUpdate(prevProps, prevState) {\n  // Capture scroll position before update\n  if (prevProps.list.length < this.props.list.length) {\n    const list = this.listRef.current;\n    return list.scrollHeight - list.scrollTop;\n  }\n  return null;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Purpose:"})," Capture information from DOM before it changes."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Key Points:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Called right before DOM updates"}),"\n",(0,t.jsxs)(n.li,{children:["Return value is passed to ",(0,t.jsx)(n.code,{children:"componentDidUpdate()"})]}),"\n",(0,t.jsx)(n.li,{children:"Rarely used, useful for scroll position handling"}),"\n",(0,t.jsxs)(n.li,{children:["Must be used with ",(0,t.jsx)(n.code,{children:"componentDidUpdate()"})]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"componentdidupdate",children:"componentDidUpdate()"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"componentDidUpdate(prevProps, prevState, snapshot) {\n  // Compare props to make API call\n  if (this.props.userId !== prevProps.userId) {\n    this.fetchUserData(this.props.userId);\n  }\n\n  // Use snapshot from getSnapshotBeforeUpdate\n  if (snapshot !== null) {\n    const list = this.listRef.current;\n    list.scrollTop = list.scrollHeight - snapshot;\n  }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Purpose:"})," Perform side effects after update."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Key Points:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Called after every update (not on initial mount)"}),"\n",(0,t.jsxs)(n.li,{children:["Can call ",(0,t.jsx)(n.code,{children:"setState()"})," but must be conditional to avoid infinite loop"]}),"\n",(0,t.jsx)(n.li,{children:"Good place to compare current and previous props"}),"\n",(0,t.jsxs)(n.li,{children:["Receives snapshot value from ",(0,t.jsx)(n.code,{children:"getSnapshotBeforeUpdate()"})]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"unmounting-phase",children:"Unmounting Phase"}),"\n",(0,t.jsx)(n.h4,{id:"componentwillunmount",children:"componentWillUnmount()"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"componentWillUnmount() {\n  // Clean up event listeners\n  window.removeEventListener('resize', this.handleResize);\n\n  // Clear timers\n  clearInterval(this.timer);\n\n  // Cancel network requests\n  this.abortController.abort();\n\n  // Unsubscribe from stores\n  this.unsubscribe();\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Purpose:"})," Clean up before component is removed."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Key Points:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Called immediately before component is destroyed"}),"\n",(0,t.jsx)(n.li,{children:"Perform cleanup like removing listeners, canceling requests, clearing timers"}),"\n",(0,t.jsxs)(n.li,{children:["Don't call ",(0,t.jsx)(n.code,{children:"setState()"})," here (component will never re-render)"]}),"\n",(0,t.jsx)(n.li,{children:"Critical for preventing memory leaks"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"error-handling-phase",children:"Error Handling Phase"}),"\n",(0,t.jsx)(n.h4,{id:"static-getderivedstatefromerror",children:"static getDerivedStateFromError()"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"static getDerivedStateFromError(error) {\n  return { hasError: true };\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Purpose:"})," Update state when descendant component throws error."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Key Points:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Called during render phase"}),"\n",(0,t.jsx)(n.li,{children:"Must be static method"}),"\n",(0,t.jsx)(n.li,{children:"Used to render fallback UI"}),"\n",(0,t.jsx)(n.li,{children:"Don't perform side effects here"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"componentdidcatch",children:"componentDidCatch()"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"componentDidCatch(error, errorInfo) {\n  // Log error to service\n  logErrorToService(error, errorInfo);\n\n  console.log('Error:', error);\n  console.log('Error Info:', errorInfo.componentStack);\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Purpose:"})," Log error information."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Key Points:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Called during commit phase"}),"\n",(0,t.jsx)(n.li,{children:"Can perform side effects like logging"}),"\n",(0,t.jsx)(n.li,{children:"Receives error and info about which component threw error"}),"\n",(0,t.jsxs)(n.li,{children:["Used with ",(0,t.jsx)(n.code,{children:"getDerivedStateFromError()"})," for error boundaries"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"functional-component-hooks",children:"Functional Component Hooks"}),"\n",(0,t.jsx)(n.h3,{id:"usestate",children:"useState"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  const [user, setUser] = useState({ name: '', age: 0 });\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n      <button onClick={() => setCount(prev => prev + 1)}>Increment (callback)</button>\n    </div>\n  );\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Purpose:"})," Add state to functional components."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Key Points:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Returns array with current state and setter function"}),"\n",(0,t.jsx)(n.li,{children:"Initial state can be value or function"}),"\n",(0,t.jsx)(n.li,{children:"Setter can take new value or updater function"}),"\n",(0,t.jsxs)(n.li,{children:["Multiple ",(0,t.jsx)(n.code,{children:"useState"})," calls are allowed"]}),"\n",(0,t.jsx)(n.li,{children:"State updates are batched for performance"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"useeffect",children:"useEffect"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { useEffect } from 'react';\n\nfunction DataFetcher({ userId }) {\n  const [data, setData] = useState(null);\n\n  // Runs after every render\n  useEffect(() => {\n    console.log('Component rendered');\n  });\n\n  // Runs once on mount (like componentDidMount)\n  useEffect(() => {\n    fetchInitialData();\n  }, []);\n\n  // Runs when userId changes (like componentDidUpdate)\n  useEffect(() => {\n    fetchUserData(userId);\n  }, [userId]);\n\n  // With cleanup (like componentWillUnmount)\n  useEffect(() => {\n    const subscription = subscribeToData();\n\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, []);\n\n  return <div>{data}</div>;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Purpose:"})," Perform side effects in functional components."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Key Points:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Combines ",(0,t.jsx)(n.code,{children:"componentDidMount"}),", ",(0,t.jsx)(n.code,{children:"componentDidUpdate"}),", and ",(0,t.jsx)(n.code,{children:"componentWillUnmount"})]}),"\n",(0,t.jsx)(n.li,{children:"Runs after render by default"}),"\n",(0,t.jsx)(n.li,{children:"Second argument is dependency array"}),"\n",(0,t.jsx)(n.li,{children:"Empty array means run once on mount"}),"\n",(0,t.jsx)(n.li,{children:"Return cleanup function for unmounting"}),"\n",(0,t.jsxs)(n.li,{children:["Can have multiple ",(0,t.jsx)(n.code,{children:"useEffect"})," hooks"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"usecontext",children:"useContext"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { useContext, createContext } from 'react';\n\nconst ThemeContext = createContext('light');\n\nfunction ThemedButton() {\n  const theme = useContext(ThemeContext);\n\n  return (\n    <button className={theme}>\n      I'm styled by context!\n    </button>\n  );\n}\n\nfunction App() {\n  return (\n    <ThemeContext.Provider value=\"dark\">\n      <ThemedButton />\n    </ThemeContext.Provider>\n  );\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Purpose:"})," Access context values without nesting."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Key Points:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Accepts context object from ",(0,t.jsx)(n.code,{children:"createContext()"})]}),"\n",(0,t.jsx)(n.li,{children:"Returns current context value"}),"\n",(0,t.jsx)(n.li,{children:"Triggers re-render when context value changes"}),"\n",(0,t.jsx)(n.li,{children:"Cleaner than Context.Consumer"}),"\n",(0,t.jsx)(n.li,{children:"Can use multiple contexts"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"usereducer",children:"useReducer"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { useReducer } from 'react';\n\nconst initialState = { count: 0 };\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'increment':\n      return { count: state.count + 1 };\n    case 'decrement':\n      return { count: state.count - 1 };\n    case 'reset':\n      return initialState;\n    default:\n      throw new Error();\n  }\n}\n\nfunction Counter() {\n  const [state, dispatch] = useReducer(reducer, initialState);\n\n  return (\n    <>\n      Count: {state.count}\n      <button onClick={() => dispatch({ type: 'increment' })}>+</button>\n      <button onClick={() => dispatch({ type: 'decrement' })}>-</button>\n      <button onClick={() => dispatch({ type: 'reset' })}>Reset</button>\n    </>\n  );\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Purpose:"})," Manage complex state logic."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Key Points:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Alternative to ",(0,t.jsx)(n.code,{children:"useState"})," for complex state"]}),"\n",(0,t.jsx)(n.li,{children:"Takes reducer function and initial state"}),"\n",(0,t.jsx)(n.li,{children:"Returns current state and dispatch function"}),"\n",(0,t.jsx)(n.li,{children:"Good for state with multiple sub-values"}),"\n",(0,t.jsx)(n.li,{children:"Similar to Redux pattern"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"usecallback",children:"useCallback"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { useCallback, useState } from 'react';\n\nfunction ParentComponent() {\n  const [count, setCount] = useState(0);\n\n  // Without useCallback - new function every render\n  const handleClick = () => {\n    console.log('Clicked');\n  };\n\n  // With useCallback - same function reference\n  const memoizedCallback = useCallback(() => {\n    console.log('Count:', count);\n  }, [count]);\n\n  return <ChildComponent onClick={memoizedCallback} />;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Purpose:"})," Memoize callback functions."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Key Points:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Returns memoized version of callback"}),"\n",(0,t.jsx)(n.li,{children:"Only changes if dependencies change"}),"\n",(0,t.jsx)(n.li,{children:"Useful for passing callbacks to optimized child components"}),"\n",(0,t.jsx)(n.li,{children:"Prevents unnecessary re-renders of children"}),"\n",(0,t.jsx)(n.li,{children:"Dependency array required"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"usememo",children:"useMemo"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { useMemo, useState } from 'react';\n\nfunction ExpensiveComponent({ items }) {\n  const [filter, setFilter] = useState('');\n\n  // Expensive calculation\n  const filteredItems = useMemo(() => {\n    console.log('Filtering items...');\n    return items.filter(item =>\n      item.name.toLowerCase().includes(filter.toLowerCase())\n    );\n  }, [items, filter]);\n\n  return (\n    <div>\n      <input value={filter} onChange={e => setFilter(e.target.value)} />\n      {filteredItems.map(item => <div key={item.id}>{item.name}</div>)}\n    </div>\n  );\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Purpose:"})," Memoize expensive calculations."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Key Points:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Returns memoized value"}),"\n",(0,t.jsx)(n.li,{children:"Only recalculates when dependencies change"}),"\n",(0,t.jsx)(n.li,{children:"Optimization technique for expensive operations"}),"\n",(0,t.jsx)(n.li,{children:"Don't overuse, adds overhead"}),"\n",(0,t.jsx)(n.li,{children:"Dependency array required"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"useref",children:"useRef"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { useRef, useEffect } from 'react';\n\nfunction TextInput() {\n  const inputRef = useRef(null);\n  const countRef = useRef(0);\n\n  useEffect(() => {\n    // Focus input on mount\n    inputRef.current.focus();\n  }, []);\n\n  const handleClick = () => {\n    // Access DOM node\n    console.log(inputRef.current.value);\n\n    // Store mutable value (doesn't cause re-render)\n    countRef.current++;\n    console.log('Clicked', countRef.current, 'times');\n  };\n\n  return (\n    <>\n      <input ref={inputRef} />\n      <button onClick={handleClick}>Click</button>\n    </>\n  );\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Purpose:"})," Create mutable reference that persists across renders."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Key Points:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Returns mutable ref object with ",(0,t.jsx)(n.code,{children:".current"})," property"]}),"\n",(0,t.jsx)(n.li,{children:"Persists across component re-renders"}),"\n",(0,t.jsx)(n.li,{children:"Doesn't trigger re-render when changed"}),"\n",(0,t.jsx)(n.li,{children:"Common for accessing DOM elements"}),"\n",(0,t.jsx)(n.li,{children:"Can store any mutable value"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"uselayouteffect",children:"useLayoutEffect"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { useLayoutEffect, useRef, useState } from 'react';\n\nfunction TooltipComponent() {\n  const tooltipRef = useRef(null);\n  const [position, setPosition] = useState({ x: 0, y: 0 });\n\n  useLayoutEffect(() => {\n    // Measure DOM before browser paints\n    const { height } = tooltipRef.current.getBoundingClientRect();\n    setPosition({ x: 10, y: -height });\n  }, []);\n\n  return (\n    <div ref={tooltipRef} style={{\n      position: 'absolute',\n      top: position.y,\n      left: position.x\n    }}>\n      Tooltip\n    </div>\n  );\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Purpose:"})," Synchronous effects before browser paint."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Key Points:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Identical signature to ",(0,t.jsx)(n.code,{children:"useEffect"})]}),"\n",(0,t.jsx)(n.li,{children:"Fires synchronously after DOM mutations"}),"\n",(0,t.jsx)(n.li,{children:"Before browser paints screen"}),"\n",(0,t.jsx)(n.li,{children:"Use for DOM measurements and preventing visual flicker"}),"\n",(0,t.jsxs)(n.li,{children:["Prefer ",(0,t.jsx)(n.code,{children:"useEffect"})," when possible (better performance)"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"useimperativehandle",children:"useImperativeHandle"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { forwardRef, useRef, useImperativeHandle } from 'react';\n\nconst FancyInput = forwardRef((props, ref) => {\n  const inputRef = useRef();\n\n  useImperativeHandle(ref, () => ({\n    focus: () => {\n      inputRef.current.focus();\n    },\n    scrollIntoView: () => {\n      inputRef.current.scrollIntoView();\n    }\n  }));\n\n  return <input ref={inputRef} />;\n});\n\nfunction Parent() {\n  const inputRef = useRef();\n\n  return (\n    <>\n      <FancyInput ref={inputRef} />\n      <button onClick={() => inputRef.current.focus()}>\n        Focus Input\n      </button>\n    </>\n  );\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Purpose:"})," Customize ref value exposed to parent."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Key Points:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Used with ",(0,t.jsx)(n.code,{children:"forwardRef"})]}),"\n",(0,t.jsx)(n.li,{children:"Customizes instance value when using refs"}),"\n",(0,t.jsx)(n.li,{children:"Exposes imperative methods to parent"}),"\n",(0,t.jsx)(n.li,{children:"Rarely needed in typical React patterns"}),"\n",(0,t.jsx)(n.li,{children:"Good for library components"}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"lifecycle-to-hooks-migration",children:"Lifecycle to Hooks Migration"}),"\n",(0,t.jsx)(n.h3,{id:"componentdidmount--useeffect",children:"componentDidMount \u2192 useEffect"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// Class\ncomponentDidMount() {\n  fetchData();\n}\n\n// Hooks\nuseEffect(() => {\n  fetchData();\n}, []);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"componentdidupdate--useeffect",children:"componentDidUpdate \u2192 useEffect"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// Class\ncomponentDidUpdate(prevProps) {\n  if (prevProps.userId !== this.props.userId) {\n    fetchUser(this.props.userId);\n  }\n}\n\n// Hooks\nuseEffect(() => {\n  fetchUser(userId);\n}, [userId]);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"componentwillunmount--useeffect-cleanup",children:"componentWillUnmount \u2192 useEffect cleanup"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// Class\ncomponentWillUnmount() {\n  subscription.unsubscribe();\n}\n\n// Hooks\nuseEffect(() => {\n  const subscription = subscribe();\n  return () => {\n    subscription.unsubscribe();\n  };\n}, []);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"shouldcomponentupdate--reactmemo",children:"shouldComponentUpdate \u2192 React.memo"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// Class\nshouldComponentUpdate(nextProps) {\n  return nextProps.value !== this.props.value;\n}\n\n// Hooks\nconst MemoizedComponent = React.memo(Component, (prevProps, nextProps) => {\n  return prevProps.value === nextProps.value;\n});\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"common-interview-questions",children:"Common Interview Questions"}),"\n",(0,t.jsx)(n.h3,{id:"q1-what-is-the-component-lifecycle-in-react",children:"Q1: What is the component lifecycle in React?"}),"\n",(0,t.jsx)(n.p,{children:"The component lifecycle is the series of phases a React component goes through from creation to removal. It consists of mounting (creation), updating (changes), and unmounting (removal) phases. Class components use lifecycle methods, while functional components use Hooks to manage these phases."}),"\n",(0,t.jsx)(n.h3,{id:"q2-whats-the-difference-between-useeffect-and-uselayouteffect",children:"Q2: What's the difference between useEffect and useLayoutEffect?"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"useEffect"})," runs asynchronously after the render is painted to the screen, while ",(0,t.jsx)(n.code,{children:"useLayoutEffect"})," runs synchronously after DOM mutations but before the browser paints. Use ",(0,t.jsx)(n.code,{children:"useLayoutEffect"})," for DOM measurements or when you need to prevent visual flickering. Prefer ",(0,t.jsx)(n.code,{children:"useEffect"})," for better performance in most cases."]}),"\n",(0,t.jsx)(n.h3,{id:"q3-why-is-the-dependency-array-important-in-useeffect",children:"Q3: Why is the dependency array important in useEffect?"}),"\n",(0,t.jsx)(n.p,{children:"The dependency array tells React when to re-run the effect. An empty array means run once on mount, specific values mean run when those values change, and no array means run after every render. Missing dependencies can cause bugs with stale values, while including unnecessary ones can cause performance issues."}),"\n",(0,t.jsx)(n.h3,{id:"q4-how-do-you-prevent-memory-leaks-with-useeffect",children:"Q4: How do you prevent memory leaks with useEffect?"}),"\n",(0,t.jsxs)(n.p,{children:["Return a cleanup function from ",(0,t.jsx)(n.code,{children:"useEffect"})," that cancels subscriptions, clears timers, removes event listeners, and aborts network requests. This cleanup runs before the effect runs again and when the component unmounts."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"useEffect(() => {\n  const timer = setInterval(() => tick(), 1000);\n  return () => clearInterval(timer);\n}, []);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"q5-when-should-you-use-usereducer-instead-of-usestate",children:"Q5: When should you use useReducer instead of useState?"}),"\n",(0,t.jsxs)(n.p,{children:["Use ",(0,t.jsx)(n.code,{children:"useReducer"})," when you have complex state logic involving multiple sub-values, when the next state depends on the previous one, or when you want to optimize performance by passing dispatch down instead of callbacks. It's particularly useful for state machines and Redux-like patterns."]}),"\n",(0,t.jsx)(n.h3,{id:"q6-whats-the-purpose-of-usecallback-and-usememo",children:"Q6: What's the purpose of useCallback and useMemo?"}),"\n",(0,t.jsxs)(n.p,{children:["Both are optimization hooks. ",(0,t.jsx)(n.code,{children:"useCallback"})," memoizes function references to prevent child re-renders when passing callbacks as props. ",(0,t.jsx)(n.code,{children:"useMemo"})," memoizes computed values to avoid expensive recalculations. Don't overuse them as they add overhead."]}),"\n",(0,t.jsx)(n.h3,{id:"q7-can-you-call-hooks-conditionally",children:"Q7: Can you call hooks conditionally?"}),"\n",(0,t.jsx)(n.p,{children:"No. Hooks must be called at the top level of your component, not inside conditions, loops, or nested functions. This ensures hooks are called in the same order every render, which is how React tracks hook state."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsx)(n.h3,{id:"1-keep-effects-focused-and-single-purpose",children:"1. Keep effects focused and single-purpose"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// Bad - multiple concerns in one effect\nuseEffect(() => {\n  fetchData();\n  subscribeToUpdates();\n  logAnalytics();\n}, []);\n\n// Good - separate effects for separate concerns\nuseEffect(() => {\n  fetchData();\n}, []);\n\nuseEffect(() => {\n  subscribeToUpdates();\n  return () => unsubscribe();\n}, []);\n\nuseEffect(() => {\n  logAnalytics();\n}, []);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"2-always-include-dependencies",children:"2. Always include dependencies"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// Bad - missing dependencies\nuseEffect(() => {\n  console.log(userId);\n}, []);\n\n// Good - all dependencies included\nuseEffect(() => {\n  console.log(userId);\n}, [userId]);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"3-clean-up-side-effects",children:"3. Clean up side effects"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"useEffect(() => {\n  const controller = new AbortController();\n\n  fetch('/api/data', { signal: controller.signal })\n    .then(response => response.json())\n    .then(data => setData(data));\n\n  return () => controller.abort();\n}, []);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"4-use-custom-hooks-for-reusable-logic",children:"4. Use custom hooks for reusable logic"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function useWindowSize() {\n  const [size, setSize] = useState({ width: 0, height: 0 });\n\n  useEffect(() => {\n    const handleResize = () => {\n      setSize({ width: window.innerWidth, height: window.innerHeight });\n    };\n\n    window.addEventListener('resize', handleResize);\n    handleResize();\n\n    return () => window.removeEventListener('resize', handleResize);\n  }, []);\n\n  return size;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"5-avoid-premature-optimization",children:"5. Avoid premature optimization"}),"\n",(0,t.jsxs)(n.p,{children:["Don't wrap everything in ",(0,t.jsx)(n.code,{children:"useCallback"})," or ",(0,t.jsx)(n.code,{children:"useMemo"})," without profiling first. These hooks add overhead and should only be used when you've identified a performance problem."]}),"\n",(0,t.jsx)(n.h3,{id:"6-use-functional-updates-for-state",children:"6. Use functional updates for state"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// Safer when new state depends on old state\nsetCount(prev => prev + 1);\n\n// Instead of\nsetCount(count + 1);\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.p,{children:"This guide covers the essential lifecycle methods and hooks you need to know for React interviews and real-world development. Understanding when and how to use each is key to building performant React applications."})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);