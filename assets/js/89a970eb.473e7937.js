"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[24020],{28453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>l});var t=r(96540);const a={},i=t.createContext(a);function s(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),t.createElement(i.Provider,{value:n},e.children)}},96698:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>h,frontMatter:()=>i,metadata:()=>l,toc:()=>d});var t=r(74848),a=r(28453);const i={},s="TreeMap & TreeSet - Guide",l={id:"Backend/Java-Fundamentals/Java/TreeMap & TreeSet - Complete Study Notes",title:"TreeMap & TreeSet - Guide",description:"\ud83d\udccb Requirements Exploration",source:"@site/docs/02-Backend/Java-Fundamentals/Java/TreeMap & TreeSet - Complete Study Notes.mdx",sourceDirName:"02-Backend/Java-Fundamentals/Java",slug:"/Backend/Java-Fundamentals/Java/TreeMap & TreeSet - Complete Study Notes",permalink:"/docs/Backend/Java-Fundamentals/Java/TreeMap & TreeSet - Complete Study Notes",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/02-Backend/Java-Fundamentals/Java/TreeMap & TreeSet - Complete Study Notes.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"System Design Notes",permalink:"/docs/Backend/Java-Fundamentals/Java/System Design Notes"},next:{title:"java.util.Objects Methods Guide",permalink:"/docs/Backend/Java-Fundamentals/Java/java.util.Objects Methods Guide"}},o={},d=[{value:"\ud83d\udccb Requirements Exploration",id:"-requirements-exploration",level:2},{value:"What are TreeMap and TreeSet?",id:"what-are-treemap-and-treeset",level:3},{value:"Key Questions to Consider:",id:"key-questions-to-consider",level:3},{value:"\ud83c\udfd7\ufe0f Architecture/High-level Design",id:"\ufe0f-architecturehigh-level-design",level:2},{value:"TreeMap Architecture",id:"treemap-architecture",level:3},{value:"TreeSet Architecture",id:"treeset-architecture",level:3},{value:"Component Relationships",id:"component-relationships",level:3},{value:"Performance Characteristics",id:"performance-characteristics",level:3},{value:"\ud83d\udcca Data Model",id:"-data-model",level:2},{value:"TreeMap Data Structure",id:"treemap-data-structure",level:3},{value:"TreeSet Data Structure",id:"treeset-data-structure",level:3},{value:"Key Data Entities",id:"key-data-entities",level:3},{value:"\ud83d\udd0c Interface Definition (API)",id:"-interface-definition-api",level:2},{value:"TreeMap Core APIs",id:"treemap-core-apis",level:3},{value:"Construction APIs",id:"construction-apis",level:4},{value:"Basic Operations",id:"basic-operations",level:4},{value:"Navigation APIs (Key Feature!)",id:"navigation-apis-key-feature",level:4},{value:"View APIs",id:"view-apis",level:4},{value:"TreeSet Core APIs",id:"treeset-core-apis",level:3},{value:"Construction APIs",id:"construction-apis-1",level:4},{value:"Basic Operations",id:"basic-operations-1",level:4},{value:"Navigation APIs (Key Feature!)",id:"navigation-apis-key-feature-1",level:4},{value:"Iterator APIs",id:"iterator-apis",level:4},{value:"\u26a1 Optimizations and Deep Dives",id:"-optimizations-and-deep-dives",level:2},{value:"Performance Optimization Tips",id:"performance-optimization-tips",level:3},{value:"1. Constructor Choice",id:"1-constructor-choice",level:4},{value:"2. Range Operations Optimization",id:"2-range-operations-optimization",level:4},{value:"3. Bulk Operations",id:"3-bulk-operations",level:4},{value:"Memory Optimization",id:"memory-optimization",level:3},{value:"Common Pitfalls and Solutions",id:"common-pitfalls-and-solutions",level:3},{value:"1. Comparable vs Comparator",id:"1-comparable-vs-comparator",level:4},{value:"2. Null Handling",id:"2-null-handling",level:4},{value:"3. Mutating Keys/Elements",id:"3-mutating-keyselements",level:4},{value:"Interview-Focused Optimizations",id:"interview-focused-optimizations",level:3},{value:"Range Query Patterns",id:"range-query-patterns",level:4},{value:"Common Interview Questions",id:"common-interview-questions",level:4},{value:"Advanced Use Cases",id:"advanced-use-cases",level:3},{value:"1. Event Timeline Management",id:"1-event-timeline-management",level:4},{value:"2. Range-based Caching",id:"2-range-based-caching",level:4},{value:"3. Interval Scheduling",id:"3-interval-scheduling",level:4},{value:"Comparison with Alternatives",id:"comparison-with-alternatives",level:3},{value:"\ud83c\udfaf Quick Reference Card",id:"-quick-reference-card",level:2},{value:"TreeMap Cheat Sheet",id:"treemap-cheat-sheet",level:3},{value:"TreeSet Cheat Sheet",id:"treeset-cheat-sheet",level:3},{value:"Time Complexity Summary",id:"time-complexity-summary",level:3},{value:"\ud83d\udca1 Interview Tips",id:"-interview-tips",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"treemap--treeset---guide",children:"TreeMap & TreeSet - Guide"})}),"\n",(0,t.jsx)(n.h2,{id:"-requirements-exploration",children:"\ud83d\udccb Requirements Exploration"}),"\n",(0,t.jsx)(n.h3,{id:"what-are-treemap-and-treeset",children:"What are TreeMap and TreeSet?"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"TreeMap"}),": A sorted map implementation that maintains key-value pairs in sorted order"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"TreeSet"}),": A sorted set implementation that maintains unique elements in sorted order"]}),"\n",(0,t.jsx)(n.li,{children:"Both use Red-Black tree internally for balanced tree operations"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"key-questions-to-consider",children:"Key Questions to Consider:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"When to use TreeMap vs HashMap?"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Use TreeMap when you need sorted keys or range operations"}),"\n",(0,t.jsx)(n.li,{children:"Use HashMap for faster O(1) operations without ordering requirements"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"When to use TreeSet vs HashSet?"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Use TreeSet for sorted elements and range queries"}),"\n",(0,t.jsx)(n.li,{children:"Use HashSet for faster O(1) operations without ordering"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"What are the ordering requirements?"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Elements must implement Comparable OR provide a Comparator"}),"\n",(0,t.jsx)(n.li,{children:"Natural ordering vs custom ordering"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"\ufe0f-architecturehigh-level-design",children:"\ud83c\udfd7\ufe0f Architecture/High-level Design"}),"\n",(0,t.jsx)(n.h3,{id:"treemap-architecture",children:"TreeMap Architecture"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"TreeMap\n\u251c\u2500\u2500 Red-Black Tree Structure\n\u251c\u2500\u2500 NavigableMap Interface\n\u251c\u2500\u2500 SortedMap Interface\n\u2514\u2500\u2500 Map Interface\n"})}),"\n",(0,t.jsx)(n.h3,{id:"treeset-architecture",children:"TreeSet Architecture"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"TreeSet\n\u251c\u2500\u2500 Red-Black Tree Structure (internally uses TreeMap)\n\u251c\u2500\u2500 NavigableSet Interface\n\u251c\u2500\u2500 SortedSet Interface\n\u2514\u2500\u2500 Set Interface\n"})}),"\n",(0,t.jsx)(n.h3,{id:"component-relationships",children:"Component Relationships"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"TreeSet internally uses TreeMap"})," with dummy values"]}),"\n",(0,t.jsxs)(n.li,{children:["Both implement ",(0,t.jsx)(n.strong,{children:"NavigableXXX"})," interfaces for range operations"]}),"\n",(0,t.jsxs)(n.li,{children:["Balanced tree ensures ",(0,t.jsx)(n.strong,{children:"O(log n)"})," for most operations"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"performance-characteristics",children:"Performance Characteristics"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Operation"}),(0,t.jsx)(n.th,{children:"TreeMap"}),(0,t.jsx)(n.th,{children:"TreeSet"}),(0,t.jsx)(n.th,{children:"HashMap"}),(0,t.jsx)(n.th,{children:"HashSet"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Insert"}),(0,t.jsx)(n.td,{children:"O(log n)"}),(0,t.jsx)(n.td,{children:"O(log n)"}),(0,t.jsx)(n.td,{children:"O(1)"}),(0,t.jsx)(n.td,{children:"O(1)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Search"}),(0,t.jsx)(n.td,{children:"O(log n)"}),(0,t.jsx)(n.td,{children:"O(log n)"}),(0,t.jsx)(n.td,{children:"O(1)"}),(0,t.jsx)(n.td,{children:"O(1)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Delete"}),(0,t.jsx)(n.td,{children:"O(log n)"}),(0,t.jsx)(n.td,{children:"O(log n)"}),(0,t.jsx)(n.td,{children:"O(1)"}),(0,t.jsx)(n.td,{children:"O(1)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Min/Max"}),(0,t.jsx)(n.td,{children:"O(log n)"}),(0,t.jsx)(n.td,{children:"O(log n)"}),(0,t.jsx)(n.td,{children:"O(n)"}),(0,t.jsx)(n.td,{children:"O(n)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Range Ops"}),(0,t.jsx)(n.td,{children:"O(log n)"}),(0,t.jsx)(n.td,{children:"O(log n)"}),(0,t.jsx)(n.td,{children:"N/A"}),(0,t.jsx)(n.td,{children:"N/A"})]})]})]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"-data-model",children:"\ud83d\udcca Data Model"}),"\n",(0,t.jsx)(n.h3,{id:"treemap-data-structure",children:"TreeMap Data Structure"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Internal structure conceptually\nclass TreeMapNode<K,V> {\n    K key;\n    V value;\n    TreeMapNode<K,V> left;\n    TreeMapNode<K,V> right;\n    TreeMapNode<K,V> parent;\n    boolean color; // RED-BLACK tree coloring\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"treeset-data-structure",children:"TreeSet Data Structure"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// TreeSet internally uses TreeMap\nclass TreeSet<E> {\n    private final NavigableMap<E,Object> map;\n    private static final Object PRESENT = new Object();\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"key-data-entities",children:"Key Data Entities"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Keys/Elements"}),": Must be comparable or have comparator"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Values"}),": Only in TreeMap, can be any object"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Comparator"}),": Optional custom ordering logic"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Tree Structure"}),": Red-Black tree for balancing"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"-interface-definition-api",children:"\ud83d\udd0c Interface Definition (API)"}),"\n",(0,t.jsx)(n.h3,{id:"treemap-core-apis",children:"TreeMap Core APIs"}),"\n",(0,t.jsx)(n.h4,{id:"construction-apis",children:"Construction APIs"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Natural order\nTreeMap<Integer, String> map = new TreeMap<>();\n\n// Custom order\nTreeMap<Integer, String> mapDesc = new TreeMap<>(Comparator.reverseOrder());\n\n// From existing map\nTreeMap<Integer, String> mapCopy = new TreeMap<>(existingMap);\n"})}),"\n",(0,t.jsx)(n.h4,{id:"basic-operations",children:"Basic Operations"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Insert/Update - O(log n)\nV put(K key, V value)\nvoid putAll(Map<? extends K, ? extends V> map)\n\n// Retrieve - O(log n)\nV get(Object key)\nboolean containsKey(Object key)\nboolean containsValue(Object value)\n\n// Remove - O(log n)\nV remove(Object key)\nvoid clear()\n\n// Size operations - O(1)\nint size()\nboolean isEmpty()\n"})}),"\n",(0,t.jsx)(n.h4,{id:"navigation-apis-key-feature",children:"Navigation APIs (Key Feature!)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Boundary operations - O(log n)\nK firstKey()                    // Smallest key\nK lastKey()                     // Largest key\n\n// Range operations - O(log n)\nK ceilingKey(K key)            // Smallest key \u2265 given key\nK floorKey(K key)              // Largest key \u2264 given key\nK higherKey(K key)             // Smallest key > given key\nK lowerKey(K key)              // Largest key < given key\n\n// Entry operations - O(log n)\nMap.Entry<K,V> firstEntry()\nMap.Entry<K,V> lastEntry()\nMap.Entry<K,V> ceilingEntry(K key)\nMap.Entry<K,V> floorEntry(K key)\nMap.Entry<K,V> higherEntry(K key)\nMap.Entry<K,V> lowerEntry(K key)\n\n// Poll operations - O(log n)\nMap.Entry<K,V> pollFirstEntry()  // Remove and return first\nMap.Entry<K,V> pollLastEntry()   // Remove and return last\n"})}),"\n",(0,t.jsx)(n.h4,{id:"view-apis",children:"View APIs"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"Set<K> keySet()                           // All keys\nCollection<V> values()                    // All values\nSet<Map.Entry<K,V>> entrySet()           // All entries\n\n// Range views\nSortedMap<K,V> subMap(K fromKey, K toKey)\nSortedMap<K,V> headMap(K toKey)\nSortedMap<K,V> tailMap(K fromKey)\nNavigableMap<K,V> descendingMap()\n"})}),"\n",(0,t.jsx)(n.h3,{id:"treeset-core-apis",children:"TreeSet Core APIs"}),"\n",(0,t.jsx)(n.h4,{id:"construction-apis-1",children:"Construction APIs"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Natural order\nTreeSet<Integer> set = new TreeSet<>();\n\n// Custom order\nTreeSet<Integer> setDesc = new TreeSet<>(Comparator.reverseOrder());\n\n// From collection\nTreeSet<Integer> setCopy = new TreeSet<>(existingCollection);\n"})}),"\n",(0,t.jsx)(n.h4,{id:"basic-operations-1",children:"Basic Operations"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Insert - O(log n)\nboolean add(E e)\nboolean addAll(Collection<? extends E> c)\n\n// Query - O(log n)\nboolean contains(Object o)\nboolean containsAll(Collection<?> c)\n\n// Remove - O(log n)\nboolean remove(Object o)\nboolean removeAll(Collection<?> c)\nvoid clear()\n\n// Size operations - O(1)\nint size()\nboolean isEmpty()\n"})}),"\n",(0,t.jsx)(n.h4,{id:"navigation-apis-key-feature-1",children:"Navigation APIs (Key Feature!)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Boundary operations - O(log n)\nE first()                       // Smallest element\nE last()                        // Largest element\n\n// Range operations - O(log n)\nE ceiling(E e)                  // Smallest element \u2265 given element\nE floor(E e)                    // Largest element \u2264 given element\nE higher(E e)                   // Smallest element > given element\nE lower(E e)                    // Largest element < given element\n\n// Poll operations - O(log n)\nE pollFirst()                   // Remove and return smallest\nE pollLast()                    // Remove and return largest\n"})}),"\n",(0,t.jsx)(n.h4,{id:"iterator-apis",children:"Iterator APIs"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"Iterator<E> iterator()                    // Ascending order\nIterator<E> descendingIterator()          // Descending order\n\n// Range views\nSortedSet<E> subSet(E fromElement, E toElement)\nSortedSet<E> headSet(E toElement)\nSortedSet<E> tailSet(E fromElement)\nNavigableSet<E> descendingSet()\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"-optimizations-and-deep-dives",children:"\u26a1 Optimizations and Deep Dives"}),"\n",(0,t.jsx)(n.h3,{id:"performance-optimization-tips",children:"Performance Optimization Tips"}),"\n",(0,t.jsx)(n.h4,{id:"1-constructor-choice",children:"1. Constructor Choice"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// \u2705 Good: Provide initial capacity hint when possible\nTreeSet<Integer> set = new TreeSet<>(existingCollection);\n\n// \u2705 Good: Custom comparator for specific ordering\nTreeMap<String, Integer> map = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);\n\n// \u274c Avoid: Frequent rebalancing with poor initial data\n"})}),"\n",(0,t.jsx)(n.h4,{id:"2-range-operations-optimization",children:"2. Range Operations Optimization"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// \u2705 Efficient: Use subMap/subSet for range queries\nNavigableMap<Integer, String> range = map.subMap(10, true, 20, true);\n\n// \u2705 Efficient: Use ceiling/floor instead of iteration\nInteger nextKey = map.ceilingKey(searchKey);\n\n// \u274c Inefficient: Manual iteration for range operations\n"})}),"\n",(0,t.jsx)(n.h4,{id:"3-bulk-operations",children:"3. Bulk Operations"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// \u2705 Efficient: Use putAll/addAll for bulk operations\nmap.putAll(anotherMap);\nset.addAll(anotherCollection);\n\n// \u274c Inefficient: Individual puts/adds in loop\n"})}),"\n",(0,t.jsx)(n.h3,{id:"memory-optimization",children:"Memory Optimization"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"TreeSet memory"}),": Uses TreeMap internally, so has overhead of dummy values"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Node overhead"}),": Each node has parent, left, right pointers + color bit"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Consider alternatives"}),": For small datasets, ArrayList with Collections.sort() might be more memory-efficient"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"common-pitfalls-and-solutions",children:"Common Pitfalls and Solutions"}),"\n",(0,t.jsx)(n.h4,{id:"1-comparable-vs-comparator",children:"1. Comparable vs Comparator"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// \u274c Problem: ClassCastException\nTreeSet<Person> set = new TreeSet<>(); // Person doesn't implement Comparable\n\n// \u2705 Solution: Provide Comparator\nTreeSet<Person> set = new TreeSet<>((p1, p2) -> p1.getName().compareTo(p2.getName()));\n"})}),"\n",(0,t.jsx)(n.h4,{id:"2-null-handling",children:"2. Null Handling"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// \u274c Problem: NullPointerException\nTreeMap<String, Integer> map = new TreeMap<>();\nmap.put(null, 1); // Throws NPE\n\n// \u2705 Solution: Use HashMap for null keys or handle explicitly\n"})}),"\n",(0,t.jsx)(n.h4,{id:"3-mutating-keyselements",children:"3. Mutating Keys/Elements"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// \u274c Dangerous: Mutating key after insertion\nPerson person = new Person("John");\nTreeSet<Person> set = new TreeSet<>(Comparator.comparing(Person::getName));\nset.add(person);\nperson.setName("Jane"); // Breaks tree structure!\n\n// \u2705 Solution: Use immutable keys or rebuild tree after mutations\n'})}),"\n",(0,t.jsx)(n.h3,{id:"interview-focused-optimizations",children:"Interview-Focused Optimizations"}),"\n",(0,t.jsx)(n.h4,{id:"range-query-patterns",children:"Range Query Patterns"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Pattern 1: Find all elements in range [low, high]\nNavigableSet<Integer> range = set.subSet(low, true, high, true);\n\n// Pattern 2: Find closest elements\nInteger lower = set.lower(target);\nInteger higher = set.higher(target);\n\n// Pattern 3: Sliding window maximum/minimum\nTreeMap<Integer, Integer> frequencyMap = new TreeMap<>();\n// Use firstKey()/lastKey() for min/max in sliding window\n"})}),"\n",(0,t.jsx)(n.h4,{id:"common-interview-questions",children:"Common Interview Questions"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Implement a data structure that supports insert, delete, and getRandom in O(log n)"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Use TreeMap with running indices\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Find the kth smallest element in a stream"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Use TreeMap to maintain frequency count\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Range sum queries"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Use TreeMap with prefix sums\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Sliding window median"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Use two TreeMaps or TreeSet with careful balancing\n"})}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"advanced-use-cases",children:"Advanced Use Cases"}),"\n",(0,t.jsx)(n.h4,{id:"1-event-timeline-management",children:"1. Event Timeline Management"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"TreeMap<LocalDateTime, Event> timeline = new TreeMap<>();\n// Efficiently query events in time ranges\nNavigableMap<LocalDateTime, Event> dayEvents =\n    timeline.subMap(dayStart, true, dayEnd, true);\n"})}),"\n",(0,t.jsx)(n.h4,{id:"2-range-based-caching",children:"2. Range-based Caching"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"TreeMap<Integer, CacheEntry> rangeCache = new TreeMap<>();\n// Find cached ranges that overlap with query range\nMap.Entry<Integer, CacheEntry> floor = rangeCache.floorEntry(queryStart);\n"})}),"\n",(0,t.jsx)(n.h4,{id:"3-interval-scheduling",children:"3. Interval Scheduling"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"TreeSet<Interval> intervals = new TreeSet<>(Comparator.comparing(i -> i.start));\n// Efficiently find overlapping intervals\n"})}),"\n",(0,t.jsx)(n.h3,{id:"comparison-with-alternatives",children:"Comparison with Alternatives"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Use Case"}),(0,t.jsx)(n.th,{children:"TreeMap/TreeSet"}),(0,t.jsx)(n.th,{children:"Alternative"}),(0,t.jsx)(n.th,{children:"When to Use Alternative"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Sorted iteration"}),(0,t.jsx)(n.td,{children:"\u2705 O(log n) ops"}),(0,t.jsx)(n.td,{children:"PriorityQueue"}),(0,t.jsx)(n.td,{children:"Only need min/max, not full sorting"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Range queries"}),(0,t.jsx)(n.td,{children:"\u2705 O(log n) range"}),(0,t.jsx)(n.td,{children:"HashMap + sort"}),(0,t.jsx)(n.td,{children:"Infrequent range queries"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Frequent updates"}),(0,t.jsx)(n.td,{children:"\u26a0\ufe0f O(log n)"}),(0,t.jsx)(n.td,{children:"ArrayList + sort"}),(0,t.jsx)(n.td,{children:"Batch updates with infrequent reads"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Small datasets"}),(0,t.jsx)(n.td,{children:"\u26a0\ufe0f High overhead"}),(0,t.jsx)(n.td,{children:"ArrayList"}),(0,t.jsx)(n.td,{children:"< 50 elements approximately"})]})]})]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"-quick-reference-card",children:"\ud83c\udfaf Quick Reference Card"}),"\n",(0,t.jsx)(n.h3,{id:"treemap-cheat-sheet",children:"TreeMap Cheat Sheet"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"TreeMap<Integer, String> map = new TreeMap<>();\n\n// Basic operations\nmap.put(key, value);        // Insert/update\nmap.get(key);              // Retrieve\nmap.remove(key);           // Delete\nmap.containsKey(key);      // Check existence\n\n// Navigation (\u2605 Interview favorites)\nmap.firstKey() / lastKey();           // Min/max keys\nmap.ceilingKey(k) / floorKey(k);     // Range boundaries\nmap.higherKey(k) / lowerKey(k);      // Strict boundaries\nmap.pollFirstEntry() / pollLastEntry(); // Remove min/max\n"})}),"\n",(0,t.jsx)(n.h3,{id:"treeset-cheat-sheet",children:"TreeSet Cheat Sheet"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"TreeSet<Integer> set = new TreeSet<>();\n\n// Basic operations\nset.add(element);          // Insert\nset.contains(element);     // Check existence\nset.remove(element);       // Delete\n\n// Navigation (\u2605 Interview favorites)\nset.first() / last();             // Min/max elements\nset.ceiling(e) / floor(e);        // Range boundaries\nset.higher(e) / lower(e);         // Strict boundaries\nset.pollFirst() / pollLast();     // Remove min/max\n"})}),"\n",(0,t.jsx)(n.h3,{id:"time-complexity-summary",children:"Time Complexity Summary"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"All basic operations"}),": O(log n)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Range operations"}),": O(log n) to find boundaries + O(k) for k results"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Iteration"}),": O(n) for full traversal"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Space"}),": O(n) with additional overhead for tree structure"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"-interview-tips",children:"\ud83d\udca1 Interview Tips"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Mention the Red-Black tree"}),": Shows deep understanding"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Highlight NavigableMap/Set interfaces"}),": Key differentiator from HashMap/HashSet"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Know the range operation methods"}),": ceiling, floor, higher, lower are commonly tested"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Understand the tradeoffs"}),": When to use Tree vs Hash implementations"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Practice range query problems"}),": Intervals, sliding windows, event processing"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Remember null handling"}),": TreeMap/Set don't allow null keys/elements (unlike HashMap/HashSet)"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}}}]);