"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[5587],{9885:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>o,toc:()=>h});var r=i(4848),n=i(8453);const s={title:"Floyd-Warshall Algorithm"},a=void 0,o={id:"tutorial-basics/Floyd-Warshall",title:"Floyd-Warshall Algorithm",description:"Floyd-Warshall algorithm is a classic algorithm for finding the shortest paths in a weighted graph with positive or negative edge weights (but no negative cycles). It can be used to find the shortest paths between all pairs of vertices in a graph.",source:"@site/docs/tutorial-basics/Floyd-Warshall.mdx",sourceDirName:"tutorial-basics",slug:"/tutorial-basics/Floyd-Warshall",permalink:"/js.enigma/docs/tutorial-basics/Floyd-Warshall",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/tutorial-basics/Floyd-Warshall.mdx",tags:[],version:"current",frontMatter:{title:"Floyd-Warshall Algorithm"},sidebar:"tutorialSidebar",previous:{title:"Flood Fill Algorithm",permalink:"/js.enigma/docs/tutorial-basics/FloodFill"},next:{title:"Floyd's Cycle Detection Algorithm",permalink:"/js.enigma/docs/tutorial-basics/FlyodsCycleDetection"}},l={},h=[{value:"Algorithm Overview",id:"algorithm-overview",level:3},{value:"Steps of the Algorithm",id:"steps-of-the-algorithm",level:3}];function c(e){const t={code:"code",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,n.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.p,{children:"Floyd-Warshall algorithm is a classic algorithm for finding the shortest paths in a weighted graph with positive or negative edge weights (but no negative cycles). It can be used to find the shortest paths between all pairs of vertices in a graph."}),"\n",(0,r.jsx)(t.h3,{id:"algorithm-overview",children:"Algorithm Overview"}),"\n",(0,r.jsx)(t.p,{children:"The algorithm works by considering all pairs of vertices and systematically trying all possible paths between each pair to find the shortest path. It does this using dynamic programming."}),"\n",(0,r.jsx)(t.h3,{id:"steps-of-the-algorithm",children:"Steps of the Algorithm"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:["Initialization: Create a distance matrix dist, where dist[i][j] represents the shortest distance from vertex i to vertex j. Initialize this matrix as follows:","\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Set ",(0,r.jsx)(t.code,{children:"dist[i][j] = 0"})," if ",(0,r.jsx)(t.code,{children:"i == j"})]}),"\n",(0,r.jsxs)(t.li,{children:["Set ",(0,r.jsx)(t.code,{children:"dist[i][j] = weight of edge (i, j)"})," if there is an edge from ",(0,r.jsx)(t.code,{children:"i"})," to ",(0,r.jsx)(t.code,{children:"j"}),"."]}),"\n",(0,r.jsxs)(t.li,{children:["Set ",(0,r.jsx)(t.code,{children:"dist[i][j] = \u221e (infinity)"})," if there is no edge from ",(0,r.jsx)(t.code,{children:"i"})," to ",(0,r.jsx)(t.code,{children:"j"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-JavaScript",children:"/**\r\n * Floyd-Warshall Algorithm to find the shortest paths between all pairs of nodes.\r\n * @param {number[][]} graph - Adjacency matrix representing the graph.\r\n * @return {number[][]} - Distance matrix with the shortest paths.\r\n */\r\nfunction floydWarshall(graph) {\r\n  const V = graph.length;\r\n  const distance = Array.from({ length: V }, (_, i) => Array.from(graph[i]));\r\n\r\n  // Initialize distances based on input graph\r\n  for (let k = 0; k < V; k++) {\r\n    for (let i = 0; i < V; i++) {\r\n      for (let j = 0; j < V; j++) {\r\n        if (distance[i][k] !== Infinity && distance[k][j] !== Infinity) {\r\n          distance[i][j] = Math.min(distance[i][j], distance[i][k] + distance[k][j]);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return distance;\r\n}\r\n\r\n// Example usage:\r\nconst graph = [\r\n  [0, 3, Infinity, Infinity],\r\n  [2, 0, Infinity, 1],\r\n  [Infinity, 7, 0, 2],\r\n  [6, Infinity, 3, 0]\r\n];\r\n\r\nconst shortestPaths = floydWarshall(graph);\r\nconsole.log(shortestPaths); //[ [ 0, 3, 7, 4 ], [ 2, 0, 4, 1 ], [ 8, 7, 0, 2 ], [ 6, 9, 3, 0 ] ]\r\n\r\n/* \r\nTime Complexity: O(V^3)\r\nSpace Complexity: O(V^2)\r\n*/\n"})})]})}function d(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,t,i)=>{i.d(t,{R:()=>a,x:()=>o});var r=i(6540);const n={},s=r.createContext(n);function a(e){const t=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:a(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);