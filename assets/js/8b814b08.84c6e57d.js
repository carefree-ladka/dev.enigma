"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[6130],{17088:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>s,default:()=>u,frontMatter:()=>a,metadata:()=>c,toc:()=>l});var i=t(74848),o=t(28453);const a={},s="React Functional Component Lifecycle",c={id:"WebDev/React/FunctionalComponentsLifeCycle",title:"React Functional Component Lifecycle",description:"Introduction",source:"@site/docs/WebDev/React/FunctionalComponentsLifeCycle.mdx",sourceDirName:"WebDev/React",slug:"/WebDev/React/FunctionalComponentsLifeCycle",permalink:"/docs/WebDev/React/FunctionalComponentsLifeCycle",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/WebDev/React/FunctionalComponentsLifeCycle.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Error Boundary",permalink:"/docs/WebDev/React/ErrorBoundary"},next:{title:"React Hooks Polyfills",permalink:"/docs/WebDev/React/HooksPolyfills"}},r={},l=[{value:"Introduction",id:"introduction",level:2},{value:"Component Lifecycle Phases",id:"component-lifecycle-phases",level:2},{value:"1. Mounting Phase",id:"1-mounting-phase",level:3},{value:"2. Updating Phase",id:"2-updating-phase",level:3},{value:"3. Unmounting Phase",id:"3-unmounting-phase",level:3},{value:"Common Lifecycle Patterns",id:"common-lifecycle-patterns",level:2},{value:"Data Fetching",id:"data-fetching",level:3},{value:"Event Listeners",id:"event-listeners",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Cleanup Functions",id:"1-cleanup-functions",level:3},{value:"2. Dependency Arrays",id:"2-dependency-arrays",level:3},{value:"3. Conditional Effects",id:"3-conditional-effects",level:3},{value:"Common Pitfalls",id:"common-pitfalls",level:2},{value:"1. Infinite Loops",id:"1-infinite-loops",level:3},{value:"2. Stale Closures",id:"2-stale-closures",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"1. useMemo and useCallback",id:"1-usememo-and-usecallback",level:3},{value:"2. Avoiding Unnecessary Re-renders",id:"2-avoiding-unnecessary-re-renders",level:3},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"react-functional-component-lifecycle",children:"React Functional Component Lifecycle"})}),"\n",(0,i.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsx)(n.p,{children:"React functional components go through several phases during their lifetime. While class components have traditional lifecycle methods, functional components use Hooks to handle lifecycle events. This document explores the complete lifecycle of a React functional component."}),"\n",(0,i.jsx)(n.h2,{id:"component-lifecycle-phases",children:"Component Lifecycle Phases"}),"\n",(0,i.jsx)(n.h3,{id:"1-mounting-phase",children:"1. Mounting Phase"}),"\n",(0,i.jsx)(n.p,{children:"When a component is being created and inserted into the DOM:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"function ExampleComponent({ initialData }) {\n  // 1. Component initialization\n  const [data, setData] = useState(initialData);\n\n  // 2. First render setup\n  useEffect(() => {\n    // Runs after first render\n    console.log('Component mounted');\n\n    // Cleanup function (optional)\n    return () => {\n      console.log('Component will unmount');\n    };\n  }, []); // Empty dependency array = run once on mount\n\n  return <div>{data}</div>;\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-updating-phase",children:"2. Updating Phase"}),"\n",(0,i.jsx)(n.p,{children:"When a component is re-rendering due to changes in props or state:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"function UpdatingExample({ user }) {\n  const [count, setCount] = useState(0);\n\n  // Runs on specific prop/state changes\n  useEffect(() => {\n    console.log('user or count updated');\n    // Side effects here\n  }, [user, count]); // Dependency array with values to watch\n\n  // Runs on every render\n  useEffect(() => {\n    console.log('Component updated');\n  }); // No dependency array\n\n  return (\n    <div>\n      <p>User: {user}</p>\n      <p>Count: {count}</p>\n    </div>\n  );\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"3-unmounting-phase",children:"3. Unmounting Phase"}),"\n",(0,i.jsx)(n.p,{children:"When a component is being removed from the DOM:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"function UnmountExample() {\n  useEffect(() => {\n    // Setup phase\n    const subscription = setupSubscription();\n\n    // Cleanup phase\n    return () => {\n      subscription.unsubscribe();\n      console.log('Cleanup performed');\n    };\n  }, []);\n\n  return <div>Subscribed Component</div>;\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"common-lifecycle-patterns",children:"Common Lifecycle Patterns"}),"\n",(0,i.jsx)(n.h3,{id:"data-fetching",children:"Data Fetching"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"function DataFetchingComponent({ id }) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    let mounted = true;\n\n    async function fetchData() {\n      try {\n        setLoading(true);\n        const response = await fetch(`/api/data/${id}`);\n        const result = await response.json();\n\n        if (mounted) {\n          setData(result);\n          setLoading(false);\n        }\n      } catch (err) {\n        if (mounted) {\n          setError(err);\n          setLoading(false);\n        }\n      }\n    }\n\n    fetchData();\n\n    return () => {\n      mounted = false;\n    };\n  }, [id]);\n\n  if (loading) return <div>Loading...</div>;\n  if (error) return <div>Error: {error.message}</div>;\n  return <div>{data}</div>;\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"event-listeners",children:"Event Listeners"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"function EventListenerComponent() {\n  useEffect(() => {\n    const handleResize = () => {\n      console.log('Window resized');\n    };\n\n    window.addEventListener('resize', handleResize);\n\n    return () => {\n      window.removeEventListener('resize', handleResize);\n    };\n  }, []);\n\n  return <div>Window Size Observer</div>;\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsx)(n.h3,{id:"1-cleanup-functions",children:"1. Cleanup Functions"}),"\n",(0,i.jsx)(n.p,{children:"Always include cleanup functions in useEffect when:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Setting up subscriptions"}),"\n",(0,i.jsx)(n.li,{children:"Adding event listeners"}),"\n",(0,i.jsx)(n.li,{children:"Starting timers"}),"\n",(0,i.jsx)(n.li,{children:"Creating WebSocket connections"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"function BestPracticeExample() {\n  useEffect(() => {\n    const timer = setInterval(() => {\n      console.log('Timer tick');\n    }, 1000);\n\n    return () => clearInterval(timer);\n  }, []);\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-dependency-arrays",children:"2. Dependency Arrays"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Empty array (",(0,i.jsx)(n.code,{children:"[]"}),") = run once on mount"]}),"\n",(0,i.jsx)(n.li,{children:"No array = run on every render"}),"\n",(0,i.jsx)(n.li,{children:"Array with dependencies = run when dependencies change"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"function DependencyExample({ data, onUpdate }) {\n  // Runs on every data or onUpdate change\n  useEffect(() => {\n    onUpdate(data);\n  }, [data, onUpdate]);\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"3-conditional-effects",children:"3. Conditional Effects"}),"\n",(0,i.jsx)(n.p,{children:"Use conditional logic inside useEffect, not around it:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// Good\nuseEffect(() => {\n  if (condition) {\n    // Do something\n  }\n}, [condition]);\n\n// Bad - Don't do this\nif (condition) {\n  useEffect(() => {\n    // Do something\n  }, []);\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"common-pitfalls",children:"Common Pitfalls"}),"\n",(0,i.jsx)(n.h3,{id:"1-infinite-loops",children:"1. Infinite Loops"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// \u274c Wrong - Creates infinite loop\nfunction InfiniteLoopExample() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    setCount(count + 1); // Triggers re-render, which triggers effect again\n  }, [count]);\n}\n\n// \u2705 Correct - Using functional update\nfunction FixedExample() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    setCount(prev => prev + 1);\n  }, []); // Runs once on mount\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-stale-closures",children:"2. Stale Closures"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// \u274c Wrong - Stale closure problem\nfunction StaleClosureExample() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    const timer = setInterval(() => {\n      console.log(count); // Will always log initial value\n    }, 1000);\n\n    return () => clearInterval(timer);\n  }, []); // Missing dependency\n}\n\n// \u2705 Correct - Using functional update\nfunction FixedStaleClosureExample() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    const timer = setInterval(() => {\n      setCount(prev => prev + 1); // Uses latest state\n    }, 1000);\n\n    return () => clearInterval(timer);\n  }, []); // No dependencies needed\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,i.jsx)(n.h3,{id:"1-usememo-and-usecallback",children:"1. useMemo and useCallback"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"function OptimizedComponent({ data }) {\n  // Memoize expensive calculations\n  const processedData = useMemo(() => {\n    return expensiveOperation(data);\n  }, [data]);\n\n  // Memoize callbacks\n  const handleClick = useCallback(() => {\n    console.log(processedData);\n  }, [processedData]);\n\n  return <button onClick={handleClick}>Process Data</button>;\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-avoiding-unnecessary-re-renders",children:"2. Avoiding Unnecessary Re-renders"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// Use React.memo for component-level memoization\nconst MemoizedChild = React.memo(function Child({ data }) {\n  return <div>{data}</div>;\n});\n\nfunction Parent() {\n  // Memoize value to prevent unnecessary re-renders\n  const memoizedValue = useMemo(\n    () => ({\n      complex: 'data structure',\n    }),\n    []\n  );\n\n  return <MemoizedChild data={memoizedValue} />;\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsx)(n.p,{children:"Understanding the lifecycle of functional components is crucial for building efficient React applications. By properly managing effects, cleanup, and dependencies, you can create components that are both performant and maintainable. Remember to always consider the cleanup phase and carefully manage your effect dependencies to avoid common pitfalls."})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>c});var i=t(96540);const o={},a=i.createContext(o);function s(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);