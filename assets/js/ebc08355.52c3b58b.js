"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[5622],{5146:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>a,toc:()=>l});var i=t(4848),r=t(8453);const s={title:"Binary Lifting"},o=void 0,a={id:"DSA/DSA with JavaScript/BinaryLifting",title:"Binary Lifting",description:'Binary lifting (also known as binary jumping or jump pointers) is an advanced algorithmic technique primarily used to solve problems involving tree traversal and finding ancestors in a tree data structure. It\'s particularly efficient for queries like "find the kth ancestor of a node" or "find the lowest common ancestor (LCA) of two nodes.',source:"@site/docs/DSA/DSA with JavaScript/BinaryLifting.mdx",sourceDirName:"DSA/DSA with JavaScript",slug:"/DSA/DSA with JavaScript/BinaryLifting",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/BinaryLifting",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with JavaScript/BinaryLifting.mdx",tags:[],version:"current",frontMatter:{title:"Binary Lifting"},sidebar:"tutorialSidebar",previous:{title:"Binary Heap",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/BinaryHeap"},next:{title:"Binary Search and Its Variants",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/BinarySearch"}},c={},l=[{value:"Core Concept",id:"core-concept",level:2},{value:"Understanding the Basics",id:"understanding-the-basics",level:2},{value:"Time and Space Complexity",id:"time-and-space-complexity",level:2}];function h(n){const e={a:"a",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.p,{children:'Binary lifting (also known as binary jumping or jump pointers) is an advanced algorithmic technique primarily used to solve problems involving tree traversal and finding ancestors in a tree data structure. It\'s particularly efficient for queries like "find the kth ancestor of a node" or "find the lowest common ancestor (LCA) of two nodes.'}),"\n",(0,i.jsx)(e.h2,{id:"core-concept",children:"Core Concept"}),"\n",(0,i.jsx)(e.p,{children:"The main idea behind binary lifting is to precompute and store ancestor information for each node in powers of 2. Instead of moving up the tree one step at a time, we can make jumps of size 2^i, allowing us to reach any ancestor in O(log n) time."}),"\n",(0,i.jsx)(e.h2,{id:"understanding-the-basics",children:"Understanding the Basics"}),"\n",(0,i.jsx)(e.p,{children:"Let's break down how binary lifting works:"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"For each node, we store its 2^i-th ancestor for i = 0, 1, 2, ... until we reach the root."}),"\n",(0,i.jsx)(e.li,{children:"To find the kth ancestor, we use the binary representation of k."}),"\n",(0,i.jsx)(e.li,{children:"We jump using the precomputed ancestors based on the set bits in k."}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-JavaScript",children:"class BinaryLifting {\n  constructor(n, edges, root = 0) {\n    this.n = n;  // number of nodes\n    this.maxLog = Math.floor(Math.log2(n));  // maximum power of 2 needed\n    this.up = Array.from({ length: n }, () => Array(this.maxLog).fill(-1));  // dp table\n    this.depth = Array(n).fill(0);  // depth of each node\n\n    // Build adjacency list\n    this.adj = Array.from({ length: n }, () => []);\n    for (let [u, v] of edges) {\n      this.adj[u].push(v);\n      this.adj[v].push(u);\n    }\n\n    // Initialize with DFS\n    this.#dfs(root, -1);\n\n    // Build the binary lifting table\n    this.#buildTable();\n  }\n\n  #dfs(v, parent) {\n    // Initialize immediate ancestors and depths\n    this.up[v][0] = parent;\n    for (let child of this.adj[v]) {\n      if (child !== parent) {\n        this.depth[child] = this.depth[v] + 1;\n        this.#dfs(child, v);\n      }\n    }\n  }\n\n  #buildTable() {\n    // Build the binary lifting table\n    for (let j = 1; j < this.maxLog; j++) {\n      for (let v = 0; v < this.n; v++) {\n        if (this.up[v][j - 1] !== -1) {\n          this.up[v][j] = this.up[this.up[v][j - 1]][j - 1];\n        }\n      }\n    }\n  }\n\n  getKthAncestor(node, k) {\n    // Find the kth ancestor of a given node\n    if (k > this.depth[node]) return -1;\n\n    // Process each bit of k\n    for (let j = 0; j < this.maxLog; j++) {\n      if (k & (1 << j)) {\n        node = this.up[node][j];\n        if (node === -1) break;\n      }\n    }\n    return node;\n  }\n\n  getLCA(u, v) {\n    // Find the Lowest Common Ancestor of nodes u and v\n    if (this.depth[u] < this.depth[v]) {\n      [u, v] = [v, u];\n    }\n\n    // Make u and v same depth\n    let diff = this.depth[u] - this.depth[v];\n\n    // Lift u to same depth as v\n    for (let j = 0; j < this.maxLog; j++) {\n      if (diff & (1 << j)) {\n        u = this.up[u][j];\n      }\n    }\n\n    if (u === v) return u;\n\n    // Lift both nodes until just before their LCA\n    for (let j = this.maxLog - 1; j >= 0; j--) {\n      if (this.up[u][j] !== this.up[v][j]) {\n        u = this.up[u][j];\n        v = this.up[v][j];\n      }\n    }\n\n    return this.up[u][0];\n  }\n}\n\n// Create a tree\n//       0\n//      / \\\n//     1   2\n//    / \\   \\\n//   3   4   5\nconst edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5]];\nconst n = 6;\n\n// Initialize binary lifting\nconst bl = new BinaryLifting(n, edges);\n\n// Find ancestors\nconsole.log(bl.getKthAncestor(4, 1));  // Output: 1 (parent of 4)\nconsole.log(bl.getKthAncestor(4, 2));  // Output: 0 (grandparent of 4)\nconsole.log(bl.getKthAncestor(5, 1));  // Output: 2 (parent of 5)\n\n// Find LCA\nconsole.log(bl.getLCA(3, 4));  // Output: 1 (LCA of 3 and 4)\n"})}),"\n",(0,i.jsx)(e.h2,{id:"time-and-space-complexity",children:"Time and Space Complexity"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Preprocessing:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Time: O(N log N) for building the table"}),"\n",(0,i.jsx)(e.li,{children:"Space: O(N log N) for storing ancestors"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Queries:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Time: O(log N) per query"}),"\n",(0,i.jsx)(e.li,{children:"Space: O(1) per query"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:["Reference : ",(0,i.jsx)(e.a,{href:"https://cp-algorithms.com/graph/lca_binary_lifting.html",children:"https://cp-algorithms.com/graph/lca_binary_lifting.html"})]}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"K-th Ancestor of a Tree Node"}),"\n",(0,i.jsx)(e.li,{children:"Lowest Common Ancestor of a Binary Tree"}),"\n",(0,i.jsx)(e.li,{children:"Distance Between Two Nodes in a Tree"}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"https://www.codechef.com/problems/LGSEG",children:"https://www.codechef.com/problems/LGSEG"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"https://www.hackerearth.com/practice/algorithms/graphs/graph-representation/practice-problems/algorithm/optimal-connectivity-c6ae79ca/",children:"https://www.hackerearth.com/practice/algorithms/graphs/graph-representation/practice-problems/algorithm/optimal-connectivity-c6ae79ca/"})}),"\n"]})]})}function d(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(h,{...n})}):h(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>o,x:()=>a});var i=t(6540);const r={},s=i.createContext(r);function o(n){const e=i.useContext(s);return i.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:o(n.components),i.createElement(s.Provider,{value:e},n.children)}}}]);