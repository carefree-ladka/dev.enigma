"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[4790],{3514:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>h,contentTitle:()=>i,default:()=>l,frontMatter:()=>o,metadata:()=>a,toc:()=>d});var t=r(4848),s=r(8453);const o={title:"DFS & BFS on Graphs",description:"A comprehensive guide to implementing Depth-First Search (DFS) & BFS (Breadth-First Search) on graphs."},i=void 0,a={id:"DSA/DFSBFSGraph",title:"DFS & BFS on Graphs",description:"A comprehensive guide to implementing Depth-First Search (DFS) & BFS (Breadth-First Search) on graphs.",source:"@site/docs/DSA/DFSBFSGraph.mdx",sourceDirName:"DSA",slug:"/DSA/DFSBFSGraph",permalink:"/js.enigma/docs/DSA/DFSBFSGraph",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DFSBFSGraph.mdx",tags:[],version:"current",frontMatter:{title:"DFS & BFS on Graphs",description:"A comprehensive guide to implementing Depth-First Search (DFS) & BFS (Breadth-First Search) on graphs."},sidebar:"tutorialSidebar",previous:{title:"Cyclic Sort Algorithm",permalink:"/js.enigma/docs/DSA/CyclicSort"},next:{title:"Depth-First Search (DFS) for Trees",permalink:"/js.enigma/docs/DSA/DFSTree"}},h={},d=[{value:"Depth-First Search (DFS) on Graphs",id:"depth-first-search-dfs-on-graphs",level:2},{value:"How DFS Works",id:"how-dfs-works",level:2},{value:"Pseudocode",id:"pseudocode",level:3},{value:"Recusrive DFS",id:"recusrive-dfs",level:3},{value:"Iterative DFS",id:"iterative-dfs",level:3},{value:"How BFS Works",id:"how-bfs-works",level:2},{value:"Pseudocode",id:"pseudocode-1",level:3},{value:"BFS",id:"bfs",level:3},{value:"Shortest Path Using BFS",id:"shortest-path-using-bfs",level:3},{value:"Shortest Path Using BFS for a 2D Grid",id:"shortest-path-using-bfs-for-a-2d-grid",level:3}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"depth-first-search-dfs-on-graphs",children:"Depth-First Search (DFS) on Graphs"}),"\n",(0,t.jsx)(n.p,{children:"Depth-First Search (DFS) is a fundamental algorithm for traversing or searching through graph data structures. The algorithm starts at a given node and explores as far as possible along each branch before backtracking."}),"\n",(0,t.jsx)(n.h2,{id:"how-dfs-works",children:"How DFS Works"}),"\n",(0,t.jsx)(n.p,{children:"DFS can be implemented using either a recursive approach or an iterative approach with a stack. The key idea is to start from a source node, visit its adjacent nodes, and continue this process until all nodes reachable from the source are visited."}),"\n",(0,t.jsx)(n.h3,{id:"pseudocode",children:"Pseudocode"}),"\n",(0,t.jsx)(n.p,{children:"Here's the pseudocode for a recursive DFS on an undirected graph:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-Javascript",children:"const graph = {\r\n  A: ['B', 'C'],\r\n  B: ['A', 'D', 'E'],\r\n  C: ['A', 'F'],\r\n  D: ['B'],\r\n  E: ['B'],\r\n  F: ['C'],\r\n  G: ['L'],\r\n  M: ['S']\r\n};\n"})}),"\n",(0,t.jsx)(n.h3,{id:"recusrive-dfs",children:"Recusrive DFS"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-Javascript",children:"const dfs = (graph, startNode, visited = new Set()) => {\r\n  visited.add(startNode);\r\n  console.log(startNode);\r\n\r\n  for (const neighbour of graph[startNode] || []) {\r\n    if (!visited.has(neighbour)) {\r\n      dfs(graph, neighbour, visited);\r\n    }\r\n  }\r\n};\r\n\r\nconst visited = new Set();\r\n\r\n// To handle disconnected components, loop through all nodes\r\nfor (const node of Object.keys(graph)) {\r\n  if (!visited.has(node)) {\r\n    dfs(graph, node, visited);\r\n  }\r\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"iterative-dfs",children:"Iterative DFS"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-Javascript",children:"const dfsIterative = (graph, start, visited = new Set()) => {\r\n  const stack = [start]\r\n  visited.add(start)\r\n\r\n  while (stack.length) {\r\n    const current = stack.pop()\r\n    console.log(current);\r\n    for (const neighbour of graph[current]) {\r\n      if (!visited.has(neighbour)) {\r\n        stack.push(neighbour)\r\n        visited.add(neighbour)\r\n      }\r\n    }\r\n\r\n  }\r\n}\r\n\r\n// To handle disconnected components, loop through all nodes\r\nconst allNodes = new Set(Object.keys(graph));\r\nconst visited = new Set();\r\n\r\nfor (const node of allNodes) {\r\n  if (!visited.has(node)) {\r\n    dfsIterative(graph, node, visited);\r\n  }\r\n}\n"})}),"\n",(0,t.jsx)(n.h1,{id:"breadth-first-search-bfs-on-graphs",children:"Breadth-First Search (BFS) on Graphs"}),"\n",(0,t.jsx)(n.p,{children:"Breadth-First Search (BFS) is an algorithm used for traversing or searching through graph or tree data structures. The algorithm starts at a given node and explores all of its neighbors at the present depth before moving on to nodes at the next depth level."}),"\n",(0,t.jsx)(n.h2,{id:"how-bfs-works",children:"How BFS Works"}),"\n",(0,t.jsx)(n.p,{children:"BFS is typically implemented using a queue data structure. It starts from a source node and explores all of its neighbors first before moving on to the next layer of nodes. This ensures that nodes are visited in the order of their distance from the source node."}),"\n",(0,t.jsx)(n.h3,{id:"pseudocode-1",children:"Pseudocode"}),"\n",(0,t.jsx)(n.p,{children:"Here\u2019s the pseudocode for BFS on an undirected graph:"}),"\n",(0,t.jsx)(n.h3,{id:"bfs",children:"BFS"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-Javascript",children:"const bfs = (graph, start, visited = new Set()) => {\r\n  const queue = [start]\r\n  visited.add(start)\r\n\r\n  while (queue.length) {\r\n    const current = queue.shift()\r\n    console.log(current);\r\n    for (const neighbour of graph[current]) {\r\n      if (!visited.has(neighbour)) {\r\n        queue.push(neighbour)\r\n        visited.add(neighbour)\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// To handle disconnected components, loop through all nodes\r\nconst allNodes = new Set(Object.keys(graph));\r\nconst visited = new Set();\r\n\r\nfor (const node of allNodes) {\r\n  if (!visited.has(node)) {\r\n    bfs(graph, node, visited);\r\n  }\r\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"shortest-path-using-bfs",children:"Shortest Path Using BFS"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-JavaScript",children:"const bfsShortestPath = (graph, start, end) => {\r\n  const queue = [[start]];\r\n  const visited = new Set();\r\n\r\n  while (queue.length > 0) {\r\n    const path = queue.shift(); // Get the current path\r\n    const node = path[path.length - 1]; // Get the last node in the path\r\n\r\n    if (node === end) {\r\n      return path; // Return the path if we've reached the end\r\n    }\r\n\r\n    if (!visited.has(node)) {\r\n      visited.add(node); // Mark the node as visited\r\n\r\n      for (const neighbor of graph[node] ?? []) {\r\n        // Create a new path to the neighbor and enqueue it\r\n        const newPath = [...path, neighbor];\r\n        queue.push(newPath);\r\n      }\r\n    }\r\n  }\r\n\r\n  return []; // Return an empty array if there's no path to the end\r\n}\r\n\r\n// Example usage with disconnected vertices:\r\nconst graph = {\r\n  A: ['B', 'C'],\r\n  B: ['A', 'D', 'E'],\r\n  C: ['A', 'F'],\r\n  D: ['B'],\r\n  E: ['B', 'F'],\r\n  F: ['C', 'E'],\r\n  G: [], // Disconnected vertex G\r\n};\r\n\r\nconst shortestPath1 = bfsShortestPath(graph, 'A', 'F');\r\nconsole.log(shortestPath1); // Output: ['A', 'C', 'F']\r\n\r\nconst shortestPath2 = bfsShortestPath(graph, 'A', 'G');\r\nconsole.log(shortestPath2); // Output: [] (no path to G)\n"})}),"\n",(0,t.jsx)(n.h3,{id:"shortest-path-using-bfs-for-a-2d-grid",children:"Shortest Path Using BFS for a 2D Grid"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-JavaScript",children:"const bfsShortestPath = (grid, start, end) => {\r\n  const rows = grid.length;\r\n  const cols = grid[0].length;\r\n  const directions = [[1, 0], [0, 1], [-1, 0], [0, -1]]; // Down, Right, Up, Left\r\n  const queue = [[...start, 0]]; // [row, col, distance]\r\n  const visited = new Set(); // To track visited cells\r\n  visited.add(start.toString()); // Mark the start cell as visited\r\n\r\n  while (queue.length > 0) {\r\n    const [row, col, distance] = queue.shift(); // Dequeue\r\n\r\n    // Check if we reached the end\r\n    if (row === end[0] && col === end[1]) {\r\n      return distance; // Return the distance (shortest path length)\r\n    }\r\n\r\n    // Explore the neighbors\r\n    for (const [dRow, dCol] of directions) {\r\n      const newRow = row + dRow;\r\n      const newCol = col + dCol;\r\n\r\n      // Check if the new position is within bounds and not visited\r\n      if (\r\n        newRow >= 0 &&\r\n        newRow < rows &&\r\n        newCol >= 0 &&\r\n        newCol < cols &&\r\n        grid[newRow][newCol] === 0 && // Assuming 0 is a valid cell\r\n        !visited.has([newRow, newCol].toString())\r\n      ) {\r\n        visited.add([newRow, newCol].toString()); // Mark as visited\r\n        queue.push([newRow, newCol, distance + 1]); // Enqueue with increased distance\r\n      }\r\n    }\r\n  }\r\n\r\n  return -1; // Return -1 if there's no path\r\n}\r\n\r\n// Example usage:\r\nconst grid = [\r\n  [0, 0, 0, 1],\r\n  [0, 1, 0, 0],\r\n  [0, 0, 0, 0],\r\n  [1, 0, 1, 0]\r\n];\r\n\r\nconst start = [0, 0]; // Starting position\r\nconst end = [3, 3];   // Ending position\r\n\r\nconst shortestPathLength = bfsShortestPath(grid, start, end);\r\nconsole.log(shortestPathLength); // Should output: 6\n"})})]})}function l(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>a});var t=r(6540);const s={},o=t.createContext(s);function i(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);