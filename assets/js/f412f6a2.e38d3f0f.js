"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[4077],{6257:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>o,contentTitle:()=>s,default:()=>m,frontMatter:()=>a,metadata:()=>l,toc:()=>u});var t=i(4848),r=i(8453);const a={},s="Sliding Window",l={id:"DSA/DSA with Java/Sliding Window",title:"Sliding Window",description:"Table of Contents",source:"@site/docs/DSA/DSA with Java/Sliding Window.mdx",sourceDirName:"DSA/DSA with Java",slug:"/DSA/DSA with Java/Sliding Window",permalink:"/js.enigma/docs/DSA/DSA with Java/Sliding Window",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with Java/Sliding Window.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Queue",permalink:"/js.enigma/docs/DSA/DSA with Java/Queue Patterns"},next:{title:"Sorting Algorithms Guide",permalink:"/js.enigma/docs/DSA/DSA with Java/Sorting Algorithms"}},o={},u=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Sliding Window Fundamentals",id:"sliding-window-fundamentals",level:2},{value:"Core Concepts and Implementation",id:"core-concepts-and-implementation",level:3},{value:"Pattern 1: Fixed Size Sliding Window",id:"pattern-1-fixed-size-sliding-window",level:2},{value:"1.1 Basic Fixed Window Problems",id:"11-basic-fixed-window-problems",level:3},{value:"1.2 Advanced Fixed Window Problems",id:"12-advanced-fixed-window-problems",level:3},{value:"Pattern 2: Variable Size Sliding Window",id:"pattern-2-variable-size-sliding-window",level:2},{value:"2.1 Basic Variable Window Problems",id:"21-basic-variable-window-problems",level:3},{value:"2.2 Advanced Variable Window Problems",id:"22-advanced-variable-window-problems",level:3},{value:"Pattern 3: Sliding Window with HashMap",id:"pattern-3-sliding-window-with-hashmap",level:2},{value:"3.1 Character Frequency Problems",id:"31-character-frequency-problems",level:3},{value:"3.2 Advanced HashMap Applications",id:"32-advanced-hashmap-applications",level:3},{value:"Pattern 4: Sliding Window Maximum/Minimum",id:"pattern-4-sliding-window-maximumminimum",level:2},{value:"4.1 Deque-based Window Extremes",id:"41-deque-based-window-extremes",level:3},{value:"Pattern 5: String Matching with Sliding Window",id:"pattern-5-string-matching-with-sliding-window",level:2},{value:"5.1 Pattern Matching Problems",id:"51-pattern-matching-problems",level:3},{value:"Pattern 6: Multiple Pointers Sliding Window",id:"pattern-6-multiple-pointers-sliding-window",level:2},{value:"6.1 Three Pointers and Beyond",id:"61-three-pointers-and-beyond",level:3},{value:"Pattern 7: Sliding Window with Deque",id:"pattern-7-sliding-window-with-deque",level:2},{value:"7.1 Deque Applications in Sliding Window",id:"71-deque-applications-in-sliding-window",level:3},{value:"Pattern 8: Two Arrays Sliding Window",id:"pattern-8-two-arrays-sliding-window",level:2},{value:"8.1 Cross Array Operations",id:"81-cross-array-operations",level:3},{value:"Pattern 9: Advanced Sliding Window Techniques",id:"pattern-9-advanced-sliding-window-techniques",level:2},{value:"9.1 Complex Problem Solving",id:"91-complex-problem-solving",level:3},{value:"Time &amp; Space Complexity Reference",id:"time--space-complexity-reference",level:2},{value:"Best Practices &amp; Interview Tips",id:"best-practices--interview-tips",level:2},{value:"Sliding Window Guidelines",id:"sliding-window-guidelines",level:3},{value:"Pattern 10: Sliding Window Optimization",id:"pattern-10-sliding-window-optimization",level:2},{value:"10.1 Memory and Time Optimizations",id:"101-memory-and-time-optimizations",level:3},{value:"Pattern 11: Real-World Applications",id:"pattern-11-real-world-applications",level:2},{value:"11.1 Practical Sliding Window Use Cases",id:"111-practical-sliding-window-use-cases",level:3},{value:"Pattern 12: Complex Sliding Window Problems",id:"pattern-12-complex-sliding-window-problems",level:2},{value:"12.1 Advanced Problem Solutions",id:"121-advanced-problem-solutions",level:3},{value:"Common Pitfalls to Avoid",id:"common-pitfalls-to-avoid",level:3},{value:"Interview Tips",id:"interview-tips",level:3},{value:"Summary and Conclusion",id:"summary-and-conclusion",level:2},{value:"Sliding Window Pattern Recognition",id:"sliding-window-pattern-recognition",level:3}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"sliding-window",children:"Sliding Window"})}),"\n",(0,t.jsx)(e.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#sliding-window-fundamentals",children:"Sliding Window Fundamentals"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-1-fixed-size-sliding-window",children:"Pattern 1: Fixed Size Sliding Window"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-2-variable-size-sliding-window",children:"Pattern 2: Variable Size Sliding Window"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-3-sliding-window-with-hashmap",children:"Pattern 3: Sliding Window with HashMap"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-4-sliding-window-maximumminimum",children:"Pattern 4: Sliding Window Maximum/Minimum"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-5-string-matching-with-sliding-window",children:"Pattern 5: String Matching with Sliding Window"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-6-multiple-pointers-sliding-window",children:"Pattern 6: Multiple Pointers Sliding Window"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-7-sliding-window-with-deque",children:"Pattern 7: Sliding Window with Deque"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-8-two-arrays-sliding-window",children:"Pattern 8: Two Arrays Sliding Window"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-9-advanced-sliding-window-techniques",children:"Pattern 9: Advanced Sliding Window Techniques"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-10-sliding-window-optimization",children:"Pattern 10: Sliding Window Optimization"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-11-real-world-applications",children:"Pattern 11: Real-World Applications"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-12-complex-sliding-window-problems",children:"Pattern 12: Complex Sliding Window Problems"})}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"sliding-window-fundamentals",children:"Sliding Window Fundamentals"}),"\n",(0,t.jsx)(e.h3,{id:"core-concepts-and-implementation",children:"Core Concepts and Implementation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:'// Basic Sliding Window Implementation\npublic class SlidingWindowFundamentals {\n\n    // Template for Fixed Size Sliding Window\n    public static class FixedWindowTemplate {\n\n        // Generic template for fixed size window problems\n        public int fixedSizeWindowTemplate(int[] nums, int windowSize) {\n            if (nums.length < windowSize) return -1;\n\n            // Calculate sum/value of first window\n            int windowSum = 0;\n            for (int i = 0; i < windowSize; i++) {\n                windowSum += nums[i];\n            }\n\n            int result = windowSum; // or any other calculation\n\n            // Slide the window\n            for (int i = windowSize; i < nums.length; i++) {\n                // Remove element going out of window\n                windowSum -= nums[i - windowSize];\n                // Add new element coming into window\n                windowSum += nums[i];\n\n                // Update result based on problem requirement\n                result = Math.max(result, windowSum); // or any other operation\n            }\n\n            return result;\n        }\n\n        // Maximum sum of subarray of size k\n        public int maxSumSubarray(int[] nums, int k) {\n            if (nums.length < k) return Integer.MIN_VALUE;\n\n            int windowSum = 0;\n\n            // Calculate sum of first window\n            for (int i = 0; i < k; i++) {\n                windowSum += nums[i];\n            }\n\n            int maxSum = windowSum;\n\n            // Slide window and find maximum\n            for (int i = k; i < nums.length; i++) {\n                windowSum = windowSum - nums[i - k] + nums[i];\n                maxSum = Math.max(maxSum, windowSum);\n            }\n\n            return maxSum;\n        }\n\n        // Average of all subarrays of size k\n        public double[] findAverages(int[] arr, int k) {\n            double[] result = new double[arr.length - k + 1];\n            double windowSum = 0;\n\n            // Calculate sum of first window\n            for (int i = 0; i < k; i++) {\n                windowSum += arr[i];\n            }\n            result[0] = windowSum / k;\n\n            // Slide window and calculate averages\n            for (int i = k; i < arr.length; i++) {\n                windowSum = windowSum - arr[i - k] + arr[i];\n                result[i - k + 1] = windowSum / k;\n            }\n\n            return result;\n        }\n    }\n\n    // Template for Variable Size Sliding Window\n    public static class VariableWindowTemplate {\n\n        // Generic template for variable size window problems\n        public int variableSizeWindowTemplate(int[] nums, int condition) {\n            int left = 0;\n            int windowValue = 0; // sum, product, etc.\n            int result = 0; // or Integer.MAX_VALUE for minimum problems\n\n            for (int right = 0; right < nums.length; right++) {\n                // Expand window by including nums[right]\n                windowValue += nums[right]; // or any other operation\n\n                // Shrink window while condition is violated\n                while (windowValue > condition) { // or any other condition\n                    windowValue -= nums[left];\n                    left++;\n                }\n\n                // Update result\n                result = Math.max(result, right - left + 1); // or any other calculation\n            }\n\n            return result;\n        }\n\n        // Longest subarray with sum <= target\n        public int longestSubarrayWithSumAtMost(int[] nums, int target) {\n            int left = 0;\n            int sum = 0;\n            int maxLength = 0;\n\n            for (int right = 0; right < nums.length; right++) {\n                sum += nums[right];\n\n                // Shrink window while sum exceeds target\n                while (sum > target) {\n                    sum -= nums[left];\n                    left++;\n                }\n\n                maxLength = Math.max(maxLength, right - left + 1);\n            }\n\n            return maxLength;\n        }\n\n        // Smallest subarray with sum >= target\n        public int minSubArrayLen(int target, int[] nums) {\n            int left = 0;\n            int sum = 0;\n            int minLength = Integer.MAX_VALUE;\n\n            for (int right = 0; right < nums.length; right++) {\n                sum += nums[right];\n\n                // Shrink window while sum >= target\n                while (sum >= target) {\n                    minLength = Math.min(minLength, right - left + 1);\n                    sum -= nums[left];\n                    left++;\n                }\n            }\n\n            return minLength == Integer.MAX_VALUE ? 0 : minLength;\n        }\n    }\n\n    // Sliding Window Utilities\n    public static class SlidingWindowUtils {\n\n        // Check if sliding window technique is applicable\n        public static boolean isApplicable(String problemDescription) {\n            String[] keywords = {\n                "subarray", "substring", "contiguous", "window",\n                "consecutive", "range", "interval"\n            };\n\n            String lowerDesc = problemDescription.toLowerCase();\n            for (String keyword : keywords) {\n                if (lowerDesc.contains(keyword)) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        // Determine window type based on problem constraints\n        public static String determineWindowType(boolean hasFixedSize,\n                                               boolean hasCondition,\n                                               boolean needsOptimization) {\n            if (hasFixedSize) {\n                return "Fixed Size Sliding Window";\n            } else if (hasCondition) {\n                return "Variable Size Sliding Window";\n            } else if (needsOptimization) {\n                return "Sliding Window with Data Structures";\n            } else {\n                return "Two Pointers or Other Technique";\n            }\n        }\n\n        // Calculate all possible window sizes for debugging\n        public static void printAllWindows(int[] nums, int maxWindowSize) {\n            for (int windowSize = 1; windowSize <= maxWindowSize; windowSize++) {\n                System.out.println("Window size " + windowSize + ":");\n\n                for (int i = 0; i <= nums.length - windowSize; i++) {\n                    System.out.print("[");\n                    for (int j = i; j < i + windowSize; j++) {\n                        System.out.print(nums[j]);\n                        if (j < i + windowSize - 1) System.out.print(", ");\n                    }\n                    System.out.print("] ");\n                }\n                System.out.println();\n            }\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-1-fixed-size-sliding-window",children:"Pattern 1: Fixed Size Sliding Window"}),"\n",(0,t.jsx)(e.h3,{id:"11-basic-fixed-window-problems",children:"1.1 Basic Fixed Window Problems"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Fixed size sliding window problems\npublic class FixedSizeSliding Window {\n\n    // Maximum sum subarray of size k\n    public int maxSumSubarray(int[] nums, int k) {\n        if (nums.length < k) return Integer.MIN_VALUE;\n\n        // Calculate sum of first window\n        int windowSum = 0;\n        for (int i = 0; i < k; i++) {\n            windowSum += nums[i];\n        }\n\n        int maxSum = windowSum;\n\n        // Slide the window\n        for (int i = k; i < nums.length; i++) {\n            windowSum = windowSum - nums[i - k] + nums[i];\n            maxSum = Math.max(maxSum, windowSum);\n        }\n\n        return maxSum;\n    }\n\n    // First negative integer in every window of size k\n    public int[] firstNegativeInWindow(int[] nums, int k) {\n        int[] result = new int[nums.length - k + 1];\n        Queue<Integer> negatives = new LinkedList<>(); // Store indices\n\n        // Process first window\n        for (int i = 0; i < k; i++) {\n            if (nums[i] < 0) {\n                negatives.offer(i);\n            }\n        }\n        result[0] = negatives.isEmpty() ? 0 : nums[negatives.peek()];\n\n        // Slide the window\n        for (int i = k; i < nums.length; i++) {\n            // Remove elements outside current window\n            while (!negatives.isEmpty() && negatives.peek() <= i - k) {\n                negatives.poll();\n            }\n\n            // Add current element if negative\n            if (nums[i] < 0) {\n                negatives.offer(i);\n            }\n\n            result[i - k + 1] = negatives.isEmpty() ? 0 : nums[negatives.peek()];\n        }\n\n        return result;\n    }\n\n    // Count occurrences of anagrams in string\n    public int countAnagrams(String text, String pattern) {\n        if (text.length() < pattern.length()) return 0;\n\n        // Count characters in pattern\n        Map<Character, Integer> patternCount = new HashMap<>();\n        for (char c : pattern.toCharArray()) {\n            patternCount.put(c, patternCount.getOrDefault(c, 0) + 1);\n        }\n\n        Map<Character, Integer> windowCount = new HashMap<>();\n        int windowSize = pattern.length();\n        int count = 0;\n\n        // Process first window\n        for (int i = 0; i < windowSize; i++) {\n            char c = text.charAt(i);\n            windowCount.put(c, windowCount.getOrDefault(c, 0) + 1);\n        }\n\n        if (windowCount.equals(patternCount)) {\n            count++;\n        }\n\n        // Slide the window\n        for (int i = windowSize; i < text.length(); i++) {\n            // Add new character\n            char newChar = text.charAt(i);\n            windowCount.put(newChar, windowCount.getOrDefault(newChar, 0) + 1);\n\n            // Remove old character\n            char oldChar = text.charAt(i - windowSize);\n            windowCount.put(oldChar, windowCount.get(oldChar) - 1);\n            if (windowCount.get(oldChar) == 0) {\n                windowCount.remove(oldChar);\n            }\n\n            // Check if current window is anagram\n            if (windowCount.equals(patternCount)) {\n                count++;\n            }\n        }\n\n        return count;\n    }\n\n    // Maximum of all subarrays of size k\n    public int[] maxInWindows(int[] nums, int k) {\n        int[] result = new int[nums.length - k + 1];\n        Deque<Integer> deque = new ArrayDeque<>(); // Store indices\n\n        for (int i = 0; i < nums.length; i++) {\n            // Remove indices outside current window\n            while (!deque.isEmpty() && deque.peekFirst() <= i - k) {\n                deque.pollFirst();\n            }\n\n            // Remove indices of smaller elements\n            while (!deque.isEmpty() && nums[deque.peekLast()] <= nums[i]) {\n                deque.pollLast();\n            }\n\n            deque.offerLast(i);\n\n            // Add to result when window is complete\n            if (i >= k - 1) {\n                result[i - k + 1] = nums[deque.peekFirst()];\n            }\n        }\n\n        return result;\n    }\n\n    // Count distinct elements in every window of size k\n    public int[] countDistinctInWindow(int[] nums, int k) {\n        int[] result = new int[nums.length - k + 1];\n        Map<Integer, Integer> freqMap = new HashMap<>();\n\n        // Process first window\n        for (int i = 0; i < k; i++) {\n            freqMap.put(nums[i], freqMap.getOrDefault(nums[i], 0) + 1);\n        }\n        result[0] = freqMap.size();\n\n        // Slide the window\n        for (int i = k; i < nums.length; i++) {\n            // Add new element\n            freqMap.put(nums[i], freqMap.getOrDefault(nums[i], 0) + 1);\n\n            // Remove old element\n            int oldElement = nums[i - k];\n            freqMap.put(oldElement, freqMap.get(oldElement) - 1);\n            if (freqMap.get(oldElement) == 0) {\n                freqMap.remove(oldElement);\n            }\n\n            result[i - k + 1] = freqMap.size();\n        }\n\n        return result;\n    }\n\n    // Minimum window size with sum >= target\n    public int minWindowSumGreaterEqual(int[] nums, int target) {\n        int minLength = Integer.MAX_VALUE;\n\n        // Try all possible window sizes\n        for (int windowSize = 1; windowSize <= nums.length; windowSize++) {\n            // Check if any window of this size has sum >= target\n            int windowSum = 0;\n\n            // Calculate sum of first window\n            for (int i = 0; i < windowSize; i++) {\n                windowSum += nums[i];\n            }\n\n            if (windowSum >= target) {\n                return windowSize;\n            }\n\n            // Slide the window\n            for (int i = windowSize; i < nums.length; i++) {\n                windowSum = windowSum - nums[i - windowSize] + nums[i];\n                if (windowSum >= target) {\n                    return windowSize;\n                }\n            }\n        }\n\n        return minLength == Integer.MAX_VALUE ? -1 : minLength;\n    }\n\n    // Maximum average subarray\n    public double findMaxAverage(int[] nums, int k) {\n        // Calculate sum of first window\n        long sum = 0;\n        for (int i = 0; i < k; i++) {\n            sum += nums[i];\n        }\n\n        long maxSum = sum;\n\n        // Slide the window\n        for (int i = k; i < nums.length; i++) {\n            sum = sum - nums[i - k] + nums[i];\n            maxSum = Math.max(maxSum, sum);\n        }\n\n        return (double) maxSum / k;\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"12-advanced-fixed-window-problems",children:"1.2 Advanced Fixed Window Problems"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Advanced fixed size window problems\npublic class AdvancedFixedWindow {\n\n    // Sliding window median\n    public double[] medianSlidingWindow(int[] nums, int k) {\n        double[] result = new double[nums.length - k + 1];\n\n        // Use two heaps to maintain median\n        PriorityQueue<Integer> small = new PriorityQueue<>(Collections.reverseOrder()); // max heap\n        PriorityQueue<Integer> large = new PriorityQueue<>(); // min heap\n\n        for (int i = 0; i < nums.length; i++) {\n            // Add current element\n            if (small.isEmpty() || nums[i] <= small.peek()) {\n                small.offer(nums[i]);\n            } else {\n                large.offer(nums[i]);\n            }\n\n            // Remove element going out of window\n            if (i >= k) {\n                int elementToRemove = nums[i - k];\n                if (elementToRemove <= small.peek()) {\n                    small.remove(elementToRemove);\n                } else {\n                    large.remove(elementToRemove);\n                }\n            }\n\n            // Balance heaps\n            balanceHeaps(small, large);\n\n            // Calculate median when window is full\n            if (i >= k - 1) {\n                double median;\n                if (small.size() == large.size()) {\n                    median = ((long) small.peek() + large.peek()) / 2.0;\n                } else {\n                    median = small.peek();\n                }\n                result[i - k + 1] = median;\n            }\n        }\n\n        return result;\n    }\n\n    private void balanceHeaps(PriorityQueue<Integer> small, PriorityQueue<Integer> large) {\n        if (small.size() > large.size() + 1) {\n            large.offer(small.poll());\n        } else if (large.size() > small.size() + 1) {\n            small.offer(large.poll());\n        }\n    }\n\n    // Maximum sum of k consecutive elements with no adjacent elements\n    public int maxSumNoAdjacent(int[] nums, int k) {\n        if (k * 2 - 1 > nums.length) return -1;\n\n        int maxSum = 0;\n\n        // Try all possible starting positions\n        for (int start = 0; start <= nums.length - (k * 2 - 1); start++) {\n            int sum = 0;\n            for (int i = 0; i < k; i++) {\n                sum += nums[start + i * 2]; // Take every alternate element\n            }\n            maxSum = Math.max(maxSum, sum);\n        }\n\n        return maxSum;\n    }\n\n    // Count subarrays of size k with all elements distinct\n    public int countDistinctSubarrays(int[] nums, int k) {\n        int count = 0;\n\n        for (int i = 0; i <= nums.length - k; i++) {\n            Set<Integer> distinct = new HashSet<>();\n\n            for (int j = i; j < i + k; j++) {\n                distinct.add(nums[j]);\n            }\n\n            if (distinct.size() == k) {\n                count++;\n            }\n        }\n\n        return count;\n    }\n\n    // Optimized version using sliding window\n    public int countDistinctSubarraysOptimized(int[] nums, int k) {\n        Map<Integer, Integer> freqMap = new HashMap<>();\n        int count = 0;\n\n        // Process first window\n        for (int i = 0; i < k; i++) {\n            freqMap.put(nums[i], freqMap.getOrDefault(nums[i], 0) + 1);\n        }\n\n        if (freqMap.size() == k) {\n            count++;\n        }\n\n        // Slide the window\n        for (int i = k; i < nums.length; i++) {\n            // Add new element\n            freqMap.put(nums[i], freqMap.getOrDefault(nums[i], 0) + 1);\n\n            // Remove old element\n            int oldElement = nums[i - k];\n            freqMap.put(oldElement, freqMap.get(oldElement) - 1);\n            if (freqMap.get(oldElement) == 0) {\n                freqMap.remove(oldElement);\n            }\n\n            if (freqMap.size() == k) {\n                count++;\n            }\n        }\n\n        return count;\n    }\n\n    // Maximum points from cards (choose k cards from start or end)\n    public int maxScore(int[] cardPoints, int k) {\n        int n = cardPoints.length;\n\n        // Calculate sum of first k cards from start\n        int currentScore = 0;\n        for (int i = 0; i < k; i++) {\n            currentScore += cardPoints[i];\n        }\n\n        int maxScore = currentScore;\n\n        // Try replacing cards from start with cards from end\n        for (int i = 0; i < k; i++) {\n            // Remove one card from start, add one card from end\n            currentScore = currentScore - cardPoints[k - 1 - i] + cardPoints[n - 1 - i];\n            maxScore = Math.max(maxScore, currentScore);\n        }\n\n        return maxScore;\n    }\n\n    // Minimum swaps to group all 1s together\n    public int minSwaps(int[] data) {\n        int totalOnes = 0;\n        for (int num : data) {\n            if (num == 1) totalOnes++;\n        }\n\n        if (totalOnes <= 1) return 0;\n\n        // Count 1s in first window of size totalOnes\n        int onesInWindow = 0;\n        for (int i = 0; i < totalOnes; i++) {\n            if (data[i] == 1) onesInWindow++;\n        }\n\n        int maxOnesInWindow = onesInWindow;\n\n        // Slide the window\n        for (int i = totalOnes; i < data.length; i++) {\n            // Remove element going out\n            if (data[i - totalOnes] == 1) onesInWindow--;\n            // Add element coming in\n            if (data[i] == 1) onesInWindow++;\n\n            maxOnesInWindow = Math.max(maxOnesInWindow, onesInWindow);\n        }\n\n        return totalOnes - maxOnesInWindow;\n    }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-2-variable-size-sliding-window",children:"Pattern 2: Variable Size Sliding Window"}),"\n",(0,t.jsx)(e.h3,{id:"21-basic-variable-window-problems",children:"2.1 Basic Variable Window Problems"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:'// Variable size sliding window problems\npublic class VariableSizeSliding Window {\n\n    // Longest substring without repeating characters\n    public int lengthOfLongestSubstring(String s) {\n        Set<Character> window = new HashSet<>();\n        int left = 0;\n        int maxLength = 0;\n\n        for (int right = 0; right < s.length(); right++) {\n            // Shrink window while character exists\n            while (window.contains(s.charAt(right))) {\n                window.remove(s.charAt(left));\n                left++;\n            }\n\n            window.add(s.charAt(right));\n            maxLength = Math.max(maxLength, right - left + 1);\n        }\n\n        return maxLength;\n    }\n\n    // Longest substring with at most k distinct characters\n    public int lengthOfLongestSubstringKDistinct(String s, int k) {\n        if (k == 0) return 0;\n\n        Map<Character, Integer> charCount = new HashMap<>();\n        int left = 0;\n        int maxLength = 0;\n\n        for (int right = 0; right < s.length(); right++) {\n            char rightChar = s.charAt(right);\n            charCount.put(rightChar, charCount.getOrDefault(rightChar, 0) + 1);\n\n            // Shrink window while more than k distinct characters\n            while (charCount.size() > k) {\n                char leftChar = s.charAt(left);\n                charCount.put(leftChar, charCount.get(leftChar) - 1);\n                if (charCount.get(leftChar) == 0) {\n                    charCount.remove(leftChar);\n                }\n                left++;\n            }\n\n            maxLength = Math.max(maxLength, right - left + 1);\n        }\n\n        return maxLength;\n    }\n\n    // Minimum window substring\n    public String minWindow(String s, String t) {\n        if (s.length() < t.length()) return "";\n\n        Map<Character, Integer> targetCount = new HashMap<>();\n        for (char c : t.toCharArray()) {\n            targetCount.put(c, targetCount.getOrDefault(c, 0) + 1);\n        }\n\n        Map<Character, Integer> windowCount = new HashMap<>();\n        int left = 0;\n        int minLength = Integer.MAX_VALUE;\n        int minStart = 0;\n        int formed = 0;\n        int required = targetCount.size();\n\n        for (int right = 0; right < s.length(); right++) {\n            char rightChar = s.charAt(right);\n            windowCount.put(rightChar, windowCount.getOrDefault(rightChar, 0) + 1);\n\n            if (targetCount.containsKey(rightChar) &&\n                windowCount.get(rightChar).intValue() == targetCount.get(rightChar).intValue()) {\n                formed++;\n            }\n\n            // Shrink window while it\'s valid\n            while (left <= right && formed == required) {\n                if (right - left + 1 < minLength) {\n                    minLength = right - left + 1;\n                    minStart = left;\n                }\n\n                char leftChar = s.charAt(left);\n                windowCount.put(leftChar, windowCount.get(leftChar) - 1);\n                if (targetCount.containsKey(leftChar) &&\n                    windowCount.get(leftChar) < targetCount.get(leftChar)) {\n                    formed--;\n                }\n                left++;\n            }\n        }\n\n        return minLength == Integer.MAX_VALUE ? "" : s.substring(minStart, minStart + minLength);\n    }\n\n    // Longest subarray with sum <= target\n    public int longestSubarrayWithSum(int[] nums, int target) {\n        int left = 0;\n        int sum = 0;\n        int maxLength = 0;\n\n        for (int right = 0; right < nums.length; right++) {\n            sum += nums[right];\n\n            // Shrink window while sum exceeds target\n            while (sum > target) {\n                sum -= nums[left];\n                left++;\n            }\n\n            maxLength = Math.max(maxLength, right - left + 1);\n        }\n\n        return maxLength;\n    }\n\n    // Longest subarray with at most k zeros\n    public int longestOnes(int[] nums, int k) {\n        int left = 0;\n        int zeros = 0;\n        int maxLength = 0;\n\n        for (int right = 0; right < nums.length; right++) {\n            if (nums[right] == 0) {\n                zeros++;\n            }\n\n            // Shrink window while zeros exceed k\n            while (zeros > k) {\n                if (nums[left] == 0) {\n                    zeros--;\n                }\n                left++;\n            }\n\n            maxLength = Math.max(maxLength, right - left + 1);\n        }\n\n        return maxLength;\n    }\n\n    // Smallest subarray with sum >= target\n    public int minSubArrayLen(int target, int[] nums) {\n        int left = 0;\n        int sum = 0;\n        int minLength = Integer.MAX_VALUE;\n\n        for (int right = 0; right < nums.length; right++) {\n            sum += nums[right];\n\n            // Shrink window while sum >= target\n            while (sum >= target) {\n                minLength = Math.min(minLength, right - left + 1);\n                sum -= nums[left];\n                left++;\n            }\n        }\n\n        return minLength == Integer.MAX_VALUE ? 0 : minLength;\n    }\n\n    // Fruit into baskets (at most 2 types)\n    public int totalFruit(int[] fruits) {\n        Map<Integer, Integer> fruitCount = new HashMap<>();\n        int left = 0;\n        int maxFruits = 0;\n\n        for (int right = 0; right < fruits.length; right++) {\n            fruitCount.put(fruits[right], fruitCount.getOrDefault(fruits[right], 0) + 1);\n\n            // Shrink window while more than 2 types\n            while (fruitCount.size() > 2) {\n                int leftFruit = fruits[left];\n                fruitCount.put(leftFruit, fruitCount.get(leftFruit) - 1);\n                if (fruitCount.get(leftFruit) == 0) {\n                    fruitCount.remove(leftFruit);\n                }\n                left++;\n            }\n\n            maxFruits = Math.max(maxFruits, right - left + 1);\n        }\n\n        return maxFruits;\n    }\n\n    // Longest repeating character replacement\n    public int characterReplacement(String s, int k) {\n        Map<Character, Integer> charCount = new HashMap<>();\n        int left = 0;\n        int maxLength = 0;\n        int maxFreq = 0;\n\n        for (int right = 0; right < s.length(); right++) {\n            char rightChar = s.charAt(right);\n            charCount.put(rightChar, charCount.getOrDefault(rightChar, 0) + 1);\n            maxFreq = Math.max(maxFreq, charCount.get(rightChar));\n\n            // Shrink window if replacements needed > k\n            while (right - left + 1 - maxFreq > k) {\n                char leftChar = s.charAt(left);\n                charCount.put(leftChar, charCount.get(leftChar) - 1);\n                left++;\n            }\n\n            maxLength = Math.max(maxLength, right - left + 1);\n        }\n\n        return maxLength;\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"22-advanced-variable-window-problems",children:"2.2 Advanced Variable Window Problems"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:'// Advanced variable size window problems\npublic class AdvancedVariableWindow {\n\n    // Subarrays with k different integers\n    public int subarraysWithKDistinct(int[] nums, int k) {\n        return atMostK(nums, k) - atMostK(nums, k - 1);\n    }\n\n    private int atMostK(int[] nums, int k) {\n        Map<Integer, Integer> count = new HashMap<>();\n        int left = 0;\n        int result = 0;\n\n        for (int right = 0; right < nums.length; right++) {\n            count.put(nums[right], count.getOrDefault(nums[right], 0) + 1);\n\n            while (count.size() > k) {\n                count.put(nums[left], count.get(nums[left]) - 1);\n                if (count.get(nums[left]) == 0) {\n                    count.remove(nums[left]);\n                }\n                left++;\n            }\n\n            result += right - left + 1;\n        }\n\n        return result;\n    }\n\n    // Number of nice subarrays (exactly k odd numbers)\n    public int numberOfSubarrays(int[] nums, int k) {\n        return atMostKOdd(nums, k) - atMostKOdd(nums, k - 1);\n    }\n\n    private int atMostKOdd(int[] nums, int k) {\n        int left = 0;\n        int oddCount = 0;\n        int result = 0;\n\n        for (int right = 0; right < nums.length; right++) {\n            if (nums[right] % 2 == 1) {\n                oddCount++;\n            }\n\n            while (oddCount > k) {\n                if (nums[left] % 2 == 1) {\n                    oddCount--;\n                }\n                left++;\n            }\n\n            result += right - left + 1;\n        }\n\n        return result;\n    }\n\n    // Subarray product less than k\n    public int numSubarrayProductLessThanK(int[] nums, int k) {\n        if (k <= 1) return 0;\n\n        int left = 0;\n        int product = 1;\n        int count = 0;\n\n        for (int right = 0; right < nums.length; right++) {\n            product *= nums[right];\n\n            while (product >= k) {\n                product /= nums[left];\n                left++;\n            }\n\n            count += right - left + 1;\n        }\n\n        return count;\n    }\n\n    // Longest substring with at least k repeating characters\n    public int longestSubstring(String s, int k) {\n        Map<Character, Integer> charCount = new HashMap<>();\n\n        // Count frequency of each character\n        for (char c : s.toCharArray()) {\n            charCount.put(c, charCount.getOrDefault(c, 0) + 1);\n        }\n\n        // Find characters with frequency < k\n        Set<Character> invalidChars = new HashSet<>();\n        for (Map.Entry<Character, Integer> entry : charCount.entrySet()) {\n            if (entry.getValue() < k) {\n                invalidChars.add(entry.getKey());\n            }\n        }\n\n        if (invalidChars.isEmpty()) {\n            return s.length();\n        }\n\n        // Split string by invalid characters and recursively solve\n        int maxLength = 0;\n        int start = 0;\n\n        for (int i = 0; i <= s.length(); i++) {\n            if (i == s.length() || invalidChars.contains(s.charAt(i))) {\n                if (i > start) {\n                    maxLength = Math.max(maxLength,\n                                       longestSubstring(s.substring(start, i), k));\n                }\n                start = i + 1;\n            }\n        }\n\n        return maxLength;\n    }\n\n    // Minimum window with character frequency\n    public String minWindowWithFreq(String s, Map<Character, Integer> targetFreq) {\n        Map<Character, Integer> windowFreq = new HashMap<>();\n        int left = 0;\n        int minLength = Integer.MAX_VALUE;\n        int minStart = 0;\n        int validChars = 0;\n        int requiredChars = targetFreq.size();\n\n        for (int right = 0; right < s.length(); right++) {\n            char rightChar = s.charAt(right);\n            windowFreq.put(rightChar, windowFreq.getOrDefault(rightChar, 0) + 1);\n\n            if (targetFreq.containsKey(rightChar) &&\n                windowFreq.get(rightChar).intValue() == targetFreq.get(rightChar).intValue()) {\n                validChars++;\n            }\n\n            while (validChars == requiredChars) {\n                if (right - left + 1 < minLength) {\n                    minLength = right - left + 1;\n                    minStart = left;\n                }\n\n                char leftChar = s.charAt(left);\n                windowFreq.put(leftChar, windowFreq.get(leftChar) - 1);\n\n                if (targetFreq.containsKey(leftChar) &&\n                    windowFreq.get(leftChar) < targetFreq.get(leftChar)) {\n                    validChars--;\n                }\n                left++;\n            }\n        }\n\n        return minLength == Integer.MAX_VALUE ? "" : s.substring(minStart, minStart + minLength);\n    }\n\n    // Maximum erasure value (sum of unique elements in subarray)\n    public int maximumUniqueSubarray(int[] nums) {\n        Set<Integer> seen = new HashSet<>();\n        int left = 0;\n        int sum = 0;\n        int maxSum = 0;\n\n        for (int right = 0; right < nums.length; right++) {\n            while (seen.contains(nums[right])) {\n                seen.remove(nums[left]);\n                sum -= nums[left];\n                left++;\n            }\n\n            seen.add(nums[right]);\n            sum += nums[right];\n            maxSum = Math.max(maxSum, sum);\n        }\n\n        return maxSum;\n    }\n}\n'})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-3-sliding-window-with-hashmap",children:"Pattern 3: Sliding Window with HashMap"}),"\n",(0,t.jsx)(e.h3,{id:"31-character-frequency-problems",children:"3.1 Character Frequency Problems"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:'// Sliding window problems using HashMap for frequency tracking\npublic class SlidingWindowHashMap {\n\n    // Find all anagrams in a string\n    public List<Integer> findAnagrams(String s, String p) {\n        List<Integer> result = new ArrayList<>();\n        if (s.length() < p.length()) return result;\n\n        Map<Character, Integer> pCount = new HashMap<>();\n        Map<Character, Integer> windowCount = new HashMap<>();\n\n        // Count characters in pattern\n        for (char c : p.toCharArray()) {\n            pCount.put(c, pCount.getOrDefault(c, 0) + 1);\n        }\n\n        int windowSize = p.length();\n\n        // Process first window\n        for (int i = 0; i < windowSize; i++) {\n            char c = s.charAt(i);\n            windowCount.put(c, windowCount.getOrDefault(c, 0) + 1);\n        }\n\n        if (windowCount.equals(pCount)) {\n            result.add(0);\n        }\n\n        // Slide the window\n        for (int i = windowSize; i < s.length(); i++) {\n            // Add new character\n            char newChar = s.charAt(i);\n            windowCount.put(newChar, windowCount.getOrDefault(newChar, 0) + 1);\n\n            // Remove old character\n            char oldChar = s.charAt(i - windowSize);\n            windowCount.put(oldChar, windowCount.get(oldChar) - 1);\n            if (windowCount.get(oldChar) == 0) {\n                windowCount.remove(oldChar);\n            }\n\n            if (windowCount.equals(pCount)) {\n                result.add(i - windowSize + 1);\n            }\n        }\n\n        return result;\n    }\n\n    // Permutation in string\n    public boolean checkInclusion(String s1, String s2) {\n        if (s1.length() > s2.length()) return false;\n\n        Map<Character, Integer> s1Count = new HashMap<>();\n        for (char c : s1.toCharArray()) {\n            s1Count.put(c, s1Count.getOrDefault(c, 0) + 1);\n        }\n\n        Map<Character, Integer> windowCount = new HashMap<>();\n        int windowSize = s1.length();\n\n        // Process first window\n        for (int i = 0; i < windowSize; i++) {\n            char c = s2.charAt(i);\n            windowCount.put(c, windowCount.getOrDefault(c, 0) + 1);\n        }\n\n        if (windowCount.equals(s1Count)) return true;\n\n        // Slide the window\n        for (int i = windowSize; i < s2.length(); i++) {\n            // Add new character\n            char newChar = s2.charAt(i);\n            windowCount.put(newChar, windowCount.getOrDefault(newChar, 0) + 1);\n\n            // Remove old character\n            char oldChar = s2.charAt(i - windowSize);\n            windowCount.put(oldChar, windowCount.get(oldChar) - 1);\n            if (windowCount.get(oldChar) == 0) {\n                windowCount.remove(oldChar);\n            }\n\n            if (windowCount.equals(s1Count)) return true;\n        }\n\n        return false;\n    }\n\n    // Longest substring with exactly k distinct characters\n    public int longestSubstringExactlyKDistinct(String s, int k) {\n        if (k == 0 || s.isEmpty()) return 0;\n\n        Map<Character, Integer> charCount = new HashMap<>();\n        int left = 0;\n        int maxLength = 0;\n\n        for (int right = 0; right < s.length(); right++) {\n            char rightChar = s.charAt(right);\n            charCount.put(rightChar, charCount.getOrDefault(rightChar, 0) + 1);\n\n            // Shrink window while more than k distinct characters\n            while (charCount.size() > k) {\n                char leftChar = s.charAt(left);\n                charCount.put(leftChar, charCount.get(leftChar) - 1);\n                if (charCount.get(leftChar) == 0) {\n                    charCount.remove(leftChar);\n                }\n                left++;\n            }\n\n            // Update maxLength only when we have exactly k distinct characters\n            if (charCount.size() == k) {\n                maxLength = Math.max(maxLength, right - left + 1);\n            }\n        }\n\n        return maxLength;\n    }\n\n    // Smallest window containing all characters of another string\n    public String smallestWindow(String s, String t) {\n        Map<Character, Integer> tCount = new HashMap<>();\n        for (char c : t.toCharArray()) {\n            tCount.put(c, tCount.getOrDefault(c, 0) + 1);\n        }\n\n        Map<Character, Integer> windowCount = new HashMap<>();\n        int left = 0;\n        int minLength = Integer.MAX_VALUE;\n        int minStart = 0;\n        int matched = 0;\n\n        for (int right = 0; right < s.length(); right++) {\n            char rightChar = s.charAt(right);\n\n            if (tCount.containsKey(rightChar)) {\n                windowCount.put(rightChar, windowCount.getOrDefault(rightChar, 0) + 1);\n                if (windowCount.get(rightChar).intValue() == tCount.get(rightChar).intValue()) {\n                    matched++;\n                }\n            }\n\n            // Shrink window while all characters are matched\n            while (matched == tCount.size()) {\n                if (right - left + 1 < minLength) {\n                    minLength = right - left + 1;\n                    minStart = left;\n                }\n\n                char leftChar = s.charAt(left);\n                if (tCount.containsKey(leftChar)) {\n                    if (windowCount.get(leftChar).intValue() == tCount.get(leftChar).intValue()) {\n                        matched--;\n                    }\n                    windowCount.put(leftChar, windowCount.get(leftChar) - 1);\n                }\n                left++;\n            }\n        }\n\n        return minLength == Integer.MAX_VALUE ? "" : s.substring(minStart, minStart + minLength);\n    }\n\n    // Count substrings with exactly k distinct characters\n    public int countSubstringExactlyKDistinct(String s, int k) {\n        return atMostKDistinct(s, k) - atMostKDistinct(s, k - 1);\n    }\n\n    private int atMostKDistinct(String s, int k) {\n        Map<Character, Integer> charCount = new HashMap<>();\n        int left = 0;\n        int count = 0;\n\n        for (int right = 0; right < s.length(); right++) {\n            char rightChar = s.charAt(right);\n            charCount.put(rightChar, charCount.getOrDefault(rightChar, 0) + 1);\n\n            while (charCount.size() > k) {\n                char leftChar = s.charAt(left);\n                charCount.put(leftChar, charCount.get(leftChar) - 1);\n                if (charCount.get(leftChar) == 0) {\n                    charCount.remove(leftChar);\n                }\n                left++;\n            }\n\n            count += right - left + 1;\n        }\n\n        return count;\n    }\n\n    // Longest substring with equal frequency of characters\n    public int longestSubstringEqualFreq(String s) {\n        int maxLength = 0;\n\n        // Try all possible starting positions\n        for (int start = 0; start < s.length(); start++) {\n            Map<Character, Integer> freq = new HashMap<>();\n\n            for (int end = start; end < s.length(); end++) {\n                char c = s.charAt(end);\n                freq.put(c, freq.getOrDefault(c, 0) + 1);\n\n                if (hasEqualFrequency(freq)) {\n                    maxLength = Math.max(maxLength, end - start + 1);\n                }\n            }\n        }\n\n        return maxLength;\n    }\n\n    private boolean hasEqualFrequency(Map<Character, Integer> freq) {\n        Set<Integer> frequencies = new HashSet<>(freq.values());\n        return frequencies.size() <= 1;\n    }\n\n    // Replace the substring for balanced string\n    public int balancedString(String s) {\n        Map<Character, Integer> count = new HashMap<>();\n        for (char c : s.toCharArray()) {\n            count.put(c, count.getOrDefault(c, 0) + 1);\n        }\n\n        int n = s.length();\n        int target = n / 4;\n\n        // Check if already balanced\n        boolean balanced = true;\n        for (int freq : count.values()) {\n            if (freq > target) {\n                balanced = false;\n                break;\n            }\n        }\n        if (balanced) return 0;\n\n        int left = 0;\n        int minLength = n;\n\n        for (int right = 0; right < n; right++) {\n            count.put(s.charAt(right), count.get(s.charAt(right)) - 1);\n\n            while (isBalanceable(count, target)) {\n                minLength = Math.min(minLength, right - left + 1);\n                count.put(s.charAt(left), count.get(s.charAt(left)) + 1);\n                left++;\n            }\n        }\n\n        return minLength;\n    }\n\n    private boolean isBalanceable(Map<Character, Integer> count, int target) {\n        for (char c : "QWER".toCharArray()) {\n            if (count.getOrDefault(c, 0) > target) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"32-advanced-hashmap-applications",children:"3.2 Advanced HashMap Applications"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Advanced sliding window with HashMap applications\npublic class AdvancedHashMapWindow {\n\n    // Shortest subarray to be removed to make array sorted\n    public int findLengthOfShortestSubarray(int[] arr) {\n        int n = arr.length;\n\n        // Find the longest non-decreasing prefix\n        int left = 0;\n        while (left < n - 1 && arr[left] <= arr[left + 1]) {\n            left++;\n        }\n\n        if (left == n - 1) return 0; // Array is already sorted\n\n        // Find the longest non-decreasing suffix\n        int right = n - 1;\n        while (right > 0 && arr[right - 1] <= arr[right]) {\n            right--;\n        }\n\n        // Minimum length considering removing suffix or prefix\n        int minLength = Math.min(n - left - 1, right);\n\n        // Try to merge prefix and suffix\n        int i = 0, j = right;\n        while (i <= left && j < n) {\n            if (arr[i] <= arr[j]) {\n                minLength = Math.min(minLength, j - i - 1);\n                i++;\n            } else {\n                j++;\n            }\n        }\n\n        return minLength;\n    }\n\n    // Frequency of the most frequent element after k operations\n    public int maxFrequency(int[] nums, int k) {\n        Arrays.sort(nums);\n\n        int left = 0;\n        long sum = 0;\n        int maxFreq = 1;\n\n        for (int right = 0; right < nums.length; right++) {\n            sum += nums[right];\n\n            // Shrink window while cost exceeds k\n            while ((long) nums[right] * (right - left + 1) - sum > k) {\n                sum -= nums[left];\n                left++;\n            }\n\n            maxFreq = Math.max(maxFreq, right - left + 1);\n        }\n\n        return maxFreq;\n    }\n\n    // Minimum operations to reduce X to zero\n    public int minOperations(int[] nums, int x) {\n        int target = Arrays.stream(nums).sum() - x;\n        if (target < 0) return -1;\n        if (target == 0) return nums.length;\n\n        // Find longest subarray with sum = target\n        Map<Integer, Integer> prefixSumIndex = new HashMap<>();\n        prefixSumIndex.put(0, -1);\n\n        int sum = 0;\n        int maxLength = -1;\n\n        for (int i = 0; i < nums.length; i++) {\n            sum += nums[i];\n\n            if (prefixSumIndex.containsKey(sum - target)) {\n                maxLength = Math.max(maxLength, i - prefixSumIndex.get(sum - target));\n            }\n\n            prefixSumIndex.put(sum, i);\n        }\n\n        return maxLength == -1 ? -1 : nums.length - maxLength;\n    }\n\n    // Subarrays with k odd numbers\n    public int numberOfSubarraysWithKOdd(int[] nums, int k) {\n        Map<Integer, Integer> prefixCount = new HashMap<>();\n        prefixCount.put(0, 1);\n\n        int count = 0;\n        int oddCount = 0;\n\n        for (int num : nums) {\n            if (num % 2 == 1) oddCount++;\n\n            count += prefixCount.getOrDefault(oddCount - k, 0);\n            prefixCount.put(oddCount, prefixCount.getOrDefault(oddCount, 0) + 1);\n        }\n\n        return count;\n    }\n\n    // Count vowel substrings of a string\n    public int countVowelSubstrings(String word) {\n        Set<Character> vowels = Set.of('a', 'e', 'i', 'o', 'u');\n        int count = 0;\n\n        for (int i = 0; i < word.length(); i++) {\n            Set<Character> seen = new HashSet<>();\n\n            for (int j = i; j < word.length(); j++) {\n                char c = word.charAt(j);\n\n                if (!vowels.contains(c)) {\n                    break; // Non-vowel character, break\n                }\n\n                seen.add(c);\n\n                if (seen.size() == 5) {\n                    count++;\n                }\n            }\n        }\n\n        return count;\n    }\n\n    // Longest substring of all vowels in order\n    public int longestBeautifulSubstring(String word) {\n        if (word.length() < 5) return 0;\n\n        String target = \"aeiou\";\n        int maxLength = 0;\n        int currentLength = 1;\n        int vowelIndex = 0;\n\n        for (int i = 1; i < word.length(); i++) {\n            char curr = word.charAt(i);\n            char prev = word.charAt(i - 1);\n\n            if (curr == prev) {\n                currentLength++;\n            } else if (vowelIndex < 4 && curr == target.charAt(vowelIndex + 1)) {\n                vowelIndex++;\n                currentLength++;\n            } else if (curr == 'a') {\n                vowelIndex = 0;\n                currentLength = 1;\n            } else {\n                vowelIndex = 0;\n                currentLength = 1;\n            }\n\n            if (vowelIndex == 4) {\n                maxLength = Math.max(maxLength, currentLength);\n            }\n        }\n\n        return maxLength;\n    }\n\n    // Count number of homogenous substrings\n    public int countHomogenous(String s) {\n        int MOD = 1000000007;\n        long count = 0;\n\n        int i = 0;\n        while (i < s.length()) {\n            int j = i;\n            while (j < s.length() && s.charAt(j) == s.charAt(i)) {\n                j++;\n            }\n\n            long len = j - i;\n            count = (count + len * (len + 1) / 2) % MOD;\n            i = j;\n        }\n\n        return (int) count;\n    }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-4-sliding-window-maximumminimum",children:"Pattern 4: Sliding Window Maximum/Minimum"}),"\n",(0,t.jsx)(e.h3,{id:"41-deque-based-window-extremes",children:"4.1 Deque-based Window Extremes"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Sliding window maximum and minimum using deque\npublic class SlidingWindowExtremes {\n\n    // Sliding window maximum using deque\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        Deque<Integer> deque = new ArrayDeque<>(); // Store indices\n        int[] result = new int[nums.length - k + 1];\n\n        for (int i = 0; i < nums.length; i++) {\n            // Remove indices outside current window\n            while (!deque.isEmpty() && deque.peekFirst() <= i - k) {\n                deque.pollFirst();\n            }\n\n            // Remove indices of smaller elements (maintain decreasing order)\n            while (!deque.isEmpty() && nums[deque.peekLast()] <= nums[i]) {\n                deque.pollLast();\n            }\n\n            deque.offerLast(i);\n\n            // Add to result when window is complete\n            if (i >= k - 1) {\n                result[i - k + 1] = nums[deque.peekFirst()];\n            }\n        }\n\n        return result;\n    }\n\n    // Sliding window minimum using deque\n    public int[] minSlidingWindow(int[] nums, int k) {\n        Deque<Integer> deque = new ArrayDeque<>();\n        int[] result = new int[nums.length - k + 1];\n\n        for (int i = 0; i < nums.length; i++) {\n            // Remove indices outside current window\n            while (!deque.isEmpty() && deque.peekFirst() <= i - k) {\n                deque.pollFirst();\n            }\n\n            // Remove indices of larger elements (maintain increasing order)\n            while (!deque.isEmpty() && nums[deque.peekLast()] >= nums[i]) {\n                deque.pollLast();\n            }\n\n            deque.offerLast(i);\n\n            if (i >= k - 1) {\n                result[i - k + 1] = nums[deque.peekFirst()];\n            }\n        }\n\n        return result;\n    }\n\n    // Constrained subsequence sum\n    public int constrainedSubsetSum(int[] nums, int k) {\n        Deque<Integer> deque = new ArrayDeque<>();\n        int[] dp = new int[nums.length];\n\n        for (int i = 0; i < nums.length; i++) {\n            // Remove indices outside window of size k\n            while (!deque.isEmpty() && deque.peekFirst() < i - k) {\n                deque.pollFirst();\n            }\n\n            // Calculate dp[i]\n            dp[i] = nums[i];\n            if (!deque.isEmpty()) {\n                dp[i] = Math.max(dp[i], nums[i] + dp[deque.peekFirst()]);\n            }\n\n            // Maintain decreasing order in deque\n            while (!deque.isEmpty() && dp[deque.peekLast()] <= dp[i]) {\n                deque.pollLast();\n            }\n\n            if (dp[i] > 0) {\n                deque.offerLast(i);\n            }\n        }\n\n        return Arrays.stream(dp).max().orElse(0);\n    }\n\n    // Maximum of minimum values in all windows\n    public int[] maxOfMinWindows(int[] nums) {\n        int n = nums.length;\n        int[] result = new int[n];\n\n        // For each window size\n        for (int windowSize = 1; windowSize <= n; windowSize++) {\n            Deque<Integer> deque = new ArrayDeque<>();\n            int maxOfMins = Integer.MIN_VALUE;\n\n            for (int i = 0; i < n; i++) {\n                // Remove elements outside current window\n                while (!deque.isEmpty() && deque.peekFirst() <= i - windowSize) {\n                    deque.pollFirst();\n                }\n\n                // Maintain increasing order (for minimum)\n                while (!deque.isEmpty() && nums[deque.peekLast()] >= nums[i]) {\n                    deque.pollLast();\n                }\n\n                deque.offerLast(i);\n\n                if (i >= windowSize - 1) {\n                    maxOfMins = Math.max(maxOfMins, nums[deque.peekFirst()]);\n                }\n            }\n\n            result[windowSize - 1] = maxOfMins;\n        }\n\n        return result;\n    }\n\n    // Shortest subarray with sum at least K (can have negative numbers)\n    public int shortestSubarray(int[] nums, int k) {\n        int n = nums.length;\n        long[] prefixSum = new long[n + 1];\n\n        // Build prefix sum array\n        for (int i = 0; i < n; i++) {\n            prefixSum[i + 1] = prefixSum[i] + nums[i];\n        }\n\n        Deque<Integer> deque = new ArrayDeque<>();\n        int minLength = Integer.MAX_VALUE;\n\n        for (int i = 0; i <= n; i++) {\n            // Check if current prefix sum can form valid subarray\n            while (!deque.isEmpty() && prefixSum[i] - prefixSum[deque.peekFirst()] >= k) {\n                minLength = Math.min(minLength, i - deque.pollFirst());\n            }\n\n            // Maintain increasing order of prefix sums\n            while (!deque.isEmpty() && prefixSum[deque.peekLast()] >= prefixSum[i]) {\n                deque.pollLast();\n            }\n\n            deque.offerLast(i);\n        }\n\n        return minLength == Integer.MAX_VALUE ? -1 : minLength;\n    }\n\n    // Sliding window maximum with updates\n    public static class SlidingWindowMaxWithUpdates {\n        private TreeMap<Integer, Integer> window;\n        private int[] nums;\n        private int k;\n        private int start;\n\n        public SlidingWindowMaxWithUpdates(int[] nums, int k) {\n            this.nums = nums.clone();\n            this.k = k;\n            this.window = new TreeMap<>();\n            this.start = 0;\n\n            // Initialize first window\n            for (int i = 0; i < k; i++) {\n                window.put(nums[i], window.getOrDefault(nums[i], 0) + 1);\n            }\n        }\n\n        public int getMax() {\n            return window.isEmpty() ? Integer.MIN_VALUE : window.lastKey();\n        }\n\n        public void slideWindow() {\n            if (start + k >= nums.length) return;\n\n            // Remove element going out of window\n            int outgoing = nums[start];\n            window.put(outgoing, window.get(outgoing) - 1);\n            if (window.get(outgoing) == 0) {\n                window.remove(outgoing);\n            }\n\n            // Add element coming into window\n            int incoming = nums[start + k];\n            window.put(incoming, window.getOrDefault(incoming, 0) + 1);\n\n            start++;\n        }\n\n        public void update(int index, int value) {\n            if (index >= start && index < start + k) {\n                // Element is in current window\n                int oldValue = nums[index];\n\n                // Remove old value\n                window.put(oldValue, window.get(oldValue) - 1);\n                if (window.get(oldValue) == 0) {\n                    window.remove(oldValue);\n                }\n\n                // Add new value\n                window.put(value, window.getOrDefault(value, 0) + 1);\n            }\n\n            nums[index] = value;\n        }\n    }\n\n    // Jump game VI with sliding window maximum\n    public int maxResult(int[] nums, int k) {\n        Deque<Integer> deque = new ArrayDeque<>();\n        int[] dp = new int[nums.length];\n        dp[0] = nums[0];\n        deque.offerLast(0);\n\n        for (int i = 1; i < nums.length; i++) {\n            // Remove indices outside window\n            while (!deque.isEmpty() && deque.peekFirst() < i - k) {\n                deque.pollFirst();\n            }\n\n            // Calculate dp[i] using maximum from window\n            dp[i] = nums[i] + dp[deque.peekFirst()];\n\n            // Maintain decreasing order in deque\n            while (!deque.isEmpty() && dp[deque.peekLast()] <= dp[i]) {\n                deque.pollLast();\n            }\n\n            deque.offerLast(i);\n        }\n\n        return dp[nums.length - 1];\n    }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-5-string-matching-with-sliding-window",children:"Pattern 5: String Matching with Sliding Window"}),"\n",(0,t.jsx)(e.h3,{id:"51-pattern-matching-problems",children:"5.1 Pattern Matching Problems"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// String pattern matching using sliding window\npublic class StringPatternMatching {\n\n    // Find all substrings of size k with k-1 distinct characters\n    public List<String> findSubstrings(String s, int k) {\n        List<String> result = new ArrayList<>();\n        if (s.length() < k) return result;\n\n        for (int i = 0; i <= s.length() - k; i++) {\n            String substring = s.substring(i, i + k);\n            Set<Character> distinct = new HashSet<>();\n\n            for (char c : substring.toCharArray()) {\n                distinct.add(c);\n            }\n\n            if (distinct.size() == k - 1) {\n                result.add(substring);\n            }\n        }\n\n        return result;\n    }\n\n    // Optimized version using sliding window\n    public List<String> findSubstringsOptimized(String s, int k) {\n        List<String> result = new ArrayList<>();\n        if (s.length() < k) return result;\n\n        Map<Character, Integer> charCount = new HashMap<>();\n\n        // Process first window\n        for (int i = 0; i < k; i++) {\n            char c = s.charAt(i);\n            charCount.put(c, charCount.getOrDefault(c, 0) + 1);\n        }\n\n        if (charCount.size() == k - 1) {\n            result.add(s.substring(0, k));\n        }\n\n        // Slide the window\n        for (int i = k; i < s.length(); i++) {\n            // Add new character\n            char newChar = s.charAt(i);\n            charCount.put(newChar, charCount.getOrDefault(newChar, 0) + 1);\n\n            // Remove old character\n            char oldChar = s.charAt(i - k);\n            charCount.put(oldChar, charCount.get(oldChar) - 1);\n            if (charCount.get(oldChar) == 0) {\n                charCount.remove(oldChar);\n            }\n\n            if (charCount.size() == k - 1) {\n                result.add(s.substring(i - k + 1, i + 1));\n            }\n        }\n\n        return result;\n    }\n\n    // Check if string contains permutation of pattern\n    public boolean checkPermutation(String s, String pattern) {\n        if (s.length() < pattern.length()) return false;\n\n        Map<Character, Integer> patternCount = new HashMap<>();\n        for (char c : pattern.toCharArray()) {\n            patternCount.put(c, patternCount.getOrDefault(c, 0) + 1);\n        }\n\n        Map<Character, Integer> windowCount = new HashMap<>();\n        int windowSize = pattern.length();\n\n        // Process first window\n        for (int i = 0; i < windowSize; i++) {\n            char c = s.charAt(i);\n            windowCount.put(c, windowCount.getOrDefault(c, 0) + 1);\n        }\n\n        if (windowCount.equals(patternCount)) return true;\n\n        // Slide the window\n        for (int i = windowSize; i < s.length(); i++) {\n            // Add new character\n            char newChar = s.charAt(i);\n            windowCount.put(newChar, windowCount.getOrDefault(newChar, 0) + 1);\n\n            // Remove old character\n            char oldChar = s.charAt(i - windowSize);\n            windowCount.put(oldChar, windowCount.get(oldChar) - 1);\n            if (windowCount.get(oldChar) == 0) {\n                windowCount.remove(oldChar);\n            }\n\n            if (windowCount.equals(patternCount)) return true;\n        }\n\n        return false;\n    }\n\n    // Find all starting indices where pattern appears as subsequence\n    public List<Integer> findPatternSubsequence(String text, String pattern) {\n        List<Integer> result = new ArrayList<>();\n\n        for (int i = 0; i <= text.length() - pattern.length(); i++) {\n            int patternIndex = 0;\n\n            for (int j = i; j < text.length() && patternIndex < pattern.length(); j++) {\n                if (text.charAt(j) == pattern.charAt(patternIndex)) {\n                    patternIndex++;\n                }\n            }\n\n            if (patternIndex == pattern.length()) {\n                result.add(i);\n            }\n        }\n\n        return result;\n    }\n\n    // Longest repeating character replacement\n    public int characterReplacement(String s, int k) {\n        Map<Character, Integer> charCount = new HashMap<>();\n        int left = 0;\n        int maxLength = 0;\n        int maxFreq = 0;\n\n        for (int right = 0; right < s.length(); right++) {\n            char rightChar = s.charAt(right);\n            charCount.put(rightChar, charCount.getOrDefault(rightChar, 0) + 1);\n            maxFreq = Math.max(maxFreq, charCount.get(rightChar));\n\n            // If replacements needed > k, shrink window\n            while (right - left + 1 - maxFreq > k) {\n                char leftChar = s.charAt(left);\n                charCount.put(leftChar, charCount.get(leftChar) - 1);\n                left++;\n            }\n\n            maxLength = Math.max(maxLength, right - left + 1);\n        }\n\n        return maxLength;\n    }\n\n    // Get equal substrings within budget\n    public int equalSubstring(String s, String t, int maxCost) {\n        int left = 0;\n        int currentCost = 0;\n        int maxLength = 0;\n\n        for (int right = 0; right < s.length(); right++) {\n            currentCost += Math.abs(s.charAt(right) - t.charAt(right));\n\n            while (currentCost > maxCost) {\n                currentCost -= Math.abs(s.charAt(left) - t.charAt(left));\n                left++;\n            }\n\n            maxLength = Math.max(maxLength, right - left + 1);\n        }\n\n        return maxLength;\n    }\n\n    // Find repeated DNA sequences\n    public List<String> findRepeatedDnaSequences(String s) {\n        Set<String> seen = new HashSet<>();\n        Set<String> repeated = new HashSet<>();\n\n        for (int i = 0; i <= s.length() - 10; i++) {\n            String sequence = s.substring(i, i + 10);\n\n            if (seen.contains(sequence)) {\n                repeated.add(sequence);\n            } else {\n                seen.add(sequence);\n            }\n        }\n\n        return new ArrayList<>(repeated);\n    }\n\n    // Optimized using rolling hash\n    public List<String> findRepeatedDnaSequencesOptimized(String s) {\n        Set<Integer> seen = new HashSet<>();\n        Set<String> repeated = new HashSet<>();\n\n        Map<Character, Integer> charToNum = Map.of('A', 0, 'C', 1, 'G', 2, 'T', 3);\n\n        int hash = 0;\n        int power = 1;\n\n        // Calculate hash for first 10 characters\n        for (int i = 0; i < 10 && i < s.length(); i++) {\n            hash = hash * 4 + charToNum.get(s.charAt(i));\n            if (i < 9) power *= 4;\n        }\n\n        seen.add(hash);\n\n        // Roll the hash\n        for (int i = 10; i < s.length(); i++) {\n            hash = (hash - charToNum.get(s.charAt(i - 10)) * power) * 4 +\n                   charToNum.get(s.charAt(i));\n\n            if (seen.contains(hash)) {\n                repeated.add(s.substring(i - 9, i + 1));\n            } else {\n                seen.add(hash);\n            }\n        }\n\n        return new ArrayList<>(repeated);\n    }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-6-multiple-pointers-sliding-window",children:"Pattern 6: Multiple Pointers Sliding Window"}),"\n",(0,t.jsx)(e.h3,{id:"61-three-pointers-and-beyond",children:"6.1 Three Pointers and Beyond"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Multiple pointers sliding window problems\npublic class MultiplePointersSlidingWindow {\n\n    // Three sum using sliding window approach\n    public List<List<Integer>> threeSum(int[] nums) {\n        Arrays.sort(nums);\n        List<List<Integer>> result = new ArrayList<>();\n\n        for (int i = 0; i < nums.length - 2; i++) {\n            if (i > 0 && nums[i] == nums[i - 1]) continue; // Skip duplicates\n\n            int left = i + 1, right = nums.length - 1;\n            int target = -nums[i];\n\n            while (left < right) {\n                int sum = nums[left] + nums[right];\n\n                if (sum == target) {\n                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));\n\n                    // Skip duplicates\n                    while (left < right && nums[left] == nums[left + 1]) left++;\n                    while (left < right && nums[right] == nums[right - 1]) right--;\n\n                    left++;\n                    right--;\n                } else if (sum < target) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n\n        return result;\n    }\n\n    // Four sum using multiple pointers\n    public List<List<Integer>> fourSum(int[] nums, int target) {\n        Arrays.sort(nums);\n        List<List<Integer>> result = new ArrayList<>();\n\n        for (int i = 0; i < nums.length - 3; i++) {\n            if (i > 0 && nums[i] == nums[i - 1]) continue;\n\n            for (int j = i + 1; j < nums.length - 2; j++) {\n                if (j > i + 1 && nums[j] == nums[j - 1]) continue;\n\n                int left = j + 1, right = nums.length - 1;\n                long remaining = (long) target - nums[i] - nums[j];\n\n                while (left < right) {\n                    long sum = nums[left] + nums[right];\n\n                    if (sum == remaining) {\n                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\n\n                        while (left < right && nums[left] == nums[left + 1]) left++;\n                        while (left < right && nums[right] == nums[right - 1]) right--;\n\n                        left++;\n                        right--;\n                    } else if (sum < remaining) {\n                        left++;\n                    } else {\n                        right--;\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n\n    // Trapping rain water using two pointers\n    public int trap(int[] height) {\n        if (height.length < 3) return 0;\n\n        int left = 0, right = height.length - 1;\n        int leftMax = 0, rightMax = 0;\n        int water = 0;\n\n        while (left < right) {\n            if (height[left] < height[right]) {\n                if (height[left] >= leftMax) {\n                    leftMax = height[left];\n                } else {\n                    water += leftMax - height[left];\n                }\n                left++;\n            } else {\n                if (height[right] >= rightMax) {\n                    rightMax = height[right];\n                } else {\n                    water += rightMax - height[right];\n                }\n                right--;\n            }\n        }\n\n        return water;\n    }\n\n    // Container with most water\n    public int maxArea(int[] height) {\n        int left = 0, right = height.length - 1;\n        int maxWater = 0;\n\n        while (left < right) {\n            int width = right - left;\n            int currentWater = Math.min(height[left], height[right]) * width;\n            maxWater = Math.max(maxWater, currentWater);\n\n            if (height[left] < height[right]) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n\n        return maxWater;\n    }\n\n    // Threesome closest to target\n    public int threeSumClosest(int[] nums, int target) {\n        Arrays.sort(nums);\n        int closestSum = nums[0] + nums[1] + nums[2];\n\n        for (int i = 0; i < nums.length - 2; i++) {\n            int left = i + 1, right = nums.length - 1;\n\n            while (left < right) {\n                int currentSum = nums[i] + nums[left] + nums[right];\n\n                if (Math.abs(currentSum - target) < Math.abs(closestSum - target)) {\n                    closestSum = currentSum;\n                }\n\n                if (currentSum < target) {\n                    left++;\n                } else if (currentSum > target) {\n                    right--;\n                } else {\n                    return currentSum; // Exact match found\n                }\n            }\n        }\n\n        return closestSum;\n    }\n\n    // Remove duplicates from sorted array II (allow at most 2 duplicates)\n    public int removeDuplicates(int[] nums) {\n        if (nums.length <= 2) return nums.length;\n\n        int writeIndex = 2; // Position to write next element\n\n        for (int readIndex = 2; readIndex < nums.length; readIndex++) {\n            if (nums[readIndex] != nums[writeIndex - 2]) {\n                nums[writeIndex] = nums[readIndex];\n                writeIndex++;\n            }\n        }\n\n        return writeIndex;\n    }\n\n    // Sort colors (Dutch national flag)\n    public void sortColors(int[] nums) {\n        int low = 0, mid = 0, high = nums.length - 1;\n\n        while (mid <= high) {\n            if (nums[mid] == 0) {\n                swap(nums, low, mid);\n                low++;\n                mid++;\n            } else if (nums[mid] == 1) {\n                mid++;\n            } else { // nums[mid] == 2\n                swap(nums, mid, high);\n                high--;\n                // Don't increment mid as we need to check swapped element\n            }\n        }\n    }\n\n    private void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n\n    // Squares of sorted array\n    public int[] sortedSquares(int[] nums) {\n        int[] result = new int[nums.length];\n        int left = 0, right = nums.length - 1;\n        int index = nums.length - 1;\n\n        while (left <= right) {\n            int leftSquare = nums[left] * nums[left];\n            int rightSquare = nums[right] * nums[right];\n\n            if (leftSquare > rightSquare) {\n                result[index] = leftSquare;\n                left++;\n            } else {\n                result[index] = rightSquare;\n                right--;\n            }\n            index--;\n        }\n\n        return result;\n    }\n\n    // Partition labels\n    public List<Integer> partitionLabels(String s) {\n        Map<Character, Integer> lastIndex = new HashMap<>();\n\n        // Record last occurrence of each character\n        for (int i = 0; i < s.length(); i++) {\n            lastIndex.put(s.charAt(i), i);\n        }\n\n        List<Integer> result = new ArrayList<>();\n        int start = 0, end = 0;\n\n        for (int i = 0; i < s.length(); i++) {\n            end = Math.max(end, lastIndex.get(s.charAt(i)));\n\n            if (i == end) {\n                result.add(end - start + 1);\n                start = end + 1;\n            }\n        }\n\n        return result;\n    }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-7-sliding-window-with-deque",children:"Pattern 7: Sliding Window with Deque"}),"\n",(0,t.jsx)(e.h3,{id:"71-deque-applications-in-sliding-window",children:"7.1 Deque Applications in Sliding Window"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Advanced sliding window using deque for optimization\npublic class SlidingWindowDeque {\n\n    // Sliding window maximum using monotonic deque\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        Deque<Integer> deque = new ArrayDeque<>();\n        int[] result = new int[nums.length - k + 1];\n\n        for (int i = 0; i < nums.length; i++) {\n            // Remove elements outside window\n            while (!deque.isEmpty() && deque.peekFirst() <= i - k) {\n                deque.pollFirst();\n            }\n\n            // Maintain decreasing order\n            while (!deque.isEmpty() && nums[deque.peekLast()] <= nums[i]) {\n                deque.pollLast();\n            }\n\n            deque.offerLast(i);\n\n            if (i >= k - 1) {\n                result[i - k + 1] = nums[deque.peekFirst()];\n            }\n        }\n\n        return result;\n    }\n\n    // Longest continuous subarray with absolute diff <= limit\n    public int longestSubarray(int[] nums, int limit) {\n        Deque<Integer> maxDeque = new ArrayDeque<>(); // Decreasing\n        Deque<Integer> minDeque = new ArrayDeque<>(); // Increasing\n\n        int left = 0, maxLength = 0;\n\n        for (int right = 0; right < nums.length; right++) {\n            // Maintain decreasing order in maxDeque\n            while (!maxDeque.isEmpty() && nums[maxDeque.peekLast()] <= nums[right]) {\n                maxDeque.pollLast();\n            }\n            maxDeque.offerLast(right);\n\n            // Maintain increasing order in minDeque\n            while (!minDeque.isEmpty() && nums[minDeque.peekLast()] >= nums[right]) {\n                minDeque.pollLast();\n            }\n            minDeque.offerLast(right);\n\n            // Shrink window while difference exceeds limit\n            while (nums[maxDeque.peekFirst()] - nums[minDeque.peekFirst()] > limit) {\n                if (maxDeque.peekFirst() <= left) {\n                    maxDeque.pollFirst();\n                }\n                if (minDeque.peekFirst() <= left) {\n                    minDeque.pollFirst();\n                }\n                left++;\n            }\n\n            maxLength = Math.max(maxLength, right - left + 1);\n        }\n\n        return maxLength;\n    }\n\n    // Jump game VI using deque\n    public int maxResult(int[] nums, int k) {\n        Deque<Integer> deque = new ArrayDeque<>();\n        int[] dp = new int[nums.length];\n\n        dp[0] = nums[0];\n        deque.offerLast(0);\n\n        for (int i = 1; i < nums.length; i++) {\n            // Remove indices outside window\n            while (!deque.isEmpty() && deque.peekFirst() < i - k) {\n                deque.pollFirst();\n            }\n\n            // Calculate dp[i] using maximum from previous k elements\n            dp[i] = nums[i] + dp[deque.peekFirst()];\n\n            // Maintain decreasing order\n            while (!deque.isEmpty() && dp[deque.peekLast()] <= dp[i]) {\n                deque.pollLast();\n            }\n\n            deque.offerLast(i);\n        }\n\n        return dp[nums.length - 1];\n    }\n\n    // Find median from data stream using sliding window\n    public static class SlidingWindowMedian {\n        private Deque<Integer> window;\n        private int k;\n\n        public SlidingWindowMedian(int k) {\n            this.k = k;\n            this.window = new ArrayDeque<>();\n        }\n\n        public double findSlidingWindowMedian(int[] nums) {\n            List<Double> medians = new ArrayList<>();\n\n            for (int num : nums) {\n                window.offerLast(num);\n\n                if (window.size() > k) {\n                    window.pollFirst();\n                }\n\n                if (window.size() == k) {\n                    medians.add(calculateMedian());\n                }\n            }\n\n            return medians.isEmpty() ? 0.0 : medians.get(medians.size() - 1);\n        }\n\n        private double calculateMedian() {\n            List<Integer> sorted = new ArrayList<>(window);\n            Collections.sort(sorted);\n\n            int size = sorted.size();\n            if (size % 2 == 1) {\n                return sorted.get(size / 2);\n            } else {\n                return (sorted.get(size / 2 - 1) + sorted.get(size / 2)) / 2.0;\n            }\n        }\n    }\n\n    // Shortest subarray with sum at least K\n    public int shortestSubarray(int[] nums, int k) {\n        long[] prefixSum = new long[nums.length + 1];\n        for (int i = 0; i < nums.length; i++) {\n            prefixSum[i + 1] = prefixSum[i] + nums[i];\n        }\n\n        Deque<Integer> deque = new ArrayDeque<>();\n        int minLength = Integer.MAX_VALUE;\n\n        for (int i = 0; i <= nums.length; i++) {\n            // Check for valid subarrays ending at i\n            while (!deque.isEmpty() && prefixSum[i] - prefixSum[deque.peekFirst()] >= k) {\n                minLength = Math.min(minLength, i - deque.pollFirst());\n            }\n\n            // Maintain increasing order of prefix sums\n            while (!deque.isEmpty() && prefixSum[deque.peekLast()] >= prefixSum[i]) {\n                deque.pollLast();\n            }\n\n            deque.offerLast(i);\n        }\n\n        return minLength == Integer.MAX_VALUE ? -1 : minLength;\n    }\n\n    // Maximum sum of subarray with length at least k\n    public int maxSubarraySum(int[] nums, int k) {\n        int n = nums.length;\n        long[] prefixSum = new long[n + 1];\n\n        for (int i = 0; i < n; i++) {\n            prefixSum[i + 1] = prefixSum[i] + nums[i];\n        }\n\n        Deque<Integer> deque = new ArrayDeque<>();\n        long maxSum = Long.MIN_VALUE;\n\n        for (int i = 0; i <= n; i++) {\n            if (i >= k) {\n                // Add current prefix to deque while maintaining increasing order\n                while (!deque.isEmpty() && prefixSum[deque.peekLast()] >= prefixSum[i - k]) {\n                    deque.pollLast();\n                }\n                deque.offerLast(i - k);\n\n                // Calculate maximum sum ending at i\n                maxSum = Math.max(maxSum, prefixSum[i] - prefixSum[deque.peekFirst()]);\n            }\n        }\n\n        return (int) maxSum;\n    }\n\n    // Sliding window unique elements counter\n    public int[] slidingWindowUniqueCount(int[] nums, int k) {\n        Map<Integer, Deque<Integer>> elementIndices = new HashMap<>();\n        int[] result = new int[nums.length - k + 1];\n\n        for (int i = 0; i < nums.length; i++) {\n            // Add current element\n            elementIndices.computeIfAbsent(nums[i], key -> new ArrayDeque<>()).offerLast(i);\n\n            // Remove elements outside current window\n            for (Deque<Integer> indices : elementIndices.values()) {\n                while (!indices.isEmpty() && indices.peekFirst() <= i - k) {\n                    indices.pollFirst();\n                }\n            }\n\n            // Count unique elements in current window\n            if (i >= k - 1) {\n                int uniqueCount = 0;\n                for (Deque<Integer> indices : elementIndices.values()) {\n                    if (!indices.isEmpty()) {\n                        uniqueCount++;\n                    }\n                }\n                result[i - k + 1] = uniqueCount;\n            }\n        }\n\n        return result;\n    }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-8-two-arrays-sliding-window",children:"Pattern 8: Two Arrays Sliding Window"}),"\n",(0,t.jsx)(e.h3,{id:"81-cross-array-operations",children:"8.1 Cross Array Operations"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:'// Sliding window operations across two arrays\npublic class TwoArraysSlidingWindow {\n\n    // Minimum window substring covering all characters from another array\n    public String minWindowCoveringArray(String s, char[] chars) {\n        Map<Character, Integer> targetCount = new HashMap<>();\n        for (char c : chars) {\n            targetCount.put(c, targetCount.getOrDefault(c, 0) + 1);\n        }\n\n        Map<Character, Integer> windowCount = new HashMap<>();\n        int left = 0, minLength = Integer.MAX_VALUE, minStart = 0;\n        int formed = 0, required = targetCount.size();\n\n        for (int right = 0; right < s.length(); right++) {\n            char rightChar = s.charAt(right);\n            windowCount.put(rightChar, windowCount.getOrDefault(rightChar, 0) + 1);\n\n            if (targetCount.containsKey(rightChar) &&\n                windowCount.get(rightChar).intValue() == targetCount.get(rightChar).intValue()) {\n                formed++;\n            }\n\n            while (formed == required) {\n                if (right - left + 1 < minLength) {\n                    minLength = right - left + 1;\n                    minStart = left;\n                }\n\n                char leftChar = s.charAt(left);\n                windowCount.put(leftChar, windowCount.get(leftChar) - 1);\n\n                if (targetCount.containsKey(leftChar) &&\n                    windowCount.get(leftChar) < targetCount.get(leftChar)) {\n                    formed--;\n                }\n                left++;\n            }\n        }\n\n        return minLength == Integer.MAX_VALUE ? "" : s.substring(minStart, minStart + minLength);\n    }\n\n    // Find common elements in sliding windows of two arrays\n    public List<List<Integer>> findCommonInWindows(int[] arr1, int[] arr2, int k) {\n        List<List<Integer>> result = new ArrayList<>();\n\n        for (int i = 0; i <= arr1.length - k; i++) {\n            Set<Integer> window1 = new HashSet<>();\n            for (int j = i; j < i + k; j++) {\n                window1.add(arr1[j]);\n            }\n\n            for (int j = 0; j <= arr2.length - k; j++) {\n                Set<Integer> window2 = new HashSet<>();\n                for (int l = j; l < j + k; l++) {\n                    window2.add(arr2[l]);\n                }\n\n                Set<Integer> common = new HashSet<>(window1);\n                common.retainAll(window2);\n\n                if (!common.isEmpty()) {\n                    result.add(new ArrayList<>(common));\n                }\n            }\n        }\n\n        return result;\n    }\n\n    // Maximum sum of k elements from two arrays\n    public int maxSumFromTwoArrays(int[] nums1, int[] nums2, int k) {\n        int maxSum = Integer.MIN_VALUE;\n\n        // Try all combinations of taking i elements from nums1 and k-i from nums2\n        for (int i = 0; i <= Math.min(k, nums1.length); i++) {\n            int remaining = k - i;\n            if (remaining > nums2.length) continue;\n\n            // Sum of top i elements from nums1\n            int sum1 = 0;\n            PriorityQueue<Integer> pq1 = new PriorityQueue<>(Collections.reverseOrder());\n            for (int num : nums1) {\n                pq1.offer(num);\n            }\n            for (int j = 0; j < i && !pq1.isEmpty(); j++) {\n                sum1 += pq1.poll();\n            }\n\n            // Sum of top remaining elements from nums2\n            int sum2 = 0;\n            PriorityQueue<Integer> pq2 = new PriorityQueue<>(Collections.reverseOrder());\n            for (int num : nums2) {\n                pq2.offer(num);\n            }\n            for (int j = 0; j < remaining && !pq2.isEmpty(); j++) {\n                sum2 += pq2.poll();\n            }\n\n            maxSum = Math.max(maxSum, sum1 + sum2);\n        }\n\n        return maxSum;\n    }\n\n    // Interleave two arrays to maximize sum of sliding window\n    public int maxSumInterleaved(int[] arr1, int[] arr2, int windowSize) {\n        List<Integer> interleaved = new ArrayList<>();\n        int i = 0, j = 0;\n\n        // Interleave based on which element is larger\n        while (i < arr1.length && j < arr2.length) {\n            if (arr1[i] >= arr2[j]) {\n                interleaved.add(arr1[i]);\n                i++;\n            } else {\n                interleaved.add(arr2[j]);\n                j++;\n            }\n        }\n\n        // Add remaining elements\n        while (i < arr1.length) {\n            interleaved.add(arr1[i]);\n            i++;\n        }\n        while (j < arr2.length) {\n            interleaved.add(arr2[j]);\n            j++;\n        }\n\n        // Find maximum sum in sliding window\n        if (interleaved.size() < windowSize) return 0;\n\n        int windowSum = 0;\n        for (int k = 0; k < windowSize; k++) {\n            windowSum += interleaved.get(k);\n        }\n\n        int maxSum = windowSum;\n        for (int k = windowSize; k < interleaved.size(); k++) {\n            windowSum = windowSum - interleaved.get(k - windowSize) + interleaved.get(k);\n            maxSum = Math.max(maxSum, windowSum);\n        }\n\n        return maxSum;\n    }\n\n    // Longest common subarray between two arrays\n    public int longestCommonSubarray(int[] arr1, int[] arr2) {\n        Map<String, Integer> subarrayMap = new HashMap<>();\n        int maxLength = 0;\n\n        // Generate all subarrays of arr1\n        for (int i = 0; i < arr1.length; i++) {\n            StringBuilder sb = new StringBuilder();\n            for (int j = i; j < arr1.length; j++) {\n                if (j > i) sb.append(",");\n                sb.append(arr1[j]);\n                subarrayMap.put(sb.toString(), j - i + 1);\n            }\n        }\n\n        // Check subarrays of arr2\n        for (int i = 0; i < arr2.length; i++) {\n            StringBuilder sb = new StringBuilder();\n            for (int j = i; j < arr2.length; j++) {\n                if (j > i) sb.append(",");\n                sb.append(arr2[j]);\n\n                String subarray = sb.toString();\n                if (subarrayMap.containsKey(subarray)) {\n                    maxLength = Math.max(maxLength, j - i + 1);\n                }\n            }\n        }\n\n        return maxLength;\n    }\n\n    // Merge two arrays to get minimum sliding window maximum\n    public int minSlidingWindowMax(int[] arr1, int[] arr2, int k) {\n        List<Integer> merged = new ArrayList<>();\n\n        // Try different merging strategies\n        int minWindowMax = Integer.MAX_VALUE;\n\n        // Strategy 1: All from arr1 first, then arr2\n        merged.clear();\n        for (int num : arr1) merged.add(num);\n        for (int num : arr2) merged.add(num);\n        minWindowMax = Math.min(minWindowMax, getMinSlidingWindowMax(merged, k));\n\n        // Strategy 2: All from arr2 first, then arr1\n        merged.clear();\n        for (int num : arr2) merged.add(num);\n        for (int num : arr1) merged.add(num);\n        minWindowMax = Math.min(minWindowMax, getMinSlidingWindowMax(merged, k));\n\n        // Strategy 3: Interleave alternately\n        merged.clear();\n        int i = 0, j = 0;\n        boolean takeFromFirst = true;\n\n        while (i < arr1.length || j < arr2.length) {\n            if (takeFromFirst && i < arr1.length) {\n                merged.add(arr1[i]);\n                i++;\n            } else if (!takeFromFirst && j < arr2.length) {\n                merged.add(arr2[j]);\n                j++;\n            } else if (i < arr1.length) {\n                merged.add(arr1[i]);\n                i++;\n            } else {\n                merged.add(arr2[j]);\n                j++;\n            }\n            takeFromFirst = !takeFromFirst;\n        }\n\n        minWindowMax = Math.min(minWindowMax, getMinSlidingWindowMax(merged, k));\n\n        return minWindowMax;\n    }\n\n    private int getMinSlidingWindowMax(List<Integer> arr, int k) {\n        if (arr.size() < k) return Integer.MAX_VALUE;\n\n        Deque<Integer> deque = new ArrayDeque<>();\n        int minMax = Integer.MAX_VALUE;\n\n        for (int i = 0; i < arr.size(); i++) {\n            while (!deque.isEmpty() && deque.peekFirst() <= i - k) {\n                deque.pollFirst();\n            }\n\n            while (!deque.isEmpty() && arr.get(deque.peekLast()) <= arr.get(i)) {\n                deque.pollLast();\n            }\n\n            deque.offerLast(i);\n\n            if (i >= k - 1) {\n                minMax = Math.min(minMax, arr.get(deque.peekFirst()));\n            }\n        }\n\n        return minMax;\n    }\n}\n'})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-9-advanced-sliding-window-techniques",children:"Pattern 9: Advanced Sliding Window Techniques"}),"\n",(0,t.jsx)(e.h3,{id:"91-complex-problem-solving",children:"9.1 Complex Problem Solving"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Advanced sliding window techniques for complex problems\npublic class AdvancedSlidingWindowTechniques {\n\n    // Longest substring with at most k distinct characters using optimized approach\n    public int lengthOfLongestSubstringKDistinctOptimized(String s, int k) {\n        if (k == 0 || s.isEmpty()) return 0;\n\n        Map<Character, Integer> charLastIndex = new HashMap<>();\n        int left = 0, maxLength = 0;\n\n        for (int right = 0; right < s.length(); right++) {\n            char rightChar = s.charAt(right);\n            charLastIndex.put(rightChar, right);\n\n            if (charLastIndex.size() > k) {\n                // Find character with smallest last index\n                int minIndex = Collections.min(charLastIndex.values());\n                char charToRemove = s.charAt(minIndex);\n                charLastIndex.remove(charToRemove);\n                left = minIndex + 1;\n            }\n\n            maxLength = Math.max(maxLength, right - left + 1);\n        }\n\n        return maxLength;\n    }\n\n    // Sliding window with multiple constraints\n    public int longestSubarrayMultipleConstraints(int[] nums, int maxSum, int maxLength) {\n        int left = 0, sum = 0, result = 0;\n\n        for (int right = 0; right < nums.length; right++) {\n            sum += nums[right];\n\n            // Shrink window while violating constraints\n            while (sum > maxSum || right - left + 1 > maxLength) {\n                sum -= nums[left];\n                left++;\n            }\n\n            result = Math.max(result, right - left + 1);\n        }\n\n        return result;\n    }\n\n    // Minimum operations to make array satisfy sliding window property\n    public int minOperations(int[] nums, int k) {\n        // Sliding window property: max - min <= k for any window\n        int operations = 0;\n\n        for (int windowSize = 2; windowSize <= nums.length; windowSize++) {\n            for (int i = 0; i <= nums.length - windowSize; i++) {\n                int min = Integer.MAX_VALUE;\n                int max = Integer.MIN_VALUE;\n\n                for (int j = i; j < i + windowSize; j++) {\n                    min = Math.min(min, nums[j]);\n                    max = Math.max(max, nums[j]);\n                }\n\n                if (max - min > k) {\n                    // Need to reduce the difference\n                    operations += (max - min - k + 1) / 2;\n                }\n            }\n        }\n\n        return operations;\n    }\n\n    // Sliding window with custom validator\n    public int longestValidWindow(int[] nums, Predicate<int[]> validator) {\n        int maxLength = 0;\n\n        for (int left = 0; left < nums.length; left++) {\n            for (int right = left; right < nums.length; right++) {\n                int[] window = Arrays.copyOfRange(nums, left, right + 1);\n\n                if (validator.test(window)) {\n                    maxLength = Math.max(maxLength, right - left + 1);\n                } else {\n                    break; // No need to expand further from this left\n                }\n            }\n        }\n\n        return maxLength;\n    }\n\n    // Adaptive sliding window (window size changes based on content)\n    public List<Integer> adaptiveWindow(int[] nums, Function<Integer, Integer> sizeCalculator) {\n        List<Integer> results = new ArrayList<>();\n        int left = 0;\n\n        while (left < nums.length) {\n            int windowSize = sizeCalculator.apply(nums[left]);\n            int right = Math.min(left + windowSize - 1, nums.length - 1);\n\n            // Process current window\n            int sum = 0;\n            for (int i = left; i <= right; i++) {\n                sum += nums[i];\n            }\n            results.add(sum);\n\n            left = right + 1;\n        }\n\n        return results;\n    }\n\n    // Multi-level sliding window (nested windows)\n    public int maxSumNestedWindows(int[] nums, int outerSize, int innerSize) {\n        if (outerSize < innerSize) return 0;\n\n        int maxSum = Integer.MIN_VALUE;\n\n        for (int outer = 0; outer <= nums.length - outerSize; outer++) {\n            // For each outer window, find best inner window\n            int maxInnerSum = Integer.MIN_VALUE;\n\n            for (int inner = outer; inner <= outer + outerSize - innerSize; inner++) {\n                int innerSum = 0;\n                for (int i = inner; i < inner + innerSize; i++) {\n                    innerSum += nums[i];\n                }\n                maxInnerSum = Math.max(maxInnerSum, innerSum);\n            }\n\n            maxSum = Math.max(maxSum, maxInnerSum);\n        }\n\n        return maxSum;\n    }\n\n    // Sliding window with gap constraints\n    public int longestWindowWithGaps(int[] nums, int maxGap) {\n        int left = 0, maxLength = 0;\n\n        for (int right = 0; right < nums.length; right++) {\n            // Check if current window satisfies gap constraint\n            while (left < right && !satisfiesGapConstraint(nums, left, right, maxGap)) {\n                left++;\n            }\n\n            maxLength = Math.max(maxLength, right - left + 1);\n        }\n\n        return maxLength;\n    }\n\n    private boolean satisfiesGapConstraint(int[] nums, int left, int right, int maxGap) {\n        for (int i = left; i < right; i++) {\n            if (Math.abs(nums[i + 1] - nums[i]) > maxGap) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // Sliding window with frequency constraints\n    public int longestWindowFrequencyConstraint(String s, int maxFreq) {\n        Map<Character, Integer> freq = new HashMap<>();\n        int left = 0, maxLength = 0;\n\n        for (int right = 0; right < s.length(); right++) {\n            char c = s.charAt(right);\n            freq.put(c, freq.getOrDefault(c, 0) + 1);\n\n            // Shrink window while any character frequency > maxFreq\n            while (freq.values().stream().anyMatch(f -> f > maxFreq)) {\n                char leftChar = s.charAt(left);\n                freq.put(leftChar, freq.get(leftChar) - 1);\n                if (freq.get(leftChar) == 0) {\n                    freq.remove(leftChar);\n                }\n                left++;\n            }\n\n            maxLength = Math.max(maxLength, right - left + 1);\n        }\n\n        return maxLength;\n    }\n\n    // Bidirectional sliding window\n    public int longestPalindromeSubarray(int[] nums) {\n        int maxLength = 1;\n\n        // For each potential center\n        for (int center = 0; center < nums.length; center++) {\n            // Odd length palindromes\n            int left = center, right = center;\n            while (left >= 0 && right < nums.length && nums[left] == nums[right]) {\n                maxLength = Math.max(maxLength, right - left + 1);\n                left--;\n                right++;\n            }\n\n            // Even length palindromes\n            left = center;\n            right = center + 1;\n            while (left >= 0 && right < nums.length && nums[left] == nums[right]) {\n                maxLength = Math.max(maxLength, right - left + 1);\n                left--;\n                right++;\n            }\n        }\n\n        return maxLength;\n    }\n\n    // Circular sliding window\n    public int maxSumCircularSubarray(int[] nums) {\n        // Case 1: Maximum subarray is non-circular\n        int maxKadane = kadane(nums);\n\n        // Case 2: Maximum subarray is circular\n        int totalSum = Arrays.stream(nums).sum();\n        int minKadane = kadaneMin(nums);\n        int maxCircular = totalSum - minKadane;\n\n        return maxCircular == 0 ? maxKadane : Math.max(maxKadane, maxCircular);\n    }\n\n    private int kadane(int[] nums) {\n        int maxSoFar = nums[0];\n        int maxEndingHere = nums[0];\n\n        for (int i = 1; i < nums.length; i++) {\n            maxEndingHere = Math.max(nums[i], maxEndingHere + nums[i]);\n            maxSoFar = Math.max(maxSoFar, maxEndingHere);\n        }\n\n        return maxSoFar;\n    }\n\n    private int kadaneMin(int[] nums) {\n        int minSoFar = nums[0];\n        int minEndingHere = nums[0];\n\n        for (int i = 1; i < nums.length; i++) {\n            minEndingHere = Math.min(nums[i], minEndingHere + nums[i]);\n            minSoFar = Math.min(minSoFar, minEndingHere);\n        }\n\n        return minSoFar;\n    }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"time--space-complexity-reference",children:"Time & Space Complexity Reference"}),"\n",(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{style:{textAlign:"left"},children:"Pattern Type"}),(0,t.jsx)(e.th,{style:{textAlign:"left"},children:"Time Complexity"}),(0,t.jsx)(e.th,{style:{textAlign:"left"},children:"Space Complexity"}),(0,t.jsx)(e.th,{style:{textAlign:"left"},children:"Key Characteristics"})]})}),(0,t.jsxs)(e.tbody,{children:[(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Fixed Size Window"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(1) to O(k)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Constant window size, slide by 1"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Variable Size Window"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(1) to O(n)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Expand/shrink based on condition"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Two Pointers"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(1)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Move pointers based on comparison"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Deque Window"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(k)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Maintain order for min/max queries"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"HashMap Window"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(k)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Track frequency/occurrences"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Multiple Arrays"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(n\xd7m)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(n+m)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Cross-array operations"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Multi-level Window"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(n\xb2)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(k)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Nested window operations"})]})]})]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"best-practices--interview-tips",children:"Best Practices & Interview Tips"}),"\n",(0,t.jsx)(e.h3,{id:"sliding-window-guidelines",children:"Sliding Window Guidelines"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:'// 1. Identify sliding window problems\npublic class SlidingWindowBestPractices {\n\n    // Problem identification checklist\n    public boolean isSlidingWindowProblem(String problemDescription) {\n        String[] keywords = {\n            "subarray", "substring", "contiguous", "window",\n            "consecutive", "range", "maximum", "minimum",\n            "longest", "shortest", "sum", "product"\n        };\n\n        String desc = problemDescription.toLowerCase();\n        return Arrays.stream(keywords).anyMatch(desc::contains);\n    }\n\n    // Choose appropriate technique\n    public String chooseApproach(boolean fixedSize, boolean hasConstraint, boolean needsOrder) {\n        if (fixedSize) {\n            return "Fixed Size Sliding Window";\n        } else if (hasConstraint) {\n            return "Variable Size with Two Pointers";\n        } else if (needsOrder) {\n            return "Sliding Window with Deque";\n        } else {\n            return "Sliding Window with HashMap";\n        }\n    }\n\n    // Template for debugging\n    public void debugSlidingWindow(int[] nums, int left, int right, int windowSum) {\n        System.out.printf("Window [%d, %d]: [", left, right);\n        for (int i = left; i <= right; i++) {\n            System.out.print(nums[i]);\n            if (i < right) System.out.print(", ");\n        }\n        System.out.printf("] Sum: %d%n", windowSum);\n    }\n\n    // Common edge cases to handle\n    public void handleEdgeCases() {\n        // 1. Empty array or string\n        // 2. Window size larger than array\n        // 3. All elements same\n        // 4. Single element\n        // 5. Negative numbers (for sum problems)\n        // 6. Integer overflow for large sums\n    }\n\n    // Performance optimization tips\n    public void optimizationTips() {\n        // 1. Use appropriate data structures (HashMap vs Array)\n        // 2. Avoid unnecessary operations in tight loops\n        // 3. Consider space-time tradeoffs\n        // 4. Use built-in functions when appropriate\n        // 5. Handle overflow with long data type\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"pattern-10-sliding-window-optimization",children:"Pattern 10: Sliding Window Optimization"}),"\n",(0,t.jsx)(e.h3,{id:"101-memory-and-time-optimizations",children:"10.1 Memory and Time Optimizations"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:'// Optimization techniques for sliding window problems\npublic class SlidingWindowOptimization {\n\n    // Space-optimized sliding window for large datasets\n    public static class MemoryEfficientWindow {\n        private int windowSum;\n        private int windowSize;\n        private int[] buffer;\n        private int head;\n        private int count;\n\n        public MemoryEfficientWindow(int size) {\n            this.windowSize = size;\n            this.buffer = new int[size];\n            this.head = 0;\n            this.count = 0;\n            this.windowSum = 0;\n        }\n\n        public void addElement(int element) {\n            if (count < windowSize) {\n                buffer[count] = element;\n                windowSum += element;\n                count++;\n            } else {\n                // Replace oldest element\n                windowSum = windowSum - buffer[head] + element;\n                buffer[head] = element;\n                head = (head + 1) % windowSize;\n            }\n        }\n\n        public double getAverage() {\n            return count == 0 ? 0.0 : (double) windowSum / Math.min(count, windowSize);\n        }\n\n        public int getSum() {\n            return windowSum;\n        }\n\n        public boolean isWindowFull() {\n            return count >= windowSize;\n        }\n    }\n\n    // Lazy evaluation for complex window operations\n    public static class LazyEvaluationWindow {\n        private int[] nums;\n        private int windowSize;\n        private Map<String, Object> cache;\n        private int lastLeft, lastRight;\n\n        public LazyEvaluationWindow(int[] nums, int windowSize) {\n            this.nums = nums;\n            this.windowSize = windowSize;\n            this.cache = new HashMap<>();\n            this.lastLeft = -1;\n            this.lastRight = -1;\n        }\n\n        public int getSum(int left, int right) {\n            String key = "sum_" + left + "_" + right;\n\n            if (cache.containsKey(key)) {\n                return (Integer) cache.get(key);\n            }\n\n            int sum = 0;\n            for (int i = left; i <= right; i++) {\n                sum += nums[i];\n            }\n\n            cache.put(key, sum);\n            return sum;\n        }\n\n        public int getMax(int left, int right) {\n            String key = "max_" + left + "_" + right;\n\n            if (cache.containsKey(key)) {\n                return (Integer) cache.get(key);\n            }\n\n            int max = Integer.MIN_VALUE;\n            for (int i = left; i <= right; i++) {\n                max = Math.max(max, nums[i]);\n            }\n\n            cache.put(key, max);\n            return max;\n        }\n\n        public void clearCache() {\n            cache.clear();\n        }\n    }\n\n    // Parallel sliding window for large arrays\n    public static class ParallelSlidingWindow {\n\n        public static List<Integer> parallelMaxWindows(int[] nums, int k) {\n            if (nums.length < k) return new ArrayList<>();\n\n            int numThreads = Runtime.getRuntime().availableProcessors();\n            int chunkSize = Math.max(1, nums.length / numThreads);\n\n            List<Future<List<Integer>>> futures = new ArrayList<>();\n            ExecutorService executor = Executors.newFixedThreadPool(numThreads);\n\n            for (int i = 0; i < nums.length; i += chunkSize) {\n                int start = i;\n                int end = Math.min(i + chunkSize + k - 1, nums.length);\n\n                Future<List<Integer>> future = executor.submit(() -> {\n                    List<Integer> results = new ArrayList<>();\n\n                    for (int j = start; j <= end - k; j++) {\n                        int max = Integer.MIN_VALUE;\n                        for (int l = j; l < j + k; l++) {\n                            max = Math.max(max, nums[l]);\n                        }\n                        results.add(max);\n                    }\n\n                    return results;\n                });\n\n                futures.add(future);\n            }\n\n            List<Integer> result = new ArrayList<>();\n            try {\n                for (Future<List<Integer>> future : futures) {\n                    result.addAll(future.get());\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            } finally {\n                executor.shutdown();\n            }\n\n            return result;\n        }\n    }\n\n    // Incremental sliding window updates\n    public static class IncrementalWindow {\n        private TreeMap<Integer, Integer> windowElements;\n        private int[] nums;\n        private int left, right;\n        private int sum;\n\n        public IncrementalWindow(int[] nums) {\n            this.nums = nums;\n            this.windowElements = new TreeMap<>();\n            this.left = 0;\n            this.right = -1;\n            this.sum = 0;\n        }\n\n        public void expandRight() {\n            if (right + 1 < nums.length) {\n                right++;\n                int element = nums[right];\n                windowElements.put(element, windowElements.getOrDefault(element, 0) + 1);\n                sum += element;\n            }\n        }\n\n        public void shrinkLeft() {\n            if (left <= right) {\n                int element = nums[left];\n                windowElements.put(element, windowElements.get(element) - 1);\n                if (windowElements.get(element) == 0) {\n                    windowElements.remove(element);\n                }\n                sum -= element;\n                left++;\n            }\n        }\n\n        public int getSum() {\n            return sum;\n        }\n\n        public int getMin() {\n            return windowElements.isEmpty() ? Integer.MAX_VALUE : windowElements.firstKey();\n        }\n\n        public int getMax() {\n            return windowElements.isEmpty() ? Integer.MIN_VALUE : windowElements.lastKey();\n        }\n\n        public int getSize() {\n            return right - left + 1;\n        }\n    }\n\n    // Compressed sliding window for sparse data\n    public static class CompressedWindow {\n        private Map<Integer, Integer> valueToIndex;\n        private List<Integer> compressedValues;\n        private int[] frequencies;\n\n        public CompressedWindow(int[] nums) {\n            Set<Integer> uniqueValues = new HashSet<>();\n            for (int num : nums) {\n                uniqueValues.add(num);\n            }\n\n            compressedValues = new ArrayList<>(uniqueValues);\n            Collections.sort(compressedValues);\n\n            valueToIndex = new HashMap<>();\n            for (int i = 0; i < compressedValues.size(); i++) {\n                valueToIndex.put(compressedValues.get(i), i);\n            }\n\n            frequencies = new int[compressedValues.size()];\n        }\n\n        public void addElement(int element) {\n            Integer index = valueToIndex.get(element);\n            if (index != null) {\n                frequencies[index]++;\n            }\n        }\n\n        public void removeElement(int element) {\n            Integer index = valueToIndex.get(element);\n            if (index != null && frequencies[index] > 0) {\n                frequencies[index]--;\n            }\n        }\n\n        public int getDistinctCount() {\n            int count = 0;\n            for (int freq : frequencies) {\n                if (freq > 0) count++;\n            }\n            return count;\n        }\n\n        public int getMin() {\n            for (int i = 0; i < frequencies.length; i++) {\n                if (frequencies[i] > 0) {\n                    return compressedValues.get(i);\n                }\n            }\n            return Integer.MAX_VALUE;\n        }\n\n        public int getMax() {\n            for (int i = frequencies.length - 1; i >= 0; i--) {\n                if (frequencies[i] > 0) {\n                    return compressedValues.get(i);\n                }\n            }\n            return Integer.MIN_VALUE;\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-11-real-world-applications",children:"Pattern 11: Real-World Applications"}),"\n",(0,t.jsx)(e.h3,{id:"111-practical-sliding-window-use-cases",children:"11.1 Practical Sliding Window Use Cases"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:'// Real-world applications of sliding window technique\npublic class RealWorldSlidingWindow {\n\n    // Network packet analysis with sliding window\n    public static class NetworkPacketAnalyzer {\n        private Queue<PacketInfo> window;\n        private long windowSizeMs;\n        private long totalBytes;\n\n        static class PacketInfo {\n            long timestamp;\n            int size;\n            String sourceIP;\n\n            PacketInfo(long timestamp, int size, String sourceIP) {\n                this.timestamp = timestamp;\n                this.size = size;\n                this.sourceIP = sourceIP;\n            }\n        }\n\n        public NetworkPacketAnalyzer(long windowSizeMs) {\n            this.window = new LinkedList<>();\n            this.windowSizeMs = windowSizeMs;\n            this.totalBytes = 0;\n        }\n\n        public void addPacket(PacketInfo packet) {\n            // Remove old packets outside window\n            long currentTime = packet.timestamp;\n            while (!window.isEmpty() &&\n                   currentTime - window.peek().timestamp > windowSizeMs) {\n                PacketInfo removed = window.poll();\n                totalBytes -= removed.size;\n            }\n\n            // Add new packet\n            window.offer(packet);\n            totalBytes += packet.size;\n        }\n\n        public double getThroughputMbps() {\n            if (window.isEmpty()) return 0.0;\n\n            long timeSpan = window.isEmpty() ? windowSizeMs :\n                           Math.min(windowSizeMs,\n                           ((LinkedList<PacketInfo>) window).peekLast().timestamp -\n                           window.peek().timestamp + 1);\n\n            return (totalBytes * 8.0) / (timeSpan * 1000.0); // Convert to Mbps\n        }\n\n        public Map<String, Integer> getTopSources(int k) {\n            Map<String, Integer> sourceBytes = new HashMap<>();\n\n            for (PacketInfo packet : window) {\n                sourceBytes.put(packet.sourceIP,\n                               sourceBytes.getOrDefault(packet.sourceIP, 0) + packet.size);\n            }\n\n            return sourceBytes.entrySet().stream()\n                    .sorted(Map.Entry.<String, Integer>comparingByValue().reversed())\n                    .limit(k)\n                    .collect(Collectors.toMap(\n                            Map.Entry::getKey,\n                            Map.Entry::getValue,\n                            (e1, e2) -> e1,\n                            LinkedHashMap::new));\n        }\n    }\n\n    // Stock price analysis with sliding window\n    public static class StockPriceAnalyzer {\n        private Deque<Double> prices;\n        private Deque<Long> timestamps;\n        private int windowSize;\n\n        public StockPriceAnalyzer(int windowSize) {\n            this.windowSize = windowSize;\n            this.prices = new ArrayDeque<>();\n            this.timestamps = new ArrayDeque<>();\n        }\n\n        public void addPrice(double price, long timestamp) {\n            // Maintain window size\n            if (prices.size() >= windowSize) {\n                prices.pollFirst();\n                timestamps.pollFirst();\n            }\n\n            prices.offerLast(price);\n            timestamps.offerLast(timestamp);\n        }\n\n        public double getMovingAverage() {\n            return prices.stream().mapToDouble(Double::doubleValue).average().orElse(0.0);\n        }\n\n        public double getVolatility() {\n            if (prices.size() < 2) return 0.0;\n\n            double mean = getMovingAverage();\n            double variance = prices.stream()\n                    .mapToDouble(price -> Math.pow(price - mean, 2))\n                    .average().orElse(0.0);\n\n            return Math.sqrt(variance);\n        }\n\n        public TrendDirection getTrend() {\n            if (prices.size() < 2) return TrendDirection.NEUTRAL;\n\n            Double first = ((ArrayDeque<Double>) prices).peekFirst();\n            Double last = ((ArrayDeque<Double>) prices).peekLast();\n\n            if (last > first * 1.02) return TrendDirection.UPWARD;\n            if (last < first * 0.98) return TrendDirection.DOWNWARD;\n            return TrendDirection.NEUTRAL;\n        }\n\n        public boolean detectAnomaly(double currentPrice) {\n            if (prices.size() < windowSize) return false;\n\n            double mean = getMovingAverage();\n            double stdDev = getVolatility();\n\n            // Anomaly if price is more than 2 standard deviations away\n            return Math.abs(currentPrice - mean) > 2 * stdDev;\n        }\n\n        enum TrendDirection {\n            UPWARD, DOWNWARD, NEUTRAL\n        }\n    }\n\n    // Database query optimization with sliding window\n    public static class QueryPerformanceAnalyzer {\n        private Queue<QueryMetric> queryWindow;\n        private long windowSizeMs;\n\n        static class QueryMetric {\n            String queryType;\n            long executionTime;\n            long timestamp;\n            int rowsAffected;\n\n            QueryMetric(String queryType, long executionTime, long timestamp, int rowsAffected) {\n                this.queryType = queryType;\n                this.executionTime = executionTime;\n                this.timestamp = timestamp;\n                this.rowsAffected = rowsAffected;\n            }\n        }\n\n        public QueryPerformanceAnalyzer(long windowSizeMs) {\n            this.queryWindow = new LinkedList<>();\n            this.windowSizeMs = windowSizeMs;\n        }\n\n        public void recordQuery(QueryMetric metric) {\n            // Remove old queries\n            long currentTime = metric.timestamp;\n            while (!queryWindow.isEmpty() &&\n                   currentTime - queryWindow.peek().timestamp > windowSizeMs) {\n                queryWindow.poll();\n            }\n\n            queryWindow.offer(metric);\n        }\n\n        public double getAverageExecutionTime() {\n            return queryWindow.stream()\n                    .mapToLong(q -> q.executionTime)\n                    .average().orElse(0.0);\n        }\n\n        public Map<String, Double> getExecutionTimeByType() {\n            Map<String, List<Long>> typeToTimes = queryWindow.stream()\n                    .collect(Collectors.groupingBy(\n                            q -> q.queryType,\n                            Collectors.mapping(q -> q.executionTime, Collectors.toList())\n                    ));\n\n            return typeToTimes.entrySet().stream()\n                    .collect(Collectors.toMap(\n                            Map.Entry::getKey,\n                            entry -> entry.getValue().stream().mapToLong(Long::longValue).average().orElse(0.0)\n                    ));\n        }\n\n        public List<QueryMetric> getSlowQueries(long thresholdMs) {\n            return queryWindow.stream()\n                    .filter(q -> q.executionTime > thresholdMs)\n                    .collect(Collectors.toList());\n        }\n\n        public double getQueriesPerSecond() {\n            if (queryWindow.isEmpty()) return 0.0;\n\n            long timeSpan = ((LinkedList<QueryMetric>) queryWindow).peekLast().timestamp -\n                           queryWindow.peek().timestamp + 1;\n\n            return (queryWindow.size() * 1000.0) / Math.max(timeSpan, 1);\n        }\n    }\n\n    // Log file analysis with sliding window\n    public static class LogAnalyzer {\n        private Queue<LogEntry> logWindow;\n        private long windowSizeMs;\n\n        static class LogEntry {\n            String level;\n            String message;\n            long timestamp;\n            String source;\n\n            LogEntry(String level, String message, long timestamp, String source) {\n                this.level = level;\n                this.message = message;\n                this.timestamp = timestamp;\n                this.source = source;\n            }\n        }\n\n        public LogAnalyzer(long windowSizeMs) {\n            this.logWindow = new LinkedList<>();\n            this.windowSizeMs = windowSizeMs;\n        }\n\n        public void addLogEntry(LogEntry entry) {\n            // Remove old entries\n            long currentTime = entry.timestamp;\n            while (!logWindow.isEmpty() &&\n                   currentTime - logWindow.peek().timestamp > windowSizeMs) {\n                logWindow.poll();\n            }\n\n            logWindow.offer(entry);\n        }\n\n        public Map<String, Long> getErrorFrequency() {\n            return logWindow.stream()\n                    .filter(entry -> "ERROR".equals(entry.level))\n                    .collect(Collectors.groupingBy(\n                            entry -> entry.source,\n                            Collectors.counting()\n                    ));\n        }\n\n        public boolean detectErrorSpike(double threshold) {\n            long errorCount = logWindow.stream()\n                    .mapToLong(entry -> "ERROR".equals(entry.level) ? 1 : 0)\n                    .sum();\n\n            double errorRate = (double) errorCount / Math.max(logWindow.size(), 1);\n            return errorRate > threshold;\n        }\n\n        public List<String> getFrequentErrorPatterns(int minOccurrences) {\n            Map<String, Long> patternCounts = logWindow.stream()\n                    .filter(entry -> "ERROR".equals(entry.level))\n                    .collect(Collectors.groupingBy(\n                            entry -> extractPattern(entry.message),\n                            Collectors.counting()\n                    ));\n\n            return patternCounts.entrySet().stream()\n                    .filter(entry -> entry.getValue() >= minOccurrences)\n                    .map(Map.Entry::getKey)\n                    .collect(Collectors.toList());\n        }\n\n        private String extractPattern(String message) {\n            // Simplified pattern extraction - replace numbers and specific values\n            return message.replaceAll("\\\\d+", "X")\n                          .replaceAll("\\\\b\\\\w+@\\\\w+\\\\.\\\\w+\\\\b", "EMAIL")\n                          .replaceAll("\\\\b\\\\d{1,3}\\\\.\\\\d{1,3}\\\\.\\\\d{1,3}\\\\.\\\\d{1,3}\\\\b", "IP");\n        }\n    }\n\n    // Real-time metrics dashboard\n    public static class MetricsDashboard {\n        private Map<String, Queue<MetricPoint>> metricWindows;\n        private long windowSizeMs;\n\n        static class MetricPoint {\n            String metricName;\n            double value;\n            long timestamp;\n            Map<String, String> tags;\n\n            MetricPoint(String metricName, double value, long timestamp, Map<String, String> tags) {\n                this.metricName = metricName;\n                this.value = value;\n                this.timestamp = timestamp;\n                this.tags = tags != null ? tags : new HashMap<>();\n            }\n        }\n\n        public MetricsDashboard(long windowSizeMs) {\n            this.metricWindows = new ConcurrentHashMap<>();\n            this.windowSizeMs = windowSizeMs;\n        }\n\n        public void recordMetric(MetricPoint point) {\n            Queue<MetricPoint> window = metricWindows.computeIfAbsent(\n                    point.metricName, k -> new LinkedList<>());\n\n            synchronized (window) {\n                // Remove old points\n                while (!window.isEmpty() &&\n                       point.timestamp - window.peek().timestamp > windowSizeMs) {\n                    window.poll();\n                }\n\n                window.offer(point);\n            }\n        }\n\n        public double getAverageValue(String metricName) {\n            Queue<MetricPoint> window = metricWindows.get(metricName);\n            if (window == null) return 0.0;\n\n            synchronized (window) {\n                return window.stream()\n                        .mapToDouble(point -> point.value)\n                        .average().orElse(0.0);\n            }\n        }\n\n        public double getPercentile(String metricName, double percentile) {\n            Queue<MetricPoint> window = metricWindows.get(metricName);\n            if (window == null) return 0.0;\n\n            synchronized (window) {\n                List<Double> values = window.stream()\n                        .map(point -> point.value)\n                        .sorted()\n                        .collect(Collectors.toList());\n\n                if (values.isEmpty()) return 0.0;\n\n                int index = (int) Math.ceil(percentile * values.size() / 100.0) - 1;\n                return values.get(Math.max(0, Math.min(index, values.size() - 1)));\n            }\n        }\n\n        public Map<String, Double> getMetricsSummary() {\n            Map<String, Double> summary = new HashMap<>();\n\n            for (String metricName : metricWindows.keySet()) {\n                summary.put(metricName + "_avg", getAverageValue(metricName));\n                summary.put(metricName + "_p95", getPercentile(metricName, 95));\n                summary.put(metricName + "_p99", getPercentile(metricName, 99));\n            }\n\n            return summary;\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-12-complex-sliding-window-problems",children:"Pattern 12: Complex Sliding Window Problems"}),"\n",(0,t.jsx)(e.h3,{id:"121-advanced-problem-solutions",children:"12.1 Advanced Problem Solutions"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Complex sliding window problems requiring multiple techniques\npublic class ComplexSlidingWindowProblems {\n\n    // Sliding window maximum with updates\n    public static class SlidingWindowMaximumWithUpdates {\n        private TreeMap<Integer, Integer> window;\n        private int[] nums;\n        private int windowSize;\n        private int left;\n\n        public SlidingWindowMaximumWithUpdates(int[] nums, int windowSize) {\n            this.nums = nums.clone();\n            this.windowSize = windowSize;\n            this.window = new TreeMap<>();\n            this.left = 0;\n\n            // Initialize first window\n            for (int i = 0; i < Math.min(windowSize, nums.length); i++) {\n                window.put(nums[i], window.getOrDefault(nums[i], 0) + 1);\n            }\n        }\n\n        public int getMaximum() {\n            return window.isEmpty() ? Integer.MIN_VALUE : window.lastKey();\n        }\n\n        public void slideWindow() {\n            if (left + windowSize >= nums.length) return;\n\n            // Remove leftmost element\n            int outgoing = nums[left];\n            window.put(outgoing, window.get(outgoing) - 1);\n            if (window.get(outgoing) == 0) {\n                window.remove(outgoing);\n            }\n\n            // Add new element\n            int incoming = nums[left + windowSize];\n            window.put(incoming, window.getOrDefault(incoming, 0) + 1);\n\n            left++;\n        }\n\n        public void update(int index, int newValue) {\n            if (index >= left && index < left + windowSize) {\n                // Update element in current window\n                int oldValue = nums[index];\n\n                // Remove old value\n                window.put(oldValue, window.get(oldValue) - 1);\n                if (window.get(oldValue) == 0) {\n                    window.remove(oldValue);\n                }\n\n                // Add new value\n                window.put(newValue, window.getOrDefault(newValue, 0) + 1);\n            }\n\n            nums[index] = newValue;\n        }\n    }\n\n    // Minimum number of operations to make all elements in sliding windows equal\n    public int minOperationsForEqualWindows(int[] nums, int windowSize) {\n        int totalOperations = 0;\n\n        for (int i = 0; i <= nums.length - windowSize; i++) {\n            Map<Integer, Integer> frequency = new HashMap<>();\n\n            // Count frequency in current window\n            for (int j = i; j < i + windowSize; j++) {\n                frequency.put(nums[j], frequency.getOrDefault(nums[j], 0) + 1);\n            }\n\n            // Find most frequent element\n            int maxFreq = frequency.values().stream().mapToInt(Integer::intValue).max().orElse(0);\n\n            // Operations needed = window size - max frequency\n            totalOperations += windowSize - maxFreq;\n        }\n\n        return totalOperations;\n    }\n\n    // Sliding window with multiple constraints\n    public int longestWindowMultipleConstraints(int[] nums, int maxSum, int maxRange, int maxDistinct) {\n        int left = 0, maxLength = 0;\n        int sum = 0;\n        Map<Integer, Integer> frequency = new HashMap<>();\n        TreeMap<Integer, Integer> sortedElements = new TreeMap<>();\n\n        for (int right = 0; right < nums.length; right++) {\n            // Add current element\n            sum += nums[right];\n            frequency.put(nums[right], frequency.getOrDefault(nums[right], 0) + 1);\n            sortedElements.put(nums[right], sortedElements.getOrDefault(nums[right], 0) + 1);\n\n            // Shrink window while violating any constraint\n            while (left <= right && (\n                    sum > maxSum ||\n                    (!sortedElements.isEmpty() && sortedElements.lastKey() - sortedElements.firstKey() > maxRange) ||\n                    frequency.size() > maxDistinct)) {\n\n                int leftElement = nums[left];\n                sum -= leftElement;\n\n                frequency.put(leftElement, frequency.get(leftElement) - 1);\n                if (frequency.get(leftElement) == 0) {\n                    frequency.remove(leftElement);\n                }\n\n                sortedElements.put(leftElement, sortedElements.get(leftElement) - 1);\n                if (sortedElements.get(leftElement) == 0) {\n                    sortedElements.remove(leftElement);\n                }\n\n                left++;\n            }\n\n            maxLength = Math.max(maxLength, right - left + 1);\n        }\n\n        return maxLength;\n    }\n\n    // Sliding window with dynamic window size based on content\n    public List<Integer> dynamicWindowAnalysis(int[] nums, Function<Integer, Integer> sizeFunction) {\n        List<Integer> results = new ArrayList<>();\n        int i = 0;\n\n        while (i < nums.length) {\n            int windowSize = sizeFunction.apply(nums[i]);\n            int sum = 0;\n            int actualSize = 0;\n\n            // Calculate sum for dynamic window\n            for (int j = i; j < Math.min(i + windowSize, nums.length); j++) {\n                sum += nums[j];\n                actualSize++;\n            }\n\n            results.add(sum);\n            i += actualSize;\n        }\n\n        return results;\n    }\n\n    // Hierarchical sliding window (windows within windows)\n    public int maxSumHierarchicalWindows(int[] nums, int outerWindowSize, int innerWindowSize) {\n        if (outerWindowSize < innerWindowSize || nums.length < outerWindowSize) {\n            return Integer.MIN_VALUE;\n        }\n\n        int maxSum = Integer.MIN_VALUE;\n\n        // For each outer window position\n        for (int outerStart = 0; outerStart <= nums.length - outerWindowSize; outerStart++) {\n            int maxInnerSum = Integer.MIN_VALUE;\n\n            // Find maximum inner window sum within current outer window\n            for (int innerStart = outerStart;\n                 innerStart <= outerStart + outerWindowSize - innerWindowSize;\n                 innerStart++) {\n\n                int innerSum = 0;\n                for (int k = innerStart; k < innerStart + innerWindowSize; k++) {\n                    innerSum += nums[k];\n                }\n\n                maxInnerSum = Math.max(maxInnerSum, innerSum);\n            }\n\n            maxSum = Math.max(maxSum, maxInnerSum);\n        }\n\n        return maxSum;\n    }\n\n    // Sliding window with gap allowance\n    public int longestIncreasingWindowWithGaps(int[] nums, int maxGaps) {\n        int left = 0, maxLength = 0, gaps = 0;\n\n        for (int right = 0; right < nums.length; right++) {\n            // Check if we need a gap\n            if (right > 0 && nums[right] <= nums[right - 1]) {\n                gaps++;\n            }\n\n            // Shrink window while gaps exceed limit\n            while (gaps > maxGaps) {\n                left++;\n                if (left < nums.length && nums[left] <= nums[left - 1]) {\n                    gaps--;\n                }\n            }\n\n            maxLength = Math.max(maxLength, right - left + 1);\n        }\n\n        return maxLength;\n    }\n\n    // Multi-dimensional sliding window\n    public int maxSumIn2DWindow(int[][] matrix, int windowHeight, int windowWidth) {\n        if (matrix.length < windowHeight || matrix[0].length < windowWidth) {\n            return Integer.MIN_VALUE;\n        }\n\n        int maxSum = Integer.MIN_VALUE;\n\n        // Build 2D prefix sum\n        int m = matrix.length, n = matrix[0].length;\n        int[][] prefixSum = new int[m + 1][n + 1];\n\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                prefixSum[i][j] = matrix[i - 1][j - 1] +\n                                  prefixSum[i - 1][j] +\n                                  prefixSum[i][j - 1] -\n                                  prefixSum[i - 1][j - 1];\n            }\n        }\n\n        // Check all possible window positions\n        for (int i = 0; i <= m - windowHeight; i++) {\n            for (int j = 0; j <= n - windowWidth; j++) {\n                int windowSum = prefixSum[i + windowHeight][j + windowWidth] -\n                               prefixSum[i][j + windowWidth] -\n                               prefixSum[i + windowHeight][j] +\n                               prefixSum[i][j];\n\n                maxSum = Math.max(maxSum, windowSum);\n            }\n        }\n\n        return maxSum;\n    }\n\n    // Sliding window with conditional elements\n    public int longestConditionalWindow(int[] nums, Predicate<Integer> condition) {\n        int left = 0, maxLength = 0;\n        int validElements = 0, totalElements = 0;\n\n        for (int right = 0; right < nums.length; right++) {\n            totalElements++;\n            if (condition.test(nums[right])) {\n                validElements++;\n            }\n\n            // Shrink window while valid ratio < 50%\n            while (totalElements > 0 && (double) validElements / totalElements < 0.5) {\n                if (condition.test(nums[left])) {\n                    validElements--;\n                }\n                totalElements--;\n                left++;\n            }\n\n            maxLength = Math.max(maxLength, right - left + 1);\n        }\n\n        return maxLength;\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"common-pitfalls-to-avoid",children:"Common Pitfalls to Avoid"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Off-by-one errors"}),": Careful with window boundaries and indices"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Not handling edge cases"}),": Empty arrays, single elements, oversized windows"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Wrong loop conditions"}),": Ensure proper window expansion/contraction"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Integer overflow"}),": Use ",(0,t.jsx)(e.code,{children:"long"})," for large sum calculations"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Inefficient data structures"}),": Choose HashMap vs Array based on constraints"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Not maintaining invariants"}),": Keep window properties consistent"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"interview-tips",children:"Interview Tips"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Start with brute force"}),": Explain O(n\xb2) solution first, then optimize"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Identify the pattern"}),': Look for keywords like "subarray", "window", "contiguous"']}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Choose right technique"}),": Fixed vs variable window based on problem"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Draw examples"}),": Visualize window movement on sample inputs"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Handle edge cases"}),": Discuss boundary conditions upfront"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Optimize step by step"}),": Show progression from basic to optimized solution"]}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"summary-and-conclusion",children:"Summary and Conclusion"}),"\n",(0,t.jsx)(e.h3,{id:"sliding-window-pattern-recognition",children:"Sliding Window Pattern Recognition"}),"\n",(0,t.jsx)(e.p,{children:"The sliding window technique is one of the most powerful and frequently used patterns in algorithm design. Here's a comprehensive summary:"}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"When to Use Sliding Window:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Problems involving contiguous subarrays or substrings"}),"\n",(0,t.jsx)(e.li,{children:"Need to find optimal window (maximum, minimum, longest, shortest)"}),"\n",(0,t.jsx)(e.li,{children:'Questions with "subarray", "substring", "window" keywords'}),"\n",(0,t.jsx)(e.li,{children:"Range-based queries on arrays or strings"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Common Variations:"})}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Fixed Size Window"}),": Window size is constant"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Variable Size Window"}),": Window expands/shrinks based on conditions"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Two Pointers"}),": Multiple pointers moving in coordination"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Deque-based"}),": Using deque for maintaining order in window"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"HashMap Window"}),": Tracking frequencies or unique elements"]}),"\n"]})]})}function m(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>s,x:()=>l});var t=i(6540);const r={},a=t.createContext(r);function s(n){const e=t.useContext(a);return t.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:s(n.components),t.createElement(a.Provider,{value:e},n.children)}}}]);