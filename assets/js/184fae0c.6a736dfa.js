"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[9615],{13256:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>l});var i=t(74848),s=t(28453);const r={},d="Dequeue (Double-Ended Queue) Implementation Cheatsheet",a={id:"DSA/DSA with JavaScript/Dequeue",title:"Dequeue (Double-Ended Queue) Implementation Cheatsheet",description:"Basic Implementation",source:"@site/docs/DSA/DSA with JavaScript/Dequeue.mdx",sourceDirName:"DSA/DSA with JavaScript",slug:"/DSA/DSA with JavaScript/Dequeue",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/Dequeue",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with JavaScript/Dequeue.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Depth-First Search (DFS) for Trees",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/DFSTree"},next:{title:"Difference Array Technique",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/DifferenceArray"}},o={},l=[{value:"Basic Implementation",id:"basic-implementation",level:2},{value:"Time Complexities",id:"time-complexities",level:2},{value:"Usage Examples",id:"usage-examples",level:2},{value:"Basic Operations",id:"basic-operations",level:3},{value:"Dequeue using DoublyLinkedList",id:"dequeue-using-doublylinkedlist",level:3},{value:"Common Applications",id:"common-applications",level:3},{value:"Sliding Window Maximum",id:"sliding-window-maximum",level:4},{value:"Palindrome Check",id:"palindrome-check",level:4},{value:"Best Practices",id:"best-practices",level:2},{value:"Memory-Efficient Version",id:"memory-efficient-version",level:2},{value:"Common Pitfalls",id:"common-pitfalls",level:2},{value:"Performance Tips",id:"performance-tips",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"dequeue-double-ended-queue-implementation-cheatsheet",children:"Dequeue (Double-Ended Queue) Implementation Cheatsheet"})}),"\n",(0,i.jsx)(n.h2,{id:"basic-implementation",children:"Basic Implementation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"class Deque {\n    constructor() {\n        this.items = {};\n        this.frontIndex = 0;\n        this.backIndex = 0;\n    }\n\n    addFront(item) {\n        this.frontIndex--;\n        this.items[this.frontIndex] = item;\n    }\n\n    addBack(item) {\n        this.items[this.backIndex] = item;\n        this.backIndex++;\n    }\n\n    removeFront() {\n        if (this.isEmpty()) return undefined;\n        const item = this.items[this.frontIndex];\n        delete this.items[this.frontIndex];\n        this.frontIndex++;\n        return item;\n    }\n\n    removeBack() {\n        if (this.isEmpty()) return undefined;\n        this.backIndex--;\n        const item = this.items[this.backIndex];\n        delete this.items[this.backIndex];\n        return item;\n    }\n\n    peekFront() {\n        if (this.isEmpty()) return undefined;\n        return this.items[this.frontIndex];\n    }\n\n    peekBack() {\n        if (this.isEmpty()) return undefined;\n        return this.items[this.backIndex - 1];\n    }\n\n    isEmpty() {\n        return this.backIndex - this.frontIndex === 0;\n    }\n\n    size() {\n        return this.backIndex - this.frontIndex;\n    }\n\n    clear() {\n        this.items = {};\n        this.frontIndex = 0;\n        this.backIndex = 0;\n    }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"time-complexities",children:"Time Complexities"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Operation"}),(0,i.jsx)(n.th,{children:"Time Complexity"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"addFront"}),(0,i.jsx)(n.td,{children:"O(1)"}),(0,i.jsx)(n.td,{children:"Add item to front"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"addBack"}),(0,i.jsx)(n.td,{children:"O(1)"}),(0,i.jsx)(n.td,{children:"Add item to back"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"removeFront"}),(0,i.jsx)(n.td,{children:"O(1)"}),(0,i.jsx)(n.td,{children:"Remove and return front item"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"removeBack"}),(0,i.jsx)(n.td,{children:"O(1)"}),(0,i.jsx)(n.td,{children:"Remove and return back item"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"peekFront"}),(0,i.jsx)(n.td,{children:"O(1)"}),(0,i.jsx)(n.td,{children:"Return front item without removing"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"peekBack"}),(0,i.jsx)(n.td,{children:"O(1)"}),(0,i.jsx)(n.td,{children:"Return back item without removing"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"isEmpty"}),(0,i.jsx)(n.td,{children:"O(1)"}),(0,i.jsx)(n.td,{children:"Check if deque is empty"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"size"}),(0,i.jsx)(n.td,{children:"O(1)"}),(0,i.jsx)(n.td,{children:"Get number of items"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"clear"}),(0,i.jsx)(n.td,{children:"O(1)"}),(0,i.jsx)(n.td,{children:"Remove all items"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,i.jsx)(n.h3,{id:"basic-operations",children:"Basic Operations"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"const deque = new Deque();\n\n// Adding elements\ndeque.addFront(1);    // [1]\ndeque.addBack(2);     // [1, 2]\ndeque.addFront(0);    // [0, 1, 2]\n\n// Removing elements\ndeque.removeFront();  // returns 0, deque is [1, 2]\ndeque.removeBack();   // returns 2, deque is [1]\n\n// Peeking elements\ndeque.peekFront();    // returns 1\ndeque.peekBack();     // returns 1\n"})}),"\n",(0,i.jsx)(n.h3,{id:"dequeue-using-doublylinkedlist",children:"Dequeue using DoublyLinkedList"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-JavaScript",children:"class Node {\n  constructor(value) {\n    this.value = value;\n    this.prev = null; // Pointer to the previous node\n    this.next = null; // Pointer to the next node\n  }\n}\n\nclass Deque {\n  constructor() {\n    this.front = null; // Pointer to the front node\n    this.rear = null;  // Pointer to the rear node\n    this.size = 0;     // Size of the deque\n  }\n\n  // Add an item at the front\n  addFront(value) {\n    const newNode = new Node(value);\n    if (this.isEmpty()) {\n      this.front = this.rear = newNode;\n    } else {\n      newNode.next = this.front;\n      this.front.prev = newNode;\n      this.front = newNode;\n    }\n    this.size++;\n  }\n\n  // Add an item at the rear\n  addRear(value) {\n    const newNode = new Node(value);\n    if (this.isEmpty()) {\n      this.front = this.rear = newNode;\n    } else {\n      newNode.prev = this.rear;\n      this.rear.next = newNode;\n      this.rear = newNode;\n    }\n    this.size++;\n  }\n\n  // Remove an item from the front\n  removeFront() {\n    if (this.isEmpty()) return null;  \n    const removedValue = this.front.value;\n    this.front = this.front.next;\n    if (this.front) {\n      this.front.prev = null;\n    } else {\n      this.rear = null; // Deque is now empty\n    }\n    this.size--;\n    return removedValue;\n  }\n\n  // Remove an item from the rear\n  removeRear() {\n    if (this.size === 0) {\n      return null; // Deque is empty\n    }\n    const removedValue = this.rear.value;\n    this.rear = this.rear.prev;\n    if (this.rear) {\n      this.rear.next = null;\n    } else {\n      this.front = null; // Deque is now empty\n    }\n    this.size--;\n    return removedValue;\n  }\n\n  // Get the size of the deque\n  getSize = () => this.size;\n\n  // Check if the deque is empty\n  isEmpty = () => this.size === 0;\n\n  // Peek at the front item\n  peekFront = () => this.front ? this.front.value : null;\n\n  // Peek at the rear item\n  peekRear = () => this.rear ? this.rear.value : null;\n}\n\n// Example usage\nconst deque = new Deque();\ndeque.addFront(10);\ndeque.addRear(20);\nconsole.log(deque.peekFront()); // 10\nconsole.log(deque.peekRear());  // 20\nconsole.log(deque.removeFront()); // 10\nconsole.log(deque.removeRear());  // 20\nconsole.log(deque.isEmpty()); // true\n"})}),"\n",(0,i.jsx)(n.h3,{id:"common-applications",children:"Common Applications"}),"\n",(0,i.jsx)(n.h4,{id:"sliding-window-maximum",children:"Sliding Window Maximum"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"function maxSlidingWindow(nums, k) {\n    const deque = new Deque();\n    const result = [];\n    \n    for (let i = 0; i < nums.length; i++) {\n        // Remove elements outside window\n        while (!deque.isEmpty() && deque.peekFront() < i - k + 1) {\n            deque.removeFront();\n        }\n        \n        // Remove smaller elements\n        while (!deque.isEmpty() && nums[deque.peekBack()] < nums[i]) {\n            deque.removeBack();\n        }\n        \n        deque.addBack(i);\n        \n        // Add to result if window has reached size k\n        if (i >= k - 1) {\n            result.push(nums[deque.peekFront()]);\n        }\n    }\n    \n    return result;\n}\n"})}),"\n",(0,i.jsx)(n.h4,{id:"palindrome-check",children:"Palindrome Check"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"function isPalindrome(str) {\n    const deque = new Deque();\n    \n    // Add all characters to deque\n    for (let char of str) {\n        deque.addBack(char);\n    }\n    \n    // Compare characters from both ends\n    while (deque.size() > 1) {\n        if (deque.removeFront() !== deque.removeBack()) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Use object-based implementation for O(1) operations"}),"\n",(0,i.jsx)(n.li,{children:"Maintain front and back indices for efficient operations"}),"\n",(0,i.jsx)(n.li,{children:"Handle edge cases (empty deque, single element)"}),"\n",(0,i.jsx)(n.li,{children:"Implement size tracking for quick length checks"}),"\n",(0,i.jsx)(n.li,{children:"Clear references to prevent memory leaks"}),"\n",(0,i.jsx)(n.li,{children:"Use type checking for robust implementation"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"memory-efficient-version",children:"Memory-Efficient Version"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"class CompactDeque {\n    constructor() {\n        this.items = new Array(16);  // Initial capacity\n        this.front = 8;              // Start in middle\n        this.back = 8;\n        this.capacity = 16;\n    }\n\n    resize(newCapacity) {\n        const newItems = new Array(newCapacity);\n        const size = this.size();\n        const newFront = Math.floor((newCapacity - size) / 2);\n        \n        for (let i = 0; i < size; i++) {\n            newItems[newFront + i] = this.items[(this.front + i) % this.capacity];\n        }\n        \n        this.items = newItems;\n        this.capacity = newCapacity;\n        this.front = newFront;\n        this.back = newFront + size;\n    }\n\n    addFront(item) {\n        if (this.front === 0) {\n            this.resize(this.capacity * 2);\n        }\n        this.front--;\n        this.items[this.front] = item;\n    }\n\n    addBack(item) {\n        if (this.back === this.capacity) {\n            this.resize(this.capacity * 2);\n        }\n        this.items[this.back] = item;\n        this.back++;\n    }\n\n    size() {\n        return this.back - this.front;\n    }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"common-pitfalls",children:"Common Pitfalls"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"\u274c Using array shift/unshift operations (O(n) complexity)"}),"\n",(0,i.jsx)(n.li,{children:"\u274c Not handling empty deque cases"}),"\n",(0,i.jsx)(n.li,{children:"\u274c Forgetting to update indices after operations"}),"\n",(0,i.jsx)(n.li,{children:"\u274c Not cleaning up removed elements"}),"\n",(0,i.jsx)(n.li,{children:"\u274c Inefficient resizing strategies"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"performance-tips",children:"Performance Tips"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Use object/array implementation instead of linked list"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Implement lazy cleanup for removed elements"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Use power-of-two capacity for efficient resizing"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Maintain indices instead of restructuring data"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Batch operations when possible"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>d,x:()=>a});var i=t(96540);const s={},r=i.createContext(s);function d(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:d(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);