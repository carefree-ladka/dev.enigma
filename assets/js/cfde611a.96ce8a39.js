"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[10692],{28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>c});var r=t(96540);const i={},s=r.createContext(i);function a(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(s.Provider,{value:n},e.children)}},65979:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>c,toc:()=>o});var r=t(74848),i=t(28453);const s={},a="Thread Safety in System Design",c={id:"Java Multithreading/Thread Safety in System Design",title:"Thread Safety in System Design",description:'What Does "Make It Thread-Safe" Mean?',source:"@site/docs/Java Multithreading/Thread Safety in System Design.mdx",sourceDirName:"Java Multithreading",slug:"/Java Multithreading/Thread Safety in System Design",permalink:"/docs/Java Multithreading/Thread Safety in System Design",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/Java Multithreading/Thread Safety in System Design.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Producer-Consumer Problem & Race Conditions",permalink:"/docs/Java Multithreading/Producer-Consumer Problem & Race Conditions"},next:{title:"Tips & Tricks",permalink:"/docs/category/tips--tricks"}},l={},o=[{value:"What Does &quot;Make It Thread-Safe&quot; Mean?",id:"what-does-make-it-thread-safe-mean",level:2},{value:"Step 1: Identify Shared Mutable State",id:"step-1-identify-shared-mutable-state",level:2},{value:"Common Examples:",id:"common-examples",level:3},{value:"Step 2: Choose the Right Synchronization Strategy",id:"step-2-choose-the-right-synchronization-strategy",level:2},{value:"Step 3: Thread-Safety Patterns",id:"step-3-thread-safety-patterns",level:2},{value:"1. Synchronized Methods",id:"1-synchronized-methods",level:3},{value:"2. Concurrent Collections",id:"2-concurrent-collections",level:3},{value:"3. Atomic Variables",id:"3-atomic-variables",level:3},{value:"4. Thread-Safe Singleton",id:"4-thread-safe-singleton",level:3},{value:"5. Explicit Locks (ReentrantLock)",id:"5-explicit-locks-reentrantlock",level:3},{value:"6. Read-Write Locks",id:"6-read-write-locks",level:3},{value:"Step 4: Avoiding Deadlocks",id:"step-4-avoiding-deadlocks",level:2},{value:"Best Practices:",id:"best-practices",level:3},{value:"Step 5: Interview Communication Strategy",id:"step-5-interview-communication-strategy",level:2},{value:"Quick Reference Checklist",id:"quick-reference-checklist",level:2},{value:"Key Takeaway",id:"key-takeaway",level:2}];function d(e){const n={blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"thread-safety-in-system-design",children:"Thread Safety in System Design"})}),"\n",(0,r.jsx)(n.h2,{id:"what-does-make-it-thread-safe-mean",children:'What Does "Make It Thread-Safe" Mean?'}),"\n",(0,r.jsx)(n.p,{children:"When an interviewer asks you to make your design thread-safe, they're evaluating:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"\u2705 Can multiple threads safely access your class/API simultaneously?"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Will shared data remain consistent under concurrent access?"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Have you prevented race conditions, deadlocks, and data corruption?"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"step-1-identify-shared-mutable-state",children:"Step 1: Identify Shared Mutable State"}),"\n",(0,r.jsxs)(n.p,{children:["Thread safety concerns arise only when you have ",(0,r.jsx)(n.strong,{children:"shared mutable state"})," \u2014 data that:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Can be modified (mutable)"}),"\n",(0,r.jsx)(n.li,{children:"Is accessed by multiple threads (shared)"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"common-examples",children:"Common Examples:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Caches (Map, List, Set)"}),"\n",(0,r.jsx)(n.li,{children:"Singleton instances"}),"\n",(0,r.jsx)(n.li,{children:"Counters, queues, session managers"}),"\n",(0,r.jsx)(n.li,{children:"Database/file access coordinators"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Already Thread-Safe:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Immutable objects (String, records with final fields)"}),"\n",(0,r.jsx)(n.li,{children:"Local variables (confined to thread stack)"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"step-2-choose-the-right-synchronization-strategy",children:"Step 2: Choose the Right Synchronization Strategy"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Problem"}),(0,r.jsx)(n.th,{children:"Solution"}),(0,r.jsx)(n.th,{children:"Java Implementation"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Shared variable updates"}),(0,r.jsx)(n.td,{children:"Lock critical sections"}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"synchronized"}),", ",(0,r.jsx)(n.code,{children:"ReentrantLock"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Atomic operations (counters/flags)"}),(0,r.jsx)(n.td,{children:"Lock-free atomics"}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"AtomicInteger"}),", ",(0,r.jsx)(n.code,{children:"AtomicBoolean"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Shared collections"}),(0,r.jsx)(n.td,{children:"Concurrent data structures"}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"ConcurrentHashMap"}),", ",(0,r.jsx)(n.code,{children:"CopyOnWriteArrayList"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Singleton initialization"}),(0,r.jsx)(n.td,{children:"Thread-safe Singleton"}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"volatile"})," + double-checked locking"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Limited resource access"}),(0,r.jsx)(n.td,{children:"Semaphores"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Semaphore"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Read-heavy workloads"}),(0,r.jsx)(n.td,{children:"Read-write locks"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"ReentrantReadWriteLock"})})]})]})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"step-3-thread-safety-patterns",children:"Step 3: Thread-Safety Patterns"}),"\n",(0,r.jsx)(n.h3,{id:"1-synchronized-methods",children:"1. Synchronized Methods"}),"\n",(0,r.jsx)(n.p,{children:"Protects shared state with implicit locks:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"class BankAccount {\n    private int balance;\n\n    public synchronized void deposit(int amount) {\n        balance += amount;\n    }\n\n    public synchronized void withdraw(int amount) {\n        if (balance >= amount) {\n            balance -= amount;\n        }\n    }\n\n    public synchronized int getBalance() {\n        return balance;\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Pros:"})," Simple, prevents race conditions\n",(0,r.jsx)(n.strong,{children:"Cons:"})," Entire method is locked, can be slow"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"2-concurrent-collections",children:"2. Concurrent Collections"}),"\n",(0,r.jsx)(n.p,{children:"Replace standard collections with thread-safe alternatives:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"// \u274c Not thread-safe\nMap<String, User> cache = new HashMap<>();\n\n// \u2705 Thread-safe\nMap<String, User> cache = new ConcurrentHashMap<>();\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Benefits:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Segment-level locking (better performance)"}),"\n",(0,r.jsx)(n.li,{children:"No explicit synchronization needed"}),"\n",(0,r.jsxs)(n.li,{children:["Built-in atomic operations like ",(0,r.jsx)(n.code,{children:"putIfAbsent()"})]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"3-atomic-variables",children:"3. Atomic Variables"}),"\n",(0,r.jsx)(n.p,{children:"For counters and flags without explicit locks:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"import java.util.concurrent.atomic.AtomicInteger;\n\nclass RequestCounter {\n    private AtomicInteger count = new AtomicInteger(0);\n\n    public void increment() {\n        count.incrementAndGet();\n    }\n\n    public int getCount() {\n        return count.get();\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Why?"})," Lock-free, CAS-based (Compare-And-Swap), faster than synchronized"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"4-thread-safe-singleton",children:"4. Thread-Safe Singleton"}),"\n",(0,r.jsx)(n.p,{children:"Ensures only one instance is created, even with multiple threads:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"class CacheManager {\n    private static volatile CacheManager instance;\n\n    private CacheManager() {}\n\n    public static CacheManager getInstance() {\n        if (instance == null) {\n            synchronized (CacheManager.class) {\n                if (instance == null) {\n                    instance = new CacheManager();\n                }\n            }\n        }\n        return instance;\n    }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Key Points:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"volatile"})," prevents instruction reordering"]}),"\n",(0,r.jsx)(n.li,{children:"Double-checked locking minimizes synchronization overhead"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"5-explicit-locks-reentrantlock",children:"5. Explicit Locks (ReentrantLock)"}),"\n",(0,r.jsx)(n.p,{children:"More flexible than synchronized:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"import java.util.concurrent.locks.ReentrantLock;\n\nclass SafeCounter {\n    private int count = 0;\n    private final ReentrantLock lock = new ReentrantLock();\n\n    public void increment() {\n        lock.lock();\n        try {\n            count++;\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Advantages over synchronized:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Try-lock with timeout"}),"\n",(0,r.jsx)(n.li,{children:"Fairness policies"}),"\n",(0,r.jsx)(n.li,{children:"Interruptible locking"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"6-read-write-locks",children:"6. Read-Write Locks"}),"\n",(0,r.jsx)(n.p,{children:"Optimized for read-heavy scenarios:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"import java.util.concurrent.locks.ReentrantReadWriteLock;\n\nclass ConfigStore {\n    private Map<String, String> config = new HashMap<>();\n    private final ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();\n\n    public void updateConfig(String key, String value) {\n        rwLock.writeLock().lock();\n        try {\n            config.put(key, value);\n        } finally {\n            rwLock.writeLock().unlock();\n        }\n    }\n\n    public String getConfig(String key) {\n        rwLock.readLock().lock();\n        try {\n            return config.get(key);\n        } finally {\n            rwLock.readLock().unlock();\n        }\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Benefits:"})," Multiple concurrent readers, exclusive writer"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"step-4-avoiding-deadlocks",children:"Step 4: Avoiding Deadlocks"}),"\n",(0,r.jsx)(n.h3,{id:"best-practices",children:"Best Practices:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Consistent lock ordering"})," \u2014 Always acquire locks in the same order"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Always release locks"})," \u2014 Use try-finally blocks"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Minimize lock scope"})," \u2014 Hold locks for shortest time possible"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use tryLock()"})," \u2014 Timeout-based lock attempts"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Avoid nested locks"})," \u2014 Unless absolutely necessary"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"// \u274c Potential deadlock\nsynchronized(lockA) {\n    synchronized(lockB) { ... }\n}\n\n// \u2705 Use tryLock with timeout\nif (lockA.tryLock(100, TimeUnit.MILLISECONDS)) {\n    try {\n        if (lockB.tryLock(100, TimeUnit.MILLISECONDS)) {\n            try {\n                // Critical section\n            } finally {\n                lockB.unlock();\n            }\n        }\n    } finally {\n        lockA.unlock();\n    }\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"step-5-interview-communication-strategy",children:"Step 5: Interview Communication Strategy"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"When asked:"})," ",(0,r.jsx)(n.em,{children:'"Now make your design thread-safe"'})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Your response:"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"\"I'll identify shared mutable state in the design \u2014 like the cache and request counter. For the cache, I'll replace HashMap with ConcurrentHashMap to allow concurrent reads/writes safely. For the counter, I'll use AtomicInteger for lock-free increments."}),"\n",(0,r.jsx)(n.p,{children:"If we have a singleton, I'll implement double-checked locking with volatile to prevent race conditions during initialization."}),"\n",(0,r.jsx)(n.p,{children:"For read-heavy components like configuration stores, I'll use ReentrantReadWriteLock to allow multiple concurrent readers while ensuring exclusive write access."}),"\n",(0,r.jsx)(n.p,{children:"Finally, I'll ensure consistent lock ordering to prevent deadlocks and keep critical sections minimal to avoid performance bottlenecks.\""}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"quick-reference-checklist",children:"Quick Reference Checklist"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Concern"}),(0,r.jsx)(n.th,{children:"Solution"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Shared mutable state"}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"synchronized"})," or ",(0,r.jsx)(n.code,{children:"ReentrantLock"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Collections"}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"ConcurrentHashMap"}),", ",(0,r.jsx)(n.code,{children:"CopyOnWriteArrayList"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Counters/flags"}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"AtomicInteger"}),", ",(0,r.jsx)(n.code,{children:"AtomicBoolean"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Singleton"}),(0,r.jsxs)(n.td,{children:["Double-checked locking + ",(0,r.jsx)(n.code,{children:"volatile"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Read-heavy workload"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"ReentrantReadWriteLock"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Resource limits"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Semaphore"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Deadlock prevention"}),(0,r.jsxs)(n.td,{children:["Consistent ordering, ",(0,r.jsx)(n.code,{children:"tryLock()"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Best approach"}),(0,r.jsx)(n.td,{children:"Prefer immutability when possible"})]})]})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"key-takeaway",children:"Key Takeaway"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Thread safety isn't about making everything synchronized \u2014 it's about:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Identifying what truly needs protection"}),"\n",(0,r.jsx)(n.li,{children:"Choosing the right tool for the job"}),"\n",(0,r.jsx)(n.li,{children:"Balancing safety with performance"}),"\n",(0,r.jsx)(n.li,{children:"Communicating your reasoning clearly"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'import java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\n/**\n * Thread-Safe URL Shortener Service\n * Demonstrates multiple thread-safety techniques\n */\npublic class URLShortenerService {\n\n    // Thread-safe collections for storing mappings\n    private final Map<String, String> shortToLongURL = new ConcurrentHashMap<>();\n    private final Map<String, URLStats> urlStats = new ConcurrentHashMap<>();\n\n    // Atomic counter for generating unique IDs\n    private final AtomicLong idGenerator = new AtomicLong(1000);\n\n    // Read-write lock for rate limiting configuration\n    private final RateLimitConfig rateLimitConfig = new RateLimitConfig();\n\n    // Thread-safe Singleton instance\n    private static volatile URLShortenerService instance;\n\n    private URLShortenerService() {}\n\n    // Thread-safe Singleton with double-checked locking\n    public static URLShortenerService getInstance() {\n        if (instance == null) {\n            synchronized (URLShortenerService.class) {\n                if (instance == null) {\n                    instance = new URLShortenerService();\n                }\n            }\n        }\n        return instance;\n    }\n\n    /**\n     * Creates a shortened URL\n     * Thread-safe: Uses atomic counter and concurrent map\n     */\n    public String createShortURL(String longURL) {\n        if (longURL == null || longURL.isEmpty()) {\n            throw new IllegalArgumentException("URL cannot be empty");\n        }\n\n        // Generate unique short code using atomic counter\n        long id = idGenerator.getAndIncrement();\n        String shortCode = encodeBase62(id);\n\n        // Store mapping atomically\n        shortToLongURL.put(shortCode, longURL);\n\n        // Initialize statistics\n        urlStats.put(shortCode, new URLStats(longURL));\n\n        return "short.ly/" + shortCode;\n    }\n\n    /**\n     * Retrieves original URL and updates statistics\n     * Thread-safe: Uses concurrent map and atomic operations\n     */\n    public String getOriginalURL(String shortCode) {\n        String longURL = shortToLongURL.get(shortCode);\n\n        if (longURL != null) {\n            // Update statistics atomically\n            URLStats stats = urlStats.get(shortCode);\n            if (stats != null) {\n                stats.incrementClicks();\n            }\n        }\n\n        return longURL;\n    }\n\n    /**\n     * Gets click statistics for a URL\n     * Thread-safe: Reads from concurrent map\n     */\n    public long getClickCount(String shortCode) {\n        URLStats stats = urlStats.get(shortCode);\n        return stats != null ? stats.getClicks() : 0;\n    }\n\n    /**\n     * Deletes a shortened URL\n     * Thread-safe: Atomic removal from concurrent maps\n     */\n    public boolean deleteShortURL(String shortCode) {\n        String removed = shortToLongURL.remove(shortCode);\n        if (removed != null) {\n            urlStats.remove(shortCode);\n            return true;\n        }\n        return false;\n    }\n\n    // Simple Base62 encoding\n    private String encodeBase62(long num) {\n        String chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";\n        StringBuilder sb = new StringBuilder();\n\n        while (num > 0) {\n            sb.append(chars.charAt((int)(num % 62)));\n            num /= 62;\n        }\n\n        return sb.reverse().toString();\n    }\n\n    /**\n     * Thread-safe statistics tracker using atomic operations\n     */\n    static class URLStats {\n        private final String originalURL;\n        private final AtomicLong clickCount = new AtomicLong(0);\n        private final long createdAt;\n\n        public URLStats(String originalURL) {\n            this.originalURL = originalURL;\n            this.createdAt = System.currentTimeMillis();\n        }\n\n        public void incrementClicks() {\n            clickCount.incrementAndGet();\n        }\n\n        public long getClicks() {\n            return clickCount.get();\n        }\n\n        public String getOriginalURL() {\n            return originalURL;\n        }\n    }\n\n    /**\n     * Thread-safe rate limit configuration using Read-Write Lock\n     * Optimized for many reads, few writes\n     */\n    static class RateLimitConfig {\n        private int maxRequestsPerMinute = 100;\n        private final ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();\n\n        public int getMaxRequests() {\n            rwLock.readLock().lock();\n            try {\n                return maxRequestsPerMinute;\n            } finally {\n                rwLock.readLock().unlock();\n            }\n        }\n\n        public void setMaxRequests(int max) {\n            rwLock.writeLock().lock();\n            try {\n                maxRequestsPerMinute = max;\n            } finally {\n                rwLock.writeLock().unlock();\n            }\n        }\n    }\n\n    /**\n     * Demo: Simulating concurrent access\n     */\n    public static void main(String[] args) throws InterruptedException {\n        URLShortenerService service = URLShortenerService.getInstance();\n\n        System.out.println("=== Thread-Safe URL Shortener Demo ===\\n");\n\n        // Create a short URL\n        String shortURL = service.createShortURL("https://example.com/very/long/url");\n        String shortCode = shortURL.replace("short.ly/", "");\n        System.out.println("Created: " + shortURL);\n\n        // Simulate concurrent access from 10 threads\n        System.out.println("\\nSimulating 10 concurrent threads accessing the URL...");\n\n        Thread[] threads = new Thread[10];\n        for (int i = 0; i < 10; i++) {\n            threads[i] = new Thread(() -> {\n                for (int j = 0; j < 100; j++) {\n                    service.getOriginalURL(shortCode);\n                }\n            });\n            threads[i].start();\n        }\n\n        // Wait for all threads to complete\n        for (Thread thread : threads) {\n            thread.join();\n        }\n\n        // Check final count - should be exactly 1000 (10 threads \xd7 100 requests)\n        long finalCount = service.getClickCount(shortCode);\n        System.out.println("\\nTotal clicks recorded: " + finalCount);\n        System.out.println("Expected: 1000");\n        System.out.println("Thread-safe: " + (finalCount == 1000 ? "\u2705 YES" : "\u274c NO"));\n\n        // Test thread-safe deletion\n        boolean deleted = service.deleteShortURL(shortCode);\n        System.out.println("\\nDeleted URL: " + deleted);\n    }\n}\n'})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);