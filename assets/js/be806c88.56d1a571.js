"use strict";(globalThis.webpackChunkdev_enigma=globalThis.webpackChunkdev_enigma||[]).push([[19385],{25571:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>l});var i=t(74848),s=t(28453);const r={},o="Shortest Paths Problems",a={id:"DSA/DSA/DSA with JavaScript/ShortestPaths",title:"Shortest Paths Problems",description:"Problem: Shortest Path with Maximum Distance from Fire",source:"@site/docs/05-DSA/DSA/DSA with JavaScript/ShortestPaths.mdx",sourceDirName:"05-DSA/DSA/DSA with JavaScript",slug:"/DSA/DSA/DSA with JavaScript/ShortestPaths",permalink:"/docs/DSA/DSA/DSA with JavaScript/ShortestPaths",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/05-DSA/DSA/DSA with JavaScript/ShortestPaths.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Segment Tree Tutorial",permalink:"/docs/DSA/DSA/DSA with JavaScript/SegmentTree"},next:{title:"Sieve of Eratosthenes",permalink:"/docs/DSA/DSA/DSA with JavaScript/SieveOfEratosthenes"}},c={},l=[{value:"Problem: Shortest Path with Maximum Distance from Fire",id:"problem-shortest-path-with-maximum-distance-from-fire",level:2},{value:"Constraints",id:"constraints",level:2},{value:"Input",id:"input",level:2},{value:"Output",id:"output",level:2},{value:"Problem: Optimal Apartment Location",id:"problem-optimal-apartment-location",level:2},{value:"Description",id:"description",level:2},{value:"Constraints",id:"constraints-1",level:2},{value:"Input",id:"input-1",level:2},{value:"Output",id:"output-1",level:2},{value:"Minimum Combined Travel Cost for Alice and Bob",id:"minimum-combined-travel-cost-for-alice-and-bob",level:2},{value:"Example",id:"example",level:2},{value:"Explanation:",id:"explanation",level:3},{value:"Input",id:"input-2",level:2},{value:"Output",id:"output-2",level:2},{value:"Constraints",id:"constraints-2",level:2},{value:"Approach",id:"approach",level:2},{value:"Find the Nearest Favorite City Using Dijkstra&#39;s Algorithm with BFS",id:"find-the-nearest-favorite-city-using-dijkstras-algorithm-with-bfs",level:2},{value:"Problem Statement",id:"problem-statement",level:3},{value:"Input",id:"input-3",level:3},{value:"Output",id:"output-3",level:3}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"shortest-paths-problems",children:"Shortest Paths Problems"})}),"\n",(0,i.jsx)(e.h2,{id:"problem-shortest-path-with-maximum-distance-from-fire",children:"Problem: Shortest Path with Maximum Distance from Fire"}),"\n",(0,i.jsxs)(e.p,{children:["The ant can move in four directions: ",(0,i.jsx)(e.strong,{children:"up"}),", ",(0,i.jsx)(e.strong,{children:"down"}),", ",(0,i.jsx)(e.strong,{children:"left"}),", or ",(0,i.jsx)(e.strong,{children:"right"}),". The goal is to find the ",(0,i.jsx)(e.strong,{children:"shortest path"})," from ",(0,i.jsx)(e.code,{children:"(0, 0)"})," to ",(0,i.jsx)(e.code,{children:"(m-1, n-1)"})," while ensuring that the ant stays as far away from the fire as possible. Specifically, the path should maximize the ",(0,i.jsx)(e.strong,{children:"minimum distance"})," from any fire cell along the way."]}),"\n",(0,i.jsx)(e.h2,{id:"constraints",children:"Constraints"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:["The grid will have dimensions ",(0,i.jsx)(e.code,{children:"m x n"}),", where ",(0,i.jsx)(e.code,{children:"1 <= m, n <= 100"}),"."]}),"\n",(0,i.jsxs)(e.li,{children:["The ant cannot travel through cells with fire (",(0,i.jsx)(e.code,{children:"F"}),")."]}),"\n",(0,i.jsx)(e.li,{children:"The ant can move in four directions: up, down, left, or right."}),"\n",(0,i.jsxs)(e.li,{children:["If no valid path exists, return ",(0,i.jsx)(e.code,{children:"-1"}),"."]}),"\n",(0,i.jsx)(e.li,{children:"The distance from a cell to the fire is the Manhattan distance to the nearest fire cell."}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"input",children:"Input"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["A 2D grid of characters (",(0,i.jsx)(e.code,{children:"F"})," or ",(0,i.jsx)(e.code,{children:"."}),") representing the map."]}),"\n",(0,i.jsxs)(e.li,{children:["The starting position is ",(0,i.jsx)(e.code,{children:"(0, 0)"}),", and the destination is ",(0,i.jsx)(e.code,{children:"(m-1, n-1)"}),"."]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"output",children:"Output"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["Return the length of the shortest path from ",(0,i.jsx)(e.code,{children:"(0, 0)"})," to ",(0,i.jsx)(e.code,{children:"(m-1, n-1)"})," while maximizing the minimum distance from any fire cell."]}),"\n",(0,i.jsxs)(e.li,{children:["If no such path exists, return ",(0,i.jsx)(e.code,{children:"-1"}),"."]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-JavaScript",children:"function shortestPathWithMaxDistanceFromFire(grid) {\n  const m = grid.length;\n  const n = grid[0].length;\n\n  // Directions for moving up, down, left, right\n  const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];\n\n  // Step 1: Precompute the distance of each cell from the nearest fire\n  const fireDistance = new Array(m).fill().map(() => new Array(n).fill(Infinity));\n  const queue = [];\n\n  // Initialize the queue with all fire positions\n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      if (grid[i][j] === 'F') {\n        queue.push([i, j]);\n        fireDistance[i][j] = 0;\n      }\n    }\n  }\n\n  // BFS to compute the distance from each fire\n  while (queue.length > 0) {\n    const [x, y] = queue.shift();\n    for (const [dx, dy] of directions) {\n      const nx = x + dx;\n      const ny = y + dy;\n      if (nx >= 0 && nx < m && ny >= 0 && ny < n && fireDistance[nx][ny] === Infinity) {\n        fireDistance[nx][ny] = fireDistance[x][y] + 1;\n        queue.push([nx, ny]);\n      }\n    }\n  }\n\n  // Step 2: Find the shortest path with maximum distance from fire\n  const visited = new Array(m).fill().map(() => new Array(n).fill(false));\n  const priorityQueue = [];\n\n  // Start from (0, 0) with distance 0 and the distance from fire at that cell\n  priorityQueue.push([0, 0, 0, fireDistance[0][0]]);\n  visited[0][0] = true;\n\n  while (priorityQueue.length > 0) {\n    priorityQueue.sort((a, b) => b[3] - a[3]); // Sort by distance from fire (max first)\n    const [x, y, dist, fireDist] = priorityQueue.pop();\n\n    // If we reach the destination, return the distance\n    if (x === m - 1 && y === n - 1) {\n      return dist;\n    }\n\n    // Explore all four directions\n    for (const [dx, dy] of directions) {\n      const nx = x + dx;\n      const ny = y + dy;\n      if (nx >= 0 && nx < m && ny >= 0 && ny < n && !visited[nx][ny] && grid[nx][ny] === '.') {\n        visited[nx][ny] = true;\n        priorityQueue.push([nx, ny, dist + 1, fireDistance[nx][ny]]);\n      }\n    }\n  }\n\n  // If no path is found\n  return -1;\n}\n\n// Example usage:\nconst grid = [\n  ['.', 'F', '.', '.'],\n  ['.', '.', '.', 'F'],\n  ['F', '.', '.', '.'],\n  ['.', '.', 'F', '.']\n];\n\nconsole.log(shortestPathWithMaxDistanceFromFire(grid)); // Output: 6\n\nconst grid2 = [\n  ['.', '.', '.', '.'],\n  ['.', 'F', '.', '.'],\n  ['.', '.', '.', '.'],\n  ['.', '.', '.', '.']\n];\n\nconsole.log(shortestPathWithMaxDistanceFromFire(grid2)); // Output: 5\n"})}),"\n",(0,i.jsx)(e.h2,{id:"problem-optimal-apartment-location",children:"Problem: Optimal Apartment Location"}),"\n",(0,i.jsx)(e.h2,{id:"description",children:"Description"}),"\n",(0,i.jsx)(e.p,{children:"You are planning to move to a new city and want to find the optimal apartment location. The city is represented as a 2D grid, where each cell can be:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"A potential apartment location."}),"\n",(0,i.jsx)(e.li,{children:"A key location (e.g., gym, office, restaurant, etc.)."}),"\n",(0,i.jsx)(e.li,{children:"An obstacle (e.g., park, lake, etc.) that cannot be traversed."}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:["Your goal is to find the apartment location that is ",(0,i.jsx)(e.strong,{children:"closest to all key locations"})," (e.g., gym, office, restaurant, etc.). The optimal apartment is the one that minimizes the ",(0,i.jsx)(e.strong,{children:"total distance"})," (or travel time) to all key locations."]}),"\n",(0,i.jsx)(e.h2,{id:"constraints-1",children:"Constraints"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:["The grid will have dimensions ",(0,i.jsx)(e.code,{children:"m x n"}),", where ",(0,i.jsx)(e.code,{children:"1 <= m, n <= 100"}),"."]}),"\n",(0,i.jsxs)(e.li,{children:["You can move in four directions: ",(0,i.jsx)(e.strong,{children:"up"}),", ",(0,i.jsx)(e.strong,{children:"down"}),", ",(0,i.jsx)(e.strong,{children:"left"}),", or ",(0,i.jsx)(e.strong,{children:"right"}),"."]}),"\n",(0,i.jsxs)(e.li,{children:["Obstacles are represented by ",(0,i.jsx)(e.code,{children:"X"}),", and you cannot travel through them."]}),"\n",(0,i.jsxs)(e.li,{children:["Key locations are represented by unique identifiers (e.g., ",(0,i.jsx)(e.code,{children:"G"})," for gym, ",(0,i.jsx)(e.code,{children:"O"})," for office, ",(0,i.jsx)(e.code,{children:"R"})," for restaurant, etc.)."]}),"\n",(0,i.jsxs)(e.li,{children:["Apartment locations are represented by ",(0,i.jsx)(e.code,{children:"A"}),"."]}),"\n",(0,i.jsxs)(e.li,{children:["If no valid apartment location exists, return ",(0,i.jsx)(e.code,{children:"-1"}),"."]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"input-1",children:"Input"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["A 2D grid of characters representing the city map. The grid contains:","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"A"}),": Potential apartment locations."]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"G"}),", ",(0,i.jsx)(e.code,{children:"O"}),", ",(0,i.jsx)(e.code,{children:"R"}),", etc.: Key locations (gym, office, restaurant, etc.)."]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"X"}),": Obstacles that cannot be traversed."]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"."}),": Empty spaces that can be traversed."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"output-1",children:"Output"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["Return the coordinates ",(0,i.jsx)(e.code,{children:"(x, y)"})," of the optimal apartment location that minimizes the total distance to all key locations."]}),"\n",(0,i.jsxs)(e.li,{children:["If no valid apartment location exists, return ",(0,i.jsx)(e.code,{children:"-1"}),"."]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-JavaScript",children:"function findOptimalApartment(grid, keyLocations) {\n    const m = grid.length;\n    const n = grid[0].length;\n    const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]; // Up, Down, Left, Right\n\n    // Initialize distance grids for each key location\n    const distanceGrids = keyLocations.map(([x, y]) => {\n        const distanceGrid = new Array(m).fill().map(() => new Array(n).fill(Infinity));\n        const queue = [[x, y]];\n        distanceGrid[x][y] = 0;\n\n        // BFS to compute distances from this key location\n        while (queue.length > 0) {\n            const [cx, cy] = queue.shift();\n            for (const [dx, dy] of directions) {\n                const nx = cx + dx;\n                const ny = cy + dy;\n                if (nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] !== 'X' && distanceGrid[nx][ny] === Infinity) {\n                    distanceGrid[nx][ny] = distanceGrid[cx][cy] + 1;\n                    queue.push([nx, ny]);\n                }\n            }\n        }\n        return distanceGrid;\n    });\n\n    // Find the apartment with the smallest total distance to all key locations\n    let minTotalDistance = Infinity;\n    let optimalApartment = null;\n\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (grid[i][j] === 'A') { // 'A' represents an apartment\n                let totalDistance = 0;\n                for (const distanceGrid of distanceGrids) {\n                    totalDistance += distanceGrid[i][j];\n                }\n                if (totalDistance < minTotalDistance) {\n                    minTotalDistance = totalDistance;\n                    optimalApartment = [i, j];\n                }\n            }\n        }\n    }\n\n    return optimalApartment;\n}\n\n// Example usage\nconst grid = [\n    ['.', '.', '.', '.', '.'],\n    ['.', 'G', '.', 'X', '.'],\n    ['.', '.', 'A', '.', '.'],\n    ['.', 'X', '.', 'O', '.'],\n    ['.', '.', '.', '.', 'R']\n];\n\nconst keyLocations = [\n    [1, 1], // Gym (G)\n    [3, 3], // Office (O)\n    [4, 4]  // Restaurant (R)\n];\n\nconst optimalApartment = findOptimalApartment(grid, keyLocations);\nconsole.log(\"Optimal Apartment Location:\", optimalApartment); // Output: [2, 2]\n"})}),"\n",(0,i.jsx)(e.h2,{id:"minimum-combined-travel-cost-for-alice-and-bob",children:"Minimum Combined Travel Cost for Alice and Bob"}),"\n",(0,i.jsxs)(e.p,{children:["You are given a graph of cities where each vertex represents a city, and the edges represent the connectivity between two cities. The cost to travel from one city to another connected by a single edge is ",(0,i.jsx)(e.strong,{children:"1 unit"}),". Two friends, Alice and Bob, live in two different cities and want to reach a destination city to attend a concert. Both Alice and Bob plan to take cabs from their respective cities to reach the destination. They may decide to share a cab at some point to minimize the total cost of traveling to the destination city."]}),"\n",(0,i.jsxs)(e.p,{children:["Your task is to find the ",(0,i.jsx)(e.strong,{children:"minimum combined cost"})," for both Alice and Bob to reach the destination city."]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"example",children:"Example"}),"\n",(0,i.jsx)(e.p,{children:"Consider the following graph:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-plaintext",children:"A - B\n|   |\nD - C\n|   |\nE - F\n"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Alice's starting city"}),": A"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Bob's starting city"}),": E"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Destination city"}),": C"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"explanation",children:"Explanation:"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:["Alice travels from ",(0,i.jsx)(e.strong,{children:"A to D"})," (cost = 1)."]}),"\n",(0,i.jsxs)(e.li,{children:["Bob travels from ",(0,i.jsx)(e.strong,{children:"E to D"})," (cost = 1)."]}),"\n",(0,i.jsxs)(e.li,{children:["Both Alice and Bob share a cab from ",(0,i.jsx)(e.strong,{children:"D to C"})," (cost = 1)."]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Total cost = 1 + 1 + 1 = 3"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"input-2",children:"Input"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"A graph represented as an adjacency list or matrix."}),"\n",(0,i.jsx)(e.li,{children:"The starting cities for Alice and Bob."}),"\n",(0,i.jsx)(e.li,{children:"The destination city."}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"output-2",children:"Output"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"The minimum combined cost for Alice and Bob to reach the destination city."}),"\n"]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"constraints-2",children:"Constraints"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"The graph is undirected and unweighted (each edge has a cost of 1 unit)."}),"\n",(0,i.jsx)(e.li,{children:"Alice and Bob can share a cab at any point during their journey."}),"\n"]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"approach",children:"Approach"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:["Use ",(0,i.jsx)(e.strong,{children:"Breadth-First Search (BFS)"})," to compute the shortest distance from Alice's starting city to all other cities."]}),"\n",(0,i.jsx)(e.li,{children:"Use BFS to compute the shortest distance from Bob's starting city to all other cities."}),"\n",(0,i.jsx)(e.li,{children:"Use BFS to compute the shortest distance from the destination city to all other cities."}),"\n",(0,i.jsx)(e.li,{children:"Iterate through all cities to find the optimal meeting point where the combined cost of Alice and Bob traveling to the meeting point and then sharing a cab to the destination is minimized."}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-JavaScript",children:"function minTravelCost(edges, alice, bob, destination) {\n  // Build adjacency list for the graph\n  let graph = new Map();\n\n  edges.forEach(([u, v]) => {\n    if (!graph.has(u)) graph.set(u, []);\n    if (!graph.has(v)) graph.set(v, []);\n    graph.get(u).push(v);\n    graph.get(v).push(u);\n  });\n\n  // BFS function to calculate shortest distances from a given start city\n  function bfs(start) {\n    let queue = [[start, 0]];\n    let distances = new Map();\n    distances.set(start, 0);\n\n    while (queue.length > 0) {\n      let [city, dist] = queue.shift();\n      for (let neighbor of (graph.get(city) || [])) {\n        if (!distances.has(neighbor)) {\n          distances.set(neighbor, dist + 1);\n          queue.push([neighbor, dist + 1]);\n        }\n      }\n    }\n    return distances;\n  }\n\n  // Get shortest paths from Alice, Bob, and the destination\n  let distFromAlice = bfs(alice);\n  let distFromBob = bfs(bob);\n  let distFromDestination = bfs(destination);\n\n  // Find the minimum cost meeting point\n  let minCost = Infinity;\n  for (let city of graph.keys()) {\n    if (distFromAlice.has(city) && distFromBob.has(city) && distFromDestination.has(city)) {\n      let totalCost = distFromAlice.get(city) + distFromBob.get(city) + distFromDestination.get(city);\n      minCost = Math.min(minCost, totalCost);\n    }\n  }\n\n  return minCost;\n}\n\n// Example usage:\nconst edges = [['A', 'B'], ['A', 'D'], ['B', 'C'], ['D', 'C'], ['D', 'E'], ['E', 'F'], ['F', 'C']];\nconsole.log(minTravelCost(edges, 'A', 'E', 'C')); // Output: 3\n"})}),"\n",(0,i.jsx)(e.h2,{id:"find-the-nearest-favorite-city-using-dijkstras-algorithm-with-bfs",children:"Find the Nearest Favorite City Using Dijkstra's Algorithm with BFS"}),"\n",(0,i.jsx)(e.h3,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,i.jsxs)(e.p,{children:["You are given a set of directed connections (weighted edges) between cities. Additionally, you have a list of favorite cities. Given a starting city, find the nearest favorite city using ",(0,i.jsx)(e.strong,{children:"Dijkstra's algorithm implemented with BFS-style traversal"}),"."]}),"\n",(0,i.jsx)(e.h3,{id:"input-3",children:"Input"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"n"}),": Number of cities."]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"edges"}),": A list of directed edges, where each edge is represented as ",(0,i.jsx)(e.code,{children:"[city1, city2, weight]"}),"."]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"favoriteCities"}),": A set containing the names (or indices) of favorite cities."]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"startCity"}),": The city from which the search begins."]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"output-3",children:"Output"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["The nearest favorite city & min distance from ",(0,i.jsx)(e.code,{children:"startCity"}),". If no favorite city is reachable, return ",(0,i.jsx)(e.code,{children:"-1"}),"."]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-JavaScript",children:"function dijkstra(graph, start, favoriteCities) {\n  const distances = {};\n  const pq = new MinPriorityQueue();\n\n  // Initialize distances\n  for (const city in graph) {\n    distances[city] = Infinity;\n  }\n  distances[start] = 0;\n  pq.enqueue(start, 0);\n\n  while (!pq.isEmpty()) {\n    const { element: currentCity, priority: currentDistance } = pq.dequeue();\n\n    if (currentDistance > distances[currentCity]) continue;\n\n    for (const neighbor in graph[currentCity]) {\n      const distance = currentDistance + graph[currentCity][neighbor];\n\n      if (distance < distances[neighbor]) {\n        distances[neighbor] = distance;\n        pq.enqueue(neighbor, distance);\n      }\n    }\n  }\n\n  // Find the nearest favorite city\n  let nearestFavoriteCity = null;\n  let minDistance = Infinity;\n\n  for (const city of favoriteCities) {\n    if (distances[city] < minDistance) {\n      minDistance = distances[city];\n      nearestFavoriteCity = city;\n    }\n  }\n\n  return [nearestFavoriteCity, minDistance];\n}\n\n// Example usage:\nconst graph = {\n  'A': { 'B': 1, 'C': 4 },\n  'B': { 'A': 1, 'C': 2, 'D': 5 },\n  'C': { 'A': 4, 'B': 2, 'D': 1 },\n  'D': { 'B': 5, 'C': 1 }\n};\n\nconst favoriteCities = ['C', 'D'];\nconst startCity = 'A';\n\nconst nearestFavoriteCity = dijkstra(graph, startCity, favoriteCities);\nconsole.log(`The nearest favorite city from ${startCity} is ${nearestFavoriteCity}`);\n/*\nThe nearest favorite city from A is C,3\n*/\n"})})]})}function h(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(d,{...n})}):d(n)}},28453:(n,e,t)=>{t.d(e,{R:()=>o,x:()=>a});var i=t(96540);const s={},r=i.createContext(s);function o(n){const e=i.useContext(r);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:o(n.components),i.createElement(r.Provider,{value:e},n.children)}}}]);