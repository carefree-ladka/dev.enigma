"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[5681],{12387:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>c,frontMatter:()=>s,metadata:()=>o,toc:()=>a});var i=t(74848),r=t(28453);const s={},l="Advanced Algorithm Techniques",o={id:"DSA/DSA with JavaScript/AdvancedTechniques",title:"Advanced Algorithm Techniques",description:"Euler Tour Technique (ETT)",source:"@site/docs/DSA/DSA with JavaScript/AdvancedTechniques.mdx",sourceDirName:"DSA/DSA with JavaScript",slug:"/DSA/DSA with JavaScript/AdvancedTechniques",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/AdvancedTechniques",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with JavaScript/AdvancedTechniques.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"AVL Tree",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/AVLTree"},next:{title:"Breadth-First Search (BFS) for Trees",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/BFSTree"}},d={},a=[{value:"Euler Tour Technique (ETT)",id:"euler-tour-technique-ett",level:2},{value:"Theory",id:"theory",level:3},{value:"Key Concepts",id:"key-concepts",level:3},{value:"Implementation",id:"implementation",level:3},{value:"LeetCode Problems",id:"leetcode-problems",level:3},{value:"Point Update Range Sum (Segment Tree)",id:"point-update-range-sum-segment-tree",level:2},{value:"Theory",id:"theory-1",level:3},{value:"Key Concepts",id:"key-concepts-1",level:3},{value:"Implementation",id:"implementation-1",level:3},{value:"LeetCode Problems",id:"leetcode-problems-1",level:3},{value:"Meet in the Middle",id:"meet-in-the-middle",level:2},{value:"Theory",id:"theory-2",level:3},{value:"Key Concepts",id:"key-concepts-2",level:3},{value:"Implementation Example (Subset Sum)",id:"implementation-example-subset-sum",level:3},{value:"LeetCode Problems",id:"leetcode-problems-2",level:3},{value:"Common Use Cases &amp; Tips",id:"common-use-cases--tips",level:2},{value:"Euler Tour Technique",id:"euler-tour-technique",level:3},{value:"Point Update Range Sum",id:"point-update-range-sum",level:3},{value:"Meet in the Middle",id:"meet-in-the-middle-1",level:3},{value:"Time Complexity Analysis",id:"time-complexity-analysis",level:2},{value:"Euler Tour",id:"euler-tour",level:3},{value:"Segment Tree",id:"segment-tree",level:3},{value:"Meet in the Middle",id:"meet-in-the-middle-2",level:3}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"advanced-algorithm-techniques",children:"Advanced Algorithm Techniques"})}),"\n",(0,i.jsx)(n.h2,{id:"euler-tour-technique-ett",children:"Euler Tour Technique (ETT)"}),"\n",(0,i.jsx)(n.h3,{id:"theory",children:"Theory"}),"\n",(0,i.jsx)(n.p,{children:"The Euler Tour Technique is a method for processing trees by converting them into a linear array representation. It involves performing a DFS traversal and recording each vertex both when entering and leaving it."}),"\n",(0,i.jsx)(n.h3,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Creates a linear representation of a tree"}),"\n",(0,i.jsx)(n.li,{children:"Each node appears twice: entry and exit times"}),"\n",(0,i.jsx)(n.li,{children:"Useful for solving subtree queries efficiently"}),"\n",(0,i.jsx)(n.li,{children:"Time complexity: O(n) for preprocessing, O(1) for queries"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"implementation",children:"Implementation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"class EulerTour {\n    constructor(n) {\n        this.adj = Array.from({ length: n }, () => []);\n        this.tour = [];\n        this.first = new Array(n).fill(-1);\n        this.last = new Array(n).fill(-1);\n    }\n\n    addEdge(u, v) {\n        this.adj[u].push(v);\n        this.adj[v].push(u);\n    }\n\n    dfs(node, parent) {\n        if (this.first[node] === -1) {\n            this.first[node] = this.tour.length;\n        }\n        this.tour.push(node);\n        \n        for (const child of this.adj[node]) {\n            if (child !== parent) {\n                this.dfs(child, node);\n                this.tour.push(node);\n            }\n        }\n        \n        this.last[node] = this.tour.length - 1;\n    }\n\n    buildTour(root = 0) {\n        this.dfs(root, -1);\n        return {\n            tour: this.tour,\n            first: this.first,\n            last: this.last\n        };\n    }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"leetcode-problems",children:"LeetCode Problems"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/kth-ancestor-of-a-tree-node/",children:"1483. Kth Ancestor of a Tree Node"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/minimize-the-total-price-of-the-trips/",children:"2646. Minimize the Total Price of the Trips"})}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"point-update-range-sum-segment-tree",children:"Point Update Range Sum (Segment Tree)"}),"\n",(0,i.jsx)(n.h3,{id:"theory-1",children:"Theory"}),"\n",(0,i.jsx)(n.p,{children:"A Segment Tree is a data structure that allows both range queries and point updates efficiently. It's particularly useful when you need to perform multiple updates and range queries on an array."}),"\n",(0,i.jsx)(n.h3,{id:"key-concepts-1",children:"Key Concepts"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Binary tree structure"}),"\n",(0,i.jsx)(n.li,{children:"Each node represents a range"}),"\n",(0,i.jsx)(n.li,{children:"Supports point updates in O(log n)"}),"\n",(0,i.jsx)(n.li,{children:"Supports range queries in O(log n)"}),"\n",(0,i.jsx)(n.li,{children:"Space complexity: O(n)"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"implementation-1",children:"Implementation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"class SegmentTree {\n    constructor(arr) {\n        this.n = arr.length;\n        this.tree = new Array(4 * this.n).fill(0);\n        this.build(arr, 1, 0, this.n - 1);\n    }\n\n    build(arr, node, start, end) {\n        if (start === end) {\n            this.tree[node] = arr[start];\n            return;\n        }\n\n        const mid = Math.floor((start + end) / 2);\n        this.build(arr, 2 * node, start, mid);\n        this.build(arr, 2 * node + 1, mid + 1, end);\n        this.tree[node] = this.tree[2 * node] + this.tree[2 * node + 1];\n    }\n\n    update(index, val, node = 1, start = 0, end = this.n - 1) {\n        if (start === end) {\n            this.tree[node] = val;\n            return;\n        }\n\n        const mid = Math.floor((start + end) / 2);\n        if (index <= mid) {\n            this.update(index, val, 2 * node, start, mid);\n        } else {\n            this.update(index, val, 2 * node + 1, mid + 1, end);\n        }\n        this.tree[node] = this.tree[2 * node] + this.tree[2 * node + 1];\n    }\n\n    query(left, right, node = 1, start = 0, end = this.n - 1) {\n        if (right < start || left > end) return 0;\n        if (left <= start && end <= right) return this.tree[node];\n\n        const mid = Math.floor((start + end) / 2);\n        const leftSum = this.query(left, right, 2 * node, start, mid);\n        const rightSum = this.query(left, right, 2 * node + 1, mid + 1, end);\n        return leftSum + rightSum;\n    }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"leetcode-problems-1",children:"LeetCode Problems"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/range-sum-query-mutable/",children:"307. Range Sum Query - Mutable"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/booking-concert-tickets-in-groups/",children:"2286. Booking Concert Tickets in Groups"})}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"meet-in-the-middle",children:"Meet in the Middle"}),"\n",(0,i.jsx)(n.h3,{id:"theory-2",children:"Theory"}),"\n",(0,i.jsx)(n.p,{children:"Meet in the Middle is a technique that splits the input into two roughly equal parts, processes them separately, and then combines the results. It's particularly useful when the brute force approach would be too slow."}),"\n",(0,i.jsx)(n.h3,{id:"key-concepts-2",children:"Key Concepts"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Divides the problem into two smaller subproblems"}),"\n",(0,i.jsx)(n.li,{children:"Processes each half independently"}),"\n",(0,i.jsx)(n.li,{children:"Combines results efficiently"}),"\n",(0,i.jsx)(n.li,{children:"Usually reduces time complexity from O(2^n) to O(2^(n/2))"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"implementation-example-subset-sum",children:"Implementation Example (Subset Sum)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"function meetInMiddle(arr, target) {\n    const n = arr.length;\n    const mid = Math.floor(n / 2);\n    \n    // Generate all possible sums for first half\n    function generateSums(start, end) {\n        const sums = [];\n        const len = end - start;\n        \n        for (let mask = 0; mask < (1 << len); mask++) {\n            let sum = 0;\n            for (let i = 0; i < len; i++) {\n                if (mask & (1 << i)) {\n                    sum += arr[start + i];\n                }\n            }\n            sums.push(sum);\n        }\n        return sums.sort((a, b) => a - b);\n    }\n    \n    const leftSums = generateSums(0, mid);\n    const rightSums = generateSums(mid, n);\n    \n    // Binary search to find pairs that sum to target\n    let count = 0;\n    for (const leftSum of leftSums) {\n        const complement = target - leftSum;\n        const low = rightSums.findIndex(x => x >= complement);\n        const high = rightSums.findIndex(x => x > complement);\n        if (low !== -1 && high !== -1) {\n            count += high - low;\n        }\n    }\n    \n    return count;\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"leetcode-problems-2",children:"LeetCode Problems"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/closest-subsequence-sum/",children:"1755. Closest Subsequence Sum"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/",children:"2035. Partition Array Into Two Arrays to Minimize Sum Difference"})}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"common-use-cases--tips",children:"Common Use Cases & Tips"}),"\n",(0,i.jsx)(n.h3,{id:"euler-tour-technique",children:"Euler Tour Technique"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Tree path queries"}),"\n",(0,i.jsx)(n.li,{children:"Subtree problems"}),"\n",(0,i.jsx)(n.li,{children:"LCA (Lowest Common Ancestor) queries"}),"\n",(0,i.jsx)(n.li,{children:"Subtree modification queries"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"point-update-range-sum",children:"Point Update Range Sum"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Dynamic range queries"}),"\n",(0,i.jsx)(n.li,{children:"Interval problems"}),"\n",(0,i.jsx)(n.li,{children:"Cumulative statistics"}),"\n",(0,i.jsx)(n.li,{children:"Online query processing"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"meet-in-the-middle-1",children:"Meet in the Middle"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Subset sum problems"}),"\n",(0,i.jsx)(n.li,{children:"Problems with exponential complexity"}),"\n",(0,i.jsx)(n.li,{children:"Optimization problems with small constraints"}),"\n",(0,i.jsx)(n.li,{children:"When searching through all possibilities is required but too slow"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"time-complexity-analysis",children:"Time Complexity Analysis"}),"\n",(0,i.jsx)(n.h3,{id:"euler-tour",children:"Euler Tour"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Preprocessing: O(n)"}),"\n",(0,i.jsx)(n.li,{children:"Query: O(1) with additional data structures"}),"\n",(0,i.jsx)(n.li,{children:"Space: O(n)"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"segment-tree",children:"Segment Tree"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Build: O(n)"}),"\n",(0,i.jsx)(n.li,{children:"Update: O(log n)"}),"\n",(0,i.jsx)(n.li,{children:"Query: O(log n)"}),"\n",(0,i.jsx)(n.li,{children:"Space: O(n)"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"meet-in-the-middle-2",children:"Meet in the Middle"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Time: O(2^(n/2))"}),"\n",(0,i.jsx)(n.li,{children:"Space: O(2^(n/2))"}),"\n",(0,i.jsx)(n.li,{children:"Typically used when n \u2264 40"}),"\n"]})]})}function c(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>o});var i=t(96540);const r={},s=i.createContext(r);function l(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);