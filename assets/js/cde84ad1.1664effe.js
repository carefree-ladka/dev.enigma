"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[2541],{4328:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>t,default:()=>h,frontMatter:()=>a,metadata:()=>l,toc:()=>o});var s=r(4848),i=r(8453);const a={},t="System Design Theory",l={id:"Frontend System Design/BackendSystemDesign",title:"System Design Theory",description:"1. Load Balancing",source:"@site/docs/Frontend System Design/BackendSystemDesign.mdx",sourceDirName:"Frontend System Design",slug:"/Frontend System Design/BackendSystemDesign",permalink:"/js.enigma/docs/Frontend System Design/BackendSystemDesign",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/Frontend System Design/BackendSystemDesign.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Frontend System Design",permalink:"/js.enigma/docs/category/frontend-system-design"},next:{title:"Frontend System Design Template",permalink:"/js.enigma/docs/Frontend System Design/BasicTemplate"}},c={},o=[{value:"1. Load Balancing",id:"1-load-balancing",level:2},{value:"Theory",id:"theory",level:3},{value:"Types",id:"types",level:3},{value:"Algorithms",id:"algorithms",level:3},{value:"2. Caching",id:"2-caching",level:2},{value:"Theory",id:"theory-1",level:3},{value:"Caching Strategies",id:"caching-strategies",level:3},{value:"3. Database Sharding",id:"3-database-sharding",level:2},{value:"Theory",id:"theory-2",level:3},{value:"Sharding Strategies",id:"sharding-strategies",level:3},{value:"4. Message Queues",id:"4-message-queues",level:2},{value:"Theory",id:"theory-3",level:3},{value:"Patterns",id:"patterns",level:3},{value:"5. Consistent Hashing",id:"5-consistent-hashing",level:2},{value:"Theory",id:"theory-4",level:3},{value:"Implementation",id:"implementation",level:3},{value:"6. CAP Theorem",id:"6-cap-theorem",level:2},{value:"Theory",id:"theory-5",level:3},{value:"Application",id:"application",level:3},{value:"7. Rate Limiting",id:"7-rate-limiting",level:2},{value:"Theory",id:"theory-6",level:3},{value:"Algorithms",id:"algorithms-1",level:3},{value:"8. Back-of-the-envelope Calculations",id:"8-back-of-the-envelope-calculations",level:2},{value:"Theory",id:"theory-7",level:3},{value:"Common Calculations",id:"common-calculations",level:3},{value:"Best Practices for System Design",id:"best-practices-for-system-design",level:2},{value:"1. Start Simple",id:"1-start-simple",level:3},{value:"2. Consider Scalability",id:"2-consider-scalability",level:3},{value:"3. Plan for Failure",id:"3-plan-for-failure",level:3},{value:"4. Make Data Decisions Early",id:"4-make-data-decisions-early",level:3},{value:"Interview Tips",id:"interview-tips",level:2},{value:"Introduction",id:"introduction",level:2},{value:"1. Feature Expectations (5 minutes)",id:"1-feature-expectations-5-minutes",level:2},{value:"1.1 Use Cases",id:"11-use-cases",level:3},{value:"1.2 Out of Scope",id:"12-out-of-scope",level:3},{value:"1.3 Users",id:"13-users",level:3},{value:"1.4 Scale",id:"14-scale",level:3},{value:"1.5 Usage Patterns",id:"15-usage-patterns",level:3},{value:"2. Estimations (5 minutes)",id:"2-estimations-5-minutes",level:2},{value:"2.1 Traffic Estimates",id:"21-traffic-estimates",level:3},{value:"Read QPS:",id:"read-qps",level:4},{value:"Write QPS:",id:"write-qps",level:4},{value:"2.2 Storage Estimates",id:"22-storage-estimates",level:3},{value:"2.3 Memory Estimates",id:"23-memory-estimates",level:3},{value:"3. Design Goals (5 minutes)",id:"3-design-goals-5-minutes",level:2},{value:"3.1 Performance Requirements",id:"31-performance-requirements",level:3},{value:"3.2 CAP Theorem Considerations",id:"32-cap-theorem-considerations",level:3},{value:"4. High-Level Design (5-10 minutes)",id:"4-high-level-design-5-10-minutes",level:2},{value:"4.1 API Design",id:"41-api-design",level:3},{value:"4.2 Database Schema",id:"42-database-schema",level:3},{value:"4.3 Basic Algorithm",id:"43-basic-algorithm",level:3},{value:"5. Deep Dive (15-20 minutes)",id:"5-deep-dive-15-20-minutes",level:2},{value:"5.1 Component Scaling",id:"51-component-scaling",level:3},{value:"Load Balancer Configuration",id:"load-balancer-configuration",level:4},{value:"Database Sharding",id:"database-sharding",level:4},{value:"5.2 Caching Strategy",id:"52-caching-strategy",level:3},{value:"5.3 Message Queue Architecture",id:"53-message-queue-architecture",level:3},{value:"6. Justification (5 minutes)",id:"6-justification-5-minutes",level:2},{value:"6.1 Performance Analysis",id:"61-performance-analysis",level:3},{value:"6.2 Back-of-the-envelope Calculations",id:"62-back-of-the-envelope-calculations",level:3},{value:"Network Bandwidth",id:"network-bandwidth",level:4},{value:"Database IOPS",id:"database-iops",level:4},{value:"Best Practices",id:"best-practices",level:2},{value:"Common Pitfalls to Avoid",id:"common-pitfalls-to-avoid",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"system-design-theory",children:"System Design Theory"})}),"\n",(0,s.jsx)(n.h2,{id:"1-load-balancing",children:"1. Load Balancing"}),"\n",(0,s.jsx)(n.h3,{id:"theory",children:"Theory"}),"\n",(0,s.jsx)(n.p,{children:"Load balancing refers to the process of distributing network traffic across multiple servers to ensure high availability and reliability by preventing any single server from becoming a bottleneck."}),"\n",(0,s.jsx)(n.h3,{id:"types",children:"Types"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Layer 4 (Transport Layer)"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Works with network/transport layer protocols (TCP/UDP)"}),"\n",(0,s.jsx)(n.li,{children:"Faster but less flexible"}),"\n",(0,s.jsx)(n.li,{children:"Based on IP address and port numbers"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Layer 7 (Application Layer)"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Content-aware routing"}),"\n",(0,s.jsx)(n.li,{children:"More flexible but higher latency"}),"\n",(0,s.jsx)(n.li,{children:"Can route based on URL, headers, cookies"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"algorithms",children:"Algorithms"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"interface LoadBalancer {\r\n  // Round Robin\r\n  roundRobin(): Server {\r\n    currentIndex = (currentIndex + 1) % servers.length;\r\n    return servers[currentIndex];\r\n  }\r\n\r\n  // Least Connections\r\n  leastConnections(): Server {\r\n    return servers.reduce((min, server) => \r\n      server.connections < min.connections ? server : min\r\n    );\r\n  }\r\n\r\n  // IP Hash\r\n  ipHash(clientIP: string): Server {\r\n    const hash = createHash(clientIP);\r\n    return servers[hash % servers.length];\r\n  }\r\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"2-caching",children:"2. Caching"}),"\n",(0,s.jsx)(n.h3,{id:"theory-1",children:"Theory"}),"\n",(0,s.jsx)(n.p,{children:"Caching is a technique that stores copies of frequently accessed data in a high-speed data storage layer to improve retrieval times and reduce database load."}),"\n",(0,s.jsx)(n.h3,{id:"caching-strategies",children:"Caching Strategies"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Cache-Aside (Lazy Loading)"})}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"class CacheAside {\r\n  async get(key: string): Promise<Data> {\r\n    // Check cache first\r\n    let data = await cache.get(key);\r\n    if (data === null) {\r\n      // Cache miss: get from DB and update cache\r\n      data = await db.get(key);\r\n      await cache.set(key, data);\r\n    }\r\n    return data;\r\n  }\r\n}\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Write-Through"})}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"class WriteThrough {\r\n  async set(key: string, value: Data): Promise<void> {\r\n    // Write to DB first\r\n    await db.set(key, value);\r\n    // Then update cache\r\n    await cache.set(key, value);\r\n  }\r\n}\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Write-Behind (Write-Back)"})}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"class WriteBehind {\r\n  async set(key: string, value: Data): Promise<void> {\r\n    // Write to cache immediately\r\n    await cache.set(key, value);\r\n    // Queue DB update\r\n    await writeQueue.push({ key, value });\r\n  }\r\n\r\n  private async processWriteQueue() {\r\n    while (true) {\r\n      const { key, value } = await writeQueue.pop();\r\n      await db.set(key, value);\r\n    }\r\n  }\r\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"3-database-sharding",children:"3. Database Sharding"}),"\n",(0,s.jsx)(n.h3,{id:"theory-2",children:"Theory"}),"\n",(0,s.jsx)(n.p,{children:"Sharding is a database architecture pattern that splits large databases into smaller, faster, more manageable pieces called shards based on some partition key."}),"\n",(0,s.jsx)(n.h3,{id:"sharding-strategies",children:"Sharding Strategies"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Hash-Based Sharding"})}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"class HashSharding {\r\n  private shardCount: number;\r\n\r\n  constructor(shardCount: number) {\r\n    this.shardCount = shardCount;\r\n  }\r\n\r\n  getShardId(key: string): number {\r\n    const hash = createHash(key);\r\n    return hash % this.shardCount;\r\n  }\r\n}\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Range-Based Sharding"})}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"class RangeSharding {\r\n  private ranges: Array<{ min: number; max: number; shardId: number }>;\r\n\r\n  getShardId(value: number): number {\r\n    const shard = this.ranges.find(range => \r\n      value >= range.min && value <= range.max\r\n    );\r\n    return shard.shardId;\r\n  }\r\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"4-message-queues",children:"4. Message Queues"}),"\n",(0,s.jsx)(n.h3,{id:"theory-3",children:"Theory"}),"\n",(0,s.jsx)(n.p,{children:"Message queues provide asynchronous communication and decoupling between components in a distributed system."}),"\n",(0,s.jsx)(n.h3,{id:"patterns",children:"Patterns"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Publisher-Subscriber"})}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"class PubSub {\r\n  private subscribers: Map<string, Function[]> = new Map();\r\n\r\n  publish(topic: string, message: any) {\r\n    const topicSubscribers = this.subscribers.get(topic) || [];\r\n    topicSubscribers.forEach(subscriber => subscriber(message));\r\n  }\r\n\r\n  subscribe(topic: string, callback: Function) {\r\n    if (!this.subscribers.has(topic)) {\r\n      this.subscribers.set(topic, []);\r\n    }\r\n    this.subscribers.get(topic).push(callback);\r\n  }\r\n}\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Point-to-Point"})}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"class Queue {\r\n  private messages: any[] = [];\r\n\r\n  async send(message: any) {\r\n    this.messages.push(message);\r\n  }\r\n\r\n  async receive(): Promise<any> {\r\n    return this.messages.shift();\r\n  }\r\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"5-consistent-hashing",children:"5. Consistent Hashing"}),"\n",(0,s.jsx)(n.h3,{id:"theory-4",children:"Theory"}),"\n",(0,s.jsx)(n.p,{children:"Consistent hashing is a technique used to distribute data across nodes in a way that minimizes reorganization when nodes are added or removed."}),"\n",(0,s.jsx)(n.h3,{id:"implementation",children:"Implementation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"class ConsistentHashing {\r\n  private nodes: Map<number, string> = new Map();\r\n  private replicas: number;\r\n\r\n  constructor(replicas: number) {\r\n    this.replicas = replicas;\r\n  }\r\n\r\n  addNode(node: string) {\r\n    for (let i = 0; i < this.replicas; i++) {\r\n      const hash = this.getHash(`${node}-${i}`);\r\n      this.nodes.set(hash, node);\r\n    }\r\n  }\r\n\r\n  removeNode(node: string) {\r\n    for (let i = 0; i < this.replicas; i++) {\r\n      const hash = this.getHash(`${node}-${i}`);\r\n      this.nodes.delete(hash);\r\n    }\r\n  }\r\n\r\n  getNode(key: string): string {\r\n    const hash = this.getHash(key);\r\n    const nodeHashes = Array.from(this.nodes.keys()).sort((a, b) => a - b);\r\n    \r\n    for (const nodeHash of nodeHashes) {\r\n      if (nodeHash >= hash) {\r\n        return this.nodes.get(nodeHash);\r\n      }\r\n    }\r\n    \r\n    // Wrap around to first node if key hash is larger than all node hashes\r\n    return this.nodes.get(nodeHashes[0]);\r\n  }\r\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"6-cap-theorem",children:"6. CAP Theorem"}),"\n",(0,s.jsx)(n.h3,{id:"theory-5",children:"Theory"}),"\n",(0,s.jsx)(n.p,{children:"The CAP theorem states that a distributed system can only provide two of the following three guarantees:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Consistency: All nodes see the same data at the same time"}),"\n",(0,s.jsx)(n.li,{children:"Availability: Every request receives a response"}),"\n",(0,s.jsx)(n.li,{children:"Partition tolerance: System continues to operate despite network failures"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"application",children:"Application"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"interface SystemRequirements {\r\n  consistency: 'strong' | 'eventual';\r\n  availability: 'high' | 'medium' | 'low';\r\n  partitionTolerance: boolean;\r\n}\r\n\r\nclass SystemDesign {\r\n  determineSystemType(requirements: SystemRequirements) {\r\n    if (requirements.partitionTolerance) {\r\n      // In practice, partition tolerance is required\r\n      if (requirements.consistency === 'strong') {\r\n        return 'CP System (e.g., MongoDB, HBase)';\r\n      } else {\r\n        return 'AP System (e.g., Cassandra, DynamoDB)';\r\n      }\r\n    }\r\n    return 'CA System (Traditional RDBMS, single node)';\r\n  }\r\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"7-rate-limiting",children:"7. Rate Limiting"}),"\n",(0,s.jsx)(n.h3,{id:"theory-6",children:"Theory"}),"\n",(0,s.jsx)(n.p,{children:"Rate limiting is a strategy to control the rate of requests a client can make to a service to prevent abuse and ensure fair usage."}),"\n",(0,s.jsx)(n.h3,{id:"algorithms-1",children:"Algorithms"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Token Bucket"})}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"class TokenBucket {\r\n  private tokens: number;\r\n  private lastRefill: number;\r\n  private capacity: number;\r\n  private refillRate: number;\r\n\r\n  constructor(capacity: number, refillRate: number) {\r\n    this.capacity = capacity;\r\n    this.refillRate = refillRate;\r\n    this.tokens = capacity;\r\n    this.lastRefill = Date.now();\r\n  }\r\n\r\n  tryConsume(): boolean {\r\n    this.refill();\r\n    if (this.tokens >= 1) {\r\n      this.tokens--;\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  private refill() {\r\n    const now = Date.now();\r\n    const timePassed = (now - this.lastRefill) / 1000;\r\n    this.tokens = Math.min(\r\n      this.capacity,\r\n      this.tokens + timePassed * this.refillRate\r\n    );\r\n    this.lastRefill = now;\r\n  }\r\n}\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Leaky Bucket"})}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"class LeakyBucket {\r\n  private queue: any[];\r\n  private capacity: number;\r\n  private processRate: number;\r\n\r\n  constructor(capacity: number, processRate: number) {\r\n    this.queue = [];\r\n    this.capacity = capacity;\r\n    this.processRate = processRate;\r\n    this.startProcessing();\r\n  }\r\n\r\n  tryAdd(request: any): boolean {\r\n    if (this.queue.length < this.capacity) {\r\n      this.queue.push(request);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  private startProcessing() {\r\n    setInterval(() => {\r\n      if (this.queue.length > 0) {\r\n        const request = this.queue.shift();\r\n        this.processRequest(request);\r\n      }\r\n    }, 1000 / this.processRate);\r\n  }\r\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"8-back-of-the-envelope-calculations",children:"8. Back-of-the-envelope Calculations"}),"\n",(0,s.jsx)(n.h3,{id:"theory-7",children:"Theory"}),"\n",(0,s.jsx)(n.p,{children:"Quick, approximate calculations used to estimate system requirements and validate design decisions."}),"\n",(0,s.jsx)(n.h3,{id:"common-calculations",children:"Common Calculations"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Storage Requirements"})}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"function calculateStorageNeeds(params: {\r\n  dailyActiveUsers: number;\r\n  averageDataPerUser: number;  // in bytes\r\n  retentionDays: number;\r\n  replicationFactor: number;\r\n}): number {\r\n  const dailyStorage = params.dailyActiveUsers * params.averageDataPerUser;\r\n  const totalStorage = dailyStorage * params.retentionDays * params.replicationFactor;\r\n  return totalStorage;\r\n}\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Bandwidth Requirements"})}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"function calculateBandwidth(params: {\r\n  requestsPerSecond: number;\r\n  averageRequestSize: number;  // in bytes\r\n  averageResponseSize: number; // in bytes\r\n}): number {\r\n  const totalBytesPerSecond = params.requestsPerSecond * \r\n    (params.averageRequestSize + params.averageResponseSize);\r\n  const bandwidthMbps = (totalBytesPerSecond * 8) / 1000000;\r\n  return bandwidthMbps;\r\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices-for-system-design",children:"Best Practices for System Design"}),"\n",(0,s.jsx)(n.h3,{id:"1-start-simple",children:"1. Start Simple"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Begin with a minimal viable solution"}),"\n",(0,s.jsx)(n.li,{children:"Add complexity only when needed"}),"\n",(0,s.jsx)(n.li,{children:"Document assumptions and constraints"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"2-consider-scalability",children:"2. Consider Scalability"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Horizontal vs Vertical scaling"}),"\n",(0,s.jsx)(n.li,{children:"Stateless services when possible"}),"\n",(0,s.jsx)(n.li,{children:"Caching strategies"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"3-plan-for-failure",children:"3. Plan for Failure"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Design for failures at every layer"}),"\n",(0,s.jsx)(n.li,{children:"Implement proper monitoring"}),"\n",(0,s.jsx)(n.li,{children:"Have fallback mechanisms"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"4-make-data-decisions-early",children:"4. Make Data Decisions Early"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Choose appropriate storage solutions"}),"\n",(0,s.jsx)(n.li,{children:"Plan data partitioning strategy"}),"\n",(0,s.jsx)(n.li,{children:"Consider data access patterns"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"interview-tips",children:"Interview Tips"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Clarify Requirements"})}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"class RequirementGathering {\r\n  gatherRequirements() {\r\n    return {\r\n      functional: this.getFunctionalRequirements(),\r\n      nonFunctional: this.getNonFunctionalRequirements(),\r\n      constraints: this.getConstraints()\r\n    };\r\n  }\r\n\r\n  private getFunctionalRequirements() {\r\n    // Core features\r\n    // User interactions\r\n    // System behaviors\r\n  }\r\n\r\n  private getNonFunctionalRequirements() {\r\n    // Performance\r\n    // Scalability\r\n    // Reliability\r\n    // Security\r\n  }\r\n\r\n  private getConstraints() {\r\n    // Time\r\n    // Budget\r\n    // Technology\r\n    // Team\r\n  }\r\n}\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Systematic Approach"})}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"class SystemDesignApproach {\r\n  designSystem() {\r\n    // 1. Requirements gathering\r\n    const requirements = this.gatherRequirements();\r\n    \r\n    // 2. High-level design\r\n    const architecture = this.createHighLevelDesign(requirements);\r\n    \r\n    // 3. Detailed design\r\n    const detailedDesign = this.createDetailedDesign(architecture);\r\n    \r\n    // 4. Identify bottlenecks\r\n    const bottlenecks = this.identifyBottlenecks(detailedDesign);\r\n    \r\n    // 5. Scaling solutions\r\n    const scalingSolutions = this.proposeSolutions(bottlenecks);\r\n    \r\n    return {\r\n      requirements,\r\n      architecture,\r\n      detailedDesign,\r\n      bottlenecks,\r\n      scalingSolutions\r\n    };\r\n  }\r\n}\n"})}),"\n",(0,s.jsx)(n.h1,{id:"system-design-interview-guide",children:"System Design Interview Guide"}),"\n",(0,s.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsx)(n.p,{children:"This guide provides a structured approach to tackling system design interviews. Each section includes key points to cover, examples, and calculation methods."}),"\n",(0,s.jsx)(n.h2,{id:"1-feature-expectations-5-minutes",children:"1. Feature Expectations (5 minutes)"}),"\n",(0,s.jsx)(n.h3,{id:"11-use-cases",children:"1.1 Use Cases"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"List primary user stories"}),"\n",(0,s.jsx)(n.li,{children:"Define core functionality"}),"\n",(0,s.jsx)(n.li,{children:"Identify key features"}),"\n",(0,s.jsx)(n.li,{children:"Determine MVP requirements"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Example for a URL Shortener:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Primary Use Cases:\r\n1. Generate short URL from long URL\r\n2. Redirect short URL to original URL\r\n3. Custom short URLs (optional)\r\n4. Analytics (optional)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"12-out-of-scope",children:"1.2 Out of Scope"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"List features explicitly not covered"}),"\n",(0,s.jsx)(n.li,{children:"Define system boundaries"}),"\n",(0,s.jsx)(n.li,{children:"Identify future considerations"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Out of Scope:\r\n1. User authentication\r\n2. URL preview\r\n3. API rate limiting (initially)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"13-users",children:"1.3 Users"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Define user types"}),"\n",(0,s.jsx)(n.li,{children:"User roles and permissions"}),"\n",(0,s.jsx)(n.li,{children:"Geographic distribution"}),"\n",(0,s.jsx)(n.li,{children:"User behavior patterns"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"14-scale",children:"1.4 Scale"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Current users"}),"\n",(0,s.jsx)(n.li,{children:"Growth projections"}),"\n",(0,s.jsx)(n.li,{children:"Peak vs. average load"}),"\n",(0,s.jsx)(n.li,{children:"Geographic distribution"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"15-usage-patterns",children:"1.5 Usage Patterns"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Daily active users"}),"\n",(0,s.jsx)(n.li,{children:"Peak hours"}),"\n",(0,s.jsx)(n.li,{children:"Seasonal variations"}),"\n",(0,s.jsx)(n.li,{children:"User interaction frequency"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"2-estimations-5-minutes",children:"2. Estimations (5 minutes)"}),"\n",(0,s.jsx)(n.h3,{id:"21-traffic-estimates",children:"2.1 Traffic Estimates"}),"\n",(0,s.jsx)(n.h4,{id:"read-qps",children:"Read QPS:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const calculateReadQPS = () => {\r\n  const dailyActiveUsers = 1000000;\r\n  const avgReadsPerUser = 10;\r\n  const secondsInDay = 86400;\r\n  \r\n  const averageQPS = (dailyActiveUsers * avgReadsPerUser) / secondsInDay;\r\n  const peakQPS = averageQPS * 2; // 2x for peak\r\n  \r\n  return { averageQPS, peakQPS };\r\n};\n"})}),"\n",(0,s.jsx)(n.h4,{id:"write-qps",children:"Write QPS:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const calculateWriteQPS = () => {\r\n  const dailyActiveUsers = 1000000;\r\n  const avgWritesPerUser = 2;\r\n  const secondsInDay = 86400;\r\n  \r\n  const averageQPS = (dailyActiveUsers * avgWritesPerUser) / secondsInDay;\r\n  const peakQPS = averageQPS * 2;\r\n  \r\n  return { averageQPS, peakQPS };\r\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"22-storage-estimates",children:"2.2 Storage Estimates"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const calculateStorageNeeds = () => {\r\n  const dailyNewRecords = 1000000;\r\n  const recordSize = 1000; // bytes\r\n  const daysToKeep = 365;\r\n  \r\n  const totalStorage = dailyNewRecords * recordSize * daysToKeep;\r\n  return totalStorage;\r\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"23-memory-estimates",children:"2.3 Memory Estimates"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const calculateCacheNeeds = () => {\r\n  const qps = 1000;\r\n  const cacheHitRatio = 0.8;\r\n  const avgRecordSize = 1000; // bytes\r\n  const cacheDuration = 3600; // 1 hour\r\n  \r\n  const cacheSize = qps * (1 - cacheHitRatio) * avgRecordSize * cacheDuration;\r\n  return cacheSize;\r\n};\n"})}),"\n",(0,s.jsx)(n.h2,{id:"3-design-goals-5-minutes",children:"3. Design Goals (5 minutes)"}),"\n",(0,s.jsx)(n.h3,{id:"31-performance-requirements",children:"3.1 Performance Requirements"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Read latency: < 100ms"}),"\n",(0,s.jsx)(n.li,{children:"Write latency: < 200ms"}),"\n",(0,s.jsx)(n.li,{children:"Availability: 99.99%"}),"\n",(0,s.jsx)(n.li,{children:"Consistency requirements"}),"\n",(0,s.jsx)(n.li,{children:"Durability guarantees"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"32-cap-theorem-considerations",children:"3.2 CAP Theorem Considerations"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"type SystemType = 'CP' | 'AP';\r\n\r\ninterface SystemRequirements {\r\n  consistency: 'strong' | 'eventual';\r\n  availability: number; // percentage\r\n  partitionTolerance: boolean;\r\n}\r\n\r\nconst determineSystemType = (requirements: SystemRequirements): SystemType => {\r\n  return requirements.consistency === 'strong' ? 'CP' : 'AP';\r\n};\n"})}),"\n",(0,s.jsx)(n.h2,{id:"4-high-level-design-5-10-minutes",children:"4. High-Level Design (5-10 minutes)"}),"\n",(0,s.jsx)(n.h3,{id:"41-api-design",children:"4.1 API Design"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// RESTful API Example\r\ninterface APIEndpoints {\r\n  // Write APIs\r\n  POST: {\r\n    '/api/v1/resource': {\r\n      request: ResourceCreationRequest;\r\n      response: ResourceCreationResponse;\r\n    };\r\n  };\r\n  \r\n  // Read APIs\r\n  GET: {\r\n    '/api/v1/resource/:id': {\r\n      params: { id: string };\r\n      response: ResourceResponse;\r\n    };\r\n  };\r\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"42-database-schema",children:"4.2 Database Schema"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Example Schema\r\nCREATE TABLE users (\r\n    id BIGSERIAL PRIMARY KEY,\r\n    email VARCHAR(255) UNIQUE NOT NULL,\r\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\r\n);\r\n\r\nCREATE TABLE resources (\r\n    id BIGSERIAL PRIMARY KEY,\r\n    user_id BIGINT REFERENCES users(id),\r\n    data JSONB NOT NULL,\r\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\r\n);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"43-basic-algorithm",children:"4.3 Basic Algorithm"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"class DataProcessor {\r\n  async process(data: InputData): Promise<ProcessedData> {\r\n    // 1. Validate input\r\n    this.validate(data);\r\n    \r\n    // 2. Transform data\r\n    const transformed = await this.transform(data);\r\n    \r\n    // 3. Store data\r\n    const stored = await this.store(transformed);\r\n    \r\n    // 4. Cache results\r\n    await this.cache(stored);\r\n    \r\n    return stored;\r\n  }\r\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"5-deep-dive-15-20-minutes",children:"5. Deep Dive (15-20 minutes)"}),"\n",(0,s.jsx)(n.h3,{id:"51-component-scaling",children:"5.1 Component Scaling"}),"\n",(0,s.jsx)(n.h4,{id:"load-balancer-configuration",children:"Load Balancer Configuration"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"interface LoadBalancer {\r\n  algorithm: 'round-robin' | 'least-connections' | 'ip-hash';\r\n  healthCheck: {\r\n    path: string;\r\n    interval: number;\r\n    timeout: number;\r\n    unhealthyThreshold: number;\r\n  };\r\n  ssl: {\r\n    enabled: boolean;\r\n    cert: string;\r\n    key: string;\r\n  };\r\n}\n"})}),"\n",(0,s.jsx)(n.h4,{id:"database-sharding",children:"Database Sharding"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"class ShardManager {\r\n  private shardCount: number;\r\n  \r\n  constructor(shardCount: number) {\r\n    this.shardCount = shardCount;\r\n  }\r\n  \r\n  getShardId(key: string): number {\r\n    const hash = this.hashFunction(key);\r\n    return hash % this.shardCount;\r\n  }\r\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"52-caching-strategy",children:"5.2 Caching Strategy"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"interface CacheConfig {\r\n  strategy: 'cache-aside' | 'write-through' | 'write-behind';\r\n  ttl: number;\r\n  maxSize: number;\r\n}\r\n\r\nclass CacheManager {\r\n  async get(key: string): Promise<Data> {\r\n    const cached = await this.cache.get(key);\r\n    if (cached) return cached;\r\n    \r\n    const data = await this.db.get(key);\r\n    await this.cache.set(key, data);\r\n    return data;\r\n  }\r\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"53-message-queue-architecture",children:"5.3 Message Queue Architecture"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"interface QueueConfig {\r\n  type: 'kafka' | 'rabbitmq' | 'sqs';\r\n  partitions: number;\r\n  replicationFactor: number;\r\n  retentionPeriod: number;\r\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"6-justification-5-minutes",children:"6. Justification (5 minutes)"}),"\n",(0,s.jsx)(n.h3,{id:"61-performance-analysis",children:"6.1 Performance Analysis"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"interface LayerMetrics {\r\n  avgLatency: number;\r\n  p95Latency: number;\r\n  p99Latency: number;\r\n  throughput: number;\r\n}\r\n\r\nconst calculateSystemMetrics = (layers: LayerMetrics[]): SystemMetrics => {\r\n  return {\r\n    totalLatency: layers.reduce((sum, layer) => sum + layer.avgLatency, 0),\r\n    bottlenecks: layers.filter(layer => layer.throughput < targetThroughput)\r\n  };\r\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"62-back-of-the-envelope-calculations",children:"6.2 Back-of-the-envelope Calculations"}),"\n",(0,s.jsx)(n.h4,{id:"network-bandwidth",children:"Network Bandwidth"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const calculateBandwidth = () => {\r\n  const requestSize = 1000; // bytes\r\n  const qps = 1000;\r\n  \r\n  const bytesPerSecond = requestSize * qps;\r\n  const megabitsPerSecond = (bytesPerSecond * 8) / 1000000;\r\n  \r\n  return megabitsPerSecond;\r\n};\n"})}),"\n",(0,s.jsx)(n.h4,{id:"database-iops",children:"Database IOPS"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const calculateIOPS = () => {\r\n  const writeQPS = 100;\r\n  const readQPS = 1000;\r\n  const replicationFactor = 3;\r\n  \r\n  const totalIOPS = (writeQPS * replicationFactor) + readQPS;\r\n  return totalIOPS;\r\n};\n"})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Start with Scale"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Begin with rough numbers"}),"\n",(0,s.jsx)(n.li,{children:"Use powers of 10"}),"\n",(0,s.jsx)(n.li,{children:"Consider growth"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Clarify Requirements"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Ask questions"}),"\n",(0,s.jsx)(n.li,{children:"State assumptions"}),"\n",(0,s.jsx)(n.li,{children:"Define scope"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Draw Diagrams"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Start simple"}),"\n",(0,s.jsx)(n.li,{children:"Add complexity gradually"}),"\n",(0,s.jsx)(n.li,{children:"Show data flow"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Consider Trade-offs"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Cost vs Performance"}),"\n",(0,s.jsx)(n.li,{children:"Consistency vs Availability"}),"\n",(0,s.jsx)(n.li,{children:"Complexity vs Maintainability"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"common-pitfalls-to-avoid",children:"Common Pitfalls to Avoid"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Over-engineering"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Don't add unnecessary complexity"}),"\n",(0,s.jsx)(n.li,{children:"Start simple, then scale"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Ignoring Requirements"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Listen carefully to requirements"}),"\n",(0,s.jsx)(n.li,{children:"Validate assumptions"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Skipping Calculations"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Always do the math"}),"\n",(0,s.jsx)(n.li,{children:"Verify numbers make sense"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Not Considering Edge Cases"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Think about failure scenarios"}),"\n",(0,s.jsx)(n.li,{children:"Plan for system degradation"}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>t,x:()=>l});var s=r(6540);const i={},a=s.createContext(i);function t(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);