"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[3486],{1888:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>c,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>a});var s=n(4848),t=n(8453);const o={},l="Promise Fundamentals",i={id:"WebDev/JavaScript/PromisePolyfills",title:"Promise Fundamentals",description:"What is a Promise?",source:"@site/docs/WebDev/JavaScript/PromisePolyfills.mdx",sourceDirName:"WebDev/JavaScript",slug:"/WebDev/JavaScript/PromisePolyfills",permalink:"/js.enigma/docs/WebDev/JavaScript/PromisePolyfills",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/WebDev/JavaScript/PromisePolyfills.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Promise Based Outputs",permalink:"/js.enigma/docs/WebDev/JavaScript/PromiseBased"},next:{title:"__proto__ vs prototype",permalink:"/js.enigma/docs/WebDev/JavaScript/ProtoVSPrototype"}},c={},a=[{value:"What is a Promise?",id:"what-is-a-promise",level:3},{value:"Creating a Promise",id:"creating-a-promise",level:3},{value:"Promise Methods",id:"promise-methods",level:2},{value:"Instance Methods",id:"instance-methods",level:3},{value:"Static Methods",id:"static-methods",level:3},{value:"Advanced Promise Patterns",id:"advanced-promise-patterns",level:2},{value:"Chaining Promises",id:"chaining-promises",level:3},{value:"Async/Await Syntax",id:"asyncawait-syntax",level:3},{value:"Common Pitfalls",id:"common-pitfalls",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Promise Polyfill",id:"promise-polyfill",level:2},{value:"Promise.all",id:"promiseall",level:2},{value:"Promise.allSettled",id:"promiseallsettled",level:2},{value:"Promise Any",id:"promise-any",level:2},{value:"Promise Race",id:"promise-race",level:2},{value:"Fetch with Retry",id:"fetch-with-retry",level:2},{value:"Sleep",id:"sleep",level:2},{value:"Retry Callback",id:"retry-callback",level:2},{value:"Example Usage",id:"example-usage",level:3}];function d(e){const r={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.header,{children:(0,s.jsx)(r.h1,{id:"promise-fundamentals",children:"Promise Fundamentals"})}),"\n",(0,s.jsx)(r.h3,{id:"what-is-a-promise",children:"What is a Promise?"}),"\n",(0,s.jsx)(r.p,{children:"A Promise represents the eventual completion (or failure) of an asynchronous operation and its resulting value. It exists in one of three states:"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Pending"}),": Initial state, neither fulfilled nor rejected"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Fulfilled"}),": Operation completed successfully"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Rejected"}),": Operation failed"]}),"\n"]}),"\n",(0,s.jsx)(r.h3,{id:"creating-a-promise",children:"Creating a Promise"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:"const myPromise = new Promise((resolve, reject) => {\r\n  // Asynchronous operation\r\n  if (/* operation successful */) {\r\n    resolve(result);\r\n  } else {\r\n    reject(error);\r\n  }\r\n});\n"})}),"\n",(0,s.jsx)(r.h2,{id:"promise-methods",children:"Promise Methods"}),"\n",(0,s.jsx)(r.h3,{id:"instance-methods",children:"Instance Methods"}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.code,{children:".then()"})}),": Handles successful Promise resolution"]}),"\n"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:"myPromise\r\n  .then((result) => {\r\n    // Handle successful result\r\n  })\r\n  .catch((error) => {\r\n    // Handle errors\r\n  });\n"})}),"\n",(0,s.jsxs)(r.ol,{start:"2",children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.code,{children:".catch()"})}),": Handles Promise rejection"]}),"\n"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:"myPromise.catch((error) => {\r\n  // Handle any errors\r\n});\n"})}),"\n",(0,s.jsxs)(r.ol,{start:"3",children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.code,{children:".finally()"})}),": Executes regardless of Promise state"]}),"\n"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:"myPromise\r\n  .then((result) => {/* success */})\r\n  .catch((error) => {/* error */})\r\n  .finally(() => {\r\n    // Always runs, useful for cleanup\r\n  });\n"})}),"\n",(0,s.jsx)(r.h3,{id:"static-methods",children:"Static Methods"}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.code,{children:"Promise.resolve()"})}),": Creates a resolved Promise"]}),"\n"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:"const resolvedPromise = Promise.resolve(value);\n"})}),"\n",(0,s.jsxs)(r.ol,{start:"2",children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.code,{children:"Promise.reject()"})}),": Creates a rejected Promise"]}),"\n"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:"const rejectedPromise = Promise.reject(error);\n"})}),"\n",(0,s.jsxs)(r.ol,{start:"3",children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.code,{children:"Promise.all()"})}),": Waits for all Promises to resolve"]}),"\n"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:"Promise.all([promise1, promise2, promise3])\r\n  .then((results) => {\r\n    // All promises resolved\r\n  })\r\n  .catch((error) => {\r\n    // If any promise is rejected\r\n  });\n"})}),"\n",(0,s.jsxs)(r.ol,{start:"4",children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.code,{children:"Promise.race()"})}),": Resolves/rejects with first settled Promise"]}),"\n"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:"Promise.race([promise1, promise2])\r\n  .then((firstResult) => {\r\n    // First promise to settle\r\n  });\n"})}),"\n",(0,s.jsxs)(r.ol,{start:"5",children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.code,{children:"Promise.allSettled()"})}),": Waits for all Promises to settle"]}),"\n"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:"Promise.allSettled([promise1, promise2])\r\n  .then((results) => {\r\n    // Array of settlement results\r\n  });\n"})}),"\n",(0,s.jsxs)(r.ol,{start:"6",children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:(0,s.jsx)(r.code,{children:"Promise.any()"})}),": Resolves with first fulfilled Promise"]}),"\n"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:"Promise.any([promise1, promise2])\r\n  .then((firstFulfilledResult) => {\r\n    // First promise fulfilled\r\n  })\r\n  .catch(AggregateError);\n"})}),"\n",(0,s.jsx)(r.h2,{id:"advanced-promise-patterns",children:"Advanced Promise Patterns"}),"\n",(0,s.jsx)(r.h3,{id:"chaining-promises",children:"Chaining Promises"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:"fetchUser()\r\n  .then(user => fetchUserPosts(user.id))\r\n  .then(posts => processPosts(posts))\r\n  .catch(handleError);\n"})}),"\n",(0,s.jsx)(r.h3,{id:"asyncawait-syntax",children:"Async/Await Syntax"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:"async function fetchData() {\r\n  try {\r\n    const user = await fetchUser();\r\n    const posts = await fetchUserPosts(user.id);\r\n    return processPosts(posts);\r\n  } catch (error) {\r\n    handleError(error);\r\n  }\r\n}\n"})}),"\n",(0,s.jsx)(r.h2,{id:"common-pitfalls",children:"Common Pitfalls"}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Unhandled Rejections"}),": Always add ",(0,s.jsx)(r.code,{children:".catch()"})," or use try/catch"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Returning New Promises"}),": Each ",(0,s.jsx)(r.code,{children:".then()"})," can return a new Promise"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Error Propagation"}),": Errors automatically propagate through Promise chain"]}),"\n"]}),"\n",(0,s.jsx)(r.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Avoid nested Promises"}),"\n",(0,s.jsxs)(r.li,{children:["Use ",(0,s.jsx)(r.code,{children:"Promise.all()"})," for concurrent operations"]}),"\n",(0,s.jsxs)(r.li,{children:["Prefer ",(0,s.jsx)(r.code,{children:"async/await"})," for readability"]}),"\n"]}),"\n",(0,s.jsx)(r.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Always handle potential errors"}),"\n",(0,s.jsx)(r.li,{children:"Use meaningful error messages"}),"\n",(0,s.jsx)(r.li,{children:"Keep Promise chains flat and readable"}),"\n",(0,s.jsxs)(r.li,{children:["Leverage ",(0,s.jsx)(r.code,{children:"async/await"})," for complex asynchronous logic"]}),"\n"]}),"\n",(0,s.jsx)(r.h2,{id:"promise-polyfill",children:"Promise Polyfill"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-JavaScript",children:"class MyPromise {\r\n  static STATUS = Object.freeze({\r\n    PENDING: 'pending',\r\n    FULFILLED: 'fulfilled',\r\n    REJECTED: 'rejected'\r\n  });\r\n\r\n  #status = MyPromise.STATUS.PENDING;\r\n  #value = null;\r\n  #successCbs = [];\r\n  #rejectedCbs = [];\r\n\r\n  constructor(executor) {\r\n    if (typeof executor !== 'function') {\r\n      throw new TypeError('Executor must be a function');\r\n    }\r\n\r\n    try {\r\n      executor(this.#resolve, this.#reject);\r\n    } catch (e) {\r\n      this.#reject(e);\r\n    }\r\n  }\r\n\r\n  #resolve = (value) => {\r\n    if (this.#status !== MyPromise.STATUS.PENDING) return;\r\n\r\n    if (value === this) {\r\n      return this.#reject(new TypeError(\"A promise cannot be resolved with itself\"));\r\n    }\r\n\r\n    if (value instanceof MyPromise) {\r\n      return value.then(this.#resolve, this.#reject);\r\n    }\r\n\r\n    if (value?.then && typeof value.then === 'function') {\r\n      return new MyPromise(value.then.bind(value)).then(this.#resolve, this.#reject);\r\n    }\r\n\r\n    this.#value = value;\r\n    this.#status = MyPromise.STATUS.FULFILLED;\r\n    this.#successCbs.forEach(cb => queueMicrotask(() => cb(value)));\r\n  };\r\n\r\n  #reject = (error) => {\r\n    if (this.#status !== MyPromise.STATUS.PENDING) return;\r\n\r\n    this.#value = error;\r\n    this.#status = MyPromise.STATUS.REJECTED;\r\n    this.#rejectedCbs.forEach(cb => queueMicrotask(() => cb(error)));\r\n  };\r\n\r\n  then = (onFulfilled, onRejected) => {\r\n    return new MyPromise((resolve, reject) => {\r\n      const handleQueueMicroTask = (isSuccess, _value) => {\r\n        queueMicrotask(() => {\r\n          try {\r\n            const value = isSuccess\r\n              ? (typeof onFulfilled === 'function' ? onFulfilled(_value) : _value)\r\n              : (typeof onRejected === 'function' ? onRejected(_value) : reject(_value));\r\n\r\n            resolve(value);\r\n          } catch (e) {\r\n            reject(e);\r\n          }\r\n        });\r\n      };\r\n\r\n      switch (this.#status) {\r\n        case MyPromise.STATUS.PENDING:\r\n          this.#successCbs.push((val) => handleQueueMicroTask(true, val));\r\n          this.#rejectedCbs.push((err) => handleQueueMicroTask(false, err));\r\n          break;\r\n        case MyPromise.STATUS.FULFILLED:\r\n          handleQueueMicroTask(true, this.#value);\r\n          break;\r\n        case MyPromise.STATUS.REJECTED:\r\n          handleQueueMicroTask(false, this.#value);\r\n          break;\r\n      }\r\n    });\r\n  };\r\n\r\n  catch = (onRejected) => {\r\n    return this.then(null, onRejected);\r\n  };\r\n\r\n  finally = (onFinally) => {\r\n    return this.then(\r\n      (val) => MyPromise.resolve(onFinally()).then(() => val),\r\n      (error) => MyPromise.resolve(onFinally()).then(() => {\r\n        throw error;\r\n      })\r\n    );\r\n  };\r\n\r\n  static resolve = (value) => {\r\n    if (value instanceof MyPromise) return value;\r\n    if (value?.then && typeof value.then === 'function') {\r\n      return new MyPromise(value.then.bind(value));\r\n    }\r\n    return new MyPromise((res) => res(value));\r\n  };\r\n\r\n  static reject = (error) => {\r\n    return new MyPromise((_, rej) => rej(error));\r\n  };\r\n\r\n  static all = (promises) => {\r\n    return new MyPromise((resolve, reject) => {\r\n      if (!Array.isArray(promises)) {\r\n        return reject(new TypeError('Argument must be an array'));\r\n      }\r\n\r\n      const results = [];\r\n      let completedCount = 0;\r\n\r\n      if (promises.length === 0) {\r\n        return resolve(results);\r\n      }\r\n\r\n      promises.forEach((promise, index) => {\r\n        MyPromise.resolve(promise).then(\r\n          (value) => {\r\n            results[index] = value;\r\n            completedCount++;\r\n            if (completedCount === promises.length) {\r\n              resolve(results);\r\n            }\r\n          },\r\n          (error) => {\r\n            reject(error);\r\n          }\r\n        );\r\n      });\r\n    });\r\n  };\r\n\r\n  static allSettled = (promises) => {\r\n    return new MyPromise((resolve) => {\r\n      if (!Array.isArray(promises)) {\r\n        return reject(new TypeError('Argument must be an array'));\r\n      }\r\n\r\n      const results = [];\r\n      let completedCount = 0;\r\n\r\n      if (promises.length === 0) {\r\n        return resolve(results);\r\n      }\r\n\r\n      promises.forEach((promise, index) => {\r\n        MyPromise.resolve(promise).then(\r\n          (value) => {\r\n            results[index] = { status: 'fulfilled', value };\r\n            completedCount++;\r\n            if (completedCount === promises.length) {\r\n              resolve(results);\r\n            }\r\n          },\r\n          (error) => {\r\n            results[index] = { status: 'rejected', reason: error };\r\n            completedCount++;\r\n            if (completedCount === promises.length) {\r\n              resolve(results);\r\n            }\r\n          }\r\n        );\r\n      });\r\n    });\r\n  };\r\n\r\n  static race = (promises) => {\r\n    return new MyPromise((resolve, reject) => {\r\n      if (!Array.isArray(promises)) {\r\n        return reject(new TypeError('Argument must be an array'));\r\n      }\r\n\r\n      promises.forEach((promise) => {\r\n        MyPromise.resolve(promise).then(resolve, reject);\r\n      });\r\n    });\r\n  };\r\n\r\n  static any = (promises) => {\r\n    return new MyPromise((resolve, reject) => {\r\n      if (!Array.isArray(promises)) {\r\n        return reject(new TypeError('Argument must be an array'));\r\n      }\r\n\r\n      const errors = [];\r\n      let rejectedCount = 0;\r\n\r\n      if (promises.length === 0) {\r\n        return reject(new AggregateError([], 'All promises were rejected'));\r\n      }\r\n\r\n      promises.forEach((promise, index) => {\r\n        MyPromise.resolve(promise).then(\r\n          (value) => {\r\n            resolve(value);\r\n          },\r\n          (error) => {\r\n            errors[index] = error;\r\n            rejectedCount++;\r\n            if (rejectedCount === promises.length) {\r\n              reject(new AggregateError(errors, 'All promises were rejected'));\r\n            }\r\n          }\r\n        );\r\n      });\r\n    });\r\n  };\r\n\r\n  static withResolvers = () => {\r\n    let resolve, reject;\r\n    const promise = new MyPromise((res, rej) => {\r\n      resolve = res;\r\n      reject = rej;\r\n    });\r\n    return { promise, resolve, reject };\r\n  };\r\n\r\n  static try = (fn) => {\r\n    if (typeof fn !== 'function') {\r\n      throw new TypeError('Argument must be a function');\r\n    }\r\n    return new MyPromise((resolve, reject) => {\r\n      try {\r\n        resolve(fn());\r\n      } catch (e) {\r\n        reject(e);\r\n      }\r\n    });\r\n  };\r\n}\r\n\r\n\r\n// Example 1: MyPromise.all\r\nconst p1 = MyPromise.resolve(1);\r\nconst p2 = MyPromise.resolve(2);\r\nconst p3 = new MyPromise((resolve) => setTimeout(() => resolve(3), 1000));\r\n\r\nMyPromise.all([p1, p2, p3]).then((results) => {\r\n  console.log(results); // [1, 2, 3] (after 1 second)\r\n});\r\n\r\n// Example 2: MyPromise.allSettled\r\nconst p4 = MyPromise.resolve(4);\r\nconst p5 = MyPromise.reject('Error 5');\r\n\r\nMyPromise.allSettled([p4, p5]).then((results) => {\r\n  console.log(results);\r\n  // [\r\n  //   { status: 'fulfilled', value: 4 },\r\n  //   { status: 'rejected', reason: 'Error 5' }\r\n  // ]\r\n});\r\n\r\n// Example 3: MyPromise.race\r\nconst p6 = new MyPromise((resolve) => setTimeout(() => resolve('Fast'), 500));\r\nconst p7 = new MyPromise((resolve) => setTimeout(() => resolve('Slow'), 1000));\r\n\r\nMyPromise.race([p6, p7]).then((result) => {\r\n  console.log(result); // 'Fast' (after 500ms)\r\n});\r\n\r\n// Example 4: MyPromise.any\r\nconst p8 = MyPromise.reject('Error 8');\r\nconst p9 = new MyPromise((resolve) => setTimeout(() => resolve('Success 9'), 1000));\r\n\r\nMyPromise.any([p8, p9]).then((result) => {\r\n  console.log(result); // 'Success 9' (after 1 second)\r\n});\r\n\r\nMyPromise.any([MyPromise.reject('Error 10'), MyPromise.reject('Error 11')]).catch((error) => {\r\n  console.log(error.errors); // ['Error 10', 'Error 11']\r\n});\r\n\r\n// Example 5: withResolvers\r\nconst { promise, resolve, reject } = MyPromise.withResolvers();\r\nsetTimeout(() => resolve('Resolved with withResolvers!'), 1000);\r\npromise.then(console.log); // 'Resolved with withResolvers!' after 1 second\r\n\r\n// Example 6: try\r\nMyPromise.try(() => {\r\n  console.log('Executing synchronous code');\r\n  if (Math.random() > 0.5) {\r\n    throw new Error('Random error in try');\r\n  }\r\n  return 'Success in try';\r\n})\r\n  .then(console.log) // 'Success in try'\r\n  .catch(console.error); // 'Error: Random error in try'\n"})}),"\n",(0,s.jsx)(r.h2,{id:"promiseall",children:"Promise.all"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-JavaScript",children:"Promise.myAll = function (promises = []) {\r\n  return new Promise((resolve, reject) => {\r\n    if (!promises.length) resolve([])\r\n    const result = []\r\n    let count = 0\r\n    promises.forEach((promise, index) => {\r\n      Promise.resolve(promise).then((value) => {\r\n        result[index] = value\r\n        count++\r\n        if (count === promises.length) {\r\n          resolve(result)\r\n        }\r\n      }).catch((error) => reject(error))\r\n    })\r\n  })\r\n}\r\n\r\n// Example usage:\r\nconst p1 = Promise.reject(3);\r\nconst p2 = 42;\r\nconst p3 = new Promise((resolve, reject) => {\r\n  setTimeout(resolve, 100, 'foo');\r\n});\r\n\r\nPromise.myAll([p1, p2, p3])\r\n  .then((values) => {\r\n    console.log(values); // [3, 42, \"foo\"]\r\n  })\r\n  .catch((error) => {\r\n    console.error(error);\r\n  });\n"})}),"\n",(0,s.jsx)(r.h2,{id:"promiseallsettled",children:"Promise.allSettled"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-JavaScript",children:"Promise.myAllSettled = function (promises = []) {\r\n  return Promise.all(\r\n    promises.map(promise => {\r\n      return Promise.resolve(promise).then((value) => ({\r\n        status: 'fulfilled', value\r\n      })).catch((reason => ({\r\n        status: 'rejected', reason\r\n      })))\r\n    })\r\n  )\r\n}\r\n\r\n// Example usage:\r\nconst p1 = Promise.resolve(3);\r\nconst p2 = Promise.reject('An error occurred');\r\nconst p3 = new Promise((resolve, reject) => {\r\n  setTimeout(resolve, 100, 'foo');\r\n});\r\n\r\nPromise.myAllSettled([p1, p2, p3])\r\n  .then(results => {\r\n    console.log(results);\r\n    // [\r\n    //   { status: 'fulfilled', value: 3 },\r\n    //   { status: 'rejected', reason: 'An error occurred' },\r\n    //   { status: 'fulfilled', value: 'foo' }\r\n    // ]\r\n  });\n"})}),"\n",(0,s.jsx)(r.h2,{id:"promise-any",children:"Promise Any"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-JavaScript",children:"Promise.myAny = function (promises = []) {\r\n  return new Promise((resolve, reject) => {\r\n    let errors = [];\r\n    let rejectedCount = 0;\r\n    const totalPromises = promises.length;\r\n\r\n    if (!totalPromises) {\r\n      return reject(new AggregateError(errors, \"All promises were rejected\"));\r\n    }\r\n\r\n    promises.forEach((promise, index) => {\r\n      Promise.resolve(promise)\r\n        .then(value => {\r\n          resolve(value);\r\n        })\r\n        .catch(error => {\r\n          errors[index] = error;\r\n          rejectedCount++;\r\n\r\n          if (rejectedCount === totalPromises) {\r\n            reject(new AggregateError(errors, \"All promises were rejected\"));\r\n          }\r\n        });\r\n    });\r\n  });\r\n};\r\n\r\n// Example usage:\r\nconst p1 = Promise.reject('Error 1');\r\nconst p2 = new Promise((resolve) => setTimeout(resolve, 100, 'Success 2'));\r\nconst p3 = new Promise((resolve) => setTimeout(resolve, 200, 'Success 3'));\r\n\r\nPromise.myAny([p1, p2, p3])\r\n  .then(value => {\r\n    console.log('Resolved with value:', value); // \"Resolved with value: Success 2\"\r\n  })\r\n  .catch(error => {\r\n    console.error('Rejected with error:', error);\r\n  });\n"})}),"\n",(0,s.jsx)(r.h2,{id:"promise-race",children:"Promise Race"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-JavaScript",children:"Promise.myRace = function (promises = []) {\r\n  return new Promise((resolve, reject) => {\r\n    promises.forEach(promise => {\r\n      Promise.resolve(promise)\r\n        .then(resolve)\r\n        .catch(reject);\r\n    });\r\n  });\r\n};\r\n\r\n// Example usage:\r\nconst p1 = new Promise((resolve) => setTimeout(resolve, 500, 'Success 1'));\r\nconst p2 = new Promise((resolve, reject) => setTimeout(reject, 100, 'Error 2'));\r\nconst p3 = new Promise((resolve) => setTimeout(resolve, 200, 'Success 3'));\r\n\r\nPromise.myRace([p1, p2, p3])\r\n  .then(value => {\r\n    console.log('Resolved with value:', value); // \"Resolved with value: Success 2\"\r\n  })\r\n  .catch(error => {\r\n    console.error('Rejected with error:', error); // \"Rejected with error: Error 2\"\r\n  });\n"})}),"\n",(0,s.jsx)(r.h2,{id:"fetch-with-retry",children:"Fetch with Retry"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-JavaScript",children:"const fetchWithRetry = async (fetcher, maxRetry = 3, currentRetry = 0) => {\r\n  try {\r\n    const response = await fetcher()\r\n    if (response.ok) {\r\n      return await response.json()\r\n    }\r\n  }\r\n  catch (err) {\r\n    console.log('err', err);\r\n    if (maxRetry > 0) {\r\n      return fetchWithRetry(fetcher, maxRetry - 1, currentRetry + 1)\r\n    }\r\n  }\r\n  throw new Error(`Failed to fetch after ${currentRetry} retries`)\r\n}\r\n\r\n\r\n//Usage \r\nconst url = 'https://api.example.com'\r\n\r\nconst fetchData = async () => fetchWithRetry(() => fetch(url), 3)\r\n\r\n\r\nfetchData()\r\n  .then(res => res.json())\r\n  .then(data => console.log(data))\r\n  .catch(error => console.log('failed to fetch', error))\n"})}),"\n",(0,s.jsx)(r.h2,{id:"sleep",children:"Sleep"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-JavaScript",children:"const sleep = (wait) => new Promise(res => setTimeout(res, wait))\r\n\r\nasync function fix() {\r\n  console.log('Start');\r\n  await sleep(2000); // Sleep for 2 seconds\r\n  console.log('End');\r\n}\r\n\r\nfix();\n"})}),"\n",(0,s.jsx)(r.h2,{id:"retry-callback",children:"Retry Callback"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-JavaScript",children:"function retry(fn, retries = 3, delay = 1000) {\r\n    const attempt = (triesLeft, resolve, reject, args) => {\r\n        fn(...args)\r\n            .then(resolve)\r\n            .catch(error => {\r\n                if (triesLeft === 0) {\r\n                    reject(`Failed after ${retries} attempts: ${error}`);\r\n                } else {\r\n                    console.log(`Retrying... Attempts left: ${triesLeft}`);\r\n                    setTimeout(() => attempt(triesLeft - 1, resolve, reject, args), delay);\r\n                }\r\n            });\r\n    };\r\n\r\n    return (...args) => new Promise((resolve, reject) => attempt(retries, resolve, reject, args));\r\n}\n"})}),"\n",(0,s.jsx)(r.h3,{id:"example-usage",children:"Example Usage"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-JavaScript",children:'function unreliableFunction() {\r\n    return new Promise((resolve, reject) => {\r\n        const success = Math.random() > 0.7;  // 30% chance of success\r\n        if (success) {\r\n            resolve("Success!");\r\n        } else {\r\n            reject("Random failure");\r\n        }\r\n    });\r\n}\r\n\r\nconst retryUnreliable = retry(unreliableFunction, 3, 1000);\r\n\r\nretryUnreliable()\r\n    .then(result => console.log(result))\r\n    .catch(error => console.error(error));\r\n\r\n/* \r\nRetrying... Attempts left: 3\r\nRetrying... Attempts left: 2\r\nRetrying... Attempts left: 1\r\nFailed after 3 attempts: Random failure\r\n*/\n'})})]})}function u(e={}){const{wrapper:r}={...(0,t.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>l,x:()=>i});var s=n(6540);const t={},o=s.createContext(t);function l(e){const r=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function i(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),s.createElement(o.Provider,{value:r},e.children)}}}]);