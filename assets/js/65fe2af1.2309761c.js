"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[3019],{6940:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>m,frontMatter:()=>r,metadata:()=>a,toc:()=>l});var i=t(4848),o=t(8453);const r={title:"Memoization"},s=void 0,a={id:"tutorial-extras/JSInterviewQuestions/Memoization",title:"Memoization",description:"Memoization in JavaScript is a technique used to optimize the performance of functions by storing the results of expensive function calls and returning the cached result when the same inputs occur again. It is particularly useful in scenarios where the same computations are repeated multiple times, like recursive algorithms (e.g., Fibonacci sequence, factorials, dynamic programming problems).",source:"@site/docs/tutorial-extras/JSInterviewQuestions/Memoization.mdx",sourceDirName:"tutorial-extras/JSInterviewQuestions",slug:"/tutorial-extras/JSInterviewQuestions/Memoization",permalink:"/js.enigma/docs/tutorial-extras/JSInterviewQuestions/Memoization",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/tutorial-extras/JSInterviewQuestions/Memoization.mdx",tags:[],version:"current",frontMatter:{title:"Memoization"},sidebar:"tutorialSidebar",previous:{title:"Canceling an API Call",permalink:"/js.enigma/docs/tutorial-extras/JSInterviewQuestions/HowToCancelAPICalls"},next:{title:"Miscellaneous",permalink:"/js.enigma/docs/tutorial-extras/JSInterviewQuestions/Misx"}},c={},l=[{value:"How Memoization Works:",id:"how-memoization-works",level:3},{value:"Without Memoization:",id:"without-memoization",level:3},{value:"With Memoization",id:"with-memoization",level:3},{value:"General Memoization Function",id:"general-memoization-function",level:3},{value:"Benefits of Memoization:",id:"benefits-of-memoization",level:3}];function u(e){const n={code:"code",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"Memoization in JavaScript is a technique used to optimize the performance of functions by storing the results of expensive function calls and returning the cached result when the same inputs occur again. It is particularly useful in scenarios where the same computations are repeated multiple times, like recursive algorithms (e.g., Fibonacci sequence, factorials, dynamic programming problems)."}),"\n",(0,i.jsx)(n.h3,{id:"how-memoization-works",children:"How Memoization Works:"}),"\n",(0,i.jsx)(n.p,{children:"A cache (often an object or map) is used to store the results of function calls.\r\nWhen the function is called, it first checks if the result for the given input is already in the cache.\r\nIf it\u2019s cached, the result is returned from the cache, avoiding the computation.\r\nIf it\u2019s not cached, the function computes the result, stores it in the cache, and then returns the result."}),"\n",(0,i.jsx)(n.h3,{id:"without-memoization",children:"Without Memoization:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-JavaScript",children:"function fibonacci(n) {\r\n  if (n <= 1) return n;\r\n  return fibonacci(n - 1) + fibonacci(n - 2);\r\n}\r\n\r\nconsole.log(fibonacci(10)); // 55\n"})}),"\n",(0,i.jsx)(n.p,{children:"This implementation works, but it recalculates the Fibonacci sequence multiple times, resulting in exponential time complexity O(2^n)."}),"\n",(0,i.jsx)(n.h3,{id:"with-memoization",children:"With Memoization"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-JavaScript",children:"function fibonacciMemoized() {\r\n  const cache = {};  // Cache object to store results\r\n\r\n  function fib(n) {\r\n    if (n <= 1) return n;\r\n    if (cache[n]) return cache[n];  // Return cached result if available\r\n    cache[n] = fib(n - 1) + fib(n - 2);  // Store the computed result\r\n    return cache[n];\r\n  }\r\n\r\n  return fib;\r\n}\r\n\r\nconst fib = fibonacciMemoized();\r\nconsole.log(fib(10)); // 55\n"})}),"\n",(0,i.jsx)(n.p,{children:"This reduces the time complexity to linear O(n)."}),"\n",(0,i.jsx)(n.h3,{id:"general-memoization-function",children:"General Memoization Function"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-JavaScript",children:"function memoize(fn) {\r\n  const cache = {};\r\n  return function(...args) {\r\n    const key = JSON.stringify(args);  // Serialize the arguments as a key\r\n    if (cache[key]) return cache[key];  // Return cached result\r\n    const result = fn(...args);  // Compute result if not cached\r\n    cache[key] = result;  // Store result in cache\r\n    return result;\r\n  };\r\n}\r\n\r\n// Example usage with a slow function\r\nfunction slowFunction(x) {\r\n  console.log('Computing...');\r\n  return x * 2;\r\n}\r\n\r\nconst memoizedSlowFunction = memoize(slowFunction);\r\nconsole.log(memoizedSlowFunction(5)); // Computes: 10\r\nconsole.log(memoizedSlowFunction(5)); // Fetches from cache: 10\n"})}),"\n",(0,i.jsx)(n.h3,{id:"benefits-of-memoization",children:"Benefits of Memoization:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Performance optimization: Memoization can drastically reduce the runtime of functions that perform expensive or repetitive computations."}),"\n",(0,i.jsx)(n.li,{children:"Avoids redundant calculations: By caching results, it prevents recalculating the same inputs multiple times"}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>a});var i=t(6540);const o={},r=i.createContext(o);function s(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);