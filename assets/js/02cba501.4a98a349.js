"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[7133],{251:(n,e,o)=>{o.r(e),o.d(e,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>r,metadata:()=>i,toc:()=>c});var s=o(4848),t=o(8453);const r={},a="Async Await",i={id:"WebDev/JavaScript/AsyncAwait",title:"Async Await",description:"Print Numbers after num Seconds",source:"@site/docs/WebDev/JavaScript/AsyncAwait.mdx",sourceDirName:"WebDev/JavaScript",slug:"/WebDev/JavaScript/AsyncAwait",permalink:"/js.enigma/docs/WebDev/JavaScript/AsyncAwait",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/WebDev/JavaScript/AsyncAwait.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Web Components",permalink:"/js.enigma/docs/WebDev/HTMLDOM/WebComponents"},next:{title:"Async Patterns",permalink:"/js.enigma/docs/WebDev/JavaScript/AsyncPatterns"}},l={},c=[{value:"Print Numbers after num Seconds",id:"print-numbers-after-num-seconds",level:2},{value:"Print Numbers after num Seconds : Async Await",id:"print-numbers-after-num-seconds--async-await",level:2}];function u(n){const e={code:"code",h1:"h1",h2:"h2",header:"header",pre:"pre",...(0,t.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"async-await",children:"Async Await"})}),"\n",(0,s.jsx)(e.h2,{id:"print-numbers-after-num-seconds",children:"Print Numbers after num Seconds"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-JavaScript",children:"const nums = [1, 2, 3, 4, 5];\n\nfunction printAfterNumber(nums) {\n  let cumulativeDelay = 0;\n\n  for (let i = 0; i < nums.length; i++) {\n    cumulativeDelay += nums[i] * 1000; // Add the delay for the current number\n    setTimeout(() => {\n      console.log(nums[i]);\n    }, cumulativeDelay);\n  }\n}\n\nprintAfterNumber(nums);\n/* \n1 // After 1s\n2 // After 2s\n3 //...\n4\n5\n*/\n"})}),"\n",(0,s.jsx)(e.h2,{id:"print-numbers-after-num-seconds--async-await",children:"Print Numbers after num Seconds : Async Await"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-JavaScript",children:"const nums = [1, 2, 3, 4, 5];\n\nconst sleep = (ms) => new Promise((res) => setTimeout(res, ms));\n\nasync function printAfterNumber(nums) {\n  for (let i = 0; i < nums.length; i++) {\n    await sleep(nums[i] * 1000);\n    console.log(nums[i]);\n  }\n}\n\nprintAfterNumber(nums);\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-JavaScript",children:"// Problem 1: Mixing Promises and setTimeout\nconsole.log('\ud83d\ude80 Problem 1: Promise vs setTimeout');\n\nasync function asyncOrder() {\n    console.log('1');\n    \n    setTimeout(() => {\n        console.log('2');\n    }, 0);\n    \n    await Promise.resolve().then(() => console.log('3'));\n    \n    console.log('4');\n}\n\nasyncOrder();\nconsole.log('5');\n\n/* Output:\n1\n5\n3\n4\n2\nExplanation: \n- Microtasks (Promises) have priority over macrotasks (setTimeout)\n- Even with 0ms timeout, setTimeout callback goes to macrotask queue\n*/\n\n// Problem 2: Multiple Awaits\nconsole.log('\\n\ud83d\ude80 Problem 2: Multiple Awaits');\n\nasync function parallel() {\n    const promise1 = Promise.resolve('First');\n    const promise2 = Promise.resolve('Second');\n    \n    const promise3 = await promise1;\n    console.log(promise3);\n    \n    const promise4 = await promise2;\n    console.log(promise4);\n}\n\nasync function concurrent() {\n    const [first, second] = await Promise.all([\n        Promise.resolve('First'),\n        Promise.resolve('Second')\n    ]);\n    \n    console.log(first);\n    console.log(second);\n}\n\nconsole.log('Start');\nparallel();\nconsole.log('End');\n\n/* Output:\nStart\nEnd\nFirst\nSecond\n\nExplanation:\n- sequential execution of awaits\n- Promise.all would be more efficient for concurrent execution\n*/\n\n// Problem 3: Error Handling\nconsole.log('\\n\ud83d\ude80 Problem 3: Error Handling');\n\nasync function errorHandling() {\n    try {\n        console.log('1');\n        await Promise.reject('Error!');\n        console.log('2'); // Never reached\n    } catch (error) {\n        console.log('3');\n    } finally {\n        console.log('4');\n    }\n    console.log('5');\n}\n\nerrorHandling();\nconsole.log('6');\n\n/* Output:\n1\n6\n3\n4\n5\n\nExplanation:\n- Error causes jump to catch block\n- finally always executes\n- async function continues after try-catch\n*/\n\n// Problem 4: Promise Race Conditions\nconsole.log('\\n\ud83d\ude80 Problem 4: Race Conditions');\n\nasync function raceCondition() {\n    const getData = () => new Promise(resolve => \n        setTimeout(() => resolve('Data'), Math.random() * 100)\n    );\n    \n    const results = [];\n    \n    // Wrong way - race condition\n    for (let i = 0; i < 3; i++) {\n        getData().then(result => results.push(result));\n    }\n    \n    await Promise.all(results); // This won't work as expected!\n    console.log(results); // May not have all results\n    \n    // Correct way\n    const correctResults = await Promise.all(\n        Array(3).fill(null).map(() => getData())\n    );\n    console.log(correctResults); // Guaranteed to have all results\n}\n\nraceCondition();\n\n// Problem 5: Async Loop Trap\nconsole.log('\\n\ud83d\ude80 Problem 5: Async Loop Trap');\n\nasync function asyncLoop() {\n    const items = [1, 2, 3];\n    \n    // Wrong way - all requests fire at once\n    items.forEach(async (item) => {\n        const result = await Promise.resolve(item * 2);\n        console.log(result);\n    });\n    \n    console.log('Done forEach');\n    \n    // Correct way - sequential processing\n    for (const item of items) {\n        const result = await Promise.resolve(item * 2);\n        console.log(result);\n    }\n    \n    console.log('Done for...of');\n}\n\nasyncLoop();\n\n/* Output:\nDone forEach\n2\n4\n6\n2\n4\n6\nDone for...of\n\nExplanation:\n- forEach doesn't wait for async operations\n- for...of allows proper sequential processing\n*/\n\n// Problem 6: Return Value Trap\nconsole.log('\\n\ud83d\ude80 Problem 6: Return Value Trap');\n\nasync function returnValue() {\n    return await Promise.resolve('Done');\n}\n\nasync function unnecessaryAwait() {\n    // Unnecessary await - just return the promise\n    return await Promise.resolve('Done');\n}\n\nconst result1 = returnValue();\nconst result2 = unnecessaryAwait();\n\nconsole.log(result1); // Promise { 'Done' }\nconsole.log(result2); // Promise { 'Done' }\n\n/* Explanation:\n- Both functions return a Promise\n- await in return is usually unnecessary\n- Need to await the function call to get the value\n*/\n\n// Problem 7: Async IIFE Confusion\nconsole.log('\\n\ud83d\ude80 Problem 7: Async IIFE');\n\n(async () => {\n    console.log('1');\n    await Promise.resolve();\n    console.log('2');\n})();\n\nconsole.log('3');\n\n/* Output:\n1\n3\n2\n\nExplanation:\n- Async IIFE is still async\n- Code outside continues executing\n*/\n\n// Problem 8: Promise Chain vs Async/Await\nconsole.log('\\n\ud83d\ude80 Problem 8: Promise Chain vs Async/Await');\n\n// Promise chain\nPromise.resolve('Start')\n    .then(result => {\n        console.log(result);\n        return 'Middle';\n    })\n    .then(result => {\n        console.log(result);\n        return 'End';\n    })\n    .then(result => {\n        console.log(result);\n    });\n\n// Equivalent async/await\nasync function asyncChain() {\n    const start = await Promise.resolve('Start');\n    console.log(start);\n    \n    const middle = await Promise.resolve('Middle');\n    console.log(middle);\n    \n    const end = await Promise.resolve('End');\n    console.log(end);\n}\n\n/* Output (both produce):\nStart\nMiddle\nEnd\n\nExplanation:\n- Both approaches are equivalent\n- Async/await is more readable for complex chains\n*/\n\n// Problem 9: Concurrent vs Sequential\nconsole.log('\\n\ud83d\ude80 Problem 9: Concurrent vs Sequential');\n\nasync function sequential() {\n    console.time('sequential');\n    const first = await new Promise(r => setTimeout(() => r('first'), 1000));\n    const second = await new Promise(r => setTimeout(() => r('second'), 1000));\n    console.timeEnd('sequential'); // ~2000ms\n    return [first, second];\n}\n\nasync function concurrent() {\n    console.time('concurrent');\n    const [first, second] = await Promise.all([\n        new Promise(r => setTimeout(() => r('first'), 1000)),\n        new Promise(r => setTimeout(() => r('second'), 1000))\n    ]);\n    console.timeEnd('concurrent'); // ~1000ms\n    return [first, second];\n}\n\n/* Explanation:\n- Sequential: Each promise waits for previous\n- Concurrent: All promises run at the same time\n- Promise.all is more efficient for independent operations\n*/\n\n// Problem 10: Event Loop Order\nconsole.log('\\n\ud83d\ude80 Problem 10: Event Loop Order');\n\nasync function eventLoop() {\n    console.log('1'); // Synchronous\n    \n    setTimeout(() => {\n        console.log('2'); // Macrotask\n    }, 0);\n    \n    new Promise(resolve => resolve('3'))\n        .then(console.log); // Microtask\n    \n    await Promise.resolve('4');\n    console.log('5'); // After await\n    \n    queueMicrotask(() => {\n        console.log('6'); // Microtask\n    });\n}\n\neventLoop();\nconsole.log('7'); // Synchronous\n\n/* Output:\n1\n7\n3\n4\n5\n6\n2\n\nExplanation:\n1. Synchronous code executes first\n2. Microtasks (Promises, queueMicrotask) execute next\n3. Macrotasks (setTimeout, setInterval) execute last\n4. Each await creates a new microtask\n*/\n"})})]})}function m(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(u,{...n})}):u(n)}},8453:(n,e,o)=>{o.d(e,{R:()=>a,x:()=>i});var s=o(6540);const t={},r=s.createContext(t);function a(n){const e=s.useContext(r);return s.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function i(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:a(n.components),s.createElement(r.Provider,{value:e},n.children)}}}]);