"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[82123],{28453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>l});var s=i(96540);const t={},r=s.createContext(t);function a(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(r.Provider,{value:n},e.children)}},82470:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var s=i(74848),t=i(28453);const r={},a="React Scalability & Performance Guide for Interviews",l={id:"Interview Prep 2026/React Scalability & Performance Guide for Interviews",title:"React Scalability & Performance Guide for Interviews",description:"Table of Contents",source:"@site/docs/08-Interview Prep 2026/React Scalability & Performance Guide for Interviews.mdx",sourceDirName:"08-Interview Prep 2026",slug:"/Interview Prep 2026/React Scalability & Performance Guide for Interviews",permalink:"/docs/Interview Prep 2026/React Scalability & Performance Guide for Interviews",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/08-Interview Prep 2026/React Scalability & Performance Guide for Interviews.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"React Router DOM Cheatsheet for Interviews",permalink:"/docs/Interview Prep 2026/React Router DOM Cheatsheet for Interviews"},next:{title:"\ud83c\udf10 Web Internals Roadmap (Interview-Oriented)",permalink:"/docs/Interview Prep 2026/Web Internals Roadmap (Interview-Oriented)"}},o={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Performance Optimization Fundamentals",id:"performance-optimization-fundamentals",level:2},{value:"Key Concepts to Explain",id:"key-concepts-to-explain",level:3},{value:"Interview Answer Framework",id:"interview-answer-framework",level:3},{value:"Handling 1M+ Users",id:"handling-1m-users",level:2},{value:"Infrastructure Considerations",id:"infrastructure-considerations",level:3},{value:"Architectural Patterns for Scale",id:"architectural-patterns-for-scale",level:3},{value:"Code Splitting &amp; Lazy Loading",id:"code-splitting--lazy-loading",level:2},{value:"Why It Matters",id:"why-it-matters",level:3},{value:"Techniques to Explain",id:"techniques-to-explain",level:3},{value:"State Management at Scale",id:"state-management-at-scale",level:2},{value:"Choosing the Right Solution",id:"choosing-the-right-solution",level:3},{value:"Anti-Patterns to Avoid",id:"anti-patterns-to-avoid",level:3},{value:"State Normalization",id:"state-normalization",level:3},{value:"Rendering Optimization",id:"rendering-optimization",level:2},{value:"React.memo and useMemo",id:"reactmemo-and-usememo",level:3},{value:"Virtualization for Large Lists",id:"virtualization-for-large-lists",level:3},{value:"Debouncing and Throttling",id:"debouncing-and-throttling",level:3},{value:"Network &amp; Data Optimization",id:"network--data-optimization",level:2},{value:"API Request Optimization",id:"api-request-optimization",level:3},{value:"GraphQL for Efficient Data Fetching",id:"graphql-for-efficient-data-fetching",level:3},{value:"Bundle Size Optimization",id:"bundle-size-optimization",level:2},{value:"Analysis Tools",id:"analysis-tools",level:3},{value:"Optimization Techniques",id:"optimization-techniques",level:3},{value:"Caching Strategies",id:"caching-strategies",level:2},{value:"Multi-Layer Caching",id:"multi-layer-caching",level:3},{value:"Monitoring &amp; Metrics",id:"monitoring--metrics",level:2},{value:"What to Monitor at Scale",id:"what-to-monitor-at-scale",level:3},{value:"Interview Question Examples",id:"interview-question-examples",level:2},{value:"Question 1: &quot;How would you handle rendering 100,000 table rows?&quot;",id:"question-1-how-would-you-handle-rendering-100000-table-rows",level:3},{value:"Question 2: &quot;Your React app is slow. How do you debug it?&quot;",id:"question-2-your-react-app-is-slow-how-do-you-debug-it",level:3},{value:"Question 3: &quot;How do you optimize a React app for 1 million users?&quot;",id:"question-3-how-do-you-optimize-a-react-app-for-1-million-users",level:3},{value:"Question 4: &quot;Explain the difference between useMemo and useCallback&quot;",id:"question-4-explain-the-difference-between-usememo-and-usecallback",level:3},{value:"Question 5: &quot;What&#39;s your approach to state management in a large app?&quot;",id:"question-5-whats-your-approach-to-state-management-in-a-large-app",level:3},{value:"Key Takeaways for Interviews",id:"key-takeaways-for-interviews",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"react-scalability--performance-guide-for-interviews",children:"React Scalability & Performance Guide for Interviews"})}),"\n",(0,s.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#performance-optimization-fundamentals",children:"Performance Optimization Fundamentals"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#handling-1m-users",children:"Handling 1M+ Users"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#code-splitting--lazy-loading",children:"Code Splitting & Lazy Loading"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#state-management-at-scale",children:"State Management at Scale"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#rendering-optimization",children:"Rendering Optimization"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#network--data-optimization",children:"Network & Data Optimization"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#bundle-size-optimization",children:"Bundle Size Optimization"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#caching-strategies",children:"Caching Strategies"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#monitoring--metrics",children:"Monitoring & Metrics"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#interview-question-examples",children:"Interview Question Examples"})}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"performance-optimization-fundamentals",children:"Performance Optimization Fundamentals"}),"\n",(0,s.jsx)(n.h3,{id:"key-concepts-to-explain",children:"Key Concepts to Explain"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"What is Performance in React?"}),"\nPerformance in React means ensuring your application remains responsive, loads quickly, and provides smooth user interactions even under heavy load or with large datasets."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Core Metrics:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"FCP (First Contentful Paint)"}),": When first content appears (< 1.8s is good)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"LCP (Largest Contentful Paint)"}),": When main content loads (< 2.5s is good)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"TTI (Time to Interactive)"}),": When page becomes fully interactive (< 3.8s is good)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"CLS (Cumulative Layout Shift)"}),": Visual stability (< 0.1 is good)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"FID (First Input Delay)"}),": Responsiveness to user interaction (< 100ms is good)"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"interview-answer-framework",children:"Interview Answer Framework"}),"\n",(0,s.jsx)(n.p,{children:"When asked about performance, structure your answer:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Identify the bottleneck"})," (rendering, network, bundle size)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Measure first"})," (use React DevTools Profiler, Chrome DevTools)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Apply appropriate technique"})," (memoization, virtualization, code splitting)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Verify improvement"})," (measure again)"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"handling-1m-users",children:"Handling 1M+ Users"}),"\n",(0,s.jsx)(n.h3,{id:"infrastructure-considerations",children:"Infrastructure Considerations"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Client-Side Scalability:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Efficient rendering"}),": Only render what's visible"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Memory management"}),": Prevent memory leaks, clean up listeners"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Bundle optimization"}),": Keep initial bundle < 200KB gzipped"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"CDN usage"}),": Serve static assets from edge locations"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Server-Side Considerations:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"SSR/SSG"}),": Pre-render pages to reduce client-side work"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"API pagination"}),": Never load all 1M records at once"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Rate limiting"}),": Protect backend from overload"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Caching layers"}),": Redis, CDN caching for frequently accessed data"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"architectural-patterns-for-scale",children:"Architectural Patterns for Scale"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// Bad: Loading everything at once\nconst UsersList = () => {\n  const [users, setUsers] = useState([]);\n\n  useEffect(() => {\n    fetch('/api/users') // Returns 1M users!\n      .then(res => res.json())\n      .then(setUsers);\n  }, []);\n\n  return users.map(user => <UserCard key={user.id} {...user} />);\n};\n\n// Good: Pagination + Virtualization\nimport { useVirtualizer } from '@tanstack/react-virtual';\n\nconst UsersList = () => {\n  const [page, setPage] = useState(1);\n  const { data, isLoading } = useQuery({\n    queryKey: ['users', page],\n    queryFn: () => fetch(`/api/users?page=${page}&limit=50`)\n  });\n\n  const parentRef = useRef();\n\n  const virtualizer = useVirtualizer({\n    count: data?.total || 0,\n    getScrollElement: () => parentRef.current,\n    estimateSize: () => 100,\n  });\n\n  return (\n    <div ref={parentRef} style={{ height: '600px', overflow: 'auto' }}>\n      <div style={{ height: `${virtualizer.getTotalSize()}px` }}>\n        {virtualizer.getVirtualItems().map(virtualRow => (\n          <div key={virtualRow.index} style={{ transform: `translateY(${virtualRow.start}px)` }}>\n            <UserCard user={data.users[virtualRow.index]} />\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n};\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"code-splitting--lazy-loading",children:"Code Splitting & Lazy Loading"}),"\n",(0,s.jsx)(n.h3,{id:"why-it-matters",children:"Why It Matters"}),"\n",(0,s.jsx)(n.p,{children:"For 1M users, your initial bundle must be tiny. Code splitting means users only download code they need."}),"\n",(0,s.jsx)(n.h3,{id:"techniques-to-explain",children:"Techniques to Explain"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Route-Based Code Splitting:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { lazy, Suspense } from 'react';\nimport { BrowserRouter, Routes, Route } from 'react-router-dom';\n\n// These components are split into separate chunks\nconst Dashboard = lazy(() => import('./pages/Dashboard'));\nconst Analytics = lazy(() => import('./pages/Analytics'));\nconst Settings = lazy(() => import('./pages/Settings'));\n\nfunction App() {\n  return (\n    <BrowserRouter>\n      <Suspense fallback={<LoadingSpinner />}>\n        <Routes>\n          <Route path=\"/dashboard\" element={<Dashboard />} />\n          <Route path=\"/analytics\" element={<Analytics />} />\n          <Route path=\"/settings\" element={<Settings />} />\n        </Routes>\n      </Suspense>\n    </BrowserRouter>\n  );\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Component-Based Code Splitting:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// Heavy chart library loaded only when needed\nconst HeavyChart = lazy(() => import('./components/HeavyChart'));\n\nfunction DashboardPage() {\n  const [showChart, setShowChart] = useState(false);\n\n  return (\n    <div>\n      <button onClick={() => setShowChart(true)}>View Chart</button>\n      {showChart && (\n        <Suspense fallback={<div>Loading chart...</div>}>\n          <HeavyChart data={data} />\n        </Suspense>\n      )}\n    </div>\n  );\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Library Code Splitting:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// Load heavy libraries only when needed\nconst loadPDF = async () => {\n  const { jsPDF } = await import('jspdf');\n  return new jsPDF();\n};\n\nconst exportToPDF = async () => {\n  const pdf = await loadPDF();\n  // Use PDF library\n};\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"state-management-at-scale",children:"State Management at Scale"}),"\n",(0,s.jsx)(n.h3,{id:"choosing-the-right-solution",children:"Choosing the Right Solution"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"For 1M+ Users:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Local state"}),": Use ",(0,s.jsx)(n.code,{children:"useState"})," for component-specific data"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Server state"}),": Use React Query/TanStack Query (automatic caching, background refetching)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Global state"}),": Use Zustand or Jotai (minimal re-renders)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Form state"}),": Use React Hook Form (uncontrolled components)"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"anti-patterns-to-avoid",children:"Anti-Patterns to Avoid"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// Bad: Everything in global state\nconst useGlobalStore = create((set) => ({\n  users: [],\n  products: [],\n  orders: [],\n  currentUser: null,\n  theme: 'light',\n  // 50 more fields...\n}));\n\n// Good: Separate concerns\nconst useAuth = create((set) => ({\n  currentUser: null,\n  login: (user) => set({ currentUser: user }),\n}));\n\nconst useTheme = create((set) => ({\n  theme: 'light',\n  setTheme: (theme) => set({ theme }),\n}));\n\n// Server data managed separately with React Query\nconst { data: users } = useQuery({\n  queryKey: ['users'],\n  queryFn: fetchUsers,\n  staleTime: 5 * 60 * 1000, // 5 minutes\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"state-normalization",children:"State Normalization"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// Bad: Nested data causes deep re-renders\nconst state = {\n  posts: [\n    {\n      id: 1,\n      title: 'Post 1',\n      author: { id: 1, name: 'John' },\n      comments: [\n        { id: 1, text: 'Comment 1', author: { id: 2, name: 'Jane' } }\n      ]\n    }\n  ]\n};\n\n// Good: Normalized structure\nconst state = {\n  posts: {\n    byId: {\n      1: { id: 1, title: 'Post 1', authorId: 1, commentIds: [1] }\n    },\n    allIds: [1]\n  },\n  users: {\n    byId: {\n      1: { id: 1, name: 'John' },\n      2: { id: 2, name: 'Jane' }\n    }\n  },\n  comments: {\n    byId: {\n      1: { id: 1, text: 'Comment 1', authorId: 2 }\n    }\n  }\n};\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"rendering-optimization",children:"Rendering Optimization"}),"\n",(0,s.jsx)(n.h3,{id:"reactmemo-and-usememo",children:"React.memo and useMemo"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"When to Use:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Component receives same props frequently"}),"\n",(0,s.jsx)(n.li,{children:"Component has expensive calculations"}),"\n",(0,s.jsx)(n.li,{children:"Rendering thousands of items in a list"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// Expensive list item that shouldn't re-render unless its own data changes\nconst UserCard = memo(({ user, onSelect }) => {\n  console.log('Rendering UserCard', user.id);\n\n  return (\n    <div onClick={() => onSelect(user.id)}>\n      <h3>{user.name}</h3>\n      <p>{user.email}</p>\n    </div>\n  );\n});\n\n// Parent component\nfunction UserList() {\n  const [selectedId, setSelectedId] = useState(null);\n  const [searchTerm, setSearchTerm] = useState('');\n\n  // Memoize callback to prevent UserCard re-renders\n  const handleSelect = useCallback((id) => {\n    setSelectedId(id);\n  }, []);\n\n  // Memoize expensive filtering\n  const filteredUsers = useMemo(() => {\n    return users.filter(user =>\n      user.name.toLowerCase().includes(searchTerm.toLowerCase())\n    );\n  }, [users, searchTerm]);\n\n  return (\n    <div>\n      <input value={searchTerm} onChange={e => setSearchTerm(e.target.value)} />\n      {filteredUsers.map(user => (\n        <UserCard key={user.id} user={user} onSelect={handleSelect} />\n      ))}\n    </div>\n  );\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"virtualization-for-large-lists",children:"Virtualization for Large Lists"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { FixedSizeList } from 'react-window';\n\n// Render 100,000 items efficiently\nfunction VirtualizedList({ items }) {\n  const Row = ({ index, style }) => (\n    <div style={style}>\n      {items[index].name}\n    </div>\n  );\n\n  return (\n    <FixedSizeList\n      height={600}\n      itemCount={items.length}\n      itemSize={50}\n      width=\"100%\"\n    >\n      {Row}\n    </FixedSizeList>\n  );\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"debouncing-and-throttling",children:"Debouncing and Throttling"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { useDebouncedValue } from './hooks';\n\nfunction SearchComponent() {\n  const [search, setSearch] = useState('');\n  const debouncedSearch = useDebouncedValue(search, 300);\n\n  // Only fires API call when user stops typing for 300ms\n  const { data } = useQuery({\n    queryKey: ['search', debouncedSearch],\n    queryFn: () => searchAPI(debouncedSearch),\n    enabled: debouncedSearch.length > 2,\n  });\n\n  return (\n    <input\n      value={search}\n      onChange={e => setSearch(e.target.value)}\n      placeholder=\"Search...\"\n    />\n  );\n}\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"network--data-optimization",children:"Network & Data Optimization"}),"\n",(0,s.jsx)(n.h3,{id:"api-request-optimization",children:"API Request Optimization"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Techniques for 1M+ Users:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Request Deduplication"}),": Prevent duplicate simultaneous requests"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Prefetching"}),": Load data before user needs it"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Background Refetching"}),": Keep data fresh without blocking UI"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Infinite Queries"}),": Load data as user scrolls"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Optimistic Updates"}),": Update UI immediately, rollback on error"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// React Query handles all these automatically\nconst { data, fetchNextPage, hasNextPage } = useInfiniteQuery({\n  queryKey: ['posts'],\n  queryFn: ({ pageParam = 1 }) => fetchPosts(pageParam),\n  getNextPageParam: (lastPage) => lastPage.nextPage,\n  staleTime: 5 * 60 * 1000, // Cache for 5 minutes\n  refetchOnWindowFocus: true, // Refresh when tab regains focus\n});\n\n// Prefetch next page\nconst prefetchNextPage = () => {\n  queryClient.prefetchQuery({\n    queryKey: ['posts', nextPage],\n    queryFn: () => fetchPosts(nextPage),\n  });\n};\n\n// Optimistic update\nconst mutation = useMutation({\n  mutationFn: updatePost,\n  onMutate: async (newPost) => {\n    await queryClient.cancelQueries(['posts']);\n    const previous = queryClient.getQueryData(['posts']);\n\n    // Optimistically update\n    queryClient.setQueryData(['posts'], old => [...old, newPost]);\n\n    return { previous };\n  },\n  onError: (err, newPost, context) => {\n    // Rollback on error\n    queryClient.setQueryData(['posts'], context.previous);\n  },\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"graphql-for-efficient-data-fetching",children:"GraphQL for Efficient Data Fetching"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// Fetch only what you need\nconst USER_QUERY = gql`\n  query GetUser($id: ID!) {\n    user(id: $id) {\n      id\n      name\n      email\n      # Only fetch required fields\n    }\n  }\n`;\n\n// Batch multiple queries\nconst DASHBOARD_QUERY = gql`\n  query GetDashboard {\n    user { id name }\n    posts { id title }\n    notifications { id message }\n  }\n`;\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"bundle-size-optimization",children:"Bundle Size Optimization"}),"\n",(0,s.jsx)(n.h3,{id:"analysis-tools",children:"Analysis Tools"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# Analyze bundle size\nnpm run build\nnpx vite-bundle-visualizer\n# or\nnpx webpack-bundle-analyzer\n"})}),"\n",(0,s.jsx)(n.h3,{id:"optimization-techniques",children:"Optimization Techniques"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"1. Tree Shaking:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// Bad: Imports entire library\nimport _ from 'lodash';\n\n// Good: Import only what you need\nimport debounce from 'lodash/debounce';\nimport throttle from 'lodash/throttle';\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"2. Dynamic Imports:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// Load heavy dependency only when needed\nconst exportToExcel = async (data) => {\n  const XLSX = await import('xlsx');\n  const wb = XLSX.utils.book_new();\n  // ... rest of export logic\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"3. Replace Heavy Libraries:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// Instead of moment.js (288KB)\nimport moment from 'moment';\n\n// Use date-fns (tree-shakeable, ~13KB for common functions)\nimport { format, addDays } from 'date-fns';\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"4. Image Optimization:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Use next-gen formats\n<picture>\n  <source srcSet="image.webp" type="image/webp" />\n  <source srcSet="image.jpg" type="image/jpeg" />\n  <img src="image.jpg" alt="Description" loading="lazy" />\n</picture>\n\n// Or use a service\n<img src="https://cdn.example.com/image.jpg?w=400&q=80" />\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"caching-strategies",children:"Caching Strategies"}),"\n",(0,s.jsx)(n.h3,{id:"multi-layer-caching",children:"Multi-Layer Caching"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"1. HTTP Caching (Browser/CDN):"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// Set proper cache headers on server\nres.setHeader('Cache-Control', 'public, max-age=31536000, immutable');\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"2. Service Worker Caching:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// Cache static assets\nself.addEventListener('install', (event) => {\n  event.waitUntil(\n    caches.open('v1').then((cache) => {\n      return cache.addAll([\n        '/index.html',\n        '/styles.css',\n        '/app.js',\n      ]);\n    })\n  );\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"3. React Query Caching:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      staleTime: 5 * 60 * 1000, // 5 minutes\n      cacheTime: 10 * 60 * 1000, // 10 minutes\n      refetchOnWindowFocus: false,\n      retry: 3,\n    },\n  },\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"4. localStorage/IndexedDB:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// Cache user preferences\nconst savePreferences = (prefs) => {\n  localStorage.setItem('userPrefs', JSON.stringify(prefs));\n};\n\n// For larger datasets, use IndexedDB\nconst db = await openDB('myDatabase', 1, {\n  upgrade(db) {\n    db.createObjectStore('users', { keyPath: 'id' });\n  },\n});\n\nawait db.put('users', userData);\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"monitoring--metrics",children:"Monitoring & Metrics"}),"\n",(0,s.jsx)(n.h3,{id:"what-to-monitor-at-scale",children:"What to Monitor at Scale"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Real User Monitoring (RUM):"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// Web Vitals reporting\nimport { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';\n\nfunction sendToAnalytics(metric) {\n  const body = JSON.stringify(metric);\n  // Use sendBeacon for reliability\n  navigator.sendBeacon('/analytics', body);\n}\n\ngetCLS(sendToAnalytics);\ngetFID(sendToAnalytics);\ngetFCP(sendToAnalytics);\ngetLCP(sendToAnalytics);\ngetTTFB(sendToAnalytics);\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Error Tracking:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Use Sentry, LogRocket, or similar\nimport * as Sentry from "@sentry/react";\n\nSentry.init({\n  dsn: "your-dsn",\n  integrations: [new Sentry.BrowserTracing()],\n  tracesSampleRate: 0.1, // Sample 10% of transactions at scale\n});\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Performance Profiling:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// React DevTools Profiler API\nimport { Profiler } from \'react\';\n\nfunction onRenderCallback(\n  id, // Component identifier\n  phase, // "mount" or "update"\n  actualDuration, // Time spent rendering\n) {\n  if (actualDuration > 16) { // More than one frame\n    console.warn(`Slow render: ${id} took ${actualDuration}ms`);\n  }\n}\n\n<Profiler id="Navigation" onRender={onRenderCallback}>\n  <Navigation />\n</Profiler>\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"interview-question-examples",children:"Interview Question Examples"}),"\n",(0,s.jsx)(n.h3,{id:"question-1-how-would-you-handle-rendering-100000-table-rows",children:'Question 1: "How would you handle rendering 100,000 table rows?"'}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Answer Structure:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Never render all at once"}),': "I\'d use virtualization with react-window or @tanstack/react-virtual"']}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Explain virtualization"}),': "Only renders visible rows plus a buffer, dramatically reducing DOM nodes"']}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Code example"}),": Show FixedSizeList or useVirtualizer"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Mention alternatives"}),': "For simple cases, pagination might be better UX"']}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Consider backend"}),': "Ideally, implement server-side pagination too"']}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"question-2-your-react-app-is-slow-how-do-you-debug-it",children:'Question 2: "Your React app is slow. How do you debug it?"'}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Answer Framework:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Measure first"}),': "Use React DevTools Profiler to identify slow components"']}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Check for unnecessary re-renders"}),': "Look for components rendering without prop changes"']}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use Performance tab"}),': "Check for long tasks, layout thrashing"']}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Network waterfall"}),': "Check for sequential requests that could be parallel"']}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Bundle analysis"}),': "Check if bundle is too large"']}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Fix systematically"}),": memo, useMemo, useCallback, code splitting"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"question-3-how-do-you-optimize-a-react-app-for-1-million-users",children:'Question 3: "How do you optimize a React app for 1 million users?"'}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Comprehensive Answer:"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Infrastructure:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"CDN for static assets"}),"\n",(0,s.jsx)(n.li,{children:"Server-side rendering or static generation for initial load"}),"\n",(0,s.jsx)(n.li,{children:"Horizontal scaling of API servers"}),"\n",(0,s.jsx)(n.li,{children:"Database optimization (indexing, read replicas)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Frontend:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Aggressive code splitting (< 200KB initial bundle)"}),"\n",(0,s.jsx)(n.li,{children:"Virtualization for large lists"}),"\n",(0,s.jsx)(n.li,{children:"Optimistic updates for better perceived performance"}),"\n",(0,s.jsx)(n.li,{children:"Service worker for offline capability and asset caching"}),"\n",(0,s.jsx)(n.li,{children:"Lazy loading of images and non-critical components"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Data Management:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"React Query for automatic caching and deduplication"}),"\n",(0,s.jsx)(n.li,{children:"Normalized state structure"}),"\n",(0,s.jsx)(n.li,{children:"Pagination or infinite scroll instead of loading everything"}),"\n",(0,s.jsx)(n.li,{children:"Debounced search and autocomplete"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Monitoring:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Real user monitoring (Web Vitals)"}),"\n",(0,s.jsx)(n.li,{children:"Error tracking"}),"\n",(0,s.jsx)(n.li,{children:"Performance budgets in CI/CD"}),"\n",(0,s.jsx)(n.li,{children:"A/B testing for performance improvements"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"question-4-explain-the-difference-between-usememo-and-usecallback",children:'Question 4: "Explain the difference between useMemo and useCallback"'}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Answer:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"useMemo"}),": Memoizes a computed ",(0,s.jsx)(n.strong,{children:"value"}),". Returns the result of a function."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"useCallback"}),": Memoizes a ",(0,s.jsx)(n.strong,{children:"function"})," itself. Returns the function."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// useMemo: Prevents recalculating expensive values\nconst expensiveValue = useMemo(() => {\n  return data.reduce((sum, item) => sum + item.value, 0);\n}, [data]);\n\n// useCallback: Prevents creating new function instances\nconst handleClick = useCallback(() => {\n  console.log('Clicked', id);\n}, [id]);\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"When to use:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"useMemo: Expensive calculations, filtered/sorted arrays"}),"\n",(0,s.jsx)(n.li,{children:"useCallback: Passing callbacks to memoized child components"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"question-5-whats-your-approach-to-state-management-in-a-large-app",children:'Question 5: "What\'s your approach to state management in a large app?"'}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Answer:"}),'\n"I follow a multi-tier approach:']}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Server state"})," (React Query/TanStack Query): API data, background sync, caching"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"URL state"})," (React Router): Current page, filters, search params"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Local state"})," (useState): Component-specific UI state"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Global state"})," (Zustand/Jotai): Authentication, theme, truly global UI state"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"I avoid putting everything in global state. Most 'global' data is actually server data that should be cached, not managed globally. This keeps each concern separate and optimizes re-renders.\""}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"key-takeaways-for-interviews",children:"Key Takeaways for Interviews"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Always measure before optimizing"}),': "Premature optimization is the root of all evil"']}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Know the trade-offs"}),": Every optimization has costs (complexity, development time)"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Think about scale"}),": How would this work with 1M users? 1B records?"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Consider user experience"}),": Fast perceived performance > actual performance"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Use the right tool"}),": Not every app needs virtualization or complex state management"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Monitor in production"}),": What you measure in dev \u2260 real user experience"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Optimize the critical path"}),": Initial load matters most"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Be specific in answers"}),": Give concrete examples, show code, mention libraries"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Discuss trade-offs"}),': "React.memo adds memory overhead but reduces render time"']}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Stay current"}),": Mention React Server Components, Suspense for data fetching if relevant"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);