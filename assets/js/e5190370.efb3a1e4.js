"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[4005],{6583:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>h,default:()=>d,frontMatter:()=>s,metadata:()=>a,toc:()=>l});var t=r(4848),i=r(8453);const s={title:"Prim's Algorithm"},h=void 0,a={id:"DSA/Prim'sAlgorithm",title:"Prim's Algorithm",description:"Prim's algorithm is a greedy algorithm that finds a Minimum Spanning Tree (MST) for a connected, weighted, undirected graph. Unlike Kruskal's algorithm, which considers edges, Prim's algorithm grows the MST by adding vertices.",source:"@site/docs/DSA/Prim'sAlgorithm.mdx",sourceDirName:"DSA",slug:"/DSA/Prim'sAlgorithm",permalink:"/js.enigma/docs/DSA/Prim'sAlgorithm",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/Prim'sAlgorithm.mdx",tags:[],version:"current",frontMatter:{title:"Prim's Algorithm"},sidebar:"tutorialSidebar",previous:{title:"Prefix Sum",permalink:"/js.enigma/docs/DSA/PrefixSum"},next:{title:"Queue",permalink:"/js.enigma/docs/DSA/Queue"}},o={},l=[{value:"Steps of Prim&#39;s Algorithm",id:"steps-of-prims-algorithm",level:2},{value:"Time Complexity",id:"time-complexity",level:2},{value:"JavaScript Implementation",id:"javascript-implementation",level:2}];function p(e){const n={code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["Prim's algorithm is a greedy algorithm that finds a ",(0,t.jsx)(n.strong,{children:"Minimum Spanning Tree (MST)"})," for a connected, weighted, undirected graph. Unlike Kruskal's algorithm, which considers edges, Prim's algorithm grows the MST by adding vertices."]}),"\n",(0,t.jsx)(n.h2,{id:"steps-of-prims-algorithm",children:"Steps of Prim's Algorithm"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Initialize"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Start with an arbitrary vertex and mark it as part of the MST."}),"\n",(0,t.jsx)(n.li,{children:"Use a priority queue (or min-heap) to keep track of the minimum weight edges that connect the MST to vertices outside the MST."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Grow the MST"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["While there are still vertices not included in the MST:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Extract the edge with the smallest weight from the priority queue."}),"\n",(0,t.jsx)(n.li,{children:"If the extracted edge connects a vertex not already in the MST, add it to the MST and mark the new vertex as part of the MST."}),"\n",(0,t.jsx)(n.li,{children:"Add all edges connected to the newly added vertex to the priority queue."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Repeat"})," until all vertices are included in the MST."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"time-complexity",children:"Time Complexity"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The time complexity of Prim's algorithm is O(ElogV), where E is the number of edges and V is the number of vertices, when using a priority queue implemented with a binary heap."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"javascript-implementation",children:"JavaScript Implementation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-JavaScript",children:"class MinMaxPriorityQueue {\r\n\r\n  #heap = []\r\n  #compare;\r\n\r\n  constructor(compare) {\r\n    this.#heap = [];\r\n    this.#compare = compare || ((a, b) => a - b) //By default, keep it MinHeap\r\n  }\r\n\r\n  // Add a new element to the priority queue\r\n  enqueue = (value) => {\r\n    this.#heap.push(value);\r\n    this.#heapifyUp(this.#heap.length - 1);\r\n  }\r\n\r\n  // Remove and return the element with the highest priority (smallest for min-heap, largest for max-heap)\r\n  dequeue = () => {\r\n    if (this.#heap.length === 0) return null;\r\n    const root = this.#heap[0];\r\n    const end = this.#heap.pop();\r\n    if (this.#heap.length > 0) {\r\n      this.#heap[0] = end;\r\n      this.#heapifyDown(0);\r\n    }\r\n    return root;\r\n  }\r\n\r\n  // Peek at the element with the highest priority without removing it\r\n  peek = () => {\r\n    return this.#heap.length > 0 ? this.#heap[0] : null;\r\n  }\r\n\r\n  // Check if the priority queue is empty\r\n  isEmpty = () => {\r\n    return this.#heap.length === 0;\r\n  }\r\n\r\n  // Get the size of the priority queue\r\n  size = () => {\r\n    return this.#heap.length;\r\n  }\r\n\r\n  // Get the heap\r\n  get heap() {\r\n    return this.#heap\r\n  }\r\n\r\n  // Maintain heap property by moving element up\r\n  #heapifyUp = (index) => {\r\n    let parent = Math.floor((index - 1) / 2);\r\n    while (index > 0 && this.#compare(this.#heap[index], this.#heap[parent]) < 0) {\r\n      this.#swap(index, parent)\r\n      index = parent;\r\n      parent = Math.floor((index - 1) / 2);\r\n    }\r\n  }\r\n\r\n  // Maintain heap property by moving element down\r\n  #heapifyDown = (index) => {\r\n    const length = this.#heap.length;\r\n    let left = 2 * index + 1;\r\n    let right = 2 * index + 2;\r\n    let extreme = index;\r\n\r\n    if (left < length && this.#compare(this.#heap[left], this.#heap[extreme]) < 0) {\r\n      extreme = left;\r\n    }\r\n\r\n    if (right < length && this.#compare(this.#heap[right], this.#heap[extreme]) < 0) {\r\n      extreme = right;\r\n    }\r\n\r\n    if (extreme !== index) {\r\n      this.#swap(index, extreme)\r\n      this.#heapifyDown(extreme);\r\n    }\r\n  }\r\n\r\n  #swap = (i, j) => {\r\n    [this.#heap[i], this.#heap[j]] = [this.#heap[j], this.#heap[i]]\r\n  }\r\n}\r\n\r\n//Prim's Algorithm\r\nfunction prim(n, edges) {\r\n  const graph = Array.from({ length: n }, () => []);\r\n  for (const [u, v, weight] of edges) {\r\n    graph[u].push([v, weight]);\r\n    graph[v].push([u, weight]);\r\n  }\r\n\r\n  const mst = [];\r\n  const visited = new Set();\r\n  const minHeap = new MinMaxPriorityQueue((a, b) => a[1] - b[1]); // MinHeap based on weight\r\n\r\n  visited.add(0);\r\n  for (const [neighbor, weight] of graph[0]) {\r\n    minHeap.enqueue([neighbor, weight]);\r\n  }\r\n\r\n  while (!minHeap.isEmpty()) {\r\n    const [u, weight] = minHeap.dequeue();\r\n    if (visited.has(u)) continue;\r\n    visited.add(u);\r\n    mst.push([u, weight]);\r\n\r\n    for (const [neighbor, edgeWeight] of graph[u]) {\r\n      if (!visited.has(neighbor)) {\r\n        minHeap.enqueue([neighbor, edgeWeight]);\r\n      }\r\n    }\r\n  }\r\n\r\n  return mst;\r\n}\r\n\r\n// Example usage\r\nconst n = 4; // Number of vertices\r\nconst edges = [\r\n  [0, 1, 10],\r\n  [0, 2, 6],\r\n  [0, 3, 5],\r\n  [1, 3, 15],\r\n  [2, 3, 4]\r\n];\r\n\r\nconsole.log(prim(n, edges)); // [ [ 3, 5 ], [ 2, 4 ], [ 1, 10 ] ]\n"})})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(p,{...e})}):p(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>h,x:()=>a});var t=r(6540);const i={},s=t.createContext(i);function h(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:h(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);