"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[97456],{11289:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>t,metadata:()=>l,toc:()=>s});var r=i(74848),a=i(28453);const t={},c="Java Multithreading & Thread Safety",l={id:"Backend/Concurrency-Threading/Java Multithreading/Java Multithreading",title:"Java Multithreading & Thread Safety",description:"Table of Contents",source:"@site/docs/02-Backend/Concurrency-Threading/Java Multithreading/Java Multithreading.mdx",sourceDirName:"02-Backend/Concurrency-Threading/Java Multithreading",slug:"/Backend/Concurrency-Threading/Java Multithreading/",permalink:"/docs/Backend/Concurrency-Threading/Java Multithreading/",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/02-Backend/Concurrency-Threading/Java Multithreading/Java Multithreading.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Java Multithreading ",permalink:"/docs/category/java-multithreading-"},next:{title:"Java Threads & Concurrency: Understanding OS-Level Implementation",permalink:"/docs/Backend/Concurrency-Threading/Java Multithreading/Java Threads & Concurrency: Understanding OS-Level Implementation"}},o={},s=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Thread Fundamentals",id:"thread-fundamentals",level:2},{value:"What is a Thread?",id:"what-is-a-thread",level:3},{value:"Creating Threads",id:"creating-threads",level:3},{value:"Thread Lifecycle",id:"thread-lifecycle",level:3},{value:"Thread Safety Problems",id:"thread-safety-problems",level:2},{value:"Race Condition",id:"race-condition",level:3},{value:"Example: Unsafe Counter",id:"example-unsafe-counter",level:3},{value:"Synchronization Mechanisms",id:"synchronization-mechanisms",level:2},{value:"1. Synchronized Keyword",id:"1-synchronized-keyword",level:3},{value:"Lock Types",id:"lock-types",level:2},{value:"1. ReentrantLock (Explicit Locking)",id:"1-reentrantlock-explicit-locking",level:3},{value:"2. ReadWriteLock",id:"2-readwritelock",level:3},{value:"3. StampedLock (Java 8+)",id:"3-stampedlock-java-8",level:3},{value:"Thread-Safe Collections",id:"thread-safe-collections",level:2},{value:"Built-in Thread-Safe Collections",id:"built-in-thread-safe-collections",level:3},{value:"ConcurrentHashMap Features",id:"concurrenthashmap-features",level:3},{value:"Atomic Variables",id:"atomic-variables",level:2},{value:"AtomicInteger, AtomicLong, AtomicReference",id:"atomicinteger-atomiclong-atomicreference",level:3},{value:"AtomicReference Example",id:"atomicreference-example",level:3},{value:"Thread Pool &amp; Executors",id:"thread-pool--executors",level:2},{value:"ExecutorService",id:"executorservice",level:3},{value:"ThreadPoolExecutor (Custom Configuration)",id:"threadpoolexecutor-custom-configuration",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Immutability (Best Thread Safety)",id:"1-immutability-best-thread-safety",level:3},{value:"2. Minimize Synchronization Scope",id:"2-minimize-synchronization-scope",level:3},{value:"3. Use Higher-Level Concurrency Utilities",id:"3-use-higher-level-concurrency-utilities",level:3},{value:"4. Volatile for Simple Flags",id:"4-volatile-for-simple-flags",level:3},{value:"Progressive Example",id:"progressive-example",level:2},{value:"Version 1: Unsafe Bank Account",id:"version-1-unsafe-bank-account",level:3},{value:"Version 2: Synchronized Methods",id:"version-2-synchronized-methods",level:3},{value:"Version 3: ReentrantLock",id:"version-3-reentrantlock",level:3},{value:"Version 4: ReadWriteLock (Optimal)",id:"version-4-readwritelock-optimal",level:3},{value:"Version 5: Atomic with Optimistic Locking (Advanced)",id:"version-5-atomic-with-optimistic-locking-advanced",level:3},{value:"Summary: Which Approach to Use?",id:"summary-which-approach-to-use",level:2},{value:"Performance Hierarchy (Fastest to Slowest)",id:"performance-hierarchy-fastest-to-slowest",level:3},{value:"Testing Thread Safety",id:"testing-thread-safety",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"java-multithreading--thread-safety",children:"Java Multithreading & Thread Safety"})}),"\n",(0,r.jsx)(e.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#thread-fundamentals",children:"Thread Fundamentals"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#thread-safety-problems",children:"Thread Safety Problems"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#synchronization-mechanisms",children:"Synchronization Mechanisms"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#lock-types",children:"Lock Types"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#thread-safe-collections",children:"Thread-Safe Collections"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#atomic-variables",children:"Atomic Variables"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#thread-pool--executors",children:"Thread Pool & Executors"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#best-practices",children:"Best Practices"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#progressive-example",children:"Progressive Example: Making Code Thread-Safe"})}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"thread-fundamentals",children:"Thread Fundamentals"}),"\n",(0,r.jsx)(e.h3,{id:"what-is-a-thread",children:"What is a Thread?"}),"\n",(0,r.jsx)(e.p,{children:"A thread is the smallest unit of execution within a process. Java supports multithreading, allowing concurrent execution of multiple threads."}),"\n",(0,r.jsx)(e.h3,{id:"creating-threads",children:"Creating Threads"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Method 1: Extending Thread class"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:'class MyThread extends Thread {\n    public void run() {\n        System.out.println("Thread running: " + Thread.currentThread().getName());\n    }\n}\n\n// Usage\nMyThread thread = new MyThread();\nthread.start();\n'})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Method 2: Implementing Runnable (Preferred)"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:'class MyRunnable implements Runnable {\n    public void run() {\n        System.out.println("Thread running: " + Thread.currentThread().getName());\n    }\n}\n\n// Usage\nThread thread = new Thread(new MyRunnable());\nthread.start();\n'})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Method 3: Lambda Expression (Java 8+)"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:'Thread thread = new Thread(() -> {\n    System.out.println("Thread running: " + Thread.currentThread().getName());\n});\nthread.start();\n'})}),"\n",(0,r.jsx)(e.h3,{id:"thread-lifecycle",children:"Thread Lifecycle"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"NEW"})," - Thread created but not started"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"RUNNABLE"})," - Thread ready to run or running"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"BLOCKED"})," - Waiting for monitor lock"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"WAITING"})," - Waiting indefinitely for another thread"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"TIMED_WAITING"})," - Waiting for specified time"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"TERMINATED"})," - Thread completed execution"]}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"thread-safety-problems",children:"Thread Safety Problems"}),"\n",(0,r.jsx)(e.h3,{id:"race-condition",children:"Race Condition"}),"\n",(0,r.jsx)(e.p,{children:"Multiple threads accessing shared data simultaneously, leading to unpredictable results."}),"\n",(0,r.jsx)(e.h3,{id:"example-unsafe-counter",children:"Example: Unsafe Counter"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"class UnsafeCounter {\n    private int count = 0;\n\n    public void increment() {\n        count++;  // NOT atomic! (read, modify, write)\n    }\n\n    public int getCount() {\n        return count;\n    }\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Problem"}),": If 1000 threads call ",(0,r.jsx)(e.code,{children:"increment()"}),", the final count might be less than 1000 due to race conditions."]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"synchronization-mechanisms",children:"Synchronization Mechanisms"}),"\n",(0,r.jsx)(e.h3,{id:"1-synchronized-keyword",children:"1. Synchronized Keyword"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Synchronized Method"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"class SafeCounter {\n    private int count = 0;\n\n    public synchronized void increment() {\n        count++;\n    }\n\n    public synchronized int getCount() {\n        return count;\n    }\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Synchronized Block"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"class SafeCounter {\n    private int count = 0;\n    private final Object lock = new Object();\n\n    public void increment() {\n        synchronized(lock) {\n            count++;\n        }\n    }\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Key Points:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Only one thread can execute synchronized code at a time"}),"\n",(0,r.jsx)(e.li,{children:"Every object has an intrinsic lock (monitor)"}),"\n",(0,r.jsxs)(e.li,{children:["Synchronized methods lock on ",(0,r.jsx)(e.code,{children:"this"})]}),"\n",(0,r.jsx)(e.li,{children:"Static synchronized methods lock on the Class object"}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"lock-types",children:"Lock Types"}),"\n",(0,r.jsx)(e.h3,{id:"1-reentrantlock-explicit-locking",children:"1. ReentrantLock (Explicit Locking)"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Basic Usage"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"import java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\nclass SafeCounterWithLock {\n    private int count = 0;\n    private final Lock lock = new ReentrantLock();\n\n    public void increment() {\n        lock.lock();\n        try {\n            count++;\n        } finally {\n            lock.unlock();  // Always unlock in finally block\n        }\n    }\n\n    public int getCount() {\n        lock.lock();\n        try {\n            return count;\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Advantages over Synchronized:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["Try to acquire lock without blocking: ",(0,r.jsx)(e.code,{children:"tryLock()"})]}),"\n",(0,r.jsxs)(e.li,{children:["Interruptible lock acquisition: ",(0,r.jsx)(e.code,{children:"lockInterruptibly()"})]}),"\n",(0,r.jsx)(e.li,{children:"Fair lock ordering"}),"\n",(0,r.jsx)(e.li,{children:"Multiple condition variables"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Advanced Features"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"Lock lock = new ReentrantLock(true);  // Fair lock\n\nif (lock.tryLock()) {\n    try {\n        // Critical section\n    } finally {\n        lock.unlock();\n    }\n} else {\n    // Couldn't acquire lock\n}\n\n// Try with timeout\nif (lock.tryLock(1, TimeUnit.SECONDS)) {\n    // Got the lock\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"2-readwritelock",children:"2. ReadWriteLock"}),"\n",(0,r.jsx)(e.p,{children:"Allows multiple readers or one writer at a time."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"import java.util.concurrent.locks.ReadWriteLock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\nclass ReadWriteCache {\n    private final Map<String, String> cache = new HashMap<>();\n    private final ReadWriteLock rwLock = new ReentrantReadWriteLock();\n\n    public String get(String key) {\n        rwLock.readLock().lock();\n        try {\n            return cache.get(key);\n        } finally {\n            rwLock.readLock().unlock();\n        }\n    }\n\n    public void put(String key, String value) {\n        rwLock.writeLock().lock();\n        try {\n            cache.put(key, value);\n        } finally {\n            rwLock.writeLock().unlock();\n        }\n    }\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"3-stampedlock-java-8",children:"3. StampedLock (Java 8+)"}),"\n",(0,r.jsx)(e.p,{children:"Optimistic reading lock for better performance."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"import java.util.concurrent.locks.StampedLock;\n\nclass OptimisticCounter {\n    private int count = 0;\n    private final StampedLock lock = new StampedLock();\n\n    public void increment() {\n        long stamp = lock.writeLock();\n        try {\n            count++;\n        } finally {\n            lock.unlockWrite(stamp);\n        }\n    }\n\n    public int getCount() {\n        long stamp = lock.tryOptimisticRead();\n        int currentCount = count;\n\n        if (!lock.validate(stamp)) {\n            // Someone modified data, acquire read lock\n            stamp = lock.readLock();\n            try {\n                currentCount = count;\n            } finally {\n                lock.unlockRead(stamp);\n            }\n        }\n        return currentCount;\n    }\n}\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"thread-safe-collections",children:"Thread-Safe Collections"}),"\n",(0,r.jsx)(e.h3,{id:"built-in-thread-safe-collections",children:"Built-in Thread-Safe Collections"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"// Legacy synchronized collections (avoid in new code)\nList<String> syncList = Collections.synchronizedList(new ArrayList<>());\nMap<String, String> syncMap = Collections.synchronizedMap(new HashMap<>());\n\n// Modern concurrent collections (preferred)\nConcurrentHashMap<String, String> concurrentMap = new ConcurrentHashMap<>();\nCopyOnWriteArrayList<String> cowList = new CopyOnWriteArrayList<>();\nConcurrentLinkedQueue<String> queue = new ConcurrentLinkedQueue<>();\nBlockingQueue<String> blockingQueue = new LinkedBlockingQueue<>();\n"})}),"\n",(0,r.jsx)(e.h3,{id:"concurrenthashmap-features",children:"ConcurrentHashMap Features"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:'ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();\n\n// Atomic operations\nmap.putIfAbsent("key", 1);\nmap.computeIfAbsent("key", k -> expensiveComputation(k));\nmap.computeIfPresent("key", (k, v) -> v + 1);\nmap.merge("key", 1, Integer::sum);\n\n// Bulk operations (parallel processing)\nmap.forEach(10, (k, v) -> System.out.println(k + ":" + v));\nmap.reduceValues(10, Integer::sum);\n'})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"atomic-variables",children:"Atomic Variables"}),"\n",(0,r.jsx)(e.h3,{id:"atomicinteger-atomiclong-atomicreference",children:"AtomicInteger, AtomicLong, AtomicReference"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"import java.util.concurrent.atomic.*;\n\nclass AtomicCounter {\n    private AtomicInteger count = new AtomicInteger(0);\n\n    public void increment() {\n        count.incrementAndGet();  // Atomic operation\n    }\n\n    public int getCount() {\n        return count.get();\n    }\n\n    public void add(int delta) {\n        count.addAndGet(delta);\n    }\n\n    // Compare and swap\n    public boolean compareAndSet(int expect, int update) {\n        return count.compareAndSet(expect, update);\n    }\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"atomicreference-example",children:"AtomicReference Example"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"class AtomicCache<T> {\n    private AtomicReference<T> cache = new AtomicReference<>();\n\n    public T get() {\n        return cache.get();\n    }\n\n    public void set(T value) {\n        cache.set(value);\n    }\n\n    public boolean compareAndSet(T expect, T update) {\n        return cache.compareAndSet(expect, update);\n    }\n}\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"thread-pool--executors",children:"Thread Pool & Executors"}),"\n",(0,r.jsx)(e.h3,{id:"executorservice",children:"ExecutorService"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"import java.util.concurrent.*;\n\n// Fixed thread pool\nExecutorService executor = Executors.newFixedThreadPool(10);\n\n// Submit tasks\nFuture<Integer> future = executor.submit(() -> {\n    return 42;\n});\n\n// Get result\nInteger result = future.get();  // Blocks until complete\n\n// Shutdown\nexecutor.shutdown();\nexecutor.awaitTermination(1, TimeUnit.MINUTES);\n"})}),"\n",(0,r.jsx)(e.h3,{id:"threadpoolexecutor-custom-configuration",children:"ThreadPoolExecutor (Custom Configuration)"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"ThreadPoolExecutor executor = new ThreadPoolExecutor(\n    5,                      // corePoolSize\n    10,                     // maximumPoolSize\n    60L,                    // keepAliveTime\n    TimeUnit.SECONDS,\n    new LinkedBlockingQueue<>(100),  // workQueue\n    new ThreadPoolExecutor.CallerRunsPolicy()  // rejection policy\n);\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsx)(e.h3,{id:"1-immutability-best-thread-safety",children:"1. Immutability (Best Thread Safety)"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"public final class ImmutablePerson {\n    private final String name;\n    private final int age;\n\n    public ImmutablePerson(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() { return name; }\n    public int getAge() { return age; }\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"2-minimize-synchronization-scope",children:"2. Minimize Synchronization Scope"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"// BAD - Entire method synchronized\npublic synchronized void process() {\n    doSomethingExpensive();  // No shared state\n    updateSharedState();     // Shared state\n}\n\n// GOOD - Only critical section synchronized\npublic void process() {\n    doSomethingExpensive();\n    synchronized(this) {\n        updateSharedState();\n    }\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"3-use-higher-level-concurrency-utilities",children:"3. Use Higher-Level Concurrency Utilities"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"// Instead of wait/notify\nCountDownLatch latch = new CountDownLatch(3);\nSemaphore semaphore = new Semaphore(5);\nCyclicBarrier barrier = new CyclicBarrier(3);\n"})}),"\n",(0,r.jsx)(e.h3,{id:"4-volatile-for-simple-flags",children:"4. Volatile for Simple Flags"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"class FlagExample {\n    private volatile boolean running = true;\n\n    public void stop() {\n        running = false;  // Visible to all threads immediately\n    }\n\n    public void run() {\n        while (running) {\n            // Do work\n        }\n    }\n}\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"progressive-example",children:"Progressive Example"}),"\n",(0,r.jsx)(e.h3,{id:"version-1-unsafe-bank-account",children:"Version 1: Unsafe Bank Account"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"class BankAccount {\n    private double balance;\n\n    public BankAccount(double initialBalance) {\n        this.balance = initialBalance;\n    }\n\n    public void deposit(double amount) {\n        balance += amount;  // RACE CONDITION\n    }\n\n    public void withdraw(double amount) {\n        if (balance >= amount) {  // RACE CONDITION\n            balance -= amount;\n        }\n    }\n\n    public double getBalance() {\n        return balance;  // RACE CONDITION\n    }\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Problems:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Multiple threads can read/modify balance simultaneously"}),"\n",(0,r.jsx)(e.li,{children:"Check-then-act pattern in withdraw() is not atomic"}),"\n",(0,r.jsx)(e.li,{children:"Lost updates possible"}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h3,{id:"version-2-synchronized-methods",children:"Version 2: Synchronized Methods"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"class BankAccount {\n    private double balance;\n\n    public BankAccount(double initialBalance) {\n        this.balance = initialBalance;\n    }\n\n    public synchronized void deposit(double amount) {\n        balance += amount;\n    }\n\n    public synchronized void withdraw(double amount) {\n        if (balance >= amount) {\n            balance -= amount;\n        }\n    }\n\n    public synchronized double getBalance() {\n        return balance;\n    }\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Improvements:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Thread-safe operations"}),"\n",(0,r.jsx)(e.li,{children:"Simple to implement"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Drawbacks:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Locks entire object for every operation"}),"\n",(0,r.jsx)(e.li,{children:"Poor scalability"}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h3,{id:"version-3-reentrantlock",children:"Version 3: ReentrantLock"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"import java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\nclass BankAccount {\n    private double balance;\n    private final Lock lock = new ReentrantLock();\n\n    public BankAccount(double initialBalance) {\n        this.balance = initialBalance;\n    }\n\n    public void deposit(double amount) {\n        lock.lock();\n        try {\n            balance += amount;\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public boolean withdraw(double amount) {\n        lock.lock();\n        try {\n            if (balance >= amount) {\n                balance -= amount;\n                return true;\n            }\n            return false;\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public double getBalance() {\n        lock.lock();\n        try {\n            return balance;\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    // Try to withdraw with timeout\n    public boolean tryWithdraw(double amount, long timeout, TimeUnit unit)\n            throws InterruptedException {\n        if (lock.tryLock(timeout, unit)) {\n            try {\n                if (balance >= amount) {\n                    balance -= amount;\n                    return true;\n                }\n                return false;\n            } finally {\n                lock.unlock();\n            }\n        }\n        return false;  // Couldn't acquire lock\n    }\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Improvements:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"More flexible than synchronized"}),"\n",(0,r.jsx)(e.li,{children:"Can timeout on lock acquisition"}),"\n",(0,r.jsx)(e.li,{children:"Fair lock option available"}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h3,{id:"version-4-readwritelock-optimal",children:"Version 4: ReadWriteLock (Optimal)"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"import java.util.concurrent.locks.ReadWriteLock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\nclass BankAccount {\n    private double balance;\n    private final ReadWriteLock rwLock = new ReentrantReadWriteLock();\n\n    public BankAccount(double initialBalance) {\n        this.balance = initialBalance;\n    }\n\n    public void deposit(double amount) {\n        rwLock.writeLock().lock();\n        try {\n            balance += amount;\n        } finally {\n            rwLock.writeLock().unlock();\n        }\n    }\n\n    public boolean withdraw(double amount) {\n        rwLock.writeLock().lock();\n        try {\n            if (balance >= amount) {\n                balance -= amount;\n                return true;\n            }\n            return false;\n        } finally {\n            rwLock.writeLock().unlock();\n        }\n    }\n\n    public double getBalance() {\n        rwLock.readLock().lock();\n        try {\n            return balance;\n        } finally {\n            rwLock.readLock().unlock();\n        }\n    }\n\n    // Multiple threads can check balance simultaneously\n    public boolean hasEnoughBalance(double amount) {\n        rwLock.readLock().lock();\n        try {\n            return balance >= amount;\n        } finally {\n            rwLock.readLock().unlock();\n        }\n    }\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Improvements:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Multiple threads can read balance concurrently"}),"\n",(0,r.jsx)(e.li,{children:"Only write operations block each other"}),"\n",(0,r.jsx)(e.li,{children:"Best performance for read-heavy workloads"}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h3,{id:"version-5-atomic-with-optimistic-locking-advanced",children:"Version 5: Atomic with Optimistic Locking (Advanced)"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"import java.util.concurrent.atomic.AtomicReference;\n\nclass BankAccount {\n    private static class Balance {\n        final double amount;\n\n        Balance(double amount) {\n            this.amount = amount;\n        }\n    }\n\n    private final AtomicReference<Balance> balance;\n\n    public BankAccount(double initialBalance) {\n        this.balance = new AtomicReference<>(new Balance(initialBalance));\n    }\n\n    public void deposit(double amount) {\n        Balance current, updated;\n        do {\n            current = balance.get();\n            updated = new Balance(current.amount + amount);\n        } while (!balance.compareAndSet(current, updated));\n    }\n\n    public boolean withdraw(double amount) {\n        Balance current, updated;\n        do {\n            current = balance.get();\n            if (current.amount < amount) {\n                return false;\n            }\n            updated = new Balance(current.amount - amount);\n        } while (!balance.compareAndSet(current, updated));\n        return true;\n    }\n\n    public double getBalance() {\n        return balance.get().amount;\n    }\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Improvements:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Lock-free implementation"}),"\n",(0,r.jsx)(e.li,{children:"Compare-and-swap (CAS) operations"}),"\n",(0,r.jsx)(e.li,{children:"Better performance under high contention"}),"\n",(0,r.jsx)(e.li,{children:"No thread blocking"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Best for:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"High-concurrency scenarios"}),"\n",(0,r.jsx)(e.li,{children:"Low contention environments"}),"\n",(0,r.jsx)(e.li,{children:"When operations are fast"}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"summary-which-approach-to-use",children:"Summary: Which Approach to Use?"}),"\n",(0,r.jsxs)(e.table,{children:[(0,r.jsx)(e.thead,{children:(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.th,{children:"Scenario"}),(0,r.jsx)(e.th,{children:"Recommended Approach"})]})}),(0,r.jsxs)(e.tbody,{children:[(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Simple counter"}),(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"AtomicInteger"})})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Read-heavy operations"}),(0,r.jsxs)(e.td,{children:[(0,r.jsx)(e.code,{children:"ReadWriteLock"})," or ",(0,r.jsx)(e.code,{children:"StampedLock"})]})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Complex critical sections"}),(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"ReentrantLock"})})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Legacy code / Simple cases"}),(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"synchronized"})})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"No shared mutable state"}),(0,r.jsx)(e.td,{children:"Immutable objects"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Collections"}),(0,r.jsxs)(e.td,{children:[(0,r.jsx)(e.code,{children:"ConcurrentHashMap"}),", ",(0,r.jsx)(e.code,{children:"CopyOnWriteArrayList"})]})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Producer-Consumer"}),(0,r.jsx)(e.td,{children:(0,r.jsx)(e.code,{children:"BlockingQueue"})})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"High contention"}),(0,r.jsxs)(e.td,{children:["Lock-free with ",(0,r.jsx)(e.code,{children:"Atomic*"})," classes"]})]})]})]}),"\n",(0,r.jsx)(e.h3,{id:"performance-hierarchy-fastest-to-slowest",children:"Performance Hierarchy (Fastest to Slowest)"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"Immutable objects (no synchronization needed)"}),"\n",(0,r.jsx)(e.li,{children:"Atomic variables with CAS"}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"ReadWriteLock"})," (for read-heavy workloads)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"StampedLock"})," optimistic reads"]}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.code,{children:"ReentrantLock"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.code,{children:"synchronized"})}),"\n",(0,r.jsx)(e.li,{children:"Synchronized collections (legacy)"}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"testing-thread-safety",children:"Testing Thread Safety"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:'import java.util.concurrent.*;\n\nclass ThreadSafetyTest {\n    public static void main(String[] args) throws InterruptedException {\n        BankAccount account = new BankAccount(1000);\n        ExecutorService executor = Executors.newFixedThreadPool(100);\n\n        // Submit 1000 deposits of $1\n        for (int i = 0; i < 1000; i++) {\n            executor.submit(() -> account.deposit(1));\n        }\n\n        executor.shutdown();\n        executor.awaitTermination(1, TimeUnit.MINUTES);\n\n        // Should be exactly 2000\n        System.out.println("Final balance: " + account.getBalance());\n    }\n}\n'})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Prefer immutability"})," - No synchronization needed"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Use concurrent collections"})," - Better than manual synchronization"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Minimize lock scope"})," - Lock only what's necessary"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsxs)(e.strong,{children:["Use ",(0,r.jsx)(e.code,{children:"java.util.concurrent"})," utilities"]})," - Higher-level abstractions"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Atomic variables for counters"})," - Simple and fast"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"ReadWriteLock for reads"})," - Allow concurrent reads"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Always unlock in finally"})," - Prevent deadlocks"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Test with concurrent load"})," - Race conditions are hard to spot"]}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Remember:"})," The best thread-safe code is code that doesn't share mutable state!"]})]})}function h(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}},28453:(n,e,i)=>{i.d(e,{R:()=>c,x:()=>l});var r=i(96540);const a={},t=r.createContext(a);function c(n){const e=r.useContext(t);return r.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:c(n.components),r.createElement(t.Provider,{value:e},n.children)}}}]);