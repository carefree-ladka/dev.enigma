"use strict";(globalThis.webpackChunkdev_enigma=globalThis.webpackChunkdev_enigma||[]).push([[24586],{28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>i});var a=t(96540);const c={},r=a.createContext(c);function s(e){const n=a.useContext(r);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:s(e.components),a.createElement(r.Provider,{value:n},e.children)}},44271:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>r,metadata:()=>i,toc:()=>o});var a=t(74848),c=t(28453);const r={},s="Event Emitter",i={id:"Frontend/Core-Technologies/JavaScript/EventEmitter",title:"Event Emitter",description:"",source:"@site/docs/01-Frontend/Core-Technologies/JavaScript/EventEmitter.mdx",sourceDirName:"01-Frontend/Core-Technologies/JavaScript",slug:"/Frontend/Core-Technologies/JavaScript/EventEmitter",permalink:"/docs/Frontend/Core-Technologies/JavaScript/EventEmitter",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/01-Frontend/Core-Technologies/JavaScript/EventEmitter.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Design Patterns",permalink:"/docs/Frontend/Core-Technologies/JavaScript/DesignPatterns"},next:{title:"Event Loop",permalink:"/docs/Frontend/Core-Technologies/JavaScript/EventLoop"}},l={},o=[];function b(e){const n={code:"code",h1:"h1",header:"header",pre:"pre",...(0,c.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"event-emitter",children:"Event Emitter"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-JavaScript",children:"class Emitter {\n  constructor() {\n    this.events = {}; // Store event name and their corresponding callbacks\n  }\n\n  // Subscribe to an event with a callback\n  subscribe(eventName, callback) {\n    if (!this.events[eventName]) {\n      this.events[eventName] = []; // If no callbacks for this event, initialize an array\n    }\n\n    // Add the callback to the event's array of listeners\n    this.events[eventName].push(callback);\n\n    // Return an object that allows unsubscribing\n    return {\n      release: () => {\n        this.events[eventName] = this.events[eventName].filter(\n          (cb) => cb !== callback\n        );\n      },\n    };\n  }\n\n  // Emit an event, calling all the callbacks with the passed arguments\n  emit(eventName, ...args) {\n    if (this.events[eventName]) {\n      this.events[eventName].forEach((callback) => {\n        callback(...args); // Call each subscribed callback with the arguments\n      });\n    }\n  }\n}\n\n// Example usage:\nconst emitter = new Emitter();\n\n// Subscribing to events\nconst callback1 = (a, b) => console.log('callback1', a, b);\nconst callback2 = (a, b) => console.log('callback2', a, b);\n\nconst sub1 = emitter.subscribe('event1', callback1);\nconst sub2 = emitter.subscribe('event2', callback2);\nconst sub3 = emitter.subscribe('event1', callback1); // Same callback1 again for event1\n\n// Emitting events\nemitter.emit('event1', 1, 2);  // callback1 will be called twice\nemitter.emit('event2', 3, 4);  // callback2 will be called once\n\n// Unsubscribing\nsub1.release(); // Unsubscribe callback1 from event1\nsub3.release(); // Unsubscribe callback1 from event1 again\n\n// Emitting event1 again (callback1 should not be called anymore)\nemitter.emit('event1', 5, 6);  // callback1 will not be called anymore\n/*\ncallback1 1 2\ncallback1 1 2\ncallback2 3 4\n */\n"})})]})}function m(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(b,{...e})}):b(e)}}}]);