"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[3770],{3387:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>a,contentTitle:()=>o,default:()=>c,frontMatter:()=>s,metadata:()=>l,toc:()=>h});var n=i(4848),r=i(8453);const s={title:"Floyd-Warshall Algorithm"},o=void 0,l={id:"DSA/Floyd-Warshall",title:"Floyd-Warshall Algorithm",description:"Floyd-Warshall algorithm is a classic algorithm for finding the shortest paths in a weighted graph with positive or negative edge weights (but no negative cycles). It can be used to find the shortest paths between all pairs of vertices in a graph.",source:"@site/docs/DSA/Floyd-Warshall.mdx",sourceDirName:"DSA",slug:"/DSA/Floyd-Warshall",permalink:"/js.enigma/docs/DSA/Floyd-Warshall",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/Floyd-Warshall.mdx",tags:[],version:"current",frontMatter:{title:"Floyd-Warshall Algorithm"},sidebar:"tutorialSidebar",previous:{title:"Flood Fill Algorithm",permalink:"/js.enigma/docs/DSA/FloodFill"},next:{title:"Floyd's Cycle Detection Algorithm",permalink:"/js.enigma/docs/DSA/FlyodsCycleDetection"}},a={},h=[{value:"Algorithm Overview",id:"algorithm-overview",level:3},{value:"Steps of the Algorithm",id:"steps-of-the-algorithm",level:3}];function d(e){const t={code:"code",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.p,{children:"Floyd-Warshall algorithm is a classic algorithm for finding the shortest paths in a weighted graph with positive or negative edge weights (but no negative cycles). It can be used to find the shortest paths between all pairs of vertices in a graph."}),"\n",(0,n.jsx)(t.h3,{id:"algorithm-overview",children:"Algorithm Overview"}),"\n",(0,n.jsx)(t.p,{children:"The algorithm works by considering all pairs of vertices and systematically trying all possible paths between each pair to find the shortest path. It does this using dynamic programming."}),"\n",(0,n.jsx)(t.h3,{id:"steps-of-the-algorithm",children:"Steps of the Algorithm"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:["Initialization: Create a distance matrix dist, where dist[i][j] represents the shortest distance from vertex i to vertex j. Initialize this matrix as follows:","\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["Set ",(0,n.jsx)(t.code,{children:"dist[i][j] = 0"})," if ",(0,n.jsx)(t.code,{children:"i == j"})]}),"\n",(0,n.jsxs)(t.li,{children:["Set ",(0,n.jsx)(t.code,{children:"dist[i][j] = weight of edge (i, j)"})," if there is an edge from ",(0,n.jsx)(t.code,{children:"i"})," to ",(0,n.jsx)(t.code,{children:"j"}),"."]}),"\n",(0,n.jsxs)(t.li,{children:["Set ",(0,n.jsx)(t.code,{children:"dist[i][j] = \u221e (infinity)"})," if there is no edge from ",(0,n.jsx)(t.code,{children:"i"})," to ",(0,n.jsx)(t.code,{children:"j"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-JavaScript",children:"/**\r\n * Floyd-Warshall Algorithm to find the shortest paths between all pairs of nodes.\r\n * @param {number[][]} graph - Adjacency matrix representing the graph.\r\n * @return {number[][]} - Distance matrix with the shortest paths.\r\n */\r\nfunction floydWarshall(graph) {\r\n  const V = graph.length;\r\n  const distance = Array.from({ length: V }, (_, i) => Array.from(graph[i]));\r\n\r\n  // Initialize distances based on input graph\r\n  for (let k = 0; k < V; k++) {\r\n    for (let i = 0; i < V; i++) {\r\n      for (let j = 0; j < V; j++) {\r\n        if (distance[i][k] !== Infinity && distance[k][j] !== Infinity) {\r\n          distance[i][j] = Math.min(distance[i][j], distance[i][k] + distance[k][j]);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return distance;\r\n}\r\n\r\n// Example usage:\r\nconst graph = [\r\n  [0, 3, Infinity, Infinity],\r\n  [2, 0, Infinity, 1],\r\n  [Infinity, 7, 0, 2],\r\n  [6, Infinity, 3, 0]\r\n];\r\n\r\nconst shortestPaths = floydWarshall(graph);\r\nconsole.log(shortestPaths); //[ [ 0, 3, 7, 4 ], [ 2, 0, 4, 1 ], [ 8, 7, 0, 2 ], [ 6, 9, 3, 0 ] ]\r\n\r\n/* \r\nTime Complexity: O(V^3)\r\nSpace Complexity: O(V^2)\r\n*/\n"})})]})}function c(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},8453:(e,t,i)=>{i.d(t,{R:()=>o,x:()=>l});var n=i(6540);const r={},s=n.createContext(r);function o(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);