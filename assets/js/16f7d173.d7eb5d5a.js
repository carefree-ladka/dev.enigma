"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[9080],{3815:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>m,frontMatter:()=>s,metadata:()=>l,toc:()=>c});var r=t(4848),i=t(8453);const s={title:"Heap\u2019s Algorithm"},a="Heap\u2019s Algorithm",l={id:"DSA/HeapAlgorithm",title:"Heap\u2019s Algorithm",description:"Heap\u2019s Algorithm is a classic algorithm used to generate all possible permutations of a finite sequence. It is particularly efficient for generating permutations and is widely used in combinatorial algorithms.",source:"@site/docs/DSA/HeapAlgorithm.mdx",sourceDirName:"DSA",slug:"/DSA/HeapAlgorithm",permalink:"/js.enigma/docs/DSA/HeapAlgorithm",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/HeapAlgorithm.mdx",tags:[],version:"current",frontMatter:{title:"Heap\u2019s Algorithm"},sidebar:"tutorialSidebar",previous:{title:"Bipartite Graphs",permalink:"/js.enigma/docs/DSA/GraphBipartile"},next:{title:"Interval Problems",permalink:"/js.enigma/docs/DSA/Intervals"}},o={},c=[{value:"Overview",id:"overview",level:2},{value:"Algorithm Steps",id:"algorithm-steps",level:2},{value:"Time Complexity",id:"time-complexity",level:2},{value:"JavaScript Implementation",id:"javascript-implementation",level:2}];function h(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"heaps-algorithm",children:"Heap\u2019s Algorithm"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Heap\u2019s Algorithm"})," is a classic algorithm used to generate all possible permutations of a finite sequence. It is particularly efficient for generating permutations and is widely used in combinatorial algorithms."]}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(n.p,{children:"Heap\u2019s Algorithm generates permutations by recursively swapping elements in the sequence. It is based on the idea of generating permutations by fixing the first element and recursively permuting the remaining elements."}),"\n",(0,r.jsx)(n.h2,{id:"algorithm-steps",children:"Algorithm Steps"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Initialization"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Start with a sequence of n elements."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Recursion"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"If n = 1, output the permutation (base case)."}),"\n",(0,r.jsx)(n.li,{children:"Otherwise, for each element, swap it with the first element and recursively generate permutations of the remaining elements."}),"\n",(0,r.jsx)(n.li,{children:"Restore the sequence by swapping back to maintain the original order."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Termination"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The recursion terminates when all permutations have been generated."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"time-complexity",children:"Time Complexity"}),"\n",(0,r.jsx)(n.p,{children:"The time complexity of Heap\u2019s Algorithm is O(n!), where n is the number of elements. This is because the algorithm generates all possible permutations of the sequence."}),"\n",(0,r.jsx)(n.h2,{id:"javascript-implementation",children:"JavaScript Implementation"}),"\n",(0,r.jsx)(n.p,{children:"Here is a JavaScript implementation of Heap\u2019s Algorithm for generating permutations:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function heapsAlgorithm(n, array, result = []) {\r\n  if (n === 1) {\r\n    result.push(array.slice()); // Add a copy of the permutation\r\n    return;\r\n  }\r\n\r\n  for (let i = 0; i < n - 1; i++) {\r\n    heapsAlgorithm(n - 1, array, result);\r\n    \r\n    // Swap the elements based on the parity of n\r\n    const j = n % 2 === 0 ? i : 0;\r\n    [array[j], array[n - 1]] = [array[n - 1], array[j]];\r\n  }\r\n\r\n  // Generate permutations for the last element\r\n  heapsAlgorithm(n - 1, array, result);\r\n}\r\n\r\n// Example usage\r\nconst array = [1, 2, 3];\r\nconst result = [];\r\nheapsAlgorithm(array.length, array, result);\r\nconsole.log(result); \r\n// Output: [ [ 1, 2, 3 ], [ 2, 1, 3 ], [ 3, 1, 2 ], [ 1, 3, 2 ], [ 2, 3, 1 ], [ 3, 2, 1 ] ]\n"})})]})}function m(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>l});var r=t(6540);const i={},s=r.createContext(i);function a(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);