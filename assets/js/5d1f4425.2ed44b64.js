"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[8502],{1481:e=>{e.exports=JSON.parse('{"version":{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"tutorialSidebar":[{"type":"link","label":"JSEnigma | Learn & Practice","href":"/js.enigma/docs/intro","docId":"intro","unlisted":false},{"type":"category","label":"Web Development","collapsible":true,"collapsed":true,"items":[{"type":"category","label":"JavaScript Core","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"CSS3 Interview Questions","href":"/js.enigma/docs/tutorial-extras/Core JavaScript/CSS","docId":"tutorial-extras/Core JavaScript/CSS","unlisted":false},{"type":"link","label":"Frontend System Design","href":"/js.enigma/docs/tutorial-extras/Core JavaScript/FrontendSystemDesign","docId":"tutorial-extras/Core JavaScript/FrontendSystemDesign","unlisted":false},{"type":"link","label":"HTML5 Interview Questions","href":"/js.enigma/docs/tutorial-extras/Core JavaScript/HTML","docId":"tutorial-extras/Core JavaScript/HTML","unlisted":false},{"type":"link","label":"JavaScript Interview Questions","href":"/js.enigma/docs/tutorial-extras/Core JavaScript/JS","docId":"tutorial-extras/Core JavaScript/JS","unlisted":false},{"type":"link","label":"React Interview Questions","href":"/js.enigma/docs/tutorial-extras/Core JavaScript/React","docId":"tutorial-extras/Core JavaScript/React","unlisted":false}],"href":"/js.enigma/docs/category/javascript-core"},{"type":"category","label":"HTML5","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Critical Rendering Path","href":"/js.enigma/docs/tutorial-extras/HTML5/CriticalRenderingPath","docId":"tutorial-extras/HTML5/CriticalRenderingPath","unlisted":false},{"type":"link","label":"Rendering / Render Tree","href":"/js.enigma/docs/tutorial-extras/HTML5/RenderingTree","docId":"tutorial-extras/HTML5/RenderingTree","unlisted":false},{"type":"link","label":"Shadow DOM","href":"/js.enigma/docs/tutorial-extras/HTML5/ShadowDOM","docId":"tutorial-extras/HTML5/ShadowDOM","unlisted":false}]},{"type":"category","label":"JSInterviewQuestions","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Closures","href":"/js.enigma/docs/tutorial-extras/JSInterviewQuestions/Closure","docId":"tutorial-extras/JSInterviewQuestions/Closure","unlisted":false},{"type":"link","label":"Currying Variations","href":"/js.enigma/docs/tutorial-extras/JSInterviewQuestions/Currying","docId":"tutorial-extras/JSInterviewQuestions/Currying","unlisted":false},{"type":"link","label":"Design Patterns","href":"/js.enigma/docs/tutorial-extras/JSInterviewQuestions/DesignPatterns","docId":"tutorial-extras/JSInterviewQuestions/DesignPatterns","unlisted":false},{"type":"link","label":"Event Loop","href":"/js.enigma/docs/tutorial-extras/JSInterviewQuestions/EventLoop","docId":"tutorial-extras/JSInterviewQuestions/EventLoop","unlisted":false},{"type":"link","label":"Function Methods Polyfill","href":"/js.enigma/docs/tutorial-extras/JSInterviewQuestions/FunctionsPolyfill","docId":"tutorial-extras/JSInterviewQuestions/FunctionsPolyfill","unlisted":false},{"type":"link","label":"Canceling an API Call","href":"/js.enigma/docs/tutorial-extras/JSInterviewQuestions/HowToCancelAPICalls","docId":"tutorial-extras/JSInterviewQuestions/HowToCancelAPICalls","unlisted":false},{"type":"link","label":"Memoization","href":"/js.enigma/docs/tutorial-extras/JSInterviewQuestions/Memoization","docId":"tutorial-extras/JSInterviewQuestions/Memoization","unlisted":false},{"type":"link","label":"Miscellaneous","href":"/js.enigma/docs/tutorial-extras/JSInterviewQuestions/Misx","docId":"tutorial-extras/JSInterviewQuestions/Misx","unlisted":false},{"type":"link","label":"Object Related Problems","href":"/js.enigma/docs/tutorial-extras/JSInterviewQuestions/Objects","docId":"tutorial-extras/JSInterviewQuestions/Objects","unlisted":false},{"type":"link","label":"Array Methods Polyfills","href":"/js.enigma/docs/tutorial-extras/JSInterviewQuestions/Polyfills","docId":"tutorial-extras/JSInterviewQuestions/Polyfills","unlisted":false},{"type":"link","label":"Promise Based Outputs","href":"/js.enigma/docs/tutorial-extras/JSInterviewQuestions/PromiseBased","docId":"tutorial-extras/JSInterviewQuestions/PromiseBased","unlisted":false},{"type":"link","label":"Promise Polyfills","href":"/js.enigma/docs/tutorial-extras/JSInterviewQuestions/PromisePolyfills","docId":"tutorial-extras/JSInterviewQuestions/PromisePolyfills","unlisted":false},{"type":"link","label":"Prototypal Inheritance","href":"/js.enigma/docs/tutorial-extras/JSInterviewQuestions/PrototypalInheritance","docId":"tutorial-extras/JSInterviewQuestions/PrototypalInheritance","unlisted":false}]},{"type":"category","label":"ReactQuestions","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Error Boundary","href":"/js.enigma/docs/tutorial-extras/ReactQuestions/ErrorBoundary","docId":"tutorial-extras/ReactQuestions/ErrorBoundary","unlisted":false},{"type":"link","label":"React Lifecycle Methods","href":"/js.enigma/docs/tutorial-extras/ReactQuestions/LifeCycleMethods","docId":"tutorial-extras/ReactQuestions/LifeCycleMethods","unlisted":false},{"type":"link","label":"React TypeScript Context","href":"/js.enigma/docs/tutorial-extras/ReactQuestions/ReactTypeScriptContext","docId":"tutorial-extras/ReactQuestions/ReactTypeScriptContext","unlisted":false},{"type":"link","label":"Redux vs Context API","href":"/js.enigma/docs/tutorial-extras/ReactQuestions/ReduxVSContext","docId":"tutorial-extras/ReactQuestions/ReduxVSContext","unlisted":false},{"type":"link","label":"Redux vs Redux-Saga","href":"/js.enigma/docs/tutorial-extras/ReactQuestions/ReduxVSRedux-Saga","docId":"tutorial-extras/ReactQuestions/ReduxVSRedux-Saga","unlisted":false},{"type":"link","label":"Rendering Strategies Types","href":"/js.enigma/docs/tutorial-extras/ReactQuestions/RenderingTypes","docId":"tutorial-extras/ReactQuestions/RenderingTypes","unlisted":false}]},{"type":"category","label":"WebBits","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Web Accessibility","href":"/js.enigma/docs/tutorial-extras/WebBits/WebAccessibility","docId":"tutorial-extras/WebBits/WebAccessibility","unlisted":false},{"type":"link","label":"Web Performance","href":"/js.enigma/docs/tutorial-extras/WebBits/WebPerformance","docId":"tutorial-extras/WebBits/WebPerformance","unlisted":false},{"type":"link","label":"Web Security","href":"/js.enigma/docs/tutorial-extras/WebBits/WebSecurity","docId":"tutorial-extras/WebBits/WebSecurity","unlisted":false}]}],"href":"/js.enigma/docs/category/web-development"},{"type":"category","label":"Data Structures & Algorithms Patterns","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"0-1 BFS Algorithm","href":"/js.enigma/docs/tutorial-basics/01BFS","docId":"tutorial-basics/01BFS","unlisted":false},{"type":"link","label":"2D Matrix Graph Algorithms","href":"/js.enigma/docs/tutorial-basics/2DGraphAlgorithms","docId":"tutorial-basics/2DGraphAlgorithms","unlisted":false},{"type":"link","label":"Breadth-First Search (BFS) for Trees","href":"/js.enigma/docs/tutorial-basics/BFSTree","docId":"tutorial-basics/BFSTree","unlisted":false},{"type":"link","label":"Backtracking Algorithm","href":"/js.enigma/docs/tutorial-basics/Backtracking","docId":"tutorial-basics/Backtracking","unlisted":false},{"type":"link","label":"Binary Heap","href":"/js.enigma/docs/tutorial-basics/BinaryHeap","docId":"tutorial-basics/BinaryHeap","unlisted":false},{"type":"link","label":"Binary Search and Its Variants","href":"/js.enigma/docs/tutorial-basics/BinarySearch","docId":"tutorial-basics/BinarySearch","unlisted":false},{"type":"link","label":"Binary Search Tree","href":"/js.enigma/docs/tutorial-basics/BinarySearchTree","docId":"tutorial-basics/BinarySearchTree","unlisted":false},{"type":"link","label":"Bit Manipulation Basics","href":"/js.enigma/docs/tutorial-basics/BitManipulation","docId":"tutorial-basics/BitManipulation","unlisted":false},{"type":"link","label":"Boyer\u2013Moore Majority Vote Algorithm","href":"/js.enigma/docs/tutorial-basics/BoyerMoore","docId":"tutorial-basics/BoyerMoore","unlisted":false},{"type":"link","label":"Bucket Sort","href":"/js.enigma/docs/tutorial-basics/BucketSort","docId":"tutorial-basics/BucketSort","unlisted":false},{"type":"link","label":"Counting Sort","href":"/js.enigma/docs/tutorial-basics/CountingSort","docId":"tutorial-basics/CountingSort","unlisted":false},{"type":"link","label":"Cycle Detection in Graphs","href":"/js.enigma/docs/tutorial-basics/CycleDetectionGraph","docId":"tutorial-basics/CycleDetectionGraph","unlisted":false},{"type":"link","label":"Cyclic Sort Algorithm","href":"/js.enigma/docs/tutorial-basics/CyclicSort","docId":"tutorial-basics/CyclicSort","unlisted":false},{"type":"link","label":"DFS & BFS on Graphs","href":"/js.enigma/docs/tutorial-basics/DFSBFSGraph","docId":"tutorial-basics/DFSBFSGraph","unlisted":false},{"type":"link","label":"Depth-First Search (DFS) for Trees","href":"/js.enigma/docs/tutorial-basics/DFSTree","docId":"tutorial-basics/DFSTree","unlisted":false},{"type":"link","label":"Dequeue","href":"/js.enigma/docs/tutorial-basics/Dequeue","docId":"tutorial-basics/Dequeue","unlisted":false},{"type":"link","label":"Dijkstra\'s Algorithm","href":"/js.enigma/docs/tutorial-basics/Dijkstra","docId":"tutorial-basics/Dijkstra","unlisted":false},{"type":"link","label":"Euclidean and Manhattan Distance","href":"/js.enigma/docs/tutorial-basics/DistancesFormula","docId":"tutorial-basics/DistancesFormula","unlisted":false},{"type":"link","label":"Dutch National Flag Algorithm","href":"/js.enigma/docs/tutorial-basics/DutchNationalFlag","docId":"tutorial-basics/DutchNationalFlag","unlisted":false},{"type":"link","label":"Dynamic Programming","href":"/js.enigma/docs/tutorial-basics/DynamicProgramming","docId":"tutorial-basics/DynamicProgramming","unlisted":false},{"type":"link","label":"Euclid\'s Algorithm for Greatest Common Divisor (GCD)","href":"/js.enigma/docs/tutorial-basics/Euclid","docId":"tutorial-basics/Euclid","unlisted":false},{"type":"link","label":"Fenwick Tree Tutorial","href":"/js.enigma/docs/tutorial-basics/Fenwick","docId":"tutorial-basics/Fenwick","unlisted":false},{"type":"link","label":"Fisher-Yates Shuffle Algorithm","href":"/js.enigma/docs/tutorial-basics/FisherYates","docId":"tutorial-basics/FisherYates","unlisted":false},{"type":"link","label":"Flood Fill Algorithm","href":"/js.enigma/docs/tutorial-basics/FloodFill","docId":"tutorial-basics/FloodFill","unlisted":false},{"type":"link","label":"Floyd-Warshall Algorithm","href":"/js.enigma/docs/tutorial-basics/Floyd-Warshall","docId":"tutorial-basics/Floyd-Warshall","unlisted":false},{"type":"link","label":"Floyd\'s Cycle Detection Algorithm","href":"/js.enigma/docs/tutorial-basics/FlyodsCycleDetection","docId":"tutorial-basics/FlyodsCycleDetection","unlisted":false},{"type":"link","label":"Frequency Counter Technique","href":"/js.enigma/docs/tutorial-basics/FrequencyCounter","docId":"tutorial-basics/FrequencyCounter","unlisted":false},{"type":"link","label":"Heap\u2019s Algorithm","href":"/js.enigma/docs/tutorial-basics/HeapAlgorithm","docId":"tutorial-basics/HeapAlgorithm","unlisted":false},{"type":"link","label":"Interval Problems","href":"/js.enigma/docs/tutorial-basics/Intervals","docId":"tutorial-basics/Intervals","unlisted":false},{"type":"link","label":"Knuth-Morris-Pratt (KMP) Algorithm","href":"/js.enigma/docs/tutorial-basics/KMPAlgo","docId":"tutorial-basics/KMPAlgo","unlisted":false},{"type":"link","label":"K-Way Merge Pattern","href":"/js.enigma/docs/tutorial-basics/KWayMerge","docId":"tutorial-basics/KWayMerge","unlisted":false},{"type":"link","label":"Kadane\'s Algorithm Tutorial","href":"/js.enigma/docs/tutorial-basics/Kadane","docId":"tutorial-basics/Kadane","unlisted":false},{"type":"link","label":"LRU Cache Design","href":"/js.enigma/docs/tutorial-basics/LRUcache","docId":"tutorial-basics/LRUcache","unlisted":false},{"type":"link","label":"Line Sweep Algorithm","href":"/js.enigma/docs/tutorial-basics/LineSweep","docId":"tutorial-basics/LineSweep","unlisted":false},{"type":"link","label":"Merge Sort","href":"/js.enigma/docs/tutorial-basics/MergeSort","docId":"tutorial-basics/MergeSort","unlisted":false},{"type":"link","label":"Morris Traversal for Binary Trees","href":"/js.enigma/docs/tutorial-basics/MorrisTraversal","docId":"tutorial-basics/MorrisTraversal","unlisted":false},{"type":"link","label":"Multi-source BFS Algorithm","href":"/js.enigma/docs/tutorial-basics/MultiSourceBFS","docId":"tutorial-basics/MultiSourceBFS","unlisted":false},{"type":"link","label":"N-ary Tree","href":"/js.enigma/docs/tutorial-basics/NryTree","docId":"tutorial-basics/NryTree","unlisted":false},{"type":"link","label":"Number of Islands Pattern","href":"/js.enigma/docs/tutorial-basics/NumberOfIsland","docId":"tutorial-basics/NumberOfIsland","unlisted":false},{"type":"link","label":"Parenthesis Pattern","href":"/js.enigma/docs/tutorial-basics/Parentheses","docId":"tutorial-basics/Parentheses","unlisted":false},{"type":"link","label":"Path Sum (Binary Tree)","href":"/js.enigma/docs/tutorial-basics/PathSumBinaryTree","docId":"tutorial-basics/PathSumBinaryTree","unlisted":false},{"type":"link","label":"Prefix Sum","href":"/js.enigma/docs/tutorial-basics/PrefixSum","docId":"tutorial-basics/PrefixSum","unlisted":false},{"type":"link","label":"Queue","href":"/js.enigma/docs/tutorial-basics/Queue","docId":"tutorial-basics/Queue","unlisted":false},{"type":"link","label":"Quick Select Algorithm","href":"/js.enigma/docs/tutorial-basics/QuickSelect","docId":"tutorial-basics/QuickSelect","unlisted":false},{"type":"link","label":"Quick Sort","href":"/js.enigma/docs/tutorial-basics/QuickSort","docId":"tutorial-basics/QuickSort","unlisted":false},{"type":"link","label":"Reservoir Sampling","href":"/js.enigma/docs/tutorial-basics/ReservoirSampling","docId":"tutorial-basics/ReservoirSampling","unlisted":false},{"type":"link","label":"In-Place Reversal of a Linked List","href":"/js.enigma/docs/tutorial-basics/ReverseLinkedList","docId":"tutorial-basics/ReverseLinkedList","unlisted":false},{"type":"link","label":"Segment Tree Tutorial","href":"/js.enigma/docs/tutorial-basics/SegmentTree","docId":"tutorial-basics/SegmentTree","unlisted":false},{"type":"link","label":"Sieve of Eratosthenes","href":"/js.enigma/docs/tutorial-basics/SieveOfEratosthenes","docId":"tutorial-basics/SieveOfEratosthenes","unlisted":false},{"type":"link","label":"Sliding Window Technique","href":"/js.enigma/docs/tutorial-basics/SlidingWindow","docId":"tutorial-basics/SlidingWindow","unlisted":false},{"type":"link","label":"Fast and Slow Pointers Technique","href":"/js.enigma/docs/tutorial-basics/SlowFastPointer","docId":"tutorial-basics/SlowFastPointer","unlisted":false},{"type":"link","label":"Stack","href":"/js.enigma/docs/tutorial-basics/Stack","docId":"tutorial-basics/Stack","unlisted":false},{"type":"link","label":"Topological Sort Tutorial","href":"/js.enigma/docs/tutorial-basics/TopologicalSort","docId":"tutorial-basics/TopologicalSort","unlisted":false},{"type":"link","label":"Trie Data Structure","href":"/js.enigma/docs/tutorial-basics/Trie","docId":"tutorial-basics/Trie","unlisted":false},{"type":"link","label":"Two Pointers Technique","href":"/js.enigma/docs/tutorial-basics/TwoPointers","docId":"tutorial-basics/TwoPointers","unlisted":false},{"type":"link","label":"Union-Find (Disjoint Set Union) Tutorial","href":"/js.enigma/docs/tutorial-basics/UnionFind","docId":"tutorial-basics/UnionFind","unlisted":false}],"href":"/js.enigma/docs/category/data-structures--algorithms-patterns"},{"type":"category","label":"Tips & Tricks","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Tips & Tricks","href":"/js.enigma/docs/Tips & Tricks/TipsAndTricks","docId":"Tips & Tricks/TipsAndTricks","unlisted":false}],"href":"/js.enigma/docs/category/tips--tricks"}]},"docs":{"intro":{"id":"intro","title":"JSEnigma | Learn & Practice","description":"The purpose of this application is to help you revise coding patterns and problems efficiently for last-minute preparation.","sidebar":"tutorialSidebar"},"Tips & Tricks/TipsAndTricks":{"id":"Tips & Tricks/TipsAndTricks","title":"Tips & Tricks","description":"Creating Visited Array for 2D Matrix Graph Problems on LC","sidebar":"tutorialSidebar"},"tutorial-basics/01BFS":{"id":"tutorial-basics/01BFS","title":"0-1 BFS Algorithm","description":"0-1 BFS Algorithm","sidebar":"tutorialSidebar"},"tutorial-basics/2DGraphAlgorithms":{"id":"tutorial-basics/2DGraphAlgorithms","title":"2D Matrix Graph Algorithms","description":"A comprehensive guide to 2D DFS, 2D BFS, and 2D Dijkstra algorithms with code examples in JavaScript.","sidebar":"tutorialSidebar"},"tutorial-basics/Backtracking":{"id":"tutorial-basics/Backtracking","title":"Backtracking Algorithm","description":"Backtracking Algorithm","sidebar":"tutorialSidebar"},"tutorial-basics/BFSTree":{"id":"tutorial-basics/BFSTree","title":"Breadth-First Search (BFS) for Trees","description":"Breadth-First Search (BFS) for Trees","sidebar":"tutorialSidebar"},"tutorial-basics/BinaryHeap":{"id":"tutorial-basics/BinaryHeap","title":"Binary Heap","description":"A Binary Heap is a complete binary tree that satisfies the heap property. It is a data structure commonly used to implement priority queues. There are two main types of binary heaps: the min-heap and the max-heap.","sidebar":"tutorialSidebar"},"tutorial-basics/BinarySearch":{"id":"tutorial-basics/BinarySearch","title":"Binary Search and Its Variants","description":"Binary Search","sidebar":"tutorialSidebar"},"tutorial-basics/BinarySearchTree":{"id":"tutorial-basics/BinarySearchTree","title":"Binary Search Tree","description":"Binary Search Tree (BST)","sidebar":"tutorialSidebar"},"tutorial-basics/BitManipulation":{"id":"tutorial-basics/BitManipulation","title":"Bit Manipulation Basics","description":"Bit Manipulation Basics","sidebar":"tutorialSidebar"},"tutorial-basics/BoyerMoore":{"id":"tutorial-basics/BoyerMoore","title":"Boyer\u2013Moore Majority Vote Algorithm","description":"Boyer\u2013Moore Majority Vote Algorithm","sidebar":"tutorialSidebar"},"tutorial-basics/BucketSort":{"id":"tutorial-basics/BucketSort","title":"Bucket Sort","description":"A detailed guide to understanding and implementing Bucket Sort.","sidebar":"tutorialSidebar"},"tutorial-basics/CountingSort":{"id":"tutorial-basics/CountingSort","title":"Counting Sort","description":"A detailed guide to understanding and implementing Counting Sort.","sidebar":"tutorialSidebar"},"tutorial-basics/CycleDetectionGraph":{"id":"tutorial-basics/CycleDetectionGraph","title":"Cycle Detection in Graphs","description":"Cycle detection is an essential aspect of graph theory, used to identify whether a graph contains cycles. This document outlines methods for detecting cycles in both directed and undirected graphs.","sidebar":"tutorialSidebar"},"tutorial-basics/CyclicSort":{"id":"tutorial-basics/CyclicSort","title":"Cyclic Sort Algorithm","description":"Cyclic Sort is an efficient algorithm for solving problems involving numbers that are in a range from 1 to n or 0 to n. The key idea is to place each number at its correct index.","sidebar":"tutorialSidebar"},"tutorial-basics/Dequeue":{"id":"tutorial-basics/Dequeue","title":"Dequeue","description":"A Deque (Double-Ended Queue) is a data structure that allows insertion and deletion of elements from both ends.","sidebar":"tutorialSidebar"},"tutorial-basics/DFSBFSGraph":{"id":"tutorial-basics/DFSBFSGraph","title":"DFS & BFS on Graphs","description":"A comprehensive guide to implementing Depth-First Search (DFS) & BFS (Breadth-First Search) on graphs.","sidebar":"tutorialSidebar"},"tutorial-basics/DFSTree":{"id":"tutorial-basics/DFSTree","title":"Depth-First Search (DFS) for Trees","description":"Depth-First Search (DFS) for Trees","sidebar":"tutorialSidebar"},"tutorial-basics/Dijkstra":{"id":"tutorial-basics/Dijkstra","title":"Dijkstra\'s Algorithm","description":"Dijkstra\'s Algorithm","sidebar":"tutorialSidebar"},"tutorial-basics/DistancesFormula":{"id":"tutorial-basics/DistancesFormula","title":"Euclidean and Manhattan Distance","description":"Euclidean Distance","sidebar":"tutorialSidebar"},"tutorial-basics/DutchNationalFlag":{"id":"tutorial-basics/DutchNationalFlag","title":"Dutch National Flag Algorithm","description":"Dutch National Flag Algorithm","sidebar":"tutorialSidebar"},"tutorial-basics/DynamicProgramming":{"id":"tutorial-basics/DynamicProgramming","title":"Dynamic Programming","description":"Dynamic Programming (DP) is a technique used for solving complex problems by breaking them down into simpler overlapping subproblems. It involves storing the results of these subproblems to avoid redundant computations. There are two main approaches to implementing DP: Top-Down and Bottom-Up.","sidebar":"tutorialSidebar"},"tutorial-basics/Euclid":{"id":"tutorial-basics/Euclid","title":"Euclid\'s Algorithm for Greatest Common Divisor (GCD)","description":"Euclid\'s Algorithm for Greatest Common Divisor (GCD)","sidebar":"tutorialSidebar"},"tutorial-basics/Fenwick":{"id":"tutorial-basics/Fenwick","title":"Fenwick Tree Tutorial","description":"A comprehensive guide to Fenwick Trees with code examples in JavaScript.","sidebar":"tutorialSidebar"},"tutorial-basics/FisherYates":{"id":"tutorial-basics/FisherYates","title":"Fisher-Yates Shuffle Algorithm","description":"The Fisher-Yates Shuffle algorithm is an efficient method for randomly shuffling a finite sequence of items. It ensures that each permutation of the sequence is equally likely.","sidebar":"tutorialSidebar"},"tutorial-basics/FloodFill":{"id":"tutorial-basics/FloodFill","title":"Flood Fill Algorithm","description":"Flood Fill Algorithm","sidebar":"tutorialSidebar"},"tutorial-basics/Floyd-Warshall":{"id":"tutorial-basics/Floyd-Warshall","title":"Floyd-Warshall Algorithm","description":"Floyd-Warshall algorithm is a classic algorithm for finding the shortest paths in a weighted graph with positive or negative edge weights (but no negative cycles). It can be used to find the shortest paths between all pairs of vertices in a graph.","sidebar":"tutorialSidebar"},"tutorial-basics/FlyodsCycleDetection":{"id":"tutorial-basics/FlyodsCycleDetection","title":"Floyd\'s Cycle Detection Algorithm","description":"Floyd\'s Cycle Detection Algorithm","sidebar":"tutorialSidebar"},"tutorial-basics/FrequencyCounter":{"id":"tutorial-basics/FrequencyCounter","title":"Frequency Counter Technique","description":"Frequency Counter Technique","sidebar":"tutorialSidebar"},"tutorial-basics/HeapAlgorithm":{"id":"tutorial-basics/HeapAlgorithm","title":"Heap\u2019s Algorithm","description":"Heap\u2019s Algorithm is a classic algorithm used to generate all possible permutations of a finite sequence. It is particularly efficient for generating permutations and is widely used in combinatorial algorithms.","sidebar":"tutorialSidebar"},"tutorial-basics/Intervals":{"id":"tutorial-basics/Intervals","title":"Interval Problems","description":"Interval Problems","sidebar":"tutorialSidebar"},"tutorial-basics/Kadane":{"id":"tutorial-basics/Kadane","title":"Kadane\'s Algorithm Tutorial","description":"A comprehensive guide to Kadane\'s Algorithm with code examples in JavaScript.","sidebar":"tutorialSidebar"},"tutorial-basics/KMPAlgo":{"id":"tutorial-basics/KMPAlgo","title":"Knuth-Morris-Pratt (KMP) Algorithm","description":"Brute-Force String Matching","sidebar":"tutorialSidebar"},"tutorial-basics/KWayMerge":{"id":"tutorial-basics/KWayMerge","title":"K-Way Merge Pattern","description":"The k-way merge pattern is a technique used to merge k sorted arrays (or linked lists) into a single sorted array. It\'s commonly used in problems like merging multiple sorted arrays, finding the smallest range covering elements from k lists, and more.","sidebar":"tutorialSidebar"},"tutorial-basics/LineSweep":{"id":"tutorial-basics/LineSweep","title":"Line Sweep Algorithm","description":"The Line Sweep algorithm is a computational geometry technique used to solve various problems involving intervals or segments. The basic idea is to \\"sweep\\" a line across the plane and process events as the line intersects with points of interest (typically the endpoints of segments).","sidebar":"tutorialSidebar"},"tutorial-basics/LRUcache":{"id":"tutorial-basics/LRUcache","title":"LRU Cache Design","description":"An LRU (Least Recently Used) Cache is a data structure that stores a limited number of items and automatically removes the least recently used item when the cache reaches its capacity. It\'s commonly used in scenarios where you need to manage memory by caching results of expensive operations.","sidebar":"tutorialSidebar"},"tutorial-basics/MergeSort":{"id":"tutorial-basics/MergeSort","title":"Merge Sort","description":"A comprehensive guide to understanding and implementing Merge Sort.","sidebar":"tutorialSidebar"},"tutorial-basics/MorrisTraversal":{"id":"tutorial-basics/MorrisTraversal","title":"Morris Traversal for Binary Trees","description":"Morris Traversal","sidebar":"tutorialSidebar"},"tutorial-basics/MultiSourceBFS":{"id":"tutorial-basics/MultiSourceBFS","title":"Multi-source BFS Algorithm","description":"Multi-source BFS Algorithm","sidebar":"tutorialSidebar"},"tutorial-basics/NryTree":{"id":"tutorial-basics/NryTree","title":"N-ary Tree","description":"An N-ary Tree is a tree data structure where each node can have up to N children. This is a generalization of a binary tree where each node can have more than two children. N-ary trees are useful in scenarios where a hierarchical structure is required, but nodes can have more than two children.","sidebar":"tutorialSidebar"},"tutorial-basics/NumberOfIsland":{"id":"tutorial-basics/NumberOfIsland","title":"Number of Islands Pattern","description":"The Number of Islands problem is a classic grid-based problem that involves finding the number of distinct islands in a 2D grid. An island is formed by connected groups of 1s (land), and they are surrounded by 0s (water). The land cells can be connected either vertically or horizontally, but not diagonally.","sidebar":"tutorialSidebar"},"tutorial-basics/Parentheses":{"id":"tutorial-basics/Parentheses","title":"Parenthesis Pattern","description":"Below is a list of common parenthesis-related problems.","sidebar":"tutorialSidebar"},"tutorial-basics/PathSumBinaryTree":{"id":"tutorial-basics/PathSumBinaryTree","title":"Path Sum (Binary Tree)","description":"Path Sum (Binary Tree)","sidebar":"tutorialSidebar"},"tutorial-basics/PrefixSum":{"id":"tutorial-basics/PrefixSum","title":"Prefix Sum","description":"A comprehensive guide to understanding and implementing Prefix Sum.","sidebar":"tutorialSidebar"},"tutorial-basics/Queue":{"id":"tutorial-basics/Queue","title":"Queue","description":"A queue is a data structure that follows the First-In-First-Out (FIFO) principle. Elements are added at the rear and removed from the front. Queues are commonly used in scenarios where processing order needs to be maintained.","sidebar":"tutorialSidebar"},"tutorial-basics/QuickSelect":{"id":"tutorial-basics/QuickSelect","title":"Quick Select Algorithm","description":"Quick Select Algorithm","sidebar":"tutorialSidebar"},"tutorial-basics/QuickSort":{"id":"tutorial-basics/QuickSort","title":"Quick Sort","description":"A comprehensive guide to understanding and implementing Quick Sort.","sidebar":"tutorialSidebar"},"tutorial-basics/ReservoirSampling":{"id":"tutorial-basics/ReservoirSampling","title":"Reservoir Sampling","description":"Reservoir Sampling is an algorithm used for randomly selecting a fixed number of items from a stream or a large dataset when the total number of items is not known in advance. It ensures that each item in the stream has an equal probability of being included in the sample.","sidebar":"tutorialSidebar"},"tutorial-basics/ReverseLinkedList":{"id":"tutorial-basics/ReverseLinkedList","title":"In-Place Reversal of a Linked List","description":"In-Place Reversal of a Linked List","sidebar":"tutorialSidebar"},"tutorial-basics/SegmentTree":{"id":"tutorial-basics/SegmentTree","title":"Segment Tree Tutorial","description":"A comprehensive guide to Segment Trees with code examples in JavaScript.","sidebar":"tutorialSidebar"},"tutorial-basics/SieveOfEratosthenes":{"id":"tutorial-basics/SieveOfEratosthenes","title":"Sieve of Eratosthenes","description":"The Sieve of Eratosthenes is an ancient algorithm used to find all prime numbers up to a given limit. It works by iteratively marking the multiples of each prime number starting from 2.","sidebar":"tutorialSidebar"},"tutorial-basics/SlidingWindow":{"id":"tutorial-basics/SlidingWindow","title":"Sliding Window Technique","description":"Sliding Window Technique","sidebar":"tutorialSidebar"},"tutorial-basics/SlowFastPointer":{"id":"tutorial-basics/SlowFastPointer","title":"Fast and Slow Pointers Technique","description":"The Fast and Slow Pointers technique, also known as the Tortoise and Hare algorithm, is a powerful method for solving problems involving linked lists and cyclic structures. It uses two pointers that move at different speeds to detect cycles, find the middle of a list, and solve other related problems efficiently.","sidebar":"tutorialSidebar"},"tutorial-basics/Stack":{"id":"tutorial-basics/Stack","title":"Stack","description":"Introduction","sidebar":"tutorialSidebar"},"tutorial-basics/TopologicalSort":{"id":"tutorial-basics/TopologicalSort","title":"Topological Sort Tutorial","description":"A comprehensive guide to Topological Sort with code examples in JavaScript.","sidebar":"tutorialSidebar"},"tutorial-basics/Trie":{"id":"tutorial-basics/Trie","title":"Trie Data Structure","description":"Trie Data Structure","sidebar":"tutorialSidebar"},"tutorial-basics/TwoPointers":{"id":"tutorial-basics/TwoPointers","title":"Two Pointers Technique","description":"The Two Pointers technique is a popular algorithmic approach used to solve problems involving arrays or lists. It involves using two pointers to traverse the data structure and solve problems efficiently.","sidebar":"tutorialSidebar"},"tutorial-basics/UnionFind":{"id":"tutorial-basics/UnionFind","title":"Union-Find (Disjoint Set Union) Tutorial","description":"A comprehensive guide to Union-Find data structure with code examples in JavaScript.","sidebar":"tutorialSidebar"},"tutorial-extras/Core JavaScript/CSS":{"id":"tutorial-extras/Core JavaScript/CSS","title":"CSS3 Interview Questions","description":"1. Box sizing","sidebar":"tutorialSidebar"},"tutorial-extras/Core JavaScript/FrontendSystemDesign":{"id":"tutorial-extras/Core JavaScript/FrontendSystemDesign","title":"Frontend System Design","description":"1. Requirements Exploration","sidebar":"tutorialSidebar"},"tutorial-extras/Core JavaScript/HTML":{"id":"tutorial-extras/Core JavaScript/HTML","title":"HTML5 Interview Questions","description":"1. What is the use of DOCTYPE. What if we do not use it in our app?","sidebar":"tutorialSidebar"},"tutorial-extras/Core JavaScript/JS":{"id":"tutorial-extras/Core JavaScript/JS","title":"JavaScript Interview Questions","description":"1. Definition","sidebar":"tutorialSidebar"},"tutorial-extras/Core JavaScript/React":{"id":"tutorial-extras/Core JavaScript/React","title":"React Interview Questions","description":"1. What is React and how it is different from Angular and Vue?","sidebar":"tutorialSidebar"},"tutorial-extras/HTML5/CriticalRenderingPath":{"id":"tutorial-extras/HTML5/CriticalRenderingPath","title":"Critical Rendering Path","description":"The Critical Rendering Path (CRP) is the sequence of steps the browser takes to convert HTML, CSS, and JavaScript into pixels on the screen. It represents the flow of the rendering process and impacts how quickly content is displayed to the user. Optimizing the CRP is key to improving website performance and reducing the time it takes to render the first visible part of the page.","sidebar":"tutorialSidebar"},"tutorial-extras/HTML5/RenderingTree":{"id":"tutorial-extras/HTML5/RenderingTree","title":"Rendering / Render Tree","description":"The Rendering Tree (or Render Tree) in web development refers to the internal structure that browsers build to render a webpage on the screen. It is a key part of how the browser\'s rendering engine works. The render tree is created after the browser processes the DOM and CSSOM (CSS Object Model), combining them to produce the visual content of a webpage.","sidebar":"tutorialSidebar"},"tutorial-extras/HTML5/ShadowDOM":{"id":"tutorial-extras/HTML5/ShadowDOM","title":"Shadow DOM","description":"Understanding Shadow DOM","sidebar":"tutorialSidebar"},"tutorial-extras/JSInterviewQuestions/Closure":{"id":"tutorial-extras/JSInterviewQuestions/Closure","title":"Closures","description":"Closures allow functions to retain access to variables from their containing (or outer) function even after that function has finished executing.","sidebar":"tutorialSidebar"},"tutorial-extras/JSInterviewQuestions/Currying":{"id":"tutorial-extras/JSInterviewQuestions/Currying","title":"Currying Variations","description":"Type 1","sidebar":"tutorialSidebar"},"tutorial-extras/JSInterviewQuestions/DesignPatterns":{"id":"tutorial-extras/JSInterviewQuestions/DesignPatterns","title":"Design Patterns","description":"Singleton Pattern","sidebar":"tutorialSidebar"},"tutorial-extras/JSInterviewQuestions/EventLoop":{"id":"tutorial-extras/JSInterviewQuestions/EventLoop","title":"Event Loop","description":"The JavaScript Event Loop is a fundamental concept in understanding how JavaScript handles asynchronous operations. It enables JavaScript to perform non-blocking I/O operations, making it possible to run other code while waiting for operations to complete.","sidebar":"tutorialSidebar"},"tutorial-extras/JSInterviewQuestions/FunctionsPolyfill":{"id":"tutorial-extras/JSInterviewQuestions/FunctionsPolyfill","title":"Function Methods Polyfill","description":"Call Polyfill","sidebar":"tutorialSidebar"},"tutorial-extras/JSInterviewQuestions/HowToCancelAPICalls":{"id":"tutorial-extras/JSInterviewQuestions/HowToCancelAPICalls","title":"Canceling an API Call","description":"In JavaScript, you can cancel API calls made with `fetch and axios using AbortController for fetch and CancelToken (or AbortController in modern versions) for axios`.","sidebar":"tutorialSidebar"},"tutorial-extras/JSInterviewQuestions/Memoization":{"id":"tutorial-extras/JSInterviewQuestions/Memoization","title":"Memoization","description":"Memoization in JavaScript is a technique used to optimize the performance of functions by storing the results of expensive function calls and returning the cached result when the same inputs occur again. It is particularly useful in scenarios where the same computations are repeated multiple times, like recursive algorithms (e.g., Fibonacci sequence, factorials, dynamic programming problems).","sidebar":"tutorialSidebar"},"tutorial-extras/JSInterviewQuestions/Misx":{"id":"tutorial-extras/JSInterviewQuestions/Misx","title":"Miscellaneous","description":"","sidebar":"tutorialSidebar"},"tutorial-extras/JSInterviewQuestions/Objects":{"id":"tutorial-extras/JSInterviewQuestions/Objects","title":"Object Related Problems","description":"Flatten an Object","sidebar":"tutorialSidebar"},"tutorial-extras/JSInterviewQuestions/Polyfills":{"id":"tutorial-extras/JSInterviewQuestions/Polyfills","title":"Array Methods Polyfills","description":"forEach Polyfill","sidebar":"tutorialSidebar"},"tutorial-extras/JSInterviewQuestions/PromiseBased":{"id":"tutorial-extras/JSInterviewQuestions/PromiseBased","title":"Promise Based Outputs","description":"In JavaScript, the concepts of Micro Queue and Macro Queue (also known as the Task Queue) refer to different types of queues that manage the execution of asynchronous tasks. Understanding these queues helps clarify how the event loop processes different types of operations.","sidebar":"tutorialSidebar"},"tutorial-extras/JSInterviewQuestions/PromisePolyfills":{"id":"tutorial-extras/JSInterviewQuestions/PromisePolyfills","title":"Promise Polyfills","description":"Promise","sidebar":"tutorialSidebar"},"tutorial-extras/JSInterviewQuestions/PrototypalInheritance":{"id":"tutorial-extras/JSInterviewQuestions/PrototypalInheritance","title":"Prototypal Inheritance","description":"Object Literal Based","sidebar":"tutorialSidebar"},"tutorial-extras/ReactQuestions/ErrorBoundary":{"id":"tutorial-extras/ReactQuestions/ErrorBoundary","title":"Error Boundary","description":"In React, an ErrorBoundary is a component that catches JavaScript errors anywhere in its child component tree, logs those errors, and displays a fallback UI instead of crashing the entire app. Error boundaries are typically used to handle errors that occur during rendering, in lifecycle methods, or in constructors of the whole component tree.","sidebar":"tutorialSidebar"},"tutorial-extras/ReactQuestions/LifeCycleMethods":{"id":"tutorial-extras/ReactQuestions/LifeCycleMethods","title":"React Lifecycle Methods","description":"In React, lifecycle methods are hooks available in class components that allow you to run code at specific points in a component\'s lifecycle. These methods provide hooks for managing side effects, initializing data, and cleaning up resources. Here\u2019s a summary of the key lifecycle methods:","sidebar":"tutorialSidebar"},"tutorial-extras/ReactQuestions/ReactTypeScriptContext":{"id":"tutorial-extras/ReactQuestions/ReactTypeScriptContext","title":"React TypeScript Context","description":"","sidebar":"tutorialSidebar"},"tutorial-extras/ReactQuestions/ReduxVSContext":{"id":"tutorial-extras/ReactQuestions/ReduxVSContext","title":"Redux vs Context API","description":"In this document, we compare Redux and React\'s Context API to help you understand their differences and when to use each.","sidebar":"tutorialSidebar"},"tutorial-extras/ReactQuestions/ReduxVSRedux-Saga":{"id":"tutorial-extras/ReactQuestions/ReduxVSRedux-Saga","title":"Redux vs Redux-Saga","description":"This document compares Redux Thunk and Redux-Saga, two popular middleware libraries for handling asynchronous actions in Redux applications.","sidebar":"tutorialSidebar"},"tutorial-extras/ReactQuestions/RenderingTypes":{"id":"tutorial-extras/ReactQuestions/RenderingTypes","title":"Rendering Strategies Types","description":"Rendering strategies in web development determine how and when components are rendered in a user interface. Here are the main types of rendering strategies:","sidebar":"tutorialSidebar"},"tutorial-extras/WebBits/WebAccessibility":{"id":"tutorial-extras/WebBits/WebAccessibility","title":"Web Accessibility","description":"Web accessibility is about making web content usable for everyone, including individuals with disabilities. Ensuring that your website is accessible helps provide an inclusive experience, complies with legal requirements, and improves overall user experience. This guide covers the principles of accessibility, common practices, and best practices for creating accessible web content.","sidebar":"tutorialSidebar"},"tutorial-extras/WebBits/WebPerformance":{"id":"tutorial-extras/WebBits/WebPerformance","title":"Web Performance","description":"Web performance refers to how quickly and efficiently a web page or application loads and operates. Good web performance is crucial for providing a positive user experience, improving SEO rankings, and reducing bounce rates. This guide covers key concepts, metrics, and best practices for optimizing web performance.","sidebar":"tutorialSidebar"},"tutorial-extras/WebBits/WebSecurity":{"id":"tutorial-extras/WebBits/WebSecurity","title":"Web Security","description":"Web security involves protecting websites and web applications from various threats and vulnerabilities. Ensuring robust security helps prevent unauthorized access, data breaches, and malicious attacks. This guide covers key concepts, common threats, and best practices for maintaining web security.","sidebar":"tutorialSidebar"}}}}')}}]);