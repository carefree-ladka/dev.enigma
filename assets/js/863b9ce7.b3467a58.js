"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[12634],{28453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>o});var i=t(96540);const r={},s=i.createContext(r);function l(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),i.createElement(s.Provider,{value:n},e.children)}},41810:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>c,frontMatter:()=>s,metadata:()=>o,toc:()=>a});var i=t(74848),r=t(28453);const s={},l="Advanced Algorithm Techniques",o={id:"DSA/DSA/DSA with JavaScript/AdvancedTechniques",title:"Advanced Algorithm Techniques",description:"Euler Tour Technique (ETT)",source:"@site/docs/05-DSA/DSA/DSA with JavaScript/AdvancedTechniques.mdx",sourceDirName:"05-DSA/DSA/DSA with JavaScript",slug:"/DSA/DSA/DSA with JavaScript/AdvancedTechniques",permalink:"/docs/DSA/DSA/DSA with JavaScript/AdvancedTechniques",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/05-DSA/DSA/DSA with JavaScript/AdvancedTechniques.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"AVL Tree",permalink:"/docs/DSA/DSA/DSA with JavaScript/AVLTree"},next:{title:"Breadth-First Search (BFS) for Trees",permalink:"/docs/DSA/DSA/DSA with JavaScript/BFSTree"}},d={},a=[{value:"Euler Tour Technique (ETT)",id:"euler-tour-technique-ett",level:2},{value:"Theory",id:"theory",level:3},{value:"Key Concepts",id:"key-concepts",level:3},{value:"Implementation",id:"implementation",level:3},{value:"LeetCode Problems",id:"leetcode-problems",level:3},{value:"Point Update Range Sum (Segment Tree)",id:"point-update-range-sum-segment-tree",level:2},{value:"Theory",id:"theory-1",level:3},{value:"Key Concepts",id:"key-concepts-1",level:3},{value:"Implementation",id:"implementation-1",level:3},{value:"LeetCode Problems",id:"leetcode-problems-1",level:3},{value:"Meet in the Middle",id:"meet-in-the-middle",level:2},{value:"Theory",id:"theory-2",level:3},{value:"Key Concepts",id:"key-concepts-2",level:3},{value:"Implementation Example (Subset Sum)",id:"implementation-example-subset-sum",level:3},{value:"LeetCode Problems",id:"leetcode-problems-2",level:3},{value:"Common Use Cases &amp; Tips",id:"common-use-cases--tips",level:2},{value:"Euler Tour Technique",id:"euler-tour-technique",level:3},{value:"Point Update Range Sum",id:"point-update-range-sum",level:3},{value:"Meet in the Middle",id:"meet-in-the-middle-1",level:3},{value:"Time Complexity Analysis",id:"time-complexity-analysis",level:2},{value:"Euler Tour",id:"euler-tour",level:3},{value:"Segment Tree",id:"segment-tree",level:3},{value:"Meet in the Middle",id:"meet-in-the-middle-2",level:3}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"advanced-algorithm-techniques",children:"Advanced Algorithm Techniques"})}),"\n",(0,i.jsx)(n.h2,{id:"euler-tour-technique-ett",children:"Euler Tour Technique (ETT)"}),"\n",(0,i.jsx)(n.h3,{id:"theory",children:"Theory"}),"\n",(0,i.jsx)(n.p,{children:"The Euler Tour Technique is a method for processing trees by converting them into a linear array representation. It involves performing a DFS traversal and recording each vertex both when entering and leaving it."}),"\n",(0,i.jsx)(n.h3,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Creates a linear representation of a tree"}),"\n",(0,i.jsx)(n.li,{children:"Each node appears twice: entry and exit times"}),"\n",(0,i.jsx)(n.li,{children:"Useful for solving subtree queries efficiently"}),"\n",(0,i.jsx)(n.li,{children:"Time complexity: O(n) for preprocessing, O(1) for queries"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"implementation",children:"Implementation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"class EulerTour {\n  constructor(n) {\n    this.adj = Array.from({ length: n }, () => []);\n    this.tour = [];\n    this.first = new Array(n).fill(-1);\n    this.last = new Array(n).fill(-1);\n  }\n\n  addEdge(u, v) {\n    this.adj[u].push(v);\n    this.adj[v].push(u);\n  }\n\n  dfs(node, parent) {\n    if (this.first[node] === -1) {\n      this.first[node] = this.tour.length;\n    }\n    this.tour.push(node);\n\n    for (const child of this.adj[node]) {\n      if (child !== parent) {\n        this.dfs(child, node);\n        this.tour.push(node);\n      }\n    }\n\n    this.last[node] = this.tour.length - 1;\n  }\n\n  buildTour(root = 0) {\n    this.dfs(root, -1);\n    return {\n      tour: this.tour,\n      first: this.first,\n      last: this.last,\n    };\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"leetcode-problems",children:"LeetCode Problems"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/kth-ancestor-of-a-tree-node/",children:"1483. Kth Ancestor of a Tree Node"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/minimize-the-total-price-of-the-trips/",children:"2646. Minimize the Total Price of the Trips"})}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"point-update-range-sum-segment-tree",children:"Point Update Range Sum (Segment Tree)"}),"\n",(0,i.jsx)(n.h3,{id:"theory-1",children:"Theory"}),"\n",(0,i.jsx)(n.p,{children:"A Segment Tree is a data structure that allows both range queries and point updates efficiently. It's particularly useful when you need to perform multiple updates and range queries on an array."}),"\n",(0,i.jsx)(n.h3,{id:"key-concepts-1",children:"Key Concepts"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Binary tree structure"}),"\n",(0,i.jsx)(n.li,{children:"Each node represents a range"}),"\n",(0,i.jsx)(n.li,{children:"Supports point updates in O(log n)"}),"\n",(0,i.jsx)(n.li,{children:"Supports range queries in O(log n)"}),"\n",(0,i.jsx)(n.li,{children:"Space complexity: O(n)"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"implementation-1",children:"Implementation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"class SegmentTree {\n  constructor(arr) {\n    this.n = arr.length;\n    this.tree = new Array(4 * this.n).fill(0);\n    this.build(arr, 1, 0, this.n - 1);\n  }\n\n  build(arr, node, start, end) {\n    if (start === end) {\n      this.tree[node] = arr[start];\n      return;\n    }\n\n    const mid = Math.floor((start + end) / 2);\n    this.build(arr, 2 * node, start, mid);\n    this.build(arr, 2 * node + 1, mid + 1, end);\n    this.tree[node] = this.tree[2 * node] + this.tree[2 * node + 1];\n  }\n\n  update(index, val, node = 1, start = 0, end = this.n - 1) {\n    if (start === end) {\n      this.tree[node] = val;\n      return;\n    }\n\n    const mid = Math.floor((start + end) / 2);\n    if (index <= mid) {\n      this.update(index, val, 2 * node, start, mid);\n    } else {\n      this.update(index, val, 2 * node + 1, mid + 1, end);\n    }\n    this.tree[node] = this.tree[2 * node] + this.tree[2 * node + 1];\n  }\n\n  query(left, right, node = 1, start = 0, end = this.n - 1) {\n    if (right < start || left > end) return 0;\n    if (left <= start && end <= right) return this.tree[node];\n\n    const mid = Math.floor((start + end) / 2);\n    const leftSum = this.query(left, right, 2 * node, start, mid);\n    const rightSum = this.query(left, right, 2 * node + 1, mid + 1, end);\n    return leftSum + rightSum;\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"leetcode-problems-1",children:"LeetCode Problems"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/range-sum-query-mutable/",children:"307. Range Sum Query - Mutable"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/booking-concert-tickets-in-groups/",children:"2286. Booking Concert Tickets in Groups"})}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"meet-in-the-middle",children:"Meet in the Middle"}),"\n",(0,i.jsx)(n.h3,{id:"theory-2",children:"Theory"}),"\n",(0,i.jsx)(n.p,{children:"Meet in the Middle is a technique that splits the input into two roughly equal parts, processes them separately, and then combines the results. It's particularly useful when the brute force approach would be too slow."}),"\n",(0,i.jsx)(n.h3,{id:"key-concepts-2",children:"Key Concepts"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Divides the problem into two smaller subproblems"}),"\n",(0,i.jsx)(n.li,{children:"Processes each half independently"}),"\n",(0,i.jsx)(n.li,{children:"Combines results efficiently"}),"\n",(0,i.jsx)(n.li,{children:"Usually reduces time complexity from O(2^n) to O(2^(n/2))"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"implementation-example-subset-sum",children:"Implementation Example (Subset Sum)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"function meetInMiddle(arr, target) {\n  const n = arr.length;\n  const mid = Math.floor(n / 2);\n\n  // Generate all possible sums for first half\n  function generateSums(start, end) {\n    const sums = [];\n    const len = end - start;\n\n    for (let mask = 0; mask < 1 << len; mask++) {\n      let sum = 0;\n      for (let i = 0; i < len; i++) {\n        if (mask & (1 << i)) {\n          sum += arr[start + i];\n        }\n      }\n      sums.push(sum);\n    }\n    return sums.sort((a, b) => a - b);\n  }\n\n  const leftSums = generateSums(0, mid);\n  const rightSums = generateSums(mid, n);\n\n  // Binary search to find pairs that sum to target\n  let count = 0;\n  for (const leftSum of leftSums) {\n    const complement = target - leftSum;\n    const low = rightSums.findIndex(x => x >= complement);\n    const high = rightSums.findIndex(x => x > complement);\n    if (low !== -1 && high !== -1) {\n      count += high - low;\n    }\n  }\n\n  return count;\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"leetcode-problems-2",children:"LeetCode Problems"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/closest-subsequence-sum/",children:"1755. Closest Subsequence Sum"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/",children:"2035. Partition Array Into Two Arrays to Minimize Sum Difference"})}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"common-use-cases--tips",children:"Common Use Cases & Tips"}),"\n",(0,i.jsx)(n.h3,{id:"euler-tour-technique",children:"Euler Tour Technique"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Tree path queries"}),"\n",(0,i.jsx)(n.li,{children:"Subtree problems"}),"\n",(0,i.jsx)(n.li,{children:"LCA (Lowest Common Ancestor) queries"}),"\n",(0,i.jsx)(n.li,{children:"Subtree modification queries"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"point-update-range-sum",children:"Point Update Range Sum"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Dynamic range queries"}),"\n",(0,i.jsx)(n.li,{children:"Interval problems"}),"\n",(0,i.jsx)(n.li,{children:"Cumulative statistics"}),"\n",(0,i.jsx)(n.li,{children:"Online query processing"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"meet-in-the-middle-1",children:"Meet in the Middle"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Subset sum problems"}),"\n",(0,i.jsx)(n.li,{children:"Problems with exponential complexity"}),"\n",(0,i.jsx)(n.li,{children:"Optimization problems with small constraints"}),"\n",(0,i.jsx)(n.li,{children:"When searching through all possibilities is required but too slow"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"time-complexity-analysis",children:"Time Complexity Analysis"}),"\n",(0,i.jsx)(n.h3,{id:"euler-tour",children:"Euler Tour"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Preprocessing: O(n)"}),"\n",(0,i.jsx)(n.li,{children:"Query: O(1) with additional data structures"}),"\n",(0,i.jsx)(n.li,{children:"Space: O(n)"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"segment-tree",children:"Segment Tree"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Build: O(n)"}),"\n",(0,i.jsx)(n.li,{children:"Update: O(log n)"}),"\n",(0,i.jsx)(n.li,{children:"Query: O(log n)"}),"\n",(0,i.jsx)(n.li,{children:"Space: O(n)"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"meet-in-the-middle-2",children:"Meet in the Middle"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Time: O(2^(n/2))"}),"\n",(0,i.jsx)(n.li,{children:"Space: O(2^(n/2))"}),"\n",(0,i.jsx)(n.li,{children:"Typically used when n \u2264 40"}),"\n"]})]})}function c(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}}}]);