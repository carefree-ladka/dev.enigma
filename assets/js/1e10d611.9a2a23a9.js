"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[3486],{28453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>i});var s=r(96540);const t={},o=s.createContext(t);function l(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),s.createElement(o.Provider,{value:n},e.children)}},61888:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>a});var s=r(74848),t=r(28453);const o={},l="Promise Fundamentals",i={id:"WebDev/JavaScript/PromisePolyfills",title:"Promise Fundamentals",description:"What is a Promise?",source:"@site/docs/WebDev/JavaScript/PromisePolyfills.mdx",sourceDirName:"WebDev/JavaScript",slug:"/WebDev/JavaScript/PromisePolyfills",permalink:"/docs/WebDev/JavaScript/PromisePolyfills",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/WebDev/JavaScript/PromisePolyfills.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Promise Based Outputs",permalink:"/docs/WebDev/JavaScript/PromiseBased"},next:{title:"__proto__ vs prototype",permalink:"/docs/WebDev/JavaScript/ProtoVSPrototype"}},c={},a=[{value:"What is a Promise?",id:"what-is-a-promise",level:3},{value:"Creating a Promise",id:"creating-a-promise",level:3},{value:"Promise Methods",id:"promise-methods",level:2},{value:"Instance Methods",id:"instance-methods",level:3},{value:"Static Methods",id:"static-methods",level:3},{value:"Advanced Promise Patterns",id:"advanced-promise-patterns",level:2},{value:"Chaining Promises",id:"chaining-promises",level:3},{value:"Async/Await Syntax",id:"asyncawait-syntax",level:3},{value:"Common Pitfalls",id:"common-pitfalls",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Promise Polyfill",id:"promise-polyfill",level:2},{value:"Promise.all",id:"promiseall",level:2},{value:"Promise.allSettled",id:"promiseallsettled",level:2},{value:"Promise Any",id:"promise-any",level:2},{value:"Promise Race",id:"promise-race",level:2},{value:"Fetch with Retry",id:"fetch-with-retry",level:2},{value:"Sleep",id:"sleep",level:2},{value:"Retry Callback",id:"retry-callback",level:2},{value:"Example Usage",id:"example-usage",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"promise-fundamentals",children:"Promise Fundamentals"})}),"\n",(0,s.jsx)(n.h3,{id:"what-is-a-promise",children:"What is a Promise?"}),"\n",(0,s.jsx)(n.p,{children:"A Promise represents the eventual completion (or failure) of an asynchronous operation and its resulting value. It exists in one of three states:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Pending"}),": Initial state, neither fulfilled nor rejected"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Fulfilled"}),": Operation completed successfully"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Rejected"}),": Operation failed"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"creating-a-promise",children:"Creating a Promise"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const myPromise = new Promise((resolve, reject) => {\n  // Asynchronous operation\n  if (/* operation successful */) {\n    resolve(result);\n  } else {\n    reject(error);\n  }\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"promise-methods",children:"Promise Methods"}),"\n",(0,s.jsx)(n.h3,{id:"instance-methods",children:"Instance Methods"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:".then()"})}),": Handles successful Promise resolution"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"myPromise\n  .then(result => {\n    // Handle successful result\n  })\n  .catch(error => {\n    // Handle errors\n  });\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:".catch()"})}),": Handles Promise rejection"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"myPromise.catch(error => {\n  // Handle any errors\n});\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:".finally()"})}),": Executes regardless of Promise state"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"myPromise\n  .then(result => {\n    /* success */\n  })\n  .catch(error => {\n    /* error */\n  })\n  .finally(() => {\n    // Always runs, useful for cleanup\n  });\n"})}),"\n",(0,s.jsx)(n.h3,{id:"static-methods",children:"Static Methods"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"Promise.resolve()"})}),": Creates a resolved Promise"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const resolvedPromise = Promise.resolve(value);\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"Promise.reject()"})}),": Creates a rejected Promise"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const rejectedPromise = Promise.reject(error);\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"Promise.all()"})}),": Waits for all Promises to resolve"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"Promise.all([promise1, promise2, promise3])\n  .then(results => {\n    // All promises resolved\n  })\n  .catch(error => {\n    // If any promise is rejected\n  });\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"4",children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"Promise.race()"})}),": Resolves/rejects with first settled Promise"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"Promise.race([promise1, promise2]).then(firstResult => {\n  // First promise to settle\n});\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"5",children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"Promise.allSettled()"})}),": Waits for all Promises to settle"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"Promise.allSettled([promise1, promise2]).then(results => {\n  // Array of settlement results\n});\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"6",children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"Promise.any()"})}),": Resolves with first fulfilled Promise"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"Promise.any([promise1, promise2])\n  .then(firstFulfilledResult => {\n    // First promise fulfilled\n  })\n  .catch(AggregateError);\n"})}),"\n",(0,s.jsx)(n.h2,{id:"advanced-promise-patterns",children:"Advanced Promise Patterns"}),"\n",(0,s.jsx)(n.h3,{id:"chaining-promises",children:"Chaining Promises"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"fetchUser()\n  .then(user => fetchUserPosts(user.id))\n  .then(posts => processPosts(posts))\n  .catch(handleError);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"asyncawait-syntax",children:"Async/Await Syntax"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"async function fetchData() {\n  try {\n    const user = await fetchUser();\n    const posts = await fetchUserPosts(user.id);\n    return processPosts(posts);\n  } catch (error) {\n    handleError(error);\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"common-pitfalls",children:"Common Pitfalls"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Unhandled Rejections"}),": Always add ",(0,s.jsx)(n.code,{children:".catch()"})," or use try/catch"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Returning New Promises"}),": Each ",(0,s.jsx)(n.code,{children:".then()"})," can return a new Promise"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Error Propagation"}),": Errors automatically propagate through Promise chain"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Avoid nested Promises"}),"\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.code,{children:"Promise.all()"})," for concurrent operations"]}),"\n",(0,s.jsxs)(n.li,{children:["Prefer ",(0,s.jsx)(n.code,{children:"async/await"})," for readability"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Always handle potential errors"}),"\n",(0,s.jsx)(n.li,{children:"Use meaningful error messages"}),"\n",(0,s.jsx)(n.li,{children:"Keep Promise chains flat and readable"}),"\n",(0,s.jsxs)(n.li,{children:["Leverage ",(0,s.jsx)(n.code,{children:"async/await"})," for complex asynchronous logic"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"promise-polyfill",children:"Promise Polyfill"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-JavaScript",children:"class MyPromise {\n  static STATUS = Object.freeze({\n    PENDING: 'pending',\n    FULFILLED: 'fulfilled',\n    REJECTED: 'rejected'\n  });\n\n  #status = MyPromise.STATUS.PENDING;\n  #value = null;\n  #successCbs = [];\n  #rejectedCbs = [];\n\n  constructor(executor) {\n    if (typeof executor !== 'function') {\n      throw new TypeError('Executor must be a function');\n    }\n\n    try {\n      executor(this.#resolve, this.#reject);\n    } catch (e) {\n      this.#reject(e);\n    }\n  }\n\n  #resolve = (value) => {\n    if (this.#status !== MyPromise.STATUS.PENDING) return;\n\n    if (value === this) {\n      return this.#reject(new TypeError(\"A promise cannot be resolved with itself\"));\n    }\n\n    if (value instanceof MyPromise) {\n      return value.then(this.#resolve, this.#reject);\n    }\n\n    if (value?.then && typeof value.then === 'function') {\n      return new MyPromise(value.then.bind(value)).then(this.#resolve, this.#reject);\n    }\n\n    this.#value = value;\n    this.#status = MyPromise.STATUS.FULFILLED;\n    this.#successCbs.forEach(cb => queueMicrotask(() => cb(value)));\n  };\n\n  #reject = (error) => {\n    if (this.#status !== MyPromise.STATUS.PENDING) return;\n\n    this.#value = error;\n    this.#status = MyPromise.STATUS.REJECTED;\n    this.#rejectedCbs.forEach(cb => queueMicrotask(() => cb(error)));\n  };\n\n  then = (onFulfilled, onRejected) => {\n    return new MyPromise((resolve, reject) => {\n      const handleQueueMicroTask = (isSuccess, _value) => {\n        queueMicrotask(() => {\n          try {\n            const value = isSuccess\n              ? (typeof onFulfilled === 'function' ? onFulfilled(_value) : _value)\n              : (typeof onRejected === 'function' ? onRejected(_value) : reject(_value));\n\n            resolve(value);\n          } catch (e) {\n            reject(e);\n          }\n        });\n      };\n\n      switch (this.#status) {\n        case MyPromise.STATUS.PENDING:\n          this.#successCbs.push((val) => handleQueueMicroTask(true, val));\n          this.#rejectedCbs.push((err) => handleQueueMicroTask(false, err));\n          break;\n        case MyPromise.STATUS.FULFILLED:\n          handleQueueMicroTask(true, this.#value);\n          break;\n        case MyPromise.STATUS.REJECTED:\n          handleQueueMicroTask(false, this.#value);\n          break;\n      }\n    });\n  };\n\n  catch = (onRejected) => {\n    return this.then(null, onRejected);\n  };\n\n  finally = (onFinally) => {\n    return this.then(\n      (val) => MyPromise.resolve(onFinally()).then(() => val),\n      (error) => MyPromise.resolve(onFinally()).then(() => {\n        throw error;\n      })\n    );\n  };\n\n  static resolve = (value) => {\n    if (value instanceof MyPromise) return value;\n    if (value?.then && typeof value.then === 'function') {\n      return new MyPromise(value.then.bind(value));\n    }\n    return new MyPromise((res) => res(value));\n  };\n\n  static reject = (error) => {\n    return new MyPromise((_, rej) => rej(error));\n  };\n\n  static all = (promises) => {\n    return new MyPromise((resolve, reject) => {\n      if (!Array.isArray(promises)) {\n        return reject(new TypeError('Argument must be an array'));\n      }\n\n      const results = [];\n      let completedCount = 0;\n\n      if (promises.length === 0) {\n        return resolve(results);\n      }\n\n      promises.forEach((promise, index) => {\n        MyPromise.resolve(promise).then(\n          (value) => {\n            results[index] = value;\n            completedCount++;\n            if (completedCount === promises.length) {\n              resolve(results);\n            }\n          },\n          (error) => {\n            reject(error);\n          }\n        );\n      });\n    });\n  };\n\n  static allSettled = (promises) => {\n    return new MyPromise((resolve) => {\n      if (!Array.isArray(promises)) {\n        return reject(new TypeError('Argument must be an array'));\n      }\n\n      const results = [];\n      let completedCount = 0;\n\n      if (promises.length === 0) {\n        return resolve(results);\n      }\n\n      promises.forEach((promise, index) => {\n        MyPromise.resolve(promise).then(\n          (value) => {\n            results[index] = { status: 'fulfilled', value };\n            completedCount++;\n            if (completedCount === promises.length) {\n              resolve(results);\n            }\n          },\n          (error) => {\n            results[index] = { status: 'rejected', reason: error };\n            completedCount++;\n            if (completedCount === promises.length) {\n              resolve(results);\n            }\n          }\n        );\n      });\n    });\n  };\n\n  static race = (promises) => {\n    return new MyPromise((resolve, reject) => {\n      if (!Array.isArray(promises)) {\n        return reject(new TypeError('Argument must be an array'));\n      }\n\n      promises.forEach((promise) => {\n        MyPromise.resolve(promise).then(resolve, reject);\n      });\n    });\n  };\n\n  static any = (promises) => {\n    return new MyPromise((resolve, reject) => {\n      if (!Array.isArray(promises)) {\n        return reject(new TypeError('Argument must be an array'));\n      }\n\n      const errors = [];\n      let rejectedCount = 0;\n\n      if (promises.length === 0) {\n        return reject(new AggregateError([], 'All promises were rejected'));\n      }\n\n      promises.forEach((promise, index) => {\n        MyPromise.resolve(promise).then(\n          (value) => {\n            resolve(value);\n          },\n          (error) => {\n            errors[index] = error;\n            rejectedCount++;\n            if (rejectedCount === promises.length) {\n              reject(new AggregateError(errors, 'All promises were rejected'));\n            }\n          }\n        );\n      });\n    });\n  };\n\n  static withResolvers = () => {\n    let resolve, reject;\n    const promise = new MyPromise((res, rej) => {\n      resolve = res;\n      reject = rej;\n    });\n    return { promise, resolve, reject };\n  };\n\n  static try = (fn) => {\n    if (typeof fn !== 'function') {\n      throw new TypeError('Argument must be a function');\n    }\n    return new MyPromise((resolve, reject) => {\n      try {\n        resolve(fn());\n      } catch (e) {\n        reject(e);\n      }\n    });\n  };\n}\n\n\n// Example 1: MyPromise.all\nconst p1 = MyPromise.resolve(1);\nconst p2 = MyPromise.resolve(2);\nconst p3 = new MyPromise((resolve) => setTimeout(() => resolve(3), 1000));\n\nMyPromise.all([p1, p2, p3]).then((results) => {\n  console.log(results); // [1, 2, 3] (after 1 second)\n});\n\n// Example 2: MyPromise.allSettled\nconst p4 = MyPromise.resolve(4);\nconst p5 = MyPromise.reject('Error 5');\n\nMyPromise.allSettled([p4, p5]).then((results) => {\n  console.log(results);\n  // [\n  //   { status: 'fulfilled', value: 4 },\n  //   { status: 'rejected', reason: 'Error 5' }\n  // ]\n});\n\n// Example 3: MyPromise.race\nconst p6 = new MyPromise((resolve) => setTimeout(() => resolve('Fast'), 500));\nconst p7 = new MyPromise((resolve) => setTimeout(() => resolve('Slow'), 1000));\n\nMyPromise.race([p6, p7]).then((result) => {\n  console.log(result); // 'Fast' (after 500ms)\n});\n\n// Example 4: MyPromise.any\nconst p8 = MyPromise.reject('Error 8');\nconst p9 = new MyPromise((resolve) => setTimeout(() => resolve('Success 9'), 1000));\n\nMyPromise.any([p8, p9]).then((result) => {\n  console.log(result); // 'Success 9' (after 1 second)\n});\n\nMyPromise.any([MyPromise.reject('Error 10'), MyPromise.reject('Error 11')]).catch((error) => {\n  console.log(error.errors); // ['Error 10', 'Error 11']\n});\n\n// Example 5: withResolvers\nconst { promise, resolve, reject } = MyPromise.withResolvers();\nsetTimeout(() => resolve('Resolved with withResolvers!'), 1000);\npromise.then(console.log); // 'Resolved with withResolvers!' after 1 second\n\n// Example 6: try\nMyPromise.try(() => {\n  console.log('Executing synchronous code');\n  if (Math.random() > 0.5) {\n    throw new Error('Random error in try');\n  }\n  return 'Success in try';\n})\n  .then(console.log) // 'Success in try'\n  .catch(console.error); // 'Error: Random error in try'\n"})}),"\n",(0,s.jsx)(n.h2,{id:"promiseall",children:"Promise.all"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-JavaScript",children:"Promise.myAll = function (promises = []) {\n  return new Promise((resolve, reject) => {\n    if (!promises.length) resolve([])\n    const result = []\n    let count = 0\n    promises.forEach((promise, index) => {\n      Promise.resolve(promise).then((value) => {\n        result[index] = value\n        count++\n        if (count === promises.length) {\n          resolve(result)\n        }\n      }).catch((error) => reject(error))\n    })\n  })\n}\n\n// Example usage:\nconst p1 = Promise.reject(3);\nconst p2 = 42;\nconst p3 = new Promise((resolve, reject) => {\n  setTimeout(resolve, 100, 'foo');\n});\n\nPromise.myAll([p1, p2, p3])\n  .then((values) => {\n    console.log(values); // [3, 42, \"foo\"]\n  })\n  .catch((error) => {\n    console.error(error);\n  });\n"})}),"\n",(0,s.jsx)(n.h2,{id:"promiseallsettled",children:"Promise.allSettled"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-JavaScript",children:"Promise.myAllSettled = function (promises = []) {\n  return Promise.all(\n    promises.map(promise => {\n      return Promise.resolve(promise).then((value) => ({\n        status: 'fulfilled', value\n      })).catch((reason => ({\n        status: 'rejected', reason\n      })))\n    })\n  )\n}\n\n// Example usage:\nconst p1 = Promise.resolve(3);\nconst p2 = Promise.reject('An error occurred');\nconst p3 = new Promise((resolve, reject) => {\n  setTimeout(resolve, 100, 'foo');\n});\n\nPromise.myAllSettled([p1, p2, p3])\n  .then(results => {\n    console.log(results);\n    // [\n    //   { status: 'fulfilled', value: 3 },\n    //   { status: 'rejected', reason: 'An error occurred' },\n    //   { status: 'fulfilled', value: 'foo' }\n    // ]\n  });\n"})}),"\n",(0,s.jsx)(n.h2,{id:"promise-any",children:"Promise Any"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-JavaScript",children:"Promise.myAny = function (promises = []) {\n  return new Promise((resolve, reject) => {\n    let errors = [];\n    let rejectedCount = 0;\n    const totalPromises = promises.length;\n\n    if (!totalPromises) {\n      return reject(new AggregateError(errors, \"All promises were rejected\"));\n    }\n\n    promises.forEach((promise, index) => {\n      Promise.resolve(promise)\n        .then(value => {\n          resolve(value);\n        })\n        .catch(error => {\n          errors[index] = error;\n          rejectedCount++;\n\n          if (rejectedCount === totalPromises) {\n            reject(new AggregateError(errors, \"All promises were rejected\"));\n          }\n        });\n    });\n  });\n};\n\n// Example usage:\nconst p1 = Promise.reject('Error 1');\nconst p2 = new Promise((resolve) => setTimeout(resolve, 100, 'Success 2'));\nconst p3 = new Promise((resolve) => setTimeout(resolve, 200, 'Success 3'));\n\nPromise.myAny([p1, p2, p3])\n  .then(value => {\n    console.log('Resolved with value:', value); // \"Resolved with value: Success 2\"\n  })\n  .catch(error => {\n    console.error('Rejected with error:', error);\n  });\n"})}),"\n",(0,s.jsx)(n.h2,{id:"promise-race",children:"Promise Race"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-JavaScript",children:"Promise.myRace = function (promises = []) {\n  return new Promise((resolve, reject) => {\n    promises.forEach(promise => {\n      Promise.resolve(promise)\n        .then(resolve)\n        .catch(reject);\n    });\n  });\n};\n\n// Example usage:\nconst p1 = new Promise((resolve) => setTimeout(resolve, 500, 'Success 1'));\nconst p2 = new Promise((resolve, reject) => setTimeout(reject, 100, 'Error 2'));\nconst p3 = new Promise((resolve) => setTimeout(resolve, 200, 'Success 3'));\n\nPromise.myRace([p1, p2, p3])\n  .then(value => {\n    console.log('Resolved with value:', value); // \"Resolved with value: Success 2\"\n  })\n  .catch(error => {\n    console.error('Rejected with error:', error); // \"Rejected with error: Error 2\"\n  });\n"})}),"\n",(0,s.jsx)(n.h2,{id:"fetch-with-retry",children:"Fetch with Retry"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-JavaScript",children:"const fetchWithRetry = async (fetcher, maxRetry = 3, currentRetry = 0) => {\n  try {\n    const response = await fetcher()\n    if (response.ok) {\n      return await response.json()\n    }\n  }\n  catch (err) {\n    console.log('err', err);\n    if (maxRetry > 0) {\n      return fetchWithRetry(fetcher, maxRetry - 1, currentRetry + 1)\n    }\n  }\n  throw new Error(`Failed to fetch after ${currentRetry} retries`)\n}\n\n\n//Usage\nconst url = 'https://api.example.com'\n\nconst fetchData = async () => fetchWithRetry(() => fetch(url), 3)\n\n\nfetchData()\n  .then(res => res.json())\n  .then(data => console.log(data))\n  .catch(error => console.log('failed to fetch', error))\n"})}),"\n",(0,s.jsx)(n.h2,{id:"sleep",children:"Sleep"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-JavaScript",children:"const sleep = (wait) => new Promise(res => setTimeout(res, wait))\n\nasync function fix() {\n  console.log('Start');\n  await sleep(2000); // Sleep for 2 seconds\n  console.log('End');\n}\n\nfix();\n"})}),"\n",(0,s.jsx)(n.h2,{id:"retry-callback",children:"Retry Callback"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-JavaScript",children:"function retry(fn, retries = 3, delay = 1000) {\n    const attempt = (triesLeft, resolve, reject, args) => {\n        fn(...args)\n            .then(resolve)\n            .catch(error => {\n                if (triesLeft === 0) {\n                    reject(`Failed after ${retries} attempts: ${error}`);\n                } else {\n                    console.log(`Retrying... Attempts left: ${triesLeft}`);\n                    setTimeout(() => attempt(triesLeft - 1, resolve, reject, args), delay);\n                }\n            });\n    };\n\n    return (...args) => new Promise((resolve, reject) => attempt(retries, resolve, reject, args));\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"example-usage",children:"Example Usage"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-JavaScript",children:'function unreliableFunction() {\n    return new Promise((resolve, reject) => {\n        const success = Math.random() > 0.7;  // 30% chance of success\n        if (success) {\n            resolve("Success!");\n        } else {\n            reject("Random failure");\n        }\n    });\n}\n\nconst retryUnreliable = retry(unreliableFunction, 3, 1000);\n\nretryUnreliable()\n    .then(result => console.log(result))\n    .catch(error => console.error(error));\n\n/*\nRetrying... Attempts left: 3\nRetrying... Attempts left: 2\nRetrying... Attempts left: 1\nFailed after 3 attempts: Random failure\n*/\n'})})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);