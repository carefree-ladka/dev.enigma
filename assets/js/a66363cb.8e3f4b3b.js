"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[86009],{18507:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>c,toc:()=>d});var r=t(74848),i=t(28453);const s={title:"In-Place Reversal of a Linked List"},a=void 0,c={id:"DSA/DSA with JavaScript/ReverseLinkedList",title:"In-Place Reversal of a Linked List",description:"In-Place Reversal of a Linked List",source:"@site/docs/DSA/DSA with JavaScript/ReverseLinkedList.mdx",sourceDirName:"DSA/DSA with JavaScript",slug:"/DSA/DSA with JavaScript/ReverseLinkedList",permalink:"/docs/DSA/DSA with JavaScript/ReverseLinkedList",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with JavaScript/ReverseLinkedList.mdx",tags:[],version:"current",frontMatter:{title:"In-Place Reversal of a Linked List"},sidebar:"tutorialSidebar",previous:{title:"Reservoir Sampling",permalink:"/docs/DSA/DSA with JavaScript/ReservoirSampling"},next:{title:"Segment Tree Tutorial",permalink:"/docs/DSA/DSA with JavaScript/SegmentTree"}},o={},d=[{value:"In-Place Reversal of a Linked List",id:"in-place-reversal-of-a-linked-list",level:2},{value:"Concept",id:"concept",level:3},{value:"Iterative Approach",id:"iterative-approach",level:3},{value:"Recursive Approach",id:"recursive-approach",level:3},{value:"Recursive Approach",id:"recursive-approach-1",level:3}];function l(e){const n={code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"in-place-reversal-of-a-linked-list",children:"In-Place Reversal of a Linked List"}),"\n",(0,r.jsx)(n.p,{children:"Reversing a linked list in-place involves reversing the direction of the pointers in the list without using additional data structures. This technique is useful for operations requiring efficient space usage and is commonly used in various linked list problems."}),"\n",(0,r.jsx)(n.h3,{id:"concept",children:"Concept"}),"\n",(0,r.jsxs)(n.p,{children:["In an in-place reversal, each node's ",(0,r.jsx)(n.code,{children:"next"})," pointer is updated to point to its previous node. This process is performed iteratively or recursively."]}),"\n",(0,r.jsx)(n.h3,{id:"iterative-approach",children:"Iterative Approach"}),"\n",(0,r.jsxs)(n.p,{children:["The iterative approach involves three pointers: ",(0,r.jsx)(n.code,{children:"prev"}),", ",(0,r.jsx)(n.code,{children:"current"}),", and ",(0,r.jsx)(n.code,{children:"next"}),". By iterating through the list and adjusting the pointers, the list can be reversed."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Code Example"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class ListNode {\n  constructor(value = 0, next = null) {\n    this.value = value;\n    this.next = next;\n  }\n}\n\n/**\n * Reverse a linked list in-place iteratively.\n * @param {ListNode} head - The head of the linked list.\n * @return {ListNode} - The new head of the reversed linked list.\n */\nconst reverseListIterative = head => {\n  let prev = null;\n  let current = head;\n\n  while (current) {\n    const next = current.next; // Save next node\n    current.next = prev; // Reverse the pointer\n    prev = current; // Move prev to current node\n    current = next; // Move to next node\n  }\n\n  return prev; // New head of the reversed list\n};\n"})}),"\n",(0,r.jsx)(n.h3,{id:"recursive-approach",children:"Recursive Approach"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-JavaScript",children:"/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nconst reverseList = (head, prev = null) => {\n  if (!head) return prev\n  const next = head.next\n  head.next = prev\n  return reverseList(next, head)\n};\n"})}),"\n",(0,r.jsx)(n.h3,{id:"recursive-approach-1",children:"Recursive Approach"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-JavaScript",children:"/**\n * Reverse a linked list in-place recursively.\n * @param {ListNode} head - The head of the linked list.\n * @return {ListNode} - The new head of the reversed linked list.\n */\nconst reverseListRecursive = (head) => {\n  // Base case: empty list or single node\n  if (!head || !head.next) {\n    return head;\n  }\n\n  // Recursively reverse the rest of the list\n  const newHead = reverseListRecursive(head.next);\n\n  // Update pointers\n  head.next.next = head;\n  head.next = null;\n\n  return newHead;\n};\n"})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>c});var r=t(96540);const i={},s=r.createContext(i);function a(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);