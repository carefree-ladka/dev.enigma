"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[6574],{28453:(n,e,t)=>{t.d(e,{R:()=>i,x:()=>o});var a=t(96540);const s={},r=a.createContext(s);function i(n){const e=a.useContext(r);return a.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:i(n.components),a.createElement(r.Provider,{value:e},n.children)}},82450:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>l});var a=t(74848),s=t(28453);const r={title:"Backtracking Algorithm"},i=void 0,o={id:"DSA/DSA with JavaScript/Backtracking",title:"Backtracking Algorithm",description:"Backtracking Algorithm",source:"@site/docs/DSA/DSA with JavaScript/Backtracking.mdx",sourceDirName:"DSA/DSA with JavaScript",slug:"/DSA/DSA with JavaScript/Backtracking",permalink:"/dev.enigma/docs/DSA/DSA with JavaScript/Backtracking",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with JavaScript/Backtracking.mdx",tags:[],version:"current",frontMatter:{title:"Backtracking Algorithm"},sidebar:"tutorialSidebar",previous:{title:"Breadth-First Search (BFS) for Trees",permalink:"/dev.enigma/docs/DSA/DSA with JavaScript/BFSTree"},next:{title:"Binary Heap",permalink:"/dev.enigma/docs/DSA/DSA with JavaScript/BinaryHeap"}},c={},l=[{value:"Backtracking Algorithm",id:"backtracking-algorithm",level:2},{value:"Overview",id:"overview",level:3},{value:"Algorithm Steps",id:"algorithm-steps",level:3},{value:"Example Implementation",id:"example-implementation",level:3},{value:"Rat in a Maze",id:"rat-in-a-maze",level:2},{value:"Count the Number of Paths",id:"count-the-number-of-paths",level:2},{value:"N Queens",id:"n-queens",level:2},{value:"Permutation",id:"permutation",level:3},{value:"Permutation 2",id:"permutation-2",level:3},{value:"Combination",id:"combination",level:3},{value:"Combination Sum",id:"combination-sum",level:3},{value:"Combination 3",id:"combination-3",level:3},{value:"Subsets",id:"subsets",level:3},{value:"Subsets 2",id:"subsets-2",level:3}];function u(n){const e={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.h2,{id:"backtracking-algorithm",children:"Backtracking Algorithm"}),"\n",(0,a.jsx)(e.p,{children:"The Backtracking algorithm is a general technique used for solving problems by incrementally building solutions and abandoning those that fail to meet the criteria. It explores all possible solutions in a systematic manner and is particularly useful for constraint satisfaction and combinatorial problems."}),"\n",(0,a.jsx)(e.h3,{id:"overview",children:"Overview"}),"\n",(0,a.jsx)(e.p,{children:"Backtracking works by trying out all potential solutions and discarding those that do not meet the problem\u2019s constraints. It builds a solution step-by-step, and if at any step the current solution does not meet the constraints, it backtracks to the previous step and tries a different option."}),"\n",(0,a.jsx)(e.h3,{id:"algorithm-steps",children:"Algorithm Steps"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Choose"}),": Select an option from the available choices."]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Explore"}),": Move to the next state or option based on the current choice."]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Check"}),": Determine if the current state meets the constraints or criteria of the problem."]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Backtrack"}),": If the current solution path does not meet the criteria, revert to the previous state and try the next option."]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"example-implementation",children:"Example Implementation"}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Code Example"}),":"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"/**\n * Solve [Problem Description] using Backtracking.\n * @param {Type} [parameterName] - [Description of the parameter]\n * @return {Type} - [Description of the return value]\n */\nconst [functionName] = ([parameters]) => {\n  const result = [];\n  \n  const backtrack = (currentState) => {\n    // Base case: Check if current state meets the criteria\n    if ([condition]) {\n      result.push([solution]);\n      return;\n    }\n    \n    // Iterate through options and recurse\n    for (const option of [options]) {\n      if ([isValid](option)) {\n        // Make a choice\n        [updateState](option);\n        \n        // Recur to explore the next step\n        backtrack([newState]);\n        \n        // Undo the choice (backtrack)\n        [revertState](option);\n      }\n    }\n  };\n\n  backtrack([initialState]);\n  return result;\n};\n\n// Example usage:\nconsole.log([functionName]([testParameters]));\n/* Output:\n[Expected output]\n*/\n"})}),"\n",(0,a.jsx)(e.h2,{id:"rat-in-a-maze",children:"Rat in a Maze"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-Javascript",children:'const ratInMaze = (maze) => {\n  const n = maze.length;\n  const paths = [];\n  const path = [];\n  const directions = [\n    [1, 0, "D"], // Down\n    [0, -1, "L"], // Left\n    [0, 1, "R"], // Right\n    [-1, 0, "U"] // Up\n  ];\n\n  const isSafe = (row, col, visited) => {\n    return (\n      row >= 0 && row < n &&\n      col >= 0 && col < n &&\n      maze[row][col] === 1 &&\n      !visited[row][col]\n    );\n  };\n\n  const backtrack = (row, col, visited) => {\n    if (row === n - 1 && col === n - 1) {\n      paths.push(path.join(""));\n      return;\n    }\n\n    visited[row][col] = true;\n\n    for (const [dx, dy, dir] of directions) {\n      const newRow = row + dx;\n      const newCol = col + dy;\n\n      if (isSafe(newRow, newCol, visited)) {\n        path.push(dir);\n        backtrack(newRow, newCol, visited);\n        path.pop(); // Backtrack\n      }\n    }\n\n    visited[row][col] = false;\n  };\n\n  if (maze[0][0] === 1) {\n    const visited = Array.from({ length: n }, () => Array(n).fill(false));\n    backtrack(0, 0, visited);\n  }\n\n  return paths;\n};\n\n// Example Usage\nconst maze = [\n  [1, 1, 1, 1],\n  [1, 1, 0, 1],\n  [0, 1, 0, 1],\n  [1, 1, 1, 1],\n];\n\nconst result = ratInMaze(maze);\nconsole.log(result);\n/* \n["DRDDRR", "DRURRDDD", "RDDDRR", "RRRDDD"]\n */\n'})}),"\n",(0,a.jsx)(e.h2,{id:"count-the-number-of-paths",children:"Count the Number of Paths"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Instead of listing all paths, count how many distinct paths exist from the top-left to the bottom-right corner."}),"\n"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-Javascript",children:"const countPathsInMaze = (maze) => {\n  const n = maze.length;\n  let count = 0;\n\n  const isSafe = (row, col, visited) => {\n    return (\n      row >= 0 && row < n &&\n      col >= 0 && col < n &&\n      maze[row][col] === 1 &&\n      !visited[row][col]\n    );\n  };\n\n  const backtrack = (row, col, visited) => {\n    if (row === n - 1 && col === n - 1) {\n      count++;\n      return;\n    }\n\n    visited[row][col] = true;\n\n    const directions = [\n      [1, 0],  // Down\n      [0, -1], // Left\n      [0, 1],  // Right\n      [-1, 0], // Up\n    ];\n\n    for (const [dr, dc] of directions) {\n      const newRow = row + dr;\n      const newCol = col + dc;\n\n      if (isSafe(newRow, newCol, visited)) {\n        backtrack(newRow, newCol, visited);\n      }\n    }\n\n    visited[row][col] = false; // Backtrack\n  };\n\n  if (maze[0][0] === 1) {\n    const visited = Array.from({ length: n }, () => Array(n).fill(false));\n    backtrack(0, 0, visited);\n  }\n\n  return count;\n};\n\n// Test Usage\nconst maze = [\n  [1, 1, 0, 0],\n  [1, 1, 0, 1],\n  [0, 1, 0, 0],\n  [1, 1, 1, 1],\n];\n\nconsole.log(countPathsInMaze(maze)); // Output: 2\n"})}),"\n",(0,a.jsx)(e.h2,{id:"n-queens",children:"N Queens"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-Javascript",children:"/**\n * @param {number} n\n * @return {string[][]}\n */\nfunction solveNQueens(n) {\n  const solutions = [];\n\n  function solve(queens = [], row = 0) {\n    if (row === n) {\n      solutions.push(queens.map(col => '.'.repeat(col) + 'Q' + '.'.repeat(n - col - 1)));\n      return;\n    }\n\n    for (let col = 0; col < n; col++) {\n      if (queens.every((queenCol, queenRow) =>\n        queenCol !== col &&\n        Math.abs(queenCol - col) !== Math.abs(queenRow - row)\n      )) {\n        solve([...queens, col], row + 1);\n      }\n    }\n  }\n\n  solve();\n  return solutions;\n}\n"})}),"\n",(0,a.jsx)(e.h3,{id:"permutation",children:"Permutation"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-Javascript",children:"const permute = (nums) => {\n  const result = [];\n  const backtrack = (path) => {\n    if (path.length === nums.length) {\n      result.push([...path]);\n      return;\n    }\n    for (let i = 0; i < nums.length; i++) {\n      if (path.includes(nums[i])) continue;\n      path.push(nums[i]);\n      backtrack(path);\n      path.pop();\n    }\n  };\n\n  backtrack([]);\n  return result;\n};\n"})}),"\n",(0,a.jsx)(e.h3,{id:"permutation-2",children:"Permutation 2"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-Javascript",children:"const permuteUnique = (nums) => {\n  const list = []\n  nums.sort((a, b) => a - b); // Sort the array to ensure duplicates are adjacent\n\n  const backtrack = (tempList, used) => {\n    if (tempList.length === nums.length) {\n      list.push([...tempList]);\n      return\n    }\n    for (let i = 0; i < nums.length; i++) {\n      // Skip the used elements or duplicates\n      if (used[i] || (i > 0 && nums[i] === nums[i - 1] && !used[i - 1])) continue;\n      used[i] = true;\n      tempList.push(nums[i]);\n      backtrack(tempList, used);\n      used[i] = false;\n      tempList.pop();\n    }\n  };\n\n  backtrack([], new Array(nums.length).fill(false));\n  return list;\n};\n"})}),"\n",(0,a.jsx)(e.h3,{id:"combination",children:"Combination"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-Javascript",children:"/**\n * @param {number} n\n * @param {number} k\n * @return {number[][]}\n */\nconst combine = (n, k) => {\n  const res = []\n\n  const backtrack = (index, comb) => {\n    if (comb.length === k) {\n      res.push([...comb])\n      return\n    }\n    for (let i = index; i < n + 1; i++) {\n      comb.push(i)\n      backtrack(i + 1, comb)\n      comb.pop()\n    }\n  }\n  backtrack(1, [])\n  return res\n};\n"})}),"\n",(0,a.jsx)(e.h3,{id:"combination-sum",children:"Combination Sum"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-Javascript",children:"/**\n * @param {number[]} candidates\n * @param {number} target\n * @return {number[][]}\n */\nconst combinationSum = (candidates, target) => {\n  const result = [];\n\n  const backtrack = (start, path, sum) => {\n    if (sum > target) return; // Exceeds the target, no need to continue\n    if (sum === target) { // Found a valid combination\n      result.push([...path]);\n      return;\n    }\n    for (let i = start; i < candidates.length; i++) {\n      path.push(candidates[i]); // Choose the candidate\n      backtrack(i, path, sum + candidates[i]); // Recur with the same candidate\n      path.pop(); // Backtrack, remove the last candidate\n    }\n  };\n\n  backtrack(0, [], 0); // Start with index 0, empty path, and sum 0\n  return result;\n};\n"})}),"\n",(0,a.jsx)(e.h3,{id:"combination-3",children:"Combination 3"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-Javascript",children:"/**\n * @param {number} k\n * @param {number} n\n * @return {number[][]}\n */\nconst combinationSum3 = (k, n) => {\n  const result = []\n\n  const backtrack = (start, path, sum) => {\n    if (path.length === k && sum === n) {\n      result.push([...path])\n      return\n    }\n\n    if (sum >= n && path.length >= k) return\n\n    for (let i = start; i <= 9; i++) {\n      path.push(i)\n      backtrack(i + 1, path, sum + i)\n      path.pop(i)\n    }\n  }\n\n  backtrack(1, [], 0)\n  return result\n};\n"})}),"\n",(0,a.jsx)(e.h3,{id:"subsets",children:"Subsets"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-Javascript",children:"/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nconst subsets = (nums) => {\n  const result = []\n\n  const backtrack = (id, subs) => {\n    result.push([...subs])\n\n    for (let i = id; i < nums.length; i++) {\n      subs.push(nums[i])\n      backtrack(i + 1, subs)\n      subs.pop()\n    }\n  }\n  backtrack(0, [])\n  return result\n};\n"})}),"\n",(0,a.jsx)(e.h3,{id:"subsets-2",children:"Subsets 2"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-Javascript",children:"/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nconst subsetsWithDup = (nums) => {\n  nums.sort((a, b) => a - b)\n  const result = []\n\n  const backtrack = (id, subs) => {\n    result.push([...subs])\n\n    for (let i = id; i < nums.length; i++) {\n      if (i > id && nums[i] === nums[i - 1]) continue\n      subs.push(nums[i])\n      backtrack(i + 1, subs)\n      subs.pop()\n    }\n  }\n  backtrack(0, [])\n  return result\n};\n"})})]})}function h(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(u,{...n})}):u(n)}}}]);