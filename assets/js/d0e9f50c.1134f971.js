"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[4349],{9967:(r,n,e)=>{e.r(n),e.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>u,frontMatter:()=>s,metadata:()=>a,toc:()=>d});var i=e(4848),t=e(8453);const s={},l="Divide and Conquer Technique",a={id:"tutorial-basics/DivideAndConquer",title:"Divide and Conquer Technique",description:"Overview",source:"@site/docs/tutorial-basics/DivideAndConquer.mdx",sourceDirName:"tutorial-basics",slug:"/tutorial-basics/DivideAndConquer",permalink:"/js.enigma/docs/tutorial-basics/DivideAndConquer",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/tutorial-basics/DivideAndConquer.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Euclidean and Manhattan Distance",permalink:"/js.enigma/docs/tutorial-basics/DistancesFormula"},next:{title:"Dutch National Flag Algorithm",permalink:"/js.enigma/docs/tutorial-basics/DutchNationalFlag"}},o={},d=[{value:"Overview",id:"overview",level:2},{value:"Three Main Steps",id:"three-main-steps",level:2},{value:"Common Examples and Implementations",id:"common-examples-and-implementations",level:2},{value:"1. Merge Sort",id:"1-merge-sort",level:3},{value:"2. Binary Search",id:"2-binary-search",level:3},{value:"3. Maximum Subarray Sum",id:"3-maximum-subarray-sum",level:3},{value:"4. Quick Sort",id:"4-quick-sort",level:3},{value:"Time Complexity Analysis",id:"time-complexity-analysis",level:2},{value:"When to Use Divide and Conquer",id:"when-to-use-divide-and-conquer",level:2},{value:"Good Use Cases:",id:"good-use-cases",level:3},{value:"Advantages:",id:"advantages",level:3},{value:"Disadvantages:",id:"disadvantages",level:3},{value:"Implementation Template",id:"implementation-template",level:2},{value:"Count Inversions in an array",id:"count-inversions-in-an-array",level:3}];function c(r){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...r.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"divide-and-conquer-technique",children:"Divide and Conquer Technique"})}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"Divide and Conquer is an algorithmic paradigm that breaks down a problem into smaller subproblems, solves them, and then combines these solutions to create a solution to the original problem."}),"\n",(0,i.jsx)(n.h2,{id:"three-main-steps",children:"Three Main Steps"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Divide"}),": Break the problem into smaller subproblems"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Conquer"}),": Recursively solve the subproblems"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Combine"}),": Combine the solutions of subproblems to create a solution to the original problem"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"common-examples-and-implementations",children:"Common Examples and Implementations"}),"\n",(0,i.jsx)(n.h3,{id:"1-merge-sort",children:"1. Merge Sort"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"function mergeSort(arr) {\r\n    // Base case\r\n    if (arr.length <= 1) return arr;\r\n    \r\n    // Divide\r\n    const mid = Math.floor(arr.length / 2);\r\n    const left = arr.slice(0, mid);\r\n    const right = arr.slice(mid);\r\n    \r\n    // Conquer\r\n    const sortedLeft = mergeSort(left);\r\n    const sortedRight = mergeSort(right);\r\n    \r\n    // Combine\r\n    return merge(sortedLeft, sortedRight);\r\n}\r\n\r\nfunction merge(left, right) {\r\n    const result = [];\r\n    let i = 0, j = 0;\r\n    \r\n    while (i < left.length && j < right.length) {\r\n        if (left[i] <= right[j]) {\r\n            result.push(left[i++]);\r\n        } else {\r\n            result.push(right[j++]);\r\n        }\r\n    }\r\n    \r\n    return result.concat(left.slice(i)).concat(right.slice(j));\r\n}\r\n\r\n// Usage\r\nconsole.log(mergeSort([38, 27, 43, 3, 9, 82, 10]));\r\n// Output: [3, 9, 10, 27, 38, 43, 82]\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-binary-search",children:"2. Binary Search"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"function binarySearch(arr, target, left = 0, right = arr.length - 1) {\r\n    // Base case\r\n    if (left > right) return -1;\r\n    \r\n    // Divide\r\n    const mid = Math.floor((left + right) / 2);\r\n    \r\n    // Conquer\r\n    if (arr[mid] === target) return mid;\r\n    \r\n    if (arr[mid] > target) {\r\n        return binarySearch(arr, target, left, mid - 1);\r\n    } else {\r\n        return binarySearch(arr, target, mid + 1, right);\r\n    }\r\n}\r\n\r\n// Usage\r\nconsole.log(binarySearch([1, 2, 3, 4, 5, 6, 7], 5));\r\n// Output: 4\n"})}),"\n",(0,i.jsx)(n.h3,{id:"3-maximum-subarray-sum",children:"3. Maximum Subarray Sum"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"function maxSubarray(arr, left = 0, right = arr.length - 1) {\r\n    // Base case\r\n    if (left === right) return arr[left];\r\n    \r\n    // Divide\r\n    const mid = Math.floor((left + right) / 2);\r\n    \r\n    // Conquer\r\n    const leftSum = maxSubarray(arr, left, mid);\r\n    const rightSum = maxSubarray(arr, mid + 1, right);\r\n    const crossSum = maxCrossingSum(arr, left, mid, right);\r\n    \r\n    // Combine\r\n    return Math.max(leftSum, rightSum, crossSum);\r\n}\r\n\r\nfunction maxCrossingSum(arr, left, mid, right) {\r\n    let sum = 0;\r\n    let leftSum = -Infinity;\r\n    let rightSum = -Infinity;\r\n    \r\n    // Find maximum sum for left half\r\n    for (let i = mid; i >= left; i--) {\r\n        sum += arr[i];\r\n        leftSum = Math.max(leftSum, sum);\r\n    }\r\n    \r\n    // Find maximum sum for right half\r\n    sum = 0;\r\n    for (let i = mid + 1; i <= right; i++) {\r\n        sum += arr[i];\r\n        rightSum = Math.max(rightSum, sum);\r\n    }\r\n    \r\n    return leftSum + rightSum;\r\n}\r\n\r\n// Usage\r\nconsole.log(maxSubarray([-2, 1, -3, 4, -1, 2, 1, -5, 4]));\r\n// Output: 6 (subarray [4, -1, 2, 1])\n"})}),"\n",(0,i.jsx)(n.h3,{id:"4-quick-sort",children:"4. Quick Sort"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"function quickSort(arr, left = 0, right = arr.length - 1) {\r\n    if (left < right) {\r\n        // Divide\r\n        const pivotIndex = partition(arr, left, right);\r\n        \r\n        // Conquer\r\n        quickSort(arr, left, pivotIndex - 1);\r\n        quickSort(arr, pivotIndex + 1, right);\r\n    }\r\n    return arr;\r\n}\r\n\r\nfunction partition(arr, left, right) {\r\n    const pivot = arr[right];\r\n    let i = left - 1;\r\n    \r\n    for (let j = left; j < right; j++) {\r\n        if (arr[j] <= pivot) {\r\n            i++;\r\n            [arr[i], arr[j]] = [arr[j], arr[i]];\r\n        }\r\n    }\r\n    \r\n    [arr[i + 1], arr[right]] = [arr[right], arr[i + 1]];\r\n    return i + 1;\r\n}\r\n\r\n// Usage\r\nconsole.log(quickSort([64, 34, 25, 12, 22, 11, 90]));\r\n// Output: [11, 12, 22, 25, 34, 64, 90]\n"})}),"\n",(0,i.jsx)(n.h2,{id:"time-complexity-analysis",children:"Time Complexity Analysis"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Algorithm"}),(0,i.jsx)(n.th,{children:"Average Case"}),(0,i.jsx)(n.th,{children:"Worst Case"}),(0,i.jsx)(n.th,{children:"Space Complexity"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Merge Sort"}),(0,i.jsx)(n.td,{children:"O(n log n)"}),(0,i.jsx)(n.td,{children:"O(n log n)"}),(0,i.jsx)(n.td,{children:"O(n)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Quick Sort"}),(0,i.jsx)(n.td,{children:"O(n log n)"}),(0,i.jsx)(n.td,{children:"O(n\xb2)"}),(0,i.jsx)(n.td,{children:"O(log n)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Binary Search"}),(0,i.jsx)(n.td,{children:"O(log n)"}),(0,i.jsx)(n.td,{children:"O(log n)"}),(0,i.jsx)(n.td,{children:"O(1)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Maximum Subarray"}),(0,i.jsx)(n.td,{children:"O(n log n)"}),(0,i.jsx)(n.td,{children:"O(n log n)"}),(0,i.jsx)(n.td,{children:"O(log n)"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"when-to-use-divide-and-conquer",children:"When to Use Divide and Conquer"}),"\n",(0,i.jsx)(n.h3,{id:"good-use-cases",children:"Good Use Cases:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Sorting large datasets"}),"\n",(0,i.jsx)(n.li,{children:"Searching in sorted arrays"}),"\n",(0,i.jsx)(n.li,{children:"Matrix multiplication"}),"\n",(0,i.jsx)(n.li,{children:"Finding closest pair of points"}),"\n",(0,i.jsx)(n.li,{children:"Computing Fibonacci numbers"}),"\n",(0,i.jsx)(n.li,{children:"Finding maximum/minimum"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"advantages",children:"Advantages:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Solves complex problems by breaking them down"}),"\n",(0,i.jsx)(n.li,{children:"Often leads to efficient solutions"}),"\n",(0,i.jsx)(n.li,{children:"Parallelization potential"}),"\n",(0,i.jsx)(n.li,{children:"Reusable solutions for similar problems"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"disadvantages",children:"Disadvantages:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Recursive nature can use more space"}),"\n",(0,i.jsx)(n.li,{children:"May be overkill for simple problems"}),"\n",(0,i.jsx)(n.li,{children:"Overhead in dividing and combining steps"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"implementation-template",children:"Implementation Template"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"function divideAndConquer(problem) {\r\n    // Base case\r\n    if (problem is small enough) {\r\n        return solve(problem);\r\n    }\r\n    \r\n    // Divide\r\n    subproblems = divide(problem);\r\n    \r\n    // Conquer\r\n    subSolutions = subproblems.map(subproblem => \r\n        divideAndConquer(subproblem)\r\n    );\r\n    \r\n    // Combine\r\n    return combine(subSolutions);\r\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"count-inversions-in-an-array",children:"Count Inversions in an array"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-JavaScript",children:"/**\r\n * Problem: Count Inversions in an array\r\n * An inversion occurs when a[i] > a[j] where i < j\r\n * Uses divide and conquer approach similar to merge sort\r\n */\r\nfunction countInversions(arr) {\r\n    // Base case\r\n    if (arr.length <= 1) return { \r\n        sortedArr: arr, \r\n        count: 0 \r\n    };\r\n    \r\n    // Divide\r\n    const mid = Math.floor(arr.length / 2);\r\n    const left = arr.slice(0, mid);\r\n    const right = arr.slice(mid);\r\n    \r\n    // Conquer\r\n    const leftResult = countInversions(left);\r\n    const rightResult = countInversions(right);\r\n    \r\n    // Combine\r\n    return mergeAndCount(leftResult.sortedArr, rightResult.sortedArr, \r\n                        leftResult.count + rightResult.count);\r\n}\r\n\r\nfunction mergeAndCount(left, right, count) {\r\n    const result = [];\r\n    let i = 0, j = 0;\r\n    \r\n    while (i < left.length && j < right.length) {\r\n        if (left[i] <= right[j]) {\r\n            result.push(left[i++]);\r\n        } else {\r\n            // Inversion found: all elements from i to left.length are inversions\r\n            count += left.length - i;\r\n            result.push(right[j++]);\r\n        }\r\n    }\r\n    \r\n    return {\r\n        sortedArr: result.concat(left.slice(i)).concat(right.slice(j)),\r\n        count: count\r\n    };\r\n}\r\n\r\n// Example usage\r\nconst arr = [8, 4, 2, 1];\r\nconsole.log(countInversions(arr));\r\n// Output: { sortedArr: [1, 2, 4, 8], count: 6 }\r\n// Inversions are: (8,4), (8,2), (8,1), (4,2), (4,1), (2,1)\n"})})]})}function u(r={}){const{wrapper:n}={...(0,t.R)(),...r.components};return n?(0,i.jsx)(n,{...r,children:(0,i.jsx)(c,{...r})}):c(r)}},8453:(r,n,e)=>{e.d(n,{R:()=>l,x:()=>a});var i=e(6540);const t={},s=i.createContext(t);function l(r){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof r?r(n):{...n,...r}}),[n,r])}function a(r){let n;return n=r.disableParentContext?"function"==typeof r.components?r.components(t):r.components||t:l(r.components),i.createElement(s.Provider,{value:n},r.children)}}}]);