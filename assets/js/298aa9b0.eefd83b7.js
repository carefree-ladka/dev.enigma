"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[9657],{23953:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var t=r(74848),a=r(28453);const i={},l="Java Multithreading",s={id:"Java/JavaMultithreading",title:"Java Multithreading",description:"Table of Contents",source:"@site/docs/Java/JavaMultithreading.mdx",sourceDirName:"Java",slug:"/Java/JavaMultithreading",permalink:"/js.enigma/docs/Java/JavaMultithreading",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/Java/JavaMultithreading.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Java Iterator",permalink:"/js.enigma/docs/Java/JavaIterator"},next:{title:"Java Object-Oriented Programming",permalink:"/js.enigma/docs/Java/JavaOOP"}},o={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Introduction to Multithreading",id:"introduction",level:2},{value:"Key Benefits",id:"key-benefits",level:3},{value:"Real-world Analogy",id:"real-world-analogy",level:3},{value:"Thread Basics",id:"thread-basics",level:2},{value:"What is a Thread?",id:"what-is-a-thread",level:3},{value:"Process vs Thread",id:"process-vs-thread",level:3},{value:"Creating Threads",id:"creating-threads",level:2},{value:"Method 1: Extending Thread Class",id:"method-1-extending-thread-class",level:3},{value:"Method 2: Implementing Runnable Interface (Preferred)",id:"method-2-implementing-runnable-interface-preferred",level:3},{value:"Method 3: Using Lambda Expressions (Java 8+)",id:"method-3-using-lambda-expressions-java-8",level:3},{value:"Thread Lifecycle",id:"thread-lifecycle",level:2},{value:"Thread States Example",id:"thread-states-example",level:3},{value:"Thread Synchronization",id:"synchronization",level:2},{value:"The Problem: Race Conditions",id:"the-problem-race-conditions",level:3},{value:"Solution 1: Synchronized Methods",id:"solution-1-synchronized-methods",level:3},{value:"Solution 2: Using Locks (More Flexible)",id:"solution-2-using-locks-more-flexible",level:3},{value:"Solution 3: Atomic Classes (Best for Simple Operations)",id:"solution-3-atomic-classes-best-for-simple-operations",level:3},{value:"Common Multithreading Problems",id:"problems",level:2},{value:"1. Producer-Consumer Problem",id:"1-producer-consumer-problem",level:3},{value:"2. Deadlock Example and Prevention",id:"2-deadlock-example-and-prevention",level:3},{value:"Advanced Concepts",id:"advanced-concepts",level:2},{value:"Thread Pools with ExecutorService",id:"thread-pools-with-executorservice",level:3},{value:"Callable and Future (Tasks that return values)",id:"callable-and-future-tasks-that-return-values",level:3},{value:"CompletableFuture (Modern Asynchronous Programming)",id:"completablefuture-modern-asynchronous-programming",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Prefer High-level Concurrency Utilities",id:"1-prefer-high-level-concurrency-utilities",level:3},{value:"2. Always Handle InterruptedException Properly",id:"2-always-handle-interruptedexception-properly",level:3},{value:"3. Use Immutable Objects When Possible",id:"3-use-immutable-objects-when-possible",level:3},{value:"4. Prefer Concurrent Collections",id:"4-prefer-concurrent-collections",level:3},{value:"JavaScript vs Java Concurrency",id:"js-comparison",level:2},{value:"Key Differences",id:"key-differences",level:3},{value:"JavaScript Async Pattern vs Java Threading",id:"javascript-async-pattern-vs-java-threading",level:3},{value:"When to Use What",id:"when-to-use-what",level:3},{value:"Summary",id:"summary",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"java-multithreading",children:"Java Multithreading"})}),"\n",(0,t.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#introduction",children:"Introduction to Multithreading"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#thread-basics",children:"Thread Basics"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#creating-threads",children:"Creating Threads"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#thread-lifecycle",children:"Thread Lifecycle"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#synchronization",children:"Thread Synchronization"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#problems",children:"Common Multithreading Problems"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#advanced-concepts",children:"Advanced Concepts"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#best-practices",children:"Best Practices"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#js-comparison",children:"JavaScript vs Java Concurrency"})}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"introduction",children:"Introduction to Multithreading"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Multithreading"})," is the ability of a program to execute multiple threads concurrently. Each thread represents an independent path of execution within the same process."]}),"\n",(0,t.jsx)(n.h3,{id:"key-benefits",children:"Key Benefits"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Improved Performance"}),": Parallel execution on multi-core systems"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Better Resource Utilization"}),": CPU can work on other threads while some are blocked"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Responsiveness"}),": UI remains responsive while background tasks run"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Modularity"}),": Different tasks can be separated into different threads"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"real-world-analogy",children:"Real-world Analogy"}),"\n",(0,t.jsx)(n.p,{children:"Think of multithreading like a restaurant kitchen:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Single-threaded"}),": One chef does everything sequentially"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Multi-threaded"}),": Multiple chefs work on different dishes simultaneously"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"thread-basics",children:"Thread Basics"}),"\n",(0,t.jsx)(n.h3,{id:"what-is-a-thread",children:"What is a Thread?"}),"\n",(0,t.jsx)(n.p,{children:"A thread is a lightweight subprocess that shares memory space with other threads in the same process but has its own:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Program counter"}),"\n",(0,t.jsx)(n.li,{children:"Stack"}),"\n",(0,t.jsx)(n.li,{children:"Set of registers"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"process-vs-thread",children:"Process vs Thread"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Process (Restaurant)\n\u251c\u2500\u2500 Memory Space (Kitchen)\n\u251c\u2500\u2500 Thread 1 (Chef 1) - Own stack, registers\n\u251c\u2500\u2500 Thread 2 (Chef 2) - Own stack, registers\n\u2514\u2500\u2500 Thread 3 (Chef 3) - Own stack, registers\n"})}),"\n",(0,t.jsx)(n.h2,{id:"creating-threads",children:"Creating Threads"}),"\n",(0,t.jsx)(n.h3,{id:"method-1-extending-thread-class",children:"Method 1: Extending Thread Class"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'class MyThread extends Thread {\n    private String threadName;\n\n    public MyThread(String name) {\n        this.threadName = name;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 1; i <= 5; i++) {\n            System.out.println(threadName + " - Count: " + i);\n            try {\n                Thread.sleep(1000); // Sleep for 1 second\n            } catch (InterruptedException e) {\n                System.out.println(threadName + " was interrupted");\n                return;\n            }\n        }\n        System.out.println(threadName + " finished");\n    }\n}\n\n// Usage\npublic class ThreadExample1 {\n    public static void main(String[] args) {\n        MyThread thread1 = new MyThread("Worker-1");\n        MyThread thread2 = new MyThread("Worker-2");\n\n        thread1.start(); // Don\'t call run() directly!\n        thread2.start();\n\n        System.out.println("Main thread continues...");\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"method-2-implementing-runnable-interface-preferred",children:"Method 2: Implementing Runnable Interface (Preferred)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'class MyTask implements Runnable {\n    private String taskName;\n\n    public MyTask(String name) {\n        this.taskName = name;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 1; i <= 5; i++) {\n            System.out.println(taskName + " executing step " + i);\n            try {\n                Thread.sleep(800);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt(); // Restore interrupted status\n                return;\n            }\n        }\n    }\n}\n\n// Usage\npublic class ThreadExample2 {\n    public static void main(String[] args) {\n        Thread thread1 = new Thread(new MyTask("Database-Sync"));\n        Thread thread2 = new Thread(new MyTask("File-Processing"));\n\n        thread1.start();\n        thread2.start();\n\n        // Wait for both threads to complete\n        try {\n            thread1.join();\n            thread2.join();\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n\n        System.out.println("All tasks completed!");\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"method-3-using-lambda-expressions-java-8",children:"Method 3: Using Lambda Expressions (Java 8+)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'public class LambdaThreadExample {\n    public static void main(String[] args) {\n        // Simple task\n        Thread thread1 = new Thread(() -> {\n            for (int i = 0; i < 5; i++) {\n                System.out.println("Lambda thread: " + i);\n                try {\n                    Thread.sleep(500);\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                    break;\n                }\n            }\n        });\n\n        // More complex task\n        Thread thread2 = new Thread(() -> {\n            String threadName = Thread.currentThread().getName();\n            System.out.println("Starting " + threadName);\n\n            // Simulate some work\n            int sum = 0;\n            for (int i = 1; i <= 100; i++) {\n                sum += i;\n            }\n\n            System.out.println(threadName + " calculated sum: " + sum);\n        });\n\n        thread1.start();\n        thread2.start();\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"thread-lifecycle",children:"Thread Lifecycle"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"NEW \u2192 RUNNABLE \u2192 BLOCKED/WAITING/TIMED_WAITING \u2192 TERMINATED\n \u2193        \u2193           \u2193                           \u2193\nCreated   Running    Suspended                  Finished\n"})}),"\n",(0,t.jsx)(n.h3,{id:"thread-states-example",children:"Thread States Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'public class ThreadStateDemo {\n    public static void main(String[] args) throws InterruptedException {\n        Thread worker = new Thread(() -> {\n            try {\n                System.out.println("Worker started");\n                Thread.sleep(2000); // TIMED_WAITING\n                System.out.println("Worker finished");\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n        });\n\n        System.out.println("1. State: " + worker.getState()); // NEW\n\n        worker.start();\n        System.out.println("2. State: " + worker.getState()); // RUNNABLE\n\n        Thread.sleep(100);\n        System.out.println("3. State: " + worker.getState()); // TIMED_WAITING\n\n        worker.join(); // Wait for completion\n        System.out.println("4. State: " + worker.getState()); // TERMINATED\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"synchronization",children:"Thread Synchronization"}),"\n",(0,t.jsx)(n.h3,{id:"the-problem-race-conditions",children:"The Problem: Race Conditions"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'class UnsafeCounter {\n    private int count = 0;\n\n    public void increment() {\n        count++; // Not atomic! Can cause race conditions\n    }\n\n    public int getCount() {\n        return count;\n    }\n}\n\n// Demonstrating race condition\npublic class RaceConditionDemo {\n    public static void main(String[] args) throws InterruptedException {\n        UnsafeCounter counter = new UnsafeCounter();\n\n        // Create 100 threads, each incrementing 1000 times\n        Thread[] threads = new Thread[100];\n        for (int i = 0; i < threads.length; i++) {\n            threads[i] = new Thread(() -> {\n                for (int j = 0; j < 1000; j++) {\n                    counter.increment();\n                }\n            });\n        }\n\n        // Start all threads\n        for (Thread thread : threads) {\n            thread.start();\n        }\n\n        // Wait for all threads\n        for (Thread thread : threads) {\n            thread.join();\n        }\n\n        System.out.println("Expected: 100000");\n        System.out.println("Actual: " + counter.getCount()); // Likely less than 100000\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"solution-1-synchronized-methods",children:"Solution 1: Synchronized Methods"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"class SafeCounter {\n    private int count = 0;\n\n    public synchronized void increment() {\n        count++; // Now thread-safe\n    }\n\n    public synchronized int getCount() {\n        return count;\n    }\n\n    // Alternative: synchronized block\n    public void incrementWithBlock() {\n        synchronized (this) {\n            count++;\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"solution-2-using-locks-more-flexible",children:"Solution 2: Using Locks (More Flexible)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"import java.util.concurrent.locks.ReentrantLock;\n\nclass AdvancedCounter {\n    private int count = 0;\n    private final ReentrantLock lock = new ReentrantLock();\n\n    public void increment() {\n        lock.lock(); // Acquire lock\n        try {\n            count++;\n        } finally {\n            lock.unlock(); // Always release in finally block\n        }\n    }\n\n    public int getCount() {\n        lock.lock();\n        try {\n            return count;\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    // Try to acquire lock without blocking\n    public boolean tryIncrement() {\n        if (lock.tryLock()) {\n            try {\n                count++;\n                return true;\n            } finally {\n                lock.unlock();\n            }\n        }\n        return false; // Could not acquire lock\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"solution-3-atomic-classes-best-for-simple-operations",children:"Solution 3: Atomic Classes (Best for Simple Operations)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"import java.util.concurrent.atomic.AtomicInteger;\n\nclass AtomicCounter {\n    private AtomicInteger count = new AtomicInteger(0);\n\n    public void increment() {\n        count.incrementAndGet(); // Thread-safe, lock-free\n    }\n\n    public int getCount() {\n        return count.get();\n    }\n\n    // Atomic compare-and-swap\n    public boolean incrementIfLessThan(int limit) {\n        int current = count.get();\n        return current < limit && count.compareAndSet(current, current + 1);\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"problems",children:"Common Multithreading Problems"}),"\n",(0,t.jsx)(n.h3,{id:"1-producer-consumer-problem",children:"1. Producer-Consumer Problem"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'import java.util.LinkedList;\nimport java.util.Queue;\n\nclass ProducerConsumer {\n    private final Queue<Integer> queue = new LinkedList<>();\n    private final int CAPACITY = 5;\n    private final Object lock = new Object();\n\n    public void produce(int item) throws InterruptedException {\n        synchronized (lock) {\n            // Wait while queue is full\n            while (queue.size() == CAPACITY) {\n                System.out.println("Queue full, producer waiting...");\n                lock.wait(); // Release lock and wait\n            }\n\n            queue.offer(item);\n            System.out.println("Produced: " + item + " (Queue size: " + queue.size() + ")");\n            lock.notifyAll(); // Notify waiting consumers\n        }\n    }\n\n    public int consume() throws InterruptedException {\n        synchronized (lock) {\n            // Wait while queue is empty\n            while (queue.isEmpty()) {\n                System.out.println("Queue empty, consumer waiting...");\n                lock.wait();\n            }\n\n            int item = queue.poll();\n            System.out.println("Consumed: " + item + " (Queue size: " + queue.size() + ")");\n            lock.notifyAll(); // Notify waiting producers\n            return item;\n        }\n    }\n}\n\n// Usage\npublic class ProducerConsumerDemo {\n    public static void main(String[] args) {\n        ProducerConsumer pc = new ProducerConsumer();\n\n        // Producer thread\n        Thread producer = new Thread(() -> {\n            try {\n                for (int i = 1; i <= 10; i++) {\n                    pc.produce(i);\n                    Thread.sleep(100);\n                }\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n        });\n\n        // Consumer thread\n        Thread consumer = new Thread(() -> {\n            try {\n                for (int i = 1; i <= 10; i++) {\n                    pc.consume();\n                    Thread.sleep(200); // Consume slower than produce\n                }\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n        });\n\n        producer.start();\n        consumer.start();\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"2-deadlock-example-and-prevention",children:"2. Deadlock Example and Prevention"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'class DeadlockDemo {\n    private final Object lock1 = new Object();\n    private final Object lock2 = new Object();\n\n    public void method1() {\n        synchronized (lock1) {\n            System.out.println("Thread " + Thread.currentThread().getName() + " acquired lock1");\n            try {\n                Thread.sleep(100);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n\n            synchronized (lock2) { // Potential deadlock here\n                System.out.println("Thread " + Thread.currentThread().getName() + " acquired lock2");\n            }\n        }\n    }\n\n    public void method2() {\n        synchronized (lock2) {\n            System.out.println("Thread " + Thread.currentThread().getName() + " acquired lock2");\n            try {\n                Thread.sleep(100);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n\n            synchronized (lock1) { // Potential deadlock here\n                System.out.println("Thread " + Thread.currentThread().getName() + " acquired lock1");\n            }\n        }\n    }\n\n    // Deadlock prevention: Always acquire locks in same order\n    public void safeMethod1() {\n        synchronized (lock1) {\n            synchronized (lock2) {\n                // Safe: consistent lock ordering\n            }\n        }\n    }\n\n    public void safeMethod2() {\n        synchronized (lock1) { // Same order as safeMethod1\n            synchronized (lock2) {\n                // Safe: consistent lock ordering\n            }\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"advanced-concepts",children:"Advanced Concepts"}),"\n",(0,t.jsx)(n.h3,{id:"thread-pools-with-executorservice",children:"Thread Pools with ExecutorService"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'import java.util.concurrent.*;\n\npublic class ThreadPoolExample {\n    public static void main(String[] args) {\n        // Create thread pool with 3 threads\n        ExecutorService executor = Executors.newFixedThreadPool(3);\n\n        // Submit tasks\n        for (int i = 1; i <= 10; i++) {\n            final int taskId = i;\n            executor.submit(() -> {\n                String threadName = Thread.currentThread().getName();\n                System.out.println("Task " + taskId + " executed by " + threadName);\n\n                try {\n                    Thread.sleep(1000); // Simulate work\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                }\n            });\n        }\n\n        executor.shutdown(); // Don\'t accept new tasks\n\n        try {\n            // Wait for existing tasks to complete\n            if (!executor.awaitTermination(10, TimeUnit.SECONDS)) {\n                executor.shutdownNow(); // Force shutdown\n            }\n        } catch (InterruptedException e) {\n            executor.shutdownNow();\n            Thread.currentThread().interrupt();\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"callable-and-future-tasks-that-return-values",children:"Callable and Future (Tasks that return values)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'import java.util.concurrent.*;\nimport java.util.List;\nimport java.util.Arrays;\n\npublic class CallableFutureExample {\n    public static void main(String[] args) {\n        ExecutorService executor = Executors.newFixedThreadPool(2);\n\n        // Create callable tasks\n        Callable<Integer> task1 = () -> {\n            Thread.sleep(2000);\n            return 42;\n        };\n\n        Callable<String> task2 = () -> {\n            Thread.sleep(1000);\n            return "Hello from callable!";\n        };\n\n        try {\n            // Submit and get Future objects\n            Future<Integer> future1 = executor.submit(task1);\n            Future<String> future2 = executor.submit(task2);\n\n            // Do other work while tasks execute\n            System.out.println("Tasks submitted, doing other work...");\n            Thread.sleep(500);\n\n            // Get results (blocks until complete)\n            Integer result1 = future1.get(); // Blocks for ~1.5 more seconds\n            String result2 = future2.get();  // Already complete\n\n            System.out.println("Result 1: " + result1);\n            System.out.println("Result 2: " + result2);\n\n            // Execute multiple tasks and wait for all\n            List<Callable<Integer>> tasks = Arrays.asList(\n                () -> { Thread.sleep(1000); return 1; },\n                () -> { Thread.sleep(1500); return 2; },\n                () -> { Thread.sleep(800); return 3; }\n            );\n\n            List<Future<Integer>> futures = executor.invokeAll(tasks);\n            System.out.println("All parallel tasks completed:");\n\n            for (int i = 0; i < futures.size(); i++) {\n                System.out.println("Task " + (i + 1) + " result: " + futures.get(i).get());\n            }\n\n        } catch (InterruptedException | ExecutionException e) {\n            e.printStackTrace();\n        } finally {\n            executor.shutdown();\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"completablefuture-modern-asynchronous-programming",children:"CompletableFuture (Modern Asynchronous Programming)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'import java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutionException;\n\npublic class CompletableFutureExample {\n    public static void main(String[] args) {\n        // Simple async task\n        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n            return "Hello";\n        });\n\n        // Chain operations\n        CompletableFuture<String> result = future\n            .thenApply(s -> s + " World") // Transform result\n            .thenApply(String::toUpperCase); // Another transformation\n\n        // Non-blocking callback\n        result.thenAccept(s -> System.out.println("Result: " + s));\n\n        // Combining multiple futures\n        CompletableFuture<Integer> future1 = CompletableFuture.supplyAsync(() -> 10);\n        CompletableFuture<Integer> future2 = CompletableFuture.supplyAsync(() -> 20);\n\n        CompletableFuture<Integer> combined = future1.thenCombine(future2, (a, b) -> a + b);\n\n        try {\n            System.out.println("Combined result: " + combined.get());\n            System.out.println("Final result: " + result.get());\n        } catch (InterruptedException | ExecutionException e) {\n            e.printStackTrace();\n        }\n\n        // Handle errors\n        CompletableFuture<String> errorHandling = CompletableFuture.supplyAsync(() -> {\n            if (Math.random() > 0.5) {\n                throw new RuntimeException("Random error!");\n            }\n            return "Success";\n        }).exceptionally(ex -> "Error occurred: " + ex.getMessage());\n\n        try {\n            System.out.println("Error handling result: " + errorHandling.get());\n        } catch (InterruptedException | ExecutionException e) {\n            e.printStackTrace();\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsx)(n.h3,{id:"1-prefer-high-level-concurrency-utilities",children:"1. Prefer High-level Concurrency Utilities"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// \u274c Don't: Manual thread management\nThread thread = new Thread(() -> processData());\nthread.start();\n\n// \u2705 Do: Use ExecutorService\nExecutorService executor = Executors.newCachedThreadPool();\nexecutor.submit(() -> processData());\n"})}),"\n",(0,t.jsx)(n.h3,{id:"2-always-handle-interruptedexception-properly",children:"2. Always Handle InterruptedException Properly"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// \u274c Don't: Swallow interruption\ntry {\n    Thread.sleep(1000);\n} catch (InterruptedException e) {\n    // Ignored - BAD!\n}\n\n// \u2705 Do: Restore interrupt status\ntry {\n    Thread.sleep(1000);\n} catch (InterruptedException e) {\n    Thread.currentThread().interrupt(); // Restore status\n    return; // Exit gracefully\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"3-use-immutable-objects-when-possible",children:"3. Use Immutable Objects When Possible"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"public final class ImmutableCounter {\n    private final int value;\n\n    public ImmutableCounter(int value) {\n        this.value = value;\n    }\n\n    public int getValue() {\n        return value;\n    }\n\n    public ImmutableCounter increment() {\n        return new ImmutableCounter(value + 1); // Return new instance\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"4-prefer-concurrent-collections",children:"4. Prefer Concurrent Collections"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"import java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\n// \u274c Don't: Regular collections with external synchronization\nMap<String, String> map = Collections.synchronizedMap(new HashMap<>());\n\n// \u2705 Do: Use concurrent collections\nMap<String, String> concurrentMap = new ConcurrentHashMap<>();\nList<String> concurrentList = new CopyOnWriteArrayList<>();\n"})}),"\n",(0,t.jsx)(n.h2,{id:"js-comparison",children:"JavaScript vs Java Concurrency"}),"\n",(0,t.jsx)(n.h3,{id:"key-differences",children:"Key Differences"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Aspect"}),(0,t.jsx)(n.th,{children:"JavaScript"}),(0,t.jsx)(n.th,{children:"Java"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Model"})}),(0,t.jsx)(n.td,{children:"Event Loop (Single-threaded)"}),(0,t.jsx)(n.td,{children:"True Multithreading"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Concurrency"})}),(0,t.jsx)(n.td,{children:"Asynchronous (Promises, async/await)"}),(0,t.jsx)(n.td,{children:"Threads, Thread Pools"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Shared State"})}),(0,t.jsx)(n.td,{children:"No shared memory issues"}),(0,t.jsx)(n.td,{children:"Requires synchronization"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Blocking"})}),(0,t.jsx)(n.td,{children:"Non-blocking I/O"}),(0,t.jsx)(n.td,{children:"Can have blocking operations"})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"javascript-async-pattern-vs-java-threading",children:"JavaScript Async Pattern vs Java Threading"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// JavaScript - Asynchronous but single-threaded\nasync function fetchData() {\n    try {\n        const response = await fetch('/api/data');\n        const data = await response.json();\n        console.log('Data received:', data);\n    } catch (error) {\n        console.error('Error:', error);\n    }\n}\n\n// Multiple async operations\nPromise.all([\n    fetchData('/api/users'),\n    fetchData('/api/posts'),\n    fetchData('/api/comments')\n]).then(results => {\n    console.log('All data loaded');\n});\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// Java - True parallel execution\n// Using CompletableFuture (similar to JavaScript Promises)\nCompletableFuture<String> fetchData(String url) {\n    return CompletableFuture.supplyAsync(() -> {\n        // Simulate HTTP call in separate thread\n        try {\n            Thread.sleep(1000); // Network delay\n            return "Data from " + url;\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException(e);\n        }\n    });\n}\n\n// Multiple parallel operations\nCompletableFuture<Void> allData = CompletableFuture.allOf(\n    fetchData("/api/users"),\n    fetchData("/api/posts"),\n    fetchData("/api/comments")\n);\n\nallData.thenRun(() -> System.out.println("All data loaded"));\n'})}),"\n",(0,t.jsx)(n.h3,{id:"when-to-use-what",children:"When to Use What"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Use JavaScript-style async/await when:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Dealing with I/O operations"}),"\n",(0,t.jsx)(n.li,{children:"Working with APIs and databases"}),"\n",(0,t.jsx)(n.li,{children:"Building responsive UIs"}),"\n",(0,t.jsx)(n.li,{children:"Single-threaded environment constraints"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Use Java multithreading when:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"CPU-intensive calculations"}),"\n",(0,t.jsx)(n.li,{children:"True parallel processing needed"}),"\n",(0,t.jsx)(n.li,{children:"Multiple cores should be utilized"}),"\n",(0,t.jsx)(n.li,{children:"Complex concurrent data structures required"}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(n.p,{children:"Java multithreading provides powerful tools for concurrent programming:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Basic Threading"}),": Extend Thread or implement Runnable"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Synchronization"}),": synchronized, locks, atomic classes"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"High-level APIs"}),": ExecutorService, CompletableFuture"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Thread Safety"}),": Immutable objects, concurrent collections"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Best Practices"}),": Proper error handling, resource management"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The key is choosing the right tool for your specific use case and always considering thread safety from the beginning of your design."})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>s});var t=r(96540);const a={},i=t.createContext(a);function l(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:l(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);