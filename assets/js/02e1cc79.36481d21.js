"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[6893],{28453:(n,e,i)=>{i.d(e,{R:()=>l,x:()=>a});var s=i(96540);const r={},t=s.createContext(r);function l(n){const e=s.useContext(t);return s.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:l(n.components),s.createElement(t.Provider,{value:e},n.children)}},82260:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>a,toc:()=>c});var s=i(74848),r=i(28453);const t={title:"Bit Manipulation Basics"},l=void 0,a={id:"DSA/DSA with JavaScript/BitManipulation",title:"Bit Manipulation Basics",description:"Bit Manipulation Basics",source:"@site/docs/DSA/DSA with JavaScript/BitManipulation.mdx",sourceDirName:"DSA/DSA with JavaScript",slug:"/DSA/DSA with JavaScript/BitManipulation",permalink:"/dev.enigma/docs/DSA/DSA with JavaScript/BitManipulation",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with JavaScript/BitManipulation.mdx",tags:[],version:"current",frontMatter:{title:"Bit Manipulation Basics"},sidebar:"tutorialSidebar",previous:{title:"Binary Search Tree (BST)",permalink:"/dev.enigma/docs/DSA/DSA with JavaScript/BinaryTree"},next:{title:"Boyer\u2013Moore Majority Vote Algorithm",permalink:"/dev.enigma/docs/DSA/DSA with JavaScript/BoyerMoore"}},o={},c=[{value:"Bit Manipulation Basics",id:"bit-manipulation-basics",level:2},{value:"Basic Bitwise Operators",id:"basic-bitwise-operators",level:3},{value:"Common Bit Manipulation Techniques",id:"common-bit-manipulation-techniques",level:3},{value:"Use Cases",id:"use-cases",level:3},{value:"Basic Properties of XOR",id:"basic-properties-of-xor",level:2},{value:"1. Fundamental Rules",id:"1-fundamental-rules",level:3},{value:"2. Important Properties",id:"2-important-properties",level:3},{value:"Common XOR Patterns in Coding Problems",id:"common-xor-patterns-in-coding-problems",level:2},{value:"1. Find Single Number",id:"1-find-single-number",level:3},{value:"2. Find Two Single Numbers",id:"2-find-two-single-numbers",level:3},{value:"3. Missing Number",id:"3-missing-number",level:3},{value:"4. Finding Duplicate Number",id:"4-finding-duplicate-number",level:3},{value:"Advanced XOR Applications",id:"advanced-xor-applications",level:2},{value:"1. Bit Manipulation with XOR",id:"1-bit-manipulation-with-xor",level:3},{value:"2. XOR for Encryption/Decryption",id:"2-xor-for-encryptiondecryption",level:3},{value:"3. XOR in Matrix Operations",id:"3-xor-in-matrix-operations",level:3},{value:"Common Interview Problem Patterns",id:"common-interview-problem-patterns",level:2},{value:"1. Adjacent XOR Problems",id:"1-adjacent-xor-problems",level:3},{value:"2. XOR Sum Problems",id:"2-xor-sum-problems",level:3},{value:"3. XOR and Binary Trees",id:"3-xor-and-binary-trees",level:3},{value:"Performance Tips",id:"performance-tips",level:2},{value:"Common Pitfalls",id:"common-pitfalls",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.h2,{id:"bit-manipulation-basics",children:"Bit Manipulation Basics"}),"\n",(0,s.jsx)(e.p,{children:"Bit manipulation involves using bitwise operators to perform operations on binary representations of numbers. This technique is useful in various programming scenarios, including optimization, cryptography, and low-level data processing."}),"\n",(0,s.jsx)(e.h3,{id:"basic-bitwise-operators",children:"Basic Bitwise Operators"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsxs)(e.strong,{children:["AND (",(0,s.jsx)(e.code,{children:"&"}),")"]}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Description"}),": Performs a bitwise AND operation."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Example"}),":","\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"const a = 5; // 0101 in binary\nconst b = 3; // 0011 in binary\nconst result = a & b; // 0001 in binary (1 in decimal)\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsxs)(e.strong,{children:["OR (",(0,s.jsx)(e.code,{children:"|"}),")"]}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Description"}),": Performs a bitwise OR operation."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Example"}),":","\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"const a = 5; // 0101 in binary\nconst b = 3; // 0011 in binary\nconst result = a | b; // 0111 in binary (7 in decimal)\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsxs)(e.strong,{children:["XOR (",(0,s.jsx)(e.code,{children:"^"}),")"]}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Description"}),": Performs a bitwise XOR operation."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Example"}),":","\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"const a = 5; // 0101 in binary\nconst b = 3; // 0011 in binary\nconst result = a ^ b; // 0110 in binary (6 in decimal)\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsxs)(e.strong,{children:["NOT (",(0,s.jsx)(e.code,{children:"~"}),")"]}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Description"}),": Performs a bitwise NOT operation (inverts all bits)."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Example"}),":","\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"const a = 5; // 0101 in binary\nconst result = ~a; // 1010 in binary (in 32-bit system: -6 in decimal)\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsxs)(e.strong,{children:["Left Shift (",(0,s.jsx)(e.code,{children:"<<"}),")"]}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Description"}),": Shifts bits to the left, filling with zeros."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Example"}),":","\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"const a = 5; // 0101 in binary\nconst result = a << 1; // 1010 in binary (10 in decimal)\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsxs)(e.strong,{children:["Right Shift (",(0,s.jsx)(e.code,{children:">>"}),")"]}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Description"}),": Shifts bits to the right, preserving the sign bit."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Example"}),":","\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"const a = 5; // 0101 in binary\nconst result = a >> 1; // 0010 in binary (2 in decimal)\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsxs)(e.strong,{children:["Unsigned Right Shift (",(0,s.jsx)(e.code,{children:">>>"}),")"]}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Description"}),": Shifts bits to the right, filling with zeros (ignores the sign bit)."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Example"}),":","\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"const a = -5; // 1111111111111111111111111111011 in binary (32-bit)\nconst result = a >>> 1; // 0111111111111111111111111111101 in binary (2147483645 in decimal)\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"common-bit-manipulation-techniques",children:"Common Bit Manipulation Techniques"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Check if a Number is Even or Odd"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Description"}),": Use bitwise AND with ",(0,s.jsx)(e.code,{children:"1"}),"."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Example"}),":","\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"const isOdd = num => (num & 1) === 1;\nconst isEven = num => (num & 1) === 0;\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Toggle a Bit"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Description"}),": Use XOR with ",(0,s.jsx)(e.code,{children:"1"})," to flip the bit."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Example"}),":","\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"const toggleBit = (num, bitPosition) => num ^ (1 << bitPosition);\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Set a Bit"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Description"}),": Use OR with ",(0,s.jsx)(e.code,{children:"1"})," shifted to the bit position."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Example"}),":","\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"const setBit = (num, bitPosition) => num | (1 << bitPosition);\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Clear a Bit"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Description"}),": Use AND with the negation of ",(0,s.jsx)(e.code,{children:"1"})," shifted to the bit position."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Example"}),":","\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"const clearBit = (num, bitPosition) => num & ~(1 << bitPosition);\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Count Number of Set Bits (Hamming Weight)"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Description"}),": Count the number of ",(0,s.jsx)(e.code,{children:"1"}),"s in the binary representation."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Example"}),":","\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"const countSetBits = num => {\n  let count = 0;\n  while (num > 0) {\n    count += num & 1;\n    num >>= 1;\n  }\n  return count;\n};\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Brian Kernighan\u2019s Algorithm"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Description"}),": Efficiently counts the number of set bits in an integer. It repeatedly clears the least significant set bit and counts the number of operations."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Example"}),":","\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"const countSetBits = num => {\n  let count = 0;\n  while (num) {\n    num &= num - 1; // Clear the least significant bit set\n    count++;\n  }\n  return count;\n};\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Find the Rightmost Set Bit"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Description"}),": Use ",(0,s.jsx)(e.code,{children:"num & -num"}),"."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Example"}),":","\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"const rightmostSetBit = num => num & -num;\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Find the Position of the Rightmost Set Bit"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Description"}),": Use ",(0,s.jsx)(e.code,{children:"Math.log2(num & -num)"}),"."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Example"}),":","\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"const rightmostSetBitPosition = num => Math.log2(num & -num);\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Swap Two Numbers Without a Temporary Variable"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Description"}),": Use XOR to swap values."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Example"}),":","\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"const swap = (a, b) => {\n  a ^= b;\n  b ^= a;\n  a ^= b;\n};\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Clear All Bits from MSB to a Specific Bit"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Clear all bits from the most significant bit (MSB) to a specific position."})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-JavaScript",children:"let number = 13; // Binary: 1101\nlet position = 2;\n\nlet newNumber = number & ((1 << position) - 1);  //Formula\nconsole.log(newNumber); // Output: 1 (Binary: 0001)\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Clear All Bits from a Specific Bit to LSB"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Clear all bits from a specific position to the least significant bit (LSB)."})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-JavaScript",children:"let number = 13; // Binary: 1101\nlet position = 1;\n\nlet newNumber = number & ~((1 << (position + 1)) - 1);\nconsole.log(newNumber); // Output: 8 (Binary: 1000)\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Extract a Range of Bits"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Extract a specific range of bits (e.g., from start to end)."})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-JavaScript",children:"let number = 29; // Binary: 11101\nlet start = 1;\nlet end = 3;\n\nlet extracted = (number >> start) & ((1 << (end - start + 1)) - 1);\nconsole.log(extracted); // Output: 6 (Binary: 110)\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Set a Range of Bits"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Set a range of bits to 1."})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-JavaScript",children:"let number = 8; // Binary: 1000\nlet start = 1;\nlet end = 3;\n\nlet newNumber = number | (((1 << (end - start + 1)) - 1) << start);\nconsole.log(newNumber); // Output: 14 (Binary: 1110)\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"use-cases",children:"Use Cases"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Data Compression"}),": Efficiently store and manipulate data using bitwise operations."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Cryptography"}),": Implement cryptographic algorithms and protocols."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Network Protocols"}),": Handle and process network data at the bit level."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Performance Optimization"}),": Use bit manipulation for performance-critical code."]}),"\n"]}),"\n",(0,s.jsx)(e.h1,{id:"xor--operations-cheatsheet-for-coding-interviews",children:"XOR (^) Operations Cheatsheet for Coding Interviews"}),"\n",(0,s.jsx)(e.h2,{id:"basic-properties-of-xor",children:"Basic Properties of XOR"}),"\n",(0,s.jsx)(e.h3,{id:"1-fundamental-rules",children:"1. Fundamental Rules"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"// 1. XOR with 0\nx ^ 0 = x            // XOR with 0 returns the number itself\n\n// 2. XOR with itself\nx ^ x = 0            // XOR of a number with itself is 0\n\n// 3. XOR is commutative\na ^ b = b ^ a        // Order doesn't matter\n\n// 4. XOR is associative\n(a ^ b) ^ c = a ^ (b ^ c)  // Grouping doesn't matter\n\n// 5. XOR with 1\nx ^ 1 = ~x           // XOR with 1 flips the bits (ones complement)\n"})}),"\n",(0,s.jsx)(e.h3,{id:"2-important-properties",children:"2. Important Properties"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"// Self-inverse property\n(a ^ b) ^ b = a      // XORing twice with same number restores original value\n\n// Swapping values using XOR\na = a ^ b\nb = a ^ b            // Now b has original value of a\na = a ^ b            // Now a has original value of b\n\n// XOR of all bits\nfunction xorOfAllBits(n) {\n    switch(n % 4) {\n        case 0: return n;     // If n % 4 = 0, xor = n\n        case 1: return 1;     // If n % 4 = 1, xor = 1\n        case 2: return n + 1; // If n % 4 = 2, xor = n + 1\n        case 3: return 0;     // If n % 4 = 3, xor = 0\n    }\n}\n"})}),"\n",(0,s.jsx)(e.h2,{id:"common-xor-patterns-in-coding-problems",children:"Common XOR Patterns in Coding Problems"}),"\n",(0,s.jsx)(e.h3,{id:"1-find-single-number",children:"1. Find Single Number"}),"\n",(0,s.jsx)(e.p,{children:"Finding a number that appears once while others appear twice."}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function findSingle(arr) {\n  let result = 0;\n  for (let num of arr) {\n    result ^= num;\n  }\n  return result;\n}\n\n// Example\nconsole.log(findSingle([4, 1, 2, 1, 2])); // Output: 4\n"})}),"\n",(0,s.jsx)(e.h3,{id:"2-find-two-single-numbers",children:"2. Find Two Single Numbers"}),"\n",(0,s.jsx)(e.p,{children:"Finding two numbers that appear once while others appear twice."}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function findTwoSingle(arr) {\n  // 1. XOR all numbers\n  let xorResult = 0;\n  for (let num of arr) {\n    xorResult ^= num;\n  }\n\n  // 2. Find rightmost set bit in xorResult\n  let rightmostSetBit = 1;\n  while ((xorResult & rightmostSetBit) === 0) {\n    rightmostSetBit <<= 1;\n  }\n\n  // 3. Divide elements into two groups\n  let x = 0,\n    y = 0;\n  for (let num of arr) {\n    if (num & rightmostSetBit) {\n      x ^= num;\n    } else {\n      y ^= num;\n    }\n  }\n\n  return [x, y];\n}\n\n// Example\nconsole.log(findTwoSingle([1, 2, 1, 3, 2, 5])); // Output: [3,5]\n"})}),"\n",(0,s.jsx)(e.h3,{id:"3-missing-number",children:"3. Missing Number"}),"\n",(0,s.jsx)(e.p,{children:"Finding missing number in array containing n distinct numbers in range [0, n]."}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function findMissing(arr) {\n  let n = arr.length;\n  let result = n; // XOR with n first\n\n  for (let i = 0; i < n; i++) {\n    result ^= i ^ arr[i]; // XOR with both index and value\n  }\n\n  return result;\n}\n\n// Example\nconsole.log(findMissing([3, 0, 1])); // Output: 2\n"})}),"\n",(0,s.jsx)(e.h3,{id:"4-finding-duplicate-number",children:"4. Finding Duplicate Number"}),"\n",(0,s.jsx)(e.p,{children:"Finding duplicate in array where one number appears twice."}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function findDuplicate(arr) {\n  let result = 0;\n  // XOR all numbers from 1 to n-1\n  for (let i = 1; i < arr.length; i++) {\n    result ^= i;\n  }\n  // XOR with all array elements\n  for (let num of arr) {\n    result ^= num;\n  }\n  return result;\n}\n"})}),"\n",(0,s.jsx)(e.h2,{id:"advanced-xor-applications",children:"Advanced XOR Applications"}),"\n",(0,s.jsx)(e.h3,{id:"1-bit-manipulation-with-xor",children:"1. Bit Manipulation with XOR"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"// Toggle bits\nfunction toggleBit(num, pos) {\n  return num ^ (1 << pos);\n}\n\n// Check if bit is set\nfunction isBitSet(num, pos) {\n  return (num & (1 << pos)) !== 0;\n}\n\n// Count set bits using XOR\nfunction countSetBits(num) {\n  let count = 0;\n  while (num) {\n    num = num & (num - 1); // Clear rightmost set bit\n    count++;\n  }\n  return count;\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"2-xor-for-encryptiondecryption",children:"2. XOR for Encryption/Decryption"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function xorEncrypt(text, key) {\n  let encrypted = '';\n  for (let i = 0; i < text.length; i++) {\n    encrypted += String.fromCharCode(text.charCodeAt(i) ^ key);\n  }\n  return encrypted;\n}\n\n// Decryption is the same operation\nconst decrypt = xorEncrypt; // XOR is self-inverse\n"})}),"\n",(0,s.jsx)(e.h3,{id:"3-xor-in-matrix-operations",children:"3. XOR in Matrix Operations"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"// XOR of all elements in matrix\nfunction matrixXOR(matrix) {\n  let result = 0;\n  for (let row of matrix) {\n    for (let val of row) {\n      result ^= val;\n    }\n  }\n  return result;\n}\n\n// Check if row/column XOR is valid\nfunction isValidXORMatrix(matrix) {\n  const n = matrix.length;\n  for (let i = 0; i < n; i++) {\n    let rowXOR = 0,\n      colXOR = 0;\n    for (let j = 0; j < n; j++) {\n      rowXOR ^= matrix[i][j];\n      colXOR ^= matrix[j][i];\n    }\n    if (rowXOR !== colXOR) return false;\n  }\n  return true;\n}\n"})}),"\n",(0,s.jsx)(e.h2,{id:"common-interview-problem-patterns",children:"Common Interview Problem Patterns"}),"\n",(0,s.jsx)(e.h3,{id:"1-adjacent-xor-problems",children:"1. Adjacent XOR Problems"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"// Check if array can be derived from adjacent XOR\nfunction canDeriveFromAdjacent(derived) {\n  let original = 0;\n  for (let i = 0; i < derived.length - 1; i++) {\n    original ^= derived[i];\n  }\n  return derived[derived.length - 1] === (original ^ 0);\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"2-xor-sum-problems",children:"2. XOR Sum Problems"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"// Calculate XOR sum of all pairs\nfunction xorSumPairs(arr) {\n  let result = 0;\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = i + 1; j < arr.length; j++) {\n      result ^= arr[i] + arr[j];\n    }\n  }\n  return result;\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"3-xor-and-binary-trees",children:"3. XOR and Binary Trees"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"class TreeNode {\n  constructor(val) {\n    this.val = val;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// XOR of all values in binary tree\nfunction treeXOR(root) {\n  if (!root) return 0;\n  return root.val ^ treeXOR(root.left) ^ treeXOR(root.right);\n}\n"})}),"\n",(0,s.jsx)(e.h2,{id:"performance-tips",children:"Performance Tips"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"XOR operations are O(1)"}),"\n",(0,s.jsx)(e.li,{children:"XOR can often replace addition/subtraction for better performance"}),"\n",(0,s.jsx)(e.li,{children:"Using XOR for swapping saves memory (no temp variable needed)"}),"\n",(0,s.jsx)(e.li,{children:"XOR can be used to avoid using extra space in many algorithms"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"common-pitfalls",children:"Common Pitfalls"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"Remember that XOR is bitwise operation"}),"\n",(0,s.jsx)(e.li,{children:"Don't forget about operator precedence"}),"\n",(0,s.jsx)(e.li,{children:"Be careful with negative numbers"}),"\n",(0,s.jsx)(e.li,{children:"Test edge cases (0, maximum values)"}),"\n",(0,s.jsx)(e.li,{children:"Consider overflow in languages with fixed-size integers"}),"\n"]})]})}function h(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}}}]);