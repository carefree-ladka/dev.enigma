"use strict";(globalThis.webpackChunkdev_enigma=globalThis.webpackChunkdev_enigma||[]).push([[45472],{28453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>l});var a=r(96540);const t={},i=a.createContext(t);function s(e){const n=a.useContext(i);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),a.createElement(i.Provider,{value:n},e.children)}},85303:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>o,frontMatter:()=>i,metadata:()=>l,toc:()=>d});var a=r(74848),t=r(28453);const i={},s="Java Threads & Concurrency: Understanding OS-Level Implementation",l={id:"Backend/Concurrency-Threading/Java Multithreading/Java Threads & Concurrency: Understanding OS-Level Implementation",title:"Java Threads & Concurrency: Understanding OS-Level Implementation",description:"Table of Contents",source:"@site/docs/02-Backend/Concurrency-Threading/Java Multithreading/Java Threads & Concurrency: Understanding OS-Level Implementation.mdx",sourceDirName:"02-Backend/Concurrency-Threading/Java Multithreading",slug:"/Backend/Concurrency-Threading/Java Multithreading/Java Threads & Concurrency: Understanding OS-Level Implementation",permalink:"/docs/Backend/Concurrency-Threading/Java Multithreading/Java Threads & Concurrency: Understanding OS-Level Implementation",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/02-Backend/Concurrency-Threading/Java Multithreading/Java Threads & Concurrency: Understanding OS-Level Implementation.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Java Multithreading & Thread Safety",permalink:"/docs/Backend/Concurrency-Threading/Java Multithreading/"},next:{title:"Producer-Consumer Problem & Race Conditions",permalink:"/docs/Backend/Concurrency-Threading/Java Multithreading/Producer-Consumer Problem & Race Conditions"}},c={},d=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Thread Fundamentals",id:"thread-fundamentals",level:2},{value:"What is a Thread?",id:"what-is-a-thread",level:3},{value:"OS-Level Thread Management",id:"os-level-thread-management",level:2},{value:"The Journey from Java to OS",id:"the-journey-from-java-to-os",level:3},{value:"Thread Models",id:"thread-models",level:3},{value:"CPU and Thread Execution",id:"cpu-and-thread-execution",level:2},{value:"How CPU Executes Threads",id:"how-cpu-executes-threads",level:3},{value:"Context Switching",id:"context-switching",level:3},{value:"Memory and RAM Interaction",id:"memory-and-ram-interaction",level:2},{value:"Thread Memory Layout",id:"thread-memory-layout",level:3},{value:"Memory Visibility Problem",id:"memory-visibility-problem",level:3},{value:"CPU Cache and Memory Hierarchy",id:"cpu-cache-and-memory-hierarchy",level:3},{value:"Practical Examples",id:"practical-examples",level:2},{value:"Example 1: CPU-Bound Task",id:"example-1-cpu-bound-task",level:3},{value:"Example 2: I/O-Bound Task",id:"example-2-io-bound-task",level:3},{value:"Example 3: Proper Synchronization",id:"example-3-proper-synchronization",level:3},{value:"Example 4: Understanding Thread States",id:"example-4-understanding-thread-states",level:3},{value:"Thread Lifecycle at OS Level",id:"thread-lifecycle-at-os-level",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"java-threads--concurrency-understanding-os-level-implementation",children:"Java Threads & Concurrency: Understanding OS-Level Implementation"})}),"\n",(0,a.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#thread-fundamentals",children:"Thread Fundamentals"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#os-level-thread-management",children:"OS-Level Thread Management"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#cpu-and-thread-execution",children:"CPU and Thread Execution"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#memory-and-ram-interaction",children:"Memory and RAM Interaction"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#practical-examples",children:"Practical Examples"})}),"\n"]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"thread-fundamentals",children:"Thread Fundamentals"}),"\n",(0,a.jsx)(n.h3,{id:"what-is-a-thread",children:"What is a Thread?"}),"\n",(0,a.jsx)(n.p,{children:"A thread is the smallest unit of execution that can be scheduled by the operating system. Think of it as a lightweight process that shares memory with other threads in the same process."}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Key Concept"}),": When you create a Java thread, you're actually requesting the OS to create a native thread."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'// Simple thread creation\nThread thread = new Thread(() -> {\n    System.out.println("Running in: " + Thread.currentThread().getName());\n});\nthread.start(); // This triggers OS-level thread creation\n'})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"os-level-thread-management",children:"OS-Level Thread Management"}),"\n",(0,a.jsx)(n.h3,{id:"the-journey-from-java-to-os",children:"The Journey from Java to OS"}),"\n",(0,a.jsxs)(n.p,{children:["When you call ",(0,a.jsx)(n.code,{children:"thread.start()"})," in Java, here's what happens underneath:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Java Application (JVM)\n         \u2193\n    JVM Thread API\n         \u2193\n    Native Thread Library (pthreads on Linux, Windows Threads on Windows)\n         \u2193\n    Operating System Kernel\n         \u2193\n    Scheduler assigns thread to CPU core\n"})}),"\n",(0,a.jsx)(n.h3,{id:"thread-models",children:"Thread Models"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"1:1 Model (Java uses this)"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"One Java thread = One OS thread"}),"\n",(0,a.jsx)(n.li,{children:"Each Java thread maps directly to a kernel thread"}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'public class ThreadMappingExample {\n    public static void main(String[] args) {\n        // Creating 3 Java threads = 3 OS threads\n        for (int i = 0; i < 3; i++) {\n            Thread t = new Thread(() -> {\n                System.out.println("Thread ID: " + Thread.currentThread().threadId());\n                System.out.println("Native thread ID: " +\n                    ProcessHandle.current().pid());\n            });\n            t.start();\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"cpu-and-thread-execution",children:"CPU and Thread Execution"}),"\n",(0,a.jsx)(n.h3,{id:"how-cpu-executes-threads",children:"How CPU Executes Threads"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Single Core CPU:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Time Slice 1: Thread A executes\nTime Slice 2: Thread B executes (context switch)\nTime Slice 3: Thread A executes (context switch)\nTime Slice 4: Thread C executes (context switch)\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Multi-Core CPU:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Core 1: Thread A\nCore 2: Thread B    } All execute simultaneously\nCore 3: Thread C\nCore 4: Thread D\n"})}),"\n",(0,a.jsx)(n.h3,{id:"context-switching",children:"Context Switching"}),"\n",(0,a.jsx)(n.p,{children:"When the OS switches from one thread to another, it must:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Save current thread state"})," (registers, program counter, stack pointer) \u2192 RAM"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Load next thread state"})," from RAM \u2192 CPU registers"]}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:"Resume execution"})}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"public class ContextSwitchExample {\n    public static void main(String[] args) {\n        // With 1000 threads on 8 cores, expect lots of context switching\n        for (int i = 0; i < 1000; i++) {\n            new Thread(() -> {\n                // CPU time slicing happens here\n                for (int j = 0; j < 1000000; j++) {\n                    Math.sqrt(j); // CPU-intensive work\n                }\n            }).start();\n        }\n    }\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Cost of Context Switching:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Save/restore CPU registers: ~1-2 microseconds"}),"\n",(0,a.jsx)(n.li,{children:"Cache invalidation (CPU cache needs to reload data)"}),"\n",(0,a.jsx)(n.li,{children:"TLB (Translation Lookaside Buffer) flush"}),"\n"]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"memory-and-ram-interaction",children:"Memory and RAM Interaction"}),"\n",(0,a.jsx)(n.h3,{id:"thread-memory-layout",children:"Thread Memory Layout"}),"\n",(0,a.jsx)(n.p,{children:"Each thread has:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502     PROCESS MEMORY SPACE        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Heap (Shared by all threads)   \u2502 \u2190 Objects created with 'new'\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Method Area (Shared)            \u2502 \u2190 Class metadata, static variables\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Thread 1 Stack (Private)        \u2502 \u2190 Local variables, method calls\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Thread 2 Stack (Private)        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Thread 3 Stack (Private)        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,a.jsx)(n.h3,{id:"memory-visibility-problem",children:"Memory Visibility Problem"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'public class MemoryVisibilityExample {\n    // Without volatile, changes might not be visible across threads\n    private static boolean flag = false;\n\n    public static void main(String[] args) throws InterruptedException {\n        // Thread 1: Reads flag\n        Thread reader = new Thread(() -> {\n            while (!flag) {\n                // CPU might cache \'flag\' value in register\n                // Never reads updated value from RAM!\n            }\n            System.out.println("Flag is now true!");\n        });\n\n        // Thread 2: Writes flag\n        Thread writer = new Thread(() -> {\n            try {\n                Thread.sleep(1000);\n                flag = true; // Written to CPU cache, maybe not RAM yet\n                System.out.println("Flag set to true");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n\n        reader.start();\n        writer.start();\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"cpu-cache-and-memory-hierarchy",children:"CPU Cache and Memory Hierarchy"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"CPU Core\n  \u251c\u2500 L1 Cache (32-64 KB, ~1 ns access)\n  \u251c\u2500 L2 Cache (256 KB, ~3 ns access)\n  \u2514\u2500 L3 Cache (Shared, 8-32 MB, ~12 ns access)\n        \u2193\n   Main RAM (GB, ~100 ns access)\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Why This Matters:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'public class CacheCoherenceExample {\n    private static int sharedCounter = 0;\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread t1 = new Thread(() -> {\n            for (int i = 0; i < 100000; i++) {\n                // Core 1 reads sharedCounter into its cache\n                // Increments it\n                // Writes back (eventually)\n                sharedCounter++;\n            }\n        });\n\n        Thread t2 = new Thread(() -> {\n            for (int i = 0; i < 100000; i++) {\n                // Core 2 also reads sharedCounter into its cache\n                // Both cores have different cached values!\n                sharedCounter++;\n            }\n        });\n\n        t1.start();\n        t2.start();\n        t1.join();\n        t2.join();\n\n        // Expected: 200000, Actual: Less (lost updates)\n        System.out.println("Counter: " + sharedCounter);\n    }\n}\n'})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"practical-examples",children:"Practical Examples"}),"\n",(0,a.jsx)(n.h3,{id:"example-1-cpu-bound-task",children:"Example 1: CPU-Bound Task"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'public class CPUBoundExample {\n    public static void main(String[] args) {\n        int cores = Runtime.getRuntime().availableProcessors();\n        System.out.println("CPU Cores: " + cores);\n\n        // Creating threads = number of cores is optimal for CPU-bound tasks\n        for (int i = 0; i < cores; i++) {\n            Thread t = new Thread(() -> {\n                // This thread gets a dedicated core\n                long sum = 0;\n                for (long j = 0; j < 1_000_000_000L; j++) {\n                    sum += j;\n                }\n                System.out.println("Sum: " + sum);\n            });\n            t.start();\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"What Happens:"})}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"JVM creates 8 threads (on 8-core CPU)"}),"\n",(0,a.jsx)(n.li,{children:"OS scheduler assigns 1 thread per core"}),"\n",(0,a.jsx)(n.li,{children:"Each core executes its thread with minimal context switching"}),"\n",(0,a.jsx)(n.li,{children:"CPU utilization: ~100%"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"example-2-io-bound-task",children:"Example 2: I/O-Bound Task"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'public class IOBoundExample {\n    public static void main(String[] args) {\n        // I/O-bound: Can create many more threads than cores\n        for (int i = 0; i < 1000; i++) {\n            Thread t = new Thread(() -> {\n                try {\n                    // Thread blocks, OS removes from CPU\n                    Thread.sleep(1000); // Simulates I/O wait\n                    // Thread wakes, OS schedules back to CPU\n                    System.out.println("Done waiting");\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            });\n            t.start();\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"What Happens:"})}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["Thread calls ",(0,a.jsx)(n.code,{children:"sleep()"})," \u2192 moves to WAITING state"]}),"\n",(0,a.jsx)(n.li,{children:"OS removes thread from CPU scheduler"}),"\n",(0,a.jsx)(n.li,{children:"CPU is free for other threads"}),"\n",(0,a.jsx)(n.li,{children:"After sleep, thread moves to RUNNABLE \u2192 OS schedules it back"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"example-3-proper-synchronization",children:"Example 3: Proper Synchronization"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'public class SynchronizedExample {\n    private static int counter = 0;\n    private static final Object lock = new Object();\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread t1 = new Thread(() -> {\n            for (int i = 0; i < 100000; i++) {\n                synchronized (lock) {\n                    // CPU acquires lock (atomic operation at hardware level)\n                    // Memory barrier: flushes CPU cache to RAM\n                    counter++;\n                    // Memory barrier: ensures write is visible\n                    // CPU releases lock\n                }\n            }\n        });\n\n        Thread t2 = new Thread(() -> {\n            for (int i = 0; i < 100000; i++) {\n                synchronized (lock) {\n                    counter++;\n                }\n            }\n        });\n\n        t1.start();\n        t2.start();\n        t1.join();\n        t2.join();\n\n        System.out.println("Counter: " + counter); // Always 200000\n    }\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"OS-Level Operations:"})}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Thread requests lock \u2192 OS/JVM checks lock status"}),"\n",(0,a.jsx)(n.li,{children:"If locked: Thread goes to BLOCKED state (not using CPU)"}),"\n",(0,a.jsx)(n.li,{children:"Lock owner releases \u2192 OS wakes waiting thread"}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"synchronized"})," creates memory barriers (CPU instruction)"]}),"\n",(0,a.jsx)(n.li,{children:"Cache coherence protocol ensures all cores see updates"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"example-4-understanding-thread-states",children:"Example 4: Understanding Thread States"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'public class ThreadStatesExample {\n    public static void main(String[] args) throws InterruptedException {\n        Object lock = new Object();\n\n        Thread t = new Thread(() -> {\n            synchronized (lock) {\n                try {\n                    System.out.println("RUNNABLE -> CPU executing");\n                    Thread.sleep(1000);\n                    System.out.println("TIMED_WAITING -> Off CPU, in RAM");\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        });\n\n        System.out.println("NEW: " + t.getState()); // Thread object in heap\n        t.start();\n        System.out.println("RUNNABLE: " + t.getState()); // OS scheduled\n        Thread.sleep(500);\n        System.out.println("TIMED_WAITING: " + t.getState()); // Off CPU\n        t.join();\n        System.out.println("TERMINATED: " + t.getState()); // OS cleaned up\n    }\n}\n'})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"thread-lifecycle-at-os-level",children:"Thread Lifecycle at OS Level"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"NEW (Java object in heap)\n  \u2193 start()\nRUNNABLE (OS ready queue)\n  \u2193 OS Scheduler\nRUNNING (Executing on CPU core)\n  \u2193 sleep()/wait()/I/O\nWAITING/TIMED_WAITING (Off CPU, in RAM)\n  \u2193 notify()/interrupt()/I/O complete\nRUNNABLE (Back to OS ready queue)\n  \u2193 Execution completes\nTERMINATED (OS cleans up resources)\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Java Thread = OS Thread"}),": Direct 1:1 mapping with native threads"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Context Switching"}),": Expensive operation, save/restore state from RAM"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"CPU Cores"}),": Limit true parallelism (8 cores = max 8 threads running simultaneously)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Memory Visibility"}),": Changes in one core's cache might not be visible to others without synchronization"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Thread Stack"}),": Each thread gets private stack space in RAM (~1 MB default)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Shared Heap"}),": All threads share heap memory, need synchronization"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"OS Scheduler"}),": Decides which thread runs on which core and when"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Understanding these concepts helps you write efficient concurrent programs and debug threading issues!"})]})}function o(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}}}]);