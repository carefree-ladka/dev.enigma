"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[9304],{28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>a});var o=n(96540);const s={},i=o.createContext(s);function r(e){const t=o.useContext(i);return o.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),o.createElement(i.Provider,{value:t},e.children)}},48559:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>p,frontMatter:()=>i,metadata:()=>a,toc:()=>l});var o=n(74848),s=n(28453);const i={title:"Event Loop"},r=void 0,a={id:"WebDev/JavaScript/EventLoop",title:"Event Loop",description:"The JavaScript Event Loop is a fundamental concept in understanding how JavaScript handles asynchronous operations. It enables JavaScript to perform non-blocking I/O operations, making it possible to run other code while waiting for operations to complete.",source:"@site/docs/WebDev/JavaScript/EventLoop.mdx",sourceDirName:"WebDev/JavaScript",slug:"/WebDev/JavaScript/EventLoop",permalink:"/js.enigma/docs/WebDev/JavaScript/EventLoop",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/WebDev/JavaScript/EventLoop.mdx",tags:[],version:"current",frontMatter:{title:"Event Loop"},sidebar:"tutorialSidebar",previous:{title:"Event Emitter",permalink:"/js.enigma/docs/WebDev/JavaScript/EventEmitter"},next:{title:"Function Methods Polyfill",permalink:"/js.enigma/docs/WebDev/JavaScript/FunctionsPolyfill"}},c={},l=[{value:"What is the Event Loop?",id:"what-is-the-event-loop",level:2},{value:"How It Works",id:"how-it-works",level:2},{value:"Example",id:"example",level:2}];function h(e){const t={code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.p,{children:"The JavaScript Event Loop is a fundamental concept in understanding how JavaScript handles asynchronous operations. It enables JavaScript to perform non-blocking I/O operations, making it possible to run other code while waiting for operations to complete."}),"\n",(0,o.jsx)(t.h2,{id:"what-is-the-event-loop",children:"What is the Event Loop?"}),"\n",(0,o.jsx)(t.p,{children:"JavaScript is single-threaded, meaning it can only execute one operation at a time. The Event Loop allows JavaScript to perform asynchronous operations like HTTP requests, file reading, or timers without blocking the main thread."}),"\n",(0,o.jsx)(t.h2,{id:"how-it-works",children:"How It Works"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Call Stack:"})," The call stack is where JavaScript keeps track of function calls. When a function is called, it gets pushed onto the call stack. When the function execution is complete, it is popped off the stack."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Web APIs:"})," Web APIs (such as ",(0,o.jsx)(t.code,{children:"setTimeout"}),", ",(0,o.jsx)(t.code,{children:"fetch"}),", etc.) handle asynchronous operations and move the callback functions to the task queue when their operations are complete."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Task Queue:"})," The task queue (or callback queue) holds the functions that are waiting to be executed. When the call stack is empty, the event loop takes functions from the task queue and pushes them onto the call stack."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Microtask Queue:"})," Microtasks, such as ",(0,o.jsx)(t.code,{children:"Promise"})," callbacks and ",(0,o.jsx)(t.code,{children:"MutationObserver"})," callbacks, are given higher priority than regular tasks. They are processed before the task queue."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"Event Loop Process:"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"The event loop continuously checks if the call stack is empty."}),"\n",(0,o.jsx)(t.li,{children:"If the call stack is empty, it looks at the microtask queue and executes all microtasks."}),"\n",(0,o.jsx)(t.li,{children:"After processing microtasks, it then processes tasks from the task queue."}),"\n",(0,o.jsx)(t.li,{children:"This process repeats, allowing JavaScript to handle multiple asynchronous operations efficiently."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"example",children:"Example"}),"\n",(0,o.jsx)(t.p,{children:"Here\u2019s a simple example to illustrate how the event loop works:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-javascript",children:"console.log('Start');\n\nsetTimeout(() => {\n  console.log('Timeout');\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('Promise');\n});\n\nconsole.log('End');\n"})}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"output"})}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"Start\nEnd\nPromise\nTimeout\n"})})]})}function p(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}}}]);