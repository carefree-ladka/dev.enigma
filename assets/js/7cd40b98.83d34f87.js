"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[9956],{19243:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>s,default:()=>h,frontMatter:()=>i,metadata:()=>l,toc:()=>a});var t=r(74848),o=r(28453);const i={title:"N-ary Tree"},s=void 0,l={id:"DSA/DSA with JavaScript/NryTree",title:"N-ary Tree",description:"An N-ary Tree is a tree data structure where each node can have up to N children. This is a generalization of a binary tree where each node can have more than two children. N-ary trees are useful in scenarios where a hierarchical structure is required, but nodes can have more than two children.",source:"@site/docs/DSA/DSA with JavaScript/NryTree.mdx",sourceDirName:"DSA/DSA with JavaScript",slug:"/DSA/DSA with JavaScript/NryTree",permalink:"/dev.enigma/docs/DSA/DSA with JavaScript/NryTree",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with JavaScript/NryTree.mdx",tags:[],version:"current",frontMatter:{title:"N-ary Tree"},sidebar:"tutorialSidebar",previous:{title:"Multi-source BFS Algorithm",permalink:"/dev.enigma/docs/DSA/DSA with JavaScript/MultiSourceBFS"},next:{title:"Number of Islands Pattern",permalink:"/dev.enigma/docs/DSA/DSA with JavaScript/NumberOfIsland"}},d={},a=[{value:"Properties of N-ary Trees",id:"properties-of-n-ary-trees",level:2},{value:"Basic Operations",id:"basic-operations",level:2},{value:"Example Structure",id:"example-structure",level:2}];function c(e){const n={code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["An ",(0,t.jsx)(n.strong,{children:"N-ary Tree"})," is a tree data structure where each node can have up to ",(0,t.jsx)(n.code,{children:"N"})," children. This is a generalization of a binary tree where each node can have more than two children. N-ary trees are useful in scenarios where a hierarchical structure is required, but nodes can have more than two children."]}),"\n",(0,t.jsx)(n.h2,{id:"properties-of-n-ary-trees",children:"Properties of N-ary Trees"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Nodes"}),": Each node in the tree has a value and a list of child nodes."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Root Node"}),": The topmost node in the tree, with no parent."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Leaf Nodes"}),": Nodes that do not have any children."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Height"}),": The length of the longest path from the root to a leaf node."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"basic-operations",children:"Basic Operations"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Insertion"}),": Adding a new node to the tree."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Deletion"}),": Removing a node from the tree."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Traversal"}),": Visiting all nodes in a specific order (e.g., pre-order, post-order)."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"example-structure",children:"Example Structure"}),"\n",(0,t.jsx)(n.p,{children:"An N-ary tree can be represented as:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-JavaScript",children:"class Node {\n\n  constructor(val, children = []) {\n    this.val = val;\n    this.children = children;\n  }\n\n  // Add a child node\n  addChild(child) {\n    if (child instanceof Node) {\n      this.children.push(child);\n    } else {\n      throw new Error(\"Invalid child node\");\n    }\n  }\n\n  // Remove a child node by value\n  removeChild(childVal) {\n    const index = this.children.findIndex(child => child.val === childVal);\n    if (index !== -1) {\n      this.children.splice(index, 1);\n    } else {\n      throw new Error(\"Child node not found\");\n    }\n  }\n\n  // Find a node by value using DFS\n  findNode(val) {\n    if (this.val === val) return this;\n\n    for (const child of this.children) {\n      const result = child.findNode(val);\n      if (result) return result;\n    }\n\n    return null;\n  }\n\n  // Pre-order DFS Traversal\n  dfsPreOrder(result = []) {\n    result.push(this.val);\n    for (const child of this.children) {\n      child.dfsPreOrder(result);\n    }\n    return result;\n  }\n\n  // Post-order DFS Traversal\n  dfsPostOrder(result = []) {\n    for (const child of this.children) {\n      child.dfsPostOrder(result);\n    }\n    result.push(this.val);\n    return result;\n  }\n\n  // In-order Traversal (customized for N-ary trees)\n  dfsInOrder(result = []) {\n    const half = Math.floor(this.children.length / 2);\n\n    for (let i = 0; i < half; i++) {\n      this.children[i].dfsInOrder(result);\n    }\n\n    result.push(this.val);\n\n    for (let i = half; i < this.children.length; i++) {\n      this.children[i].dfsInOrder(result);\n    }\n\n    return result;\n  }\n\n  bfs = (root) => {\n    const queue = [root]\n    const result = []\n\n    while (queue.length) {\n      const current = queue.shift()\n      result.push(current.val);\n      for (const child of current.children) {\n        queue.push(child)\n      }\n    }\n    return result\n  }\n\n  // Level-order BFS Traversal\n  static bfsLevelOrder(root) {\n    const result = [];\n    if (!root) return result;\n\n    const queue = [root];\n\n    while (queue.length > 0) {\n      const levelSize = queue.length;\n      const currentLevel = [];\n\n      for (let i = 0; i < levelSize; i++) {\n        const node = queue.shift();\n        currentLevel.push(node.val);\n\n        for (const child of node.children) {\n          queue.push(child);\n        }\n      }\n      result.push(currentLevel);\n    }\n    return result;\n  }\n\n  // Maximum Depth of the N-ary Tree\n  maxDepth() {\n    if (this.children.length === 0) return 1;\n\n    let depth = 0;\n    for (const child of this.children) {\n      depth = Math.max(depth, child.maxDepth());\n    }\n\n    return depth + 1; // Add 1 to account for the current node\n  }\n}\n\n// Create a sample N-ary tree\nconst root = new Node(1);\nconst child1 = new Node(3);\nconst child2 = new Node(2);\nconst child3 = new Node(4);\n\nroot.addChild(child1);\nroot.addChild(child2);\nroot.addChild(child3);\n\nconst grandchild1 = new Node(5);\nconst grandchild2 = new Node(6);\n\nchild1.addChild(grandchild1);\nchild1.addChild(grandchild2);\n\n\n/*\n        1\n       /|\\\n      / | \\\n     3  2  4\n    / \\\n   5   6\n*/\n\n\n// Perform traversals\nconsole.log('DFS Pre-order:', root.dfsPreOrder([])); // Output: [1, 3, 5, 6, 2, 4]\nconsole.log('DFS Post-order:', root.dfsPostOrder([])); // Output: [5, 6, 3, 2, 4, 1]\nconsole.log('DFS In-order:', root.dfsInOrder([])); // Output: [5, 6, 3, 1, 2, 4]\nconsole.log('BFS', root.bfs(root)); //[ 1, 3, 2, 4, 5, 6 ]\nconsole.log('BFS Level-order:', Node.bfsLevelOrder(root)); // Output: [[1], [3, 2, 4], [5, 6]]\nconsole.log('Maximum Depth of the Tree:', root.maxDepth()); // Output: 3\n"})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>l});var t=r(96540);const o={},i=t.createContext(o);function s(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);