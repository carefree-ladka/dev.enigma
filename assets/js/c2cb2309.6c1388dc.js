"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[5323],{28453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>a});var t=r(96540);const o={},l=t.createContext(o);function i(e){const n=t.useContext(l);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),t.createElement(l.Provider,{value:n},e.children)}},50109:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>h,frontMatter:()=>l,metadata:()=>a,toc:()=>d});var t=r(74848),o=r(28453);const l={},i="Binary Tree & BST",a={id:"DSA/DSA with Java/Binary Tree Patterns",title:"Binary Tree & BST",description:"Table of Contents",source:"@site/docs/DSA/DSA with Java/Binary Tree Patterns.mdx",sourceDirName:"DSA/DSA with Java",slug:"/DSA/DSA with Java/Binary Tree Patterns",permalink:"/js.enigma/docs/DSA/DSA with Java/Binary Tree Patterns",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with Java/Binary Tree Patterns.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Binary Search",permalink:"/js.enigma/docs/DSA/DSA with Java/Binary Search Patterns"},next:{title:"Binary Tree Recursion",permalink:"/js.enigma/docs/DSA/DSA with Java/Binary Tree Recusion Patterns"}},s={},d=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Tree Node Definition",id:"tree-node-definition",level:2},{value:"Pattern 1: Traversal Patterns",id:"pattern-1-traversal-patterns",level:2},{value:"1.1 Inorder Traversal (Left, Root, Right)",id:"11-inorder-traversal-left-root-right",level:3},{value:"1.2 Preorder Traversal (Root, Left, Right)",id:"12-preorder-traversal-root-left-right",level:3},{value:"1.3 Postorder Traversal (Left, Right, Root)",id:"13-postorder-traversal-left-right-root",level:3},{value:"Pattern 2: Level Order (BFS) Patterns",id:"pattern-2-level-order-bfs-patterns",level:2},{value:"2.1 Basic Level Order Traversal",id:"21-basic-level-order-traversal",level:3},{value:"2.2 Level Order Bottom (Reverse Level Order)",id:"22-level-order-bottom-reverse-level-order",level:3},{value:"2.3 Zigzag Level Order",id:"23-zigzag-level-order",level:3},{value:"2.4 Average of Levels",id:"24-average-of-levels",level:3},{value:"2.5 Level with Maximum Sum",id:"25-level-with-maximum-sum",level:3},{value:"2.6 Populate Next Right Pointers",id:"26-populate-next-right-pointers",level:3},{value:"Pattern 3: DFS Recursive Patterns",id:"pattern-3-dfs-recursive-patterns",level:2},{value:"3.1 Maximum Depth",id:"31-maximum-depth",level:3},{value:"3.2 Minimum Depth",id:"32-minimum-depth",level:3},{value:"3.3 Diameter of Binary Tree",id:"33-diameter-of-binary-tree",level:3},{value:"3.4 Check if Balanced",id:"34-check-if-balanced",level:3},{value:"3.5 Symmetric Tree",id:"35-symmetric-tree",level:3},{value:"3.6 Invert Binary Tree",id:"36-invert-binary-tree",level:3},{value:"3.7 Same Tree",id:"37-same-tree",level:3},{value:"3.8 Count Complete Tree Nodes",id:"38-count-complete-tree-nodes",level:3},{value:"Pattern 4: Path Problems",id:"pattern-4-path-problems",level:2},{value:"4.1 Binary Tree Paths (Root to Leaf)",id:"41-binary-tree-paths-root-to-leaf",level:3},{value:"4.2 Path Sum (Target Sum)",id:"42-path-sum-target-sum",level:3},{value:"4.3 Path Sum II (All Paths with Target Sum)",id:"43-path-sum-ii-all-paths-with-target-sum",level:3},{value:"4.4 Path Sum III (Any Path)",id:"44-path-sum-iii-any-path",level:3},{value:"4.5 Maximum Path Sum",id:"45-maximum-path-sum",level:3},{value:"4.6 Sum Root to Leaf Numbers",id:"46-sum-root-to-leaf-numbers",level:3},{value:"4.7 Longest Zigzag Path",id:"47-longest-zigzag-path",level:3},{value:"Pattern 5: Tree Construction",id:"pattern-5-tree-construction",level:2},{value:"5.1 Build Tree from Preorder and Inorder",id:"51-build-tree-from-preorder-and-inorder",level:3},{value:"5.2 Build Tree from Inorder and Postorder",id:"52-build-tree-from-inorder-and-postorder",level:3},{value:"5.3 Build Tree from Preorder and Postorder",id:"53-build-tree-from-preorder-and-postorder",level:3},{value:"5.4 Build Complete Binary Tree from Array",id:"54-build-complete-binary-tree-from-array",level:3},{value:"5.5 Convert Sorted Array to BST",id:"55-convert-sorted-array-to-bst",level:3},{value:"5.6 Convert Sorted List to BST",id:"56-convert-sorted-list-to-bst",level:3},{value:"Pattern 6: BST Patterns",id:"pattern-6-bst-patterns",level:2},{value:"6.1 Validate BST",id:"61-validate-bst",level:3},{value:"6.2 Search in BST",id:"62-search-in-bst",level:3},{value:"6.3 Insert into BST",id:"63-insert-into-bst",level:3},{value:"6.4 Delete from BST",id:"64-delete-from-bst",level:3},{value:"6.5 Kth Smallest Element in BST",id:"65-kth-smallest-element-in-bst",level:3},{value:"6.6 Kth Largest Element in BST",id:"66-kth-largest-element-in-bst",level:3},{value:"6.7 Lowest Common Ancestor in BST",id:"67-lowest-common-ancestor-in-bst",level:3},{value:"6.8 Inorder Successor in BST",id:"68-inorder-successor-in-bst",level:3},{value:"6.9 Inorder Predecessor in BST",id:"69-inorder-predecessor-in-bst",level:3},{value:"6.10 Two Sum IV - Input is a BST",id:"610-two-sum-iv---input-is-a-bst",level:3},{value:"6.11 Range Sum of BST",id:"611-range-sum-of-bst",level:3},{value:"6.12 Convert BST to Greater Tree",id:"612-convert-bst-to-greater-tree",level:3},{value:"6.13 Recover BST (Two nodes swapped)",id:"613-recover-bst-two-nodes-swapped",level:3},{value:"Pattern 7: Tree Modification",id:"pattern-7-tree-modification",level:2},{value:"7.1 Flatten Binary Tree to Linked List",id:"71-flatten-binary-tree-to-linked-list",level:3},{value:"7.2 Binary Tree Pruning (Remove subtrees with all zeros)",id:"72-binary-tree-pruning-remove-subtrees-with-all-zeros",level:3},{value:"7.3 Delete Leaves with Given Value",id:"73-delete-leaves-with-given-value",level:3},{value:"7.4 Add One Row to Tree",id:"74-add-one-row-to-tree",level:3},{value:"7.5 Merge Two Binary Trees",id:"75-merge-two-binary-trees",level:3},{value:"Pattern 8: Ancestor &amp; LCA Problems",id:"pattern-8-ancestor--lca-problems",level:2},{value:"8.1 Lowest Common Ancestor (Binary Tree)",id:"81-lowest-common-ancestor-binary-tree",level:3},{value:"8.2 Distance Between Two Nodes",id:"82-distance-between-two-nodes",level:3},{value:"8.3 All Ancestors of a Node",id:"83-all-ancestors-of-a-node",level:3},{value:"8.4 Deepest Leaves Sum",id:"84-deepest-leaves-sum",level:3},{value:"Pattern 9: Serialization/Deserialization",id:"pattern-9-serializationdeserialization",level:2},{value:"9.1 Serialize and Deserialize Binary Tree",id:"91-serialize-and-deserialize-binary-tree",level:3},{value:"9.2 Serialize and Deserialize BST (Optimized)",id:"92-serialize-and-deserialize-bst-optimized",level:3},{value:"Pattern 10: View &amp; Boundary Problems",id:"pattern-10-view--boundary-problems",level:2},{value:"10.1 Right Side View",id:"101-right-side-view",level:3},{value:"10.2 Left Side View",id:"102-left-side-view",level:3},{value:"10.3 Top View",id:"103-top-view",level:3},{value:"10.4 Bottom View",id:"104-bottom-view",level:3},{value:"10.5 Vertical Order Traversal",id:"105-vertical-order-traversal",level:3},{value:"10.6 Boundary Traversal",id:"106-boundary-traversal",level:3},{value:"Pattern 11: Distance &amp; Range Problems",id:"pattern-11-distance--range-problems",level:2},{value:"11.1 All Nodes Distance K",id:"111-all-nodes-distance-k",level:3},{value:"11.2 Width of Binary Tree",id:"112-width-of-binary-tree",level:3},{value:"Pattern 12: Subtree Problems",id:"pattern-12-subtree-problems",level:2},{value:"12.1 Subtree of Another Tree",id:"121-subtree-of-another-tree",level:3},{value:"12.2 Count Univalue Subtrees",id:"122-count-univalue-subtrees",level:3},{value:"12.3 Maximum Average Subtree",id:"123-maximum-average-subtree",level:3},{value:"Common Tree Problem Techniques Summary",id:"common-tree-problem-techniques-summary",level:2},{value:"1. <strong>Traversal Choice</strong>",id:"1-traversal-choice",level:3},{value:"2. <strong>DFS vs BFS</strong>",id:"2-dfs-vs-bfs",level:3},{value:"3. <strong>Helper Variables</strong>",id:"3-helper-variables",level:3},{value:"4. <strong>Common Patterns</strong>",id:"4-common-patterns",level:3},{value:"5. <strong>Time Complexities</strong>",id:"5-time-complexities",level:3}];function u(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"binary-tree--bst",children:"Binary Tree & BST"})}),"\n",(0,t.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#tree-node-definition",children:"Tree Node Definition"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-1-traversal-patterns",children:"Pattern 1: Traversal Patterns"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-2-level-order-bfs-patterns",children:"Pattern 2: Level Order (BFS) Patterns"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-3-dfs-recursive-patterns",children:"Pattern 3: DFS Recursive Patterns"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-4-path-problems",children:"Pattern 4: Path Problems"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-5-tree-construction",children:"Pattern 5: Tree Construction"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-6-bst-patterns",children:"Pattern 6: BST Patterns"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-7-tree-modification",children:"Pattern 7: Tree Modification"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-8-ancestor--lca-problems",children:"Pattern 8: Ancestor & LCA Problems"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-9-serializationdeserialization",children:"Pattern 9: Serialization/Deserialization"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-10-view--boundary-problems",children:"Pattern 10: View & Boundary Problems"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-11-distance--range-problems",children:"Pattern 11: Distance & Range Problems"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-12-subtree-problems",children:"Pattern 12: Subtree Problems"})}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"tree-node-definition",children:"Tree Node Definition"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    TreeNode(int val) {\n        this.val = val;\n    }\n\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-1-traversal-patterns",children:"Pattern 1: Traversal Patterns"}),"\n",(0,t.jsx)(n.h3,{id:"11-inorder-traversal-left-root-right",children:"1.1 Inorder Traversal (Left, Root, Right)"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Recursive:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"List<Integer> inorderTraversal(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n    inorder(root, result);\n    return result;\n}\n\nvoid inorder(TreeNode root, List<Integer> result) {\n    if (root == null) return;\n    inorder(root.left, result);\n    result.add(root.val);\n    inorder(root.right, result);\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Iterative:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"List<Integer> inorderTraversal(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n    Deque<TreeNode> stack = new ArrayDeque<>();\n    TreeNode curr = root;\n\n    while (curr != null || !stack.isEmpty()) {\n        while (curr != null) {\n            stack.push(curr);\n            curr = curr.left;\n        }\n        curr = stack.pop();\n        result.add(curr.val);\n        curr = curr.right;\n    }\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Morris Traversal (O(1) Space):"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"List<Integer> inorderTraversal(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n    TreeNode curr = root;\n\n    while (curr != null) {\n        if (curr.left == null) {\n            result.add(curr.val);\n            curr = curr.right;\n        } else {\n            TreeNode pred = curr.left;\n            while (pred.right != null && pred.right != curr) {\n                pred = pred.right;\n            }\n\n            if (pred.right == null) {\n                pred.right = curr;\n                curr = curr.left;\n            } else {\n                pred.right = null;\n                result.add(curr.val);\n                curr = curr.right;\n            }\n        }\n    }\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"12-preorder-traversal-root-left-right",children:"1.2 Preorder Traversal (Root, Left, Right)"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Recursive:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"List<Integer> preorderTraversal(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n    preorder(root, result);\n    return result;\n}\n\nvoid preorder(TreeNode root, List<Integer> result) {\n    if (root == null) return;\n    result.add(root.val);\n    preorder(root.left, result);\n    preorder(root.right, result);\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Iterative:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"List<Integer> preorderTraversal(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n    if (root == null) return result;\n\n    Deque<TreeNode> stack = new ArrayDeque<>();\n    stack.push(root);\n\n    while (!stack.isEmpty()) {\n        TreeNode node = stack.pop();\n        result.add(node.val);\n\n        if (node.right != null) stack.push(node.right);\n        if (node.left != null) stack.push(node.left);\n    }\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"13-postorder-traversal-left-right-root",children:"1.3 Postorder Traversal (Left, Right, Root)"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Recursive:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"List<Integer> postorderTraversal(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n    postorder(root, result);\n    return result;\n}\n\nvoid postorder(TreeNode root, List<Integer> result) {\n    if (root == null) return;\n    postorder(root.left, result);\n    postorder(root.right, result);\n    result.add(root.val);\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Iterative (Two Stacks):"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"List<Integer> postorderTraversal(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n    if (root == null) return result;\n\n    Deque<TreeNode> stack1 = new ArrayDeque<>();\n    Deque<TreeNode> stack2 = new ArrayDeque<>();\n\n    stack1.push(root);\n\n    while (!stack1.isEmpty()) {\n        TreeNode node = stack1.pop();\n        stack2.push(node);\n\n        if (node.left != null) stack1.push(node.left);\n        if (node.right != null) stack1.push(node.right);\n    }\n\n    while (!stack2.isEmpty()) {\n        result.add(stack2.pop().val);\n    }\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Iterative (One Stack):"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"List<Integer> postorderTraversal(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n    if (root == null) return result;\n\n    Deque<TreeNode> stack = new ArrayDeque<>();\n    TreeNode curr = root;\n    TreeNode lastVisited = null;\n\n    while (curr != null || !stack.isEmpty()) {\n        while (curr != null) {\n            stack.push(curr);\n            curr = curr.left;\n        }\n\n        TreeNode peekNode = stack.peek();\n        if (peekNode.right != null && lastVisited != peekNode.right) {\n            curr = peekNode.right;\n        } else {\n            result.add(peekNode.val);\n            lastVisited = stack.pop();\n        }\n    }\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-2-level-order-bfs-patterns",children:"Pattern 2: Level Order (BFS) Patterns"}),"\n",(0,t.jsx)(n.h3,{id:"21-basic-level-order-traversal",children:"2.1 Basic Level Order Traversal"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"List<List<Integer>> levelOrder(TreeNode root) {\n    List<List<Integer>> result = new ArrayList<>();\n    if (root == null) return result;\n\n    Queue<TreeNode> queue = new ArrayDeque<>();\n    queue.offer(root);\n\n    while (!queue.isEmpty()) {\n        int size = queue.size();\n        List<Integer> level = new ArrayList<>();\n\n        for (int i = 0; i < size; i++) {\n            TreeNode node = queue.poll();\n            level.add(node.val);\n\n            if (node.left != null) queue.offer(node.left);\n            if (node.right != null) queue.offer(node.right);\n        }\n        result.add(level);\n    }\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"22-level-order-bottom-reverse-level-order",children:"2.2 Level Order Bottom (Reverse Level Order)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"List<List<Integer>> levelOrderBottom(TreeNode root) {\n    List<List<Integer>> result = new ArrayList<>();\n    if (root == null) return result;\n\n    Queue<TreeNode> queue = new ArrayDeque<>();\n    queue.offer(root);\n\n    while (!queue.isEmpty()) {\n        int size = queue.size();\n        List<Integer> level = new ArrayList<>();\n\n        for (int i = 0; i < size; i++) {\n            TreeNode node = queue.poll();\n            level.add(node.val);\n\n            if (node.left != null) queue.offer(node.left);\n            if (node.right != null) queue.offer(node.right);\n        }\n        result.add(0, level); // Add at beginning\n    }\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"23-zigzag-level-order",children:"2.3 Zigzag Level Order"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n    List<List<Integer>> result = new ArrayList<>();\n    if (root == null) return result;\n\n    Queue<TreeNode> queue = new ArrayDeque<>();\n    queue.offer(root);\n    boolean leftToRight = true;\n\n    while (!queue.isEmpty()) {\n        int size = queue.size();\n        List<Integer> level = new ArrayList<>();\n\n        for (int i = 0; i < size; i++) {\n            TreeNode node = queue.poll();\n\n            if (leftToRight) {\n                level.add(node.val);\n            } else {\n                level.add(0, node.val);\n            }\n\n            if (node.left != null) queue.offer(node.left);\n            if (node.right != null) queue.offer(node.right);\n        }\n        result.add(level);\n        leftToRight = !leftToRight;\n    }\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"24-average-of-levels",children:"2.4 Average of Levels"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"List<Double> averageOfLevels(TreeNode root) {\n    List<Double> result = new ArrayList<>();\n    if (root == null) return result;\n\n    Queue<TreeNode> queue = new ArrayDeque<>();\n    queue.offer(root);\n\n    while (!queue.isEmpty()) {\n        int size = queue.size();\n        double sum = 0;\n\n        for (int i = 0; i < size; i++) {\n            TreeNode node = queue.poll();\n            sum += node.val;\n\n            if (node.left != null) queue.offer(node.left);\n            if (node.right != null) queue.offer(node.right);\n        }\n        result.add(sum / size);\n    }\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"25-level-with-maximum-sum",children:"2.5 Level with Maximum Sum"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"int maxLevelSum(TreeNode root) {\n    if (root == null) return 0;\n\n    Queue<TreeNode> queue = new ArrayDeque<>();\n    queue.offer(root);\n    int maxSum = Integer.MIN_VALUE;\n    int maxLevel = 1;\n    int currentLevel = 1;\n\n    while (!queue.isEmpty()) {\n        int size = queue.size();\n        int levelSum = 0;\n\n        for (int i = 0; i < size; i++) {\n            TreeNode node = queue.poll();\n            levelSum += node.val;\n\n            if (node.left != null) queue.offer(node.left);\n            if (node.right != null) queue.offer(node.right);\n        }\n\n        if (levelSum > maxSum) {\n            maxSum = levelSum;\n            maxLevel = currentLevel;\n        }\n        currentLevel++;\n    }\n    return maxLevel;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"26-populate-next-right-pointers",children:"2.6 Populate Next Right Pointers"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"class Node {\n    int val;\n    Node left, right, next;\n    Node(int val) { this.val = val; }\n}\n\nNode connect(Node root) {\n    if (root == null) return null;\n\n    Queue<Node> queue = new ArrayDeque<>();\n    queue.offer(root);\n\n    while (!queue.isEmpty()) {\n        int size = queue.size();\n        Node prev = null;\n\n        for (int i = 0; i < size; i++) {\n            Node node = queue.poll();\n\n            if (prev != null) {\n                prev.next = node;\n            }\n            prev = node;\n\n            if (node.left != null) queue.offer(node.left);\n            if (node.right != null) queue.offer(node.right);\n        }\n    }\n    return root;\n}\n\n// O(1) Space Solution\nNode connectOptimized(Node root) {\n    if (root == null) return null;\n\n    Node leftmost = root;\n\n    while (leftmost.left != null) {\n        Node head = leftmost;\n\n        while (head != null) {\n            head.left.next = head.right;\n\n            if (head.next != null) {\n                head.right.next = head.next.left;\n            }\n            head = head.next;\n        }\n        leftmost = leftmost.left;\n    }\n    return root;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-3-dfs-recursive-patterns",children:"Pattern 3: DFS Recursive Patterns"}),"\n",(0,t.jsx)(n.h3,{id:"31-maximum-depth",children:"3.1 Maximum Depth"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"int maxDepth(TreeNode root) {\n    if (root == null) return 0;\n    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"32-minimum-depth",children:"3.2 Minimum Depth"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"int minDepth(TreeNode root) {\n    if (root == null) return 0;\n\n    if (root.left == null && root.right == null) return 1;\n\n    if (root.left == null) return 1 + minDepth(root.right);\n    if (root.right == null) return 1 + minDepth(root.left);\n\n    return 1 + Math.min(minDepth(root.left), minDepth(root.right));\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"33-diameter-of-binary-tree",children:"3.3 Diameter of Binary Tree"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"int diameterOfBinaryTree(TreeNode root) {\n    int[] diameter = new int[1];\n    height(root, diameter);\n    return diameter[0];\n}\n\nint height(TreeNode root, int[] diameter) {\n    if (root == null) return 0;\n\n    int left = height(root.left, diameter);\n    int right = height(root.right, diameter);\n\n    diameter[0] = Math.max(diameter[0], left + right);\n\n    return 1 + Math.max(left, right);\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"34-check-if-balanced",children:"3.4 Check if Balanced"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"boolean isBalanced(TreeNode root) {\n    return checkHeight(root) != -1;\n}\n\nint checkHeight(TreeNode root) {\n    if (root == null) return 0;\n\n    int left = checkHeight(root.left);\n    if (left == -1) return -1;\n\n    int right = checkHeight(root.right);\n    if (right == -1) return -1;\n\n    if (Math.abs(left - right) > 1) return -1;\n\n    return 1 + Math.max(left, right);\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"35-symmetric-tree",children:"3.5 Symmetric Tree"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"boolean isSymmetric(TreeNode root) {\n    if (root == null) return true;\n    return isMirror(root.left, root.right);\n}\n\nboolean isMirror(TreeNode left, TreeNode right) {\n    if (left == null && right == null) return true;\n    if (left == null || right == null) return false;\n\n    return left.val == right.val &&\n           isMirror(left.left, right.right) &&\n           isMirror(left.right, right.left);\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"36-invert-binary-tree",children:"3.6 Invert Binary Tree"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"TreeNode invertTree(TreeNode root) {\n    if (root == null) return null;\n\n    TreeNode temp = root.left;\n    root.left = invertTree(root.right);\n    root.right = invertTree(temp);\n\n    return root;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"37-same-tree",children:"3.7 Same Tree"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (p == null || q == null) return false;\n\n    return p.val == q.val &&\n           isSameTree(p.left, q.left) &&\n           isSameTree(p.right, q.right);\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"38-count-complete-tree-nodes",children:"3.8 Count Complete Tree Nodes"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"int countNodes(TreeNode root) {\n    if (root == null) return 0;\n\n    int leftHeight = getLeftHeight(root);\n    int rightHeight = getRightHeight(root);\n\n    if (leftHeight == rightHeight) {\n        return (1 << leftHeight) - 1; // 2^h - 1\n    }\n\n    return 1 + countNodes(root.left) + countNodes(root.right);\n}\n\nint getLeftHeight(TreeNode root) {\n    int height = 0;\n    while (root != null) {\n        height++;\n        root = root.left;\n    }\n    return height;\n}\n\nint getRightHeight(TreeNode root) {\n    int height = 0;\n    while (root != null) {\n        height++;\n        root = root.right;\n    }\n    return height;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-4-path-problems",children:"Pattern 4: Path Problems"}),"\n",(0,t.jsx)(n.h3,{id:"41-binary-tree-paths-root-to-leaf",children:"4.1 Binary Tree Paths (Root to Leaf)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'List<String> binaryTreePaths(TreeNode root) {\n    List<String> result = new ArrayList<>();\n    if (root == null) return result;\n    findPaths(root, "", result);\n    return result;\n}\n\nvoid findPaths(TreeNode root, String path, List<String> result) {\n    if (root == null) return;\n\n    path += root.val;\n\n    if (root.left == null && root.right == null) {\n        result.add(path);\n        return;\n    }\n\n    path += "->";\n    findPaths(root.left, path, result);\n    findPaths(root.right, path, result);\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"42-path-sum-target-sum",children:"4.2 Path Sum (Target Sum)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"boolean hasPathSum(TreeNode root, int targetSum) {\n    if (root == null) return false;\n\n    if (root.left == null && root.right == null) {\n        return targetSum == root.val;\n    }\n\n    return hasPathSum(root.left, targetSum - root.val) ||\n           hasPathSum(root.right, targetSum - root.val);\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"43-path-sum-ii-all-paths-with-target-sum",children:"4.3 Path Sum II (All Paths with Target Sum)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"List<List<Integer>> pathSum(TreeNode root, int targetSum) {\n    List<List<Integer>> result = new ArrayList<>();\n    findPaths(root, targetSum, new ArrayList<>(), result);\n    return result;\n}\n\nvoid findPaths(TreeNode root, int remaining, List<Integer> path,\n               List<List<Integer>> result) {\n    if (root == null) return;\n\n    path.add(root.val);\n\n    if (root.left == null && root.right == null && remaining == root.val) {\n        result.add(new ArrayList<>(path));\n    } else {\n        findPaths(root.left, remaining - root.val, path, result);\n        findPaths(root.right, remaining - root.val, path, result);\n    }\n\n    path.remove(path.size() - 1); // Backtrack\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"44-path-sum-iii-any-path",children:"4.4 Path Sum III (Any Path)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"int pathSum(TreeNode root, int targetSum) {\n    if (root == null) return 0;\n\n    return pathSumFrom(root, targetSum) +\n           pathSum(root.left, targetSum) +\n           pathSum(root.right, targetSum);\n}\n\nint pathSumFrom(TreeNode root, long targetSum) {\n    if (root == null) return 0;\n\n    int count = 0;\n    if (root.val == targetSum) count++;\n\n    count += pathSumFrom(root.left, targetSum - root.val);\n    count += pathSumFrom(root.right, targetSum - root.val);\n\n    return count;\n}\n\n// Optimized with HashMap\nint pathSumOptimized(TreeNode root, int targetSum) {\n    HashMap<Long, Integer> prefixSum = new HashMap<>();\n    prefixSum.put(0L, 1);\n    return pathSumHelper(root, 0, targetSum, prefixSum);\n}\n\nint pathSumHelper(TreeNode root, long currentSum, int target,\n                  HashMap<Long, Integer> prefixSum) {\n    if (root == null) return 0;\n\n    currentSum += root.val;\n    int count = prefixSum.getOrDefault(currentSum - target, 0);\n\n    prefixSum.put(currentSum, prefixSum.getOrDefault(currentSum, 0) + 1);\n\n    count += pathSumHelper(root.left, currentSum, target, prefixSum);\n    count += pathSumHelper(root.right, currentSum, target, prefixSum);\n\n    prefixSum.put(currentSum, prefixSum.get(currentSum) - 1);\n\n    return count;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"45-maximum-path-sum",children:"4.5 Maximum Path Sum"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"int maxPathSum(TreeNode root) {\n    int[] max = new int[]{Integer.MIN_VALUE};\n    maxPathSumHelper(root, max);\n    return max[0];\n}\n\nint maxPathSumHelper(TreeNode root, int[] max) {\n    if (root == null) return 0;\n\n    int left = Math.max(0, maxPathSumHelper(root.left, max));\n    int right = Math.max(0, maxPathSumHelper(root.right, max));\n\n    max[0] = Math.max(max[0], left + right + root.val);\n\n    return root.val + Math.max(left, right);\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"46-sum-root-to-leaf-numbers",children:"4.6 Sum Root to Leaf Numbers"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"int sumNumbers(TreeNode root) {\n    return sumHelper(root, 0);\n}\n\nint sumHelper(TreeNode root, int currentSum) {\n    if (root == null) return 0;\n\n    currentSum = currentSum * 10 + root.val;\n\n    if (root.left == null && root.right == null) {\n        return currentSum;\n    }\n\n    return sumHelper(root.left, currentSum) + sumHelper(root.right, currentSum);\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"47-longest-zigzag-path",children:"4.7 Longest Zigzag Path"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"int longestZigZag(TreeNode root) {\n    int[] max = new int[1];\n    dfs(root, true, 0, max);\n    dfs(root, false, 0, max);\n    return max[0];\n}\n\nvoid dfs(TreeNode root, boolean isLeft, int length, int[] max) {\n    if (root == null) return;\n\n    max[0] = Math.max(max[0], length);\n\n    if (isLeft) {\n        dfs(root.left, false, length + 1, max);\n        dfs(root.right, true, 1, max);\n    } else {\n        dfs(root.right, true, length + 1, max);\n        dfs(root.left, false, 1, max);\n    }\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-5-tree-construction",children:"Pattern 5: Tree Construction"}),"\n",(0,t.jsx)(n.h3,{id:"51-build-tree-from-preorder-and-inorder",children:"5.1 Build Tree from Preorder and Inorder"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"int preIndex = 0;\n\nTreeNode buildTree(int[] preorder, int[] inorder) {\n    HashMap<Integer, Integer> inMap = new HashMap<>();\n    for (int i = 0; i < inorder.length; i++) {\n        inMap.put(inorder[i], i);\n    }\n    return build(preorder, 0, preorder.length - 1, inMap);\n}\n\nTreeNode build(int[] preorder, int inStart, int inEnd,\n               HashMap<Integer, Integer> inMap) {\n    if (inStart > inEnd) return null;\n\n    int rootVal = preorder[preIndex++];\n    TreeNode root = new TreeNode(rootVal);\n\n    int inIndex = inMap.get(rootVal);\n\n    root.left = build(preorder, inStart, inIndex - 1, inMap);\n    root.right = build(preorder, inIndex + 1, inEnd, inMap);\n\n    return root;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"52-build-tree-from-inorder-and-postorder",children:"5.2 Build Tree from Inorder and Postorder"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"int postIndex;\n\nTreeNode buildTree(int[] inorder, int[] postorder) {\n    postIndex = postorder.length - 1;\n    HashMap<Integer, Integer> inMap = new HashMap<>();\n    for (int i = 0; i < inorder.length; i++) {\n        inMap.put(inorder[i], i);\n    }\n    return build(postorder, 0, postorder.length - 1, inMap);\n}\n\nTreeNode build(int[] postorder, int inStart, int inEnd,\n               HashMap<Integer, Integer> inMap) {\n    if (inStart > inEnd) return null;\n\n    int rootVal = postorder[postIndex--];\n    TreeNode root = new TreeNode(rootVal);\n\n    int inIndex = inMap.get(rootVal);\n\n    root.right = build(postorder, inIndex + 1, inEnd, inMap);\n    root.left = build(postorder, inStart, inIndex - 1, inMap);\n\n    return root;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"53-build-tree-from-preorder-and-postorder",children:"5.3 Build Tree from Preorder and Postorder"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"int preIndex = 0, postIndex = 0;\n\nTreeNode constructFromPrePost(int[] preorder, int[] postorder) {\n    TreeNode root = new TreeNode(preorder[preIndex++]);\n    if (root.val != postorder[postIndex]) {\n        root.left = constructFromPrePost(preorder, postorder);\n    }\n    if (root.val != postorder[postIndex]) {\n        root.right = constructFromPrePost(preorder, postorder);\n    }\n    postIndex++;\n    return root;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"54-build-complete-binary-tree-from-array",children:"5.4 Build Complete Binary Tree from Array"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"TreeNode arrayToTree(int[] arr, int i) {\n    if (i >= arr.length) return null;\n\n    TreeNode root = new TreeNode(arr[i]);\n    root.left = arrayToTree(arr, 2 * i + 1);\n    root.right = arrayToTree(arr, 2 * i + 2);\n\n    return root;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"55-convert-sorted-array-to-bst",children:"5.5 Convert Sorted Array to BST"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"TreeNode sortedArrayToBST(int[] nums) {\n    return buildBST(nums, 0, nums.length - 1);\n}\n\nTreeNode buildBST(int[] nums, int left, int right) {\n    if (left > right) return null;\n\n    int mid = left + (right - left) / 2;\n    TreeNode root = new TreeNode(nums[mid]);\n\n    root.left = buildBST(nums, left, mid - 1);\n    root.right = buildBST(nums, mid + 1, right);\n\n    return root;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"56-convert-sorted-list-to-bst",children:"5.6 Convert Sorted List to BST"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"class ListNode {\n    int val;\n    ListNode next;\n    ListNode(int val) { this.val = val; }\n}\n\nTreeNode sortedListToBST(ListNode head) {\n    if (head == null) return null;\n    if (head.next == null) return new TreeNode(head.val);\n\n    ListNode slow = head, fast = head, prev = null;\n\n    while (fast != null && fast.next != null) {\n        prev = slow;\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n\n    TreeNode root = new TreeNode(slow.val);\n\n    if (prev != null) prev.next = null;\n    root.left = sortedListToBST(head == slow ? null : head);\n    root.right = sortedListToBST(slow.next);\n\n    return root;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-6-bst-patterns",children:"Pattern 6: BST Patterns"}),"\n",(0,t.jsx)(n.h3,{id:"61-validate-bst",children:"6.1 Validate BST"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"boolean isValidBST(TreeNode root) {\n    return validate(root, null, null);\n}\n\nboolean validate(TreeNode root, Integer min, Integer max) {\n    if (root == null) return true;\n\n    if ((min != null && root.val <= min) || (max != null && root.val >= max)) {\n        return false;\n    }\n\n    return validate(root.left, min, root.val) && validate(root.right, root.val, max);\n}\n\n// Using Inorder\nboolean isValidBST2(TreeNode root) {\n    Deque<TreeNode> stack = new ArrayDeque<>();\n    Integer prev = null;\n    TreeNode curr = root;\n\n    while (curr != null || !stack.isEmpty()) {\n        while (curr != null) {\n            stack.push(curr);\n            curr = curr.left;\n        }\n        curr = stack.pop();\n\n        if (prev != null && curr.val <= prev) return false;\n        prev = curr.val;\n\n        curr = curr.right;\n    }\n    return true;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"62-search-in-bst",children:"6.2 Search in BST"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"TreeNode searchBST(TreeNode root, int val) {\n    if (root == null || root.val == val) return root;\n\n    if (val < root.val) {\n        return searchBST(root.left, val);\n    }\n    return searchBST(root.right, val);\n}\n\n// Iterative\nTreeNode searchBSTIterative(TreeNode root, int val) {\n    while (root != null && root.val != val) {\n        root = val < root.val ? root.left : root.right;\n    }\n    return root;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"63-insert-into-bst",children:"6.3 Insert into BST"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"TreeNode insertIntoBST(TreeNode root, int val) {\n    if (root == null) return new TreeNode(val);\n\n    if (val < root.val) {\n        root.left = insertIntoBST(root.left, val);\n    } else {\n        root.right = insertIntoBST(root.right, val);\n    }\n    return root;\n}\n\n// Iterative\nTreeNode insertIntoBSTIterative(TreeNode root, int val) {\n    if (root == null) return new TreeNode(val);\n\n    TreeNode curr = root;\n    while (true) {\n        if (val < curr.val) {\n            if (curr.left == null) {\n                curr.left = new TreeNode(val);\n                break;\n            }\n            curr = curr.left;\n        } else {\n            if (curr.right == null) {\n                curr.right = new TreeNode(val);\n                break;\n            }\n            curr = curr.right;\n        }\n    }\n    return root;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"64-delete-from-bst",children:"6.4 Delete from BST"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"TreeNode deleteNode(TreeNode root, int key) {\n    if (root == null) return null;\n\n    if (key < root.val) {\n        root.left = deleteNode(root.left, key);\n    } else if (key > root.val) {\n        root.right = deleteNode(root.right, key);\n    } else {\n        // Node has two children\n        TreeNode minNode = findMin(root.right);\n        root.val = minNode.val;\n        root.right = deleteNode(root.right, minNode.val);\n    }\n    return root;\n}\n\nTreeNode findMin(TreeNode root) {\n    while (root.left != null) root = root.left;\n    return root;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"65-kth-smallest-element-in-bst",children:"6.5 Kth Smallest Element in BST"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"int kthSmallest(TreeNode root, int k) {\n    Deque<TreeNode> stack = new ArrayDeque<>();\n    TreeNode curr = root;\n\n    while (curr != null || !stack.isEmpty()) {\n        while (curr != null) {\n            stack.push(curr);\n            curr = curr.left;\n        }\n        curr = stack.pop();\n        k--;\n        if (k == 0) return curr.val;\n        curr = curr.right;\n    }\n    return -1;\n}\n\n// With counter approach\nint kthSmallest2(TreeNode root, int k) {\n    int[] result = new int[]{0};\n    int[] count = new int[]{k};\n    inorder(root, count, result);\n    return result[0];\n}\n\nvoid inorder(TreeNode root, int[] count, int[] result) {\n    if (root == null) return;\n\n    inorder(root.left, count, result);\n\n    count[0]--;\n    if (count[0] == 0) {\n        result[0] = root.val;\n        return;\n    }\n\n    inorder(root.right, count, result);\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"66-kth-largest-element-in-bst",children:"6.6 Kth Largest Element in BST"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"int kthLargest(TreeNode root, int k) {\n    int[] result = new int[]{0};\n    int[] count = new int[]{k};\n    reverseInorder(root, count, result);\n    return result[0];\n}\n\nvoid reverseInorder(TreeNode root, int[] count, int[] result) {\n    if (root == null) return;\n\n    reverseInorder(root.right, count, result);\n\n    count[0]--;\n    if (count[0] == 0) {\n        result[0] = root.val;\n        return;\n    }\n\n    reverseInorder(root.left, count, result);\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"67-lowest-common-ancestor-in-bst",children:"6.7 Lowest Common Ancestor in BST"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n    if (root.val > p.val && root.val > q.val) {\n        return lowestCommonAncestor(root.left, p, q);\n    }\n    if (root.val < p.val && root.val < q.val) {\n        return lowestCommonAncestor(root.right, p, q);\n    }\n    return root;\n}\n\n// Iterative\nTreeNode lowestCommonAncestorIterative(TreeNode root, TreeNode p, TreeNode q) {\n    while (root != null) {\n        if (root.val > p.val && root.val > q.val) {\n            root = root.left;\n        } else if (root.val < p.val && root.val < q.val) {\n            root = root.right;\n        } else {\n            return root;\n        }\n    }\n    return null;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"68-inorder-successor-in-bst",children:"6.8 Inorder Successor in BST"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"TreeNode inorderSuccessor(TreeNode root, TreeNode p) {\n    TreeNode successor = null;\n\n    while (root != null) {\n        if (p.val < root.val) {\n            successor = root;\n            root = root.left;\n        } else {\n            root = root.right;\n        }\n    }\n    return successor;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"69-inorder-predecessor-in-bst",children:"6.9 Inorder Predecessor in BST"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"TreeNode inorderPredecessor(TreeNode root, TreeNode p) {\n    TreeNode predecessor = null;\n\n    while (root != null) {\n        if (p.val > root.val) {\n            predecessor = root;\n            root = root.right;\n        } else {\n            root = root.left;\n        }\n    }\n    return predecessor;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"610-two-sum-iv---input-is-a-bst",children:"6.10 Two Sum IV - Input is a BST"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"boolean findTarget(TreeNode root, int k) {\n    HashSet<Integer> set = new HashSet<>();\n    return find(root, k, set);\n}\n\nboolean find(TreeNode root, int k, HashSet<Integer> set) {\n    if (root == null) return false;\n\n    if (set.contains(k - root.val)) return true;\n\n    set.add(root.val);\n\n    return find(root.left, k, set) || find(root.right, k, set);\n}\n\n// Using Two Pointers with Inorder\nboolean findTarget2(TreeNode root, int k) {\n    List<Integer> list = new ArrayList<>();\n    inorder(root, list);\n\n    int left = 0, right = list.size() - 1;\n\n    while (left < right) {\n        int sum = list.get(left) + list.get(right);\n        if (sum == k) return true;\n        if (sum < k) left++;\n        else right--;\n    }\n    return false;\n}\n\nvoid inorder(TreeNode root, List<Integer> list) {\n    if (root == null) return;\n    inorder(root.left, list);\n    list.add(root.val);\n    inorder(root.right, list);\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"611-range-sum-of-bst",children:"6.11 Range Sum of BST"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"int rangeSumBST(TreeNode root, int low, int high) {\n    if (root == null) return 0;\n\n    if (root.val < low) {\n        return rangeSumBST(root.right, low, high);\n    }\n    if (root.val > high) {\n        return rangeSumBST(root.left, low, high);\n    }\n\n    return root.val + rangeSumBST(root.left, low, high) +\n           rangeSumBST(root.right, low, high);\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"612-convert-bst-to-greater-tree",children:"6.12 Convert BST to Greater Tree"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"int sum = 0;\n\nTreeNode convertBST(TreeNode root) {\n    if (root != null) {\n        convertBST(root.right);\n        sum += root.val;\n        root.val = sum;\n        convertBST(root.left);\n    }\n    return root;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"613-recover-bst-two-nodes-swapped",children:"6.13 Recover BST (Two nodes swapped)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"TreeNode first = null, second = null, prev = null;\n\nvoid recoverTree(TreeNode root) {\n    inorder(root);\n\n    // Swap values\n    int temp = first.val;\n    first.val = second.val;\n    second.val = temp;\n}\n\nvoid inorder(TreeNode root) {\n    if (root == null) return;\n\n    inorder(root.left);\n\n    if (prev != null && prev.val > root.val) {\n        if (first == null) first = prev;\n        second = root;\n    }\n    prev = root;\n\n    inorder(root.right);\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-7-tree-modification",children:"Pattern 7: Tree Modification"}),"\n",(0,t.jsx)(n.h3,{id:"71-flatten-binary-tree-to-linked-list",children:"7.1 Flatten Binary Tree to Linked List"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"void flatten(TreeNode root) {\n    if (root == null) return;\n\n    flatten(root.left);\n    flatten(root.right);\n\n    TreeNode right = root.right;\n    root.right = root.left;\n    root.left = null;\n\n    TreeNode curr = root;\n    while (curr.right != null) {\n        curr = curr.right;\n    }\n    curr.right = right;\n}\n\n// Iterative\nvoid flattenIterative(TreeNode root) {\n    TreeNode curr = root;\n\n    while (curr != null) {\n        if (curr.left != null) {\n            TreeNode rightmost = curr.left;\n            while (rightmost.right != null) {\n                rightmost = rightmost.right;\n            }\n\n            rightmost.right = curr.right;\n            curr.right = curr.left;\n            curr.left = null;\n        }\n        curr = curr.right;\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"72-binary-tree-pruning-remove-subtrees-with-all-zeros",children:"7.2 Binary Tree Pruning (Remove subtrees with all zeros)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"TreeNode pruneTree(TreeNode root) {\n    if (root == null) return null;\n\n    root.left = pruneTree(root.left);\n    root.right = pruneTree(root.right);\n\n    if (root.val == 0 && root.left == null && root.right == null) {\n        return null;\n    }\n\n    return root;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"73-delete-leaves-with-given-value",children:"7.3 Delete Leaves with Given Value"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"TreeNode removeLeafNodes(TreeNode root, int target) {\n    if (root == null) return null;\n\n    root.left = removeLeafNodes(root.left, target);\n    root.right = removeLeafNodes(root.right, target);\n\n    if (root.left == null && root.right == null && root.val == target) {\n        return null;\n    }\n\n    return root;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"74-add-one-row-to-tree",children:"7.4 Add One Row to Tree"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"TreeNode addOneRow(TreeNode root, int val, int depth) {\n    if (depth == 1) {\n        TreeNode newRoot = new TreeNode(val);\n        newRoot.left = root;\n        return newRoot;\n    }\n\n    addRow(root, val, depth, 1);\n    return root;\n}\n\nvoid addRow(TreeNode root, int val, int depth, int currentDepth) {\n    if (root == null) return;\n\n    if (currentDepth == depth - 1) {\n        TreeNode tempLeft = root.left;\n        TreeNode tempRight = root.right;\n\n        root.left = new TreeNode(val);\n        root.right = new TreeNode(val);\n\n        root.left.left = tempLeft;\n        root.right.right = tempRight;\n\n        return;\n    }\n\n    addRow(root.left, val, depth, currentDepth + 1);\n    addRow(root.right, val, depth, currentDepth + 1);\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"75-merge-two-binary-trees",children:"7.5 Merge Two Binary Trees"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\n    if (t1 == null) return t2;\n    if (t2 == null) return t1;\n\n    TreeNode merged = new TreeNode(t1.val + t2.val);\n    merged.left = mergeTrees(t1.left, t2.left);\n    merged.right = mergeTrees(t1.right, t2.right);\n\n    return merged;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-8-ancestor--lca-problems",children:"Pattern 8: Ancestor & LCA Problems"}),"\n",(0,t.jsx)(n.h3,{id:"81-lowest-common-ancestor-binary-tree",children:"8.1 Lowest Common Ancestor (Binary Tree)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n    if (root == null || root == p || root == q) return root;\n\n    TreeNode left = lowestCommonAncestor(root.left, p, q);\n    TreeNode right = lowestCommonAncestor(root.right, p, q);\n\n    if (left != null && right != null) return root;\n    return left != null ? left : right;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"82-distance-between-two-nodes",children:"8.2 Distance Between Two Nodes"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"int findDistance(TreeNode root, TreeNode p, TreeNode q) {\n    TreeNode lca = lowestCommonAncestor(root, p, q);\n    int d1 = findLevel(lca, p, 0);\n    int d2 = findLevel(lca, q, 0);\n    return d1 + d2;\n}\n\nint findLevel(TreeNode root, TreeNode target, int level) {\n    if (root == null) return -1;\n    if (root == target) return level;\n\n    int left = findLevel(root.left, target, level + 1);\n    if (left != -1) return left;\n\n    return findLevel(root.right, target, level + 1);\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"83-all-ancestors-of-a-node",children:"8.3 All Ancestors of a Node"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"boolean findAncestors(TreeNode root, int target, List<Integer> ancestors) {\n    if (root == null) return false;\n\n    if (root.val == target) return true;\n\n    if (findAncestors(root.left, target, ancestors) ||\n        findAncestors(root.right, target, ancestors)) {\n        ancestors.add(root.val);\n        return true;\n    }\n\n    return false;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"84-deepest-leaves-sum",children:"8.4 Deepest Leaves Sum"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"int deepestLeavesSum(TreeNode root) {\n    Queue<TreeNode> queue = new ArrayDeque<>();\n    queue.offer(root);\n    int sum = 0;\n\n    while (!queue.isEmpty()) {\n        int size = queue.size();\n        sum = 0;\n\n        for (int i = 0; i < size; i++) {\n            TreeNode node = queue.poll();\n            sum += node.val;\n\n            if (node.left != null) queue.offer(node.left);\n            if (node.right != null) queue.offer(node.right);\n        }\n    }\n    return sum;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-9-serializationdeserialization",children:"Pattern 9: Serialization/Deserialization"}),"\n",(0,t.jsx)(n.h3,{id:"91-serialize-and-deserialize-binary-tree",children:"9.1 Serialize and Deserialize Binary Tree"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'class Codec {\n    // Serialize\n    public String serialize(TreeNode root) {\n        if (root == null) return "null";\n\n        StringBuilder sb = new StringBuilder();\n        Queue<TreeNode> queue = new ArrayDeque<>();\n        queue.offer(root);\n\n        while (!queue.isEmpty()) {\n            TreeNode node = queue.poll();\n\n            if (node == null) {\n                sb.append("null,");\n            } else {\n                sb.append(node.val).append(",");\n                queue.offer(node.left);\n                queue.offer(node.right);\n            }\n        }\n        return sb.toString();\n    }\n\n    // Deserialize\n    public TreeNode deserialize(String data) {\n        if (data.equals("null")) return null;\n\n        String[] values = data.split(",");\n        TreeNode root = new TreeNode(Integer.parseInt(values[0]));\n        Queue<TreeNode> queue = new ArrayDeque<>();\n        queue.offer(root);\n\n        int i = 1;\n        while (!queue.isEmpty()) {\n            TreeNode node = queue.poll();\n\n            if (!values[i].equals("null")) {\n                node.left = new TreeNode(Integer.parseInt(values[i]));\n                queue.offer(node.left);\n            }\n            i++;\n\n            if (!values[i].equals("null")) {\n                node.right = new TreeNode(Integer.parseInt(values[i]));\n                queue.offer(node.right);\n            }\n            i++;\n        }\n        return root;\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"92-serialize-and-deserialize-bst-optimized",children:"9.2 Serialize and Deserialize BST (Optimized)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'class Codec {\n    // Serialize using preorder\n    public String serialize(TreeNode root) {\n        StringBuilder sb = new StringBuilder();\n        serialize(root, sb);\n        return sb.toString();\n    }\n\n    void serialize(TreeNode root, StringBuilder sb) {\n        if (root == null) return;\n        sb.append(root.val).append(",");\n        serialize(root.left, sb);\n        serialize(root.right, sb);\n    }\n\n    // Deserialize\n    public TreeNode deserialize(String data) {\n        if (data.isEmpty()) return null;\n        String[] values = data.split(",");\n        Queue<Integer> queue = new ArrayDeque<>();\n        for (String val : values) {\n            queue.offer(Integer.parseInt(val));\n        }\n        return deserialize(queue, Integer.MIN_VALUE, Integer.MAX_VALUE);\n    }\n\n    TreeNode deserialize(Queue<Integer> queue, int min, int max) {\n        if (queue.isEmpty()) return null;\n\n        int val = queue.peek();\n        if (val < min || val > max) return null;\n\n        queue.poll();\n        TreeNode root = new TreeNode(val);\n        root.left = deserialize(queue, min, val);\n        root.right = deserialize(queue, val, max);\n        return root;\n    }\n}\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-10-view--boundary-problems",children:"Pattern 10: View & Boundary Problems"}),"\n",(0,t.jsx)(n.h3,{id:"101-right-side-view",children:"10.1 Right Side View"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"List<Integer> rightSideView(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n    if (root == null) return result;\n\n    Queue<TreeNode> queue = new ArrayDeque<>();\n    queue.offer(root);\n\n    while (!queue.isEmpty()) {\n        int size = queue.size();\n\n        for (int i = 0; i < size; i++) {\n            TreeNode node = queue.poll();\n\n            if (i == size - 1) {\n                result.add(node.val);\n            }\n\n            if (node.left != null) queue.offer(node.left);\n            if (node.right != null) queue.offer(node.right);\n        }\n    }\n    return result;\n}\n\n// DFS approach\nList<Integer> rightSideViewDFS(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n    dfs(root, 0, result);\n    return result;\n}\n\nvoid dfs(TreeNode root, int level, List<Integer> result) {\n    if (root == null) return;\n\n    if (level == result.size()) {\n        result.add(root.val);\n    }\n\n    dfs(root.right, level + 1, result);\n    dfs(root.left, level + 1, result);\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"102-left-side-view",children:"10.2 Left Side View"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"List<Integer> leftSideView(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n    if (root == null) return result;\n\n    Queue<TreeNode> queue = new ArrayDeque<>();\n    queue.offer(root);\n\n    while (!queue.isEmpty()) {\n        int size = queue.size();\n\n        for (int i = 0; i < size; i++) {\n            TreeNode node = queue.poll();\n\n            if (i == 0) {\n                result.add(node.val);\n            }\n\n            if (node.left != null) queue.offer(node.left);\n            if (node.right != null) queue.offer(node.right);\n        }\n    }\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"103-top-view",children:"10.3 Top View"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"class Pair {\n    TreeNode node;\n    int hd;\n    Pair(TreeNode node, int hd) {\n        this.node = node;\n        this.hd = hd;\n    }\n}\n\nList<Integer> topView(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n    if (root == null) return result;\n\n    TreeMap<Integer, Integer> map = new TreeMap<>();\n    Queue<Pair> queue = new ArrayDeque<>();\n    queue.offer(new Pair(root, 0));\n\n    while (!queue.isEmpty()) {\n        Pair pair = queue.poll();\n        TreeNode node = pair.node;\n        int hd = pair.hd;\n\n        if (!map.containsKey(hd)) {\n            map.put(hd, node.val);\n        }\n\n        if (node.left != null) {\n            queue.offer(new Pair(node.left, hd - 1));\n        }\n        if (node.right != null) {\n            queue.offer(new Pair(node.right, hd + 1));\n        }\n    }\n\n    result.addAll(map.values());\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"104-bottom-view",children:"10.4 Bottom View"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"List<Integer> bottomView(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n    if (root == null) return result;\n\n    TreeMap<Integer, Integer> map = new TreeMap<>();\n    Queue<Pair> queue = new ArrayDeque<>();\n    queue.offer(new Pair(root, 0));\n\n    while (!queue.isEmpty()) {\n        Pair pair = queue.poll();\n        TreeNode node = pair.node;\n        int hd = pair.hd;\n\n        map.put(hd, node.val); // Overwrite for bottom view\n\n        if (node.left != null) {\n            queue.offer(new Pair(node.left, hd - 1));\n        }\n        if (node.right != null) {\n            queue.offer(new Pair(node.right, hd + 1));\n        }\n    }\n\n    result.addAll(map.values());\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"105-vertical-order-traversal",children:"10.5 Vertical Order Traversal"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"List<List<Integer>> verticalOrder(TreeNode root) {\n    List<List<Integer>> result = new ArrayList<>();\n    if (root == null) return result;\n\n    TreeMap<Integer, List<Integer>> map = new TreeMap<>();\n    Queue<Pair> queue = new ArrayDeque<>();\n    queue.offer(new Pair(root, 0));\n\n    while (!queue.isEmpty()) {\n        Pair pair = queue.poll();\n        TreeNode node = pair.node;\n        int hd = pair.hd;\n\n        map.computeIfAbsent(hd, k -> new ArrayList<>()).add(node.val);\n\n        if (node.left != null) {\n            queue.offer(new Pair(node.left, hd - 1));\n        }\n        if (node.right != null) {\n            queue.offer(new Pair(node.right, hd + 1));\n        }\n    }\n\n    for (List<Integer> list : map.values()) {\n        result.add(list);\n    }\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"106-boundary-traversal",children:"10.6 Boundary Traversal"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"List<Integer> boundaryOfBinaryTree(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n    if (root == null) return result;\n\n    if (!isLeaf(root)) result.add(root.val);\n\n    addLeftBoundary(root.left, result);\n    addLeaves(root, result);\n    addRightBoundary(root.right, result);\n\n    return result;\n}\n\nboolean isLeaf(TreeNode node) {\n    return node != null && node.left == null && node.right == null;\n}\n\nvoid addLeftBoundary(TreeNode root, List<Integer> result) {\n    TreeNode curr = root;\n    while (curr != null) {\n        if (!isLeaf(curr)) result.add(curr.val);\n        curr = curr.left != null ? curr.left : curr.right;\n    }\n}\n\nvoid addRightBoundary(TreeNode root, List<Integer> result) {\n    TreeNode curr = root;\n    List<Integer> temp = new ArrayList<>();\n\n    while (curr != null) {\n        if (!isLeaf(curr)) temp.add(curr.val);\n        curr = curr.right != null ? curr.right : curr.left;\n    }\n\n    for (int i = temp.size() - 1; i >= 0; i--) {\n        result.add(temp.get(i));\n    }\n}\n\nvoid addLeaves(TreeNode root, List<Integer> result) {\n    if (root == null) return;\n\n    if (isLeaf(root)) {\n        result.add(root.val);\n        return;\n    }\n\n    addLeaves(root.left, result);\n    addLeaves(root.right, result);\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-11-distance--range-problems",children:"Pattern 11: Distance & Range Problems"}),"\n",(0,t.jsx)(n.h3,{id:"111-all-nodes-distance-k",children:"11.1 All Nodes Distance K"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"List<Integer> distanceK(TreeNode root, TreeNode target, int k) {\n    HashMap<TreeNode, TreeNode> parent = new HashMap<>();\n    buildParentMap(root, null, parent);\n\n    Queue<TreeNode> queue = new ArrayDeque<>();\n    HashSet<TreeNode> visited = new HashSet<>();\n\n    queue.offer(target);\n    visited.add(target);\n    int distance = 0;\n\n    while (!queue.isEmpty()) {\n        if (distance == k) {\n            List<Integer> result = new ArrayList<>();\n            for (TreeNode node : queue) {\n                result.add(node.val);\n            }\n            return result;\n        }\n\n        int size = queue.size();\n        for (int i = 0; i < size; i++) {\n            TreeNode node = queue.poll();\n\n            if (node.left != null && !visited.contains(node.left)) {\n                queue.offer(node.left);\n                visited.add(node.left);\n            }\n            if (node.right != null && !visited.contains(node.right)) {\n                queue.offer(node.right);\n                visited.add(node.right);\n            }\n            if (parent.get(node) != null && !visited.contains(parent.get(node))) {\n                queue.offer(parent.get(node));\n                visited.add(parent.get(node));\n            }\n        }\n        distance++;\n    }\n    return new ArrayList<>();\n}\n\nvoid buildParentMap(TreeNode root, TreeNode par, HashMap<TreeNode, TreeNode> parent) {\n    if (root == null) return;\n    parent.put(root, par);\n    buildParentMap(root.left, root, parent);\n    buildParentMap(root.right, root, parent);\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"112-width-of-binary-tree",children:"11.2 Width of Binary Tree"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"int widthOfBinaryTree(TreeNode root) {\n    if (root == null) return 0;\n\n    Queue<TreeNode> queue = new ArrayDeque<>();\n    HashMap<TreeNode, Integer> map = new HashMap<>();\n\n    queue.offer(root);\n    map.put(root, 0);\n    int maxWidth = 1;\n\n    while (!queue.isEmpty()) {\n        int size = queue.size();\n        int start = map.get(queue.peek());\n        int end = start;\n\n        for (int i = 0; i < size; i++) {\n            TreeNode node = queue.poll();\n            int idx = map.get(node);\n            end = idx;\n\n            if (node.left != null) {\n                queue.offer(node.left);\n                map.put(node.left, 2 * idx);\n            }\n            if (node.right != null) {\n                queue.offer(node.right);\n                map.put(node.right, 2 * idx + 1);\n            }\n        }\n        maxWidth = Math.max(maxWidth, end - start + 1);\n    }\n    return maxWidth;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-12-subtree-problems",children:"Pattern 12: Subtree Problems"}),"\n",(0,t.jsx)(n.h3,{id:"121-subtree-of-another-tree",children:"12.1 Subtree of Another Tree"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"boolean isSubtree(TreeNode root, TreeNode subRoot) {\n    if (root == null) return false;\n\n    if (isSameTree(root, subRoot)) return true;\n\n    return isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);\n}\n\nboolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (p == null || q == null) return false;\n\n    return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"122-count-univalue-subtrees",children:"12.2 Count Univalue Subtrees"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"int countUnivalSubtrees(TreeNode root) {\n    int[] count = new int[1];\n    isUnival(root, count);\n    return count[0];\n}\n\nboolean isUnival(TreeNode root, int[] count) {\n    if (root == null) return true;\n\n    boolean left = isUnival(root.left, count);\n    boolean right = isUnival(root.right, count);\n\n    if (!left || !right) return false;\n\n    if (root.left != null && root.left.val != root.val) return false;\n    if (root.right != null && root.right.val != root.val) return false;\n\n    count[0]++;\n    return true;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"123-maximum-average-subtree",children:"12.3 Maximum Average Subtree"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"double maximumAverageSubtree(TreeNode root) {\n    double[] max = new double[]{0.0};\n    helper(root, max);\n    return max[0];\n}\n\ndouble[] helper(TreeNode root, double[] max) {\n    if (root == null) return new double[]{0, 0}; // {sum, count}\n\n    double[] left = helper(root.left, max);\n    double[] right = helper(root.right, max);\n\n    double sum = root.val + left[0] + right[0];\n    double count = 1 + left[1] + right[1];\n    double avg = sum / count;\n\n    max[0] = Math.max(max[0], avg);\n\n    return new double[]{sum, count};\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"common-tree-problem-techniques-summary",children:"Common Tree Problem Techniques Summary"}),"\n",(0,t.jsxs)(n.h3,{id:"1-traversal-choice",children:["1. ",(0,t.jsx)(n.strong,{children:"Traversal Choice"})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Inorder"}),": BST problems, sorted order"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Preorder"}),": Tree construction, serialization"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Postorder"}),": Bottom-up processing, deletion"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Level Order"}),": Level-wise operations, shortest path"]}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"2-dfs-vs-bfs",children:["2. ",(0,t.jsx)(n.strong,{children:"DFS vs BFS"})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"DFS"}),": Path problems, tree properties, recursion-friendly"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"BFS"}),": Level-wise, shortest distance, width"]}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"3-helper-variables",children:["3. ",(0,t.jsx)(n.strong,{children:"Helper Variables"})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Use arrays/objects for mutable state in recursion"}),"\n",(0,t.jsx)(n.li,{children:"Pass level/depth information"}),"\n",(0,t.jsx)(n.li,{children:"Use HashMap for parent pointers"}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"4-common-patterns",children:["4. ",(0,t.jsx)(n.strong,{children:"Common Patterns"})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Two Pass"}),": First gather info, then process"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Post-order for bottom-up"}),": Children first, then parent"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Parent Pointers"}),": For upward traversal"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Horizontal Distance"}),": For vertical/top/bottom views"]}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"5-time-complexities",children:["5. ",(0,t.jsx)(n.strong,{children:"Time Complexities"})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Most tree operations: O(n)"}),"\n",(0,t.jsx)(n.li,{children:"BST search/insert/delete: O(h) where h = height"}),"\n",(0,t.jsx)(n.li,{children:"Balanced BST: O(log n)"}),"\n",(0,t.jsx)(n.li,{children:"Skewed tree: O(n)"}),"\n"]}),"\n",(0,t.jsx)(n.hr,{})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}}}]);