"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[6133],{2340:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>l});var r=t(4848),i=t(8453);const s={},o="Shortest Paths Problems",a={id:"DSA/ShortestPaths",title:"Shortest Paths Problems",description:"Problem: Shortest Path with Maximum Distance from Fire",source:"@site/docs/DSA/ShortestPaths.mdx",sourceDirName:"DSA",slug:"/DSA/ShortestPaths",permalink:"/js.enigma/docs/DSA/ShortestPaths",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/ShortestPaths.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Segment Tree Tutorial",permalink:"/js.enigma/docs/DSA/SegmentTree"},next:{title:"Sieve of Eratosthenes",permalink:"/js.enigma/docs/DSA/SieveOfEratosthenes"}},c={},l=[{value:"Problem: Shortest Path with Maximum Distance from Fire",id:"problem-shortest-path-with-maximum-distance-from-fire",level:2},{value:"Constraints",id:"constraints",level:2},{value:"Input",id:"input",level:2},{value:"Output",id:"output",level:2},{value:"Problem: Optimal Apartment Location",id:"problem-optimal-apartment-location",level:2},{value:"Description",id:"description",level:2},{value:"Constraints",id:"constraints-1",level:2},{value:"Input",id:"input-1",level:2},{value:"Output",id:"output-1",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"shortest-paths-problems",children:"Shortest Paths Problems"})}),"\n",(0,r.jsx)(e.h2,{id:"problem-shortest-path-with-maximum-distance-from-fire",children:"Problem: Shortest Path with Maximum Distance from Fire"}),"\n",(0,r.jsxs)(e.p,{children:["The ant can move in four directions: ",(0,r.jsx)(e.strong,{children:"up"}),", ",(0,r.jsx)(e.strong,{children:"down"}),", ",(0,r.jsx)(e.strong,{children:"left"}),", or ",(0,r.jsx)(e.strong,{children:"right"}),". The goal is to find the ",(0,r.jsx)(e.strong,{children:"shortest path"})," from ",(0,r.jsx)(e.code,{children:"(0, 0)"})," to ",(0,r.jsx)(e.code,{children:"(m-1, n-1)"})," while ensuring that the ant stays as far away from the fire as possible. Specifically, the path should maximize the ",(0,r.jsx)(e.strong,{children:"minimum distance"})," from any fire cell along the way."]}),"\n",(0,r.jsx)(e.h2,{id:"constraints",children:"Constraints"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:["The grid will have dimensions ",(0,r.jsx)(e.code,{children:"m x n"}),", where ",(0,r.jsx)(e.code,{children:"1 <= m, n <= 100"}),"."]}),"\n",(0,r.jsxs)(e.li,{children:["The ant cannot travel through cells with fire (",(0,r.jsx)(e.code,{children:"F"}),")."]}),"\n",(0,r.jsx)(e.li,{children:"The ant can move in four directions: up, down, left, or right."}),"\n",(0,r.jsxs)(e.li,{children:["If no valid path exists, return ",(0,r.jsx)(e.code,{children:"-1"}),"."]}),"\n",(0,r.jsx)(e.li,{children:"The distance from a cell to the fire is the Manhattan distance to the nearest fire cell."}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"input",children:"Input"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["A 2D grid of characters (",(0,r.jsx)(e.code,{children:"F"})," or ",(0,r.jsx)(e.code,{children:"."}),") representing the map."]}),"\n",(0,r.jsxs)(e.li,{children:["The starting position is ",(0,r.jsx)(e.code,{children:"(0, 0)"}),", and the destination is ",(0,r.jsx)(e.code,{children:"(m-1, n-1)"}),"."]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"output",children:"Output"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["Return the length of the shortest path from ",(0,r.jsx)(e.code,{children:"(0, 0)"})," to ",(0,r.jsx)(e.code,{children:"(m-1, n-1)"})," while maximizing the minimum distance from any fire cell."]}),"\n",(0,r.jsxs)(e.li,{children:["If no such path exists, return ",(0,r.jsx)(e.code,{children:"-1"}),"."]}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-JavaScript",children:"function shortestPathWithMaxDistanceFromFire(grid) {\r\n  const m = grid.length;\r\n  const n = grid[0].length;\r\n\r\n  // Directions for moving up, down, left, right\r\n  const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];\r\n\r\n  // Step 1: Precompute the distance of each cell from the nearest fire\r\n  const fireDistance = new Array(m).fill().map(() => new Array(n).fill(Infinity));\r\n  const queue = [];\r\n\r\n  // Initialize the queue with all fire positions\r\n  for (let i = 0; i < m; i++) {\r\n    for (let j = 0; j < n; j++) {\r\n      if (grid[i][j] === 'F') {\r\n        queue.push([i, j]);\r\n        fireDistance[i][j] = 0;\r\n      }\r\n    }\r\n  }\r\n\r\n  // BFS to compute the distance from each fire\r\n  while (queue.length > 0) {\r\n    const [x, y] = queue.shift();\r\n    for (const [dx, dy] of directions) {\r\n      const nx = x + dx;\r\n      const ny = y + dy;\r\n      if (nx >= 0 && nx < m && ny >= 0 && ny < n && fireDistance[nx][ny] === Infinity) {\r\n        fireDistance[nx][ny] = fireDistance[x][y] + 1;\r\n        queue.push([nx, ny]);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Step 2: Find the shortest path with maximum distance from fire\r\n  const visited = new Array(m).fill().map(() => new Array(n).fill(false));\r\n  const priorityQueue = [];\r\n\r\n  // Start from (0, 0) with distance 0 and the distance from fire at that cell\r\n  priorityQueue.push([0, 0, 0, fireDistance[0][0]]);\r\n  visited[0][0] = true;\r\n\r\n  while (priorityQueue.length > 0) {\r\n    priorityQueue.sort((a, b) => b[3] - a[3]); // Sort by distance from fire (max first)\r\n    const [x, y, dist, fireDist] = priorityQueue.pop();\r\n\r\n    // If we reach the destination, return the distance\r\n    if (x === m - 1 && y === n - 1) {\r\n      return dist;\r\n    }\r\n\r\n    // Explore all four directions\r\n    for (const [dx, dy] of directions) {\r\n      const nx = x + dx;\r\n      const ny = y + dy;\r\n      if (nx >= 0 && nx < m && ny >= 0 && ny < n && !visited[nx][ny] && grid[nx][ny] === '.') {\r\n        visited[nx][ny] = true;\r\n        priorityQueue.push([nx, ny, dist + 1, fireDistance[nx][ny]]);\r\n      }\r\n    }\r\n  }\r\n\r\n  // If no path is found\r\n  return -1;\r\n}\r\n\r\n// Example usage:\r\nconst grid = [\r\n  ['.', 'F', '.', '.'],\r\n  ['.', '.', '.', 'F'],\r\n  ['F', '.', '.', '.'],\r\n  ['.', '.', 'F', '.']\r\n];\r\n\r\nconsole.log(shortestPathWithMaxDistanceFromFire(grid)); // Output: 6\r\n\r\nconst grid2 = [\r\n  ['.', '.', '.', '.'],\r\n  ['.', 'F', '.', '.'],\r\n  ['.', '.', '.', '.'],\r\n  ['.', '.', '.', '.']\r\n];\r\n\r\nconsole.log(shortestPathWithMaxDistanceFromFire(grid2)); // Output: 5\n"})}),"\n",(0,r.jsx)(e.h2,{id:"problem-optimal-apartment-location",children:"Problem: Optimal Apartment Location"}),"\n",(0,r.jsx)(e.h2,{id:"description",children:"Description"}),"\n",(0,r.jsx)(e.p,{children:"You are planning to move to a new city and want to find the optimal apartment location. The city is represented as a 2D grid, where each cell can be:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"A potential apartment location."}),"\n",(0,r.jsx)(e.li,{children:"A key location (e.g., gym, office, restaurant, etc.)."}),"\n",(0,r.jsx)(e.li,{children:"An obstacle (e.g., park, lake, etc.) that cannot be traversed."}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["Your goal is to find the apartment location that is ",(0,r.jsx)(e.strong,{children:"closest to all key locations"})," (e.g., gym, office, restaurant, etc.). The optimal apartment is the one that minimizes the ",(0,r.jsx)(e.strong,{children:"total distance"})," (or travel time) to all key locations."]}),"\n",(0,r.jsx)(e.h2,{id:"constraints-1",children:"Constraints"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:["The grid will have dimensions ",(0,r.jsx)(e.code,{children:"m x n"}),", where ",(0,r.jsx)(e.code,{children:"1 <= m, n <= 100"}),"."]}),"\n",(0,r.jsxs)(e.li,{children:["You can move in four directions: ",(0,r.jsx)(e.strong,{children:"up"}),", ",(0,r.jsx)(e.strong,{children:"down"}),", ",(0,r.jsx)(e.strong,{children:"left"}),", or ",(0,r.jsx)(e.strong,{children:"right"}),"."]}),"\n",(0,r.jsxs)(e.li,{children:["Obstacles are represented by ",(0,r.jsx)(e.code,{children:"X"}),", and you cannot travel through them."]}),"\n",(0,r.jsxs)(e.li,{children:["Key locations are represented by unique identifiers (e.g., ",(0,r.jsx)(e.code,{children:"G"})," for gym, ",(0,r.jsx)(e.code,{children:"O"})," for office, ",(0,r.jsx)(e.code,{children:"R"})," for restaurant, etc.)."]}),"\n",(0,r.jsxs)(e.li,{children:["Apartment locations are represented by ",(0,r.jsx)(e.code,{children:"A"}),"."]}),"\n",(0,r.jsxs)(e.li,{children:["If no valid apartment location exists, return ",(0,r.jsx)(e.code,{children:"-1"}),"."]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"input-1",children:"Input"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["A 2D grid of characters representing the city map. The grid contains:","\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"A"}),": Potential apartment locations."]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"G"}),", ",(0,r.jsx)(e.code,{children:"O"}),", ",(0,r.jsx)(e.code,{children:"R"}),", etc.: Key locations (gym, office, restaurant, etc.)."]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"X"}),": Obstacles that cannot be traversed."]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"."}),": Empty spaces that can be traversed."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"output-1",children:"Output"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["Return the coordinates ",(0,r.jsx)(e.code,{children:"(x, y)"})," of the optimal apartment location that minimizes the total distance to all key locations."]}),"\n",(0,r.jsxs)(e.li,{children:["If no valid apartment location exists, return ",(0,r.jsx)(e.code,{children:"-1"}),"."]}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-JavaScript",children:"function findOptimalApartment(grid, keyLocations) {\r\n    const m = grid.length;\r\n    const n = grid[0].length;\r\n    const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]; // Up, Down, Left, Right\r\n\r\n    // Initialize distance grids for each key location\r\n    const distanceGrids = keyLocations.map(([x, y]) => {\r\n        const distanceGrid = new Array(m).fill().map(() => new Array(n).fill(Infinity));\r\n        const queue = [[x, y]];\r\n        distanceGrid[x][y] = 0;\r\n\r\n        // BFS to compute distances from this key location\r\n        while (queue.length > 0) {\r\n            const [cx, cy] = queue.shift();\r\n            for (const [dx, dy] of directions) {\r\n                const nx = cx + dx;\r\n                const ny = cy + dy;\r\n                if (nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] !== 'X' && distanceGrid[nx][ny] === Infinity) {\r\n                    distanceGrid[nx][ny] = distanceGrid[cx][cy] + 1;\r\n                    queue.push([nx, ny]);\r\n                }\r\n            }\r\n        }\r\n        return distanceGrid;\r\n    });\r\n\r\n    // Find the apartment with the smallest total distance to all key locations\r\n    let minTotalDistance = Infinity;\r\n    let optimalApartment = null;\r\n\r\n    for (let i = 0; i < m; i++) {\r\n        for (let j = 0; j < n; j++) {\r\n            if (grid[i][j] === 'A') { // 'A' represents an apartment\r\n                let totalDistance = 0;\r\n                for (const distanceGrid of distanceGrids) {\r\n                    totalDistance += distanceGrid[i][j];\r\n                }\r\n                if (totalDistance < minTotalDistance) {\r\n                    minTotalDistance = totalDistance;\r\n                    optimalApartment = [i, j];\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return optimalApartment;\r\n}\r\n\r\n// Example usage\r\nconst grid = [\r\n    ['.', '.', '.', '.', '.'],\r\n    ['.', 'G', '.', 'X', '.'],\r\n    ['.', '.', 'A', '.', '.'],\r\n    ['.', 'X', '.', 'O', '.'],\r\n    ['.', '.', '.', '.', 'R']\r\n];\r\n\r\nconst keyLocations = [\r\n    [1, 1], // Gym (G)\r\n    [3, 3], // Office (O)\r\n    [4, 4]  // Restaurant (R)\r\n];\r\n\r\nconst optimalApartment = findOptimalApartment(grid, keyLocations);\r\nconsole.log(\"Optimal Apartment Location:\", optimalApartment); // Output: [2, 2]\n"})})]})}function h(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>o,x:()=>a});var r=t(6540);const i={},s=r.createContext(i);function o(n){const e=r.useContext(s);return r.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:o(n.components),r.createElement(s.Provider,{value:e},n.children)}}}]);