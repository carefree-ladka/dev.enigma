"use strict";(globalThis.webpackChunkdev_enigma=globalThis.webpackChunkdev_enigma||[]).push([[89792],{18737:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>c,toc:()=>l});var i=r(74848),t=r(28453);const s={},o="Trie",c={id:"DSA/DSA/DSA with JavaScript/DSA Cheatsheets/Trie",title:"Trie",description:"A comprehensive guide to Trie (Prefix Tree) algorithms and techniques for Data Structures and Algorithms.",source:"@site/docs/05-DSA/DSA/DSA with JavaScript/DSA Cheatsheets/Trie.mdx",sourceDirName:"05-DSA/DSA/DSA with JavaScript/DSA Cheatsheets",slug:"/DSA/DSA/DSA with JavaScript/DSA Cheatsheets/Trie",permalink:"/docs/DSA/DSA/DSA with JavaScript/DSA Cheatsheets/Trie",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/05-DSA/DSA/DSA with JavaScript/DSA Cheatsheets/Trie.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Binary Tree",permalink:"/docs/DSA/DSA/DSA with JavaScript/DSA Cheatsheets/Tree"},next:{title:"Two Pointer",permalink:"/docs/DSA/DSA/DSA with JavaScript/DSA Cheatsheets/Two Pointer"}},d={},l=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Introduction to Trie",id:"introduction-to-trie",level:2},{value:"Key Properties",id:"key-properties",level:3},{value:"Visual Representation",id:"visual-representation",level:3},{value:"When to Use Trie",id:"when-to-use-trie",level:3},{value:"Time Complexity Overview",id:"time-complexity-overview",level:3},{value:"Basic Trie Implementation",id:"basic-trie-implementation",level:2},{value:"1. Array-based Trie Node",id:"1-array-based-trie-node",level:3},{value:"2. HashMap-based Trie Node (More Flexible)",id:"2-hashmap-based-trie-node-more-flexible",level:3},{value:"Search and Prefix Operations",id:"search-and-prefix-operations",level:2},{value:"1. Word Search with Wildcards",id:"1-word-search-with-wildcards",level:3},{value:"2. Auto-complete System",id:"2-auto-complete-system",level:3},{value:"3. Word Break with Trie",id:"3-word-break-with-trie",level:3},{value:"4. Longest Word in Dictionary",id:"4-longest-word-in-dictionary",level:3},{value:"Advanced Trie Techniques",id:"advanced-trie-techniques",level:2},{value:"1. Delete Operation with Cleanup",id:"1-delete-operation-with-cleanup",level:3},{value:"2. Longest Common Prefix",id:"2-longest-common-prefix",level:3},{value:"3. Count Distinct Substrings",id:"3-count-distinct-substrings",level:3},{value:"4. Replace Words (Root Dictionary)",id:"4-replace-words-root-dictionary",level:3},{value:"Compressed Trie (Radix Tree)",id:"compressed-trie-radix-tree",level:2},{value:"1. Radix Tree Implementation",id:"1-radix-tree-implementation",level:3},{value:"Trie with HashMap",id:"trie-with-hashmap",level:2},{value:"1. Word Search II (Board + Dictionary)",id:"1-word-search-ii-board--dictionary",level:3},{value:"2. Top K Frequent Words",id:"2-top-k-frequent-words",level:3},{value:"3. Stream of Characters",id:"3-stream-of-characters",level:3},{value:"Bitwise Trie",id:"bitwise-trie",level:2},{value:"1. Maximum XOR Trie",id:"1-maximum-xor-trie",level:3},{value:"2. Count Pairs with XOR in Range",id:"2-count-pairs-with-xor-in-range",level:3},{value:"Trie Applications",id:"trie-applications",level:2},{value:"1. Phone Directory (T9 Predictive Text)",id:"1-phone-directory-t9-predictive-text",level:3},{value:"2. Spell Checker with Edit Distance",id:"2-spell-checker-with-edit-distance",level:3},{value:"3. IP Address Trie (Longest Prefix Match)",id:"3-ip-address-trie-longest-prefix-match",level:3},{value:"4. Boggle Game Solver",id:"4-boggle-game-solver",level:3},{value:"Usage Examples",id:"usage-examples",level:2},{value:"Time Complexity Summary",id:"time-complexity-summary",level:2},{value:"Common Patterns to Remember",id:"common-patterns-to-remember",level:2},{value:"1. <strong>Basic Trie Template</strong>",id:"1-basic-trie-template",level:3},{value:"2. <strong>DFS for Word Collection</strong>",id:"2-dfs-for-word-collection",level:3},{value:"3. <strong>Backtracking with Trie</strong>",id:"3-backtracking-with-trie",level:3},{value:"4. <strong>Bitwise Trie for XOR</strong>",id:"4-bitwise-trie-for-xor",level:3},{value:"5. <strong>Delete with Cleanup</strong>",id:"5-delete-with-cleanup",level:3},{value:"Key Interview Tips",id:"key-interview-tips",level:2},{value:"Problem Recognition Checklist",id:"problem-recognition-checklist",level:3},{value:"Common Mistakes to Avoid",id:"common-mistakes-to-avoid",level:3},{value:"Space vs Time Tradeoffs",id:"space-vs-time-tradeoffs",level:3},{value:"Performance Optimization Tips",id:"performance-optimization-tips",level:3},{value:"Advanced Techniques",id:"advanced-techniques",level:3},{value:"Trie with Suffix Arrays",id:"trie-with-suffix-arrays",level:4},{value:"Concurrent Trie (Thread-Safe)",id:"concurrent-trie-thread-safe",level:4},{value:"Practice Problems by Difficulty",id:"practice-problems-by-difficulty",level:2},{value:"Beginner",id:"beginner",level:3},{value:"Intermediate",id:"intermediate",level:3},{value:"Advanced",id:"advanced",level:3},{value:"Expert",id:"expert",level:3}];function a(n){const e={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"trie",children:"Trie"})}),"\n",(0,i.jsx)(e.p,{children:"A comprehensive guide to Trie (Prefix Tree) algorithms and techniques for Data Structures and Algorithms."}),"\n",(0,i.jsx)(e.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#introduction-to-trie",children:"Introduction to Trie"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#basic-trie-implementation",children:"Basic Trie Implementation"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#search-and-prefix-operations",children:"Search and Prefix Operations"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#advanced-trie-techniques",children:"Advanced Trie Techniques"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#compressed-trie-radix-tree",children:"Compressed Trie (Radix Tree)"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#trie-with-hashmap",children:"Trie with HashMap"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#bitwise-trie",children:"Bitwise Trie"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#trie-applications",children:"Trie Applications"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#usage-examples",children:"Usage Examples"})}),"\n"]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"introduction-to-trie",children:"Introduction to Trie"}),"\n",(0,i.jsx)(e.p,{children:'A Trie (pronounced "try") is a tree-like data structure used for storing and searching strings efficiently. Also known as a prefix tree, it\'s particularly useful for applications involving string prefixes, autocomplete, and word games.'}),"\n",(0,i.jsx)(e.h3,{id:"key-properties",children:"Key Properties"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Root"}),": Empty node representing empty string"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Edges"}),": Represent characters"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Nodes"}),": Represent prefixes"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Leaf marking"}),": Indicates end of valid word"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Path from root"}),": Represents a string/prefix"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"visual-representation",children:"Visual Representation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"        root\n       /  |  \\\n      a   b   c\n     /    |    \\\n    p     a     a\n   /      |      \\\n  p       t       t\n /        |       |\ne         h       h\n(ape)   (bath)   (cat)\n"})}),"\n",(0,i.jsx)(e.h3,{id:"when-to-use-trie",children:"When to Use Trie"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Prefix-based searches"})," (autocomplete, search suggestions)"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Word games"})," (Scrabble, Boggle, crosswords)"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"String matching"})," with multiple patterns"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"IP routing"})," tables"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Dictionary operations"})," with prefix queries"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Longest common prefix"})," problems"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"time-complexity-overview",children:"Time Complexity Overview"}),"\n",(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:"Operation"}),(0,i.jsx)(e.th,{children:"Time"}),(0,i.jsx)(e.th,{children:"Space"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"Insert"}),(0,i.jsx)(e.td,{children:"O(m)"}),(0,i.jsx)(e.td,{children:"O(ALPHABET_SIZE \xd7 N \xd7 M)"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"Search"}),(0,i.jsx)(e.td,{children:"O(m)"}),(0,i.jsx)(e.td,{children:"-"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"Delete"}),(0,i.jsx)(e.td,{children:"O(m)"}),(0,i.jsx)(e.td,{children:"-"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"Prefix Search"}),(0,i.jsx)(e.td,{children:"O(p)"}),(0,i.jsx)(e.td,{children:"-"})]})]})]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.em,{children:"Where m = length of word, p = length of prefix, N = number of words, M = average length"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"basic-trie-implementation",children:"Basic Trie Implementation"}),"\n",(0,i.jsx)(e.h3,{id:"1-array-based-trie-node",children:"1. Array-based Trie Node"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"class TrieNode {\n  constructor() {\n    this.children = new Array(26).fill(null); // For lowercase a-z\n    this.isEndOfWord = false;\n    this.count = 0; // Optional: count of words ending here\n  }\n}\n\nclass Trie {\n  constructor() {\n    this.root = new TrieNode();\n  }\n\n  // Helper function to get character index\n  getIndex(char) {\n    return char.charCodeAt(0) - 'a'.charCodeAt(0);\n  }\n\n  // Insert a word into the trie\n  insert(word) {\n    let current = this.root;\n\n    for (const char of word) {\n      const index = this.getIndex(char);\n\n      if (current.children[index] === null) {\n        current.children[index] = new TrieNode();\n      }\n\n      current = current.children[index];\n    }\n\n    current.isEndOfWord = true;\n    current.count++;\n  }\n\n  // Search for a word in the trie\n  search(word) {\n    let current = this.root;\n\n    for (const char of word) {\n      const index = this.getIndex(char);\n\n      if (current.children[index] === null) {\n        return false;\n      }\n\n      current = current.children[index];\n    }\n\n    return current.isEndOfWord;\n  }\n\n  // Check if any word starts with the given prefix\n  startsWith(prefix) {\n    let current = this.root;\n\n    for (const char of prefix) {\n      const index = this.getIndex(char);\n\n      if (current.children[index] === null) {\n        return false;\n      }\n\n      current = current.children[index];\n    }\n\n    return true;\n  }\n}\n"})}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Time Complexity:"})," O(m) for all operations | ",(0,i.jsx)(e.strong,{children:"Space Complexity:"})," O(ALPHABET_SIZE \xd7 N \xd7 M)"]}),"\n",(0,i.jsx)(e.h3,{id:"2-hashmap-based-trie-node-more-flexible",children:"2. HashMap-based Trie Node (More Flexible)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"class TrieNodeMap {\n  constructor() {\n    this.children = new Map();\n    this.isEndOfWord = false;\n    this.count = 0;\n  }\n}\n\nclass TrieMap {\n  constructor() {\n    this.root = new TrieNodeMap();\n  }\n\n  insert(word) {\n    let current = this.root;\n\n    for (const char of word) {\n      if (!current.children.has(char)) {\n        current.children.set(char, new TrieNodeMap());\n      }\n      current = current.children.get(char);\n    }\n\n    current.isEndOfWord = true;\n    current.count++;\n  }\n\n  search(word) {\n    let current = this.root;\n\n    for (const char of word) {\n      if (!current.children.has(char)) {\n        return false;\n      }\n      current = current.children.get(char);\n    }\n\n    return current.isEndOfWord;\n  }\n\n  startsWith(prefix) {\n    let current = this.root;\n\n    for (const char of prefix) {\n      if (!current.children.has(char)) {\n        return false;\n      }\n      current = current.children.get(char);\n    }\n\n    return true;\n  }\n\n  // Get all words with given prefix\n  getWordsWithPrefix(prefix) {\n    let current = this.root;\n\n    // Navigate to prefix node\n    for (const char of prefix) {\n      if (!current.children.has(char)) {\n        return [];\n      }\n      current = current.children.get(char);\n    }\n\n    // DFS to collect all words\n    const words = [];\n    this.dfs(current, prefix, words);\n    return words;\n  }\n\n  dfs(node, currentWord, words) {\n    if (node.isEndOfWord) {\n      words.push(currentWord);\n    }\n\n    for (const [char, childNode] of node.children) {\n      this.dfs(childNode, currentWord + char, words);\n    }\n  }\n}\n"})}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"\ud83d\udd27 Technique:"})," HashMap-based implementation handles any character set (Unicode, special chars)!"]}),"\n"]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"search-and-prefix-operations",children:"Search and Prefix Operations"}),"\n",(0,i.jsx)(e.h3,{id:"1-word-search-with-wildcards",children:"1. Word Search with Wildcards"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"class WildcardTrie extends TrieMap {\n  // Search with '.' as wildcard matching any character\n  searchWildcard(word) {\n    return this.searchHelper(this.root, word, 0);\n  }\n\n  searchHelper(node, word, index) {\n    if (index === word.length) {\n      return node.isEndOfWord;\n    }\n\n    const char = word[index];\n\n    if (char === '.') {\n      // Try all possible characters\n      for (const childNode of node.children.values()) {\n        if (this.searchHelper(childNode, word, index + 1)) {\n          return true;\n        }\n      }\n      return false;\n    } else {\n      // Regular character\n      if (!node.children.has(char)) {\n        return false;\n      }\n      return this.searchHelper(node.children.get(char), word, index + 1);\n    }\n  }\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"2-auto-complete-system",children:"2. Auto-complete System"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"class AutoComplete {\n  constructor() {\n    this.trie = new TrieMap();\n    this.frequencies = new Map();\n  }\n\n  // Add sentence with frequency\n  input(sentence, frequency = 1) {\n    this.frequencies.set(\n      sentence,\n      (this.frequencies.get(sentence) || 0) + frequency\n    );\n    this.trie.insert(sentence);\n  }\n\n  // Get top k suggestions for prefix\n  search(prefix, k = 3) {\n    const words = this.trie.getWordsWithPrefix(prefix);\n\n    // Sort by frequency (descending) then lexicographically\n    words.sort((a, b) => {\n      const freqA = this.frequencies.get(a) || 0;\n      const freqB = this.frequencies.get(b) || 0;\n\n      if (freqA !== freqB) {\n        return freqB - freqA;\n      }\n      return a.localeCompare(b);\n    });\n\n    return words.slice(0, k);\n  }\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"3-word-break-with-trie",children:"3. Word Break with Trie"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function wordBreakTrie(s, wordDict) {\n  // Build trie from dictionary\n  const trie = new TrieMap();\n  for (const word of wordDict) {\n    trie.insert(word);\n  }\n\n  const memo = new Map();\n\n  function canBreak(start) {\n    if (start === s.length) return true;\n    if (memo.has(start)) return memo.get(start);\n\n    let current = trie.root;\n\n    for (let i = start; i < s.length; i++) {\n      const char = s[i];\n\n      if (!current.children.has(char)) {\n        break;\n      }\n\n      current = current.children.get(char);\n\n      if (current.isEndOfWord && canBreak(i + 1)) {\n        memo.set(start, true);\n        return true;\n      }\n    }\n\n    memo.set(start, false);\n    return false;\n  }\n\n  return canBreak(0);\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"4-longest-word-in-dictionary",children:"4. Longest Word in Dictionary"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function longestWord(words) {\n  const trie = new TrieMap();\n\n  // Insert all words\n  for (const word of words) {\n    trie.insert(word);\n  }\n\n  let longestWord = '';\n\n  function dfs(node, currentWord) {\n    // Update longest word if current is longer (or lexicographically smaller)\n    if (\n      currentWord.length > longestWord.length ||\n      (currentWord.length === longestWord.length && currentWord < longestWord)\n    ) {\n      longestWord = currentWord;\n    }\n\n    for (const [char, childNode] of node.children) {\n      // Only continue if the prefix is also a valid word\n      if (childNode.isEndOfWord) {\n        dfs(childNode, currentWord + char);\n      }\n    }\n  }\n\n  dfs(trie.root, '');\n  return longestWord;\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"advanced-trie-techniques",children:"Advanced Trie Techniques"}),"\n",(0,i.jsx)(e.h3,{id:"1-delete-operation-with-cleanup",children:"1. Delete Operation with Cleanup"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"class AdvancedTrie extends TrieMap {\n  delete(word) {\n    return this.deleteHelper(this.root, word, 0);\n  }\n\n  deleteHelper(node, word, index) {\n    if (index === word.length) {\n      // Reached end of word\n      if (!node.isEndOfWord) {\n        return false; // Word doesn't exist\n      }\n\n      node.isEndOfWord = false;\n      node.count = 0;\n\n      // Return true if node has no children (can be deleted)\n      return node.children.size === 0;\n    }\n\n    const char = word[index];\n    const childNode = node.children.get(char);\n\n    if (!childNode) {\n      return false; // Word doesn't exist\n    }\n\n    const shouldDeleteChild = this.deleteHelper(childNode, word, index + 1);\n\n    if (shouldDeleteChild) {\n      node.children.delete(char);\n\n      // Return true if current node can also be deleted\n      return !node.isEndOfWord && node.children.size === 0;\n    }\n\n    return false;\n  }\n\n  // Check if trie is empty\n  isEmpty() {\n    return this.root.children.size === 0;\n  }\n\n  // Get total number of words\n  getTotalWords() {\n    return this.getTotalWordsHelper(this.root);\n  }\n\n  getTotalWordsHelper(node) {\n    let count = node.count;\n\n    for (const childNode of node.children.values()) {\n      count += this.getTotalWordsHelper(childNode);\n    }\n\n    return count;\n  }\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"2-longest-common-prefix",children:"2. Longest Common Prefix"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function longestCommonPrefix(words) {\n  if (!words || words.length === 0) return '';\n\n  const trie = new TrieMap();\n\n  // Insert all words\n  for (const word of words) {\n    trie.insert(word);\n  }\n\n  let lcp = '';\n  let current = trie.root;\n\n  // Traverse while there's exactly one child and no word ends here\n  while (current.children.size === 1 && !current.isEndOfWord) {\n    const char = current.children.keys().next().value;\n    lcp += char;\n    current = current.children.get(char);\n  }\n\n  return lcp;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"3-count-distinct-substrings",children:"3. Count Distinct Substrings"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function countDistinctSubstrings(s) {\n  const trie = new TrieMap();\n\n  // Insert all suffixes\n  for (let i = 0; i < s.length; i++) {\n    let current = trie.root;\n\n    for (let j = i; j < s.length; j++) {\n      const char = s[j];\n\n      if (!current.children.has(char)) {\n        current.children.set(char, new TrieNodeMap());\n      }\n\n      current = current.children.get(char);\n    }\n  }\n\n  // Count nodes (excluding root)\n  return countNodes(trie.root) - 1;\n}\n\nfunction countNodes(node) {\n  let count = 1; // Count current node\n\n  for (const childNode of node.children.values()) {\n    count += countNodes(childNode);\n  }\n\n  return count;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"4-replace-words-root-dictionary",children:"4. Replace Words (Root Dictionary)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function replaceWords(dictionary, sentence) {\n  const trie = new TrieMap();\n\n  // Build trie with dictionary roots\n  for (const root of dictionary) {\n    trie.insert(root);\n  }\n\n  const words = sentence.split(' ');\n  const result = [];\n\n  for (const word of words) {\n    let current = trie.root;\n    let replacement = '';\n    let found = false;\n\n    for (const char of word) {\n      if (!current.children.has(char)) {\n        break;\n      }\n\n      replacement += char;\n      current = current.children.get(char);\n\n      if (current.isEndOfWord) {\n        found = true;\n        break;\n      }\n    }\n\n    result.push(found ? replacement : word);\n  }\n\n  return result.join(' ');\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"compressed-trie-radix-tree",children:"Compressed Trie (Radix Tree)"}),"\n",(0,i.jsx)(e.p,{children:"Space-optimized trie that compresses chains of single-child nodes."}),"\n",(0,i.jsx)(e.h3,{id:"1-radix-tree-implementation",children:"1. Radix Tree Implementation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"class RadixNode {\n  constructor(label = '') {\n    this.label = label; // String label for this edge\n    this.children = new Map();\n    this.isEndOfWord = false;\n  }\n}\n\nclass RadixTree {\n  constructor() {\n    this.root = new RadixNode();\n  }\n\n  insert(word) {\n    this.insertHelper(this.root, word);\n  }\n\n  insertHelper(node, word) {\n    if (word.length === 0) {\n      node.isEndOfWord = true;\n      return;\n    }\n\n    const firstChar = word[0];\n\n    if (node.children.has(firstChar)) {\n      const child = node.children.get(firstChar);\n      const commonLength = this.getCommonPrefixLength(child.label, word);\n\n      if (commonLength === child.label.length) {\n        // Full match with child label, continue recursively\n        this.insertHelper(child, word.substring(commonLength));\n      } else {\n        // Partial match, need to split the node\n        this.splitNode(child, commonLength);\n        this.insertHelper(child, word.substring(commonLength));\n      }\n    } else {\n      // No matching child, create new node\n      const newNode = new RadixNode(word);\n      newNode.isEndOfWord = true;\n      node.children.set(firstChar, newNode);\n    }\n  }\n\n  getCommonPrefixLength(str1, str2) {\n    let i = 0;\n    while (i < str1.length && i < str2.length && str1[i] === str2[i]) {\n      i++;\n    }\n    return i;\n  }\n\n  splitNode(node, splitIndex) {\n    const remainingLabel = node.label.substring(splitIndex);\n    const originalChildren = new Map(node.children);\n    const originalIsEndOfWord = node.isEndOfWord;\n\n    // Create new child with remaining label\n    const newChild = new RadixNode(remainingLabel);\n    newChild.children = originalChildren;\n    newChild.isEndOfWord = originalIsEndOfWord;\n\n    // Update current node\n    node.label = node.label.substring(0, splitIndex);\n    node.children.clear();\n    node.children.set(remainingLabel[0], newChild);\n    node.isEndOfWord = false;\n  }\n\n  search(word) {\n    let current = this.root;\n    let remaining = word;\n\n    while (remaining.length > 0) {\n      const firstChar = remaining[0];\n\n      if (!current.children.has(firstChar)) {\n        return false;\n      }\n\n      const child = current.children.get(firstChar);\n\n      if (remaining.startsWith(child.label)) {\n        remaining = remaining.substring(child.label.length);\n        current = child;\n      } else {\n        return false;\n      }\n    }\n\n    return current.isEndOfWord;\n  }\n}\n"})}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"\u26a1 Optimization:"})," Radix trees use O(n) space in worst case vs O(ALPHABET_SIZE \xd7 n) for regular tries!"]}),"\n"]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"trie-with-hashmap",children:"Trie with HashMap"}),"\n",(0,i.jsx)(e.p,{children:"Advanced applications using tries with additional data structures."}),"\n",(0,i.jsx)(e.h3,{id:"1-word-search-ii-board--dictionary",children:"1. Word Search II (Board + Dictionary)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function findWords(board, words) {\n  // Build trie from words\n  const trie = new TrieMap();\n  for (const word of words) {\n    trie.insert(word);\n  }\n\n  const result = new Set();\n  const rows = board.length;\n  const cols = board[0].length;\n  const directions = [\n    [0, 1],\n    [1, 0],\n    [0, -1],\n    [-1, 0],\n  ];\n\n  function dfs(row, col, node, currentWord, visited) {\n    if (row < 0 || row >= rows || col < 0 || col >= cols) return;\n    if (visited.has(`${row},${col}`)) return;\n\n    const char = board[row][col];\n    if (!node.children.has(char)) return;\n\n    const childNode = node.children.get(char);\n    const newWord = currentWord + char;\n\n    if (childNode.isEndOfWord) {\n      result.add(newWord);\n    }\n\n    visited.add(`${row},${col}`);\n\n    for (const [dr, dc] of directions) {\n      dfs(row + dr, col + dc, childNode, newWord, visited);\n    }\n\n    visited.delete(`${row},${col}`);\n  }\n\n  // Start DFS from each cell\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      dfs(i, j, trie.root, '', new Set());\n    }\n  }\n\n  return Array.from(result);\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"2-top-k-frequent-words",children:"2. Top K Frequent Words"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function topKFrequent(words, k) {\n  // Count frequencies\n  const frequency = new Map();\n  for (const word of words) {\n    frequency.set(word, (frequency.get(word) || 0) + 1);\n  }\n\n  // Build trie with frequency information\n  class FreqTrieNode extends TrieNodeMap {\n    constructor() {\n      super();\n      this.frequency = 0;\n    }\n  }\n\n  const trie = new TrieMap();\n  trie.root = new FreqTrieNode();\n\n  for (const [word, freq] of frequency) {\n    let current = trie.root;\n\n    for (const char of word) {\n      if (!current.children.has(char)) {\n        current.children.set(char, new FreqTrieNode());\n      }\n      current = current.children.get(char);\n    }\n\n    current.isEndOfWord = true;\n    current.frequency = freq;\n  }\n\n  // Collect words with frequencies\n  const wordsWithFreq = [];\n\n  function collectWords(node, currentWord) {\n    if (node.isEndOfWord) {\n      wordsWithFreq.push([currentWord, node.frequency]);\n    }\n\n    for (const [char, childNode] of node.children) {\n      collectWords(childNode, currentWord + char);\n    }\n  }\n\n  collectWords(trie.root, '');\n\n  // Sort by frequency (desc) then lexicographically (asc)\n  wordsWithFreq.sort(([wordA, freqA], [wordB, freqB]) => {\n    if (freqA !== freqB) return freqB - freqA;\n    return wordA.localeCompare(wordB);\n  });\n\n  return wordsWithFreq.slice(0, k).map(([word, freq]) => word);\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"3-stream-of-characters",children:"3. Stream of Characters"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"class StreamChecker {\n  constructor(words) {\n    this.trie = new TrieMap();\n    this.stream = '';\n    this.maxWordLength = 0;\n\n    // Insert reversed words for suffix matching\n    for (const word of words) {\n      const reversedWord = word.split('').reverse().join('');\n      this.trie.insert(reversedWord);\n      this.maxWordLength = Math.max(this.maxWordLength, word.length);\n    }\n  }\n\n  query(letter) {\n    this.stream += letter;\n\n    // Keep only last maxWordLength characters\n    if (this.stream.length > this.maxWordLength) {\n      this.stream = this.stream.substring(\n        this.stream.length - this.maxWordLength\n      );\n    }\n\n    // Check if any suffix of reversed stream matches a word\n    let current = this.trie.root;\n\n    for (let i = this.stream.length - 1; i >= 0; i--) {\n      const char = this.stream[i];\n\n      if (!current.children.has(char)) {\n        return false;\n      }\n\n      current = current.children.get(char);\n\n      if (current.isEndOfWord) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"bitwise-trie",children:"Bitwise Trie"}),"\n",(0,i.jsx)(e.p,{children:"Special trie for handling binary representations and XOR operations."}),"\n",(0,i.jsx)(e.h3,{id:"1-maximum-xor-trie",children:"1. Maximum XOR Trie"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"class BitTrieNode {\n  constructor() {\n    this.children = new Array(2).fill(null); // 0 and 1\n    this.value = -1; // Store the actual number at leaf\n  }\n}\n\nclass BitTrie {\n  constructor() {\n    this.root = new BitTrieNode();\n  }\n\n  insert(num) {\n    let current = this.root;\n\n    // Process 32 bits from MSB to LSB\n    for (let i = 31; i >= 0; i--) {\n      const bit = (num >> i) & 1;\n\n      if (current.children[bit] === null) {\n        current.children[bit] = new BitTrieNode();\n      }\n\n      current = current.children[bit];\n    }\n\n    current.value = num;\n  }\n\n  findMaxXOR(num) {\n    let current = this.root;\n    let maxXOR = 0;\n\n    for (let i = 31; i >= 0; i--) {\n      const bit = (num >> i) & 1;\n      const oppositeBit = 1 - bit;\n\n      if (current.children[oppositeBit] !== null) {\n        maxXOR |= 1 << i;\n        current = current.children[oppositeBit];\n      } else {\n        current = current.children[bit];\n      }\n    }\n\n    return maxXOR;\n  }\n}\n\nfunction findMaximumXOR(nums) {\n  const trie = new BitTrie();\n  let maxXOR = 0;\n\n  // Insert first number\n  trie.insert(nums[0]);\n\n  // For each subsequent number, find max XOR and insert it\n  for (let i = 1; i < nums.length; i++) {\n    maxXOR = Math.max(maxXOR, trie.findMaxXOR(nums[i]));\n    trie.insert(nums[i]);\n  }\n\n  return maxXOR;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"2-count-pairs-with-xor-in-range",children:"2. Count Pairs with XOR in Range"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function countPairsInRange(nums, low, high) {\n  const trie = new BitTrie();\n\n  function countPairsWithMaxXOR(maxXOR) {\n    let count = 0;\n\n    for (const num of nums) {\n      count += countPairsHelper(trie.root, num, maxXOR, 31);\n      trie.insert(num);\n    }\n\n    return count;\n  }\n\n  function countPairsHelper(node, num, maxXOR, bit) {\n    if (bit < 0) return 1;\n\n    const numBit = (num >> bit) & 1;\n    const maxBit = (maxXOR >> bit) & 1;\n    let count = 0;\n\n    if (maxBit === 1) {\n      // Can take either path\n      if (node.children[numBit] !== null) {\n        count += countPairsHelper(node.children[numBit], num, maxXOR, bit - 1);\n      }\n      if (node.children[1 - numBit] !== null) {\n        count += countPairsHelper(\n          node.children[1 - numBit],\n          num,\n          maxXOR,\n          bit - 1\n        );\n      }\n    } else {\n      // Must take the same bit to stay <= maxXOR\n      const requiredBit = numBit;\n      if (node.children[requiredBit] !== null) {\n        count += countPairsHelper(\n          node.children[requiredBit],\n          num,\n          maxXOR,\n          bit - 1\n        );\n      }\n    }\n\n    return count;\n  }\n\n  return countPairsWithMaxXOR(high) - countPairsWithMaxXOR(low - 1);\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"trie-applications",children:"Trie Applications"}),"\n",(0,i.jsx)(e.h3,{id:"1-phone-directory-t9-predictive-text",children:"1. Phone Directory (T9 Predictive Text)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"class T9Trie {\n  constructor() {\n    // Map phone digits to letters\n    this.digitToLetters = {\n      2: 'abc',\n      3: 'def',\n      4: 'ghi',\n      5: 'jkl',\n      6: 'mno',\n      7: 'pqrs',\n      8: 'tuv',\n      9: 'wxyz',\n    };\n\n    this.letterToDigit = {};\n\n    // Build reverse mapping\n    for (const [digit, letters] of Object.entries(this.digitToLetters)) {\n      for (const letter of letters) {\n        this.letterToDigit[letter] = digit;\n      }\n    }\n\n    this.trie = new TrieMap();\n  }\n\n  addWord(word) {\n    // Convert word to digit sequence\n    const digitSequence = word\n      .toLowerCase()\n      .split('')\n      .map(char => this.letterToDigit[char] || char)\n      .join('');\n\n    // Store both digit sequence and original word\n    let current = this.trie.root;\n\n    for (const digit of digitSequence) {\n      if (!current.children.has(digit)) {\n        current.children.set(digit, new TrieNodeMap());\n        current.children.get(digit).words = [];\n      }\n      current = current.children.get(digit);\n    }\n\n    if (!current.words) current.words = [];\n    current.words.push(word);\n    current.isEndOfWord = true;\n  }\n\n  getSuggestions(digitSequence, maxSuggestions = 10) {\n    let current = this.trie.root;\n\n    // Navigate to the digit sequence\n    for (const digit of digitSequence) {\n      if (!current.children.has(digit)) {\n        return [];\n      }\n      current = current.children.get(digit);\n    }\n\n    // Collect all words from this point\n    const suggestions = [];\n    this.collectWords(current, suggestions);\n\n    return suggestions.slice(0, maxSuggestions);\n  }\n\n  collectWords(node, result) {\n    if (node.words) {\n      result.push(...node.words);\n    }\n\n    for (const childNode of node.children.values()) {\n      this.collectWords(childNode, result);\n    }\n  }\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"2-spell-checker-with-edit-distance",children:"2. Spell Checker with Edit Distance"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"class SpellChecker {\n  constructor(dictionary) {\n    this.trie = new TrieMap();\n\n    for (const word of dictionary) {\n      this.trie.insert(word.toLowerCase());\n    }\n  }\n\n  // Find words within edit distance k\n  findSimilarWords(word, maxDistance = 1) {\n    const results = [];\n    const wordLower = word.toLowerCase();\n\n    this.searchWithDistance(\n      this.trie.root,\n      '',\n      wordLower,\n      maxDistance,\n      results\n    );\n\n    return results;\n  }\n\n  searchWithDistance(\n    node,\n    currentWord,\n    targetWord,\n    remainingDistance,\n    results\n  ) {\n    // If we've matched the entire target word\n    if (targetWord.length === 0) {\n      if (node.isEndOfWord) {\n        results.push(currentWord);\n      }\n      // Continue to find longer words if we have remaining distance\n      if (remainingDistance > 0) {\n        for (const [char, childNode] of node.children) {\n          this.searchWithDistance(\n            childNode,\n            currentWord + char,\n            '',\n            remainingDistance - 1,\n            results\n          );\n        }\n      }\n      return;\n    }\n\n    const targetChar = targetWord[0];\n    const remainingTarget = targetWord.substring(1);\n\n    for (const [char, childNode] of node.children) {\n      if (char === targetChar) {\n        // Exact match - no cost\n        this.searchWithDistance(\n          childNode,\n          currentWord + char,\n          remainingTarget,\n          remainingDistance,\n          results\n        );\n      } else if (remainingDistance > 0) {\n        // Substitution - cost 1\n        this.searchWithDistance(\n          childNode,\n          currentWord + char,\n          remainingTarget,\n          remainingDistance - 1,\n          results\n        );\n      }\n    }\n\n    // Insertion - add character from target without moving in trie\n    if (remainingDistance > 0) {\n      this.searchWithDistance(\n        node,\n        currentWord + targetChar,\n        remainingTarget,\n        remainingDistance - 1,\n        results\n      );\n    }\n\n    // Deletion - move in trie without consuming target character\n    if (remainingDistance > 0) {\n      for (const [char, childNode] of node.children) {\n        this.searchWithDistance(\n          childNode,\n          currentWord + char,\n          targetWord,\n          remainingDistance - 1,\n          results\n        );\n      }\n    }\n  }\n\n  // Simple spell check with suggestions\n  spellCheck(word) {\n    const wordLower = word.toLowerCase();\n\n    if (this.trie.search(wordLower)) {\n      return { isCorrect: true, suggestions: [] };\n    }\n\n    const suggestions = this.findSimilarWords(wordLower, 2);\n    return { isCorrect: false, suggestions };\n  }\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"3-ip-address-trie-longest-prefix-match",children:"3. IP Address Trie (Longest Prefix Match)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"class IPTrie {\n  constructor() {\n    this.root = new TrieNodeMap();\n    this.root.route = null; // Store routing information\n  }\n\n  // Convert IP to binary string\n  ipToBinary(ip) {\n    return ip\n      .split('.')\n      .map(octet => {\n        return parseInt(octet).toString(2).padStart(8, '0');\n      })\n      .join('');\n  }\n\n  // Add route with CIDR notation (e.g., \"192.168.1.0/24\")\n  addRoute(cidr, routeInfo) {\n    const [ip, prefixLength] = cidr.split('/');\n    const binaryIP = this.ipToBinary(ip);\n    const prefix = binaryIP.substring(0, parseInt(prefixLength));\n\n    let current = this.root;\n\n    for (const bit of prefix) {\n      if (!current.children.has(bit)) {\n        current.children.set(bit, new TrieNodeMap());\n        current.children.get(bit).route = null;\n      }\n      current = current.children.get(bit);\n    }\n\n    current.route = routeInfo;\n  }\n\n  // Find longest prefix match for an IP\n  longestPrefixMatch(ip) {\n    const binaryIP = this.ipToBinary(ip);\n    let current = this.root;\n    let lastMatchedRoute = current.route;\n\n    for (const bit of binaryIP) {\n      if (!current.children.has(bit)) {\n        break;\n      }\n\n      current = current.children.get(bit);\n\n      if (current.route !== null) {\n        lastMatchedRoute = current.route;\n      }\n    }\n\n    return lastMatchedRoute;\n  }\n}\n\n// Usage example\nconst ipTrie = new IPTrie();\nipTrie.addRoute('192.168.1.0/24', {\n  gateway: '192.168.1.1',\n  interface: 'eth0',\n});\nipTrie.addRoute('192.168.0.0/16', {\n  gateway: '192.168.0.1',\n  interface: 'eth1',\n});\nipTrie.addRoute('0.0.0.0/0', { gateway: '10.0.0.1', interface: 'eth2' }); // Default route\n\nconsole.log(ipTrie.longestPrefixMatch('192.168.1.100')); // Should match /24 route\n"})}),"\n",(0,i.jsx)(e.h3,{id:"4-boggle-game-solver",children:"4. Boggle Game Solver"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function findWordsInBoggle(board, dictionary) {\n  // Build trie from dictionary\n  const trie = new TrieMap();\n  for (const word of dictionary) {\n    trie.insert(word.toUpperCase());\n  }\n\n  const rows = board.length;\n  const cols = board[0].length;\n  const directions = [\n    [-1, -1],\n    [-1, 0],\n    [-1, 1],\n    [0, -1],\n    [0, 1],\n    [1, -1],\n    [1, 0],\n    [1, 1],\n  ];\n\n  const foundWords = new Set();\n\n  function dfs(row, col, node, currentWord, visited) {\n    if (row < 0 || row >= rows || col < 0 || col >= cols) return;\n    if (visited[row][col]) return;\n\n    const char = board[row][col].toUpperCase();\n    if (!node.children.has(char)) return;\n\n    const childNode = node.children.get(char);\n    const newWord = currentWord + char;\n\n    // Mark as visited\n    visited[row][col] = true;\n\n    // If we found a complete word (and it's at least 3 characters long)\n    if (childNode.isEndOfWord && newWord.length >= 3) {\n      foundWords.add(newWord);\n    }\n\n    // Continue searching in all directions\n    for (const [dr, dc] of directions) {\n      dfs(row + dr, col + dc, childNode, newWord, visited);\n    }\n\n    // Backtrack\n    visited[row][col] = false;\n  }\n\n  // Start DFS from each cell\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      const visited = Array(rows)\n        .fill(null)\n        .map(() => Array(cols).fill(false));\n      dfs(i, j, trie.root, '', visited);\n    }\n  }\n\n  return Array.from(foundWords).sort();\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"console.log('=== Trie Data Structure Demo ===');\n\n// Basic Trie Operations\nconst trie = new TrieMap();\nconst words = ['apple', 'app', 'application', 'apply', 'banana'];\n\nfor (const word of words) {\n  trie.insert(word);\n}\n\nconsole.log(\"Search 'app':\", trie.search('app')); // true\nconsole.log(\"Search 'appl':\", trie.search('appl')); // false\nconsole.log(\"Starts with 'app':\", trie.startsWith('app')); // true\nconsole.log(\"Words with prefix 'app':\", trie.getWordsWithPrefix('app'));\n// [\"app\", \"apple\", \"application\", \"apply\"]\n\n// Wildcard Search\nconst wildcardTrie = new WildcardTrie();\nwildcardTrie.insert('bad');\nwildcardTrie.insert('dad');\nwildcardTrie.insert('mad');\n\nconsole.log(\"Search 'b.d':\", wildcardTrie.searchWildcard('b.d')); // true\nconsole.log(\"Search '.ad':\", wildcardTrie.searchWildcard('.ad')); // true\n\n// Auto-complete System\nconst autoComplete = new AutoComplete();\nautoComplete.input('i love you', 5);\nautoComplete.input('island', 3);\nautoComplete.input('i love leetcode', 2);\n\nconsole.log(\"Autocomplete 'i':\", autoComplete.search('i', 3));\n// [\"i love you\", \"island\", \"i love leetcode\"]\n\n// Word Break\nconst wordDict = ['apple', 'pen', 'applepen', 'pine', 'pineapple'];\nconsole.log(\n  \"Word break 'pineapplepenapple':\",\n  wordBreakTrie('pineapplepenapple', wordDict)\n); // true\n\n// Longest Common Prefix\nconst words2 = ['flower', 'flow', 'flight'];\nconsole.log('Longest common prefix:', longestCommonPrefix(words2)); // \"fl\"\n\n// Replace Words\nconst dictionary = ['cat', 'bat', 'rat'];\nconst sentence = 'the cattle was rattled by the battery';\nconsole.log('Replace words:', replaceWords(dictionary, sentence));\n// \"the cat was rat by the bat\"\n\n// Maximum XOR\nconst nums = [3, 10, 5, 25, 2, 8];\nconsole.log('Maximum XOR:', findMaximumXOR(nums)); // 28\n\n// Spell Checker\nconst spellChecker = new SpellChecker(['hello', 'world', 'help', 'held']);\nconsole.log(\"Spell check 'helo':\", spellChecker.spellCheck('helo'));\n// { isCorrect: false, suggestions: [\"hello\", \"help\", \"held\"] }\n\n// Boggle Solver\nconst board = [\n  ['E', 'A', 'A', 'N'],\n  ['T', 'T', 'A', 'E'],\n  ['I', 'H', 'K', 'R'],\n  ['I', 'F', 'L', 'V'],\n];\nconst boggleDict = ['eat', 'rain', 'hike', 'fire', 'lair'];\nconsole.log('Boggle words:', findWordsInBoggle(board, boggleDict));\n\n// IP Routing\nconst ipTrie = new IPTrie();\nipTrie.addRoute('192.168.1.0/24', { gateway: '192.168.1.1' });\nipTrie.addRoute('0.0.0.0/0', { gateway: '10.0.0.1' });\n\nconsole.log(\n  'Route for 192.168.1.100:',\n  ipTrie.longestPrefixMatch('192.168.1.100')\n);\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"time-complexity-summary",children:"Time Complexity Summary"}),"\n",(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:"Operation"}),(0,i.jsx)(e.th,{children:"Trie"}),(0,i.jsx)(e.th,{children:"Compressed Trie"}),(0,i.jsx)(e.th,{children:"Hash Map"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"Insert"}),(0,i.jsx)(e.td,{children:"O(m)"}),(0,i.jsx)(e.td,{children:"O(m)"}),(0,i.jsx)(e.td,{children:"O(1) avg"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"Search"}),(0,i.jsx)(e.td,{children:"O(m)"}),(0,i.jsx)(e.td,{children:"O(m)"}),(0,i.jsx)(e.td,{children:"O(1) avg"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"Delete"}),(0,i.jsx)(e.td,{children:"O(m)"}),(0,i.jsx)(e.td,{children:"O(m)"}),(0,i.jsx)(e.td,{children:"O(1) avg"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"Prefix Search"}),(0,i.jsx)(e.td,{children:"O(p)"}),(0,i.jsx)(e.td,{children:"O(p)"}),(0,i.jsx)(e.td,{children:"O(n)"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"Space"}),(0,i.jsx)(e.td,{children:"O(ALPHABET \xd7 N \xd7 M)"}),(0,i.jsx)(e.td,{children:"O(N \xd7 M)"}),(0,i.jsx)(e.td,{children:"O(N \xd7 M)"})]})]})]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.em,{children:"Where m = word length, p = prefix length, N = number of words, M = average word length"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"common-patterns-to-remember",children:"Common Patterns to Remember"}),"\n",(0,i.jsxs)(e.h3,{id:"1-basic-trie-template",children:["1. ",(0,i.jsx)(e.strong,{children:"Basic Trie Template"})]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"class TrieNode {\n  constructor() {\n    this.children = new Map(); // or Array for fixed alphabet\n    this.isEndOfWord = false;\n  }\n}\n\nclass Trie {\n  constructor() {\n    this.root = new TrieNode();\n  }\n\n  insert(word) {\n    let current = this.root;\n    for (const char of word) {\n      if (!current.children.has(char)) {\n        current.children.set(char, new TrieNode());\n      }\n      current = current.children.get(char);\n    }\n    current.isEndOfWord = true;\n  }\n}\n"})}),"\n",(0,i.jsxs)(e.h3,{id:"2-dfs-for-word-collection",children:["2. ",(0,i.jsx)(e.strong,{children:"DFS for Word Collection"})]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function collectWords(node, prefix, result) {\n  if (node.isEndOfWord) {\n    result.push(prefix);\n  }\n\n  for (const [char, childNode] of node.children) {\n    collectWords(childNode, prefix + char, result);\n  }\n}\n"})}),"\n",(0,i.jsxs)(e.h3,{id:"3-backtracking-with-trie",children:["3. ",(0,i.jsx)(e.strong,{children:"Backtracking with Trie"})]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function dfsWithBacktrack(board, row, col, node, currentWord, visited, result) {\n  // Boundary checks\n  if (row < 0 || row >= rows || col < 0 || col >= cols) return;\n  if (visited[row][col]) return;\n\n  const char = board[row][col];\n  if (!node.children.has(char)) return;\n\n  // Mark visited\n  visited[row][col] = true;\n  const childNode = node.children.get(char);\n\n  if (childNode.isEndOfWord) {\n    result.add(currentWord + char);\n  }\n\n  // Explore neighbors\n  for (const [dr, dc] of directions) {\n    dfsWithBacktrack(\n      board,\n      row + dr,\n      col + dc,\n      childNode,\n      currentWord + char,\n      visited,\n      result\n    );\n  }\n\n  // Backtrack\n  visited[row][col] = false;\n}\n"})}),"\n",(0,i.jsxs)(e.h3,{id:"4-bitwise-trie-for-xor",children:["4. ",(0,i.jsx)(e.strong,{children:"Bitwise Trie for XOR"})]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"class BitTrie {\n  insert(num) {\n    let current = this.root;\n    for (let i = 31; i >= 0; i--) {\n      const bit = (num >> i) & 1;\n      if (!current.children[bit]) {\n        current.children[bit] = new BitTrieNode();\n      }\n      current = current.children[bit];\n    }\n  }\n\n  findMaxXOR(num) {\n    let current = this.root;\n    let maxXOR = 0;\n\n    for (let i = 31; i >= 0; i--) {\n      const bit = (num >> i) & 1;\n      const oppositeBit = 1 - bit;\n\n      if (current.children[oppositeBit]) {\n        maxXOR |= 1 << i;\n        current = current.children[oppositeBit];\n      } else {\n        current = current.children[bit];\n      }\n    }\n\n    return maxXOR;\n  }\n}\n"})}),"\n",(0,i.jsxs)(e.h3,{id:"5-delete-with-cleanup",children:["5. ",(0,i.jsx)(e.strong,{children:"Delete with Cleanup"})]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function deleteWord(node, word, index) {\n  if (index === word.length) {\n    if (!node.isEndOfWord) return false;\n    node.isEndOfWord = false;\n    return node.children.size === 0; // Can delete if no children\n  }\n\n  const char = word[index];\n  const childNode = node.children.get(char);\n\n  if (!childNode) return false;\n\n  const shouldDelete = deleteWord(childNode, word, index + 1);\n\n  if (shouldDelete) {\n    node.children.delete(char);\n    return !node.isEndOfWord && node.children.size === 0;\n  }\n\n  return false;\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"key-interview-tips",children:"Key Interview Tips"}),"\n",(0,i.jsx)(e.h3,{id:"problem-recognition-checklist",children:"Problem Recognition Checklist"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Use Trie when you see:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\u2705 ",(0,i.jsx)(e.strong,{children:"Prefix-based operations"})," (autocomplete, search suggestions)"]}),"\n",(0,i.jsxs)(e.li,{children:["\u2705 ",(0,i.jsx)(e.strong,{children:"Word games"})," (Boggle, Scrabble, crosswords)"]}),"\n",(0,i.jsxs)(e.li,{children:["\u2705 ",(0,i.jsx)(e.strong,{children:"Multiple pattern matching"})," in strings"]}),"\n",(0,i.jsxs)(e.li,{children:["\u2705 ",(0,i.jsx)(e.strong,{children:"Dictionary operations"})," with prefix queries"]}),"\n",(0,i.jsxs)(e.li,{children:["\u2705 ",(0,i.jsx)(e.strong,{children:"String collections"})," with common prefixes"]}),"\n",(0,i.jsxs)(e.li,{children:["\u2705 ",(0,i.jsx)(e.strong,{children:"Longest common prefix"})," problems"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Use Bitwise Trie for:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\u2705 ",(0,i.jsx)(e.strong,{children:"XOR problems"})," with arrays of numbers"]}),"\n",(0,i.jsxs)(e.li,{children:["\u2705 ",(0,i.jsx)(e.strong,{children:"Maximum/minimum XOR"})," queries"]}),"\n",(0,i.jsxs)(e.li,{children:["\u2705 ",(0,i.jsx)(e.strong,{children:"Bit manipulation"})," on collections"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"common-mistakes-to-avoid",children:"Common Mistakes to Avoid"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Forgetting isEndOfWord"}),": Not marking word endings properly"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Memory leaks"}),": Not cleaning up nodes during deletion"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Case sensitivity"}),": Inconsistent handling of upper/lowercase"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Null pointer errors"}),": Not checking if children exist"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Over-engineering"}),": Using trie when hash map would suffice"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"space-vs-time-tradeoffs",children:"Space vs Time Tradeoffs"}),"\n",(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:"Scenario"}),(0,i.jsx)(e.th,{children:"Trie Advantage"}),(0,i.jsx)(e.th,{children:"Hash Map Advantage"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Prefix operations"})}),(0,i.jsx)(e.td,{children:"O(p) prefix search"}),(0,i.jsx)(e.td,{children:"O(n) to find all prefixes"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Memory usage"})}),(0,i.jsx)(e.td,{children:"Shared prefixes save space"}),(0,i.jsx)(e.td,{children:"Each word stored separately"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Insertion/Search"})}),(0,i.jsx)(e.td,{children:"O(m) guaranteed"}),(0,i.jsx)(e.td,{children:"O(1) average case"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Implementation"})}),(0,i.jsx)(e.td,{children:"More complex"}),(0,i.jsx)(e.td,{children:"Simpler"})]})]})]}),"\n",(0,i.jsx)(e.h3,{id:"performance-optimization-tips",children:"Performance Optimization Tips"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Use arrays for fixed alphabets"})," (26 lowercase letters)"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Use hash maps for arbitrary characters"})," (Unicode, mixed case)"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Consider compressed tries"})," for sparse data"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Add early termination"})," in search algorithms"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Implement lazy deletion"})," for better performance"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"advanced-techniques",children:"Advanced Techniques"}),"\n",(0,i.jsx)(e.h4,{id:"trie-with-suffix-arrays",children:"Trie with Suffix Arrays"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// For advanced string algorithms\nclass SuffixTrie {\n  constructor(text) {\n    this.trie = new TrieMap();\n    this.buildSuffixTrie(text);\n  }\n\n  buildSuffixTrie(text) {\n    for (let i = 0; i < text.length; i++) {\n      this.trie.insert(text.substring(i));\n    }\n  }\n}\n"})}),"\n",(0,i.jsx)(e.h4,{id:"concurrent-trie-thread-safe",children:"Concurrent Trie (Thread-Safe)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"class ConcurrentTrie {\n  constructor() {\n    this.trie = new TrieMap();\n    this.locks = new Map(); // Simplified locking mechanism\n  }\n\n  // Add proper synchronization for multi-threaded environments\n  safeInsert(word) {\n    // Implementation would include proper locking\n    this.trie.insert(word);\n  }\n}\n"})}),"\n",(0,i.jsx)(e.p,{children:"This comprehensive guide covers all essential Trie techniques for coding interviews and competitive programming. The combination of trie with various algorithms (DFS, backtracking, bit manipulation) makes it a versatile data structure for many string and prefix-related problems!"}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"practice-problems-by-difficulty",children:"Practice Problems by Difficulty"}),"\n",(0,i.jsx)(e.h3,{id:"beginner",children:"Beginner"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"Implement Trie (Prefix Tree)"}),"\n",(0,i.jsx)(e.li,{children:"Longest Common Prefix"}),"\n",(0,i.jsx)(e.li,{children:"Design Add and Search Words Data Structure"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"intermediate",children:"Intermediate"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"Word Search II"}),"\n",(0,i.jsx)(e.li,{children:"Replace Words"}),"\n",(0,i.jsx)(e.li,{children:"Top K Frequent Words"}),"\n",(0,i.jsx)(e.li,{children:"Stream of Characters"}),"\n",(0,i.jsx)(e.li,{children:"Word Break with Trie"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"advanced",children:"Advanced"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"Maximum XOR of Two Numbers in Array"}),"\n",(0,i.jsx)(e.li,{children:"Count Pairs with XOR in Range"}),"\n",(0,i.jsx)(e.li,{children:"Palindrome Pairs"}),"\n",(0,i.jsx)(e.li,{children:"Index Pairs of a String"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"expert",children:"Expert"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"Design Search Autocomplete System"}),"\n",(0,i.jsx)(e.li,{children:"Word Squares"}),"\n",(0,i.jsx)(e.li,{children:"Concatenated Words"}),"\n",(0,i.jsx)(e.li,{children:"Number of Distinct Substrings using Suffix Trie"}),"\n"]})]})}function h(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(a,{...n})}):a(n)}},28453:(n,e,r)=>{r.d(e,{R:()=>o,x:()=>c});var i=r(96540);const t={},s=i.createContext(t);function o(n){const e=i.useContext(s);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function c(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:o(n.components),i.createElement(s.Provider,{value:e},n.children)}}}]);