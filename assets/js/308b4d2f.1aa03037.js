"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[6240],{8236:(r,e,n)=>{n.r(e),n.d(e,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>s,metadata:()=>d,toc:()=>l});var t=n(4848),o=n(8453);const s={title:"Trie Data Structure"},i=void 0,d={id:"DSA/Trie",title:"Trie Data Structure",description:"Trie Data Structure",source:"@site/docs/DSA/Trie.mdx",sourceDirName:"DSA",slug:"/DSA/Trie",permalink:"/js.enigma/docs/DSA/Trie",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/Trie.mdx",tags:[],version:"current",frontMatter:{title:"Trie Data Structure"},sidebar:"tutorialSidebar",previous:{title:"TreeSet",permalink:"/js.enigma/docs/DSA/TreeSet"},next:{title:"Two Pointers Technique",permalink:"/js.enigma/docs/DSA/TwoPointers"}},c={},l=[{value:"Trie Data Structure",id:"trie-data-structure",level:2},{value:"Key Concepts",id:"key-concepts",level:3},{value:"Operations",id:"operations",level:3},{value:"Code Implementation",id:"code-implementation",level:3},{value:"XOR Trie",id:"xor-trie",level:2}];function a(r){const e={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...r.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{id:"trie-data-structure",children:"Trie Data Structure"}),"\n",(0,t.jsx)(e.p,{children:"A Trie, also known as a prefix tree or digital tree, is a specialized tree used to store associative data structures. It is commonly used for storing strings or sequences where it can efficiently support operations like insertion, deletion, and prefix search."}),"\n",(0,t.jsx)(e.h3,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Nodes"}),": Each node represents a character of the stored strings."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Edges"}),": The edges between nodes represent the transitions from one character to the next."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Root"}),": The root node represents the starting point of the Trie and does not store any character."]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"operations",children:"Operations"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Insertion"}),": Add a new string to the Trie."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Search"}),": Check if a string exists in the Trie."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Prefix Search"}),": Find all strings that share a common prefix."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Deletion"}),": Remove a string from the Trie."]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"code-implementation",children:"Code Implementation"}),"\n",(0,t.jsx)(e.p,{children:"Here's a basic implementation of a Trie in JavaScript:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:'class TrieNode {\r\n  constructor() {\r\n    this.children = {};\r\n    this.isEndOfWord = false;\r\n    this.frequency = 0;    // Track word frequency\r\n    this.lastAccessed = 0; // Track last access timestamp\r\n  }\r\n}\r\n\r\nclass Trie {\r\n  constructor() {\r\n    this.root = new TrieNode();\r\n    this.wordCount = 0;    // Track total number of words\r\n  }\r\n\r\n  insert(word) {\r\n    if (!word) return;\r\n    let node = this.root;\r\n    for (const char of word) {\r\n      if (!node.children[char]) {\r\n        node.children[char] = new TrieNode();\r\n      }\r\n      node = node.children[char];\r\n    }\r\n    if (!node.isEndOfWord) {\r\n      this.wordCount++;\r\n    }\r\n    node.isEndOfWord = true;\r\n    node.frequency++;\r\n    node.lastAccessed = Date.now();\r\n  }\r\n\r\n  search(word) {\r\n    let node = this.traverse(word);\r\n    if (node && node.isEndOfWord) {\r\n      node.lastAccessed = Date.now();\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  startsWith(prefix) {\r\n    return this.traverse(prefix) !== null;\r\n  }\r\n\r\n  // Helper method to traverse to a node\r\n  traverse(str) {\r\n    let node = this.root;\r\n    for (const char of str) {\r\n      if (!node.children[char]) {\r\n        return null;\r\n      }\r\n      node = node.children[char];\r\n    }\r\n    return node;\r\n  }\r\n\r\n  // Delete a word from the trie\r\n  delete(word) {\r\n    return this.#deleteHelper(this.root, word, 0);\r\n  }\r\n\r\n  #deleteHelper(node, word, depth) {\r\n    if (!node) return false;\r\n\r\n    // If we\'ve reached the end of the word\r\n    if (depth === word.length) {\r\n      if (!node.isEndOfWord) return false;\r\n      \r\n      node.isEndOfWord = false;\r\n      node.frequency = 0;\r\n      this.wordCount--;\r\n      \r\n      // Return true if node has no children\r\n      return Object.keys(node.children).length === 0;\r\n    }\r\n\r\n    const char = word[depth];\r\n    const shouldDeleteChild = this.#deleteHelper(node.children[char], word, depth + 1);\r\n\r\n    // If child should be deleted, remove it\r\n    if (shouldDeleteChild) {\r\n      delete node.children[char];\r\n      // Return true if this node should also be deleted\r\n      return !node.isEndOfWord && Object.keys(node.children).length === 0;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  // Get word frequency\r\n  getFrequency(word) {\r\n    const node = this.traverse(word);\r\n    return node ? node.frequency : 0;\r\n  }\r\n\r\n  // Get all words in the trie\r\n  getAllWords() {\r\n    const words = [];\r\n    this.#collectAllWords(this.root, \'\', words);\r\n    return words;\r\n  }\r\n\r\n  // Get words sorted by frequency\r\n  getWordsByFrequency() {\r\n    const words = this.getAllWords();\r\n    return words.sort((a, b) => {\r\n      const nodeA = this.traverse(a);\r\n      const nodeB = this.traverse(b);\r\n      return nodeB.frequency - nodeA.frequency;\r\n    });\r\n  }\r\n\r\n  // Get recently accessed words\r\n  getRecentWords(limit = 10) {\r\n    const words = this.getAllWords();\r\n    return words.sort((a, b) => {\r\n      const nodeA = this.traverse(a);\r\n      const nodeB = this.traverse(b);\r\n      return nodeB.lastAccessed - nodeA.lastAccessed;\r\n    }).slice(0, limit);\r\n  }\r\n\r\n  // Get words with wildcard pattern (? for single char, * for multiple chars)\r\n  searchWithWildcard(pattern) {\r\n    const results = [];\r\n    this.#searchWithWildcardHelper(this.root, \'\', pattern, 0, results);\r\n    return results;\r\n  }\r\n\r\n  #searchWithWildcardHelper(node, current, pattern, index, results) {\r\n    if (index === pattern.length) {\r\n      if (node.isEndOfWord) {\r\n        results.push(current);\r\n      }\r\n      return;\r\n    }\r\n\r\n    const char = pattern[index];\r\n    if (char === \'?\') {\r\n      // Match any single character\r\n      for (const nextChar in node.children) {\r\n        this.#searchWithWildcardHelper(\r\n          node.children[nextChar],\r\n          current + nextChar,\r\n          pattern,\r\n          index + 1,\r\n          results\r\n        );\r\n      }\r\n    } else if (char === \'*\') {\r\n      // Match zero or more characters\r\n      // Match zero characters\r\n      this.#searchWithWildcardHelper(node, current, pattern, index + 1, results);\r\n      // Match one or more characters\r\n      for (const nextChar in node.children) {\r\n        this.#searchWithWildcardHelper(\r\n          node.children[nextChar],\r\n          current + nextChar,\r\n          pattern,\r\n          index,\r\n          results\r\n        );\r\n      }\r\n    } else {\r\n      // Match exact character\r\n      if (node.children[char]) {\r\n        this.#searchWithWildcardHelper(\r\n          node.children[char],\r\n          current + char,\r\n          pattern,\r\n          index + 1,\r\n          results\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  // Find longest word in trie\r\n  getLongestWord() {\r\n    return this.#findLongestWord(this.root, \'\');\r\n  }\r\n\r\n  #findLongestWord(node, current) {\r\n    let longest = node.isEndOfWord ? current : \'\';\r\n\r\n    for (const char in node.children) {\r\n      const childResult = this.#findLongestWord(node.children[char], current + char);\r\n      if (childResult.length > longest.length) {\r\n        longest = childResult;\r\n      }\r\n    }\r\n\r\n    return longest;\r\n  }\r\n\r\n  // Helper function for autocomplete and collecting words\r\n  #collectAllWords(node, prefix, results) {\r\n    if (node.isEndOfWord) {\r\n      results.push(prefix);\r\n    }\r\n    for (let char in node.children) {\r\n      this.#collectAllWords(node.children[char], prefix + char, results);\r\n    }\r\n  }\r\n\r\n  // Get size statistics\r\n  getStats() {\r\n    return {\r\n      totalWords: this.wordCount,\r\n      totalNodes: this.#countNodes(this.root),\r\n      maxDepth: this.#getMaxDepth(this.root),\r\n      memoryUsage: this.#approximateMemoryUsage()\r\n    };\r\n  }\r\n\r\n  #countNodes(node) {\r\n    let count = 1;\r\n    for (const child in node.children) {\r\n      count += this.#countNodes(node.children[child]);\r\n    }\r\n    return count;\r\n  }\r\n\r\n  #getMaxDepth(node, depth = 0) {\r\n    if (Object.keys(node.children).length === 0) {\r\n      return depth;\r\n    }\r\n    let maxDepth = depth;\r\n    for (const child in node.children) {\r\n      maxDepth = Math.max(maxDepth, this.#getMaxDepth(node.children[child], depth + 1));\r\n    }\r\n    return maxDepth;\r\n  }\r\n\r\n  #approximateMemoryUsage() {\r\n    // Rough approximation in bytes\r\n    return this.#countNodes(this.root) * \r\n           (8 + // references to children object\r\n            4 + // isEndOfWord boolean\r\n            8 + // frequency number\r\n            8); // lastAccessed timestamp\r\n  }\r\n}\r\n\r\n// Example usage with new features\r\nconst trie = new Trie();\r\n\r\n// Insert words with multiple occurrences\r\ntrie.insert("hello");\r\ntrie.insert("hello");  // inserted twice\r\ntrie.insert("world");\r\ntrie.insert("wonderful");\r\ntrie.insert("win");\r\ntrie.insert("wine");\r\n\r\n// Test deletion\r\nconsole.log(trie.search("hello"));  // true\r\ntrie.delete("hello");\r\nconsole.log(trie.search("hello"));  // false\r\n\r\n// Test wildcard search\r\nconsole.log(trie.searchWithWildcard("w?n"));     // ["win"]\r\nconsole.log(trie.searchWithWildcard("w*"));      // ["world", "wonderful", "win", "wine"]\r\n\r\n// Test frequency and recent words\r\nconsole.log(trie.getFrequency("hello"));     // 0 (deleted)\r\nconsole.log(trie.getWordsByFrequency());     // Shows words sorted by frequency\r\nconsole.log(trie.getRecentWords(3));         // Shows 3 most recently accessed words\r\n\r\n// Get statistics\r\nconsole.log(trie.getStats());                // Shows trie statistics\r\n\r\n// Get longest word\r\nconsole.log(trie.getLongestWord());          // "wonderful"\n'})}),"\n",(0,t.jsx)(e.h2,{id:"xor-trie",children:"XOR Trie"}),"\n",(0,t.jsx)(e.p,{children:"A XOR Trie is a data structure specifically designed for efficiently solving problems related to finding the maximum XOR of numbers in an array, subarray XOR queries, or other XOR-related tasks."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-JavaScript",children:"class XORTrie {\r\n  root = {};\r\n\r\n  // Insert a number into the trie\r\n  insert = (num) => {\r\n    let node = this.root;\r\n    for (let i = 31; i >= 0; i--) {\r\n      const bit = (num >> i) & 1; // Extract the i-th bit\r\n      if (!node[bit]) {\r\n        node[bit] = {}; // Create a new branch if it doesn't exist\r\n      }\r\n      node = node[bit];\r\n    }\r\n  }\r\n\r\n  // Find the maximum XOR of a given number with the trie\r\n  findMaxXOR = (num) => {\r\n    let node = this.root;\r\n    let maxXOR = 0;\r\n    for (let i = 31; i >= 0; i--) {\r\n      const bit = (num >> i) & 1; // Extract the i-th bit\r\n      const oppositeBit = 1 - bit; // XOR maximization prefers the opposite bit\r\n      if (node[oppositeBit]) {\r\n        maxXOR = (maxXOR << 1) | 1; // Add 1 to maxXOR (prefer opposite bit)\r\n        node = node[oppositeBit];\r\n      } else {\r\n        maxXOR = maxXOR << 1; // Add 0 to maxXOR\r\n        node = node[bit];\r\n      }\r\n    }\r\n    return maxXOR;\r\n  }\r\n}\r\n\r\n// Example usage\r\nconst nums = [3, 10, 5, 25, 2, 8];\r\nconst xorTrie = new XORTrie();\r\n\r\n// Insert all numbers into the trie\r\nnums.forEach(num => xorTrie.insert(num));\r\n\r\n// Find the maximum XOR of any pair in the array\r\nconsole.log(nums.reduce((maxXor, num) => Math.max(maxXor, xorTrie.findMaxXOR(num)), 0)); // Output: 28\n"})})]})}function h(r={}){const{wrapper:e}={...(0,o.R)(),...r.components};return e?(0,t.jsx)(e,{...r,children:(0,t.jsx)(a,{...r})}):a(r)}},8453:(r,e,n)=>{n.d(e,{R:()=>i,x:()=>d});var t=n(6540);const o={},s=t.createContext(o);function i(r){const e=t.useContext(s);return t.useMemo((function(){return"function"==typeof r?r(e):{...e,...r}}),[e,r])}function d(r){let e;return e=r.disableParentContext?"function"==typeof r.components?r.components(o):r.components||o:i(r.components),t.createElement(s.Provider,{value:e},r.children)}}}]);