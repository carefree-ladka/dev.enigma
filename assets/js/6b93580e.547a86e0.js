"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[8201],{8438:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>a,default:()=>c,frontMatter:()=>s,metadata:()=>o,toc:()=>d});var t=i(4848),r=i(8453);const s={},a="Sliding Window",o={id:"DSA/DSA Cheatsheets/Sliding Window",title:"Sliding Window",description:"A comprehensive guide to sliding window algorithms and techniques for Data Structures and Algorithms.",source:"@site/docs/DSA/DSA Cheatsheets/Sliding Window.mdx",sourceDirName:"DSA/DSA Cheatsheets",slug:"/DSA/DSA Cheatsheets/Sliding Window",permalink:"/js.enigma/docs/DSA/DSA Cheatsheets/Sliding Window",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA Cheatsheets/Sliding Window.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Complete Recursion",permalink:"/js.enigma/docs/DSA/DSA Cheatsheets/Recursion"},next:{title:"Stack",permalink:"/js.enigma/docs/DSA/DSA Cheatsheets/Stack"}},l={},d=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Introduction to Sliding Window",id:"introduction-to-sliding-window",level:2},{value:"When to Use Sliding Window",id:"when-to-use-sliding-window",level:3},{value:"Core Concept",id:"core-concept",level:3},{value:"Fixed Size Window",id:"fixed-size-window",level:2},{value:"1. Maximum Sum Subarray of Size K",id:"1-maximum-sum-subarray-of-size-k",level:3},{value:"2. Average of Subarrays of Size K",id:"2-average-of-subarrays-of-size-k",level:3},{value:"3. Maximum in Each Window of Size K",id:"3-maximum-in-each-window-of-size-k",level:3},{value:"4. First Negative in Each Window",id:"4-first-negative-in-each-window",level:3},{value:"Variable Size Window",id:"variable-size-window",level:2},{value:"1. Longest Substring Without Repeating Characters",id:"1-longest-substring-without-repeating-characters",level:3},{value:"2. Smallest Subarray with Sum Greater than Target",id:"2-smallest-subarray-with-sum-greater-than-target",level:3},{value:"3. Longest Subarray with At Most K Distinct Characters",id:"3-longest-subarray-with-at-most-k-distinct-characters",level:3},{value:"4. Subarray with Target Sum",id:"4-subarray-with-target-sum",level:3},{value:"5. Maximum Fruits in Baskets (At Most 2 Types)",id:"5-maximum-fruits-in-baskets-at-most-2-types",level:3},{value:"String Pattern Matching",id:"string-pattern-matching",level:2},{value:"1. Permutation in String",id:"1-permutation-in-string",level:3},{value:"2. Find All Anagrams in String",id:"2-find-all-anagrams-in-string",level:3},{value:"3. Minimum Window Substring",id:"3-minimum-window-substring",level:3},{value:"Advanced Sliding Window",id:"advanced-sliding-window",level:2},{value:"1. Longest Repeating Character Replacement",id:"1-longest-repeating-character-replacement",level:3},{value:"2. Max Consecutive Ones with K Flips",id:"2-max-consecutive-ones-with-k-flips",level:3},{value:"3. Sliding Window Maximum with Deque",id:"3-sliding-window-maximum-with-deque",level:3},{value:"4. Substring with Concatenation of All Words",id:"4-substring-with-concatenation-of-all-words",level:3},{value:"Two Pointers vs Sliding Window",id:"two-pointers-vs-sliding-window",level:2},{value:"Two Pointers",id:"two-pointers",level:3},{value:"Sliding Window",id:"sliding-window-1",level:3},{value:"When to Use Each",id:"when-to-use-each",level:3},{value:"Multi-Window Techniques",id:"multi-window-techniques",level:2},{value:"1. Sliding Window with Multiple Constraints",id:"1-sliding-window-with-multiple-constraints",level:3},{value:"2. Overlapping Windows",id:"2-overlapping-windows",level:3},{value:"Usage Examples",id:"usage-examples",level:2},{value:"Time Complexity Summary",id:"time-complexity-summary",level:2},{value:"Common Patterns to Remember",id:"common-patterns-to-remember",level:2},{value:"1. <strong>Fixed Window Template</strong>",id:"1-fixed-window-template",level:3},{value:"2. <strong>Variable Window Template</strong>",id:"2-variable-window-template",level:3},{value:"3. <strong>Character Frequency Template</strong>",id:"3-character-frequency-template",level:3},{value:"4. <strong>Deque for Min/Max</strong>",id:"4-deque-for-minmax",level:3},{value:"Key Interview Tips",id:"key-interview-tips",level:2},{value:"Problem Recognition Checklist",id:"problem-recognition-checklist",level:3}];function h(n){const e={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"sliding-window",children:"Sliding Window"})}),"\n",(0,t.jsx)(e.p,{children:"A comprehensive guide to sliding window algorithms and techniques for Data Structures and Algorithms."}),"\n",(0,t.jsx)(e.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#introduction-to-sliding-window",children:"Introduction to Sliding Window"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#fixed-size-window",children:"Fixed Size Window"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#variable-size-window",children:"Variable Size Window"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#string-pattern-matching",children:"String Pattern Matching"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#advanced-sliding-window",children:"Advanced Sliding Window"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#two-pointers-vs-sliding-window",children:"Two Pointers vs Sliding Window"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#multi-window-techniques",children:"Multi-Window Techniques"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#usage-examples",children:"Usage Examples"})}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"introduction-to-sliding-window",children:"Introduction to Sliding Window"}),"\n",(0,t.jsx)(e.p,{children:'The sliding window technique is a powerful algorithmic approach used to solve problems involving subarrays, substrings, or sequences. Instead of using nested loops (O(n\xb2)), it maintains a "window" that slides through the data structure in O(n) time.'}),"\n",(0,t.jsx)(e.h3,{id:"when-to-use-sliding-window",children:"When to Use Sliding Window"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Subarray/Substring problems"})," with contiguous elements"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Optimization problems"})," (maximum, minimum, target sum)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Pattern matching"})," in strings"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Problems with constraints"})," on window size or content"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"core-concept",children:"Core Concept"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Basic sliding window template\nfunction slidingWindowTemplate(arr) {\n    let left = 0;\n    let windowSum = 0;\n    let result = 0;\n\n    for (let right = 0; right < arr.length; right++) {\n        // Expand window by including arr[right]\n        windowSum += arr[right];\n\n        // Contract window if needed\n        while (/* condition to shrink window */) {\n            windowSum -= arr[left];\n            left++;\n        }\n\n        // Update result based on current window\n        result = Math.max(result, windowSum);\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"fixed-size-window",children:"Fixed Size Window"}),"\n",(0,t.jsx)(e.p,{children:"Fixed size sliding window problems have a predetermined window size k."}),"\n",(0,t.jsx)(e.h3,{id:"1-maximum-sum-subarray-of-size-k",children:"1. Maximum Sum Subarray of Size K"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function maxSumSubarray(arr, k) {\n    if (arr.length < k) return -1;\n\n    let windowSum = 0;\n    let maxSum = 0;\n\n    // Calculate sum of first window\n    for (let i = 0; i < k; i++) {\n        windowSum += arr[i];\n    }\n    maxSum = windowSum;\n\n    // Slide the window\n    for (let i = k; i < arr.length; i++) {\n        windowSum = windowSum - arr[i - k] + arr[i];\n        maxSum = Math.max(maxSum, windowSum);\n    }\n\n    return maxSum;\n}\n"})}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Time Complexity:"})," O(n) | ",(0,t.jsx)(e.strong,{children:"Space Complexity:"})," O(1)"]}),"\n",(0,t.jsx)(e.h3,{id:"2-average-of-subarrays-of-size-k",children:"2. Average of Subarrays of Size K"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function findAverages(arr, k) {\n    const result = [];\n    let windowSum = 0;\n    let windowStart = 0;\n\n    for (let windowEnd = 0; windowEnd < arr.length; windowEnd++) {\n        windowSum += arr[windowEnd];\n\n        // If we've hit the window size\n        if (windowEnd >= k - 1) {\n            result.push(windowSum / k);\n            windowSum -= arr[windowStart];\n            windowStart++;\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-maximum-in-each-window-of-size-k",children:"3. Maximum in Each Window of Size K"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function maxInWindow(arr, k) {\n    const result = [];\n    const deque = []; // Store indices\n\n    for (let i = 0; i < arr.length; i++) {\n        // Remove indices outside current window\n        while (deque.length && deque[0] <= i - k) {\n            deque.shift();\n        }\n\n        // Remove smaller elements from back\n        while (deque.length && arr[deque[deque.length - 1]] <= arr[i]) {\n            deque.pop();\n        }\n\n        deque.push(i);\n\n        // Add to result if window is complete\n        if (i >= k - 1) {\n            result.push(arr[deque[0]]);\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsxs)(e.blockquote,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"\ud83d\udd27 Technique:"})," Using deque (double-ended queue) for efficient maximum tracking!"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"4-first-negative-in-each-window",children:"4. First Negative in Each Window"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function firstNegativeInWindow(arr, k) {\n    const result = [];\n    const negatives = []; // Store indices of negative numbers\n\n    for (let i = 0; i < arr.length; i++) {\n        // Remove indices outside current window\n        while (negatives.length && negatives[0] <= i - k) {\n            negatives.shift();\n        }\n\n        // Add current index if negative\n        if (arr[i] < 0) {\n            negatives.push(i);\n        }\n\n        // Add result if window is complete\n        if (i >= k - 1) {\n            result.push(negatives.length ? arr[negatives[0]] : 0);\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"variable-size-window",children:"Variable Size Window"}),"\n",(0,t.jsx)(e.p,{children:"Variable size windows expand and contract based on conditions."}),"\n",(0,t.jsx)(e.h3,{id:"1-longest-substring-without-repeating-characters",children:"1. Longest Substring Without Repeating Characters"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function lengthOfLongestSubstring(s) {\n    const charSet = new Set();\n    let left = 0;\n    let maxLength = 0;\n\n    for (let right = 0; right < s.length; right++) {\n        // Shrink window until no repeating character\n        while (charSet.has(s[right])) {\n            charSet.delete(s[left]);\n            left++;\n        }\n\n        charSet.add(s[right]);\n        maxLength = Math.max(maxLength, right - left + 1);\n    }\n\n    return maxLength;\n}\n"})}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Time Complexity:"})," O(n) | ",(0,t.jsx)(e.strong,{children:"Space Complexity:"})," O(min(m,n)) where m is charset size"]}),"\n",(0,t.jsx)(e.h3,{id:"2-smallest-subarray-with-sum-greater-than-target",children:"2. Smallest Subarray with Sum Greater than Target"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function smallestSubarraySum(arr, target) {\n    let windowSum = 0;\n    let minLength = Infinity;\n    let windowStart = 0;\n\n    for (let windowEnd = 0; windowEnd < arr.length; windowEnd++) {\n        windowSum += arr[windowEnd];\n\n        // Shrink window while sum >= target\n        while (windowSum >= target) {\n            minLength = Math.min(minLength, windowEnd - windowStart + 1);\n            windowSum -= arr[windowStart];\n            windowStart++;\n        }\n    }\n\n    return minLength === Infinity ? 0 : minLength;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-longest-subarray-with-at-most-k-distinct-characters",children:"3. Longest Subarray with At Most K Distinct Characters"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function longestSubstringWithKDistinct(s, k) {\n    if (k === 0) return 0;\n\n    const charCount = new Map();\n    let left = 0;\n    let maxLength = 0;\n\n    for (let right = 0; right < s.length; right++) {\n        const rightChar = s[right];\n        charCount.set(rightChar, (charCount.get(rightChar) || 0) + 1);\n\n        // Shrink window if we have more than k distinct characters\n        while (charCount.size > k) {\n            const leftChar = s[left];\n            charCount.set(leftChar, charCount.get(leftChar) - 1);\n            if (charCount.get(leftChar) === 0) {\n                charCount.delete(leftChar);\n            }\n            left++;\n        }\n\n        maxLength = Math.max(maxLength, right - left + 1);\n    }\n\n    return maxLength;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"4-subarray-with-target-sum",children:"4. Subarray with Target Sum"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function subarraySum(arr, target) {\n    let windowSum = 0;\n    let windowStart = 0;\n\n    for (let windowEnd = 0; windowEnd < arr.length; windowEnd++) {\n        windowSum += arr[windowEnd];\n\n        // Shrink window if sum exceeds target\n        while (windowSum > target && windowStart <= windowEnd) {\n            windowSum -= arr[windowStart];\n            windowStart++;\n        }\n\n        // Check if we found target sum\n        if (windowSum === target) {\n            return [windowStart, windowEnd];\n        }\n    }\n\n    return [-1, -1]; // Not found\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"5-maximum-fruits-in-baskets-at-most-2-types",children:"5. Maximum Fruits in Baskets (At Most 2 Types)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function totalFruit(fruits) {\n    const basketCount = new Map();\n    let left = 0;\n    let maxFruits = 0;\n\n    for (let right = 0; right < fruits.length; right++) {\n        basketCount.set(fruits[right], (basketCount.get(fruits[right]) || 0) + 1);\n\n        // If more than 2 types, shrink window\n        while (basketCount.size > 2) {\n            basketCount.set(fruits[left], basketCount.get(fruits[left]) - 1);\n            if (basketCount.get(fruits[left]) === 0) {\n                basketCount.delete(fruits[left]);\n            }\n            left++;\n        }\n\n        maxFruits = Math.max(maxFruits, right - left + 1);\n    }\n\n    return maxFruits;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"string-pattern-matching",children:"String Pattern Matching"}),"\n",(0,t.jsx)(e.p,{children:"Advanced sliding window techniques for string problems."}),"\n",(0,t.jsx)(e.h3,{id:"1-permutation-in-string",children:"1. Permutation in String"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function checkInclusion(s1, s2) {\n    if (s1.length > s2.length) return false;\n\n    const s1Count = new Map();\n    const windowCount = new Map();\n\n    // Count characters in s1\n    for (const char of s1) {\n        s1Count.set(char, (s1Count.get(char) || 0) + 1);\n    }\n\n    let left = 0;\n    let matches = 0;\n\n    for (let right = 0; right < s2.length; right++) {\n        const rightChar = s2[right];\n\n        // Expand window\n        windowCount.set(rightChar, (windowCount.get(rightChar) || 0) + 1);\n        if (windowCount.get(rightChar) === s1Count.get(rightChar)) {\n            matches++;\n        }\n\n        // Shrink window if size exceeds s1 length\n        if (right - left + 1 > s1.length) {\n            const leftChar = s2[left];\n            if (windowCount.get(leftChar) === s1Count.get(leftChar)) {\n                matches--;\n            }\n            windowCount.set(leftChar, windowCount.get(leftChar) - 1);\n            left++;\n        }\n\n        // Check if all characters match\n        if (matches === s1Count.size) {\n            return true;\n        }\n    }\n\n    return false;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-find-all-anagrams-in-string",children:"2. Find All Anagrams in String"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function findAnagrams(s, p) {\n    if (p.length > s.length) return [];\n\n    const result = [];\n    const pCount = new Map();\n    const windowCount = new Map();\n\n    // Count characters in p\n    for (const char of p) {\n        pCount.set(char, (pCount.get(char) || 0) + 1);\n    }\n\n    let left = 0;\n\n    for (let right = 0; right < s.length; right++) {\n        const rightChar = s[right];\n        windowCount.set(rightChar, (windowCount.get(rightChar) || 0) + 1);\n\n        // Shrink window if size exceeds p length\n        if (right - left + 1 > p.length) {\n            const leftChar = s[left];\n            windowCount.set(leftChar, windowCount.get(leftChar) - 1);\n            if (windowCount.get(leftChar) === 0) {\n                windowCount.delete(leftChar);\n            }\n            left++;\n        }\n\n        // Check if current window is an anagram\n        if (right - left + 1 === p.length && mapsEqual(windowCount, pCount)) {\n            result.push(left);\n        }\n    }\n\n    return result;\n}\n\nfunction mapsEqual(map1, map2) {\n    if (map1.size !== map2.size) return false;\n    for (const [key, value] of map1) {\n        if (map2.get(key) !== value) return false;\n    }\n    return true;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-minimum-window-substring",children:"3. Minimum Window Substring"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:'function minWindow(s, t) {\n    if (t.length > s.length) return "";\n\n    const tCount = new Map();\n    const windowCount = new Map();\n\n    // Count characters in t\n    for (const char of t) {\n        tCount.set(char, (tCount.get(char) || 0) + 1);\n    }\n\n    let left = 0;\n    let matches = 0;\n    let minLength = Infinity;\n    let minStart = 0;\n\n    for (let right = 0; right < s.length; right++) {\n        const rightChar = s[right];\n\n        // Expand window\n        windowCount.set(rightChar, (windowCount.get(rightChar) || 0) + 1);\n        if (tCount.has(rightChar) && windowCount.get(rightChar) === tCount.get(rightChar)) {\n            matches++;\n        }\n\n        // Contract window while we have all required characters\n        while (matches === tCount.size) {\n            // Update minimum window\n            if (right - left + 1 < minLength) {\n                minLength = right - left + 1;\n                minStart = left;\n            }\n\n            const leftChar = s[left];\n            if (tCount.has(leftChar) && windowCount.get(leftChar) === tCount.get(leftChar)) {\n                matches--;\n            }\n            windowCount.set(leftChar, windowCount.get(leftChar) - 1);\n            left++;\n        }\n    }\n\n    return minLength === Infinity ? "" : s.substring(minStart, minStart + minLength);\n}\n'})}),"\n",(0,t.jsxs)(e.blockquote,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"\ud83e\udde0 Algorithm Insight:"})," This is one of the most complex sliding window problems - master this and you'll handle most variations!"]}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"advanced-sliding-window",children:"Advanced Sliding Window"}),"\n",(0,t.jsx)(e.h3,{id:"1-longest-repeating-character-replacement",children:"1. Longest Repeating Character Replacement"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function characterReplacement(s, k) {\n    const charCount = new Map();\n    let left = 0;\n    let maxCount = 0;\n    let maxLength = 0;\n\n    for (let right = 0; right < s.length; right++) {\n        charCount.set(s[right], (charCount.get(s[right]) || 0) + 1);\n        maxCount = Math.max(maxCount, charCount.get(s[right]));\n\n        // If replacements needed > k, shrink window\n        if (right - left + 1 - maxCount > k) {\n            charCount.set(s[left], charCount.get(s[left]) - 1);\n            left++;\n        }\n\n        maxLength = Math.max(maxLength, right - left + 1);\n    }\n\n    return maxLength;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-max-consecutive-ones-with-k-flips",children:"2. Max Consecutive Ones with K Flips"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function longestOnes(nums, k) {\n    let left = 0;\n    let zeroCount = 0;\n    let maxLength = 0;\n\n    for (let right = 0; right < nums.length; right++) {\n        if (nums[right] === 0) {\n            zeroCount++;\n        }\n\n        // If zero count exceeds k, shrink window\n        while (zeroCount > k) {\n            if (nums[left] === 0) {\n                zeroCount--;\n            }\n            left++;\n        }\n\n        maxLength = Math.max(maxLength, right - left + 1);\n    }\n\n    return maxLength;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-sliding-window-maximum-with-deque",children:"3. Sliding Window Maximum with Deque"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function maxSlidingWindow(nums, k) {\n    const result = [];\n    const deque = []; // Store indices in decreasing order of values\n\n    for (let i = 0; i < nums.length; i++) {\n        // Remove indices outside current window\n        while (deque.length && deque[0] <= i - k) {\n            deque.shift();\n        }\n\n        // Remove indices with smaller values\n        while (deque.length && nums[deque[deque.length - 1]] <= nums[i]) {\n            deque.pop();\n        }\n\n        deque.push(i);\n\n        // Add maximum of current window to result\n        if (i >= k - 1) {\n            result.push(nums[deque[0]]);\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"4-substring-with-concatenation-of-all-words",children:"4. Substring with Concatenation of All Words"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function findSubstring(s, words) {\n    if (!s || !words || words.length === 0) return [];\n\n    const result = [];\n    const wordLen = words[0].length;\n    const totalLen = wordLen * words.length;\n    const wordCount = new Map();\n\n    // Count word frequencies\n    for (const word of words) {\n        wordCount.set(word, (wordCount.get(word) || 0) + 1);\n    }\n\n    for (let i = 0; i <= s.length - totalLen; i++) {\n        const windowCount = new Map();\n        let j = 0;\n\n        // Check each word in the window\n        while (j < words.length) {\n            const word = s.substring(i + j * wordLen, i + (j + 1) * wordLen);\n\n            if (!wordCount.has(word)) break;\n\n            windowCount.set(word, (windowCount.get(word) || 0) + 1);\n\n            if (windowCount.get(word) > wordCount.get(word)) break;\n\n            j++;\n        }\n\n        if (j === words.length) {\n            result.push(i);\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"two-pointers-vs-sliding-window",children:"Two Pointers vs Sliding Window"}),"\n",(0,t.jsx)(e.p,{children:"Understanding when to use each technique:"}),"\n",(0,t.jsx)(e.h3,{id:"two-pointers",children:"Two Pointers"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Used for sorted arrays, palindromes, pair problems\nfunction twoSum(arr, target) {\n    let left = 0;\n    let right = arr.length - 1;\n\n    while (left < right) {\n        const sum = arr[left] + arr[right];\n        if (sum === target) return [left, right];\n        else if (sum < target) left++;\n        else right--;\n    }\n\n    return [-1, -1];\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"sliding-window-1",children:"Sliding Window"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Used for subarray/substring problems with contiguous elements\nfunction maxSubarraySum(arr, k) {\n    let windowSum = 0;\n    let maxSum = 0;\n\n    for (let i = 0; i < arr.length; i++) {\n        windowSum += arr[i];\n\n        if (i >= k - 1) {\n            maxSum = Math.max(maxSum, windowSum);\n            windowSum -= arr[i - k + 1];\n        }\n    }\n\n    return maxSum;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"when-to-use-each",children:"When to Use Each"}),"\n",(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{children:"Two Pointers"}),(0,t.jsx)(e.th,{children:"Sliding Window"})]})}),(0,t.jsxs)(e.tbody,{children:[(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Sorted arrays"}),(0,t.jsx)(e.td,{children:"Contiguous subarrays"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Pair/triplet problems"}),(0,t.jsx)(e.td,{children:"Substring problems"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Palindrome checks"}),(0,t.jsx)(e.td,{children:"Window-based optimization"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Meet-in-the-middle"}),(0,t.jsx)(e.td,{children:"Pattern matching"})]})]})]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"multi-window-techniques",children:"Multi-Window Techniques"}),"\n",(0,t.jsx)(e.h3,{id:"1-sliding-window-with-multiple-constraints",children:"1. Sliding Window with Multiple Constraints"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:'function minWindowTwoArrays(s1, s2, s3) {\n    // Find minimum window in s1 that contains all characters from s2 and s3\n    const s2Count = new Map();\n    const s3Count = new Map();\n\n    for (const char of s2) s2Count.set(char, (s2Count.get(char) || 0) + 1);\n    for (const char of s3) s3Count.set(char, (s3Count.get(char) || 0) + 1);\n\n    const windowCount = new Map();\n    let left = 0;\n    let matches2 = 0, matches3 = 0;\n    let minLength = Infinity;\n    let result = "";\n\n    for (let right = 0; right < s1.length; right++) {\n        const char = s1[right];\n        windowCount.set(char, (windowCount.get(char) || 0) + 1);\n\n        if (s2Count.has(char) && windowCount.get(char) === s2Count.get(char)) matches2++;\n        if (s3Count.has(char) && windowCount.get(char) === s3Count.get(char)) matches3++;\n\n        while (matches2 === s2Count.size && matches3 === s3Count.size) {\n            if (right - left + 1 < minLength) {\n                minLength = right - left + 1;\n                result = s1.substring(left, right + 1);\n            }\n\n            const leftChar = s1[left];\n            if (s2Count.has(leftChar) && windowCount.get(leftChar) === s2Count.get(leftChar)) matches2--;\n            if (s3Count.has(leftChar) && windowCount.get(leftChar) === s3Count.get(leftChar)) matches3--;\n\n            windowCount.set(leftChar, windowCount.get(leftChar) - 1);\n            left++;\n        }\n    }\n\n    return result;\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"2-overlapping-windows",children:"2. Overlapping Windows"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function maxSumTwoWindows(arr, k1, k2) {\n    const n = arr.length;\n    if (n < k1 + k2) return 0;\n\n    // Precompute maximum sum for k1-size window ending at each position\n    const maxK1Left = new Array(n).fill(0);\n    const maxK1Right = new Array(n).fill(0);\n\n    let windowSum = 0;\n\n    // Left to right for k1\n    for (let i = 0; i < n; i++) {\n        windowSum += arr[i];\n        if (i >= k1 - 1) {\n            maxK1Left[i] = windowSum;\n            if (i > k1 - 1) {\n                maxK1Left[i] = Math.max(maxK1Left[i], maxK1Left[i - 1]);\n                windowSum -= arr[i - k1 + 1];\n            }\n        } else if (i > 0) {\n            maxK1Left[i] = maxK1Left[i - 1];\n        }\n    }\n\n    // Right to left for k1\n    windowSum = 0;\n    for (let i = n - 1; i >= 0; i--) {\n        windowSum += arr[i];\n        if (n - 1 - i >= k1 - 1) {\n            maxK1Right[i] = windowSum;\n            if (n - 1 - i > k1 - 1) {\n                maxK1Right[i] = Math.max(maxK1Right[i], maxK1Right[i + 1]);\n                windowSum -= arr[i + k1 - 1];\n            }\n        } else if (i < n - 1) {\n            maxK1Right[i] = maxK1Right[i + 1];\n        }\n    }\n\n    // Find maximum sum of two non-overlapping windows\n    let maxSum = 0;\n    windowSum = 0;\n\n    for (let i = 0; i <= n - k2; i++) {\n        windowSum += arr[i];\n        if (i >= k2 - 1) {\n            const currentK2Sum = windowSum;\n            const leftMax = i - k2 >= 0 ? maxK1Left[i - k2] : 0;\n            const rightMax = i + 1 < n ? maxK1Right[i + 1] : 0;\n\n            maxSum = Math.max(maxSum, currentK2Sum + Math.max(leftMax, rightMax));\n            windowSum -= arr[i - k2 + 1];\n        }\n    }\n\n    return maxSum;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:'console.log("=== Sliding Window Techniques Demo ===");\n\n// Fixed size window\nconst arr1 = [2, 1, 5, 1, 3, 2];\nconsole.log("Max sum subarray (k=3):", maxSumSubarray(arr1, 3)); // 9\n\n// Variable size window\nconst s1 = "abcabcbb";\nconsole.log("Longest substring without repeating:", lengthOfLongestSubstring(s1)); // 3\n\nconst arr2 = [2, 1, 2, 3, 4, 3, 1];\nconsole.log("Smallest subarray sum >= 7:", smallestSubarraySum(arr2, 7)); // 2\n\n// String pattern matching\nconst s2 = "eidbaooo";\nconst s3 = "ab";\nconsole.log("Contains permutation of \'ab\':", checkInclusion(s3, s2)); // true\n\nconst s4 = "ADOBECODEBANC";\nconst t1 = "ABC";\nconsole.log("Minimum window substring:", minWindow(s4, t1)); // "BANC"\n\n// Advanced techniques\nconst s5 = "ABAB";\nconsole.log("Longest repeating char replacement (k=2):", characterReplacement(s5, 2)); // 4\n\nconst nums1 = [1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0];\nconsole.log("Max consecutive ones (k=2):", longestOnes(nums1, 2)); // 6\n\nconst nums2 = [1, 3, -1, -3, 5, 3, 6, 7];\nconsole.log("Sliding window maximum (k=3):", maxSlidingWindow(nums2, 3)); // [3, 3, 5, 5, 6, 7]\n'})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"time-complexity-summary",children:"Time Complexity Summary"}),"\n",(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{children:"Problem Type"}),(0,t.jsx)(e.th,{children:"Time Complexity"}),(0,t.jsx)(e.th,{children:"Space Complexity"})]})}),(0,t.jsxs)(e.tbody,{children:[(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Fixed Size Window"}),(0,t.jsx)(e.td,{children:"O(n)"}),(0,t.jsx)(e.td,{children:"O(1)"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Variable Size Window"}),(0,t.jsx)(e.td,{children:"O(n)"}),(0,t.jsx)(e.td,{children:"O(k) for hash map"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"String Pattern Matching"}),(0,t.jsx)(e.td,{children:"O(n + m)"}),(0,t.jsx)(e.td,{children:"O(m) for pattern"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Sliding Window Maximum"}),(0,t.jsx)(e.td,{children:"O(n)"}),(0,t.jsx)(e.td,{children:"O(k) for deque"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Multi-Window"}),(0,t.jsx)(e.td,{children:"O(n)"}),(0,t.jsx)(e.td,{children:"O(1) typically"})]})]})]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"common-patterns-to-remember",children:"Common Patterns to Remember"}),"\n",(0,t.jsxs)(e.h3,{id:"1-fixed-window-template",children:["1. ",(0,t.jsx)(e.strong,{children:"Fixed Window Template"})]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"for (let i = 0; i < arr.length; i++) {\n    windowSum += arr[i];\n    if (i >= k - 1) {\n        // Process window\n        result = Math.max(result, windowSum);\n        windowSum -= arr[i - k + 1];\n    }\n}\n"})}),"\n",(0,t.jsxs)(e.h3,{id:"2-variable-window-template",children:["2. ",(0,t.jsx)(e.strong,{children:"Variable Window Template"})]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"let left = 0;\nfor (let right = 0; right < arr.length; right++) {\n    // Expand window\n    windowSum += arr[right];\n\n    // Contract window while condition\n    while (/* condition to shrink */) {\n        windowSum -= arr[left];\n        left++;\n    }\n\n    // Update result\n    result = Math.max(result, right - left + 1);\n}\n"})}),"\n",(0,t.jsxs)(e.h3,{id:"3-character-frequency-template",children:["3. ",(0,t.jsx)(e.strong,{children:"Character Frequency Template"})]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"const charCount = new Map();\nlet left = 0, matches = 0;\n\nfor (let right = 0; right < s.length; right++) {\n    charCount.set(s[right], (charCount.get(s[right]) || 0) + 1);\n\n    if (charCount.get(s[right]) === targetCount.get(s[right])) {\n        matches++;\n    }\n\n    // Shrink window logic...\n}\n"})}),"\n",(0,t.jsxs)(e.h3,{id:"4-deque-for-minmax",children:["4. ",(0,t.jsx)(e.strong,{children:"Deque for Min/Max"})]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"const deque = [];\nfor (let i = 0; i < arr.length; i++) {\n    // Remove out of window elements\n    while (deque.length && deque[0] <= i - k) {\n        deque.shift();\n    }\n\n    // Maintain order (max at front)\n    while (deque.length && arr[deque[deque.length - 1]] <= arr[i]) {\n        deque.pop();\n    }\n\n    deque.push(i);\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"key-interview-tips",children:"Key Interview Tips"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Identify the pattern"}),": Look for subarray/substring with constraints"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Choose the right variant"}),": Fixed vs variable size window"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Handle edge cases"}),": Empty arrays, single elements, impossible cases"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Use appropriate data structures"}),": Hash maps for frequency, deque for min/max"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Optimize space"}),": Often O(1) space is possible with careful implementation"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Test thoroughly"}),": Use examples like [1,2,3], [], [1], and edge cases"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"problem-recognition-checklist",children:"Problem Recognition Checklist"}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Use Sliding Window when you see:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:'\u2705 "Subarray" or "Substring" in the problem'}),"\n",(0,t.jsx)(e.li,{children:'\u2705 "Contiguous" elements requirement'}),"\n",(0,t.jsx)(e.li,{children:'\u2705 "Maximum/Minimum" with size constraint'}),"\n",(0,t.jsx)(e.li,{children:'\u2705 "Contains all" or "exactly K" conditions'}),"\n",(0,t.jsx)(e.li,{children:"\u2705 Pattern matching in strings"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Don't use Sliding Window for:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"\u274c Non-contiguous subsequences"}),"\n",(0,t.jsx)(e.li,{children:"\u274c Problems requiring backtracking"}),"\n",(0,t.jsx)(e.li,{children:"\u274c Tree or graph traversals"}),"\n",(0,t.jsx)(e.li,{children:"\u274c Dynamic programming with overlapping subproblems"}),"\n"]})]})}function c(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(h,{...n})}):h(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>a,x:()=>o});var t=i(6540);const r={},s=t.createContext(r);function a(n){const e=t.useContext(s);return t.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:a(n.components),t.createElement(s.Provider,{value:e},n.children)}}}]);