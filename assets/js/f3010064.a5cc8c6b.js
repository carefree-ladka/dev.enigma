"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[3937],{1330:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>d,toc:()=>c});var i=r(4848),t=r(8453);const s={title:"2D Matrix Graph Algorithms",description:"A comprehensive guide to 2D DFS, 2D BFS, and 2D Dijkstra algorithms with code examples in JavaScript."},o="2D Graph Algorithms Tutorial",d={id:"DSA/DSA with JavaScript/2DGraphAlgorithms",title:"2D Matrix Graph Algorithms",description:"A comprehensive guide to 2D DFS, 2D BFS, and 2D Dijkstra algorithms with code examples in JavaScript.",source:"@site/docs/DSA/DSA with JavaScript/2DGraphAlgorithms.mdx",sourceDirName:"DSA/DSA with JavaScript",slug:"/DSA/DSA with JavaScript/2DGraphAlgorithms",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/2DGraphAlgorithms",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with JavaScript/2DGraphAlgorithms.mdx",tags:[],version:"current",frontMatter:{title:"2D Matrix Graph Algorithms",description:"A comprehensive guide to 2D DFS, 2D BFS, and 2D Dijkstra algorithms with code examples in JavaScript."},sidebar:"tutorialSidebar",previous:{title:"0-1 BFS Algorithm",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/01BFS"},next:{title:"AVL Tree",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/AVLTree"}},l={},c=[{value:"Introduction",id:"introduction",level:2},{value:"2D Depth-First Search (DFS)",id:"2d-depth-first-search-dfs",level:2},{value:"Overview",id:"overview",level:3},{value:"Implementation",id:"implementation",level:3},{value:"Problem Statement",id:"problem-statement",level:2},{value:"3D Grid Representation",id:"3d-grid-representation",level:2},{value:"Depth-First Search (DFS) Algorithm",id:"depth-first-search-dfs-algorithm",level:2},{value:"JavaScript Implementation",id:"javascript-implementation",level:3},{value:"DFS on Boundary Conditions",id:"dfs-on-boundary-conditions",level:2},{value:"2D Breadth-First Search (BFS)",id:"2d-breadth-first-search-bfs",level:2},{value:"Problem Statement",id:"problem-statement-1",level:2},{value:"3D Grid Representation",id:"3d-grid-representation-1",level:2},{value:"Breadth-First Search (BFS) Algorithm",id:"breadth-first-search-bfs-algorithm",level:2},{value:"JavaScript Implementation",id:"javascript-implementation-1",level:3},{value:"Shortest Path using BFS on 2D Grid",id:"shortest-path-using-bfs-on-2d-grid",level:2},{value:"Shortest Path using Dijkstra on 2D Grid",id:"shortest-path-using-dijkstra-on-2d-grid",level:2}];function a(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"2d-graph-algorithms-tutorial",children:"2D Graph Algorithms Tutorial"})}),"\n",(0,i.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsx)(e.p,{children:"In many problems involving grids or 2D matrices, algorithms designed for 2D graphs become crucial. These algorithms help in navigating and solving various tasks in grid-based problems. This tutorial covers three key algorithms used in 2D grids:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.strong,{children:"2D Depth-First Search (DFS)"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.strong,{children:"2D Breadth-First Search (BFS)"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.strong,{children:"2D Dijkstra's Algorithm"})}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"2d-depth-first-search-dfs",children:"2D Depth-First Search (DFS)"}),"\n",(0,i.jsx)(e.h3,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(e.p,{children:"DFS explores as far as possible along each branch before backtracking. In a 2D grid, DFS can be used to traverse and solve problems like connected components or island counting."}),"\n",(0,i.jsx)(e.h3,{id:"implementation",children:"Implementation"}),"\n",(0,i.jsx)(e.p,{children:"Here\u2019s a JavaScript implementation of 2D DFS:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-JavaScript",children:"function dfs(grid, row, col, visited) {\n  // Check boundaries and if the cell is already visited\n  if (\n    row < 0 || row >= grid.length ||\n    col < 0 || col >= grid[0].length ||\n    visited[row][col]\n  ) {\n    return;\n  }\n\n  // Mark the cell as visited\n  visited[row][col] = true;\n\n  // Print the current cell's value\n  console.log(grid[row][col]);\n\n  // Define the directions for traversal: right, down, left, up\n  const directions = [\n    [0, 1],    // right\n    [1, 0],    // down\n    [0, -1],   // left\n    [-1, 0],   // up\n    [1, 1],    // down-right (diagonal)\n    [1, -1],   // down-left (diagonal)\n    [-1, 1],   // up-right (diagonal)\n    [-1, -1]   // up-left (diagonal)\n  ];\n\n  // Explore all neighbors\n  for (let [dr, dc] of directions) {\n    dfs(grid, row + dr, col + dc, visited);\n  }\n}\n\n// Example usage:\nconst grid = [\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9]\n];\n\n// Create a visited matrix initialized to false\nconst visited = Array.from({ length: grid.length }, () => Array(grid[0].length).fill(false));\n\n// Start DFS from cell (0, 0)\ndfs(grid, 0, 0, visited);\n\n"})}),"\n",(0,i.jsx)(e.h1,{id:"depth-first-search-dfs-on-a-3d-grid",children:"Depth-First Search (DFS) on a 3D Grid"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Depth-First Search (DFS)"})," is a fundamental algorithm used to explore nodes and edges of a graph or grid. It can be extended to 3D grids to explore nodes in three dimensions. In a 3D grid, each cell can be thought of as a node, and there are six possible directions to move to adjacent nodes."]}),"\n",(0,i.jsx)(e.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,i.jsx)(e.p,{children:"Given a 3D grid, where each cell represents a node, perform a Depth-First Search to explore all reachable nodes starting from a given source cell. The grid allows movement in six possible directions: left, right, up, down, forward, and backward."}),"\n",(0,i.jsx)(e.h2,{id:"3d-grid-representation",children:"3D Grid Representation"}),"\n",(0,i.jsxs)(e.p,{children:["A 3D grid can be represented as a 3D array ",(0,i.jsx)(e.code,{children:"grid[x][y][z]"}),", where:"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"x"})," represents the row index,"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"y"})," represents the column index,"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"z"})," represents the depth index."]}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:["The six possible moves from a cell ",(0,i.jsx)(e.code,{children:"(x, y, z)"})," are:"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Left"}),": ",(0,i.jsx)(e.code,{children:"(x - 1, y, z)"})]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Right"}),": ",(0,i.jsx)(e.code,{children:"(x + 1, y, z)"})]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Up"}),": ",(0,i.jsx)(e.code,{children:"(x, y - 1, z)"})]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Down"}),": ",(0,i.jsx)(e.code,{children:"(x, y + 1, z)"})]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Forward"}),": ",(0,i.jsx)(e.code,{children:"(x, y, z + 1)"})]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Backward"}),": ",(0,i.jsx)(e.code,{children:"(x, y, z - 1)"})]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"depth-first-search-dfs-algorithm",children:"Depth-First Search (DFS) Algorithm"}),"\n",(0,i.jsx)(e.p,{children:"DFS explores as far as possible along a branch before backtracking. For a 3D grid, it involves:"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Initialization"}),":"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Use a stack to keep track of cells to visit."}),"\n",(0,i.jsx)(e.li,{children:"Maintain a set or array to mark visited cells to avoid reprocessing."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Processing"}),":"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Push the starting cell onto the stack."}),"\n",(0,i.jsx)(e.li,{children:"While the stack is not empty, pop the top cell and process it."}),"\n",(0,i.jsx)(e.li,{children:"Push all valid and unvisited neighboring cells onto the stack."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Termination"}),":"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Continue until the stack is empty or a specific condition is met."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"javascript-implementation",children:"JavaScript Implementation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-JavaScript",children:"function isValid(x, y, z, grid) {\n    return (\n        x >= 0 && x < grid.length &&\n        y >= 0 && y < grid[0].length &&\n        z >= 0 && z < grid[0][0].length\n    );\n}\n\nfunction dfs3D(grid, start) {\n    const directions = [\n        [-1, 0, 0], [1, 0, 0], // left, right\n        [0, -1, 0], [0, 1, 0], // up, down\n        [0, 0, -1], [0, 0, 1]  // backward, forward\n    ];\n\n    const [startX, startY, startZ] = start;\n    const stack = [[startX, startY, startZ]];\n    const visited = new Set();\n    visited.add(`${startX},${startY},${startZ}`);\n\n    while (stack.length > 0) {\n        const [x, y, z] = stack.pop();\n        console.log(`Visited cell: (${x}, ${y}, ${z})`); // Process the cell\n\n        for (const [dx, dy, dz] of directions) {\n            const nx = x + dx;\n            const ny = y + dy;\n            const nz = z + dz;\n\n            if (isValid(nx, ny, nz, grid) && !visited.has(`${nx},${ny},${nz}`)) {\n                visited.add(`${nx},${ny},${nz}`);\n                stack.push([nx, ny, nz]);\n            }\n        }\n    }\n}\n\n// Example usage:\nconst grid = [\n    [\n        [[1, 2], [3, 4]],\n        [[5, 6], [7, 8]]\n    ],\n    [\n        [[9, 10], [11, 12]],\n        [[13, 14], [15, 16]]\n    ]\n];\n\nconst start = [0, 0, 0];\ndfs3D(grid, start);\n"})}),"\n",(0,i.jsx)(e.h2,{id:"dfs-on-boundary-conditions",children:"DFS on Boundary Conditions"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.a,{href:"https://leetcode.com/problems/number-of-enclaves",children:"1020. Number of Enclaves"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-JavaScript",children:"function numEnclaves(grid) {\n  const rows = grid.length, cols = grid[0].length;\n  const directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]; // down, up, right, left\n\n  // DFS function to mark connected land cells as visited\n  function dfs(r, c) {\n    if (r < 0 || c < 0 || r >= rows || c >= cols || grid[r][c] === 0) return;\n    grid[r][c] = 0; // Mark the cell as visited\n    for (const [dr, dc] of directions) {\n      dfs(r + dr, c + dc);\n    }\n  }\n\n  // Run DFS on all boundary cells that contain land\n  for (let r = 0; r < rows; r++) {\n    if (grid[r][0] === 1) dfs(r, 0);\n    if (grid[r][cols - 1] === 1) dfs(r, cols - 1);\n  }\n  for (let c = 0; c < cols; c++) {\n    if (grid[0][c] === 1) dfs(0, c);\n    if (grid[rows - 1][c] === 1) dfs(rows - 1, c);\n  }\n\n  // Count the remaining land cells (enclaves)\n  let enclaveCount = 0;\n  for (let r = 0; r < rows; r++) {\n    for (let c = 0; c < cols; c++) {\n      if (grid[r][c] === 1) enclaveCount++;\n    }\n  }\n\n  return enclaveCount;\n}\n"})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.a,{href:"https://leetcode.com/problems/surrounded-regions/",children:"130. Surrounded Regions"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-JavaScript",children:"/**\n * @param {character[][]} board\n * @return {void} Do not return anything, modify board in-place instead.\n */\nvar solve = function (board) {\n  if (board.length === 0 || board[0].length === 0) return;\n  const rows = board.length;\n  const cols = board[0].length;\n\n  // Directions array to move: up, down, left, right\n  const directions = [\n    [-1, 0], // Move up\n    [1, 0],  // Move down\n    [0, -1], // Move left\n    [0, 1]   // Move right\n  ];\n\n  // Function to perform DFS and mark 'O's connected to borders\n  const dfs = (r, c) => {\n    if (r < 0 || r >= rows || c < 0 || c >= cols || board[r][c] !== 'O') return;\n    board[r][c] = 'E'; // Mark as escaped\n    // Explore all 4 directions\n    for (const [dr, dc] of directions) {\n      dfs(r + dr, c + dc);\n    }\n  };\n\n  // Start DFS from the border cells\n  for (let r = 0; r < rows; r++) {\n    dfs(r, 0); // Left border\n    dfs(r, cols - 1); // Right border\n  }\n  for (let c = 0; c < cols; c++) {\n    dfs(0, c); // Top border\n    dfs(rows - 1, c); // Bottom border\n  }\n\n  // Flip all 'O's to 'X's and all 'E's back to 'O's\n  for (let r = 0; r < rows; r++) {\n    for (let c = 0; c < cols; c++) {\n      if (board[r][c] === 'O') {\n        board[r][c] = 'X'; // Flip surrounded 'O' to 'X'\n      } else if (board[r][c] === 'E') {\n        board[r][c] = 'O'; // Restore escaped 'O' to 'O'\n      }\n    }\n  }\n};\n"})}),"\n",(0,i.jsx)(e.h2,{id:"2d-breadth-first-search-bfs",children:"2D Breadth-First Search (BFS)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-JavaScript",children:"function bfs(grid, startRow, startCol) {\n  const rows = grid.length;\n  const cols = grid[0].length;\n\n  // Direction vectors for moving right, down, left, and up\n  const directions = [\n    [0, 1],   // right\n    [1, 0],   // down\n    [0, -1],  // left\n    [-1, 0]   // up\n  ];\n\n  // Create a visited matrix initialized to false\n  const visited = Array.from({ length: rows }, () => Array(cols).fill(false));\n\n  // Initialize the queue with the starting cell\n  const queue = [[startRow, startCol]];\n  visited[startRow][startCol] = true;\n\n  while (queue.length > 0) {\n    // Dequeue the front cell\n    const [row, col] = queue.shift();\n\n    // Print the current cell's value\n    console.log(grid[row][col]);\n\n    // Explore all neighbors\n    for (let [dr, dc] of directions) {\n      const newRow = row + dr;\n      const newCol = col + dc;\n\n      // Check if the new position is within bounds and not visited\n      if (\n        newRow >= 0 && newRow < rows &&\n        newCol >= 0 && newCol < cols &&\n        !visited[newRow][newCol]\n      ) {\n        // Mark the new cell as visited and enqueue it\n        visited[newRow][newCol] = true;\n        queue.push([newRow, newCol]);\n      }\n    }\n  }\n}\n"})}),"\n",(0,i.jsx)(e.h1,{id:"breadth-first-search-bfs-on-a-3d-grid",children:"Breadth-First Search (BFS) on a 3D Grid"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Breadth-First Search (BFS)"})," is an algorithm used to explore nodes in a graph or grid level by level. It is particularly useful for finding the shortest path in unweighted graphs or grids. For a 3D grid, BFS can explore nodes in three dimensions, considering all six possible directions."]}),"\n",(0,i.jsx)(e.h2,{id:"problem-statement-1",children:"Problem Statement"}),"\n",(0,i.jsx)(e.p,{children:"Given a 3D grid, where each cell represents a node, perform a Breadth-First Search to explore all reachable nodes starting from a given source cell. The grid allows movement in six possible directions: left, right, up, down, forward, and backward."}),"\n",(0,i.jsx)(e.h2,{id:"3d-grid-representation-1",children:"3D Grid Representation"}),"\n",(0,i.jsxs)(e.p,{children:["A 3D grid is represented as a 3D array ",(0,i.jsx)(e.code,{children:"grid[x][y][z]"}),", where:"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"x"})," is the row index,"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"y"})," is the column index,"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"z"})," is the depth index."]}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:["The six possible moves from a cell ",(0,i.jsx)(e.code,{children:"(x, y, z)"})," are:"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Left"}),": ",(0,i.jsx)(e.code,{children:"(x - 1, y, z)"})]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Right"}),": ",(0,i.jsx)(e.code,{children:"(x + 1, y, z)"})]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Up"}),": ",(0,i.jsx)(e.code,{children:"(x, y - 1, z)"})]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Down"}),": ",(0,i.jsx)(e.code,{children:"(x, y + 1, z)"})]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Forward"}),": ",(0,i.jsx)(e.code,{children:"(x, y, z + 1)"})]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Backward"}),": ",(0,i.jsx)(e.code,{children:"(x, y, z - 1)"})]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"breadth-first-search-bfs-algorithm",children:"Breadth-First Search (BFS) Algorithm"}),"\n",(0,i.jsx)(e.p,{children:"BFS explores nodes level by level, starting from the source node. For a 3D grid:"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Initialization"}),":"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Use a queue to keep track of cells to visit."}),"\n",(0,i.jsx)(e.li,{children:"Maintain a set or array to mark visited cells to avoid reprocessing."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Processing"}),":"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Dequeue the front cell and process it."}),"\n",(0,i.jsx)(e.li,{children:"Enqueue all valid and unvisited neighboring cells."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Termination"}),":"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Continue until the queue is empty or a specific condition is met."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"javascript-implementation-1",children:"JavaScript Implementation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-JavaScript",children:"function isValid(x, y, z, grid) {\n    return (\n        x >= 0 && x < grid.length &&\n        y >= 0 && y < grid[0].length &&\n        z >= 0 && z < grid[0][0].length\n    );\n}\n\nfunction bfs3D(grid, start) {\n    const directions = [\n        [-1, 0, 0], [1, 0, 0], // left, right\n        [0, -1, 0], [0, 1, 0], // up, down\n        [0, 0, -1], [0, 0, 1]  // backward, forward\n    ];\n\n    const [startX, startY, startZ] = start;\n    const queue = [[startX, startY, startZ]];\n    const visited = new Set();\n    visited.add(`${startX},${startY},${startZ}`);\n\n    while (queue.length > 0) {\n        const [x, y, z] = queue.shift(); // Dequeue the front cell\n        console.log(`Visited cell: (${x}, ${y}, ${z})`); // Process the cell\n\n        for (const [dx, dy, dz] of directions) {\n            const nx = x + dx;\n            const ny = y + dy;\n            const nz = z + dz;\n\n            if (isValid(nx, ny, nz, grid) && !visited.has(`${nx},${ny},${nz}`)) {\n                visited.add(`${nx},${ny},${nz}`);\n                queue.push([nx, ny, nz]); // Enqueue the neighboring cell\n            }\n        }\n    }\n}\n\n// Example usage:\nconst grid = [\n    [\n        [[1, 2], [3, 4]],\n        [[5, 6], [7, 8]]\n    ],\n    [\n        [[9, 10], [11, 12]],\n        [[13, 14], [15, 16]]\n    ]\n];\n\nconst start = [0, 0, 0];\nbfs3D(grid, start);\n"})}),"\n",(0,i.jsx)(e.h2,{id:"shortest-path-using-bfs-on-2d-grid",children:"Shortest Path using BFS on 2D Grid"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-JavaScript",children:"function shortestPathInGrid(grid, startX, startY, endX, endY) {\n    const rows = grid.length;\n    const cols = grid[0].length;\n    const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]]; // Right, Down, Left, Up\n\n    let queue = [[startX, startY, 0]]; // [row, col, distance]\n    let visited = new Set([`${startX},${startY}`]);\n\n    while (queue.length > 0) {\n        const [x, y, dist] = queue.shift();\n\n        if (x === endX && y === endY) return dist; // Reached the target\n\n        for (const [dx, dy] of directions) {\n            const newX = x + dx;\n            const newY = y + dy;\n\n            if (newX >= 0 && newY >= 0 && newX < rows && newY < cols &&\n                grid[newX][newY] === 1 && !visited.has(`${newX},${newY}`)) {\n                visited.add(`${newX},${newY}`);\n                queue.push([newX, newY, dist + 1]);\n            }\n        }\n    }\n\n    return -1; // No path found\n}\n"})}),"\n",(0,i.jsx)(e.h2,{id:"shortest-path-using-dijkstra-on-2d-grid",children:"Shortest Path using Dijkstra on 2D Grid"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-JavaScript",children:"function dijkstra(grid, start, end) {\n  const rows = grid.length;\n  const cols = grid[0].length;\n  const distances = Array.from({ length: rows }, () => Array(cols).fill(Infinity));\n  const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]]; // Right, Down, Left, Up\n  const heap = new MinHeap();\n  const [startRow, startCol] = start;\n  const [endRow, endCol] = end;\n\n  distances[startRow][startCol] = 0;\n  heap.push([0, startRow, startCol]); //startDistance, row, col\n\n  while (heap.heap.length > 0) {\n    const [currentDist, row, col] = heap.pop();\n\n    if (row === endRow && col === endCol) {\n      return currentDist;\n    }\n\n    for (const [dr, dc] of directions) {\n      const newRow = row + dr;\n      const newCol = col + dc;\n\n      if (\n        newRow >= 0 &&\n        newRow < rows &&\n        newCol >= 0 &&\n        newCol < cols\n      ) {\n        const newDist = currentDist + grid[newRow][newCol];\n        if (newDist < distances[newRow][newCol]) {\n          distances[newRow][newCol] = newDist;\n          heap.push([newDist, newRow, newCol]);\n        }\n      }\n    }\n  }\n\n  return -1; // If no path is found\n}\n"})})]})}function h(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(a,{...n})}):a(n)}},8453:(n,e,r)=>{r.d(e,{R:()=>o,x:()=>d});var i=r(6540);const t={},s=i.createContext(t);function o(n){const e=i.useContext(s);return i.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function d(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:o(n.components),i.createElement(s.Provider,{value:e},n.children)}}}]);