"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[22747],{28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>a});var r=t(96540);const i={},o=r.createContext(i);function s(e){const n=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(o.Provider,{value:n},e.children)}},62980:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>o,metadata:()=>a,toc:()=>h});var r=t(74848),i=t(28453);const o={},s="TreeMap",a={id:"DSA/DSA with JavaScript/TreeMap",title:"TreeMap",description:"A self-balancing binary search tree implementation that stores key-value pairs in sorted order by keys.",source:"@site/docs/DSA/DSA with JavaScript/TreeMap.mdx",sourceDirName:"DSA/DSA with JavaScript",slug:"/DSA/DSA with JavaScript/TreeMap",permalink:"/docs/DSA/DSA with JavaScript/TreeMap",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with JavaScript/TreeMap.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Topological Sort Tutorial",permalink:"/docs/DSA/DSA with JavaScript/TopologicalSort"},next:{title:"TreeSet",permalink:"/docs/DSA/DSA with JavaScript/TreeSet"}},l={},h=[{value:"Purpose",id:"purpose",level:3},{value:"Common Methods",id:"common-methods",level:3},{value:"Example Usage",id:"example-usage",level:3},{value:"When to Use Each",id:"when-to-use-each",level:3},{value:"Performance Comparison",id:"performance-comparison",level:3}];function d(e){const n={code:"code",h1:"h1",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"treemap",children:"TreeMap"})}),"\n",(0,r.jsx)(n.p,{children:"A self-balancing binary search tree implementation that stores key-value pairs in sorted order by keys."}),"\n",(0,r.jsx)(n.h3,{id:"purpose",children:"Purpose"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Maintains key-value pairs in sorted order"}),"\n",(0,r.jsx)(n.li,{children:"Provides efficient operations for insertion, deletion, and lookup"}),"\n",(0,r.jsx)(n.li,{children:"Guarantees O(log n) time complexity for most operations"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"common-methods",children:"Common Methods"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const map = new TreeMap();\n\n// Basic Operations\nmap.put(key, value); // Add or update key-value pair\nmap.get(key); // Get value by key\nmap.remove(key); // Remove key-value pair\nmap.has(key); // Check if key exists\nmap.clear(); // Remove all entries\nmap.getSize(); // Get number of entries\nmap.isEmpty(); // Check if map is empty\n\n// Navigation\nmap.firstKey(); // Get minimum key\nmap.lastKey(); // Get maximum key\nmap.ceilingKey(key); // Get smallest key \u2265 given key\nmap.floorKey(key); // Get largest key \u2264 given key\n\n// Collection Views\nmap.keys(); // Get all keys in sorted order\nmap.values(); // Get all values in key order\nmap.entries(); // Get all key-value pairs in key order\n"})}),"\n",(0,r.jsx)(n.h3,{id:"example-usage",children:"Example Usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const map = new TreeMap();\nmap.put('A', 1);\nmap.put('C', 3);\nmap.put('B', 2);\n\nconsole.log(map.get('B')); // 2\nconsole.log(map.ceilingKey('B')); // \"B\"\nconsole.log(map.floorKey('B')); // \"B\"\nconsole.log(map.keys()); // [\"A\", \"B\", \"C\"]\n"})}),"\n",(0,r.jsx)(n.h1,{id:"treemap-implementation",children:"TreeMap implementation"}),"\n",(0,r.jsx)(n.p,{children:"The TreeMap implementation provides a wide range of functionalities for storing and navigating key-value pairs."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-JavaScript",children:'class TreeNode {\n  constructor(key, value) {\n    this.key = key;\n    this.value = value;\n    this.left = null;\n    this.right = null;\n    this.height = 1;\n  }\n}\n\n\nclass TreeMap {\n  constructor() {\n    this.root = null;\n    this.size = 0;\n  }\n\n  // Get height of node\n  #getHeight(node) {\n    return node ? node.height : 0;\n  }\n\n  // Get balance factor\n  #getBalance(node) {\n    return node ? this.#getHeight(node.left) - this.#getHeight(node.right) : 0;\n  }\n\n  // Right rotation\n  #rightRotate(y) {\n    const x = y.left;\n    const T2 = x.right;\n\n    x.right = y;\n    y.left = T2;\n\n    y.height = Math.max(this.#getHeight(y.left), this.#getHeight(y.right)) + 1;\n    x.height = Math.max(this.#getHeight(x.left), this.#getHeight(x.right)) + 1;\n\n    return x;\n  }\n\n  // Left rotation\n  #leftRotate(x) {\n    const y = x.right;\n    const T2 = y.left;\n\n    y.left = x;\n    x.right = T2;\n\n    x.height = Math.max(this.#getHeight(x.left), this.#getHeight(x.right)) + 1;\n    y.height = Math.max(this.#getHeight(y.left), this.#getHeight(y.right)) + 1;\n\n    return y;\n  }\n\n  // Insert a key-value pair\n  put(key, value) {\n    this.root = this.#put(this.root, key, value);\n    return this;\n  }\n\n  #put(node, key, value) {\n    if (!node) {\n      this.size++;\n      return new TreeNode(key, value);\n    }\n\n    if (key < node.key) {\n      node.left = this.#put(node.left, key, value);\n    } else if (key > node.key) {\n      node.right = this.#put(node.right, key, value);\n    } else {\n      node.value = value; // Update value if key exists\n      return node;\n    }\n\n    node.height = Math.max(this.#getHeight(node.left), this.#getHeight(node.right)) + 1;\n\n    const balance = this.#getBalance(node);\n\n    // Left Left Case\n    if (balance > 1 && key < node.left.key) {\n      return this.#rightRotate(node);\n    }\n\n    // Right Right Case\n    if (balance < -1 && key > node.right.key) {\n      return this.#leftRotate(node);\n    }\n\n    // Left Right Case\n    if (balance > 1 && key > node.left.key) {\n      node.left = this.#leftRotate(node.left);\n      return this.#rightRotate(node);\n    }\n\n    // Right Left Case\n    if (balance < -1 && key < node.right.key) {\n      node.right = this.#rightRotate(node.right);\n      return this.#leftRotate(node);\n    }\n\n    return node;\n  }\n\n  // Get value by key\n  get(key) {\n    const node = this.#get(this.root, key);\n    return node ? node.value : undefined;\n  }\n\n  #get(node, key) {\n    if (!node) return null;\n    if (key === node.key) return node;\n    return key < node.key ? this.#get(node.left, key) : this.#get(node.right, key);\n  }\n\n  // Remove key-value pair\n  remove(key) {\n    const hasKey = this.has(key);\n    if (hasKey) {\n      this.root = this.#remove(this.root, key);\n      this.size--;\n    }\n    return hasKey;\n  }\n\n  #remove(node, key) {\n    if (!node) return null;\n\n    if (key < node.key) {\n      node.left = this.#remove(node.left, key);\n    } else if (key > node.key) {\n      node.right = this.#remove(node.right, key);\n    } else {\n      if (!node.left || !node.right) {\n        return node.left || node.right;\n      }\n\n      const successor = this.#getMin(node.right);\n      node.key = successor.key;\n      node.value = successor.value;\n      node.right = this.#remove(node.right, successor.key);\n    }\n\n    node.height = Math.max(this.#getHeight(node.left), this.#getHeight(node.right)) + 1;\n\n    const balance = this.#getBalance(node);\n\n    // Rebalance after removal\n    if (balance > 1 && this.#getBalance(node.left) >= 0) {\n      return this.#rightRotate(node);\n    }\n    if (balance > 1 && this.#getBalance(node.left) < 0) {\n      node.left = this.#leftRotate(node.left);\n      return this.#rightRotate(node);\n    }\n    if (balance < -1 && this.#getBalance(node.right) <= 0) {\n      return this.#leftRotate(node);\n    }\n    if (balance < -1 && this.#getBalance(node.right) > 0) {\n      node.right = this.#rightRotate(node.right);\n      return this.#leftRotate(node);\n    }\n\n    return node;\n  }\n\n  // Check if key exists\n  has(key) {\n    return this.#get(this.root, key) !== null;\n  }\n\n  // Get minimum key\n  firstKey() {\n    if (!this.root) return undefined;\n    return this.#getMin(this.root).key;\n  }\n\n  // Get maximum key\n  lastKey() {\n    if (!this.root) return undefined;\n    return this.#getMax(this.root).key;\n  }\n\n  #getMin(node) {\n    while (node.left) {\n      node = node.left;\n    }\n    return node;\n  }\n\n  #getMax(node) {\n    while (node.right) {\n      node = node.right;\n    }\n    return node;\n  }\n\n  // Get first key greater than or equal to given key\n  ceilingKey(key) {\n    let node = this.root;\n    let ceiling = null;\n\n    while (node) {\n      if (key === node.key) {\n        return key;\n      }\n      if (key < node.key) {\n        ceiling = node.key;\n        node = node.left;\n      } else {\n        node = node.right;\n      }\n    }\n\n    return ceiling;\n  }\n\n  // Get last key less than or equal to given key\n  floorKey(key) {\n    let node = this.root;\n    let floor = null;\n\n    while (node) {\n      if (key === node.key) {\n        return key;\n      }\n      if (key < node.key) {\n        node = node.left;\n      } else {\n        floor = node.key;\n        node = node.right;\n      }\n    }\n\n    return floor;\n  }\n\n  // Clear all entries\n  clear() {\n    this.root = null;\n    this.size = 0;\n  }\n\n  // Get size of tree\n  getSize() {\n    return this.size;\n  }\n\n  // Check if tree is empty\n  isEmpty() {\n    return this.size === 0;\n  }\n\n  // Get all keys in order\n  keys() {\n    const result = [];\n    this.#inorderTraversal(this.root, node => result.push(node.key));\n    return result;\n  }\n\n  // Get all values in order of keys\n  values() {\n    const result = [];\n    this.#inorderTraversal(this.root, node => result.push(node.value));\n    return result;\n  }\n\n  // Get all entries in order\n  entries() {\n    const result = [];\n    this.#inorderTraversal(this.root, node => result.push([node.key, node.value]));\n    return result;\n  }\n\n  #inorderTraversal(node, callback) {\n    if (node) {\n      this.#inorderTraversal(node.left, callback);\n      callback(node);\n      this.#inorderTraversal(node.right, callback);\n    }\n  }\n}\n\nconst map = new TreeMap();\n\n// Insert key-value pairs\nmap.put(5, "five");\nmap.put(3, "three");\nmap.put(7, "seven");\n\nconsole.log(map.get(3));  // "three"\nconsole.log(map.has(7));  // true\nconsole.log(map.firstKey());  // 3\nconsole.log(map.lastKey());   // 7\nconsole.log(map.ceilingKey(4));  // 5\nconsole.log(map.floorKey(6));    // 5\nconsole.log(map.keys());     // [3, 5, 7]\nconsole.log(map.getSize());  // 3\n\nmap.remove(5);\nconsole.log(map.has(5));  // false\n'})}),"\n",(0,r.jsx)(n.h3,{id:"when-to-use-each",children:"When to Use Each"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"TreeMap"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Need key-value associations in sorted order"}),"\n",(0,r.jsx)(n.li,{children:"Large datasets with frequent modifications"}),"\n",(0,r.jsx)(n.li,{children:"Need efficient range queries"}),"\n",(0,r.jsx)(n.li,{children:"Memory usage is not a primary concern"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"performance-comparison",children:"Performance Comparison"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Operation"}),(0,r.jsx)(n.th,{children:"TreeMap/Set"}),(0,r.jsx)(n.th,{children:"SortedList"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Insert"}),(0,r.jsx)(n.td,{children:"O(log n)"}),(0,r.jsx)(n.td,{children:"O(n)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Delete"}),(0,r.jsx)(n.td,{children:"O(log n)"}),(0,r.jsx)(n.td,{children:"O(n)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Search"}),(0,r.jsx)(n.td,{children:"O(log n)"}),(0,r.jsx)(n.td,{children:"O(log n)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Access"}),(0,r.jsx)(n.td,{children:"O(log n)"}),(0,r.jsx)(n.td,{children:"O(1)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Min/Max"}),(0,r.jsx)(n.td,{children:"O(log n)"}),(0,r.jsx)(n.td,{children:"O(1)"})]})]})]})]})}function c(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);