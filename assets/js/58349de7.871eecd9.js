"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[77010],{28453:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>c});var r=s(96540);const o={},l=r.createContext(o);function i(e){const n=r.useContext(l);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),r.createElement(l.Provider,{value:n},e.children)}},38106:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>t,contentTitle:()=>i,default:()=>h,frontMatter:()=>l,metadata:()=>c,toc:()=>a});var r=s(74848),o=s(28453);const l={},i="JavaScript Promises & Event Loop - Tricky Questions",c={id:"Interview Prep 2026/JavaScript Promises & Event Loop - Tricky Questions",title:"JavaScript Promises & Event Loop - Tricky Questions",description:"A comprehensive guide to understanding JavaScript promises, async/await, and the event loop through challenging quiz questions.",source:"@site/docs/08-Interview Prep 2026/JavaScript Promises & Event Loop - Tricky Questions.mdx",sourceDirName:"08-Interview Prep 2026",slug:"/Interview Prep 2026/JavaScript Promises & Event Loop - Tricky Questions",permalink:"/docs/Interview Prep 2026/JavaScript Promises & Event Loop - Tricky Questions",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/08-Interview Prep 2026/JavaScript Promises & Event Loop - Tricky Questions.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"JavaScript Meta Programming Guide",permalink:"/docs/Interview Prep 2026/JavaScript Meta Programming Guide"},next:{title:"JavaScript Prototypes & Inheritance: Complete Guide",permalink:"/docs/Interview Prep 2026/JavaScript Prototypes & Inheritance: Complete Guide"}},t={},a=[{value:"#1: Promise Executor Order",id:"1-promise-executor-order",level:2},{value:"#2: Promise Chain Return Values",id:"2-promise-chain-return-values",level:2},{value:"#3: Promise.resolve Unwrapping",id:"3-promiseresolve-unwrapping",level:2},{value:"#4: Microtasks vs Macrotasks",id:"4-microtasks-vs-macrotasks",level:2},{value:"#5: Error Handling in Chains",id:"5-error-handling-in-chains",level:2},{value:"#6: Promise Settles Once",id:"6-promise-settles-once",level:2},{value:"#7: Return Values and Rejections",id:"7-return-values-and-rejections",level:2},{value:"#8: Async/Await and Microtasks",id:"8-asyncawait-and-microtasks",level:2},{value:"#9: Promise.all Fail Fast",id:"9-promiseall-fail-fast",level:2},{value:"#10: Nested Promise Chains",id:"10-nested-promise-chains",level:2},{value:"#11: Promise.race First Settler",id:"11-promiserace-first-settler",level:2},{value:"#12: Multiple Catches",id:"12-multiple-catches",level:2},{value:"#13: Async Function Return Values",id:"13-async-function-return-values",level:2},{value:"#14: Promise.finally Behavior",id:"14-promisefinally-behavior",level:2},{value:"#15: Complex Event Loop Ordering",id:"15-complex-event-loop-ordering",level:2},{value:"#16: Executor Sync, Resolve Async",id:"16-executor-sync-resolve-async",level:2},{value:"#17: Complex Microtask and Macrotask Mix",id:"17-complex-microtask-and-macrotask-mix",level:2},{value:"Event Loop Fundamentals",id:"event-loop-fundamentals",level:2},{value:"Execution Order:",id:"execution-order",level:3},{value:"Key Concepts:",id:"key-concepts",level:3},{value:"Practice Tips",id:"practice-tips",level:2},{value:"Additional Tricky Questions - Nested Patterns",id:"additional-tricky-questions---nested-patterns",level:2},{value:"#18: Promise Inside setTimeout",id:"18-promise-inside-settimeout",level:3},{value:"#19: Multiple Nested Levels",id:"19-multiple-nested-levels",level:3},{value:"#20: setTimeout Zero with Promises",id:"20-settimeout-zero-with-promises",level:3},{value:"#21: Deep Nesting Pattern",id:"21-deep-nesting-pattern",level:3},{value:"#22: Promise Constructor Pitfall",id:"22-promise-constructor-pitfall",level:3},{value:"#23: Throw in Finally",id:"23-throw-in-finally",level:3},{value:"#24: Async Function Exception",id:"24-async-function-exception",level:3},{value:"#25: Interleaved Nesting",id:"25-interleaved-nesting",level:3},{value:"#26: Triple Nesting",id:"26-triple-nesting",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"javascript-promises--event-loop---tricky-questions",children:"JavaScript Promises & Event Loop - Tricky Questions"})}),"\n",(0,r.jsx)(n.p,{children:"A comprehensive guide to understanding JavaScript promises, async/await, and the event loop through challenging quiz questions."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"1-promise-executor-order",children:"#1: Promise Executor Order"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"console.log('Start');\n\nconst promise = new Promise((resolve, reject) => {\n  console.log('Promise executor');\n  resolve('Resolved');\n});\n\npromise.then((value) => {\n  console.log(value);\n});\n\nconsole.log('End');\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Output:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Start\nPromise executor\nEnd\nResolved\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Explanation:"}),"\nThe promise executor runs synchronously when the promise is created. The ",(0,r.jsx)(n.code,{children:".then()"})," callback is scheduled as a microtask and runs after the current synchronous code completes."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Answer: Start, Promise executor, End, Resolved"})," \u2713"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"2-promise-chain-return-values",children:"#2: Promise Chain Return Values"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"Promise.resolve(1)\n  .then((value) => {\n    console.log(value);\n    return value + 1;\n  })\n  .then((value) => {\n    console.log(value);\n  })\n  .then((value) => {\n    console.log(value);\n    return Promise.resolve(3);\n  })\n  .then((value) => {\n    console.log(value);\n  });\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Output:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"1\n2\nundefined\n3\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Explanation:"}),"\nThe second ",(0,r.jsx)(n.code,{children:".then()"})," doesn't return anything, so ",(0,r.jsx)(n.code,{children:"undefined"})," is passed to the next ",(0,r.jsx)(n.code,{children:".then()"}),". The third ",(0,r.jsx)(n.code,{children:".then()"})," returns a promise that resolves to 3."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Answer: 1, 2, undefined, 3"})," \u2713"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"3-promiseresolve-unwrapping",children:"#3: Promise.resolve Unwrapping"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const promise1 = Promise.resolve(Promise.resolve(Promise.resolve(1)));\n\npromise1.then((value) => {\n  console.log(value);\n});\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Output:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"1\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Explanation:"}),"\n",(0,r.jsx)(n.code,{children:"Promise.resolve()"})," automatically unwraps nested promises. It recursively unwraps until it gets to a non-promise value."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Answer: 1"})," \u2713"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"4-microtasks-vs-macrotasks",children:"#4: Microtasks vs Macrotasks"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"console.log('1');\n\nsetTimeout(() => {\n  console.log('2');\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('3');\n});\n\nconsole.log('4');\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Output:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"1\n4\n3\n2\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Explanation:"}),"\nSynchronous code runs first (1, 4). Microtasks (promises) run before macrotasks (setTimeout), so 3 runs before 2."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Answer: 1, 4, 3, 2"})," \u2713"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"5-error-handling-in-chains",children:"#5: Error Handling in Chains"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"Promise.resolve('Start')\n  .then((value) => {\n    console.log(value);\n    throw new Error('Oops!');\n  })\n  .then((value) => {\n    console.log('Hello');\n  })\n  .catch((error) => {\n    console.log('Caught:', error.message);\n    return 'Recovered';\n  })\n  .then((value) => {\n    console.log(value);\n  });\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Output:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Start\nCaught: Oops!\nRecovered\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Explanation:"}),"\nThe error skips the second ",(0,r.jsx)(n.code,{children:".then()"})," and goes directly to ",(0,r.jsx)(n.code,{children:".catch()"}),". The catch returns a resolved value, so the chain continues normally."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Answer: Start, Caught: Oops!, Recovered"})," \u2713"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"6-promise-settles-once",children:"#6: Promise Settles Once"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const promise = new Promise((resolve, reject) => {\n  resolve('First');\n  resolve('Second');\n  reject('Third');\n});\n\npromise\n  .then((value) => console.log(value))\n  .catch((error) => console.log(error));\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Output:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"First\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Explanation:"}),"\nA promise can only settle once. After the first ",(0,r.jsx)(n.code,{children:"resolve('First')"}),", all subsequent resolve/reject calls are ignored."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Answer: First"})," \u2713"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"7-return-values-and-rejections",children:"#7: Return Values and Rejections"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"new Promise((resolve, reject) => {\n  resolve(1);\n})\n  .then((value) => {\n    console.log(value);\n    return 2;\n  })\n  .then((value) => {\n    console.log(value);\n    // No return statement\n  })\n  .then((value) => {\n    console.log(value);\n    return Promise.reject('Error');\n  })\n  .catch((error) => {\n    console.log(error);\n  })\n  .then(() => {\n    console.log('Done');\n  });\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Output:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"1\n2\nundefined\nError\nDone\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Explanation:"}),"\nMissing return statements result in ",(0,r.jsx)(n.code,{children:"undefined"}),". After ",(0,r.jsx)(n.code,{children:".catch()"}),", the chain continues with a resolved promise."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Answer: 1, 2, undefined, Error, Done"})," \u2713"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"8-asyncawait-and-microtasks",children:"#8: Async/Await and Microtasks"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"async function test() {\n  console.log('1');\n  await Promise.resolve();\n  console.log('2');\n}\n\nconsole.log('3');\ntest();\nconsole.log('4');\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Output:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"3\n1\n4\n2\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Explanation:"}),"\n",(0,r.jsx)(n.code,{children:"test()"})," runs synchronously until ",(0,r.jsx)(n.code,{children:"await"}),", which schedules the rest as a microtask. Synchronous code (4) completes first, then microtask (2) runs."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Answer: 3, 1, 4, 2"})," \u2713"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"9-promiseall-fail-fast",children:"#9: Promise.all Fail Fast"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const promise1 = Promise.resolve(1);\nconst promise2 = Promise.reject('Error');\nconst promise3 = Promise.resolve(3);\n\nPromise.all([promise1, promise2, promise3])\n  .then((values) => {\n    console.log('Success:', values);\n  })\n  .catch((error) => {\n    console.log('Failed:', error);\n  });\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Output:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Failed: Error\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Explanation:"}),"\n",(0,r.jsx)(n.code,{children:"Promise.all()"})," rejects immediately when any promise rejects. It doesn't wait for other promises to settle."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Answer: Failed: Error"})," \u2713"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"10-nested-promise-chains",children:"#10: Nested Promise Chains"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"Promise.resolve(1)\n  .then((value) => {\n    console.log(value);\n    Promise.resolve(2)\n      .then((value) => {\n        console.log(value);\n      });\n    return 3;\n  })\n  .then((value) => {\n    console.log(value);\n  });\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Output:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"1\n3\n2\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Explanation:"}),"\nThe nested promise creates a separate microtask queue entry. The outer chain continues immediately with the return value (3), then the nested promise resolves (2)."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Answer: 1, 3, 2"})," \u2713"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"11-promiserace-first-settler",children:"#11: Promise.race First Settler"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const promise1 = new Promise((resolve) => {\n  setTimeout(() => resolve('Slow'), 1000);\n});\n\nconst promise2 = new Promise((resolve) => {\n  setTimeout(() => resolve('Fast'), 100);\n});\n\nconst promise3 = new Promise((resolve, reject) => {\n  setTimeout(() => reject('Error'), 50);\n});\n\nPromise.race([promise1, promise2, promise3])\n  .then((value) => {\n    console.log('Winner:', value);\n  })\n  .catch((error) => {\n    console.log('Failed:', error);\n  });\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Output:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Failed: Error\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Explanation:"}),"\n",(0,r.jsx)(n.code,{children:"Promise.race()"})," settles with the first promise that settles, whether resolved or rejected. The error at 50ms wins."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Answer: Failed: Error"})," \u2713"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"12-multiple-catches",children:"#12: Multiple Catches"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"Promise.reject('First error')\n  .catch((error) => {\n    console.log('Catch 1:', error);\n    throw new Error('Second error');\n  })\n  .catch((error) => {\n    console.log('Catch 2:', error.message);\n    return 'Recovered';\n  })\n  .then((value) => {\n    console.log('Then:', value);\n    throw new Error('Third error');\n  })\n  .catch((error) => {\n    console.log('Catch 3:', error.message);\n  });\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Output:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Catch 1: First error\nCatch 2: Second error\nThen: Recovered\nCatch 3: Third error\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Explanation:"}),"\nEach ",(0,r.jsx)(n.code,{children:".catch()"})," can handle errors and either recover (return) or propagate new errors (throw). The chain continues based on what each handler does."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Answer: Catch 1: First error, Catch 2: Second error, Then: Recovered, Catch 3: Third error"})," \u2713"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"13-async-function-return-values",children:"#13: Async Function Return Values"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"async function func1() {\n  return 1;\n}\n\nasync function func2() {\n  return Promise.resolve(2);\n}\n\nfunc1().then(console.log);\nfunc2().then(console.log);\nconsole.log(3);\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Output:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"3\n1\n2\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Explanation:"}),"\nAsync functions always return promises. Both ",(0,r.jsx)(n.code,{children:".then()"})," callbacks are microtasks that run after synchronous code (3). They execute in order: 1, then 2."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Answer: 3, 1, 2"})," \u2713"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"14-promisefinally-behavior",children:"#14: Promise.finally Behavior"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"Promise.resolve('Success')\n  .finally(() => {\n    console.log('Finally 1');\n    return 'This will be ignored';\n  })\n  .then((value) => {\n    console.log('Then 1:', value);\n  })\n  .finally(() => {\n    console.log('Finally 2');\n    throw new Error('Finally error');\n  })\n  .then((value) => {\n    console.log('Then 2:', value);\n  })\n  .catch((error) => {\n    console.log('Catch:', error.message);\n  });\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Output:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Finally 1\nThen 1: Success\nFinally 2\nCatch: Finally error\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Explanation:"}),"\n",(0,r.jsx)(n.code,{children:".finally()"})," doesn't change the promise value unless it throws an error or returns a rejected promise. Return values are ignored."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Answer: Finally 1, Then 1: Success, Finally 2, Catch: Finally error"})," \u2713"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"15-complex-event-loop-ordering",children:"#15: Complex Event Loop Ordering"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"console.log('Start');\n\nsetTimeout(() => {\n  console.log('Timeout 1');\n  Promise.resolve().then(() => console.log('Promise in Timeout'));\n}, 0);\n\nPromise.resolve()\n  .then(() => {\n    console.log('Promise 1');\n    setTimeout(() => console.log('Timeout in Promise'), 0);\n  })\n  .then(() => {\n    console.log('Promise 2');\n  });\n\nsetTimeout(() => {\n  console.log('Timeout 2');\n}, 0);\n\nconsole.log('End');\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Output:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Start\nEnd\nPromise 1\nPromise 2\nTimeout 1\nPromise in Timeout\nTimeout 2\nTimeout in Promise\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Explanation:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Synchronous: Start, End"}),"\n",(0,r.jsx)(n.li,{children:"Microtasks: Promise 1, Promise 2"}),"\n",(0,r.jsx)(n.li,{children:"Macrotask (Timeout 1) runs, creates microtask (Promise in Timeout)"}),"\n",(0,r.jsx)(n.li,{children:"Microtask runs: Promise in Timeout"}),"\n",(0,r.jsx)(n.li,{children:"Macrotask: Timeout 2"}),"\n",(0,r.jsx)(n.li,{children:"Macrotask: Timeout in Promise"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Answer: Start, End, Promise 1, Promise 2, Timeout 1, Promise in Timeout, Timeout 2, Timeout in Promise"})," \u2713"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"16-executor-sync-resolve-async",children:"#16: Executor Sync, Resolve Async"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const promise = new Promise((resolve, reject) => {\n  console.log('Executor start');\n  setTimeout(() => {\n    console.log('Timeout in executor');\n    resolve('Done');\n  }, 0);\n  console.log('Executor end');\n});\n\npromise.then((value) => {\n  console.log('Then:', value);\n});\n\nconsole.log('After promise creation');\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Output:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Executor start\nExecutor end\nAfter promise creation\nTimeout in executor\nThen: Done\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Explanation:"}),"\nThe executor runs synchronously. ",(0,r.jsx)(n.code,{children:"setTimeout"})," schedules a macrotask. Synchronous code completes first, then the timeout runs and resolves the promise."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Answer: Executor start, Executor end, After promise creation, Timeout in executor, Then: Done"})," \u2713"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"17-complex-microtask-and-macrotask-mix",children:"#17: Complex Microtask and Macrotask Mix"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"console.log(1);\n\nsetTimeout(() => {\n  console.log(2);\n}, 10);\n\nsetTimeout(() => {\n  console.log(3);\n}, 0);\n\nnew Promise((_, reject) => {\n  console.log(4);\n  reject(5);\n  console.log(6);\n})\n  .then(() => console.log(7))\n  .catch(() => console.log(8))\n  .then(() => console.log(9))\n  .catch(() => console.log(10))\n  .then(() => console.log(11))\n  .then(console.log)\n  .finally(() => console.log(12));\n\nconsole.log(13);\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Output:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"1\n4\n6\n13\n8\n9\n11\nundefined\n12\n3\n2\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Explanation:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Synchronous:"})," 1, 4, 6, 13"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Microtasks (promise chain):"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Rejection caught: 8"}),"\n",(0,r.jsx)(n.li,{children:"Chain continues: 9, 11"}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:".then(console.log)"})," logs ",(0,r.jsx)(n.code,{children:"undefined"})," (no return value)"]}),"\n",(0,r.jsx)(n.li,{children:"Finally: 12"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Macrotasks:"})," 3 (0ms timeout), then 2 (10ms timeout)"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Key Points:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Promise executor runs synchronously"}),"\n",(0,r.jsx)(n.li,{children:"Reject doesn't stop executor (6 still logs)"}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:".catch()"})," recovers the chain"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:".then(console.log)"})," without return logs ",(0,r.jsx)(n.code,{children:"undefined"})]}),"\n",(0,r.jsx)(n.li,{children:"Microtasks drain completely before macrotasks"}),"\n",(0,r.jsx)(n.li,{children:"Timeouts execute in order of delay"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"event-loop-fundamentals",children:"Event Loop Fundamentals"}),"\n",(0,r.jsx)(n.h3,{id:"execution-order",children:"Execution Order:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Synchronous code"})," - Runs immediately"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Microtasks"})," - Promises, queueMicrotask"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Macrotasks"})," - setTimeout, setInterval, I/O"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"key-concepts",children:"Key Concepts:"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Promise Executor:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Runs synchronously when promise is created"}),"\n",(0,r.jsx)(n.li,{children:"Cannot be cancelled once started"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Microtask Queue:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:".then()"}),", ",(0,r.jsx)(n.code,{children:".catch()"}),", ",(0,r.jsx)(n.code,{children:".finally()"})," callbacks"]}),"\n",(0,r.jsx)(n.li,{children:"Drains completely before next macrotask"}),"\n",(0,r.jsx)(n.li,{children:"New microtasks added during processing still run in same cycle"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Macrotask Queue:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"setTimeout, setInterval callbacks"}),"\n",(0,r.jsx)(n.li,{children:"One macrotask per event loop cycle"}),"\n",(0,r.jsx)(n.li,{children:"After each macrotask, microtask queue drains"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Async/Await:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Code before ",(0,r.jsx)(n.code,{children:"await"})," runs synchronously"]}),"\n",(0,r.jsxs)(n.li,{children:["Code after ",(0,r.jsx)(n.code,{children:"await"})," becomes a microtask"]}),"\n",(0,r.jsxs)(n.li,{children:["Equivalent to ",(0,r.jsx)(n.code,{children:".then()"})," callback"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Promise Settling:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Promises settle only once"}),"\n",(0,r.jsx)(n.li,{children:"Subsequent resolve/reject calls ignored"}),"\n",(0,r.jsx)(n.li,{children:"Settlement is irreversible"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"practice-tips",children:"Practice Tips"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Track execution order:"})," Synchronous \u2192 Microtasks \u2192 Macrotasks"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Watch for nested promises:"})," They create separate microtask entries"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Return values matter:"})," Missing returns pass ",(0,r.jsx)(n.code,{children:"undefined"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Errors skip .then():"})," Go directly to next ",(0,r.jsx)(n.code,{children:".catch()"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Finally is special:"})," Doesn't change promise value (unless it throws)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Async always returns promise:"})," Even plain values get wrapped"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"additional-tricky-questions---nested-patterns",children:"Additional Tricky Questions - Nested Patterns"}),"\n",(0,r.jsx)(n.h3,{id:"18-promise-inside-settimeout",children:"#18: Promise Inside setTimeout"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"console.log(1);\n\nsetTimeout(() => {\n  console.log(3);\n  Promise.resolve().then(() => console.log(4));\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log(5);\n  setTimeout(() => {\n    console.log(7);\n  }, 0);\n});\n\nconsole.log(6);\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Output:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"1\n6\n5\n3\n4\n7\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Explanation:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Synchronous:"})," 1, 6"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Microtask:"})," 5 (creates setTimeout with 7)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Macrotask 1:"})," 3 (creates microtask with 4)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Microtask:"})," 4 (from inside first setTimeout)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Macrotask 2:"})," 7 (from inside first promise)"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Key Point:"})," When a macrotask creates a microtask, that microtask runs before the next macrotask!"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"19-multiple-nested-levels",children:"#19: Multiple Nested Levels"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"console.log('A');\n\nsetTimeout(() => {\n  console.log('B');\n  Promise.resolve().then(() => {\n    console.log('C');\n    setTimeout(() => console.log('D'), 0);\n  });\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('E');\n  setTimeout(() => {\n    console.log('F');\n    Promise.resolve().then(() => console.log('G'));\n  }, 0);\n});\n\nsetTimeout(() => console.log('H'), 0);\n\nconsole.log('I');\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Output:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"A\nI\nE\nB\nC\nH\nF\nG\nD\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Explanation:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sync:"})," A, I"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Microtask:"})," E (schedules F-G timeout)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Macrotask:"})," B (schedules C microtask)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Microtask:"})," C (schedules D timeout)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Macrotask:"})," H"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Macrotask:"})," F (schedules G microtask)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Microtask:"})," G"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Macrotask:"})," D"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"20-settimeout-zero-with-promises",children:"#20: setTimeout Zero with Promises"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"console.log(1);\n\nsetTimeout(() => {\n  console.log(2);\n  Promise.resolve()\n    .then(() => console.log(3))\n    .then(() => console.log(4));\n}, 0);\n\nsetTimeout(() => {\n  console.log(5);\n  Promise.resolve()\n    .then(() => console.log(6));\n}, 0);\n\nPromise.resolve()\n  .then(() => {\n    console.log(7);\n    setTimeout(() => console.log(8), 0);\n  })\n  .then(() => console.log(9));\n\nconsole.log(10);\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Output:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"1\n10\n7\n9\n2\n3\n4\n5\n6\n8\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Explanation:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sync:"})," 1, 10"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Microtasks:"})," 7 (schedules 8), then 9"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Macrotask:"})," 2 (schedules 3, 4 microtasks)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Microtasks:"})," 3, 4 (drain before next macrotask)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Macrotask:"})," 5 (schedules 6 microtask)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Microtask:"})," 6"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Macrotask:"})," 8"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"21-deep-nesting-pattern",children:"#21: Deep Nesting Pattern"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"setTimeout(() => {\n  console.log('Timeout 1');\n  Promise.resolve()\n    .then(() => {\n      console.log('Promise 1');\n      setTimeout(() => {\n        console.log('Timeout 2');\n        Promise.resolve().then(() => console.log('Promise 2'));\n      }, 0);\n    })\n    .then(() => console.log('Promise 3'));\n}, 0);\n\nconsole.log('Start');\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Output:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Start\nTimeout 1\nPromise 1\nPromise 3\nTimeout 2\nPromise 2\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Explanation:"}),"\nMicrotasks created within a macrotask must complete before the next macrotask runs. This creates a cascading effect where each level fully resolves its microtasks."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"22-promise-constructor-pitfall",children:"#22: Promise Constructor Pitfall"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const p = new Promise((resolve) => {\n  return resolve(Promise.resolve(2));\n});\n\np.then(console.log);\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Output:"})," ",(0,r.jsx)(n.code,{children:"2"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Explanation:"})," Promise constructors unwrap returned promises just like ",(0,r.jsx)(n.code,{children:"Promise.resolve()"}),"."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"23-throw-in-finally",children:"#23: Throw in Finally"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"Promise.resolve(1)\n  .finally(() => {\n    throw new Error('Finally error');\n  })\n  .then(\n    (value) => console.log('Success:', value),\n    (error) => console.log('Error:', error.message)\n  );\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Output:"})," ",(0,r.jsx)(n.code,{children:"Error: Finally error"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Explanation:"})," Throwing in ",(0,r.jsx)(n.code,{children:".finally()"})," rejects the promise, overriding the original value."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"24-async-function-exception",children:"#24: Async Function Exception"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"async function test() {\n  throw new Error('Async error');\n}\n\ntest().catch((error) => console.log('Caught:', error.message));\nconsole.log('After test call');\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Output:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"After test call\nCaught: Async error\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Explanation:"})," Async function exceptions are caught asynchronously as microtasks, so synchronous code runs first."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"25-interleaved-nesting",children:"#25: Interleaved Nesting"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"console.log('Start');\n\nPromise.resolve().then(() => {\n  console.log('P1');\n  setTimeout(() => console.log('T1'), 0);\n});\n\nsetTimeout(() => {\n  console.log('T2');\n  Promise.resolve().then(() => console.log('P2'));\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('P3');\n  setTimeout(() => console.log('T3'), 0);\n});\n\nsetTimeout(() => {\n  console.log('T4');\n  Promise.resolve().then(() => console.log('P4'));\n}, 0);\n\nconsole.log('End');\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Output:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Start\nEnd\nP1\nP3\nT2\nP2\nT4\nP4\nT1\nT3\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Explanation:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sync:"})," Start, End"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Microtasks:"})," P1 (schedules T1), P3 (schedules T3)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Macrotask:"})," T2 (schedules P2 microtask)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Microtask:"})," P2 (drains before next macrotask)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Macrotask:"})," T4 (schedules P4 microtask)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Microtask:"})," P4"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Macrotasks:"})," T1, T3 (scheduled from earlier promises)"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"26-triple-nesting",children:"#26: Triple Nesting"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"console.log(1);\n\nsetTimeout(() => {\n  console.log(2);\n  Promise.resolve().then(() => {\n    console.log(3);\n    setTimeout(() => {\n      console.log(4);\n      Promise.resolve().then(() => console.log(5));\n    }, 0);\n  });\n  setTimeout(() => console.log(6), 0);\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log(7);\n  setTimeout(() => {\n    console.log(8);\n    Promise.resolve().then(() => console.log(9));\n  }, 0);\n});\n\nconsole.log(10);\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Output:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"1\n10\n7\n2\n3\n6\n8\n9\n4\n5\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Explanation:"}),'\nThis demonstrates the "microtask barrier" - microtasks always drain completely before moving to the next macrotask, creating predictable ordering even with deep nesting.']})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);