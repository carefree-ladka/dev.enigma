"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[11166],{28453:(e,n,i)=>{i.d(n,{R:()=>d,x:()=>l});var t=i(96540);const r={},s=t.createContext(r);function d(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:d(e.components),t.createElement(s.Provider,{value:n},e.children)}},91737:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>h,frontMatter:()=>s,metadata:()=>l,toc:()=>a});var t=i(74848),r=i(28453);const s={},d="Complete Guide to Graph Cycles",l={id:"DSA/Graph Cycles",title:"Complete Guide to Graph Cycles",description:"Table of Contents",source:"@site/docs/DSA/Graph Cycles.mdx",sourceDirName:"DSA",slug:"/DSA/Graph Cycles",permalink:"/docs/DSA/Graph Cycles",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/Graph Cycles.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Blind 75 + Essential LeetCode Solutions",permalink:"/docs/DSA/Blind 75 + Essential LeetCode Solutions"},next:{title:"Java Tutorial",permalink:"/docs/category/java-tutorial"}},c={},a=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Part 1: Cycle Detection Techniques",id:"part-1-cycle-detection-techniques",level:3},{value:"Part 2: Finding Shortest and Longest Cycles",id:"part-2-finding-shortest-and-longest-cycles",level:3},{value:"Introduction to Cycle Detection",id:"cycle-detection-intro",level:2},{value:"Cycle Detection in Undirected Graphs",id:"cycle-detection-undirected",level:2},{value:"DFS-based Detection",id:"undirected-dfs",level:3},{value:"BFS-based Detection",id:"undirected-bfs",level:3},{value:"Union-Find (Disjoint Set Union)",id:"undirected-union-find",level:3},{value:"Cycle Detection in Directed Graphs",id:"cycle-detection-directed",level:2},{value:"DFS with Recursion Stack",id:"directed-dfs",level:3},{value:"BFS with Kahn&#39;s Algorithm (Topological Sort)",id:"directed-topo-sort",level:3},{value:"Graph Coloring (Three-Color Method)",id:"directed-coloring",level:3},{value:"Shortest Cycle in Undirected Graphs",id:"shortest-cycle-undirected",level:2},{value:"Shortest Cycle in Directed Graphs",id:"shortest-cycle-directed",level:2},{value:"Longest Cycle in Undirected Graphs",id:"longest-cycle-undirected",level:2},{value:"Longest Cycle in Directed Graphs",id:"longest-cycle-directed",level:2},{value:"Summary and Comparison",id:"summary",level:2},{value:"Cycle Detection Algorithms Comparison",id:"cycle-detection-algorithms-comparison",level:3},{value:"Undirected Graphs",id:"undirected-graphs",level:4},{value:"Directed Graphs",id:"directed-graphs",level:4},{value:"Shortest and Longest Cycle Algorithms",id:"shortest-and-longest-cycle-algorithms",level:3},{value:"Key Takeaways",id:"key-takeaways",level:3},{value:"Practice Problems",id:"practice-problems",level:3},{value:"Common Interview Questions",id:"common-interview-questions",level:3},{value:"Additional Resources",id:"additional-resources",level:3},{value:"Complexity Summary Table",id:"complexity-summary-table",level:3}];function o(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"complete-guide-to-graph-cycles",children:"Complete Guide to Graph Cycles"})}),"\n",(0,t.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,t.jsx)(n.h3,{id:"part-1-cycle-detection-techniques",children:"Part 1: Cycle Detection Techniques"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#cycle-detection-intro",children:"Introduction to Cycle Detection"})}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"#cycle-detection-undirected",children:"Cycle Detection in Undirected Graphs"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#undirected-dfs",children:"DFS-based Detection"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#undirected-bfs",children:"BFS-based Detection"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#undirected-union-find",children:"Union-Find (Disjoint Set Union)"})}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"#cycle-detection-directed",children:"Cycle Detection in Directed Graphs"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#directed-dfs",children:"DFS with Recursion Stack"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#directed-topo-sort",children:"BFS with Kahn's Algorithm (Topological Sort)"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#directed-coloring",children:"Graph Coloring (Three-Color Method)"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"part-2-finding-shortest-and-longest-cycles",children:"Part 2: Finding Shortest and Longest Cycles"}),"\n",(0,t.jsxs)(n.ol,{start:"4",children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#shortest-cycle-undirected",children:"Shortest Cycle in Undirected Graphs"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#shortest-cycle-directed",children:"Shortest Cycle in Directed Graphs"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#longest-cycle-undirected",children:"Longest Cycle in Undirected Graphs"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#longest-cycle-directed",children:"Longest Cycle in Directed Graphs"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#summary",children:"Summary and Comparison"})}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h1,{id:"part-1-cycle-detection-techniques-1",children:"Part 1: Cycle Detection Techniques"}),"\n",(0,t.jsx)(n.h2,{id:"cycle-detection-intro",children:"Introduction to Cycle Detection"}),"\n",(0,t.jsx)(n.p,{children:"Cycle detection is fundamental in graph theory with applications in:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Deadlock detection in operating systems"}),"\n",(0,t.jsx)(n.li,{children:"Dependency resolution"}),"\n",(0,t.jsx)(n.li,{children:"Circuit design verification"}),"\n",(0,t.jsx)(n.li,{children:"Detecting infinite loops in state machines"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Key Difference:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Undirected Graphs"}),": A cycle exists if we visit a vertex that's already visited (excluding parent)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Directed Graphs"}),": A cycle exists if we visit a vertex that's in the current recursion stack/path"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"cycle-detection-undirected",children:"Cycle Detection in Undirected Graphs"}),"\n",(0,t.jsx)(n.h3,{id:"undirected-dfs",children:"DFS-based Detection"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Algorithm Overview:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Use DFS traversal"}),"\n",(0,t.jsx)(n.li,{children:"Track visited vertices"}),"\n",(0,t.jsx)(n.li,{children:"If we encounter a visited vertex that's not the parent, cycle exists"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Time Complexity"}),": O(V + E)\n",(0,t.jsx)(n.strong,{children:"Space Complexity"}),": O(V)"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'import java.util.*;\n\nclass CycleDetectionUndirectedDFS {\n    private int vertices;\n    private List<List<Integer>> adjList;\n\n    public CycleDetectionUndirectedDFS(int v) {\n        vertices = v;\n        adjList = new ArrayList<>(v);\n        for (int i = 0; i < v; i++) {\n            adjList.add(new ArrayList<>());\n        }\n    }\n\n    public void addEdge(int u, int v) {\n        adjList.get(u).add(v);\n        adjList.get(v).add(u);\n    }\n\n    private boolean dfsUtil(int v, boolean[] visited, int parent) {\n        visited[v] = true;\n\n        for (int neighbor : adjList.get(v)) {\n            // If neighbor is not visited, recurse\n            if (!visited[neighbor]) {\n                if (dfsUtil(neighbor, visited, v)) {\n                    return true;\n                }\n            }\n            // If visited and not parent, cycle found\n            else if (neighbor != parent) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public boolean hasCycle() {\n        boolean[] visited = new boolean[vertices];\n\n        // Check for all components\n        for (int i = 0; i < vertices; i++) {\n            if (!visited[i]) {\n                if (dfsUtil(i, visited, -1)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        CycleDetectionUndirectedDFS graph = new CycleDetectionUndirectedDFS(5);\n\n        graph.addEdge(0, 1);\n        graph.addEdge(1, 2);\n        graph.addEdge(2, 3);\n        graph.addEdge(3, 4);\n        graph.addEdge(4, 1); // Creates cycle\n\n        System.out.println("Graph has cycle: " + graph.hasCycle());\n    }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Steps:"})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Mark current vertex as visited"}),"\n",(0,t.jsx)(n.li,{children:"Explore all adjacent vertices"}),"\n",(0,t.jsx)(n.li,{children:"If adjacent vertex is visited and not parent \u2192 cycle exists"}),"\n",(0,t.jsx)(n.li,{children:"If adjacent vertex is not visited \u2192 recurse"}),"\n",(0,t.jsx)(n.li,{children:"Check all disconnected components"}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"undirected-bfs",children:"BFS-based Detection"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Algorithm Overview:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Use BFS with parent tracking"}),"\n",(0,t.jsx)(n.li,{children:"Similar logic to DFS but iterative with queue"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Time Complexity"}),": O(V + E)\n",(0,t.jsx)(n.strong,{children:"Space Complexity"}),": O(V)"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'import java.util.*;\n\nclass CycleDetectionUndirectedBFS {\n    private int vertices;\n    private List<List<Integer>> adjList;\n\n    static class Node {\n        int vertex;\n        int parent;\n\n        Node(int v, int p) {\n            vertex = v;\n            parent = p;\n        }\n    }\n\n    public CycleDetectionUndirectedBFS(int v) {\n        vertices = v;\n        adjList = new ArrayList<>(v);\n        for (int i = 0; i < v; i++) {\n            adjList.add(new ArrayList<>());\n        }\n    }\n\n    public void addEdge(int u, int v) {\n        adjList.get(u).add(v);\n        adjList.get(v).add(u);\n    }\n\n    private boolean bfsUtil(int start, boolean[] visited) {\n        Queue<Node> queue = new LinkedList<>();\n        visited[start] = true;\n        queue.add(new Node(start, -1));\n\n        while (!queue.isEmpty()) {\n            Node current = queue.poll();\n            int v = current.vertex;\n            int parent = current.parent;\n\n            for (int neighbor : adjList.get(v)) {\n                if (!visited[neighbor]) {\n                    visited[neighbor] = true;\n                    queue.add(new Node(neighbor, v));\n                } else if (neighbor != parent) {\n                    // Visited neighbor that\'s not parent = cycle\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public boolean hasCycle() {\n        boolean[] visited = new boolean[vertices];\n\n        for (int i = 0; i < vertices; i++) {\n            if (!visited[i]) {\n                if (bfsUtil(i, visited)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        CycleDetectionUndirectedBFS graph = new CycleDetectionUndirectedBFS(4);\n\n        graph.addEdge(0, 1);\n        graph.addEdge(1, 2);\n        graph.addEdge(2, 0); // Creates cycle\n        graph.addEdge(2, 3);\n\n        System.out.println("Graph has cycle: " + graph.hasCycle());\n    }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Steps:"})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Initialize queue with starting vertex and parent -1"}),"\n",(0,t.jsxs)(n.li,{children:["For each vertex in queue:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Check all neighbors"}),"\n",(0,t.jsx)(n.li,{children:"If neighbor is visited and not parent \u2192 cycle"}),"\n",(0,t.jsx)(n.li,{children:"If neighbor is unvisited \u2192 add to queue with current as parent"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:"Process all components"}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"undirected-union-find",children:"Union-Find (Disjoint Set Union)"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Algorithm Overview:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Initially, each vertex is in its own set"}),"\n",(0,t.jsxs)(n.li,{children:["For each edge (u, v):","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"If u and v are already in same set \u2192 cycle exists"}),"\n",(0,t.jsx)(n.li,{children:"Otherwise, union the sets"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Time Complexity"}),": O(E \xd7 \u03b1(V)) \u2248 O(E) with path compression\n",(0,t.jsx)(n.strong,{children:"Space Complexity"}),": O(V)"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'import java.util.*;\n\nclass CycleDetectionUnionFind {\n    private int vertices;\n    private List<int[]> edges;\n    private int[] parent;\n    private int[] rank;\n\n    public CycleDetectionUnionFind(int v) {\n        vertices = v;\n        edges = new ArrayList<>();\n        parent = new int[v];\n        rank = new int[v];\n\n        // Initialize each vertex as its own parent\n        for (int i = 0; i < v; i++) {\n            parent[i] = i;\n            rank[i] = 0;\n        }\n    }\n\n    public void addEdge(int u, int v) {\n        edges.add(new int[]{u, v});\n    }\n\n    // Find with path compression\n    private int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]); // Path compression\n        }\n        return parent[x];\n    }\n\n    // Union by rank\n    private void union(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n\n        if (rootX != rootY) {\n            if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n        }\n    }\n\n    public boolean hasCycle() {\n        for (int[] edge : edges) {\n            int u = edge[0];\n            int v = edge[1];\n\n            int setU = find(u);\n            int setV = find(v);\n\n            // If both endpoints are in same set, cycle exists\n            if (setU == setV) {\n                return true;\n            }\n\n            // Otherwise, union the sets\n            union(setU, setV);\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        CycleDetectionUnionFind graph = new CycleDetectionUnionFind(4);\n\n        graph.addEdge(0, 1);\n        graph.addEdge(1, 2);\n        graph.addEdge(0, 2); // Creates cycle\n\n        System.out.println("Graph has cycle: " + graph.hasCycle());\n    }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Steps:"})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Initialize DSU with each vertex as separate set"}),"\n",(0,t.jsxs)(n.li,{children:["For each edge (u, v):","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Find root of u and v"}),"\n",(0,t.jsx)(n.li,{children:"If roots are same \u2192 cycle detected"}),"\n",(0,t.jsx)(n.li,{children:"If roots are different \u2192 perform union"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:"Return whether cycle was found"}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"cycle-detection-directed",children:"Cycle Detection in Directed Graphs"}),"\n",(0,t.jsx)(n.h3,{id:"directed-dfs",children:"DFS with Recursion Stack"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Algorithm Overview:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Use DFS with recursion stack tracking"}),"\n",(0,t.jsx)(n.li,{children:"A cycle exists if we visit a vertex that's in the current recursion stack"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Time Complexity"}),": O(V + E)\n",(0,t.jsx)(n.strong,{children:"Space Complexity"}),": O(V)"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'import java.util.*;\n\nclass CycleDetectionDirectedDFS {\n    private int vertices;\n    private List<List<Integer>> adjList;\n\n    public CycleDetectionDirectedDFS(int v) {\n        vertices = v;\n        adjList = new ArrayList<>(v);\n        for (int i = 0; i < v; i++) {\n            adjList.add(new ArrayList<>());\n        }\n    }\n\n    public void addEdge(int u, int v) {\n        adjList.get(u).add(v);\n    }\n\n    private boolean dfsUtil(int v, boolean[] visited, boolean[] recStack) {\n        visited[v] = true;\n        recStack[v] = true;\n\n        for (int neighbor : adjList.get(v)) {\n            // If neighbor not visited, recurse\n            if (!visited[neighbor]) {\n                if (dfsUtil(neighbor, visited, recStack)) {\n                    return true;\n                }\n            }\n            // If neighbor is in recursion stack, cycle found\n            else if (recStack[neighbor]) {\n                return true;\n            }\n        }\n\n        // Remove from recursion stack before returning\n        recStack[v] = false;\n        return false;\n    }\n\n    public boolean hasCycle() {\n        boolean[] visited = new boolean[vertices];\n        boolean[] recStack = new boolean[vertices];\n\n        // Check all vertices (for disconnected components)\n        for (int i = 0; i < vertices; i++) {\n            if (!visited[i]) {\n                if (dfsUtil(i, visited, recStack)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        CycleDetectionDirectedDFS graph = new CycleDetectionDirectedDFS(4);\n\n        graph.addEdge(0, 1);\n        graph.addEdge(1, 2);\n        graph.addEdge(2, 3);\n        graph.addEdge(3, 1); // Creates cycle\n\n        System.out.println("Graph has cycle: " + graph.hasCycle());\n    }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Steps:"})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Maintain two arrays: visited and recursion stack"}),"\n",(0,t.jsx)(n.li,{children:"Mark current vertex as visited and in recursion stack"}),"\n",(0,t.jsxs)(n.li,{children:["For each neighbor:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"If unvisited \u2192 recurse"}),"\n",(0,t.jsx)(n.li,{children:"If in recursion stack \u2192 cycle exists"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:"Remove from recursion stack before backtracking"}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"directed-topo-sort",children:"BFS with Kahn's Algorithm (Topological Sort)"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Algorithm Overview:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Calculate in-degree for all vertices"}),"\n",(0,t.jsx)(n.li,{children:"Process vertices with in-degree 0"}),"\n",(0,t.jsx)(n.li,{children:"If we can't process all vertices \u2192 cycle exists"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Time Complexity"}),": O(V + E)\n",(0,t.jsx)(n.strong,{children:"Space Complexity"}),": O(V)"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'import java.util.*;\n\nclass CycleDetectionKahnAlgorithm {\n    private int vertices;\n    private List<List<Integer>> adjList;\n\n    public CycleDetectionKahnAlgorithm(int v) {\n        vertices = v;\n        adjList = new ArrayList<>(v);\n        for (int i = 0; i < v; i++) {\n            adjList.add(new ArrayList<>());\n        }\n    }\n\n    public void addEdge(int u, int v) {\n        adjList.get(u).add(v);\n    }\n\n    public boolean hasCycle() {\n        int[] inDegree = new int[vertices];\n\n        // Calculate in-degree for all vertices\n        for (int i = 0; i < vertices; i++) {\n            for (int neighbor : adjList.get(i)) {\n                inDegree[neighbor]++;\n            }\n        }\n\n        // Queue for vertices with in-degree 0\n        Queue<Integer> queue = new LinkedList<>();\n        for (int i = 0; i < vertices; i++) {\n            if (inDegree[i] == 0) {\n                queue.add(i);\n            }\n        }\n\n        int processedCount = 0;\n\n        while (!queue.isEmpty()) {\n            int v = queue.poll();\n            processedCount++;\n\n            // Reduce in-degree of neighbors\n            for (int neighbor : adjList.get(v)) {\n                inDegree[neighbor]--;\n                if (inDegree[neighbor] == 0) {\n                    queue.add(neighbor);\n                }\n            }\n        }\n\n        // If we couldn\'t process all vertices, cycle exists\n        return processedCount != vertices;\n    }\n\n    public List<Integer> topologicalSort() {\n        int[] inDegree = new int[vertices];\n        List<Integer> result = new ArrayList<>();\n\n        for (int i = 0; i < vertices; i++) {\n            for (int neighbor : adjList.get(i)) {\n                inDegree[neighbor]++;\n            }\n        }\n\n        Queue<Integer> queue = new LinkedList<>();\n        for (int i = 0; i < vertices; i++) {\n            if (inDegree[i] == 0) {\n                queue.add(i);\n            }\n        }\n\n        while (!queue.isEmpty()) {\n            int v = queue.poll();\n            result.add(v);\n\n            for (int neighbor : adjList.get(v)) {\n                inDegree[neighbor]--;\n                if (inDegree[neighbor] == 0) {\n                    queue.add(neighbor);\n                }\n            }\n        }\n\n        // If result size != vertices, cycle exists\n        return result.size() == vertices ? result : null;\n    }\n\n    public static void main(String[] args) {\n        CycleDetectionKahnAlgorithm graph = new CycleDetectionKahnAlgorithm(6);\n\n        graph.addEdge(5, 2);\n        graph.addEdge(5, 0);\n        graph.addEdge(4, 0);\n        graph.addEdge(4, 1);\n        graph.addEdge(2, 3);\n        graph.addEdge(3, 1);\n\n        System.out.println("Graph has cycle: " + graph.hasCycle());\n        System.out.println("Topological order: " + graph.topologicalSort());\n\n        // Add cycle\n        graph.addEdge(1, 4);\n        System.out.println("\\nAfter adding cycle:");\n        System.out.println("Graph has cycle: " + graph.hasCycle());\n    }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Steps:"})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Calculate in-degree for all vertices"}),"\n",(0,t.jsx)(n.li,{children:"Add all vertices with in-degree 0 to queue"}),"\n",(0,t.jsxs)(n.li,{children:["Process queue:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Remove vertex from queue"}),"\n",(0,t.jsx)(n.li,{children:"Decrease in-degree of neighbors"}),"\n",(0,t.jsx)(n.li,{children:"Add neighbors with in-degree 0 to queue"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:"If processed count < total vertices \u2192 cycle exists"}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"directed-coloring",children:"Graph Coloring (Three-Color Method)"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Algorithm Overview:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Use three colors: WHITE (unvisited), GRAY (in progress), BLACK (finished)"}),"\n",(0,t.jsx)(n.li,{children:"If we encounter a GRAY vertex \u2192 cycle exists"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Time Complexity"}),": O(V + E)\n",(0,t.jsx)(n.strong,{children:"Space Complexity"}),": O(V)"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'import java.util.*;\n\nclass CycleDetectionGraphColoring {\n    private int vertices;\n    private List<List<Integer>> adjList;\n\n    enum Color {\n        WHITE,  // Unvisited\n        GRAY,   // In progress (in recursion stack)\n        BLACK   // Finished\n    }\n\n    public CycleDetectionGraphColoring(int v) {\n        vertices = v;\n        adjList = new ArrayList<>(v);\n        for (int i = 0; i < v; i++) {\n            adjList.add(new ArrayList<>());\n        }\n    }\n\n    public void addEdge(int u, int v) {\n        adjList.get(u).add(v);\n    }\n\n    private boolean dfsUtil(int v, Color[] color) {\n        color[v] = Color.GRAY;\n\n        for (int neighbor : adjList.get(v)) {\n            // If neighbor is GRAY, cycle found\n            if (color[neighbor] == Color.GRAY) {\n                return true;\n            }\n\n            // If neighbor is WHITE, recurse\n            if (color[neighbor] == Color.WHITE) {\n                if (dfsUtil(neighbor, color)) {\n                    return true;\n                }\n            }\n\n            // If neighbor is BLACK, do nothing (already processed)\n        }\n\n        color[v] = Color.BLACK;\n        return false;\n    }\n\n    public boolean hasCycle() {\n        Color[] color = new Color[vertices];\n        Arrays.fill(color, Color.WHITE);\n\n        for (int i = 0; i < vertices; i++) {\n            if (color[i] == Color.WHITE) {\n                if (dfsUtil(i, color)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        CycleDetectionGraphColoring graph = new CycleDetectionGraphColoring(4);\n\n        graph.addEdge(0, 1);\n        graph.addEdge(1, 2);\n        graph.addEdge(2, 0); // Creates cycle\n        graph.addEdge(2, 3);\n\n        System.out.println("Graph has cycle: " + graph.hasCycle());\n    }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Steps:"})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Initialize all vertices as WHITE"}),"\n",(0,t.jsxs)(n.li,{children:["For each WHITE vertex, start DFS:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Mark vertex as GRAY (in progress)"}),"\n",(0,t.jsxs)(n.li,{children:["For each neighbor:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"If GRAY \u2192 cycle exists"}),"\n",(0,t.jsx)(n.li,{children:"If WHITE \u2192 recurse"}),"\n",(0,t.jsx)(n.li,{children:"If BLACK \u2192 skip (already processed)"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:"Mark vertex as BLACK (finished)"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h1,{id:"part-2-finding-shortest-and-longest-cycles-1",children:"Part 2: Finding Shortest and Longest Cycles"}),"\n",(0,t.jsx)(n.h2,{id:"shortest-cycle-undirected",children:"Shortest Cycle in Undirected Graphs"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Algorithm"}),": BFS from each vertex to find girth (shortest cycle)"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Time Complexity"}),": O(V \xd7 (V + E))"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'import java.util.*;\n\nclass ShortestCycleUndirected {\n    private int vertices;\n    private List<List<Integer>> adjList;\n\n    public ShortestCycleUndirected(int v) {\n        vertices = v;\n        adjList = new ArrayList<>(v);\n        for (int i = 0; i < v; i++) {\n            adjList.add(new ArrayList<>());\n        }\n    }\n\n    public void addEdge(int u, int v) {\n        adjList.get(u).add(v);\n        adjList.get(v).add(u);\n    }\n\n    public int findShortestCycle() {\n        int minCycle = Integer.MAX_VALUE;\n\n        // Try BFS from each vertex\n        for (int src = 0; src < vertices; src++) {\n            int[] dist = new int[vertices];\n            int[] parent = new int[vertices];\n            Arrays.fill(dist, -1);\n            Arrays.fill(parent, -1);\n\n            Queue<Integer> queue = new LinkedList<>();\n            dist[src] = 0;\n            queue.add(src);\n\n            while (!queue.isEmpty()) {\n                int u = queue.poll();\n\n                for (int v : adjList.get(u)) {\n                    if (dist[v] == -1) {\n                        dist[v] = dist[u] + 1;\n                        parent[v] = u;\n                        queue.add(v);\n                    } else if (parent[u] != v) {\n                        minCycle = Math.min(minCycle, dist[u] + dist[v] + 1);\n                    }\n                }\n            }\n        }\n\n        return minCycle == Integer.MAX_VALUE ? -1 : minCycle;\n    }\n\n    public static void main(String[] args) {\n        ShortestCycleUndirected graph = new ShortestCycleUndirected(7);\n\n        graph.addEdge(0, 1);\n        graph.addEdge(1, 2);\n        graph.addEdge(2, 3);\n        graph.addEdge(3, 0);\n        graph.addEdge(3, 4);\n        graph.addEdge(4, 5);\n        graph.addEdge(5, 6);\n        graph.addEdge(6, 3);\n\n        int result = graph.findShortestCycle();\n        System.out.println("Shortest cycle length: " + result);\n    }\n}\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"shortest-cycle-directed",children:"Shortest Cycle in Directed Graphs"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Algorithm"}),": BFS from each vertex to find shortest path back to itself"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Time Complexity"}),": O(V \xd7 (V + E))"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'import java.util.*;\n\nclass ShortestCycleDirected {\n    private int vertices;\n    private List<List<Integer>> adjList;\n\n    public ShortestCycleDirected(int v) {\n        vertices = v;\n        adjList = new ArrayList<>(v);\n        for (int i = 0; i < v; i++) {\n            adjList.add(new ArrayList<>());\n        }\n    }\n\n    public void addEdge(int u, int v) {\n        adjList.get(u).add(v);\n    }\n\n    public int findShortestCycle() {\n        int minCycle = Integer.MAX_VALUE;\n\n        for (int src = 0; src < vertices; src++) {\n            int[] dist = new int[vertices];\n            Arrays.fill(dist, Integer.MAX_VALUE);\n            dist[src] = 0;\n\n            Queue<Integer> queue = new LinkedList<>();\n            queue.add(src);\n            boolean first = true;\n\n            while (!queue.isEmpty()) {\n                int u = queue.poll();\n\n                for (int v : adjList.get(u)) {\n                    if (v == src && !first) {\n                        minCycle = Math.min(minCycle, dist[u] + 1);\n                    } else if (dist[v] == Integer.MAX_VALUE) {\n                        dist[v] = dist[u] + 1;\n                        queue.add(v);\n                    }\n                }\n                first = false;\n            }\n        }\n\n        return minCycle == Integer.MAX_VALUE ? -1 : minCycle;\n    }\n\n    public static void main(String[] args) {\n        ShortestCycleDirected graph = new ShortestCycleDirected(4);\n\n        graph.addEdge(0, 1);\n        graph.addEdge(1, 2);\n        graph.addEdge(2, 3);\n        graph.addEdge(3, 0);\n        graph.addEdge(1, 3);\n\n        int result = graph.findShortestCycle();\n        System.out.println("Shortest cycle length: " + result);\n    }\n}\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"longest-cycle-undirected",children:"Longest Cycle in Undirected Graphs"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Algorithm"}),": Backtracking with DFS (NP-Hard)"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Time Complexity"}),": O(V!) - Exponential"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'import java.util.*;\n\nclass LongestCycleUndirected {\n    private int vertices;\n    private List<List<Integer>> adjList;\n    private int maxCycleLength;\n    private List<Integer> longestCycle;\n\n    public LongestCycleUndirected(int v) {\n        vertices = v;\n        adjList = new ArrayList<>(v);\n        for (int i = 0; i < v; i++) {\n            adjList.add(new ArrayList<>());\n        }\n        maxCycleLength = 0;\n        longestCycle = new ArrayList<>();\n    }\n\n    public void addEdge(int u, int v) {\n        adjList.get(u).add(v);\n        adjList.get(v).add(u);\n    }\n\n    private void dfs(int current, int start, boolean[] visited,\n                     List<Integer> path, int parent) {\n        visited[current] = true;\n        path.add(current);\n\n        for (int neighbor : adjList.get(current)) {\n            if (!visited[neighbor]) {\n                dfs(neighbor, start, visited, path, current);\n            } else if (neighbor == start && path.size() > 2 && neighbor != parent) {\n                if (path.size() > maxCycleLength) {\n                    maxCycleLength = path.size();\n                    longestCycle = new ArrayList<>(path);\n                }\n            }\n        }\n\n        path.remove(path.size() - 1);\n        visited[current] = false;\n    }\n\n    public int findLongestCycle() {\n        for (int i = 0; i < vertices; i++) {\n            boolean[] visited = new boolean[vertices];\n            List<Integer> path = new ArrayList<>();\n            dfs(i, i, visited, path, -1);\n        }\n\n        return maxCycleLength;\n    }\n\n    public List<Integer> getLongestCycle() {\n        return longestCycle;\n    }\n\n    public static void main(String[] args) {\n        LongestCycleUndirected graph = new LongestCycleUndirected(6);\n\n        graph.addEdge(0, 1);\n        graph.addEdge(1, 2);\n        graph.addEdge(2, 3);\n        graph.addEdge(3, 4);\n        graph.addEdge(4, 5);\n        graph.addEdge(5, 0);\n        graph.addEdge(1, 5);\n        graph.addEdge(2, 4);\n\n        int result = graph.findLongestCycle();\n        System.out.println("Longest cycle length: " + result);\n        System.out.println("Longest cycle: " + graph.getLongestCycle());\n    }\n}\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"longest-cycle-directed",children:"Longest Cycle in Directed Graphs"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Algorithm"}),": Backtracking with DFS (NP-Hard)"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Time Complexity"}),": O(V!) - Exponential"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'import java.util.*;\n\nclass LongestCycleDirected {\n    private int vertices;\n    private List<List<Integer>> adjList;\n    private int maxCycleLength;\n    private List<Integer> longestCycle;\n\n    public LongestCycleDirected(int v) {\n        vertices = v;\n        adjList = new ArrayList<>(v);\n        for (int i = 0; i < v; i++) {\n            adjList.add(new ArrayList<>());\n        }\n        maxCycleLength = 0;\n        longestCycle = new ArrayList<>();\n    }\n\n    public void addEdge(int u, int v) {\n        adjList.get(u).add(v);\n    }\n\n    private void dfs(int current, int start, boolean[] visited,\n                     List<Integer> path, Map<Integer, Integer> pathIndex) {\n        visited[current] = true;\n        pathIndex.put(current, path.size());\n        path.add(current);\n\n        for (int neighbor : adjList.get(current)) {\n            if (!visited[neighbor]) {\n                dfs(neighbor, start, visited, path, pathIndex);\n            } else if (pathIndex.containsKey(neighbor)) {\n                int cycleStart = pathIndex.get(neighbor);\n                int cycleLength = path.size() - cycleStart;\n\n                if (cycleLength > maxCycleLength) {\n                    maxCycleLength = cycleLength;\n                    longestCycle = new ArrayList<>(path.subList(cycleStart, path.size()));\n                }\n            }\n        }\n\n        path.remove(path.size() - 1);\n        pathIndex.remove(current);\n        visited[current] = false;\n    }\n\n    public int findLongestCycle() {\n        for (int i = 0; i < vertices; i++) {\n            boolean[] visited = new boolean[vertices];\n            List<Integer> path = new ArrayList<>();\n            Map<Integer, Integer> pathIndex = new HashMap<>();\n            dfs(i, i, visited, path, pathIndex);\n        }\n\n        return maxCycleLength;\n    }\n\n    public List<Integer> getLongestCycle() {\n        return longestCycle;\n    }\n\n    public static void main(String[] args) {\n        LongestCycleDirected graph = new LongestCycleDirected(6);\n\n        graph.addEdge(0, 1);\n        graph.addEdge(1, 2);\n        graph.addEdge(2, 3);\n        graph.addEdge(3, 4);\n        graph.addEdge(4, 5);\n        graph.addEdge(5, 0);\n        graph.addEdge(2, 0);\n        graph.addEdge(3, 1);\n\n        int result = graph.findLongestCycle();\n        System.out.println("Longest cycle length: " + result);\n        System.out.println("Longest cycle: " + graph.getLongestCycle());\n    }\n}\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"summary",children:"Summary and Comparison"}),"\n",(0,t.jsx)(n.h3,{id:"cycle-detection-algorithms-comparison",children:"Cycle Detection Algorithms Comparison"}),"\n",(0,t.jsx)(n.h4,{id:"undirected-graphs",children:"Undirected Graphs"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Algorithm"}),(0,t.jsx)(n.th,{children:"Time Complexity"}),(0,t.jsx)(n.th,{children:"Space Complexity"}),(0,t.jsx)(n.th,{children:"Best Use Case"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"DFS"}),(0,t.jsx)(n.td,{children:"O(V + E)"}),(0,t.jsx)(n.td,{children:"O(V)"}),(0,t.jsx)(n.td,{children:"Most intuitive, good for finding any cycle"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"BFS"}),(0,t.jsx)(n.td,{children:"O(V + E)"}),(0,t.jsx)(n.td,{children:"O(V)"}),(0,t.jsx)(n.td,{children:"Level-by-level traversal needed"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Union-Find"}),(0,t.jsx)(n.td,{children:"O(E \xd7 \u03b1(V))"}),(0,t.jsx)(n.td,{children:"O(V)"}),(0,t.jsx)(n.td,{children:"Edge list representation, incremental edge addition"})]})]})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Recommendation"}),": DFS is typically preferred for its simplicity and efficiency."]}),"\n",(0,t.jsx)(n.h4,{id:"directed-graphs",children:"Directed Graphs"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Algorithm"}),(0,t.jsx)(n.th,{children:"Time Complexity"}),(0,t.jsx)(n.th,{children:"Space Complexity"}),(0,t.jsx)(n.th,{children:"Best Use Case"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"DFS with Recursion Stack"}),(0,t.jsx)(n.td,{children:"O(V + E)"}),(0,t.jsx)(n.td,{children:"O(V)"}),(0,t.jsx)(n.td,{children:"Most common, intuitive approach"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Kahn's Algorithm"}),(0,t.jsx)(n.td,{children:"O(V + E)"}),(0,t.jsx)(n.td,{children:"O(V)"}),(0,t.jsx)(n.td,{children:"Also need topological sort"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Graph Coloring"}),(0,t.jsx)(n.td,{children:"O(V + E)"}),(0,t.jsx)(n.td,{children:"O(V)"}),(0,t.jsx)(n.td,{children:"Clear state visualization"})]})]})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Recommendation"}),": DFS with recursion stack is the most commonly used approach."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"shortest-and-longest-cycle-algorithms",children:"Shortest and Longest Cycle Algorithms"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Problem"}),(0,t.jsx)(n.th,{children:"Graph Type"}),(0,t.jsx)(n.th,{children:"Time Complexity"}),(0,t.jsx)(n.th,{children:"Difficulty"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Shortest Cycle"}),(0,t.jsx)(n.td,{children:"Undirected"}),(0,t.jsx)(n.td,{children:"O(V \xd7 (V + E))"}),(0,t.jsx)(n.td,{children:"Polynomial"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Shortest Cycle"}),(0,t.jsx)(n.td,{children:"Directed"}),(0,t.jsx)(n.td,{children:"O(V \xd7 (V + E))"}),(0,t.jsx)(n.td,{children:"Polynomial"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Longest Cycle"}),(0,t.jsx)(n.td,{children:"Undirected"}),(0,t.jsx)(n.td,{children:"O(V!)"}),(0,t.jsx)(n.td,{children:"NP-Hard"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Longest Cycle"}),(0,t.jsx)(n.td,{children:"Directed"}),(0,t.jsx)(n.td,{children:"O(V!)"}),(0,t.jsx)(n.td,{children:"NP-Hard"})]})]})]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Cycle Detection"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Undirected: Check if visited neighbor is not parent"}),"\n",(0,t.jsx)(n.li,{children:"Directed: Check if neighbor is in current recursion stack"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Shortest Cycle"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Use BFS from each vertex"}),"\n",(0,t.jsx)(n.li,{children:"For undirected: detect cross-edges"}),"\n",(0,t.jsx)(n.li,{children:"For directed: find shortest path back to source"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Longest Cycle"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"NP-Hard problem"}),"\n",(0,t.jsx)(n.li,{children:"Requires backtracking/exhaustive search"}),"\n",(0,t.jsx)(n.li,{children:"Not practical for large graphs"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Choosing the Right Algorithm"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"For simple cycle detection: Use DFS"}),"\n",(0,t.jsx)(n.li,{children:"For topological sort + cycle detection: Use Kahn's algorithm"}),"\n",(0,t.jsx)(n.li,{children:"For incremental edge addition: Use Union-Find"}),"\n",(0,t.jsx)(n.li,{children:"For shortest cycle: Use BFS from each vertex"}),"\n",(0,t.jsx)(n.li,{children:"For longest cycle: Use backtracking (small graphs only)"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"practice-problems",children:"Practice Problems"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Easy"}),":"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Detect if a graph has a cycle"}),"\n",(0,t.jsx)(n.li,{children:"Find if a directed graph is a DAG (Directed Acyclic Graph)"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Medium"}),":"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Find the shortest cycle in an undirected graph"}),"\n",(0,t.jsx)(n.li,{children:"Count the number of cycles in a graph"}),"\n",(0,t.jsx)(n.li,{children:"Find all vertices that are part of at least one cycle"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Hard"}),":"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Find the longest cycle in a small graph"}),"\n",(0,t.jsx)(n.li,{children:"Find all simple cycles in a directed graph"}),"\n",(0,t.jsx)(n.li,{children:"Find the minimum spanning tree avoiding cycles (Kruskal's/Prim's)"}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"common-interview-questions",children:"Common Interview Questions"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:'"How do you detect a cycle in a linked list?"'})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Use Floyd's cycle detection (fast and slow pointers)"}),"\n",(0,t.jsx)(n.li,{children:"Related to graph cycle detection concepts"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:'"How do you detect a cycle in a dependency graph?"'})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Use DFS with recursion stack on directed graph"}),"\n",(0,t.jsx)(n.li,{children:"Application: build systems, package managers"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:'"How do you find if a course schedule is possible?"'})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Use topological sort (Kahn's algorithm)"}),"\n",(0,t.jsx)(n.li,{children:"If cycle exists, schedule is impossible"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:'"How do you detect deadlock in an operating system?"'})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Model as directed graph (resource allocation graph)"}),"\n",(0,t.jsx)(n.li,{children:"Cycle indicates potential deadlock"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"additional-resources",children:"Additional Resources"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Topics to Explore Next"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Strongly Connected Components (Tarjan's/Kosaraju's algorithms)"}),"\n",(0,t.jsx)(n.li,{children:"Eulerian and Hamiltonian Cycles"}),"\n",(0,t.jsx)(n.li,{children:"Minimum Cycle Basis"}),"\n",(0,t.jsx)(n.li,{children:"Cycle space in graph theory"}),"\n",(0,t.jsx)(n.li,{children:"Applications in network flow problems"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Related Algorithms"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Floyd-Warshall (all-pairs shortest paths)"}),"\n",(0,t.jsx)(n.li,{children:"Bellman-Ford (negative cycle detection)"}),"\n",(0,t.jsx)(n.li,{children:"Tarjan's algorithm (finding bridges and articulation points)"}),"\n",(0,t.jsx)(n.li,{children:"Johnson's algorithm (all-pairs shortest paths with negative edges)"}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"complexity-summary-table",children:"Complexity Summary Table"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Operation"}),(0,t.jsx)(n.th,{children:"Best Algorithm"}),(0,t.jsx)(n.th,{children:"Time"}),(0,t.jsx)(n.th,{children:"Space"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Detect cycle (undirected)"}),(0,t.jsx)(n.td,{children:"DFS"}),(0,t.jsx)(n.td,{children:"O(V + E)"}),(0,t.jsx)(n.td,{children:"O(V)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Detect cycle (directed)"}),(0,t.jsx)(n.td,{children:"DFS + Rec Stack"}),(0,t.jsx)(n.td,{children:"O(V + E)"}),(0,t.jsx)(n.td,{children:"O(V)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Shortest cycle (undirected)"}),(0,t.jsx)(n.td,{children:"BFS from each vertex"}),(0,t.jsx)(n.td,{children:"O(V(V + E))"}),(0,t.jsx)(n.td,{children:"O(V)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Shortest cycle (directed)"}),(0,t.jsx)(n.td,{children:"BFS from each vertex"}),(0,t.jsx)(n.td,{children:"O(V(V + E))"}),(0,t.jsx)(n.td,{children:"O(V)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Longest cycle"}),(0,t.jsx)(n.td,{children:"Backtracking DFS"}),(0,t.jsx)(n.td,{children:"O(V!)"}),(0,t.jsx)(n.td,{children:"O(V)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Topological sort + cycle"}),(0,t.jsx)(n.td,{children:"Kahn's algorithm"}),(0,t.jsx)(n.td,{children:"O(V + E)"}),(0,t.jsx)(n.td,{children:"O(V)"})]})]})]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}}}]);