"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[495],{9898:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>l,metadata:()=>o,toc:()=>a});var s=i(4848),t=i(8453);const l={title:"Dynamic Programming"},r=void 0,o={id:"DSA/DSA with JavaScript/DynamicProgramming",title:"Dynamic Programming",description:"Dynamic Programming (DP) is a technique used for solving complex problems by breaking them down into simpler overlapping subproblems. It involves storing the results of these subproblems to avoid redundant computations. There are two main approaches to implementing DP: Top-Down and Bottom-Up.",source:"@site/docs/DSA/DSA with JavaScript/DynamicProgramming.mdx",sourceDirName:"DSA/DSA with JavaScript",slug:"/DSA/DSA with JavaScript/DynamicProgramming",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/DynamicProgramming",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with JavaScript/DynamicProgramming.mdx",tags:[],version:"current",frontMatter:{title:"Dynamic Programming"},sidebar:"tutorialSidebar",previous:{title:"Dutch National Flag Algorithm",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/DutchNationalFlag"},next:{title:"Euclid's Algorithm for Greatest Common Divisor (GCD)",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/Euclid"}},c={},a=[{value:"Top-Down Approach (Memoization)",id:"top-down-approach-memoization",level:2},{value:"Steps",id:"steps",level:3},{value:"Example: Fibonacci Numbers",id:"example-fibonacci-numbers",level:3},{value:"Bottom-Up Approach (Tabulation)",id:"bottom-up-approach-tabulation",level:2},{value:"Steps",id:"steps-1",level:2},{value:"Initialization",id:"initialization",level:2},{value:"Fibonacci Style",id:"fibonacci-style",level:2},{value:"Matrix",id:"matrix",level:2},{value:"On Strings",id:"on-strings",level:2},{value:"Longest Increasing Subsequence",id:"longest-increasing-subsequence",level:2},{value:"Longest Common Subsequence",id:"longest-common-subsequence",level:2},{value:"Best Time to Buy &amp; Sell Stock / State Machine",id:"best-time-to-buy--sell-stock--state-machine",level:2},{value:"On Trees",id:"on-trees",level:2},{value:"Knapsack",id:"knapsack",level:2},{value:"General 1D",id:"general-1d",level:2},{value:"2D Grid DP Problems",id:"2d-grid-dp-problems",level:2},{value:"3D Grid DP Problems",id:"3d-grid-dp-problems",level:2},{value:"0/1 Knapsack Problem",id:"01-knapsack-problem",level:2},{value:"Constraint",id:"constraint",level:3},{value:"Objective",id:"objective",level:3},{value:"Decision",id:"decision",level:3},{value:"Approach",id:"approach",level:3},{value:"Recurrence Relation",id:"recurrence-relation",level:3},{value:"0/1 Knapsack Fractional Weight",id:"01-knapsack-fractional-weight",level:3},{value:"Unbounded Knapsack Problem",id:"unbounded-knapsack-problem",level:2},{value:"Constraint",id:"constraint-1",level:3},{value:"Objective",id:"objective-1",level:3},{value:"Decision",id:"decision-1",level:3},{value:"Approach",id:"approach-1",level:3},{value:"Recurrence Relation",id:"recurrence-relation-1",level:3},{value:"Key Differences",id:"key-differences",level:2},{value:"Item Usage",id:"item-usage",level:3},{value:"State Representation",id:"state-representation",level:3},{value:"Complexity",id:"complexity",level:3},{value:"Example",id:"example",level:2},{value:"0/1 Knapsack Problems",id:"01-knapsack-problems",level:2},{value:"Unbounded Knapsack Problems",id:"unbounded-knapsack-problems",level:2},{value:"Longest Decreasing Subsequence",id:"longest-decreasing-subsequence",level:3},{value:"Longest Increasing Subsequence in a 2D Matrix",id:"longest-increasing-subsequence-in-a-2d-matrix",level:3},{value:"Longest Bitonic Subsequence",id:"longest-bitonic-subsequence",level:3}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Dynamic Programming (DP) is a technique used for solving complex problems by breaking them down into simpler overlapping subproblems. It involves storing the results of these subproblems to avoid redundant computations. There are two main approaches to implementing DP: ",(0,s.jsx)(n.strong,{children:"Top-Down"})," and ",(0,s.jsx)(n.strong,{children:"Bottom-Up"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"top-down-approach-memoization",children:"Top-Down Approach (Memoization)"}),"\n",(0,s.jsxs)(n.p,{children:["In the ",(0,s.jsx)(n.strong,{children:"Top-Down"})," approach, also known as ",(0,s.jsx)(n.strong,{children:"Memoization"}),", the problem is solved by recursively breaking it down into subproblems. Each subproblem's result is stored in a data structure (like an array or hash map) to avoid redundant calculations."]}),"\n",(0,s.jsx)(n.h3,{id:"steps",children:"Steps"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Recursive Definition"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Define the problem recursively in terms of smaller subproblems."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Memoization"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Use a data structure (memoization table) to store the results of subproblems."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Recursion"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Solve the problem by making recursive calls and using the memoized results."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"example-fibonacci-numbers",children:"Example: Fibonacci Numbers"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"function fibonacci(n, memo = {}) {\n  if (n in memo) return memo[n];\n  if (n <= 1) return n;\n  memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n  return memo[n];\n}\n\n// Example usage\nconsole.log(fibonacci(10)); // Output: 55\n"})}),"\n",(0,s.jsx)(n.h2,{id:"bottom-up-approach-tabulation",children:"Bottom-Up Approach (Tabulation)"}),"\n",(0,s.jsxs)(n.p,{children:["In the ",(0,s.jsx)(n.strong,{children:"Bottom-Up approach"}),", also known as Tabulation, the problem is solved by iteratively building up solutions to subproblems starting from the smallest subproblems. Results are stored in a table to build up the final solution."]}),"\n",(0,s.jsx)(n.h2,{id:"steps-1",children:"Steps"}),"\n",(0,s.jsx)(n.h2,{id:"initialization",children:"Initialization"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Initialize a table to store solutions to subproblems.\nIteration:"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Solve smaller subproblems iteratively and store their results in the table.\nBuild Solution:"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Use the results of smaller subproblems to build up the solution to the larger problem.\nExample: Fibonacci Numbers"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-JavaScript",children:"function fibonacci(n) {\n  if (n <= 1) return n;\n  const dp = new Array(n + 1);\n  dp[0] = 0;\n  dp[1] = 1;\n\n  for (let i = 2; i <= n; i++) {\n    dp[i] = dp[i - 1] + dp[i - 2];\n  }\n\n  return dp[n];\n}\n\n// Example usage\nconsole.log(fibonacci(10)); // Output: 55\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h1,{id:"dynamic-programming-problems",children:"Dynamic Programming Problems"}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"fibonacci-style",children:"Fibonacci Style"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/climbing-stairs/",children:"Climbing Stairs"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/fibonacci-number/",children:"Fibonacci Number"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/n-th-tribonacci-number/",children:"Nth Tribonacci Number"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/min-cost-climbing-stairs/",children:"Min Cost Climbing Stairs"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/house-robber/",children:"House Robber"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/delete-and-earn/",children:"Delete and Earn"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://www.geeksforgeeks.org/problems/geek-jump/0",children:"Geek Jump (GeeksforGeeks)"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"matrix",children:"Matrix"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/unique-paths/",children:"Unique Paths"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/minimum-path-sum/",children:"Minimum Path Sum"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/unique-paths-ii/",children:"Unique Paths II"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/triangle/",children:"Triangle"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/minimum-falling-path-sum/",children:"Minimum Falling Path Sum"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/maximal-square/",children:"Maximal Square"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"on-strings",children:"On Strings"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/longest-palindromic-substring/",children:"Longest Palindromic Substring"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/word-break/description",children:"Word Break"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/longest-palindromic-subsequence/",children:"Longest Palindromic Subsequence"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/edit-distance/description",children:"Edit Distance"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/",children:"Minimum ASCII Delete Sum for Two Strings"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/distinct-subsequences/",children:"Distinct Subsequences"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"longest-increasing-subsequence",children:"Longest Increasing Subsequence"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/longest-increasing-subsequence/",children:"Longest Increasing Subsequence"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/number-of-longest-increasing-subsequence/",children:"Number of Longest Increasing Subsequence"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/maximum-length-of-pair-chain/",children:"Maximum Length of Pair Chain"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/longest-arithmetic-subsequence-of-given-difference/",children:"Longest Arithmetic Subsequence of Given Difference"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/longest-arithmetic-subsequence/",children:"Longest Arithmetic Subsequence"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/russian-doll-envelopes/",children:"Russian Doll Envelopes"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/find-the-longest-valid-obstacle-course-at-each-position/",children:"Find the Longest Valid Obstacle Course at Each Position"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"longest-common-subsequence",children:"Longest Common Subsequence"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/longest-common-subsequence/",children:"Longest Common Subsequence"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/uncrossed-lines/",children:"Uncrossed Lines"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/",children:"Minimum Insertion Steps to Make a String Palindrome"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"best-time-to-buy--sell-stock--state-machine",children:"Best Time to Buy & Sell Stock / State Machine"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/description",children:"Best Time to Buy and Sell Stock with Cooldown"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/best-time-to-buy-and-sell-stock/",children:"Best Time to Buy and Sell Stock"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/maximum-subarray/",children:"Maximum Subarray"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/",children:"Best Time to Buy and Sell Stock with Transaction Fee"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/",children:"Best Time to Buy and Sell Stock III"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/",children:"Best Time to Buy and Sell Stock IV"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"on-trees",children:"On Trees"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/unique-binary-search-trees/description",children:"Unique Binary Search Trees"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/unique-binary-search-trees-ii/",children:"Unique Binary Search Trees II"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/house-robber-iii/",children:"House Robber III"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/binary-tree-maximum-path-sum/",children:"Binary Tree Maximum Path Sum"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"knapsack",children:"Knapsack"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/perfect-squares/",children:"Perfect Squares"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/coin-change-ii/",children:"Coin Change II"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/combination-sum-iv/",children:"Combination Sum IV"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/ones-and-zeroes/",children:"Ones and Zeroes"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"general-1d",children:"General 1D"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/solving-questions-with-brainpower/",children:"Solving Questions With Brainpower"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/coin-change/description",children:"Coin Change"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/count-ways-to-build-good-strings/",children:"Count Ways to Build Good Strings"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/minimum-cost-for-tickets/description",children:"Minimum Cost For Tickets"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/domino-and-tromino-tiling/",children:"Domino and Tromino Tiling"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/decode-ways/description",children:"Decode Ways"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"2d-grid-dp-problems",children:"2D Grid DP Problems"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/unique-paths/",children:"Unique Paths"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/minimum-path-sum/",children:"Minimum Path Sum"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/unique-paths-ii/",children:"Unique Paths II"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/triangle/",children:"Triangle"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/minimum-falling-path-sum/",children:"Minimum Falling Path Sum"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/maximal-square/",children:"Maximal Square"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"3d-grid-dp-problems",children:"3D Grid DP Problems"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/out-of-boundary-paths/",children:"Out of Boundary Paths"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/",children:"Shortest Path in a Grid with Obstacles Elimination"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/minimum-path-cost-in-a-grid/",children:"Minimum Path Cost in a Grid"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/cherry-pickup-ii/",children:"Cherry Pickup II"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/remove-boxes/",children:"Remove Boxes"})}),"\n"]}),"\n",(0,s.jsx)(n.h1,{id:"dynamic-programming-knapsack-problems",children:"Dynamic Programming: Knapsack Problems"}),"\n",(0,s.jsx)(n.h2,{id:"01-knapsack-problem",children:"0/1 Knapsack Problem"}),"\n",(0,s.jsx)(n.h3,{id:"constraint",children:"Constraint"}),"\n",(0,s.jsx)(n.p,{children:"You can either include or exclude an item, i.e., you can take at most one of each item."}),"\n",(0,s.jsx)(n.h3,{id:"objective",children:"Objective"}),"\n",(0,s.jsx)(n.p,{children:"Maximize the total value of items chosen such that their combined weight is less than or equal to a given capacity."}),"\n",(0,s.jsx)(n.h3,{id:"decision",children:"Decision"}),"\n",(0,s.jsx)(n.p,{children:"For each item, you have a binary choice (0 or 1)\u2014either take it or leave it."}),"\n",(0,s.jsx)(n.h3,{id:"approach",children:"Approach"}),"\n",(0,s.jsx)(n.p,{children:"Dynamic programming is often used, where each subproblem considers whether to include or exclude a particular item."}),"\n",(0,s.jsx)(n.h3,{id:"recurrence-relation",children:"Recurrence Relation"}),"\n",(0,s.jsx)(n.p,{children:"The recurrence relation is typically:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"dp[i][w] = max(dp[i-1][w], dp[i-1][w - weight[i]] + value[i])"})}),"\n",(0,s.jsx)(n.p,{children:"Where:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"i is the item index,"}),"\n",(0,s.jsx)(n.li,{children:"w is the current weight capacity."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-JavaScript",children:"const knapsack01 = (W, items) => {\n  const n = items.length;\n  const dp = Array(W + 1).fill(0); // DP table to store the max profit for each weight limit\n\n  // Iterate over each item\n  for (let i = 0; i < n; i++) {\n    const { weight, profit } = items[i];\n\n    // Traverse DP table backwards to avoid overwriting values in the same round\n    for (let w = W; w >= weight; w--) {\n      dp[w] = Math.max(dp[w], dp[w - weight] + profit);\n    }\n  }\n\n  return dp[W]; // Max profit for capacity W\n}\n\n// Example usage:\nconst items01 = [\n  { weight: 1, profit: 60 },\n  { weight: 2, profit: 100 },\n  { weight: 3, profit: 120 }\n];\nconst W01 = 5;\nconsole.log(knapsack01(W01, items01)); // Output: 220\n/* \nTC : O(N*W)\nSC : O(W)\n*/\n"})}),"\n",(0,s.jsx)(n.h3,{id:"01-knapsack-fractional-weight",children:"0/1 Knapsack Fractional Weight"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-JavaScript",children:"const fractionalKnapsack = (W, items) => {\n    // Sort items by profit-to-weight ratio in descending order\n    items.sort((a, b) => (b.profit / b.weight) - (a.profit / a.weight));\n\n    let totalProfit = 0;\n    for (let i = 0; i < items.length && W > 0; i++) {\n        if (W >= items[i].weight) {\n            // Take the full item\n            totalProfit += items[i].profit;\n            W -= items[i].weight;\n        } else {\n            // Take a fraction of the item\n            totalProfit += (W / items[i].weight) * items[i].profit;\n            break;\n        }\n    }\n    return totalProfit;\n}\n\n// Example usage:\nconst items = [\n    { weight: 4, profit: 12 },\n    { weight: 2, profit: 10 },\n    { weight: 1, profit: 4 }\n];\nconst W = 5;\nconsole.log(fractionalKnapsack(W, items)); // Output: 16\n/* \nTC : O(N*logN)\nSC : O(1)\n*/\n"})}),"\n",(0,s.jsx)(n.h2,{id:"unbounded-knapsack-problem",children:"Unbounded Knapsack Problem"}),"\n",(0,s.jsx)(n.h3,{id:"constraint-1",children:"Constraint"}),"\n",(0,s.jsx)(n.p,{children:"There is no limit on how many times you can take each item, i.e., you can take an unlimited number of each item."}),"\n",(0,s.jsx)(n.h3,{id:"objective-1",children:"Objective"}),"\n",(0,s.jsx)(n.p,{children:"Similar to the 0/1 problem\u2014maximize the total value while adhering to a weight constraint."}),"\n",(0,s.jsx)(n.h3,{id:"decision-1",children:"Decision"}),"\n",(0,s.jsx)(n.p,{children:"For each item, you can include it any number of times, or not include it at all."}),"\n",(0,s.jsx)(n.h3,{id:"approach-1",children:"Approach"}),"\n",(0,s.jsx)(n.p,{children:"Dynamic programming is also used, but the recurrence allows taking an item multiple times."}),"\n",(0,s.jsx)(n.h3,{id:"recurrence-relation-1",children:"Recurrence Relation"}),"\n",(0,s.jsx)(n.p,{children:"The recurrence relation is:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"dp[w] = max(dp[w], dp[w - weight[i]] + value[i])"})}),"\n",(0,s.jsx)(n.p,{children:"Where w is the current weight capacity. Notice that the i-th item can be considered multiple times."}),"\n",(0,s.jsx)(n.h2,{id:"key-differences",children:"Key Differences"}),"\n",(0,s.jsx)(n.h3,{id:"item-usage",children:"Item Usage"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"0/1 Knapsack:"})," Each item can only be selected once."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Unbounded Knapsack:"})," Items can be selected multiple times."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"state-representation",children:"State Representation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"0/1 Knapsack:"})," Typically uses a 2D array dp[i][w], where i is the index of the item, and w is the current weight."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Unbounded Knapsack:"})," Uses a 1D array dp[w] since each item can be used more than once, eliminating the need for the second dimension."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"complexity",children:"Complexity"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"0/1 Knapsack:"})," Time complexity is O(nW), where n is the number of items and W is the knapsack capacity."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Unbounded Knapsack:"})," Time complexity is also O(nW), but the recursive calls allow for the same item to be picked multiple times."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-JavaScript",children:"const unboundedKnapsack = (W, items) => {\n  const n = items.length;\n  const dp = Array(W + 1).fill(0); // DP table to store the max profit for each weight limit\n\n  // Iterate over each item\n  for (let i = 0; i < n; i++) {\n    const { weight, profit } = items[i];\n\n    // Traverse DP table forwards since items can be taken multiple times\n    for (let w = weight; w <= W; w++) {\n      dp[w] = Math.max(dp[w], dp[w - weight] + profit);\n    }\n  }\n\n  return dp[W]; // Max profit for capacity W\n}\n\n// Example usage:\nconst itemsUnbounded = [\n  { weight: 1, profit: 10 },\n  { weight: 3, profit: 40 },\n  { weight: 4, profit: 50 }\n];\nconst WUnbounded = 6;\nconsole.log(unboundedKnapsack(WUnbounded, itemsUnbounded)); // Output: 80\n/* \nTC : O(N*W)\nSC : O(W)\n*/\n"})}),"\n",(0,s.jsx)(n.h2,{id:"example",children:"Example"}),"\n",(0,s.jsx)(n.p,{children:"Suppose you have items with weights [2, 3, 4] and values [4, 5, 6] and a knapsack capacity of 6:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"0/1 Knapsack:"})," You can pick at most one of each item. The optimal solution is to select items with weights 2 and 4, giving a total value of 10."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Unbounded Knapsack:"})," You can take multiple of the same item. The optimal solution is to take three items with weight 2 (since each gives 4 value), yielding a total value of 12."]}),"\n"]}),"\n",(0,s.jsx)(n.h1,{id:"knapsack-problems-on-leetcode",children:"Knapsack Problems on LeetCode"}),"\n",(0,s.jsx)(n.h2,{id:"01-knapsack-problems",children:"0/1 Knapsack Problems"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/partition-equal-subset-sum/",children:"Partition Equal Subset Sum (LC 416)"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/target-sum/",children:"Target Sum (LC 494)"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/ones-and-zeroes/",children:"Ones and Zeroes (LC 474)"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/integer-break/",children:"Integer Break (LC 343)"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/combination-sum-iv/",children:"Combination Sum IV"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/partition-equal-subset-sum/",children:"Subset Sum Problem"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/coin-change/",children:"Coin Change"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"unbounded-knapsack-problems",children:"Unbounded Knapsack Problems"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/coin-change-ii/",children:"Coin Change II (LC 518)"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/combination-sum-iv/",children:"Combination Sum IV (LC 377)"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/minimum-cost-for-tickets/",children:"Minimum Cost For Tickets (LC 983)"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/house-robber/",children:"House Robber (LC 198)"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/house-robber-ii/",children:"House Robber II (LC 213)"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/burst-balloons/",children:"Burst Balloons (LC 312)"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/maximum-profit-in-job-scheduling/",children:"Maximum Profit in Job Scheduling (LC 1235)"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/frog-jump/",children:"Frog Jump (LC 403)"})}),"\n"]}),"\n",(0,s.jsx)(n.h1,{id:"interesting-follow-ups",children:"Interesting Follow-ups"}),"\n",(0,s.jsx)(n.h3,{id:"longest-decreasing-subsequence",children:"Longest Decreasing Subsequence"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-JavaScript",children:"function lengthOfLDS(arr) {\n  const n = arr.length;\n  const dp = new Array(n).fill(1); // Initialize dp array\n\n  // Build the dp array\n  for (let i = 1; i < n; i++) {\n    for (let j = 0; j < i; j++) {\n      if (arr[j] > arr[i]) {\n        dp[i] = Math.max(dp[i], dp[j] + 1);\n      }\n    }\n  }\n\n  // The length of the longest decreasing subsequence\n  return Math.max(...dp);\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"longest-increasing-subsequence-in-a-2d-matrix",children:"Longest Increasing Subsequence in a 2D Matrix"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-JavaScript",children:"function longestIncreasingPath(matrix) {\n  if (!matrix.length || !matrix[0].length) return 0;\n\n  const rows = matrix.length;\n  const cols = matrix[0].length;\n  const dp = Array.from({ length: rows }, () => Array(cols).fill(-1)); // Memoization table\n\n  // Directions for moving in the matrix (down, up, right, left)\n  const directions = [\n    [1, 0], // down\n    [-1, 0], // up\n    [0, 1], // right\n    [0, -1] // left\n  ];\n\n  const isValid = (x, y, prevValue) => {\n    return x >= 0 && x < rows && y >= 0 && y < cols && matrix[x][y] > prevValue;\n  };\n\n  const dfs = (x, y) => {\n    if (dp[x][y] !== -1) return dp[x][y]; // Return already computed result\n\n    let maxLength = 1; // The length of path starting from (x, y) is at least 1 (the cell itself)\n\n    for (const [dx, dy] of directions) {\n      const newX = x + dx;\n      const newY = y + dy;\n\n      if (isValid(newX, newY, matrix[x][y])) {\n        maxLength = Math.max(maxLength, 1 + dfs(newX, newY));\n      }\n    }\n\n    dp[x][y] = maxLength; // Memoize the result\n    return maxLength;\n  };\n\n  let longestPath = 0;\n\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      longestPath = Math.max(longestPath, dfs(i, j));\n    }\n  }\n\n  return longestPath;\n}\n\n// Example usage\nconst matrix = [\n  [9, 9, 4],\n  [6, 6, 8],\n  [2, 1, 1]\n];\nconsole.log(longestIncreasingPath(matrix)); // Output: 4 (path: [1, 2, 6, 9])\n"})}),"\n",(0,s.jsx)(n.h3,{id:"longest-bitonic-subsequence",children:"Longest Bitonic Subsequence"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-JavaScript",children:"function lengthOfLBS(arr) {\n    const n = arr.length;\n    if (n === 0) return 0;\n\n    // Step 1: Initialize LIS and LDS arrays\n    const lis = new Array(n).fill(1);\n    const lds = new Array(n).fill(1);\n\n    // Step 2: Compute LIS for each element\n    for (let i = 1; i < n; i++) {\n        for (let j = 0; j < i; j++) {\n            if (arr[i] > arr[j]) {\n                lis[i] = Math.max(lis[i], lis[j] + 1);\n            }\n        }\n    }\n\n    // Step 3: Compute LDS for each element\n    for (let i = n - 2; i >= 0; i--) {\n        for (let j = n - 1; j > i; j--) {\n            if (arr[i] > arr[j]) {\n                lds[i] = Math.max(lds[i], lds[j] + 1);\n            }\n        }\n    }\n\n    // Step 4: Calculate the maximum length of the bitonic subsequence\n    let maxLength = 0;\n    for (let i = 0; i < n; i++) {\n        maxLength = Math.max(maxLength, lis[i] + lds[i] - 1);\n    }\n\n    return maxLength;\n}\n\n// Example usage\nconst arr = [1, 3, 5, 4, 7];\nconsole.log(lengthOfLBS(arr)); // Output: 5 (subsequence: [1, 3, 5, 4, 1])\n"})})]})}function d(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>o});var s=i(6540);const t={},l=s.createContext(t);function r(e){const n=s.useContext(l);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),s.createElement(l.Provider,{value:n},e.children)}}}]);