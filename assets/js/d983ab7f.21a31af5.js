"use strict";(globalThis.webpackChunkdev_enigma=globalThis.webpackChunkdev_enigma||[]).push([[47775],{28453:(n,e,i)=>{i.d(e,{R:()=>s,x:()=>l});var t=i(96540);const r={},a=t.createContext(r);function s(n){const e=t.useContext(a);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:s(n.components),t.createElement(a.Provider,{value:e},n.children)}},64716:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>o,contentTitle:()=>s,default:()=>u,frontMatter:()=>a,metadata:()=>l,toc:()=>d});var t=i(74848),r=i(28453);const a={},s="Dynamic Programming",l={id:"DSA/DSA/DSA with Java/Dynamic Programming",title:"Dynamic Programming",description:"Table of Contents",source:"@site/docs/05-DSA/DSA/DSA with Java/Dynamic Programming.mdx",sourceDirName:"05-DSA/DSA/DSA with Java",slug:"/DSA/DSA/DSA with Java/Dynamic Programming",permalink:"/docs/DSA/DSA/DSA with Java/Dynamic Programming",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/05-DSA/DSA/DSA with Java/Dynamic Programming.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Bit Manipulation",permalink:"/docs/DSA/DSA/DSA with Java/Bit Manipulation"},next:{title:"Graph",permalink:"/docs/DSA/DSA/DSA with Java/Graph Patterns"}},o={},d=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"DP Fundamentals &amp; Templates",id:"dp-fundamentals--templates",level:2},{value:"Core DP Characteristics",id:"core-dp-characteristics",level:3},{value:"Seven Steps to Solve Any DP Problem",id:"seven-steps-to-solve-any-dp-problem",level:3},{value:"Pattern 1: Linear DP (1D)",id:"pattern-1-linear-dp-1d",level:2},{value:"1.1 Fibonacci Sequence",id:"11-fibonacci-sequence",level:3},{value:"1.2 Climbing Stairs",id:"12-climbing-stairs",level:3},{value:"1.3 House Robber",id:"13-house-robber",level:3},{value:"1.4 Maximum Subarray (Kadane&#39;s Algorithm)",id:"14-maximum-subarray-kadanes-algorithm",level:3},{value:"1.5 Coin Change (Minimum Coins)",id:"15-coin-change-minimum-coins",level:3},{value:"Pattern 2: Grid DP (2D)",id:"pattern-2-grid-dp-2d",level:2},{value:"2.1 Unique Paths",id:"21-unique-paths",level:3},{value:"2.2 Minimum Path Sum",id:"22-minimum-path-sum",level:3},{value:"2.3 Longest Common Subsequence (LCS)",id:"23-longest-common-subsequence-lcs",level:3},{value:"2.4 Edit Distance (Levenshtein Distance)",id:"24-edit-distance-levenshtein-distance",level:3},{value:"2.5 Maximum Square",id:"25-maximum-square",level:3},{value:"Pattern 3: Knapsack Patterns",id:"pattern-3-knapsack-patterns",level:2},{value:"3.1 0/1 Knapsack",id:"31-01-knapsack",level:3},{value:"3.2 Unbounded Knapsack",id:"32-unbounded-knapsack",level:3},{value:"3.3 Partition Equal Subset Sum",id:"33-partition-equal-subset-sum",level:3},{value:"3.4 Target Sum",id:"34-target-sum",level:3},{value:"Pattern 4: Subsequence DP",id:"pattern-4-subsequence-dp",level:2},{value:"4.1 Longest Increasing Subsequence (LIS)",id:"41-longest-increasing-subsequence-lis",level:3},{value:"4.2 Longest Decreasing Subsequence",id:"42-longest-decreasing-subsequence",level:3},{value:"4.3 Russian Doll Envelopes",id:"43-russian-doll-envelopes",level:3},{value:"4.4 Number of LIS",id:"44-number-of-lis",level:3},{value:"Pattern 5: String DP",id:"pattern-5-string-dp",level:2},{value:"5.1 Palindromic Substring Problems",id:"51-palindromic-substring-problems",level:3},{value:"5.2 Word Break",id:"52-word-break",level:3},{value:"5.3 Distinct Subsequences",id:"53-distinct-subsequences",level:3},{value:"5.4 Regular Expression Matching",id:"54-regular-expression-matching",level:3},{value:"Pattern 6: Decision Making DP",id:"pattern-6-decision-making-dp",level:2},{value:"6.1 Best Time to Buy and Sell Stock",id:"61-best-time-to-buy-and-sell-stock",level:3},{value:"6.2 House Robber Variations",id:"62-house-robber-variations",level:3},{value:"Pattern 7: Interval DP",id:"pattern-7-interval-dp",level:2},{value:"7.1 Matrix Chain Multiplication",id:"71-matrix-chain-multiplication",level:3},{value:"7.2 Burst Balloons",id:"72-burst-balloons",level:3},{value:"7.3 Palindrome Partitioning II",id:"73-palindrome-partitioning-ii",level:3},{value:"Pattern 8: Tree DP",id:"pattern-8-tree-dp",level:2},{value:"8.1 Binary Tree Maximum Path Sum",id:"81-binary-tree-maximum-path-sum",level:3},{value:"8.2 Diameter of Binary Tree",id:"82-diameter-of-binary-tree",level:3},{value:"8.3 Binary Tree Cameras",id:"83-binary-tree-cameras",level:3},{value:"Pattern 9: Digit DP",id:"pattern-9-digit-dp",level:2},{value:"9.1 Count Numbers with Unique Digits",id:"91-count-numbers-with-unique-digits",level:3},{value:"9.2 Numbers At Most N Given Digit Set",id:"92-numbers-at-most-n-given-digit-set",level:3},{value:"Pattern 10: Bitmask DP",id:"pattern-10-bitmask-dp",level:2},{value:"10.1 Traveling Salesman Problem[1]",id:"101-traveling-salesman-problem1",level:3},{value:"10.2 Number of Ways to Wear Different Hats",id:"102-number-of-ways-to-wear-different-hats",level:3},{value:"Pattern 11: State Machine DP",id:"pattern-11-state-machine-dp",level:2},{value:"11.1 Best Time to Buy and Sell Stock with Transaction Fee",id:"111-best-time-to-buy-and-sell-stock-with-transaction-fee",level:3},{value:"11.2 Paint House",id:"112-paint-house",level:3},{value:"Pattern 12: Optimization DP",id:"pattern-12-optimization-dp",level:2},{value:"12.1 Maximum Rectangle in Binary Matrix",id:"121-maximum-rectangle-in-binary-matrix",level:3},{value:"Pattern 13: Probability DP",id:"pattern-13-probability-dp",level:2},{value:"13.1 Knight Probability in Chessboard",id:"131-knight-probability-in-chessboard",level:3},{value:"Pattern 14: Game Theory DP",id:"pattern-14-game-theory-dp",level:2},{value:"14.1 Stone Game",id:"141-stone-game",level:3},{value:"14.2 Predict the Winner",id:"142-predict-the-winner",level:3},{value:"Time Complexity Reference[4][5]",id:"time-complexity-reference45",level:2},{value:"Optimization Techniques[6][2]",id:"optimization-techniques62",level:2},{value:"Space Optimization Strategies",id:"space-optimization-strategies",level:3},{value:"Common Pitfalls",id:"common-pitfalls",level:3}];function m(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"dynamic-programming",children:"Dynamic Programming"})}),"\n",(0,t.jsx)(e.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#dp-fundamentals--templates",children:"DP Fundamentals & Templates"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-1-linear-dp-1d",children:"Pattern 1: Linear DP (1D)"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-2-grid-dp-2d",children:"Pattern 2: Grid DP (2D)"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-3-knapsack-patterns",children:"Pattern 3: Knapsack Patterns"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-4-subsequence-dp",children:"Pattern 4: Subsequence DP"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-5-string-dp",children:"Pattern 5: String DP"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-6-decision-making-dp",children:"Pattern 6: Decision Making DP"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-7-interval-dp",children:"Pattern 7: Interval DP"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-8-tree-dp",children:"Pattern 8: Tree DP"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-9-digit-dp",children:"Pattern 9: Digit DP"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-10-bitmask-dp",children:"Pattern 10: Bitmask DP"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-11-state-machine-dp",children:"Pattern 11: State Machine DP"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-12-optimization-dp",children:"Pattern 12: Optimization DP"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-13-probability-dp",children:"Pattern 13: Probability DP"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-14-game-theory-dp",children:"Pattern 14: Game Theory DP"})}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"dp-fundamentals--templates",children:"DP Fundamentals & Templates"}),"\n",(0,t.jsx)(e.h3,{id:"core-dp-characteristics",children:"Core DP Characteristics"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Dynamic Programming Requirements:\n// 1. Optimal Substructure: Optimal solution can be constructed from optimal solutions of subproblems\n// 2. Overlapping Subproblems: Same subproblems are solved multiple times\n\n// DP Template Structure\nclass DPTemplate {\n    // 1. Top-Down Approach (Memoization)\n    Map<String, Integer> memo = new HashMap<>();\n\n    int topDown(int[] params) {\n        String key = Arrays.toString(params);\n        if (memo.containsKey(key)) return memo.get(key);\n\n        // Base case\n        if (isBaseCase(params)) {\n            return baseValue(params);\n        }\n\n        // Recurrence relation\n        int result = Integer.MIN_VALUE; // or MAX_VALUE for min problems\n        for (int choice : getChoices(params)) {\n            result = Math.max(result, topDown(makeChoice(params, choice)));\n        }\n\n        memo.put(key, result);\n        return result;\n    }\n\n    // 2. Bottom-Up Approach (Tabulation)\n    int bottomUp(int n) {\n        int[] dp = new int[n + 1];\n\n        // Initialize base cases\n        dp[0] = baseCase0();\n        if (n > 0) dp[1] = baseCase1();\n\n        // Fill table using recurrence relation\n        for (int i = 2; i <= n; i++) {\n            dp[i] = recurrenceRelation(dp, i);\n        }\n\n        return dp[n];\n    }\n\n    // Helper methods\n    boolean isBaseCase(int[] params) { return /* condition */; }\n    int baseValue(int[] params) { return /* base value */; }\n    int[] getChoices(int[] params) { return /* available choices */; }\n    int[] makeChoice(int[] params, int choice) { return /* new state */; }\n    int baseCase0() { return /* base case value */; }\n    int baseCase1() { return /* base case value */; }\n    int recurrenceRelation(int[] dp, int i) { return /* recurrence */; }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"seven-steps-to-solve-any-dp-problem",children:"Seven Steps to Solve Any DP Problem"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:'class DPSolutionFramework {\n    /*\n    Step 1: Identify if it\'s a DP problem\n    - Optimal substructure + Overlapping subproblems\n    - Keywords: "maximum", "minimum", "count ways", "longest", "shortest"\n\n    Step 2: Identify the state\n    - What parameters uniquely identify a subproblem?\n    - Usually 1-3 variables (index, capacity, etc.)\n\n    Step 3: Formulate state relationship\n    - How does dp[i] relate to previous states?\n    - Write the recurrence relation\n\n    Step 4: Identify base cases\n    - What are the smallest subproblems?\n    - Usually when indices are 0 or at boundaries\n\n    Step 5: Decide implementation approach\n    - Top-down (recursion + memoization) or Bottom-up (tabulation)\n\n    Step 6: Add memoization or create DP table\n    - Cache results to avoid recomputation\n\n    Step 7: Optimize space if possible\n    - Can we reduce space complexity using rolling arrays?\n    */\n}\n'})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-1-linear-dp-1d",children:"Pattern 1: Linear DP (1D)"}),"\n",(0,t.jsx)(e.h3,{id:"11-fibonacci-sequence",children:"1.1 Fibonacci Sequence"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Classic DP example - each number is sum of two preceding ones\nint fibonacci(int n) {\n    if (n <= 1) return n;\n\n    // Space optimized O(1)\n    int prev2 = 0, prev1 = 1;\n    for (int i = 2; i <= n; i++) {\n        int curr = prev1 + prev2;\n        prev2 = prev1;\n        prev1 = curr;\n    }\n    return prev1;\n}\n\n// Tabulation approach O(n) space\nint fibonacciTable(int n) {\n    if (n <= 1) return n;\n\n    int[] dp = new int[n + 1];\n    dp[0] = 0;\n    dp[1] = 1;\n\n    for (int i = 2; i <= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2];\n    }\n\n    return dp[n];\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"12-climbing-stairs",children:"1.2 Climbing Stairs"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"int climbStairs(int n) {\n    if (n <= 2) return n;\n\n    // dp[i] = number of ways to reach step i\n    int[] dp = new int[n + 1];\n    dp[1] = 1; // 1 way to reach step 1\n    dp[2] = 2; // 2 ways to reach step 2 (1+1 or 2)\n\n    for (int i = 3; i <= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2]; // Can come from step i-1 or i-2\n    }\n\n    return dp[n];\n}\n\n// Space optimized\nint climbStairsOptimized(int n) {\n    if (n <= 2) return n;\n\n    int first = 1, second = 2;\n    for (int i = 3; i <= n; i++) {\n        int third = first + second;\n        first = second;\n        second = third;\n    }\n\n    return second;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"13-house-robber",children:"1.3 House Robber"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"int rob(int[] nums) {\n    if (nums.length == 0) return 0;\n    if (nums.length == 1) return nums[0];\n\n    // dp[i] = maximum money can rob up to house i\n    int[] dp = new int[nums.length];\n    dp[0] = nums[0];\n    dp[1] = Math.max(nums[0], nums[1]);\n\n    for (int i = 2; i < nums.length; i++) {\n        // Either rob current house + max from i-2, or don't rob (take i-1)\n        dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);\n    }\n\n    return dp[nums.length - 1];\n}\n\n// Space optimized O(1)\nint robOptimized(int[] nums) {\n    int prev2 = 0, prev1 = 0;\n\n    for (int num : nums) {\n        int curr = Math.max(prev1, prev2 + num);\n        prev2 = prev1;\n        prev1 = curr;\n    }\n\n    return prev1;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"14-maximum-subarray-kadanes-algorithm",children:"1.4 Maximum Subarray (Kadane's Algorithm)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"int maxSubArray(int[] nums) {\n    // dp[i] = maximum sum ending at index i\n    int maxSoFar = nums[0];\n    int maxEndingHere = nums[0];\n\n    for (int i = 1; i < nums.length; i++) {\n        // Either extend previous subarray or start new subarray\n        maxEndingHere = Math.max(nums[i], maxEndingHere + nums[i]);\n        maxSoFar = Math.max(maxSoFar, maxEndingHere);\n    }\n\n    return maxSoFar;\n}\n\n// With indices tracking\nclass SubarrayResult {\n    int maxSum, start, end;\n    SubarrayResult(int sum, int s, int e) {\n        maxSum = sum; start = s; end = e;\n    }\n}\n\nSubarrayResult maxSubarrayWithIndices(int[] nums) {\n    int maxSum = nums[0];\n    int currentSum = nums[0];\n    int start = 0, end = 0, tempStart = 0;\n\n    for (int i = 1; i < nums.length; i++) {\n        if (currentSum < 0) {\n            currentSum = nums[i];\n            tempStart = i;\n        } else {\n            currentSum += nums[i];\n        }\n\n        if (currentSum > maxSum) {\n            maxSum = currentSum;\n            start = tempStart;\n            end = i;\n        }\n    }\n\n    return new SubarrayResult(maxSum, start, end);\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"15-coin-change-minimum-coins",children:"1.5 Coin Change (Minimum Coins)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"int coinChange(int[] coins, int amount) {\n    // dp[i] = minimum coins needed to make amount i\n    int[] dp = new int[amount + 1];\n    Arrays.fill(dp, amount + 1); // Initialize with impossible value\n    dp[0] = 0; // 0 coins needed for amount 0\n\n    for (int i = 1; i <= amount; i++) {\n        for (int coin : coins) {\n            if (coin <= i) {\n                dp[i] = Math.min(dp[i], dp[i - coin] + 1);\n            }\n        }\n    }\n\n    return dp[amount] > amount ? -1 : dp[amount];\n}\n\n// Count number of ways to make change\nint coinChangeWays(int[] coins, int amount) {\n    int[] dp = new int[amount + 1];\n    dp[0] = 1; // One way to make amount 0\n\n    for (int coin : coins) {\n        for (int i = coin; i <= amount; i++) {\n            dp[i] += dp[i - coin];\n        }\n    }\n\n    return dp[amount];\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-2-grid-dp-2d",children:"Pattern 2: Grid DP (2D)"}),"\n",(0,t.jsx)(e.h3,{id:"21-unique-paths",children:"2.1 Unique Paths"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"int uniquePaths(int m, int n) {\n    // dp[i][j] = number of paths to reach cell (i,j)\n    int[][] dp = new int[m][n];\n\n    // Initialize first row and column\n    for (int i = 0; i < m; i++) dp[i][0] = 1;\n    for (int j = 0; j < n; j++) dp[0][j] = 1;\n\n    for (int i = 1; i < m; i++) {\n        for (int j = 1; j < n; j++) {\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n        }\n    }\n\n    return dp[m - 1][n - 1];\n}\n\n// Space optimized O(n)\nint uniquePathsOptimized(int m, int n) {\n    int[] dp = new int[n];\n    Arrays.fill(dp, 1);\n\n    for (int i = 1; i < m; i++) {\n        for (int j = 1; j < n; j++) {\n            dp[j] += dp[j - 1];\n        }\n    }\n\n    return dp[n - 1];\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"22-minimum-path-sum",children:"2.2 Minimum Path Sum"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"int minPathSum(int[][] grid) {\n    int m = grid.length, n = grid[0].length;\n    int[][] dp = new int[m][n];\n\n    dp[0][0] = grid[0][0];\n\n    // Initialize first row\n    for (int j = 1; j < n; j++) {\n        dp[0][j] = dp[0][j - 1] + grid[0][j];\n    }\n\n    // Initialize first column\n    for (int i = 1; i < m; i++) {\n        dp[i][0] = dp[i - 1][0] + grid[i][0];\n    }\n\n    // Fill the rest\n    for (int i = 1; i < m; i++) {\n        for (int j = 1; j < n; j++) {\n            dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\n        }\n    }\n\n    return dp[m - 1][n - 1];\n}\n\n// In-place modification (if allowed)\nint minPathSumInPlace(int[][] grid) {\n    int m = grid.length, n = grid[0].length;\n\n    for (int i = 1; i < m; i++) {\n        grid[i][0] += grid[i - 1][0];\n    }\n\n    for (int j = 1; j < n; j++) {\n        grid[0][j] += grid[0][j - 1];\n    }\n\n    for (int i = 1; i < m; i++) {\n        for (int j = 1; j < n; j++) {\n            grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);\n        }\n    }\n\n    return grid[m - 1][n - 1];\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"23-longest-common-subsequence-lcs",children:"2.3 Longest Common Subsequence (LCS)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"int longestCommonSubsequence(String text1, String text2) {\n    int m = text1.length(), n = text2.length();\n    int[][] dp = new int[m + 1][n + 1];\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (text1.charAt(i - 1) == text2.charAt(j - 1)) {\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            } else {\n                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n\n// Space optimized O(min(m,n))\nint lcsOptimized(String text1, String text2) {\n    if (text1.length() < text2.length()) {\n        return lcsOptimized(text2, text1);\n    }\n\n    int n = text2.length();\n    int[] prev = new int[n + 1];\n    int[] curr = new int[n + 1];\n\n    for (int i = 1; i <= text1.length(); i++) {\n        for (int j = 1; j <= n; j++) {\n            if (text1.charAt(i - 1) == text2.charAt(j - 1)) {\n                curr[j] = prev[j - 1] + 1;\n            } else {\n                curr[j] = Math.max(prev[j], curr[j - 1]);\n            }\n        }\n        int[] temp = prev;\n        prev = curr;\n        curr = temp;\n    }\n\n    return prev[n];\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"24-edit-distance-levenshtein-distance",children:"2.4 Edit Distance (Levenshtein Distance)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"int minDistance(String word1, String word2) {\n    int m = word1.length(), n = word2.length();\n    int[][] dp = new int[m + 1][n + 1];\n\n    // Base cases\n    for (int i = 0; i <= m; i++) dp[i][0] = i; // Delete all characters\n    for (int j = 0; j <= n; j++) dp[0][j] = j; // Insert all characters\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (word1.charAt(i - 1) == word2.charAt(j - 1)) {\n                dp[i][j] = dp[i - 1][j - 1]; // No operation needed\n            } else {\n                dp[i][j] = 1 + Math.min(\n                    Math.min(dp[i - 1][j],     // Delete\n                            dp[i][j - 1]),     // Insert\n                    dp[i - 1][j - 1]           // Replace\n                );\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"25-maximum-square",children:"2.5 Maximum Square"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"int maximalSquare(char[][] matrix) {\n    if (matrix.length == 0) return 0;\n\n    int m = matrix.length, n = matrix[0].length;\n    int[][] dp = new int[m + 1][n + 1];\n    int maxSide = 0;\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (matrix[i - 1][j - 1] == '1') {\n                dp[i][j] = Math.min(\n                    Math.min(dp[i - 1][j], dp[i][j - 1]),\n                    dp[i - 1][j - 1]\n                ) + 1;\n                maxSide = Math.max(maxSide, dp[i][j]);\n            }\n        }\n    }\n\n    return maxSide * maxSide;\n}\n\n// Space optimized O(n)\nint maximalSquareOptimized(char[][] matrix) {\n    if (matrix.length == 0) return 0;\n\n    int n = matrix[0].length;\n    int[] dp = new int[n + 1];\n    int maxSide = 0, prev = 0;\n\n    for (char[] row : matrix) {\n        for (int j = 1; j <= n; j++) {\n            int temp = dp[j];\n            if (row[j - 1] == '1') {\n                dp[j] = Math.min(Math.min(dp[j], dp[j - 1]), prev) + 1;\n                maxSide = Math.max(maxSide, dp[j]);\n            } else {\n                dp[j] = 0;\n            }\n            prev = temp;\n        }\n    }\n\n    return maxSide * maxSide;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-3-knapsack-patterns",children:"Pattern 3: Knapsack Patterns"}),"\n",(0,t.jsx)(e.h3,{id:"31-01-knapsack",children:"3.1 0/1 Knapsack"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"int knapsack01(int[] weights, int[] values, int capacity) {\n    int n = weights.length;\n    // dp[i][w] = maximum value using first i items with weight limit w\n    int[][] dp = new int[n + 1][capacity + 1];\n\n    for (int i = 1; i <= n; i++) {\n        for (int w = 1; w <= capacity; w++) {\n            // Don't take item i-1\n            dp[i][w] = dp[i - 1][w];\n\n            // Take item i-1 if it fits\n            if (weights[i - 1] <= w) {\n                dp[i][w] = Math.max(dp[i][w],\n                    dp[i - 1][w - weights[i - 1]] + values[i - 1]);\n            }\n        }\n    }\n\n    return dp[n][capacity];\n}\n\n// Space optimized O(capacity)\nint knapsack01Optimized(int[] weights, int[] values, int capacity) {\n    int[] dp = new int[capacity + 1];\n\n    for (int i = 0; i < weights.length; i++) {\n        // Traverse backwards to avoid using updated values\n        for (int w = capacity; w >= weights[i]; w--) {\n            dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]);\n        }\n    }\n\n    return dp[capacity];\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"32-unbounded-knapsack",children:"3.2 Unbounded Knapsack"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"int unboundedKnapsack(int[] weights, int[] values, int capacity) {\n    int[] dp = new int[capacity + 1];\n\n    for (int w = 1; w <= capacity; w++) {\n        for (int i = 0; i < weights.length; i++) {\n            if (weights[i] <= w) {\n                dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]);\n            }\n        }\n    }\n\n    return dp[capacity];\n}\n\n// Alternative approach - process items first\nint unboundedKnapsackAlt(int[] weights, int[] values, int capacity) {\n    int[] dp = new int[capacity + 1];\n\n    for (int i = 0; i < weights.length; i++) {\n        for (int w = weights[i]; w <= capacity; w++) {\n            dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]);\n        }\n    }\n\n    return dp[capacity];\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"33-partition-equal-subset-sum",children:"3.3 Partition Equal Subset Sum"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"boolean canPartition(int[] nums) {\n    int sum = Arrays.stream(nums).sum();\n    if (sum % 2 != 0) return false;\n\n    int target = sum / 2;\n    boolean[] dp = new boolean[target + 1];\n    dp[0] = true; // Can always make sum 0\n\n    for (int num : nums) {\n        for (int j = target; j >= num; j--) {\n            dp[j] = dp[j] || dp[j - num];\n        }\n    }\n\n    return dp[target];\n}\n\n// With path reconstruction\nList<Integer> findPartition(int[] nums) {\n    int sum = Arrays.stream(nums).sum();\n    if (sum % 2 != 0) return new ArrayList<>();\n\n    int target = sum / 2;\n    boolean[][] dp = new boolean[nums.length + 1][target + 1];\n\n    for (int i = 0; i <= nums.length; i++) {\n        dp[i][0] = true;\n    }\n\n    for (int i = 1; i <= nums.length; i++) {\n        for (int j = 1; j <= target; j++) {\n            dp[i][j] = dp[i - 1][j];\n            if (nums[i - 1] <= j) {\n                dp[i][j] = dp[i][j] || dp[i - 1][j - nums[i - 1]];\n            }\n        }\n    }\n\n    if (!dp[nums.length][target]) return new ArrayList<>();\n\n    // Reconstruct path\n    List<Integer> result = new ArrayList<>();\n    int i = nums.length, j = target;\n    while (i > 0 && j > 0) {\n        if (!dp[i - 1][j]) {\n            result.add(nums[i - 1]);\n            j -= nums[i - 1];\n        }\n        i--;\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"34-target-sum",children:"3.4 Target Sum"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"int findTargetSumWays(int[] nums, int target) {\n    int sum = Arrays.stream(nums).sum();\n    if (sum < Math.abs(target) || (sum + target) % 2 != 0) return 0;\n\n    int subset1Sum = (sum + target) / 2;\n    return countSubsets(nums, subset1Sum);\n}\n\nint countSubsets(int[] nums, int target) {\n    int[] dp = new int[target + 1];\n    dp[0] = 1; // One way to make sum 0\n\n    for (int num : nums) {\n        for (int j = target; j >= num; j--) {\n            dp[j] += dp[j - num];\n        }\n    }\n\n    return dp[target];\n}\n\n// Handle zeros separately\nint findTargetSumWaysWithZeros(int[] nums, int target) {\n    int sum = 0, zeros = 0;\n    for (int num : nums) {\n        if (num == 0) zeros++;\n        else sum += num;\n    }\n\n    if (sum < Math.abs(target) || (sum + target) % 2 != 0) return 0;\n\n    int subset1Sum = (sum + target) / 2;\n    int ways = countSubsetsNonZero(nums, subset1Sum);\n\n    return ways * (1 << zeros); // 2^zeros ways to assign signs to zeros\n}\n\nint countSubsetsNonZero(int[] nums, int target) {\n    int[] dp = new int[target + 1];\n    dp[0] = 1;\n\n    for (int num : nums) {\n        if (num > 0) { // Skip zeros\n            for (int j = target; j >= num; j--) {\n                dp[j] += dp[j - num];\n            }\n        }\n    }\n\n    return dp[target];\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-4-subsequence-dp",children:"Pattern 4: Subsequence DP"}),"\n",(0,t.jsx)(e.h3,{id:"41-longest-increasing-subsequence-lis",children:"4.1 Longest Increasing Subsequence (LIS)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"int lengthOfLIS(int[] nums) {\n    int[] dp = new int[nums.length];\n    Arrays.fill(dp, 1); // Each element forms LIS of length 1\n\n    int maxLength = 1;\n    for (int i = 1; i < nums.length; i++) {\n        for (int j = 0; j < i; j++) {\n            if (nums[j] < nums[i]) {\n                dp[i] = Math.max(dp[i], dp[j] + 1);\n            }\n        }\n        maxLength = Math.max(maxLength, dp[i]);\n    }\n\n    return maxLength;\n}\n\n// Binary Search Approach O(n log n)\nint lengthOfLISOptimal(int[] nums) {\n    List<Integer> tails = new ArrayList<>();\n\n    for (int num : nums) {\n        int pos = Collections.binarySearch(tails, num);\n        if (pos < 0) pos = -(pos + 1);\n\n        if (pos == tails.size()) {\n            tails.add(num);\n        } else {\n            tails.set(pos, num);\n        }\n    }\n\n    return tails.size();\n}\n\n// Get actual LIS sequence\nList<Integer> getLIS(int[] nums) {\n    int[] dp = new int[nums.length];\n    int[] parent = new int[nums.length];\n    Arrays.fill(dp, 1);\n    Arrays.fill(parent, -1);\n\n    int maxLength = 1, maxIndex = 0;\n\n    for (int i = 1; i < nums.length; i++) {\n        for (int j = 0; j < i; j++) {\n            if (nums[j] < nums[i] && dp[j] + 1 > dp[i]) {\n                dp[i] = dp[j] + 1;\n                parent[i] = j;\n            }\n        }\n\n        if (dp[i] > maxLength) {\n            maxLength = dp[i];\n            maxIndex = i;\n        }\n    }\n\n    // Reconstruct LIS\n    List<Integer> lis = new ArrayList<>();\n    int curr = maxIndex;\n    while (curr != -1) {\n        lis.add(nums[curr]);\n        curr = parent[curr];\n    }\n\n    Collections.reverse(lis);\n    return lis;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"42-longest-decreasing-subsequence",children:"4.2 Longest Decreasing Subsequence"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"int lengthOfLDS(int[] nums) {\n    int[] dp = new int[nums.length];\n    Arrays.fill(dp, 1);\n\n    int maxLength = 1;\n    for (int i = 1; i < nums.length; i++) {\n        for (int j = 0; j < i; j++) {\n            if (nums[j] > nums[i]) { // Changed condition for decreasing\n                dp[i] = Math.max(dp[i], dp[j] + 1);\n            }\n        }\n        maxLength = Math.max(maxLength, dp[i]);\n    }\n\n    return maxLength;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"43-russian-doll-envelopes",children:"4.3 Russian Doll Envelopes"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"int maxEnvelopes(int[][] envelopes) {\n    // Sort by width ascending, then by height descending\n    Arrays.sort(envelopes, (a, b) ->\n        a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);\n\n    // Find LIS on heights\n    int[] heights = new int[envelopes.length];\n    for (int i = 0; i < envelopes.length; i++) {\n        heights[i] = envelopes[i][1];\n    }\n\n    return lengthOfLISOptimal(heights);\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"44-number-of-lis",children:"4.4 Number of LIS"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"int findNumberOfLIS(int[] nums) {\n    int[] lengths = new int[nums.length]; // Length of LIS ending at i\n    int[] counts = new int[nums.length];  // Number of LIS ending at i\n    Arrays.fill(lengths, 1);\n    Arrays.fill(counts, 1);\n\n    int maxLength = 1;\n    for (int i = 1; i < nums.length; i++) {\n        for (int j = 0; j < i; j++) {\n            if (nums[j] < nums[i]) {\n                if (lengths[j] + 1 > lengths[i]) {\n                    lengths[i] = lengths[j] + 1;\n                    counts[i] = counts[j];\n                } else if (lengths[j] + 1 == lengths[i]) {\n                    counts[i] += counts[j];\n                }\n            }\n        }\n        maxLength = Math.max(maxLength, lengths[i]);\n    }\n\n    int result = 0;\n    for (int i = 0; i < nums.length; i++) {\n        if (lengths[i] == maxLength) {\n            result += counts[i];\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-5-string-dp",children:"Pattern 5: String DP"}),"\n",(0,t.jsx)(e.h3,{id:"51-palindromic-substring-problems",children:"5.1 Palindromic Substring Problems"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:'// Longest Palindromic Substring\nString longestPalindrome(String s) {\n    int n = s.length();\n    boolean[][] dp = new boolean[n][n];\n    String result = "";\n\n    // Every single character is a palindrome\n    for (int i = 0; i < n; i++) {\n        dp[i][i] = true;\n        result = s.substring(i, i + 1);\n    }\n\n    // Check for length 2\n    for (int i = 0; i < n - 1; i++) {\n        if (s.charAt(i) == s.charAt(i + 1)) {\n            dp[i][i + 1] = true;\n            result = s.substring(i, i + 2);\n        }\n    }\n\n    // Check for lengths 3 to n\n    for (int len = 3; len <= n; len++) {\n        for (int i = 0; i < n - len + 1; i++) {\n            int j = i + len - 1;\n\n            if (s.charAt(i) == s.charAt(j) && dp[i + 1][j - 1]) {\n                dp[i][j] = true;\n                result = s.substring(i, j + 1);\n            }\n        }\n    }\n\n    return result;\n}\n\n// Count Palindromic Substrings\nint countSubstrings(String s) {\n    int n = s.length();\n    boolean[][] dp = new boolean[n][n];\n    int count = 0;\n\n    // Single characters\n    for (int i = 0; i < n; i++) {\n        dp[i][i] = true;\n        count++;\n    }\n\n    // Length 2\n    for (int i = 0; i < n - 1; i++) {\n        if (s.charAt(i) == s.charAt(i + 1)) {\n            dp[i][i + 1] = true;\n            count++;\n        }\n    }\n\n    // Length 3+\n    for (int len = 3; len <= n; len++) {\n        for (int i = 0; i < n - len + 1; i++) {\n            int j = i + len - 1;\n            if (s.charAt(i) == s.charAt(j) && dp[i + 1][j - 1]) {\n                dp[i][j] = true;\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"52-word-break",children:"5.2 Word Break"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:'boolean wordBreak(String s, List<String> wordDict) {\n    Set<String> wordSet = new HashSet<>(wordDict);\n    boolean[] dp = new boolean[s.length() + 1];\n    dp[0] = true; // Empty string can always be segmented\n\n    for (int i = 1; i <= s.length(); i++) {\n        for (int j = 0; j < i; j++) {\n            if (dp[j] && wordSet.contains(s.substring(j, i))) {\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n\n    return dp[s.length()];\n}\n\n// Word Break II - return all possible sentences\nList<String> wordBreakII(String s, List<String> wordDict) {\n    Set<String> wordSet = new HashSet<>(wordDict);\n    Map<String, List<String>> memo = new HashMap<>();\n    return wordBreakHelper(s, wordSet, memo);\n}\n\nList<String> wordBreakHelper(String s, Set<String> wordSet,\n                           Map<String, List<String>> memo) {\n    if (memo.containsKey(s)) return memo.get(s);\n\n    List<String> result = new ArrayList<>();\n\n    if (s.isEmpty()) {\n        result.add("");\n        return result;\n    }\n\n    for (String word : wordSet) {\n        if (s.startsWith(word)) {\n            List<String> sublist = wordBreakHelper(s.substring(word.length()),\n                                                  wordSet, memo);\n            for (String sub : sublist) {\n                result.add(word + (sub.isEmpty() ? "" : " ") + sub);\n            }\n        }\n    }\n\n    memo.put(s, result);\n    return result;\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"53-distinct-subsequences",children:"5.3 Distinct Subsequences"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"int numDistinct(String s, String t) {\n    int m = s.length(), n = t.length();\n    // dp[i][j] = number of ways to form t[0..j-1] using s[0..i-1]\n    int[][] dp = new int[m + 1][n + 1];\n\n    // Empty string t can be formed in 1 way from any string s\n    for (int i = 0; i <= m; i++) {\n        dp[i][0] = 1;\n    }\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            // Don't use s[i-1]\n            dp[i][j] = dp[i - 1][j];\n\n            // Use s[i-1] if it matches t[j-1]\n            if (s.charAt(i - 1) == t.charAt(j - 1)) {\n                dp[i][j] += dp[i - 1][j - 1];\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n\n// Space optimized\nint numDistinctOptimized(String s, String t) {\n    int n = t.length();\n    int[] dp = new int[n + 1];\n    dp[0] = 1;\n\n    for (char c : s.toCharArray()) {\n        for (int j = n; j >= 1; j--) {\n            if (c == t.charAt(j - 1)) {\n                dp[j] += dp[j - 1];\n            }\n        }\n    }\n\n    return dp[n];\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"54-regular-expression-matching",children:"5.4 Regular Expression Matching"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"boolean isMatch(String s, String p) {\n    int m = s.length(), n = p.length();\n    boolean[][] dp = new boolean[m + 1][n + 1];\n\n    dp[0][0] = true; // Empty string matches empty pattern\n\n    // Handle patterns like a*, a*b*, a*b*c*\n    for (int j = 2; j <= n; j++) {\n        if (p.charAt(j - 1) == '*') {\n            dp[0][j] = dp[0][j - 2];\n        }\n    }\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            char sc = s.charAt(i - 1);\n            char pc = p.charAt(j - 1);\n\n            if (pc == '*') {\n                // Check pattern before *\n                char prevPc = p.charAt(j - 2);\n\n                // Don't use the character before *\n                dp[i][j] = dp[i][j - 2];\n\n                // Use the character before * if it matches\n                if (prevPc == '.' || prevPc == sc) {\n                    dp[i][j] = dp[i][j] || dp[i - 1][j];\n                }\n            } else if (pc == '.' || pc == sc) {\n                dp[i][j] = dp[i - 1][j - 1];\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-6-decision-making-dp",children:"Pattern 6: Decision Making DP"}),"\n",(0,t.jsx)(e.h3,{id:"61-best-time-to-buy-and-sell-stock",children:"6.1 Best Time to Buy and Sell Stock"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Single Transaction\nint maxProfit(int[] prices) {\n    int minPrice = Integer.MAX_VALUE;\n    int maxProfit = 0;\n\n    for (int price : prices) {\n        if (price < minPrice) {\n            minPrice = price;\n        } else if (price - minPrice > maxProfit) {\n            maxProfit = price - minPrice;\n        }\n    }\n\n    return maxProfit;\n}\n\n// Multiple Transactions\nint maxProfitMultiple(int[] prices) {\n    int profit = 0;\n\n    for (int i = 1; i < prices.length; i++) {\n        if (prices[i] > prices[i - 1]) {\n            profit += prices[i] - prices[i - 1];\n        }\n    }\n\n    return profit;\n}\n\n// At Most K Transactions\nint maxProfitKTransactions(int k, int[] prices) {\n    if (prices.length <= 1) return 0;\n\n    // If k is large enough, treat as unlimited transactions\n    if (k >= prices.length / 2) {\n        return maxProfitMultiple(prices);\n    }\n\n    // dp[i][j] = max profit after at most i transactions by day j\n    int[][] dp = new int[k + 1][prices.length];\n\n    for (int i = 1; i <= k; i++) {\n        int maxDiff = -prices[0]; // Max profit if we bought on day 0\n\n        for (int j = 1; j < prices.length; j++) {\n            dp[i][j] = Math.max(dp[i][j - 1], prices[j] + maxDiff);\n            maxDiff = Math.max(maxDiff, dp[i - 1][j] - prices[j]);\n        }\n    }\n\n    return dp[k][prices.length - 1];\n}\n\n// With Cooldown\nint maxProfitWithCooldown(int[] prices) {\n    if (prices.length <= 1) return 0;\n\n    // State: held[i] = max profit when holding stock on day i\n    //        sold[i] = max profit when sold stock on day i\n    //        rest[i] = max profit when resting on day i\n\n    int held = -prices[0]; // Buy on day 0\n    int sold = 0;          // Can't sell on day 0\n    int rest = 0;          // Rest on day 0\n\n    for (int i = 1; i < prices.length; i++) {\n        int prevHeld = held, prevSold = sold, prevRest = rest;\n\n        held = Math.max(prevHeld, prevRest - prices[i]); // Keep holding or buy\n        sold = prevHeld + prices[i];                     // Sell\n        rest = Math.max(prevRest, prevSold);             // Rest\n    }\n\n    return Math.max(sold, rest); // Can't hold stock at the end\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"62-house-robber-variations",children:"6.2 House Robber Variations"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// House Robber II (Circular Array)\nint robCircular(int[] nums) {\n    if (nums.length == 1) return nums[0];\n\n    // Case 1: Rob houses 0 to n-2 (exclude last house)\n    int max1 = robLinear(Arrays.copyOfRange(nums, 0, nums.length - 1));\n\n    // Case 2: Rob houses 1 to n-1 (exclude first house)\n    int max2 = robLinear(Arrays.copyOfRange(nums, 1, nums.length));\n\n    return Math.max(max1, max2);\n}\n\nint robLinear(int[] nums) {\n    int prev1 = 0, prev2 = 0;\n\n    for (int num : nums) {\n        int curr = Math.max(prev1, prev2 + num);\n        prev2 = prev1;\n        prev1 = curr;\n    }\n\n    return prev1;\n}\n\n// House Robber III (Binary Tree)\nMap<TreeNode, Integer> memo = new HashMap<>();\n\nint robTree(TreeNode root) {\n    if (root == null) return 0;\n    if (memo.containsKey(root)) return memo.get(root);\n\n    // Rob this node\n    int robThis = root.val;\n    if (root.left != null) {\n        robThis += robTree(root.left.left) + robTree(root.left.right);\n    }\n    if (root.right != null) {\n        robThis += robTree(root.right.left) + robTree(root.right.right);\n    }\n\n    // Don't rob this node\n    int dontRobThis = robTree(root.left) + robTree(root.right);\n\n    int result = Math.max(robThis, dontRobThis);\n    memo.put(root, result);\n    return result;\n}\n\n// Optimized Tree Solution\nint[] robTreeOptimized(TreeNode root) {\n    // Returns [don't rob this node, rob this node]\n    if (root == null) return new int[]{0, 0};\n\n    int[] left = robTreeOptimized(root.left);\n    int[] right = robTreeOptimized(root.right);\n\n    int dontRob = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);\n    int rob = root.val + left[0] + right[0];\n\n    return new int[]{dontRob, rob};\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-7-interval-dp",children:"Pattern 7: Interval DP"}),"\n",(0,t.jsx)(e.h3,{id:"71-matrix-chain-multiplication",children:"7.1 Matrix Chain Multiplication"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:'int matrixChainOrder(int[] dims) {\n    int n = dims.length - 1; // Number of matrices\n    int[][] dp = new int[n][n];\n\n    // Length of chain\n    for (int len = 2; len <= n; len++) {\n        for (int i = 0; i <= n - len; i++) {\n            int j = i + len - 1;\n            dp[i][j] = Integer.MAX_VALUE;\n\n            for (int k = i; k < j; k++) {\n                int cost = dp[i][k] + dp[k + 1][j] +\n                          dims[i] * dims[k + 1] * dims[j + 1];\n                dp[i][j] = Math.min(dp[i][j], cost);\n            }\n        }\n    }\n\n    return dp[0][n - 1];\n}\n\n// With parenthesization tracking\nclass MatrixChainResult {\n    int minCost;\n    String parenthesization;\n\n    MatrixChainResult(int cost, String paren) {\n        minCost = cost;\n        parenthesization = paren;\n    }\n}\n\nMatrixChainResult matrixChainWithParen(int[] dims) {\n    int n = dims.length - 1;\n    int[][] dp = new int[n][n];\n    int[][] split = new int[n][n];\n\n    for (int len = 2; len <= n; len++) {\n        for (int i = 0; i <= n - len; i++) {\n            int j = i + len - 1;\n            dp[i][j] = Integer.MAX_VALUE;\n\n            for (int k = i; k < j; k++) {\n                int cost = dp[i][k] + dp[k + 1][j] +\n                          dims[i] * dims[k + 1] * dims[j + 1];\n\n                if (cost < dp[i][j]) {\n                    dp[i][j] = cost;\n                    split[i][j] = k;\n                }\n            }\n        }\n    }\n\n    String paren = buildParenthesization(split, 0, n - 1);\n    return new MatrixChainResult(dp[0][n - 1], paren);\n}\n\nString buildParenthesization(int[][] split, int i, int j) {\n    if (i == j) {\n        return "M" + i;\n    }\n\n    return "(" + buildParenthesization(split, i, split[i][j]) +\n           " \xd7 " + buildParenthesization(split, split[i][j] + 1, j) + ")";\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"72-burst-balloons",children:"7.2 Burst Balloons"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"int maxCoins(int[] nums) {\n    // Add dummy balloons with value 1 at both ends\n    int[] balloons = new int[nums.length + 2];\n    balloons[0] = balloons[balloons.length - 1] = 1;\n    System.arraycopy(nums, 0, balloons, 1, nums.length);\n\n    int n = balloons.length;\n    int[][] dp = new int[n][n];\n\n    // len is the length of the interval\n    for (int len = 2; len < n; len++) {\n        for (int left = 0; left < n - len; left++) {\n            int right = left + len;\n\n            // Try bursting each balloon k in (left, right)\n            for (int k = left + 1; k < right; k++) {\n                dp[left][right] = Math.max(dp[left][right],\n                    dp[left][k] + dp[k][right] +\n                    balloons[left] * balloons[k] * balloons[right]);\n            }\n        }\n    }\n\n    return dp[0][n - 1];\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"73-palindrome-partitioning-ii",children:"7.3 Palindrome Partitioning II"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"int minCut(String s) {\n    int n = s.length();\n\n    // Precompute palindrome check\n    boolean[][] isPalindrome = new boolean[n][n];\n    for (int i = 0; i < n; i++) {\n        isPalindrome[i][i] = true;\n    }\n\n    for (int i = 0; i < n - 1; i++) {\n        isPalindrome[i][i + 1] = (s.charAt(i) == s.charAt(i + 1));\n    }\n\n    for (int len = 3; len <= n; len++) {\n        for (int i = 0; i <= n - len; i++) {\n            int j = i + len - 1;\n            isPalindrome[i][j] = (s.charAt(i) == s.charAt(j)) &&\n                                isPalindrome[i + 1][j - 1];\n        }\n    }\n\n    // DP for minimum cuts\n    int[] dp = new int[n];\n    for (int i = 0; i < n; i++) {\n        if (isPalindrome[0][i]) {\n            dp[i] = 0; // No cut needed\n        } else {\n            dp[i] = i; // Worst case: i cuts\n            for (int j = 1; j <= i; j++) {\n                if (isPalindrome[j][i]) {\n                    dp[i] = Math.min(dp[i], dp[j - 1] + 1);\n                }\n            }\n        }\n    }\n\n    return dp[n - 1];\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-8-tree-dp",children:"Pattern 8: Tree DP"}),"\n",(0,t.jsx)(e.h3,{id:"81-binary-tree-maximum-path-sum",children:"8.1 Binary Tree Maximum Path Sum"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"int maxPathSum = Integer.MIN_VALUE;\n\nint maxPathSum(TreeNode root) {\n    maxPathSum = Integer.MIN_VALUE;\n    maxPathSumHelper(root);\n    return maxPathSum;\n}\n\nint maxPathSumHelper(TreeNode node) {\n    if (node == null) return 0;\n\n    // Get maximum sum from left and right subtrees\n    int leftSum = Math.max(0, maxPathSumHelper(node.left));\n    int rightSum = Math.max(0, maxPathSumHelper(node.right));\n\n    // Current path sum including this node as the highest point\n    int currentPathSum = node.val + leftSum + rightSum;\n\n    // Update global maximum\n    maxPathSum = Math.max(maxPathSum, currentPathSum);\n\n    // Return maximum sum including this node and one subtree\n    return node.val + Math.max(leftSum, rightSum);\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"82-diameter-of-binary-tree",children:"8.2 Diameter of Binary Tree"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"int diameter = 0;\n\nint diameterOfBinaryTree(TreeNode root) {\n    diameter = 0;\n    diameterHelper(root);\n    return diameter;\n}\n\nint diameterHelper(TreeNode node) {\n    if (node == null) return 0;\n\n    int leftHeight = diameterHelper(node.left);\n    int rightHeight = diameterHelper(node.right);\n\n    // Update diameter (path through this node)\n    diameter = Math.max(diameter, leftHeight + rightHeight);\n\n    // Return height of subtree rooted at this node\n    return 1 + Math.max(leftHeight, rightHeight);\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"83-binary-tree-cameras",children:"8.3 Binary Tree Cameras"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"int cameras = 0;\n\nint minCameraCover(TreeNode root) {\n    cameras = 0;\n    int result = dfsCamera(root);\n    // If root is not covered, add a camera\n    return cameras + (result == 0 ? 1 : 0);\n}\n\nint dfsCamera(TreeNode node) {\n    if (node == null) return 1; // Null nodes are covered\n\n    int left = dfsCamera(node.left);\n    int right = dfsCamera(node.right);\n\n    // If either child is not covered, this node needs a camera\n    if (left == 0 || right == 0) {\n        cameras++;\n        return 2; // This node has a camera\n    }\n\n    // If either child has a camera, this node is covered\n    if (left == 2 || right == 2) {\n        return 1; // This node is covered\n    }\n\n    // Both children are covered but don't have cameras\n    return 0; // This node is not covered\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-9-digit-dp",children:"Pattern 9: Digit DP"}),"\n",(0,t.jsx)(e.h3,{id:"91-count-numbers-with-unique-digits",children:"9.1 Count Numbers with Unique Digits"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"int countNumbersWithUniqueDigits(int n) {\n    if (n == 0) return 1;\n\n    int[] dp = new int[n + 1];\n    dp[0] = 1; // Empty number\n    dp[1] = 10; // 0-9\n\n    for (int i = 2; i <= n; i++) {\n        // First digit: 9 choices (1-9)\n        // Remaining digits: decreasing choices\n        dp[i] = dp[i - 1] + (dp[i - 1] - dp[i - 2]) * (11 - i);\n    }\n\n    return dp[n];\n}\n\n// Alternative approach\nint countNumbersWithUniqueDigitsAlt(int n) {\n    if (n == 0) return 1;\n\n    int result = 10; // 1-digit numbers\n    int uniqueDigits = 9;\n    int availableNumber = 9;\n\n    while (n-- > 1 && availableNumber > 0) {\n        uniqueDigits *= availableNumber;\n        result += uniqueDigits;\n        availableNumber--;\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"92-numbers-at-most-n-given-digit-set",children:"9.2 Numbers At Most N Given Digit Set"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"int atMostNGivenDigitSet(String[] digits, int n) {\n    String nStr = String.valueOf(n);\n    int nLen = nStr.length();\n    int digitCount = digits.length;\n\n    // Count numbers with fewer digits\n    int result = 0;\n    for (int i = 1; i < nLen; i++) {\n        result += Math.pow(digitCount, i);\n    }\n\n    // Count numbers with same number of digits\n    for (int i = 0; i < nLen; i++) {\n        int currentDigit = nStr.charAt(i) - '0';\n        int smallerCount = 0;\n\n        // Count digits smaller than current digit\n        for (String digit : digits) {\n            if (Integer.parseInt(digit) < currentDigit) {\n                smallerCount++;\n            }\n        }\n\n        result += smallerCount * Math.pow(digitCount, nLen - i - 1);\n\n        // Check if current digit exists in the set\n        boolean found = false;\n        for (String digit : digits) {\n            if (Integer.parseInt(digit) == currentDigit) {\n                found = true;\n                break;\n            }\n        }\n\n        if (!found) break;\n\n        // If we've processed all digits and all exist in set\n        if (i == nLen - 1) result++;\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-10-bitmask-dp",children:"Pattern 10: Bitmask DP"}),"\n",(0,t.jsx)(e.h3,{id:"101-traveling-salesman-problem1",children:"10.1 Traveling Salesman Problem[1]"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"int tsp(int[][] dist) {\n    int n = dist.length;\n    int[][] dp = new int[1 << n][n];\n\n    // Initialize with large values\n    for (int[] row : dp) {\n        Arrays.fill(row, Integer.MAX_VALUE / 2);\n    }\n\n    dp[1][0] = 0; // Start at city 0\n\n    for (int mask = 1; mask < (1 << n); mask++) {\n        for (int u = 0; u < n; u++) {\n            if ((mask & (1 << u)) == 0) continue;\n\n            for (int v = 0; v < n; v++) {\n                if ((mask & (1 << v)) != 0) continue;\n\n                int newMask = mask | (1 << v);\n                dp[newMask][v] = Math.min(dp[newMask][v],\n                                         dp[mask][u] + dist[u][v]);\n            }\n        }\n    }\n\n    int result = Integer.MAX_VALUE;\n    for (int i = 1; i < n; i++) {\n        result = Math.min(result, dp[(1 << n) - 1][i] + dist[i][0]);\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"102-number-of-ways-to-wear-different-hats",children:"10.2 Number of Ways to Wear Different Hats"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"int numberWaysToWearHats(List<List<Integer>> hats) {\n    int MOD = 1000000007;\n    int n = hats.size();\n\n    // Group people by their hat preferences\n    Map<Integer, List<Integer>> hatToPeople = new HashMap<>();\n    for (int person = 0; person < n; person++) {\n        for (int hat : hats.get(person)) {\n            hatToPeople.computeIfAbsent(hat, k -> new ArrayList<>()).add(person);\n        }\n    }\n\n    List<Integer> uniqueHats = new ArrayList<>(hatToPeople.keySet());\n    int[][] dp = new int[uniqueHats.size() + 1][1 << n];\n    dp[0][0] = 1;\n\n    for (int i = 1; i <= uniqueHats.size(); i++) {\n        int hat = uniqueHats.get(i - 1);\n\n        for (int mask = 0; mask < (1 << n); mask++) {\n            // Don't assign this hat to anyone\n            dp[i][mask] = dp[i - 1][mask];\n\n            // Try assigning this hat to each person who likes it\n            for (int person : hatToPeople.get(hat)) {\n                if ((mask & (1 << person)) != 0) {\n                    int prevMask = mask ^ (1 << person);\n                    dp[i][mask] = (dp[i][mask] + dp[i - 1][prevMask]) % MOD;\n                }\n            }\n        }\n    }\n\n    return dp[uniqueHats.size()][(1 << n) - 1];\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-11-state-machine-dp",children:"Pattern 11: State Machine DP"}),"\n",(0,t.jsx)(e.h3,{id:"111-best-time-to-buy-and-sell-stock-with-transaction-fee",children:"11.1 Best Time to Buy and Sell Stock with Transaction Fee"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"int maxProfitWithFee(int[] prices, int fee) {\n    // State: hold (holding stock) or sold (not holding stock)\n    int hold = -prices[0]; // Buy first stock\n    int sold = 0;          // Don't buy first stock\n\n    for (int i = 1; i < prices.length; i++) {\n        hold = Math.max(hold, sold - prices[i]);\n        sold = Math.max(sold, hold + prices[i] - fee);\n    }\n\n    return sold;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"112-paint-house",children:"11.2 Paint House"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"int minCost(int[][] costs) {\n    if (costs.length == 0) return 0;\n\n    int n = costs.length;\n    // State: dp[i][j] = min cost to paint house i with color j\n    int[][] dp = new int[n][3];\n\n    // Base case\n    dp[0][0] = costs[0][0];\n    dp[0][1] = costs[0][1];\n    dp[0][2] = costs[0][2];\n\n    for (int i = 1; i < n; i++) {\n        dp[i][0] = costs[i][0] + Math.min(dp[i - 1][1], dp[i - 1][2]);\n        dp[i][1] = costs[i][1] + Math.min(dp[i - 1][0], dp[i - 1][2]);\n        dp[i][2] = costs[i][2] + Math.min(dp[i - 1][0], dp[i - 1][1]);\n    }\n\n    return Math.min(Math.min(dp[n - 1][0], dp[n - 1][1]), dp[n - 1][2]);\n}\n\n// Space optimized\nint minCostOptimized(int[][] costs) {\n    int prevRed = costs[0][0];\n    int prevBlue = costs[0][1];\n    int prevGreen = costs[0][2];\n\n    for (int i = 1; i < costs.length; i++) {\n        int currRed = costs[i][0] + Math.min(prevBlue, prevGreen);\n        int currBlue = costs[i][1] + Math.min(prevRed, prevGreen);\n        int currGreen = costs[i][2] + Math.min(prevRed, prevBlue);\n\n        prevRed = currRed;\n        prevBlue = currBlue;\n        prevGreen = currGreen;\n    }\n\n    return Math.min(Math.min(prevRed, prevBlue), prevGreen);\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-12-optimization-dp",children:"Pattern 12: Optimization DP"}),"\n",(0,t.jsx)(e.h3,{id:"121-maximum-rectangle-in-binary-matrix",children:"12.1 Maximum Rectangle in Binary Matrix"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"int maximalRectangle(char[][] matrix) {\n    if (matrix.length == 0) return 0;\n\n    int m = matrix.length, n = matrix[0].length;\n    int[] heights = new int[n];\n    int maxArea = 0;\n\n    for (int i = 0; i < m; i++) {\n        // Update heights array\n        for (int j = 0; j < n; j++) {\n            heights[j] = matrix[i][j] == '1' ? heights[j] + 1 : 0;\n        }\n\n        // Find max rectangle in histogram\n        maxArea = Math.max(maxArea, largestRectangleArea(heights));\n    }\n\n    return maxArea;\n}\n\nint largestRectangleArea(int[] heights) {\n    Stack<Integer> stack = new Stack<>();\n    int maxArea = 0;\n\n    for (int i = 0; i <= heights.length; i++) {\n        int currHeight = (i == heights.length) ? 0 : heights[i];\n\n        while (!stack.isEmpty() && currHeight < heights[stack.peek()]) {\n            int height = heights[stack.pop()];\n            int width = stack.isEmpty() ? i : i - stack.peek() - 1;\n            maxArea = Math.max(maxArea, height * width);\n        }\n\n        stack.push(i);\n    }\n\n    return maxArea;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-13-probability-dp",children:"Pattern 13: Probability DP"}),"\n",(0,t.jsx)(e.h3,{id:"131-knight-probability-in-chessboard",children:"13.1 Knight Probability in Chessboard"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"double knightProbability(int n, int k, int row, int column) {\n    // 8 possible knight moves\n    int[][] directions = {{-2,-1}, {-2,1}, {-1,-2}, {-1,2},\n                         {1,-2}, {1,2}, {2,-1}, {2,1}};\n\n    // dp[i][j] = probability of being at (i,j)\n    double[][] dp = new double[n][n];\n    dp[row][column] = 1.0;\n\n    for (int step = 0; step < k; step++) {\n        double[][] newDp = new double[n][n];\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (dp[i][j] > 0) {\n                    for (int[] dir : directions) {\n                        int ni = i + dir[0];\n                        int nj = j + dir[1];\n\n                        if (ni >= 0 && ni < n && nj >= 0 && nj < n) {\n                            newDp[ni][nj] += dp[i][j] / 8.0;\n                        }\n                    }\n                }\n            }\n        }\n\n        dp = newDp;\n    }\n\n    double totalProbability = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            totalProbability += dp[i][j];\n        }\n    }\n\n    return totalProbability;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-14-game-theory-dp",children:"Pattern 14: Game Theory DP"}),"\n",(0,t.jsx)(e.h3,{id:"141-stone-game",children:"14.1 Stone Game"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"boolean stoneGame(int[] piles) {\n    int n = piles.length;\n    // dp[i][j] = max score difference (Alex - Lee) for piles[i..j]\n    int[][] dp = new int[n][n];\n\n    // Base case: single pile\n    for (int i = 0; i < n; i++) {\n        dp[i][i] = piles[i];\n    }\n\n    // Fill for all lengths\n    for (int len = 2; len <= n; len++) {\n        for (int i = 0; i <= n - len; i++) {\n            int j = i + len - 1;\n            // Alex can take piles[i] or piles[j]\n            dp[i][j] = Math.max(piles[i] - dp[i + 1][j],\n                               piles[j] - dp[i][j - 1]);\n        }\n    }\n\n    return dp[0][n - 1] > 0;\n}\n\n// Optimized: Alex always wins (mathematical proof)\nboolean stoneGameOptimal(int[] piles) {\n    return true; // Alex can always choose all even or all odd indexed piles\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"142-predict-the-winner",children:"14.2 Predict the Winner"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"boolean predictTheWinner(int[] nums) {\n    int n = nums.length;\n    int[][] dp = new int[n][n];\n\n    // Base case: single element\n    for (int i = 0; i < n; i++) {\n        dp[i][i] = nums[i];\n    }\n\n    // Fill diagonal by diagonal\n    for (int len = 2; len <= n; len++) {\n        for (int i = 0; i <= n - len; i++) {\n            int j = i + len - 1;\n            dp[i][j] = Math.max(nums[i] - dp[i + 1][j],\n                               nums[j] - dp[i][j - 1]);\n        }\n    }\n\n    return dp[0][n - 1] >= 0;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"time-complexity-reference45",children:"Time Complexity Reference[4][5]"}),"\n",(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{style:{textAlign:"left"},children:"Pattern"}),(0,t.jsx)(e.th,{style:{textAlign:"left"},children:"Time Complexity"}),(0,t.jsx)(e.th,{style:{textAlign:"left"},children:"Space Complexity"}),(0,t.jsx)(e.th,{style:{textAlign:"left"},children:"Key Problems"})]})}),(0,t.jsxs)(e.tbody,{children:[(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Linear DP"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(1) to O(n)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Fibonacci, Climbing Stairs"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Grid DP"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(m\xd7n)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(m\xd7n) to O(n)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Unique Paths, LCS"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Knapsack"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(n\xd7W)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(W)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"0/1 Knapsack, Coin Change"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Subsequence"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(n\xb2) to O(n log n)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"LIS, LCS"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"String DP"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(n\xb2) to O(n\xd7m)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(n\xd7m)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Edit Distance, Word Break"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Tree DP"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(h)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Max Path Sum, Diameter"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Interval DP"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(n\xb3)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(n\xb2)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Matrix Chain, Burst Balloons"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Bitmask DP"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(2\u207f\xd7n)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(2\u207f\xd7n)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"TSP, Assignment"})]})]})]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"optimization-techniques62",children:"Optimization Techniques[6][2]"}),"\n",(0,t.jsx)(e.h3,{id:"space-optimization-strategies",children:"Space Optimization Strategies"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// 1. Rolling Array Technique\n// From dp[i][j] = f(dp[i-1][j], dp[i][j-1])\n// To: prev[j] and curr[j]\n\n// 2. State Compression\n// Use bitmask when state space is small\n\n// 3. Memoization vs Tabulation\n// Top-down: easier to implement, uses recursion\n// Bottom-up: better space usage, iterative\n\n// 4. Coordinate Compression\n// When dealing with large coordinate ranges\n"})}),"\n",(0,t.jsx)(e.h3,{id:"common-pitfalls",children:"Common Pitfalls"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Off-by-one errors"})," in array indexing"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Integer overflow"})," in large sum calculations"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Base case handling"})," - especially empty inputs"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"State definition"})," - ensure it captures all necessary information"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Transition validity"})," - check bounds and constraints"]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"This comprehensive DP patterns guide provides the foundation for solving complex optimization problems in technical interviews, particularly valuable for your backend engineering and system design expertise."})]})}function u(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(m,{...n})}):m(n)}}}]);