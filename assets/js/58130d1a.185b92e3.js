"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[1694],{28453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>o});var i=t(96540);const r={},a=i.createContext(r);function l(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),i.createElement(a.Provider,{value:n},e.children)}},40981:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>c,frontMatter:()=>a,metadata:()=>o,toc:()=>h});var i=t(74848),r=t(28453);const a={},l="AVL Tree",o={id:"DSA/DSA with JavaScript/AVLTree",title:"AVL Tree",description:"The implementation maintains the AVL tree properties:",source:"@site/docs/DSA/DSA with JavaScript/AVLTree.mdx",sourceDirName:"DSA/DSA with JavaScript",slug:"/DSA/DSA with JavaScript/AVLTree",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/AVLTree",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with JavaScript/AVLTree.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"2D Matrix Graph Algorithms",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/2DGraphAlgorithms"},next:{title:"Advanced Algorithm Techniques",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/AdvancedTechniques"}},s={},h=[{value:"Key features and optimizations:",id:"key-features-and-optimizations",level:2},{value:"Implementation",id:"implementation",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"avl-tree",children:"AVL Tree"})}),"\n",(0,i.jsx)(n.p,{children:"The implementation maintains the AVL tree properties:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Balance factor of every node is -1, 0, or 1"}),"\n",(0,i.jsx)(n.li,{children:"For each node, the heights of its left and right subtrees differ by at most 1"}),"\n",(0,i.jsx)(n.li,{children:"All BST properties are maintained"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"key-features-and-optimizations",children:"Key features and optimizations:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"1. Self-Balancing:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Maintains height balance property (difference in heights \u2264 1)"}),"\n",(0,i.jsx)(n.li,{children:"Four types of rotations: Left-Left, Right-Right, Left-Right, Right-Left"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"2. Performance:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Insert: O(log n)"}),"\n",(0,i.jsx)(n.li,{children:"Delete: O(log n)"}),"\n",(0,i.jsx)(n.li,{children:"Search: O(log n)"}),"\n",(0,i.jsx)(n.li,{children:"Space: O(n)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"3. Balanced Operations:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Automatic rebalancing after insertions and deletions"}),"\n",(0,i.jsx)(n.li,{children:"Height tracking for efficient balance factor calculation"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"4. Memory Efficient:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Minimal node structure with just value, height, and child pointers"}),"\n",(0,i.jsx)(n.li,{children:"Size tracking for quick size queries"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"5. Complete API:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Insert, delete, search operations"}),"\n",(0,i.jsx)(n.li,{children:"Traversal methods"}),"\n",(0,i.jsx)(n.li,{children:"Size and emptiness checks"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"implementation",children:"Implementation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-JavaScript",children:"class Node {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n    this.height = 1;  // Height of the node (used for balancing)\n  }\n}\n\nclass AVLTree {\n  constructor() {\n    this.root = null;\n    this.size = 0;\n  }\n\n  // Get height of a node\n  getHeight(node) {\n    return node ? node.height : 0;\n  }\n\n  // Get balance factor of a node\n  getBalanceFactor(node) {\n    return node ? this.getHeight(node.left) - this.getHeight(node.right) : 0;\n  }\n\n  // Update height of a node\n  updateHeight(node) {\n    if (node) {\n      node.height = 1 + Math.max(\n        this.getHeight(node.left),\n        this.getHeight(node.right)\n      );\n    }\n  }\n\n  // Right rotation\n  rightRotate(y) {\n    const x = y.left;\n    const T2 = x.right;\n\n    x.right = y;\n    y.left = T2;\n\n    // Update heights\n    this.updateHeight(y);\n    this.updateHeight(x);\n\n    return x;\n  }\n\n  // Left rotation\n  leftRotate(x) {\n    const y = x.right;\n    const T2 = y.left;\n\n    y.left = x;\n    x.right = T2;\n\n    // Update heights\n    this.updateHeight(x);\n    this.updateHeight(y);\n\n    return y;\n  }\n\n  // Insert a value into the tree\n  insert(value) {\n    this.root = this.#insert(this.root, value);\n    this.size++;\n  }\n\n  #insert(node, value) {\n    // Normal BST insertion\n    if (!node) {\n      return new Node(value);\n    }\n\n    if (value < node.value) {\n      node.left = this.#insert(node.left, value);\n    } else if (value > node.value) {\n      node.right = this.#insert(node.right, value);\n    } else {\n      return node; // Duplicate values not allowed\n    }\n\n    // Update height\n    this.updateHeight(node);\n\n    // Get balance factor\n    const balance = this.getBalanceFactor(node);\n\n    // Left Left Case\n    if (balance > 1 && value < node.left.value) {\n      return this.rightRotate(node);\n    }\n\n    // Right Right Case\n    if (balance < -1 && value > node.right.value) {\n      return this.leftRotate(node);\n    }\n\n    // Left Right Case\n    if (balance > 1 && value > node.left.value) {\n      node.left = this.leftRotate(node.left);\n      return this.rightRotate(node);\n    }\n\n    // Right Left Case\n    if (balance < -1 && value < node.right.value) {\n      node.right = this.rightRotate(node.right);\n      return this.leftRotate(node);\n    }\n\n    return node;\n  }\n\n  // Delete a value from the tree\n  delete(value) {\n    this.root = this.#delete(this.root, value);\n  }\n\n  #delete(node, value) {\n    if (!node) {\n      return null;\n    }\n\n    if (value < node.value) {\n      node.left = this.#delete(node.left, value);\n    } else if (value > node.value) {\n      node.right = this.#delete(node.right, value);\n    } else {\n      // Node with only one child or no child\n      if (!node.left || !node.right) {\n        const temp = node.left || node.right;\n        if (!temp) {\n          // No child case\n          node = null;\n        } else {\n          // One child case\n          node = temp;\n        }\n        this.size--;\n      } else {\n        // Node with two children\n        const temp = this.getMinNode(node.right);\n        node.value = temp.value;\n        node.right = this.#delete(node.right, temp.value);\n      }\n    }\n\n    if (!node) {\n      return null;\n    }\n\n    // Update height\n    this.updateHeight(node);\n\n    // Get balance factor\n    const balance = this.getBalanceFactor(node);\n\n    // Left Left Case\n    if (balance > 1 && this.getBalanceFactor(node.left) >= 0) {\n      return this.rightRotate(node);\n    }\n\n    // Left Right Case\n    if (balance > 1 && this.getBalanceFactor(node.left) < 0) {\n      node.left = this.leftRotate(node.left);\n      return this.rightRotate(node);\n    }\n\n    // Right Right Case\n    if (balance < -1 && this.getBalanceFactor(node.right) <= 0) {\n      return this.leftRotate(node);\n    }\n\n    // Right Left Case\n    if (balance < -1 && this.getBalanceFactor(node.right) > 0) {\n      node.right = this.rightRotate(node.right);\n      return this.leftRotate(node);\n    }\n\n    return node;\n  }\n\n  // Find minimum value node in the tree\n  getMinNode(node) {\n    let current = node;\n    while (current.left) {\n      current = current.left;\n    }\n    return current;\n  }\n\n  // Search for a value\n  search(value) {\n    return this.#search(this.root, value);\n  }\n\n  #search(node, value) {\n    if (!node || node.value === value) {\n      return node;\n    }\n\n    if (value < node.value) {\n      return this.#search(node.left, value);\n    }\n    return this.#search(node.right, value);\n  }\n\n  // Traversal methods\n  inorder() {\n    const result = [];\n    this.#inorder(this.root, result);\n    return result;\n  }\n\n  #inorder(node, result) {\n    if (node) {\n      this.#inorder(node.left, result);\n      result.push(node.value);\n      this.#inorder(node.right, result);\n    }\n  }\n\n  // Get tree size\n  getSize() {\n    return this.size;\n  }\n\n  // Check if tree is empty\n  isEmpty() {\n    return this.size === 0;\n  }\n}\n\n// Create AVL Tree\nconst avl = new AVLTree();\n\n// Insert values\navl.insert(10);\navl.insert(20);\navl.insert(30);\navl.insert(40);\navl.insert(50);\navl.insert(25);\n\n// Search\nconsole.log(avl.search(30));  // Node { value: 30, ... }\nconsole.log(avl.search(100)); // null\n\n// Delete\navl.delete(30);\n\n// Get sorted array\nconsole.log(avl.inorder()); // [10, 20, 25, 40, 50]\n"})})]})}function c(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);