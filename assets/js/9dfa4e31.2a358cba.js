"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[1486],{4977:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>s,default:()=>c,frontMatter:()=>u,metadata:()=>l,toc:()=>o});var t=i(4848),r=i(8453);const u={},s="Queue",l={id:"DSA/DSA with Java/Queue Patterns",title:"Queue",description:"Table of Contents",source:"@site/docs/DSA/DSA with Java/Queue Patterns.mdx",sourceDirName:"DSA/DSA with Java",slug:"/DSA/DSA with Java/Queue Patterns",permalink:"/js.enigma/docs/DSA/DSA with Java/Queue Patterns",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with Java/Queue Patterns.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Prefix Sum",permalink:"/js.enigma/docs/DSA/DSA with Java/Prefix Sum Patterns"},next:{title:"Sliding Window",permalink:"/js.enigma/docs/DSA/DSA with Java/Sliding Window"}},a={},o=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Queue Fundamentals",id:"queue-fundamentals",level:2},{value:"Core Queue Implementation",id:"core-queue-implementation",level:3},{value:"Pattern 1: Basic Queue Operations",id:"pattern-1-basic-queue-operations",level:2},{value:"1.1 Queue Using Stacks",id:"11-queue-using-stacks",level:3},{value:"1.2 Stack Using Queues",id:"12-stack-using-queues",level:3},{value:"1.3 Reverse Queue",id:"13-reverse-queue",level:3},{value:"Pattern 2: BFS &amp; Level Order Traversal",id:"pattern-2-bfs--level-order-traversal",level:2},{value:"2.1 Binary Tree Level Order Traversal",id:"21-binary-tree-level-order-traversal",level:3},{value:"2.2 Graph BFS Traversal",id:"22-graph-bfs-traversal",level:3},{value:"2.3 Grid BFS Problems",id:"23-grid-bfs-problems",level:3},{value:"Pattern 3: Sliding Window with Queue",id:"pattern-3-sliding-window-with-queue",level:2},{value:"3.1 Moving Average",id:"31-moving-average",level:3},{value:"3.2 First Unique Character in Stream",id:"32-first-unique-character-in-stream",level:3},{value:"Pattern 4: Monotonic Queue/Deque",id:"pattern-4-monotonic-queuedeque",level:2},{value:"4.1 Sliding Window Maximum",id:"41-sliding-window-maximum",level:3},{value:"4.2 Sliding Window Minimum",id:"42-sliding-window-minimum",level:3},{value:"4.3 Constrained Subsequence Sum",id:"43-constrained-subsequence-sum",level:3},{value:"4.4 Shortest Subarray with Sum at Least K",id:"44-shortest-subarray-with-sum-at-least-k",level:3},{value:"4.5 Jump Game VI",id:"45-jump-game-vi",level:3},{value:"Pattern 5: Priority Queue Patterns",id:"pattern-5-priority-queue-patterns",level:2},{value:"5.1 K Closest Points to Origin",id:"51-k-closest-points-to-origin",level:3},{value:"5.2 Top K Frequent Elements",id:"52-top-k-frequent-elements",level:3},{value:"5.3 Merge K Sorted Lists",id:"53-merge-k-sorted-lists",level:3},{value:"Pattern 6: Circular Queue &amp; Design",id:"pattern-6-circular-queue--design",level:2},{value:"6.1 Design Circular Queue",id:"61-design-circular-queue",level:3},{value:"6.2 Design Circular Deque",id:"62-design-circular-deque",level:3},{value:"Pattern 7: Multi-level BFS",id:"pattern-7-multi-level-bfs",level:2},{value:"7.1 Word Ladder",id:"71-word-ladder",level:3},{value:"7.2 Open the Lock",id:"72-open-the-lock",level:3},{value:"Pattern 8: Queue-based Simulation",id:"pattern-8-queue-based-simulation",level:2},{value:"8.1 Design Hit Counter",id:"81-design-hit-counter",level:3},{value:"8.2 Design Snake Game",id:"82-design-snake-game",level:3},{value:"Pattern 9: Queue for Tree Problems",id:"pattern-9-queue-for-tree-problems",level:2},{value:"9.1 Populating Next Right Pointers",id:"91-populating-next-right-pointers",level:3},{value:"9.2 Binary Tree Right Side View",id:"92-binary-tree-right-side-view",level:3},{value:"Pattern 10: Advanced Queue Applications",id:"pattern-10-advanced-queue-applications",level:2},{value:"10.1 Shortest Bridge",id:"101-shortest-bridge",level:3},{value:"10.2 Walls and Gates",id:"102-walls-and-gates",level:3},{value:"Pattern 11: Concurrent Queue Patterns",id:"pattern-11-concurrent-queue-patterns",level:2},{value:"11.1 Producer-Consumer with BlockingQueue",id:"111-producer-consumer-with-blockingqueue",level:3},{value:"11.2 Rate Limiter with Queue",id:"112-rate-limiter-with-queue",level:3},{value:"Pattern 12: Complex Queue Problems",id:"pattern-12-complex-queue-problems",level:2},{value:"12.1 Sliding Window Median",id:"121-sliding-window-median",level:3},{value:"12.2 Find Median from Data Stream",id:"122-find-median-from-data-stream",level:3},{value:"Time &amp; Space Complexity Reference",id:"time--space-complexity-reference",level:2},{value:"Best Practices &amp; Optimization Tips",id:"best-practices--optimization-tips",level:2},{value:"Queue Implementation Guidelines",id:"queue-implementation-guidelines",level:3},{value:"Common Optimizations",id:"common-optimizations",level:3},{value:"Interview Tips",id:"interview-tips",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"queue",children:"Queue"})}),"\n",(0,t.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#queue-fundamentals",children:"Queue Fundamentals"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-1-basic-queue-operations",children:"Pattern 1: Basic Queue Operations"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-2-bfs--level-order-traversal",children:"Pattern 2: BFS & Level Order Traversal"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-3-sliding-window-with-queue",children:"Pattern 3: Sliding Window with Queue"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-4-monotonic-queuedeque",children:"Pattern 4: Monotonic Queue/Deque"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-5-priority-queue-patterns",children:"Pattern 5: Priority Queue Patterns"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-6-circular-queue--design",children:"Pattern 6: Circular Queue & Design"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-7-multi-level-bfs",children:"Pattern 7: Multi-level BFS"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-8-queue-based-simulation",children:"Pattern 8: Queue-based Simulation"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-9-queue-for-tree-problems",children:"Pattern 9: Queue for Tree Problems"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-10-advanced-queue-applications",children:"Pattern 10: Advanced Queue Applications"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-11-concurrent-queue-patterns",children:"Pattern 11: Concurrent Queue Patterns"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#pattern-12-complex-queue-problems",children:"Pattern 12: Complex Queue Problems"})}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"queue-fundamentals",children:"Queue Fundamentals"}),"\n",(0,t.jsx)(n.h3,{id:"core-queue-implementation",children:"Core Queue Implementation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// Basic Queue Interface\ninterface Queue<T> {\n    void enqueue(T item);\n    T dequeue();\n    T front();\n    boolean isEmpty();\n    int size();\n}\n\n// Array-based Queue Implementation\nclass ArrayQueue<T> implements Queue<T> {\n    private T[] queue;\n    private int front;\n    private int rear;\n    private int size;\n    private int capacity;\n\n    @SuppressWarnings("unchecked")\n    public ArrayQueue(int capacity) {\n        this.capacity = capacity;\n        this.queue = (T[]) new Object[capacity];\n        this.front = 0;\n        this.rear = -1;\n        this.size = 0;\n    }\n\n    @Override\n    public void enqueue(T item) {\n        if (size >= capacity) {\n            throw new IllegalStateException("Queue is full");\n        }\n        rear = (rear + 1) % capacity;\n        queue[rear] = item;\n        size++;\n    }\n\n    @Override\n    public T dequeue() {\n        if (isEmpty()) {\n            throw new NoSuchElementException("Queue is empty");\n        }\n        T item = queue[front];\n        queue[front] = null; // Help GC\n        front = (front + 1) % capacity;\n        size--;\n        return item;\n    }\n\n    @Override\n    public T front() {\n        if (isEmpty()) {\n            throw new NoSuchElementException("Queue is empty");\n        }\n        return queue[front];\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    @Override\n    public int size() {\n        return size;\n    }\n}\n\n// LinkedList-based Queue Implementation\nclass LinkedQueue<T> implements Queue<T> {\n    private Node<T> front;\n    private Node<T> rear;\n    private int size;\n\n    private static class Node<T> {\n        T data;\n        Node<T> next;\n\n        Node(T data) {\n            this.data = data;\n        }\n    }\n\n    @Override\n    public void enqueue(T item) {\n        Node<T> newNode = new Node<>(item);\n\n        if (rear == null) {\n            front = rear = newNode;\n        } else {\n            rear.next = newNode;\n            rear = newNode;\n        }\n        size++;\n    }\n\n    @Override\n    public T dequeue() {\n        if (isEmpty()) {\n            throw new NoSuchElementException("Queue is empty");\n        }\n\n        T data = front.data;\n        front = front.next;\n\n        if (front == null) {\n            rear = null;\n        }\n\n        size--;\n        return data;\n    }\n\n    @Override\n    public T front() {\n        if (isEmpty()) {\n            throw new NoSuchElementException("Queue is empty");\n        }\n        return front.data;\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return front == null;\n    }\n\n    @Override\n    public int size() {\n        return size;\n    }\n}\n\n// Deque (Double-ended queue) Implementation [web:180]\nclass ArrayDeque<T> {\n    private T[] deque;\n    private int front;\n    private int rear;\n    private int size;\n    private int capacity;\n\n    @SuppressWarnings("unchecked")\n    public ArrayDeque(int capacity) {\n        this.capacity = capacity;\n        this.deque = (T[]) new Object[capacity];\n        this.front = 0;\n        this.rear = 0;\n        this.size = 0;\n    }\n\n    public void addFirst(T item) {\n        if (size >= capacity) throw new IllegalStateException("Deque is full");\n\n        front = (front - 1 + capacity) % capacity;\n        deque[front] = item;\n        size++;\n    }\n\n    public void addLast(T item) {\n        if (size >= capacity) throw new IllegalStateException("Deque is full");\n\n        deque[rear] = item;\n        rear = (rear + 1) % capacity;\n        size++;\n    }\n\n    public T removeFirst() {\n        if (isEmpty()) throw new NoSuchElementException("Deque is empty");\n\n        T item = deque[front];\n        deque[front] = null;\n        front = (front + 1) % capacity;\n        size--;\n        return item;\n    }\n\n    public T removeLast() {\n        if (isEmpty()) throw new NoSuchElementException("Deque is empty");\n\n        rear = (rear - 1 + capacity) % capacity;\n        T item = deque[rear];\n        deque[rear] = null;\n        size--;\n        return item;\n    }\n\n    public T peekFirst() {\n        if (isEmpty()) throw new NoSuchElementException("Deque is empty");\n        return deque[front];\n    }\n\n    public T peekLast() {\n        if (isEmpty()) throw new NoSuchElementException("Deque is empty");\n        return deque[(rear - 1 + capacity) % capacity];\n    }\n\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    public int size() {\n        return size;\n    }\n}\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-1-basic-queue-operations",children:"Pattern 1: Basic Queue Operations"}),"\n",(0,t.jsx)(n.h3,{id:"11-queue-using-stacks",children:"1.1 Queue Using Stacks"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Implement Queue using Two Stacks\nclass MyQueue {\n    private Stack<Integer> stackNewest; // For enqueue\n    private Stack<Integer> stackOldest; // For dequeue\n\n    public MyQueue() {\n        stackNewest = new Stack<>();\n        stackOldest = new Stack<>();\n    }\n\n    public void push(int x) {\n        stackNewest.push(x);\n    }\n\n    public int pop() {\n        shiftStacks();\n        return stackOldest.pop();\n    }\n\n    public int peek() {\n        shiftStacks();\n        return stackOldest.peek();\n    }\n\n    public boolean empty() {\n        return stackNewest.isEmpty() && stackOldest.isEmpty();\n    }\n\n    private void shiftStacks() {\n        if (stackOldest.isEmpty()) {\n            while (!stackNewest.isEmpty()) {\n                stackOldest.push(stackNewest.pop());\n            }\n        }\n    }\n}\n\n// Implement Queue using Single Stack (Recursive)\nclass MyQueueRecursive {\n    private Stack<Integer> stack;\n\n    public MyQueueRecursive() {\n        stack = new Stack<>();\n    }\n\n    public void push(int x) {\n        stack.push(x);\n    }\n\n    public int pop() {\n        if (stack.size() == 1) {\n            return stack.pop();\n        }\n\n        int item = stack.pop();\n        int result = pop(); // Recursive call\n        stack.push(item);\n        return result;\n    }\n\n    public int peek() {\n        if (stack.size() == 1) {\n            return stack.peek();\n        }\n\n        int item = stack.pop();\n        int result = peek(); // Recursive call\n        stack.push(item);\n        return result;\n    }\n\n    public boolean empty() {\n        return stack.isEmpty();\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"12-stack-using-queues",children:"1.2 Stack Using Queues"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Implement Stack using Two Queues\nclass MyStack {\n    private Queue<Integer> queue1;\n    private Queue<Integer> queue2;\n\n    public MyStack() {\n        queue1 = new LinkedList<>();\n        queue2 = new LinkedList<>();\n    }\n\n    public void push(int x) {\n        queue2.offer(x);\n\n        // Move all elements from queue1 to queue2\n        while (!queue1.isEmpty()) {\n            queue2.offer(queue1.poll());\n        }\n\n        // Swap references\n        Queue<Integer> temp = queue1;\n        queue1 = queue2;\n        queue2 = temp;\n    }\n\n    public int pop() {\n        return queue1.poll();\n    }\n\n    public int top() {\n        return queue1.peek();\n    }\n\n    public boolean empty() {\n        return queue1.isEmpty();\n    }\n}\n\n// Implement Stack using Single Queue\nclass MyStackSingleQueue {\n    private Queue<Integer> queue;\n\n    public MyStackSingleQueue() {\n        queue = new LinkedList<>();\n    }\n\n    public void push(int x) {\n        int size = queue.size();\n        queue.offer(x);\n\n        // Rotate the queue to bring the new element to front\n        for (int i = 0; i < size; i++) {\n            queue.offer(queue.poll());\n        }\n    }\n\n    public int pop() {\n        return queue.poll();\n    }\n\n    public int top() {\n        return queue.peek();\n    }\n\n    public boolean empty() {\n        return queue.isEmpty();\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"13-reverse-queue",children:"1.3 Reverse Queue"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Reverse Queue using Stack\npublic void reverseQueue(Queue<Integer> queue) {\n    Stack<Integer> stack = new Stack<>();\n\n    // Move all elements to stack\n    while (!queue.isEmpty()) {\n        stack.push(queue.poll());\n    }\n\n    // Move all elements back to queue\n    while (!stack.isEmpty()) {\n        queue.offer(stack.pop());\n    }\n}\n\n// Reverse Queue using Recursion\npublic void reverseQueueRecursive(Queue<Integer> queue) {\n    if (queue.isEmpty()) return;\n\n    int item = queue.poll();\n    reverseQueueRecursive(queue);\n    queue.offer(item);\n}\n\n// Reverse First K Elements of Queue\npublic void reverseFirstK(Queue<Integer> queue, int k) {\n    if (k <= 0 || k > queue.size()) return;\n\n    Stack<Integer> stack = new Stack<>();\n\n    // Move first k elements to stack\n    for (int i = 0; i < k; i++) {\n        stack.push(queue.poll());\n    }\n\n    // Move remaining elements to temporary queue\n    Queue<Integer> temp = new LinkedList<>();\n    while (!queue.isEmpty()) {\n        temp.offer(queue.poll());\n    }\n\n    // Move elements back from stack to queue (reversed)\n    while (!stack.isEmpty()) {\n        queue.offer(stack.pop());\n    }\n\n    // Move remaining elements back\n    while (!temp.isEmpty()) {\n        queue.offer(temp.poll());\n    }\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-2-bfs--level-order-traversal",children:"Pattern 2: BFS & Level Order Traversal"}),"\n",(0,t.jsx)(n.h3,{id:"21-binary-tree-level-order-traversal",children:"2.1 Binary Tree Level Order Traversal"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Basic Level Order Traversal\npublic List<List<Integer>> levelOrder(TreeNode root) {\n    List<List<Integer>> result = new ArrayList<>();\n    if (root == null) return result;\n\n    Queue<TreeNode> queue = new LinkedList<>();\n    queue.offer(root);\n\n    while (!queue.isEmpty()) {\n        int levelSize = queue.size();\n        List<Integer> currentLevel = new ArrayList<>();\n\n        for (int i = 0; i < levelSize; i++) {\n            TreeNode node = queue.poll();\n            currentLevel.add(node.val);\n\n            if (node.left != null) queue.offer(node.left);\n            if (node.right != null) queue.offer(node.right);\n        }\n\n        result.add(currentLevel);\n    }\n\n    return result;\n}\n\n// Zigzag Level Order Traversal\npublic List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n    List<List<Integer>> result = new ArrayList<>();\n    if (root == null) return result;\n\n    Queue<TreeNode> queue = new LinkedList<>();\n    queue.offer(root);\n    boolean leftToRight = true;\n\n    while (!queue.isEmpty()) {\n        int levelSize = queue.size();\n        List<Integer> currentLevel = new ArrayList<>();\n\n        for (int i = 0; i < levelSize; i++) {\n            TreeNode node = queue.poll();\n\n            if (leftToRight) {\n                currentLevel.add(node.val);\n            } else {\n                currentLevel.add(0, node.val); // Add at beginning\n            }\n\n            if (node.left != null) queue.offer(node.left);\n            if (node.right != null) queue.offer(node.right);\n        }\n\n        result.add(currentLevel);\n        leftToRight = !leftToRight;\n    }\n\n    return result;\n}\n\n// Level Order Bottom-Up\npublic List<List<Integer>> levelOrderBottom(TreeNode root) {\n    List<List<Integer>> result = new ArrayList<>();\n    if (root == null) return result;\n\n    Queue<TreeNode> queue = new LinkedList<>();\n    queue.offer(root);\n\n    while (!queue.isEmpty()) {\n        int levelSize = queue.size();\n        List<Integer> currentLevel = new ArrayList<>();\n\n        for (int i = 0; i < levelSize; i++) {\n            TreeNode node = queue.poll();\n            currentLevel.add(node.val);\n\n            if (node.left != null) queue.offer(node.left);\n            if (node.right != null) queue.offer(node.right);\n        }\n\n        result.add(0, currentLevel); // Add at beginning\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"22-graph-bfs-traversal",children:"2.2 Graph BFS Traversal"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// Basic Graph BFS\npublic void bfs(List<List<Integer>> graph, int start) {\n    boolean[] visited = new boolean[graph.size()];\n    Queue<Integer> queue = new LinkedList<>();\n\n    visited[start] = true;\n    queue.offer(start);\n\n    while (!queue.isEmpty()) {\n        int node = queue.poll();\n        System.out.print(node + " ");\n\n        for (int neighbor : graph.get(node)) {\n            if (!visited[neighbor]) {\n                visited[neighbor] = true;\n                queue.offer(neighbor);\n            }\n        }\n    }\n}\n\n// BFS with Distance Tracking\npublic int[] bfsDistance(List<List<Integer>> graph, int start) {\n    int n = graph.size();\n    int[] distance = new int[n];\n    Arrays.fill(distance, -1);\n\n    Queue<Integer> queue = new LinkedList<>();\n    distance[start] = 0;\n    queue.offer(start);\n\n    while (!queue.isEmpty()) {\n        int node = queue.poll();\n\n        for (int neighbor : graph.get(node)) {\n            if (distance[neighbor] == -1) {\n                distance[neighbor] = distance[node] + 1;\n                queue.offer(neighbor);\n            }\n        }\n    }\n\n    return distance;\n}\n\n// BFS Shortest Path with Path Reconstruction\npublic List<Integer> bfsShortestPath(List<List<Integer>> graph, int start, int end) {\n    int n = graph.size();\n    int[] parent = new int[n];\n    boolean[] visited = new boolean[n];\n    Arrays.fill(parent, -1);\n\n    Queue<Integer> queue = new LinkedList<>();\n    visited[start] = true;\n    queue.offer(start);\n\n    while (!queue.isEmpty()) {\n        int node = queue.poll();\n\n        if (node == end) break;\n\n        for (int neighbor : graph.get(node)) {\n            if (!visited[neighbor]) {\n                visited[neighbor] = true;\n                parent[neighbor] = node;\n                queue.offer(neighbor);\n            }\n        }\n    }\n\n    // Reconstruct path\n    List<Integer> path = new ArrayList<>();\n    if (!visited[end]) return path; // No path found\n\n    for (int at = end; at != -1; at = parent[at]) {\n        path.add(at);\n    }\n\n    Collections.reverse(path);\n    return path;\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"23-grid-bfs-problems",children:"2.3 Grid BFS Problems"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Shortest Path in Binary Matrix\npublic int shortestPathBinaryMatrix(int[][] grid) {\n    int n = grid.length;\n    if (grid[0][0] != 0 || grid[n-1][n-1] != 0) return -1;\n\n    Queue<int[]> queue = new LinkedList<>();\n    boolean[][] visited = new boolean[n][n];\n    int[][] directions = {{-1,-1}, {-1,0}, {-1,1}, {0,-1}, {0,1}, {1,-1}, {1,0}, {1,1}};\n\n    queue.offer(new int[]{0, 0, 1}); // row, col, distance\n    visited[0][0] = true;\n\n    while (!queue.isEmpty()) {\n        int[] current = queue.poll();\n        int row = current[0], col = current[1], dist = current[2];\n\n        if (row == n-1 && col == n-1) return dist;\n\n        for (int[] dir : directions) {\n            int newRow = row + dir[0];\n            int newCol = col + dir[1];\n\n            if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n &&\n                grid[newRow][newCol] == 0 && !visited[newRow][newCol]) {\n\n                visited[newRow][newCol] = true;\n                queue.offer(new int[]{newRow, newCol, dist + 1});\n            }\n        }\n    }\n\n    return -1;\n}\n\n// Rotting Oranges\npublic int orangesRotting(int[][] grid) {\n    Queue<int[]> queue = new LinkedList<>();\n    int freshCount = 0;\n\n    // Find all rotten oranges and count fresh ones\n    for (int i = 0; i < grid.length; i++) {\n        for (int j = 0; j < grid[0].length; j++) {\n            if (grid[i][j] == 2) {\n                queue.offer(new int[]{i, j});\n            } else if (grid[i][j] == 1) {\n                freshCount++;\n            }\n        }\n    }\n\n    if (freshCount == 0) return 0; // No fresh oranges\n\n    int[][] directions = {{-1,0}, {1,0}, {0,-1}, {0,1}};\n    int minutes = 0;\n\n    while (!queue.isEmpty() && freshCount > 0) {\n        int size = queue.size();\n\n        for (int i = 0; i < size; i++) {\n            int[] current = queue.poll();\n            int row = current[0], col = current[1];\n\n            for (int[] dir : directions) {\n                int newRow = row + dir[0];\n                int newCol = col + dir[1];\n\n                if (newRow >= 0 && newRow < grid.length &&\n                    newCol >= 0 && newCol < grid[0].length &&\n                    grid[newRow][newCol] == 1) {\n\n                    grid[newRow][newCol] = 2; // Rot the orange\n                    freshCount--;\n                    queue.offer(new int[]{newRow, newCol});\n                }\n            }\n        }\n\n        minutes++;\n    }\n\n    return freshCount == 0 ? minutes : -1;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-3-sliding-window-with-queue",children:"Pattern 3: Sliding Window with Queue"}),"\n",(0,t.jsx)(n.h3,{id:"31-moving-average",children:"3.1 Moving Average"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Moving Average from Data Stream\nclass MovingAverage {\n    private Queue<Integer> queue;\n    private int size;\n    private double sum;\n\n    public MovingAverage(int size) {\n        this.queue = new LinkedList<>();\n        this.size = size;\n        this.sum = 0;\n    }\n\n    public double next(int val) {\n        queue.offer(val);\n        sum += val;\n\n        if (queue.size() > size) {\n            sum -= queue.poll();\n        }\n\n        return sum / queue.size();\n    }\n}\n\n// Sliding Window Average for Array\npublic double[] slidingWindowAverage(int[] nums, int k) {\n    double[] result = new double[nums.length - k + 1];\n    Queue<Integer> queue = new LinkedList<>();\n    double sum = 0;\n\n    for (int i = 0; i < nums.length; i++) {\n        queue.offer(nums[i]);\n        sum += nums[i];\n\n        if (queue.size() > k) {\n            sum -= queue.poll();\n        }\n\n        if (queue.size() == k) {\n            result[i - k + 1] = sum / k;\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"32-first-unique-character-in-stream",children:"3.2 First Unique Character in Stream"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// First Unique Character in Data Stream\nclass FirstUnique {\n    private Queue<Integer> queue;\n    private Map<Integer, Integer> count;\n\n    public FirstUnique(int[] nums) {\n        queue = new LinkedList<>();\n        count = new HashMap<>();\n\n        for (int num : nums) {\n            add(num);\n        }\n    }\n\n    public int showFirstUnique() {\n        // Remove non-unique elements from front\n        while (!queue.isEmpty() && count.get(queue.peek()) > 1) {\n            queue.poll();\n        }\n\n        return queue.isEmpty() ? -1 : queue.peek();\n    }\n\n    public void add(int value) {\n        count.put(value, count.getOrDefault(value, 0) + 1);\n\n        if (count.get(value) == 1) {\n            queue.offer(value);\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-4-monotonic-queuedeque",children:"Pattern 4: Monotonic Queue/Deque"}),"\n",(0,t.jsx)(n.h3,{id:"41-sliding-window-maximum",children:"4.1 Sliding Window Maximum"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Sliding Window Maximum using Monotonic Deque\npublic int[] maxSlidingWindow(int[] nums, int k) {\n    Deque<Integer> deque = new ArrayDeque<>(); // Store indices\n    int[] result = new int[nums.length - k + 1];\n\n    for (int i = 0; i < nums.length; i++) {\n        // Remove elements outside current window\n        while (!deque.isEmpty() && deque.peekFirst() < i - k + 1) {\n            deque.pollFirst();\n        }\n\n        // Remove smaller elements from rear (maintain decreasing order)\n        while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {\n            deque.pollLast();\n        }\n\n        deque.offerLast(i);\n\n        // Add to result when window is complete\n        if (i >= k - 1) {\n            result[i - k + 1] = nums[deque.peekFirst()];\n        }\n    }\n\n    return result;\n}\n\n// Generic Monotonic Deque Template\npublic int[] monotonicDequeTemplate(int[] nums, int k, boolean findMax, boolean decreasing) {\n    Deque<Integer> deque = new ArrayDeque<>();\n    int[] result = new int[nums.length - k + 1];\n\n    for (int i = 0; i < nums.length; i++) {\n        // Remove elements outside window\n        while (!deque.isEmpty() && deque.peekFirst() < i - k + 1) {\n            deque.pollFirst();\n        }\n\n        // Maintain monotonic property\n        while (!deque.isEmpty() && shouldRemove(nums, deque.peekLast(), i, decreasing)) {\n            deque.pollLast();\n        }\n\n        deque.offerLast(i);\n\n        if (i >= k - 1) {\n            result[i - k + 1] = nums[findMax ? deque.peekFirst() : deque.peekLast()];\n        }\n    }\n\n    return result;\n}\n\nprivate boolean shouldRemove(int[] nums, int lastIndex, int currentIndex, boolean decreasing) {\n    if (decreasing) {\n        return nums[lastIndex] < nums[currentIndex]; // For max window\n    } else {\n        return nums[lastIndex] > nums[currentIndex]; // For min window\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"42-sliding-window-minimum",children:"4.2 Sliding Window Minimum"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Sliding Window Minimum using Monotonic Deque\npublic int[] minSlidingWindow(int[] nums, int k) {\n    Deque<Integer> deque = new ArrayDeque<>(); // Store indices\n    int[] result = new int[nums.length - k + 1];\n\n    for (int i = 0; i < nums.length; i++) {\n        // Remove elements outside current window\n        while (!deque.isEmpty() && deque.peekFirst() < i - k + 1) {\n            deque.pollFirst();\n        }\n\n        // Remove larger elements from rear (maintain increasing order)\n        while (!deque.isEmpty() && nums[deque.peekLast()] > nums[i]) {\n            deque.pollLast();\n        }\n\n        deque.offerLast(i);\n\n        if (i >= k - 1) {\n            result[i - k + 1] = nums[deque.peekFirst()];\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"43-constrained-subsequence-sum",children:"4.3 Constrained Subsequence Sum"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Constrained Subsequence Sum\npublic int constrainedSubsetSum(int[] nums, int k) {\n    Deque<Integer> deque = new ArrayDeque<>(); // Monotonic decreasing deque\n    int[] dp = new int[nums.length];\n\n    for (int i = 0; i < nums.length; i++) {\n        // Remove elements outside window [i-k, i-1]\n        while (!deque.isEmpty() && deque.peekFirst() < i - k) {\n            deque.pollFirst();\n        }\n\n        // Calculate dp[i]\n        dp[i] = nums[i];\n        if (!deque.isEmpty()) {\n            dp[i] = Math.max(dp[i], nums[i] + dp[deque.peekFirst()]);\n        }\n\n        // Maintain monotonic decreasing property\n        while (!deque.isEmpty() && dp[deque.peekLast()] <= dp[i]) {\n            deque.pollLast();\n        }\n\n        // Only add positive dp values to deque\n        if (dp[i] > 0) {\n            deque.offerLast(i);\n        }\n    }\n\n    return Arrays.stream(dp).max().orElse(0);\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"44-shortest-subarray-with-sum-at-least-k",children:"4.4 Shortest Subarray with Sum at Least K"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Shortest Subarray with Sum at Least K\npublic int shortestSubarray(int[] nums, int k) {\n    int n = nums.length;\n    long[] prefixSum = new long[n + 1];\n\n    // Calculate prefix sums\n    for (int i = 0; i < n; i++) {\n        prefixSum[i + 1] = prefixSum[i] + nums[i];\n    }\n\n    Deque<Integer> deque = new ArrayDeque<>(); // Monotonic increasing deque\n    int minLength = Integer.MAX_VALUE;\n\n    for (int i = 0; i <= n; i++) {\n        // Check if we can form a valid subarray\n        while (!deque.isEmpty() && prefixSum[i] - prefixSum[deque.peekFirst()] >= k) {\n            minLength = Math.min(minLength, i - deque.pollFirst());\n        }\n\n        // Maintain monotonic increasing property\n        while (!deque.isEmpty() && prefixSum[deque.peekLast()] >= prefixSum[i]) {\n            deque.pollLast();\n        }\n\n        deque.offerLast(i);\n    }\n\n    return minLength == Integer.MAX_VALUE ? -1 : minLength;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"45-jump-game-vi",children:"4.5 Jump Game VI"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Jump Game VI\npublic int maxResult(int[] nums, int k) {\n    int n = nums.length;\n    Deque<Integer> deque = new ArrayDeque<>(); // Monotonic decreasing deque\n    int[] dp = new int[n];\n\n    dp[0] = nums[0];\n    deque.offerLast(0);\n\n    for (int i = 1; i < n; i++) {\n        // Remove elements outside jump range\n        while (!deque.isEmpty() && deque.peekFirst() < i - k) {\n            deque.pollFirst();\n        }\n\n        // Calculate maximum score for current position\n        dp[i] = nums[i] + dp[deque.peekFirst()];\n\n        // Maintain monotonic decreasing property\n        while (!deque.isEmpty() && dp[deque.peekLast()] <= dp[i]) {\n            deque.pollLast();\n        }\n\n        deque.offerLast(i);\n    }\n\n    return dp[n - 1];\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-5-priority-queue-patterns",children:"Pattern 5: Priority Queue Patterns"}),"\n",(0,t.jsx)(n.h3,{id:"51-k-closest-points-to-origin",children:"5.1 K Closest Points to Origin"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// K Closest Points to Origin\npublic int[][] kClosest(int[][] points, int k) {\n    PriorityQueue<int[]> maxHeap = new PriorityQueue<>((a, b) ->\n        Integer.compare(distanceSquared(b), distanceSquared(a)));\n\n    for (int[] point : points) {\n        maxHeap.offer(point);\n\n        if (maxHeap.size() > k) {\n            maxHeap.poll();\n        }\n    }\n\n    int[][] result = new int[k][2];\n    for (int i = 0; i < k; i++) {\n        result[i] = maxHeap.poll();\n    }\n\n    return result;\n}\n\nprivate int distanceSquared(int[] point) {\n    return point[0] * point[0] + point[1] * point[1];\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"52-top-k-frequent-elements",children:"5.2 Top K Frequent Elements"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Top K Frequent Elements\npublic int[] topKFrequent(int[] nums, int k) {\n    Map<Integer, Integer> count = new HashMap<>();\n    for (int num : nums) {\n        count.put(num, count.getOrDefault(num, 0) + 1);\n    }\n\n    PriorityQueue<Integer> minHeap = new PriorityQueue<>((a, b) ->\n        Integer.compare(count.get(a), count.get(b)));\n\n    for (int num : count.keySet()) {\n        minHeap.offer(num);\n        if (minHeap.size() > k) {\n            minHeap.poll();\n        }\n    }\n\n    int[] result = new int[k];\n    for (int i = k - 1; i >= 0; i--) {\n        result[i] = minHeap.poll();\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"53-merge-k-sorted-lists",children:"5.3 Merge K Sorted Lists"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Merge K Sorted Lists\npublic ListNode mergeKLists(ListNode[] lists) {\n    if (lists == null || lists.length == 0) return null;\n\n    PriorityQueue<ListNode> minHeap = new PriorityQueue<>((a, b) ->\n        Integer.compare(a.val, b.val));\n\n    // Add all non-null heads to heap\n    for (ListNode head : lists) {\n        if (head != null) {\n            minHeap.offer(head);\n        }\n    }\n\n    ListNode dummy = new ListNode(0);\n    ListNode current = dummy;\n\n    while (!minHeap.isEmpty()) {\n        ListNode node = minHeap.poll();\n        current.next = node;\n        current = current.next;\n\n        if (node.next != null) {\n            minHeap.offer(node.next);\n        }\n    }\n\n    return dummy.next;\n}\n\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode() {}\n    ListNode(int val) { this.val = val; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-6-circular-queue--design",children:"Pattern 6: Circular Queue & Design"}),"\n",(0,t.jsx)(n.h3,{id:"61-design-circular-queue",children:"6.1 Design Circular Queue"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Design Circular Queue\nclass MyCircularQueue {\n    private int[] queue;\n    private int front;\n    private int rear;\n    private int size;\n    private int capacity;\n\n    public MyCircularQueue(int k) {\n        this.capacity = k;\n        this.queue = new int[k];\n        this.front = 0;\n        this.rear = -1;\n        this.size = 0;\n    }\n\n    public boolean enQueue(int value) {\n        if (isFull()) return false;\n\n        rear = (rear + 1) % capacity;\n        queue[rear] = value;\n        size++;\n        return true;\n    }\n\n    public boolean deQueue() {\n        if (isEmpty()) return false;\n\n        front = (front + 1) % capacity;\n        size--;\n        return true;\n    }\n\n    public int Front() {\n        return isEmpty() ? -1 : queue[front];\n    }\n\n    public int Rear() {\n        return isEmpty() ? -1 : queue[rear];\n    }\n\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    public boolean isFull() {\n        return size == capacity;\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"62-design-circular-deque",children:"6.2 Design Circular Deque"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Design Circular Deque\nclass MyCircularDeque {\n    private int[] deque;\n    private int front;\n    private int rear;\n    private int size;\n    private int capacity;\n\n    public MyCircularDeque(int k) {\n        this.capacity = k;\n        this.deque = new int[k];\n        this.front = 0;\n        this.rear = k - 1; // rear points to last element\n        this.size = 0;\n    }\n\n    public boolean insertFront(int value) {\n        if (isFull()) return false;\n\n        front = (front - 1 + capacity) % capacity;\n        deque[front] = value;\n        size++;\n        return true;\n    }\n\n    public boolean insertLast(int value) {\n        if (isFull()) return false;\n\n        rear = (rear + 1) % capacity;\n        deque[rear] = value;\n        size++;\n        return true;\n    }\n\n    public boolean deleteFront() {\n        if (isEmpty()) return false;\n\n        front = (front + 1) % capacity;\n        size--;\n        return true;\n    }\n\n    public boolean deleteLast() {\n        if (isEmpty()) return false;\n\n        rear = (rear - 1 + capacity) % capacity;\n        size--;\n        return true;\n    }\n\n    public int getFront() {\n        return isEmpty() ? -1 : deque[front];\n    }\n\n    public int getRear() {\n        return isEmpty() ? -1 : deque[rear];\n    }\n\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    public boolean isFull() {\n        return size == capacity;\n    }\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-7-multi-level-bfs",children:"Pattern 7: Multi-level BFS"}),"\n",(0,t.jsx)(n.h3,{id:"71-word-ladder",children:"7.1 Word Ladder"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Word Ladder\npublic int ladderLength(String beginWord, String endWord, List<String> wordList) {\n    Set<String> wordSet = new HashSet<>(wordList);\n    if (!wordSet.contains(endWord)) return 0;\n\n    Queue<String> queue = new LinkedList<>();\n    Set<String> visited = new HashSet<>();\n\n    queue.offer(beginWord);\n    visited.add(beginWord);\n    int level = 1;\n\n    while (!queue.isEmpty()) {\n        int size = queue.size();\n\n        for (int i = 0; i < size; i++) {\n            String word = queue.poll();\n\n            if (word.equals(endWord)) return level;\n\n            // Generate all possible next words\n            for (int j = 0; j < word.length(); j++) {\n                char[] chars = word.toCharArray();\n\n                for (char c = 'a'; c <= 'z'; c++) {\n                    chars[j] = c;\n                    String newWord = new String(chars);\n\n                    if (wordSet.contains(newWord) && !visited.contains(newWord)) {\n                        visited.add(newWord);\n                        queue.offer(newWord);\n                    }\n                }\n            }\n        }\n\n        level++;\n    }\n\n    return 0;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"72-open-the-lock",children:"7.2 Open the Lock"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// Open the Lock\npublic int openLock(String[] deadends, String target) {\n    Set<String> deadSet = new HashSet<>(Arrays.asList(deadends));\n    if (deadSet.contains("0000")) return -1;\n\n    Queue<String> queue = new LinkedList<>();\n    Set<String> visited = new HashSet<>();\n\n    queue.offer("0000");\n    visited.add("0000");\n    int steps = 0;\n\n    while (!queue.isEmpty()) {\n        int size = queue.size();\n\n        for (int i = 0; i < size; i++) {\n            String current = queue.poll();\n\n            if (current.equals(target)) return steps;\n\n            // Generate all possible next states\n            for (int j = 0; j < 4; j++) {\n                String next1 = turnWheel(current, j, 1);\n                String next2 = turnWheel(current, j, -1);\n\n                if (!deadSet.contains(next1) && !visited.contains(next1)) {\n                    visited.add(next1);\n                    queue.offer(next1);\n                }\n\n                if (!deadSet.contains(next2) && !visited.contains(next2)) {\n                    visited.add(next2);\n                    queue.offer(next2);\n                }\n            }\n        }\n\n        steps++;\n    }\n\n    return -1;\n}\n\nprivate String turnWheel(String combination, int pos, int direction) {\n    char[] chars = combination.toCharArray();\n    int digit = chars[pos] - \'0\';\n\n    if (direction == 1) {\n        digit = (digit + 1) % 10;\n    } else {\n        digit = (digit - 1 + 10) % 10;\n    }\n\n    chars[pos] = (char) (\'0\' + digit);\n    return new String(chars);\n}\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-8-queue-based-simulation",children:"Pattern 8: Queue-based Simulation"}),"\n",(0,t.jsx)(n.h3,{id:"81-design-hit-counter",children:"8.1 Design Hit Counter"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Design Hit Counter\nclass HitCounter {\n    private Queue<Integer> hits;\n\n    public HitCounter() {\n        hits = new LinkedList<>();\n    }\n\n    public void hit(int timestamp) {\n        hits.offer(timestamp);\n    }\n\n    public int getHits(int timestamp) {\n        // Remove hits older than 300 seconds\n        while (!hits.isEmpty() && hits.peek() <= timestamp - 300) {\n            hits.poll();\n        }\n\n        return hits.size();\n    }\n}\n\n// Optimized Hit Counter using Buckets\nclass HitCounterOptimized {\n    private int[] times;\n    private int[] hits;\n\n    public HitCounterOptimized() {\n        times = new int[300];\n        hits = new int[300];\n    }\n\n    public void hit(int timestamp) {\n        int index = timestamp % 300;\n        if (times[index] != timestamp) {\n            times[index] = timestamp;\n            hits[index] = 1;\n        } else {\n            hits[index]++;\n        }\n    }\n\n    public int getHits(int timestamp) {\n        int total = 0;\n        for (int i = 0; i < 300; i++) {\n            if (timestamp - times[i] < 300) {\n                total += hits[i];\n            }\n        }\n        return total;\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"82-design-snake-game",children:"8.2 Design Snake Game"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// Design Snake Game\nclass SnakeGame {\n    private int width;\n    private int height;\n    private int[][] food;\n    private int foodIndex;\n    private Set<String> snakeSet;\n    private Deque<int[]> snake;\n\n    public SnakeGame(int width, int height, int[][] food) {\n        this.width = width;\n        this.height = height;\n        this.food = food;\n        this.foodIndex = 0;\n        this.snakeSet = new HashSet<>();\n        this.snake = new LinkedList<>();\n\n        // Initialize snake at (0, 0)\n        snake.offerLast(new int[]{0, 0});\n        snakeSet.add("0,0");\n    }\n\n    public int move(String direction) {\n        int[] head = snake.peekFirst();\n        int newRow = head[0];\n        int newCol = head[1];\n\n        // Calculate new head position\n        switch (direction) {\n            case "U": newRow--; break;\n            case "D": newRow++; break;\n            case "L": newCol--; break;\n            case "R": newCol++; break;\n        }\n\n        // Check boundary collision\n        if (newRow < 0 || newRow >= height || newCol < 0 || newCol >= width) {\n            return -1;\n        }\n\n        // Check if eating food\n        boolean ateFood = false;\n        if (foodIndex < food.length &&\n            newRow == food[foodIndex][0] && newCol == food[foodIndex][1]) {\n            ateFood = true;\n            foodIndex++;\n        }\n\n        // Remove tail if not eating food\n        if (!ateFood) {\n            int[] tail = snake.pollLast();\n            snakeSet.remove(tail[0] + "," + tail[1]);\n        }\n\n        // Check self collision\n        if (snakeSet.contains(newRow + "," + newCol)) {\n            return -1;\n        }\n\n        // Add new head\n        snake.offerFirst(new int[]{newRow, newCol});\n        snakeSet.add(newRow + "," + newCol);\n\n        return snake.size() - 1; // Score is length - 1\n    }\n}\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-9-queue-for-tree-problems",children:"Pattern 9: Queue for Tree Problems"}),"\n",(0,t.jsx)(n.h3,{id:"91-populating-next-right-pointers",children:"9.1 Populating Next Right Pointers"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Populating Next Right Pointers in Each Node\npublic Node connect(Node root) {\n    if (root == null) return null;\n\n    Queue<Node> queue = new LinkedList<>();\n    queue.offer(root);\n\n    while (!queue.isEmpty()) {\n        int size = queue.size();\n        Node prev = null;\n\n        for (int i = 0; i < size; i++) {\n            Node current = queue.poll();\n\n            if (prev != null) {\n                prev.next = current;\n            }\n            prev = current;\n\n            if (current.left != null) queue.offer(current.left);\n            if (current.right != null) queue.offer(current.right);\n        }\n    }\n\n    return root;\n}\n\nclass Node {\n    public int val;\n    public Node left;\n    public Node right;\n    public Node next;\n\n    public Node() {}\n    public Node(int val) { this.val = val; }\n    public Node(int val, Node left, Node right, Node next) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n        this.next = next;\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"92-binary-tree-right-side-view",children:"9.2 Binary Tree Right Side View"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Binary Tree Right Side View\npublic List<Integer> rightSideView(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n    if (root == null) return result;\n\n    Queue<TreeNode> queue = new LinkedList<>();\n    queue.offer(root);\n\n    while (!queue.isEmpty()) {\n        int size = queue.size();\n\n        for (int i = 0; i < size; i++) {\n            TreeNode node = queue.poll();\n\n            // Add the rightmost node of each level\n            if (i == size - 1) {\n                result.add(node.val);\n            }\n\n            if (node.left != null) queue.offer(node.left);\n            if (node.right != null) queue.offer(node.right);\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-10-advanced-queue-applications",children:"Pattern 10: Advanced Queue Applications"}),"\n",(0,t.jsx)(n.h3,{id:"101-shortest-bridge",children:"10.1 Shortest Bridge"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Shortest Bridge\npublic int shortestBridge(int[][] grid) {\n    int n = grid.length;\n    Queue<int[]> queue = new LinkedList<>();\n    boolean found = false;\n\n    // Find first island and mark it\n    for (int i = 0; i < n && !found; i++) {\n        for (int j = 0; j < n && !found; j++) {\n            if (grid[i][j] == 1) {\n                dfsMarkIsland(grid, i, j, queue);\n                found = true;\n            }\n        }\n    }\n\n    // BFS to find shortest path to second island\n    int[][] directions = {{-1,0}, {1,0}, {0,-1}, {0,1}};\n    int steps = 0;\n\n    while (!queue.isEmpty()) {\n        int size = queue.size();\n\n        for (int i = 0; i < size; i++) {\n            int[] current = queue.poll();\n            int row = current[0], col = current[1];\n\n            for (int[] dir : directions) {\n                int newRow = row + dir[0];\n                int newCol = col + dir[1];\n\n                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n) {\n                    if (grid[newRow][newCol] == 1) {\n                        return steps; // Found second island\n                    }\n                    if (grid[newRow][newCol] == 0) {\n                        grid[newRow][newCol] = 2; // Mark as visited\n                        queue.offer(new int[]{newRow, newCol});\n                    }\n                }\n            }\n        }\n\n        steps++;\n    }\n\n    return steps;\n}\n\nprivate void dfsMarkIsland(int[][] grid, int row, int col, Queue<int[]> queue) {\n    if (row < 0 || row >= grid.length || col < 0 || col >= grid[0].length ||\n        grid[row][col] != 1) {\n        return;\n    }\n\n    grid[row][col] = 2; // Mark as first island\n    queue.offer(new int[]{row, col});\n\n    dfsMarkIsland(grid, row + 1, col, queue);\n    dfsMarkIsland(grid, row - 1, col, queue);\n    dfsMarkIsland(grid, row, col + 1, queue);\n    dfsMarkIsland(grid, row, col - 1, queue);\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"102-walls-and-gates",children:"10.2 Walls and Gates"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Walls and Gates\npublic void wallsAndGates(int[][] rooms) {\n    Queue<int[]> queue = new LinkedList<>();\n    int[][] directions = {{-1,0}, {1,0}, {0,-1}, {0,1}};\n\n    // Find all gates and add to queue\n    for (int i = 0; i < rooms.length; i++) {\n        for (int j = 0; j < rooms[0].length; j++) {\n            if (rooms[i][j] == 0) {\n                queue.offer(new int[]{i, j});\n            }\n        }\n    }\n\n    // Multi-source BFS\n    while (!queue.isEmpty()) {\n        int[] current = queue.poll();\n        int row = current[0], col = current[1];\n\n        for (int[] dir : directions) {\n            int newRow = row + dir[0];\n            int newCol = col + dir[1];\n\n            if (newRow >= 0 && newRow < rooms.length &&\n                newCol >= 0 && newCol < rooms[0].length &&\n                rooms[newRow][newCol] == Integer.MAX_VALUE) {\n\n                rooms[newRow][newCol] = rooms[row][col] + 1;\n                queue.offer(new int[]{newRow, newCol});\n            }\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-11-concurrent-queue-patterns",children:"Pattern 11: Concurrent Queue Patterns"}),"\n",(0,t.jsx)(n.h3,{id:"111-producer-consumer-with-blockingqueue",children:"11.1 Producer-Consumer with BlockingQueue"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// Producer-Consumer Pattern\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\n\nclass ProducerConsumerExample {\n    private BlockingQueue<Integer> queue = new LinkedBlockingQueue<>(10);\n\n    class Producer implements Runnable {\n        @Override\n        public void run() {\n            try {\n                for (int i = 0; i < 20; i++) {\n                    queue.put(i); // Blocks if queue is full\n                    System.out.println("Produced: " + i);\n                    Thread.sleep(100);\n                }\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    class Consumer implements Runnable {\n        @Override\n        public void run() {\n            try {\n                while (true) {\n                    Integer item = queue.take(); // Blocks if queue is empty\n                    System.out.println("Consumed: " + item);\n                    Thread.sleep(150);\n                }\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    public void start() {\n        new Thread(new Producer()).start();\n        new Thread(new Consumer()).start();\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"112-rate-limiter-with-queue",children:"11.2 Rate Limiter with Queue"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Token Bucket Rate Limiter\nclass TokenBucketRateLimiter {\n    private final Queue<Long> tokens;\n    private final int capacity;\n    private final long refillRate; // tokens per second\n    private long lastRefillTime;\n\n    public TokenBucketRateLimiter(int capacity, long refillRate) {\n        this.capacity = capacity;\n        this.refillRate = refillRate;\n        this.tokens = new LinkedList<>();\n        this.lastRefillTime = System.currentTimeMillis();\n\n        // Fill initial tokens\n        for (int i = 0; i < capacity; i++) {\n            tokens.offer(System.currentTimeMillis());\n        }\n    }\n\n    public synchronized boolean tryAcquire() {\n        refillTokens();\n\n        if (!tokens.isEmpty()) {\n            tokens.poll();\n            return true;\n        }\n\n        return false;\n    }\n\n    private void refillTokens() {\n        long now = System.currentTimeMillis();\n        long timeElapsed = now - lastRefillTime;\n        long tokensToAdd = (timeElapsed * refillRate) / 1000;\n\n        for (long i = 0; i < tokensToAdd && tokens.size() < capacity; i++) {\n            tokens.offer(now);\n        }\n\n        lastRefillTime = now;\n    }\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pattern-12-complex-queue-problems",children:"Pattern 12: Complex Queue Problems"}),"\n",(0,t.jsx)(n.h3,{id:"121-sliding-window-median",children:"12.1 Sliding Window Median"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Sliding Window Median using Two Priority Queues\npublic double[] medianSlidingWindow(int[] nums, int k) {\n    PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\n    PriorityQueue<Integer> minHeap = new PriorityQueue<>();\n    double[] result = new double[nums.length - k + 1];\n\n    for (int i = 0; i < nums.length; i++) {\n        // Add number\n        if (maxHeap.isEmpty() || nums[i] <= maxHeap.peek()) {\n            maxHeap.offer(nums[i]);\n        } else {\n            minHeap.offer(nums[i]);\n        }\n\n        // Remove number outside window\n        if (i >= k) {\n            int toRemove = nums[i - k];\n            if (toRemove <= maxHeap.peek()) {\n                maxHeap.remove(toRemove);\n            } else {\n                minHeap.remove(toRemove);\n            }\n        }\n\n        // Balance heaps\n        if (maxHeap.size() > minHeap.size() + 1) {\n            minHeap.offer(maxHeap.poll());\n        } else if (minHeap.size() > maxHeap.size() + 1) {\n            maxHeap.offer(minHeap.poll());\n        }\n\n        // Calculate median when window is complete\n        if (i >= k - 1) {\n            if (k % 2 == 1) {\n                result[i - k + 1] = maxHeap.size() > minHeap.size() ?\n                    maxHeap.peek() : minHeap.peek();\n            } else {\n                result[i - k + 1] = ((double) maxHeap.peek() + minHeap.peek()) / 2.0;\n            }\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"122-find-median-from-data-stream",children:"12.2 Find Median from Data Stream"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Find Median from Data Stream\nclass MedianFinder {\n    private PriorityQueue<Integer> maxHeap; // Lower half\n    private PriorityQueue<Integer> minHeap; // Upper half\n\n    public MedianFinder() {\n        maxHeap = new PriorityQueue<>(Collections.reverseOrder());\n        minHeap = new PriorityQueue<>();\n    }\n\n    public void addNum(int num) {\n        if (maxHeap.isEmpty() || num <= maxHeap.peek()) {\n            maxHeap.offer(num);\n        } else {\n            minHeap.offer(num);\n        }\n\n        // Balance heaps\n        if (maxHeap.size() > minHeap.size() + 1) {\n            minHeap.offer(maxHeap.poll());\n        } else if (minHeap.size() > maxHeap.size() + 1) {\n            maxHeap.offer(minHeap.poll());\n        }\n    }\n\n    public double findMedian() {\n        if (maxHeap.size() == minHeap.size()) {\n            return ((double) maxHeap.peek() + minHeap.peek()) / 2.0;\n        } else {\n            return maxHeap.size() > minHeap.size() ? maxHeap.peek() : minHeap.peek();\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"time--space-complexity-reference",children:"Time & Space Complexity Reference"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{style:{textAlign:"left"},children:"Pattern"}),(0,t.jsx)(n.th,{style:{textAlign:"left"},children:"Time Complexity"}),(0,t.jsx)(n.th,{style:{textAlign:"left"},children:"Space Complexity"}),(0,t.jsx)(n.th,{style:{textAlign:"left"},children:"Key Characteristics"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Basic Queue Ops"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(1) per operation"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Enqueue, Dequeue in constant time"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"BFS Traversal"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(V + E)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(V)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Visit each vertex/edge once"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Level Order"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(w)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"w = maximum width of tree"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Monotonic Deque"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(k)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Each element added/removed once"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Sliding Window"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(k)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"k = window size"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Priority Queue"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(log n) per operation"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Heap-based operations"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Multi-source BFS"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(V + E)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(V)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Multiple starting points"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Circular Queue"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(1) per operation"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(k)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Fixed size, circular indexing"})]})]})]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"best-practices--optimization-tips",children:"Best Practices & Optimization Tips"}),"\n",(0,t.jsx)(n.h3,{id:"queue-implementation-guidelines",children:"Queue Implementation Guidelines"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Prefer ArrayDeque over LinkedList for better performance\nDeque<Integer> deque = new ArrayDeque<>(); // Faster than LinkedList\n\n// Use appropriate queue type for the use case\nQueue<Integer> queue = new LinkedList<>();     // General purpose\nPriorityQueue<Integer> pq = new PriorityQueue<>(); // Ordered processing\nBlockingQueue<Integer> bq = new LinkedBlockingQueue<>(); // Thread-safe\n\n// Monotonic Deque Template\npublic int[] monotonicDequePattern(int[] nums, int k) {\n    Deque<Integer> deque = new ArrayDeque<>();\n    int[] result = new int[nums.length - k + 1];\n\n    for (int i = 0; i < nums.length; i++) {\n        // Remove elements outside window\n        while (!deque.isEmpty() && deque.peekFirst() < i - k + 1) {\n            deque.pollFirst();\n        }\n\n        // Maintain monotonic property\n        while (!deque.isEmpty() && shouldRemove(nums, deque.peekLast(), i)) {\n            deque.pollLast();\n        }\n\n        deque.offerLast(i);\n\n        if (i >= k - 1) {\n            result[i - k + 1] = nums[deque.peekFirst()];\n        }\n    }\n\n    return result;\n}\n\nboolean shouldRemove(int[] nums, int lastIndex, int currentIndex) {\n    // Implement based on specific problem requirements\n    return nums[lastIndex] < nums[currentIndex]; // For maximum window\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"common-optimizations",children:"Common Optimizations"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// 1. Use indices instead of values for flexibility\nDeque<Integer> indices = new ArrayDeque<>();\n\n// 2. Combine operations when possible\npublic void processWindow(int[] nums, int k) {\n    // Process multiple sliding window operations in single pass\n    Deque<Integer> maxDeque = new ArrayDeque<>();\n    Deque<Integer> minDeque = new ArrayDeque<>();\n\n    for (int i = 0; i < nums.length; i++) {\n        // Maintain both max and min windows simultaneously\n        updateMaxWindow(maxDeque, nums, i, k);\n        updateMinWindow(minDeque, nums, i, k);\n\n        if (i >= k - 1) {\n            int max = nums[maxDeque.peekFirst()];\n            int min = nums[minDeque.peekFirst()];\n            // Process both values\n        }\n    }\n}\n\n// 3. Early termination in BFS\npublic boolean bfsEarlyTermination(int[][] grid, int target) {\n    Queue<int[]> queue = new LinkedList<>();\n    // ... initialization\n\n    while (!queue.isEmpty()) {\n        int[] current = queue.poll();\n        if (current[0] == target) return true; // Early return\n\n        // Continue BFS...\n    }\n    return false;\n}\n\nvoid updateMaxWindow(Deque<Integer> deque, int[] nums, int i, int k) { /* Implementation */ }\nvoid updateMinWindow(Deque<Integer> deque, int[] nums, int i, int k) { /* Implementation */ }\n"})}),"\n",(0,t.jsx)(n.h3,{id:"interview-tips",children:"Interview Tips"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Identify the pattern"})," early: BFS for shortest path, monotonic deque for sliding window extremes"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Choose the right queue type"}),": ArrayDeque for general use, PriorityQueue for ordered processing"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Handle edge cases"}),": empty queues, single elements, window size edge cases"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Consider space optimization"}),": use indices instead of storing large objects"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Think about concurrency"}),": use BlockingQueue for multi-threaded scenarios"]}),"\n"]})]})}function c(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>l});var t=i(6540);const r={},u=t.createContext(r);function s(e){const n=t.useContext(u);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),t.createElement(u.Provider,{value:n},e.children)}}}]);