"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[9027],{28453:(n,e,t)=>{t.d(e,{R:()=>s,x:()=>l});var i=t(96540);const r={},a=i.createContext(r);function s(n){const e=i.useContext(a);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:s(n.components),i.createElement(a.Provider,{value:e},n.children)}},73148:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>o,contentTitle:()=>s,default:()=>c,frontMatter:()=>a,metadata:()=>l,toc:()=>d});var i=t(74848),r=t(28453);const a={},s="Intervals",l={id:"DSA/DSA with Java/Intervals Patterns",title:"Intervals",description:"Table of Contents",source:"@site/docs/DSA/DSA with Java/Intervals Patterns.mdx",sourceDirName:"DSA/DSA with Java",slug:"/DSA/DSA with Java/Intervals Patterns",permalink:"/docs/DSA/DSA with Java/Intervals Patterns",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with Java/Intervals Patterns.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Grid-Based Graph",permalink:"/docs/DSA/DSA with Java/Grid Based Graph Patterns"},next:{title:"Java DSA Fundamentals",permalink:"/docs/DSA/DSA with Java/Java DSA Fundamentals"}},o={},d=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Interval Fundamentals",id:"interval-fundamentals",level:2},{value:"Basic Interval Class",id:"basic-interval-class",level:3},{value:"Common Interval Operations",id:"common-interval-operations",level:3},{value:"Pattern 1: Merge Intervals",id:"pattern-1-merge-intervals",level:2},{value:"1.1 Basic Merge Intervals",id:"11-basic-merge-intervals",level:3},{value:"1.2 Merge Intervals with Custom Object",id:"12-merge-intervals-with-custom-object",level:3},{value:"1.3 Merge with Employee Free Time",id:"13-merge-with-employee-free-time",level:3},{value:"1.4 Merge Similar Items",id:"14-merge-similar-items",level:3},{value:"Pattern 2: Insert &amp; Delete Intervals",id:"pattern-2-insert--delete-intervals",level:2},{value:"2.1 Insert Interval",id:"21-insert-interval",level:3},{value:"2.2 Remove Interval",id:"22-remove-interval",level:3},{value:"2.3 Insert with Merge",id:"23-insert-with-merge",level:3},{value:"2.4 Replace Interval",id:"24-replace-interval",level:3},{value:"Pattern 3: Interval Intersection",id:"pattern-3-interval-intersection",level:2},{value:"3.1 Interval List Intersections",id:"31-interval-list-intersections",level:3},{value:"3.2 Multiple Interval Intersections",id:"32-multiple-interval-intersections",level:3},{value:"3.3 Find Intersection Points",id:"33-find-intersection-points",level:3},{value:"3.4 Intersect and Count",id:"34-intersect-and-count",level:3},{value:"Pattern 4: Non-Overlapping Intervals",id:"pattern-4-non-overlapping-intervals",level:2},{value:"4.1 Minimum Intervals to Remove",id:"41-minimum-intervals-to-remove",level:3},{value:"4.2 Maximum Non-Overlapping Intervals",id:"42-maximum-non-overlapping-intervals",level:3},{value:"4.3 Minimum Arrows to Burst Balloons",id:"43-minimum-arrows-to-burst-balloons",level:3},{value:"4.4 Non-Overlapping Activity Selection",id:"44-non-overlapping-activity-selection",level:3},{value:"Pattern 5: Meeting Room Problems",id:"pattern-5-meeting-room-problems",level:2},{value:"5.1 Meeting Rooms I",id:"51-meeting-rooms-i",level:3},{value:"5.2 Meeting Rooms II",id:"52-meeting-rooms-ii",level:3},{value:"5.3 Meeting Rooms III",id:"53-meeting-rooms-iii",level:3},{value:"5.4 Conference Room Allocation",id:"54-conference-room-allocation",level:3},{value:"Pattern 6: Line Sweep Algorithm",id:"pattern-6-line-sweep-algorithm",level:2},{value:"6.1 Basic Line Sweep Template",id:"61-basic-line-sweep-template",level:3},{value:"6.2 Maximum Overlap Count",id:"62-maximum-overlap-count",level:3},{value:"6.3 Find All Overlap Points",id:"63-find-all-overlap-points",level:3},{value:"6.4 Line Sweep for Rectangle Area",id:"64-line-sweep-for-rectangle-area",level:3},{value:"6.5 Closest Pair Using Line Sweep",id:"65-closest-pair-using-line-sweep",level:3},{value:"Pattern 7: Point Coverage",id:"pattern-7-point-coverage",level:2},{value:"7.1 Minimum Points to Cover Intervals",id:"71-minimum-points-to-cover-intervals",level:3},{value:"7.2 Points Covered by Intervals",id:"72-points-covered-by-intervals",level:3},{value:"7.3 Interval Coverage by Points",id:"73-interval-coverage-by-points",level:3},{value:"7.4 Minimum Intervals to Remove for Point Coverage",id:"74-minimum-intervals-to-remove-for-point-coverage",level:3},{value:"Pattern 8: Interval Scheduling",id:"pattern-8-interval-scheduling",level:2},{value:"8.1 Weighted Job Scheduling",id:"81-weighted-job-scheduling",level:3},{value:"8.2 Maximum CPU Load",id:"82-maximum-cpu-load",level:3},{value:"8.3 Task Scheduler with Intervals",id:"83-task-scheduler-with-intervals",level:3},{value:"8.4 Minimum Platforms for Trains",id:"84-minimum-platforms-for-trains",level:3},{value:"Pattern 9: Time-based Problems",id:"pattern-9-time-based-problems",level:2},{value:"9.1 Car Pooling",id:"91-car-pooling",level:3},{value:"9.2 Corporate Flight Bookings",id:"92-corporate-flight-bookings",level:3},{value:"9.3 Process Transactions",id:"93-process-transactions",level:3},{value:"9.4 Time-based Key-Value Store",id:"94-time-based-key-value-store",level:3},{value:"Pattern 10: Range Sum &amp; Query",id:"pattern-10-range-sum--query",level:2},{value:"10.1 Range Sum Query with Updates",id:"101-range-sum-query-with-updates",level:3},{value:"10.2 Range Addition",id:"102-range-addition",level:3},{value:"10.3 My Calendar",id:"103-my-calendar",level:3},{value:"10.4 My Calendar II (Double Booking)",id:"104-my-calendar-ii-double-booking",level:3},{value:"Pattern 11: Calendar Problems",id:"pattern-11-calendar-problems",level:2},{value:"11.1 My Calendar III",id:"111-my-calendar-iii",level:3},{value:"11.2 Event Availability",id:"112-event-availability",level:3},{value:"11.3 Exam Room",id:"113-exam-room",level:3},{value:"11.4 Design Hit Counter",id:"114-design-hit-counter",level:3},{value:"Pattern 12: Advanced Interval Patterns",id:"pattern-12-advanced-interval-patterns",level:2},{value:"12.1 Skyline Problem",id:"121-skyline-problem",level:3},{value:"12.2 Falling Squares",id:"122-falling-squares",level:3},{value:"12.3 Rectangle Area II",id:"123-rectangle-area-ii",level:3},{value:"12.4 Data Stream as Disjoint Intervals",id:"124-data-stream-as-disjoint-intervals",level:3},{value:"Time Complexity Reference",id:"time-complexity-reference",level:2},{value:"Common Interval Patterns Summary",id:"common-interval-patterns-summary",level:2}];function v(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"intervals",children:"Intervals"})}),"\n",(0,i.jsx)(e.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#interval-fundamentals",children:"Interval Fundamentals"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#pattern-1-merge-intervals",children:"Pattern 1: Merge Intervals"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#pattern-2-insert--delete-intervals",children:"Pattern 2: Insert & Delete Intervals"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#pattern-3-interval-intersection",children:"Pattern 3: Interval Intersection"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#pattern-4-non-overlapping-intervals",children:"Pattern 4: Non-Overlapping Intervals"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#pattern-5-meeting-room-problems",children:"Pattern 5: Meeting Room Problems"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#pattern-6-line-sweep-algorithm",children:"Pattern 6: Line Sweep Algorithm"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#pattern-7-point-coverage",children:"Pattern 7: Point Coverage"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#pattern-8-interval-scheduling",children:"Pattern 8: Interval Scheduling"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#pattern-9-time-based-problems",children:"Pattern 9: Time-based Problems"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#pattern-10-range-sum--query",children:"Pattern 10: Range Sum & Query"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#pattern-11-calendar-problems",children:"Pattern 11: Calendar Problems"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#pattern-12-advanced-interval-patterns",children:"Pattern 12: Advanced Interval Patterns"})}),"\n"]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"interval-fundamentals",children:"Interval Fundamentals"}),"\n",(0,i.jsx)(e.h3,{id:"basic-interval-class",children:"Basic Interval Class"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'class Interval {\n    int start;\n    int end;\n\n    public Interval(int start, int end) {\n        this.start = start;\n        this.end = end;\n    }\n\n    public boolean overlaps(Interval other) {\n        return this.start < other.end && other.start < this.end;\n    }\n\n    public Interval merge(Interval other) {\n        return new Interval(Math.min(this.start, other.start),\n                           Math.max(this.end, other.end));\n    }\n\n    public boolean contains(int point) {\n        return this.start <= point && point < this.end;\n    }\n\n    @Override\n    public String toString() {\n        return "[" + start + "," + end + "]";\n    }\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"common-interval-operations",children:"Common Interval Operations"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"public class IntervalUtils {\n\n    // Check if two intervals overlap\n    public static boolean overlap(int[] a, int[] b) {\n        return a[0] < b[1] && b[0] < a[1];\n    }\n\n    // Get overlap between two intervals\n    public static int[] getOverlap(int[] a, int[] b) {\n        if (!overlap(a, b)) return null;\n        return new int[]{Math.max(a[0], b[0]), Math.min(a[1], b[1])};\n    }\n\n    // Merge two overlapping intervals\n    public static int[] merge(int[] a, int[] b) {\n        return new int[]{Math.min(a[0], b[0]), Math.max(a[1], b[1])};\n    }\n\n    // Get gap between two non-overlapping intervals\n    public static int[] getGap(int[] a, int[] b) {\n        if (overlap(a, b)) return null;\n        if (a[1] <= b[0]) return new int[]{a[1], b[0]};\n        return new int[]{b[1], a[0]};\n    }\n\n    // Sort intervals by start time\n    public static void sortByStart(int[][] intervals) {\n        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\n    }\n\n    // Sort intervals by end time\n    public static void sortByEnd(int[][] intervals) {\n        Arrays.sort(intervals, (a, b) -> a[1] - b[1]);\n    }\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"pattern-1-merge-intervals",children:"Pattern 1: Merge Intervals"}),"\n",(0,i.jsx)(e.h3,{id:"11-basic-merge-intervals",children:"1.1 Basic Merge Intervals"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"int[][] merge(int[][] intervals) {\n    if (intervals.length <= 1) return intervals;\n\n    // Sort by start time\n    Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\n\n    List<int[]> result = new ArrayList<>();\n    int[] current = intervals[0];\n\n    for (int i = 1; i < intervals.length; i++) {\n        if (current[1] >= intervals[i][0]) {\n            // Overlapping, merge\n            current[1] = Math.max(current[1], intervals[i][1]);\n        } else {\n            // Non-overlapping, add current and start new\n            result.add(current);\n            current = intervals[i];\n        }\n    }\n\n    result.add(current);\n    return result.toArray(new int[result.size()][]);\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"12-merge-intervals-with-custom-object",children:"1.2 Merge Intervals with Custom Object"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"class Interval {\n    int start, end;\n    Interval(int start, int end) {\n        this.start = start;\n        this.end = end;\n    }\n}\n\nList<Interval> mergeIntervals(List<Interval> intervals) {\n    if (intervals.size() <= 1) return intervals;\n\n    intervals.sort((a, b) -> a.start - b.start);\n\n    List<Interval> result = new ArrayList<>();\n    Interval current = intervals.get(0);\n\n    for (int i = 1; i < intervals.size(); i++) {\n        Interval next = intervals.get(i);\n\n        if (current.end >= next.start) {\n            current.end = Math.max(current.end, next.end);\n        } else {\n            result.add(current);\n            current = next;\n        }\n    }\n\n    result.add(current);\n    return result;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"13-merge-with-employee-free-time",children:"1.3 Merge with Employee Free Time"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"List<Interval> employeeFreeTime(List<List<Interval>> schedule) {\n    List<Interval> allIntervals = new ArrayList<>();\n\n    // Collect all intervals\n    for (List<Interval> employee : schedule) {\n        allIntervals.addAll(employee);\n    }\n\n    // Sort by start time\n    allIntervals.sort((a, b) -> a.start - b.start);\n\n    // Merge overlapping intervals\n    List<Interval> merged = new ArrayList<>();\n    Interval current = allIntervals.get(0);\n\n    for (int i = 1; i < allIntervals.size(); i++) {\n        Interval next = allIntervals.get(i);\n\n        if (current.end >= next.start) {\n            current.end = Math.max(current.end, next.end);\n        } else {\n            merged.add(current);\n            current = next;\n        }\n    }\n    merged.add(current);\n\n    // Find free time gaps\n    List<Interval> freeTime = new ArrayList<>();\n    for (int i = 0; i < merged.size() - 1; i++) {\n        if (merged.get(i).end < merged.get(i + 1).start) {\n            freeTime.add(new Interval(merged.get(i).end, merged.get(i + 1).start));\n        }\n    }\n\n    return freeTime;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"14-merge-similar-items",children:"1.4 Merge Similar Items"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"int[][] mergeSimilarItems(int[][] items1, int[][] items2) {\n    Map<Integer, Integer> map = new HashMap<>();\n\n    for (int[] item : items1) {\n        map.put(item[0], map.getOrDefault(item[0], 0) + item[1]);\n    }\n\n    for (int[] item : items2) {\n        map.put(item[0], map.getOrDefault(item[0], 0) + item[1]);\n    }\n\n    List<int[]> result = new ArrayList<>();\n    for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\n        result.add(new int[]{entry.getKey(), entry.getValue()});\n    }\n\n    result.sort((a, b) -> a[0] - b[0]);\n    return result.toArray(new int[result.size()][]);\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"pattern-2-insert--delete-intervals",children:"Pattern 2: Insert & Delete Intervals"}),"\n",(0,i.jsx)(e.h3,{id:"21-insert-interval",children:"2.1 Insert Interval"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"int[][] insert(int[][] intervals, int[] newInterval) {\n    List<int[]> result = new ArrayList<>();\n    int i = 0;\n\n    // Add all intervals that end before newInterval starts\n    while (i < intervals.length && intervals[i][1] < newInterval[0]) {\n        result.add(intervals[i]);\n        i++;\n    }\n\n    // Merge overlapping intervals\n    while (i < intervals.length && intervals[i][0] <= newInterval[1]) {\n        newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\n        newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\n        i++;\n    }\n    result.add(newInterval);\n\n    // Add remaining intervals\n    while (i < intervals.length) {\n        result.add(intervals[i]);\n        i++;\n    }\n\n    return result.toArray(new int[result.size()][]);\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"22-remove-interval",children:"2.2 Remove Interval"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"List<int[]> removeInterval(int[][] intervals, int[] toBeRemoved) {\n    List<int[]> result = new ArrayList<>();\n\n    for (int[] interval : intervals) {\n        // No overlap\n        if (interval[1] <= toBeRemoved[0] || interval[0] >= toBeRemoved[1]) {\n            result.add(interval);\n        }\n        // Partial overlap\n        else {\n            // Left part remains\n            if (interval[0] < toBeRemoved[0]) {\n                result.add(new int[]{interval[0], toBeRemoved[0]});\n            }\n\n            // Right part remains\n            if (interval[1] > toBeRemoved[1]) {\n                result.add(new int[]{toBeRemoved[1], interval[1]});\n            }\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"23-insert-with-merge",children:"2.3 Insert with Merge"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"int[][] insertAndMerge(int[][] intervals, int[] newInterval) {\n    if (intervals.length == 0) {\n        return new int[][]{newInterval};\n    }\n\n    List<int[]> result = new ArrayList<>();\n    boolean inserted = false;\n\n    for (int[] interval : intervals) {\n        if (interval[1] < newInterval[0]) {\n            // Current interval ends before new interval starts\n            result.add(interval);\n        } else if (interval[0] > newInterval[1]) {\n            // Current interval starts after new interval ends\n            if (!inserted) {\n                result.add(newInterval);\n                inserted = true;\n            }\n            result.add(interval);\n        } else {\n            // Overlapping - merge\n            newInterval[0] = Math.min(newInterval[0], interval[0]);\n            newInterval[1] = Math.max(newInterval[1], interval[1]);\n        }\n    }\n\n    if (!inserted) {\n        result.add(newInterval);\n    }\n\n    return result.toArray(new int[result.size()][]);\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"24-replace-interval",children:"2.4 Replace Interval"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"int[][] replaceInterval(int[][] intervals, int[] oldInterval, int[] newInterval) {\n    List<int[]> result = new ArrayList<>();\n    boolean replaced = false;\n\n    for (int[] interval : intervals) {\n        if (!replaced && Arrays.equals(interval, oldInterval)) {\n            result.add(newInterval);\n            replaced = true;\n        } else {\n            result.add(interval);\n        }\n    }\n\n    if (!replaced) {\n        result.add(newInterval);\n    }\n\n    // Sort and merge if necessary\n    result.sort((a, b) -> a[0] - b[0]);\n    return merge(result.toArray(new int[result.size()][]));\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"pattern-3-interval-intersection",children:"Pattern 3: Interval Intersection"}),"\n",(0,i.jsx)(e.h3,{id:"31-interval-list-intersections",children:"3.1 Interval List Intersections"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"int[][] intervalIntersection(int[][] firstList, int[][] secondList) {\n    List<int[]> result = new ArrayList<>();\n    int i = 0, j = 0;\n\n    while (i < firstList.length && j < secondList.length) {\n        int[] first = firstList[i];\n        int[] second = secondList[j];\n\n        // Check if they overlap\n        int start = Math.max(first[0], second[0]);\n        int end = Math.min(first[1], second[1]);\n\n        if (start <= end) {\n            result.add(new int[]{start, end});\n        }\n\n        // Move the pointer of interval that ends first\n        if (first[1] <= second[1]) {\n            i++;\n        } else {\n            j++;\n        }\n    }\n\n    return result.toArray(new int[result.size()][]);\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"32-multiple-interval-intersections",children:"3.2 Multiple Interval Intersections"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"List<int[]> intersectMultipleIntervals(List<List<int[]>> intervalLists) {\n    if (intervalLists.isEmpty()) return new ArrayList<>();\n\n    List<int[]> result = Arrays.asList(intervalLists.get(0).toArray(new int[0][]));\n\n    for (int i = 1; i < intervalLists.size(); i++) {\n        result = intersectTwoLists(result, intervalLists.get(i));\n        if (result.isEmpty()) break;\n    }\n\n    return result;\n}\n\nList<int[]> intersectTwoLists(List<int[]> list1, List<int[]> list2) {\n    List<int[]> result = new ArrayList<>();\n    int i = 0, j = 0;\n\n    while (i < list1.size() && j < list2.size()) {\n        int[] first = list1.get(i);\n        int[] second = list2.get(j);\n\n        int start = Math.max(first[0], second[0]);\n        int end = Math.min(first[1], second[1]);\n\n        if (start <= end) {\n            result.add(new int[]{start, end});\n        }\n\n        if (first[1] <= second[1]) {\n            i++;\n        } else {\n            j++;\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"33-find-intersection-points",children:"3.3 Find Intersection Points"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"List<Integer> findIntersectionPoints(int[][] intervals1, int[][] intervals2) {\n    Set<Integer> points = new HashSet<>();\n\n    for (int[] interval1 : intervals1) {\n        for (int[] interval2 : intervals2) {\n            int start = Math.max(interval1[0], interval2[0]);\n            int end = Math.min(interval1[1], interval2[1]);\n\n            if (start <= end) {\n                points.add(start);\n                points.add(end);\n            }\n        }\n    }\n\n    List<Integer> result = new ArrayList<>(points);\n    Collections.sort(result);\n    return result;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"34-intersect-and-count",children:"3.4 Intersect and Count"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"int countIntersections(int[][] intervals1, int[][] intervals2) {\n    int count = 0;\n\n    for (int[] interval1 : intervals1) {\n        for (int[] interval2 : intervals2) {\n            if (interval1[0] < interval2[1] && interval2[0] < interval1[1]) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"pattern-4-non-overlapping-intervals",children:"Pattern 4: Non-Overlapping Intervals"}),"\n",(0,i.jsx)(e.h3,{id:"41-minimum-intervals-to-remove",children:"4.1 Minimum Intervals to Remove"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"int eraseOverlapIntervals(int[][] intervals) {\n    if (intervals.length <= 1) return 0;\n\n    // Sort by end time for greedy approach\n    Arrays.sort(intervals, (a, b) -> a[1] - b[1]);\n\n    int count = 0;\n    int lastEnd = intervals[0][1];\n\n    for (int i = 1; i < intervals.length; i++) {\n        if (intervals[i][0] < lastEnd) {\n            // Overlapping interval, remove it\n            count++;\n        } else {\n            // Non-overlapping, update lastEnd\n            lastEnd = intervals[i][1];\n        }\n    }\n\n    return count;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"42-maximum-non-overlapping-intervals",children:"4.2 Maximum Non-Overlapping Intervals"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"int maxNonOverlapping(int[][] intervals) {\n    if (intervals.length == 0) return 0;\n\n    Arrays.sort(intervals, (a, b) -> a[1] - b[1]);\n\n    int count = 1;\n    int lastEnd = intervals[0][1];\n\n    for (int i = 1; i < intervals.length; i++) {\n        if (intervals[i][0] >= lastEnd) {\n            count++;\n            lastEnd = intervals[i][1];\n        }\n    }\n\n    return count;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"43-minimum-arrows-to-burst-balloons",children:"4.3 Minimum Arrows to Burst Balloons"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"int findMinArrowShots(int[][] points) {\n    if (points.length == 0) return 0;\n\n    Arrays.sort(points, (a, b) -> Integer.compare(a[1], b[1]));\n\n    int arrows = 1;\n    int arrowPos = points[0][1];\n\n    for (int i = 1; i < points.length; i++) {\n        if (points[i][0] > arrowPos) {\n            arrows++;\n            arrowPos = points[i][1];\n        }\n    }\n\n    return arrows;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"44-non-overlapping-activity-selection",children:"4.4 Non-Overlapping Activity Selection"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"List<int[]> activitySelection(int[][] activities) {\n    Arrays.sort(activities, (a, b) -> a[1] - b[1]);\n\n    List<int[]> selected = new ArrayList<>();\n    selected.add(activities[0]);\n    int lastEnd = activities[0][1];\n\n    for (int i = 1; i < activities.length; i++) {\n        if (activities[i][0] >= lastEnd) {\n            selected.add(activities[i]);\n            lastEnd = activities[i][1];\n        }\n    }\n\n    return selected;\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"pattern-5-meeting-room-problems",children:"Pattern 5: Meeting Room Problems"}),"\n",(0,i.jsx)(e.h3,{id:"51-meeting-rooms-i",children:"5.1 Meeting Rooms I"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"boolean canAttendMeetings(int[][] intervals) {\n    Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\n\n    for (int i = 1; i < intervals.length; i++) {\n        if (intervals[i][0] < intervals[i - 1][1]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"52-meeting-rooms-ii",children:"5.2 Meeting Rooms II"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"int minMeetingRooms(int[][] intervals) {\n    if (intervals.length == 0) return 0;\n\n    PriorityQueue<Integer> minHeap = new PriorityQueue<>();\n    Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\n\n    for (int[] interval : intervals) {\n        if (!minHeap.isEmpty() && minHeap.peek() <= interval[0]) {\n            minHeap.poll();\n        }\n        minHeap.offer(interval[1]);\n    }\n\n    return minHeap.size();\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"53-meeting-rooms-iii",children:"5.3 Meeting Rooms III"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"int mostBooked(int n, int[][] meetings) {\n    Arrays.sort(meetings, (a, b) -> a[0] - b[0]);\n\n    PriorityQueue<Integer> availableRooms = new PriorityQueue<>();\n    PriorityQueue<long[]> busyRooms = new PriorityQueue<>((a, b) -> {\n        if (a[0] != b[0]) return Long.compare(a[0], b[0]);\n        return Long.compare(a[1], b[1]);\n    });\n\n    for (int i = 0; i < n; i++) {\n        availableRooms.offer(i);\n    }\n\n    int[] count = new int[n];\n\n    for (int[] meeting : meetings) {\n        long start = meeting[0];\n        long duration = meeting[1] - meeting[0];\n\n        // Free up rooms\n        while (!busyRooms.isEmpty() && busyRooms.peek()[0] <= start) {\n            availableRooms.offer((int) busyRooms.poll()[1]);\n        }\n\n        if (!availableRooms.isEmpty()) {\n            int room = availableRooms.poll();\n            count[room]++;\n            busyRooms.offer(new long[]{start + duration, room});\n        } else {\n            long[] earliest = busyRooms.poll();\n            int room = (int) earliest[1];\n            count[room]++;\n            busyRooms.offer(new long[]{earliest[0] + duration, room});\n        }\n    }\n\n    int maxCount = 0;\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        if (count[i] > maxCount) {\n            maxCount = count[i];\n            result = i;\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"54-conference-room-allocation",children:"5.4 Conference Room Allocation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"int[][] allocateConferenceRooms(int[][] meetings, int numRooms) {\n    Arrays.sort(meetings, (a, b) -> a[0] - b[0]);\n\n    PriorityQueue<Integer> availableRooms = new PriorityQueue<>();\n    PriorityQueue<int[]> busyRooms = new PriorityQueue<>((a, b) -> a[0] - b[0]);\n\n    for (int i = 0; i < numRooms; i++) {\n        availableRooms.offer(i);\n    }\n\n    List<int[]> result = new ArrayList<>();\n\n    for (int i = 0; i < meetings.length; i++) {\n        int[] meeting = meetings[i];\n\n        // Free up rooms\n        while (!busyRooms.isEmpty() && busyRooms.peek()[0] <= meeting[0]) {\n            availableRooms.offer(busyRooms.poll()[1]);\n        }\n\n        if (!availableRooms.isEmpty()) {\n            int room = availableRooms.poll();\n            result.add(new int[]{i, room}); // meeting index, room number\n            busyRooms.offer(new int[]{meeting[1], room});\n        } else {\n            result.add(new int[]{i, -1}); // cannot allocate\n        }\n    }\n\n    return result.toArray(new int[result.size()][]);\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"pattern-6-line-sweep-algorithm",children:"Pattern 6: Line Sweep Algorithm"}),"\n",(0,i.jsx)(e.h3,{id:"61-basic-line-sweep-template",children:"6.1 Basic Line Sweep Template"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"class Event {\n    int time;\n    int type; // 1 for start, -1 for end\n    int index;\n\n    Event(int time, int type, int index) {\n        this.time = time;\n        this.type = type;\n        this.index = index;\n    }\n}\n\nList<Event> createEvents(int[][] intervals) {\n    List<Event> events = new ArrayList<>();\n\n    for (int i = 0; i < intervals.length; i++) {\n        events.add(new Event(intervals[i][0], 1, i));  // start\n        events.add(new Event(intervals[i][1], -1, i)); // end\n    }\n\n    // Sort events by time, then by type (start before end)\n    events.sort((a, b) -> {\n        if (a.time != b.time) return a.time - b.time;\n        return b.type - a.type; // start (1) before end (-1)\n    });\n\n    return events;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"62-maximum-overlap-count",children:"6.2 Maximum Overlap Count"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"int maxOverlapCount(int[][] intervals) {\n    List<Event> events = createEvents(intervals);\n\n    int maxOverlap = 0;\n    int currentOverlap = 0;\n\n    for (Event event : events) {\n        currentOverlap += event.type;\n        maxOverlap = Math.max(maxOverlap, currentOverlap);\n    }\n\n    return maxOverlap;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"63-find-all-overlap-points",children:"6.3 Find All Overlap Points"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"List<int[]> findOverlapRanges(int[][] intervals) {\n    List<Event> events = createEvents(intervals);\n\n    List<int[]> overlaps = new ArrayList<>();\n    int activeCount = 0;\n    int lastTime = -1;\n\n    for (Event event : events) {\n        if (activeCount > 1 && lastTime != event.time) {\n            overlaps.add(new int[]{lastTime, event.time});\n        }\n\n        activeCount += event.type;\n        lastTime = event.time;\n    }\n\n    return overlaps;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"64-line-sweep-for-rectangle-area",children:"6.4 Line Sweep for Rectangle Area"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"class Rectangle {\n    int x1, y1, x2, y2;\n    Rectangle(int x1, int y1, int x2, int y2) {\n        this.x1 = x1; this.y1 = y1;\n        this.x2 = x2; this.y2 = y2;\n    }\n}\n\nlong rectangleArea(Rectangle[] rectangles) {\n    List<int[]> events = new ArrayList<>();\n\n    for (Rectangle rect : rectangles) {\n        events.add(new int[]{rect.x1, 1, rect.y1, rect.y2}); // start\n        events.add(new int[]{rect.x2, -1, rect.y1, rect.y2}); // end\n    }\n\n    events.sort((a, b) -> {\n        if (a[0] != b[0]) return a[0] - b[0];\n        return b[1] - a[1];\n    });\n\n    long totalArea = 0;\n    List<int[]> activeY = new ArrayList<>();\n    int lastX = 0;\n\n    for (int[] event : events) {\n        int x = event[0];\n        int type = event[1];\n        int y1 = event[2];\n        int y2 = event[3];\n\n        // Calculate area with current active Y ranges\n        if (!activeY.isEmpty()) {\n            totalArea += (long)(x - lastX) * getTotalLength(activeY);\n        }\n\n        // Update active Y ranges\n        if (type == 1) {\n            addYRange(activeY, y1, y2);\n        } else {\n            removeYRange(activeY, y1, y2);\n        }\n\n        lastX = x;\n    }\n\n    return totalArea;\n}\n\nvoid addYRange(List<int[]> ranges, int y1, int y2) {\n    ranges.add(new int[]{y1, y2});\n    mergeYRanges(ranges);\n}\n\nvoid removeYRange(List<int[]> ranges, int y1, int y2) {\n    List<int[]> newRanges = new ArrayList<>();\n\n    for (int[] range : ranges) {\n        if (range[0] >= y2 || range[1] <= y1) {\n            newRanges.add(range);\n        } else {\n            if (range[0] < y1) {\n                newRanges.add(new int[]{range[0], y1});\n            }\n            if (range[1] > y2) {\n                newRanges.add(new int[]{y2, range[1]});\n            }\n        }\n    }\n\n    ranges.clear();\n    ranges.addAll(newRanges);\n    mergeYRanges(ranges);\n}\n\nvoid mergeYRanges(List<int[]> ranges) {\n    ranges.sort((a, b) -> a[0] - b[0]);\n\n    List<int[]> merged = new ArrayList<>();\n    for (int[] range : ranges) {\n        if (merged.isEmpty() || merged.get(merged.size() - 1)[1] < range[0]) {\n            merged.add(range);\n        } else {\n            merged.get(merged.size() - 1)[1] = Math.max(merged.get(merged.size() - 1)[1], range[1]);\n        }\n    }\n\n    ranges.clear();\n    ranges.addAll(merged);\n}\n\nint getTotalLength(List<int[]> ranges) {\n    int total = 0;\n    for (int[] range : ranges) {\n        total += range[1] - range[0];\n    }\n    return total;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"65-closest-pair-using-line-sweep",children:"6.5 Closest Pair Using Line Sweep"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"class Point {\n    int x, y, index;\n    Point(int x, int y, int index) {\n        this.x = x; this.y = y; this.index = index;\n    }\n}\n\ndouble closestPair(int[][] points) {\n    Point[] pts = new Point[points.length];\n    for (int i = 0; i < points.length; i++) {\n        pts[i] = new Point(points[i][0], points[i][1], i);\n    }\n\n    Arrays.sort(pts, (a, b) -> a.x - b.x);\n\n    return closestPairRec(pts, 0, pts.length - 1);\n}\n\ndouble closestPairRec(Point[] points, int left, int right) {\n    if (right - left <= 3) {\n        return bruteForce(points, left, right);\n    }\n\n    int mid = left + (right - left) / 2;\n    Point midPoint = points[mid];\n\n    double leftMin = closestPairRec(points, left, mid);\n    double rightMin = closestPairRec(points, mid + 1, right);\n\n    double minDist = Math.min(leftMin, rightMin);\n\n    // Check points near the dividing line\n    List<Point> strip = new ArrayList<>();\n    for (int i = left; i <= right; i++) {\n        if (Math.abs(points[i].x - midPoint.x) < minDist) {\n            strip.add(points[i]);\n        }\n    }\n\n    strip.sort((a, b) -> a.y - b.y);\n\n    for (int i = 0; i < strip.size(); i++) {\n        for (int j = i + 1; j < strip.size() && (strip.get(j).y - strip.get(i).y) < minDist; j++) {\n            minDist = Math.min(minDist, distance(strip.get(i), strip.get(j)));\n        }\n    }\n\n    return minDist;\n}\n\ndouble bruteForce(Point[] points, int left, int right) {\n    double minDist = Double.MAX_VALUE;\n\n    for (int i = left; i <= right; i++) {\n        for (int j = i + 1; j <= right; j++) {\n            minDist = Math.min(minDist, distance(points[i], points[j]));\n        }\n    }\n\n    return minDist;\n}\n\ndouble distance(Point a, Point b) {\n    return Math.sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"pattern-7-point-coverage",children:"Pattern 7: Point Coverage"}),"\n",(0,i.jsx)(e.h3,{id:"71-minimum-points-to-cover-intervals",children:"7.1 Minimum Points to Cover Intervals"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"int minPointsToCover(int[][] intervals) {\n    Arrays.sort(intervals, (a, b) -> a[1] - b[1]);\n\n    int points = 0;\n    int lastPoint = Integer.MIN_VALUE;\n\n    for (int[] interval : intervals) {\n        if (lastPoint < interval[0]) {\n            points++;\n            lastPoint = interval[1];\n        }\n    }\n\n    return points;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"72-points-covered-by-intervals",children:"7.2 Points Covered by Intervals"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"List<Integer> pointsCoveredByIntervals(int[][] intervals, int[] points) {\n    List<Integer> result = new ArrayList<>();\n\n    for (int point : points) {\n        boolean covered = false;\n\n        for (int[] interval : intervals) {\n            if (point >= interval[0] && point <= interval[1]) {\n                covered = true;\n                break;\n            }\n        }\n\n        if (covered) {\n            result.add(point);\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"73-interval-coverage-by-points",children:"7.3 Interval Coverage by Points"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"int maxIntervalsCoveredByPoint(int[][] intervals) {\n    Map<Integer, Integer> pointCount = new HashMap<>();\n\n    for (int[] interval : intervals) {\n        for (int point = interval[0]; point <= interval[1]; point++) {\n            pointCount.put(point, pointCount.getOrDefault(point, 0) + 1);\n        }\n    }\n\n    return pointCount.values().stream().max(Integer::compare).orElse(0);\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"74-minimum-intervals-to-remove-for-point-coverage",children:"7.4 Minimum Intervals to Remove for Point Coverage"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"int minIntervalsToRemove(int[][] intervals, int point) {\n    int removeCount = 0;\n\n    for (int[] interval : intervals) {\n        if (point >= interval[0] && point <= interval[1]) {\n            removeCount++;\n        }\n    }\n\n    return removeCount;\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"pattern-8-interval-scheduling",children:"Pattern 8: Interval Scheduling"}),"\n",(0,i.jsx)(e.h3,{id:"81-weighted-job-scheduling",children:"8.1 Weighted Job Scheduling"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"int jobScheduling(int[] startTime, int[] endTime, int[] profit) {\n    int n = startTime.length;\n    int[][] jobs = new int[n][3];\n\n    for (int i = 0; i < n; i++) {\n        jobs[i] = new int[]{startTime[i], endTime[i], profit[i]};\n    }\n\n    Arrays.sort(jobs, (a, b) -> a[1] - b[1]); // sort by end time\n\n    int[] dp = new int[n];\n    dp[0] = jobs[0][2];\n\n    for (int i = 1; i < n; i++) {\n        int currentProfit = jobs[i][2];\n        int latestNonOverlapping = findLatestNonOverlapping(jobs, i);\n\n        if (latestNonOverlapping != -1) {\n            currentProfit += dp[latestNonOverlapping];\n        }\n\n        dp[i] = Math.max(dp[i - 1], currentProfit);\n    }\n\n    return dp[n - 1];\n}\n\nint findLatestNonOverlapping(int[][] jobs, int index) {\n    int currentStart = jobs[index][0];\n\n    for (int i = index - 1; i >= 0; i--) {\n        if (jobs[i][1] <= currentStart) {\n            return i;\n        }\n    }\n\n    return -1;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"82-maximum-cpu-load",children:"8.2 Maximum CPU Load"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"int maxCPULoad(int[][] jobs) {\n    Arrays.sort(jobs, (a, b) -> a[0] - b[0]);\n\n    PriorityQueue<int[]> minHeap = new PriorityQueue<>((a, b) -> a[1] - b[1]);\n    int maxLoad = 0;\n    int currentLoad = 0;\n\n    for (int[] job : jobs) {\n        while (!minHeap.isEmpty() && minHeap.peek()[1] <= job[0]) {\n            currentLoad -= minHeap.poll()[2];\n        }\n\n        minHeap.offer(job);\n        currentLoad += job[2];\n        maxLoad = Math.max(maxLoad, currentLoad);\n    }\n\n    return maxLoad;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"83-task-scheduler-with-intervals",children:"8.3 Task Scheduler with Intervals"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"int taskSchedulerWithIntervals(int[][] tasks, int cooldown) {\n    Arrays.sort(tasks, (a, b) -> a[0] - b[0]);\n\n    PriorityQueue<Integer> endTimes = new PriorityQueue<>();\n    int time = 0;\n\n    for (int[] task : tasks) {\n        int start = task[0];\n        int duration = task[1];\n\n        // Remove finished tasks\n        while (!endTimes.isEmpty() && endTimes.peek() + cooldown <= start) {\n            endTimes.poll();\n        }\n\n        // Schedule current task\n        time = Math.max(start, time);\n        time += duration;\n        endTimes.offer(time);\n    }\n\n    return time;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"84-minimum-platforms-for-trains",children:"8.4 Minimum Platforms for Trains"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"int minPlatforms(int[] arrivals, int[] departures) {\n    Arrays.sort(arrivals);\n    Arrays.sort(departures);\n\n    int platforms = 0;\n    int maxPlatforms = 0;\n    int i = 0, j = 0;\n\n    while (i < arrivals.length && j < departures.length) {\n        if (arrivals[i] <= departures[j]) {\n            platforms++;\n            maxPlatforms = Math.max(maxPlatforms, platforms);\n            i++;\n        } else {\n            platforms--;\n            j++;\n        }\n    }\n\n    return maxPlatforms;\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"pattern-9-time-based-problems",children:"Pattern 9: Time-based Problems"}),"\n",(0,i.jsx)(e.h3,{id:"91-car-pooling",children:"9.1 Car Pooling"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"boolean carPooling(int[][] trips, int capacity) {\n    Map<Integer, Integer> timeline = new TreeMap<>();\n\n    for (int[] trip : trips) {\n        int passengers = trip[0];\n        int start = trip[1];\n        int end = trip[2];\n\n        timeline.put(start, timeline.getOrDefault(start, 0) + passengers);\n        timeline.put(end, timeline.getOrDefault(end, 0) - passengers);\n    }\n\n    int currentPassengers = 0;\n\n    for (int change : timeline.values()) {\n        currentPassengers += change;\n        if (currentPassengers > capacity) {\n            return false;\n        }\n    }\n\n    return true;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"92-corporate-flight-bookings",children:"9.2 Corporate Flight Bookings"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"int[] corpFlightBookings(int[][] bookings, int n) {\n    int[] result = new int[n];\n\n    for (int[] booking : bookings) {\n        int first = booking[0] - 1;\n        int last = booking[1] - 1;\n        int seats = booking[2];\n\n        result[first] += seats;\n        if (last + 1 < n) {\n            result[last + 1] -= seats;\n        }\n    }\n\n    // Convert to actual values\n    for (int i = 1; i < n; i++) {\n        result[i] += result[i - 1];\n    }\n\n    return result;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"93-process-transactions",children:"9.3 Process Transactions"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'List<String> processTransactions(String[] transactions) {\n    Map<String, List<Transaction>> personTransactions = new HashMap<>();\n    List<Transaction> allTransactions = new ArrayList<>();\n\n    for (int i = 0; i < transactions.length; i++) {\n        String[] parts = transactions[i].split(",");\n        Transaction t = new Transaction(parts[0], Integer.parseInt(parts[1]),\n                                      Integer.parseInt(parts[2]), parts[3], i);\n\n        allTransactions.add(t);\n        personTransactions.computeIfAbsent(t.name, k -> new ArrayList<>()).add(t);\n    }\n\n    List<String> invalid = new ArrayList<>();\n\n    for (Transaction t1 : allTransactions) {\n        if (t1.amount > 1000) {\n            invalid.add(transactions[t1.index]);\n            continue;\n        }\n\n        boolean isInvalid = false;\n        for (Transaction t2 : personTransactions.get(t1.name)) {\n            if (Math.abs(t1.time - t2.time) <= 60 && !t1.city.equals(t2.city)) {\n                isInvalid = true;\n                break;\n            }\n        }\n\n        if (isInvalid) {\n            invalid.add(transactions[t1.index]);\n        }\n    }\n\n    return invalid;\n}\n\nclass Transaction {\n    String name;\n    int time;\n    int amount;\n    String city;\n    int index;\n\n    Transaction(String name, int time, int amount, String city, int index) {\n        this.name = name;\n        this.time = time;\n        this.amount = amount;\n        this.city = city;\n        this.index = index;\n    }\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"94-time-based-key-value-store",children:"9.4 Time-based Key-Value Store"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'class TimeMap {\n    private Map<String, List<TimeValue>> store;\n\n    public TimeMap() {\n        store = new HashMap<>();\n    }\n\n    public void set(String key, String value, int timestamp) {\n        store.computeIfAbsent(key, k -> new ArrayList<>()).add(new TimeValue(timestamp, value));\n    }\n\n    public String get(String key, int timestamp) {\n        if (!store.containsKey(key)) return "";\n\n        List<TimeValue> values = store.get(key);\n        int left = 0, right = values.size() - 1;\n        String result = "";\n\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n\n            if (values.get(mid).timestamp <= timestamp) {\n                result = values.get(mid).value;\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n        return result;\n    }\n\n    class TimeValue {\n        int timestamp;\n        String value;\n\n        TimeValue(int timestamp, String value) {\n            this.timestamp = timestamp;\n            this.value = value;\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"pattern-10-range-sum--query",children:"Pattern 10: Range Sum & Query"}),"\n",(0,i.jsx)(e.h3,{id:"101-range-sum-query-with-updates",children:"10.1 Range Sum Query with Updates"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"class RangeSum {\n    private int[] nums;\n    private int[] tree;\n    private int n;\n\n    public RangeSum(int[] nums) {\n        this.nums = nums.clone();\n        this.n = nums.length;\n        this.tree = new int[n * 2];\n\n        // Build segment tree\n        for (int i = n; i < 2 * n; i++) {\n            tree[i] = nums[i - n];\n        }\n\n        for (int i = n - 1; i > 0; i--) {\n            tree[i] = tree[i * 2] + tree[i * 2 + 1];\n        }\n    }\n\n    public void update(int index, int val) {\n        index += n;\n        tree[index] = val;\n\n        while (index > 0) {\n            tree[index / 2] = tree[index] + tree[index ^ 1];\n            index /= 2;\n        }\n    }\n\n    public int sumRange(int left, int right) {\n        left += n;\n        right += n;\n        int sum = 0;\n\n        while (left <= right) {\n            if (left % 2 == 1) {\n                sum += tree[left];\n                left++;\n            }\n            if (right % 2 == 0) {\n                sum += tree[right];\n                right--;\n            }\n            left /= 2;\n            right /= 2;\n        }\n\n        return sum;\n    }\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"102-range-addition",children:"10.2 Range Addition"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"int[] getModifiedArray(int length, int[][] updates) {\n    int[] result = new int[length];\n\n    for (int[] update : updates) {\n        int start = update[0];\n        int end = update[1];\n        int value = update[2];\n\n        result[start] += value;\n        if (end + 1 < length) {\n            result[end + 1] -= value;\n        }\n    }\n\n    // Convert to actual values\n    for (int i = 1; i < length; i++) {\n        result[i] += result[i - 1];\n    }\n\n    return result;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"103-my-calendar",children:"10.3 My Calendar"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"class MyCalendar {\n    private List<int[]> bookings;\n\n    public MyCalendar() {\n        bookings = new ArrayList<>();\n    }\n\n    public boolean book(int start, int end) {\n        for (int[] booking : bookings) {\n            if (start < booking[1] && end > booking[0]) {\n                return false; // Overlap found\n            }\n        }\n\n        bookings.add(new int[]{start, end});\n        return true;\n    }\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"104-my-calendar-ii-double-booking",children:"10.4 My Calendar II (Double Booking)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"class MyCalendarTwo {\n    private List<int[]> bookings;\n    private List<int[]> overlaps;\n\n    public MyCalendarTwo() {\n        bookings = new ArrayList<>();\n        overlaps = new ArrayList<>();\n    }\n\n    public boolean book(int start, int end) {\n        // Check if it conflicts with existing overlaps\n        for (int[] overlap : overlaps) {\n            if (start < overlap[1] && end > overlap[0]) {\n                return false; // Triple booking\n            }\n        }\n\n        // Add new overlaps\n        for (int[] booking : bookings) {\n            if (start < booking[1] && end > booking[0]) {\n                overlaps.add(new int[]{Math.max(start, booking[0]), Math.min(end, booking[1])});\n            }\n        }\n\n        bookings.add(new int[]{start, end});\n        return true;\n    }\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"pattern-11-calendar-problems",children:"Pattern 11: Calendar Problems"}),"\n",(0,i.jsx)(e.h3,{id:"111-my-calendar-iii",children:"11.1 My Calendar III"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"class MyCalendarThree {\n    private Map<Integer, Integer> timeline;\n\n    public MyCalendarThree() {\n        timeline = new TreeMap<>();\n    }\n\n    public int book(int start, int end) {\n        timeline.put(start, timeline.getOrDefault(start, 0) + 1);\n        timeline.put(end, timeline.getOrDefault(end, 0) - 1);\n\n        int maxBookings = 0;\n        int currentBookings = 0;\n\n        for (int count : timeline.values()) {\n            currentBookings += count;\n            maxBookings = Math.max(maxBookings, currentBookings);\n        }\n\n        return maxBookings;\n    }\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"112-event-availability",children:"11.2 Event Availability"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"boolean isAvailable(List<int[]> events, int[] newEvent) {\n    for (int[] event : events) {\n        if (newEvent[0] < event[1] && newEvent[1] > event[0]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nList<int[]> findAvailableSlots(List<int[]> busyTimes, int[] workingHours, int duration) {\n    List<int[]> merged = mergeIntervals(busyTimes);\n    List<int[]> available = new ArrayList<>();\n\n    int start = workingHours[0];\n\n    for (int[] busy : merged) {\n        if (start + duration <= busy[0]) {\n            available.add(new int[]{start, busy[0]});\n        }\n        start = Math.max(start, busy[1]);\n    }\n\n    if (start + duration <= workingHours[1]) {\n        available.add(new int[]{start, workingHours[1]});\n    }\n\n    return available;\n}\n\nList<int[]> mergeIntervals(List<int[]> intervals) {\n    if (intervals.isEmpty()) return new ArrayList<>();\n\n    intervals.sort((a, b) -> a[0] - b[0]);\n\n    List<int[]> merged = new ArrayList<>();\n    int[] current = intervals.get(0);\n\n    for (int i = 1; i < intervals.size(); i++) {\n        int[] next = intervals.get(i);\n\n        if (current[1] >= next[0]) {\n            current[1] = Math.max(current[1], next[1]);\n        } else {\n            merged.add(current);\n            current = next;\n        }\n    }\n\n    merged.add(current);\n    return merged;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"113-exam-room",children:"11.3 Exam Room"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"class ExamRoom {\n    private TreeSet<Integer> seats;\n    private int n;\n\n    public ExamRoom(int n) {\n        this.n = n;\n        this.seats = new TreeSet<>();\n    }\n\n    public int seat() {\n        int seatNum = 0;\n\n        if (seats.size() > 0) {\n            int maxDistance = seats.first();\n            Integer prev = null;\n\n            for (Integer seat : seats) {\n                if (prev != null) {\n                    int distance = (seat - prev) / 2;\n                    if (distance > maxDistance) {\n                        maxDistance = distance;\n                        seatNum = prev + distance;\n                    }\n                }\n                prev = seat;\n            }\n\n            if (n - 1 - seats.last() > maxDistance) {\n                seatNum = n - 1;\n            }\n        }\n\n        seats.add(seatNum);\n        return seatNum;\n    }\n\n    public void leave(int p) {\n        seats.remove(p);\n    }\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"114-design-hit-counter",children:"11.4 Design Hit Counter"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"class HitCounter {\n    private Queue<Integer> hits;\n\n    public HitCounter() {\n        hits = new LinkedList<>();\n    }\n\n    public void hit(int timestamp) {\n        hits.offer(timestamp);\n    }\n\n    public int getHits(int timestamp) {\n        while (!hits.isEmpty() && hits.peek() <= timestamp - 300) {\n            hits.poll();\n        }\n        return hits.size();\n    }\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"pattern-12-advanced-interval-patterns",children:"Pattern 12: Advanced Interval Patterns"}),"\n",(0,i.jsx)(e.h3,{id:"121-skyline-problem",children:"12.1 Skyline Problem"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"List<List<Integer>> getSkyline(int[][] buildings) {\n    List<int[]> events = new ArrayList<>();\n\n    for (int[] building : buildings) {\n        events.add(new int[]{building[0], building[2], 0}); // start\n        events.add(new int[]{building[1], building[2], 1}); // end\n    }\n\n    events.sort((a, b) -> {\n        if (a[0] != b[0]) return a[0] - b[0];\n        if (a[2] != b[2]) return a[2] - b[2]; // start before end\n        return a[2] == 0 ? b[1] - a[1] : a[1] - b[1]; // height order\n    });\n\n    List<List<Integer>> result = new ArrayList<>();\n    PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\n    maxHeap.offer(0);\n\n    for (int[] event : events) {\n        int x = event[0];\n        int height = event[1];\n        int type = event[2];\n\n        if (type == 0) {\n            maxHeap.offer(height);\n        } else {\n            maxHeap.remove(height);\n        }\n\n        int maxHeight = maxHeap.peek();\n\n        if (result.isEmpty() || result.get(result.size() - 1).get(1) != maxHeight) {\n            result.add(Arrays.asList(x, maxHeight));\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"122-falling-squares",children:"12.2 Falling Squares"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"List<Integer> fallingSquares(int[][] positions) {\n    List<Integer> result = new ArrayList<>();\n    List<int[]> intervals = new ArrayList<>();\n\n    for (int[] pos : positions) {\n        int left = pos[0];\n        int size = pos[1];\n        int right = left + size;\n\n        int height = size;\n\n        // Find overlapping intervals and get max height\n        for (int[] interval : intervals) {\n            if (interval[0] < right && left < interval[1]) {\n                height = Math.max(height, interval[2] + size);\n            }\n        }\n\n        intervals.add(new int[]{left, right, height});\n\n        // Update result with current max height\n        int maxHeight = 0;\n        for (int[] interval : intervals) {\n            maxHeight = Math.max(maxHeight, interval[2]);\n        }\n\n        result.add(maxHeight);\n    }\n\n    return result;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"123-rectangle-area-ii",children:"12.3 Rectangle Area II"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"int rectangleArea(int[][] rectangles) {\n    final int MOD = 1_000_000_007;\n\n    Set<Integer> xCoords = new HashSet<>();\n    Set<Integer> yCoords = new HashSet<>();\n\n    for (int[] rect : rectangles) {\n        xCoords.add(rect[0]);\n        xCoords.add(rect[2]);\n        yCoords.add(rect[1]);\n        yCoords.add(rect[3]);\n    }\n\n    Integer[] xSorted = xCoords.toArray(new Integer[0]);\n    Integer[] ySorted = yCoords.toArray(new Integer[0]);\n    Arrays.sort(xSorted);\n    Arrays.sort(ySorted);\n\n    Map<Integer, Integer> xIndex = new HashMap<>();\n    Map<Integer, Integer> yIndex = new HashMap<>();\n\n    for (int i = 0; i < xSorted.length; i++) {\n        xIndex.put(xSorted[i], i);\n    }\n\n    for (int i = 0; i < ySorted.length; i++) {\n        yIndex.put(ySorted[i], i);\n    }\n\n    boolean[][] grid = new boolean[xSorted.length][ySorted.length];\n\n    for (int[] rect : rectangles) {\n        int x1 = xIndex.get(rect[0]);\n        int y1 = yIndex.get(rect[1]);\n        int x2 = xIndex.get(rect[2]);\n        int y2 = yIndex.get(rect[3]);\n\n        for (int i = x1; i < x2; i++) {\n            for (int j = y1; j < y2; j++) {\n                grid[i][j] = true;\n            }\n        }\n    }\n\n    long area = 0;\n\n    for (int i = 0; i < xSorted.length - 1; i++) {\n        for (int j = 0; j < ySorted.length - 1; j++) {\n            if (grid[i][j]) {\n                area += (long)(xSorted[i + 1] - xSorted[i]) * (ySorted[j + 1] - ySorted[j]);\n                area %= MOD;\n            }\n        }\n    }\n\n    return (int) area;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"124-data-stream-as-disjoint-intervals",children:"12.4 Data Stream as Disjoint Intervals"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"class SummaryRanges {\n    private TreeMap<Integer, Integer> intervals;\n\n    public SummaryRanges() {\n        intervals = new TreeMap<>();\n    }\n\n    public void addNum(int value) {\n        Integer start = intervals.floorKey(value);\n        Integer end = intervals.ceilingKey(value);\n\n        if ((start != null && intervals.get(start) >= value) ||\n            (end != null && end == value)) {\n            return; // Already covered\n        }\n\n        int newStart = value;\n        int newEnd = value;\n\n        if (start != null && intervals.get(start) == value - 1) {\n            newStart = start;\n            intervals.remove(start);\n        }\n\n        if (end != null && end == value + 1) {\n            newEnd = intervals.get(end);\n            intervals.remove(end);\n        }\n\n        intervals.put(newStart, newEnd);\n    }\n\n    public int[][] getIntervals() {\n        return intervals.entrySet().stream()\n            .map(entry -> new int[]{entry.getKey(), entry.getValue()})\n            .toArray(int[][]::new);\n    }\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"time-complexity-reference",children:"Time Complexity Reference"}),"\n",(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{style:{textAlign:"left"},children:"Pattern"}),(0,i.jsx)(e.th,{style:{textAlign:"left"},children:"Best Case"}),(0,i.jsx)(e.th,{style:{textAlign:"left"},children:"Average Case"}),(0,i.jsx)(e.th,{style:{textAlign:"left"},children:"Worst Case"}),(0,i.jsx)(e.th,{style:{textAlign:"left"},children:"Space"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"Merge Intervals"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"O(n log n)"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"O(n log n)"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"O(n log n)"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"O(1)"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"Insert Interval"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"O(n)"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"O(n)"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"O(n)"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"O(1)"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"Intersection"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"O(m + n)"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"O(m + n)"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"O(m + n)"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"O(1)"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"Line Sweep"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"O(n log n)"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"O(n log n)"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"O(n log n)"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"O(n)"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"Meeting Rooms II"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"O(n log n)"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"O(n log n)"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"O(n log n)"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"O(n)"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"Point Coverage"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"O(n)"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"O(n)"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"O(n\xb2)"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"O(1)"})]})]})]}),"\n",(0,i.jsx)(e.h2,{id:"common-interval-patterns-summary",children:"Common Interval Patterns Summary"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Merge Intervals"}),": Sort by start time, then merge overlapping intervals[2][3]"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Insert Interval"}),": Handle three cases - before, overlapping, after[4]"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Line Sweep"}),": Process events in chronological order with active set[5][6]"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Meeting Rooms"}),": Use priority queue to track end times[7]"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Intersection"}),": Two-pointer technique on sorted intervals[8]"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Non-Overlapping"}),": Greedy approach sorting by end time[9]"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Scheduling"}),": Dynamic programming with interval constraints[10]"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Calendar Problems"}),": Maintain sorted intervals for conflict detection[11]"]}),"\n"]})]})}function c(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(v,{...n})}):v(n)}}}]);