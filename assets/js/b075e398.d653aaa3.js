"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[10106],{17766:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>d,contentTitle:()=>t,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>a});var i=r(74848),o=r(28453);const l={title:"Flood Fill Algorithm"},t=void 0,s={id:"DSA/DSA/DSA with JavaScript/FloodFill",title:"Flood Fill Algorithm",description:"Flood Fill Algorithm",source:"@site/docs/05-DSA/DSA/DSA with JavaScript/FloodFill.mdx",sourceDirName:"05-DSA/DSA/DSA with JavaScript",slug:"/DSA/DSA/DSA with JavaScript/FloodFill",permalink:"/docs/DSA/DSA/DSA with JavaScript/FloodFill",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/05-DSA/DSA/DSA with JavaScript/FloodFill.mdx",tags:[],version:"current",frontMatter:{title:"Flood Fill Algorithm"},sidebar:"tutorialSidebar",previous:{title:"Fisher-Yates Shuffle Algorithm",permalink:"/docs/DSA/DSA/DSA with JavaScript/FisherYates"},next:{title:"Floyd-Warshall Algorithm",permalink:"/docs/DSA/DSA/DSA with JavaScript/Floyd-Warshall"}},d={},a=[{value:"Flood Fill Algorithm",id:"flood-fill-algorithm",level:2},{value:"Overview",id:"overview",level:3},{value:"Algorithm Steps",id:"algorithm-steps",level:3},{value:"Example Implementation",id:"example-implementation",level:3},{value:"Using Depth-First Search (DFS)",id:"using-depth-first-search-dfs",level:4},{value:"Using BFS",id:"using-bfs",level:3}];function c(n){const e={code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h2,{id:"flood-fill-algorithm",children:"Flood Fill Algorithm"}),"\n",(0,i.jsx)(e.p,{children:"The Flood Fill Algorithm is used to determine the area connected to a given node in a multi-dimensional array or grid. It is commonly used in computer graphics for tasks such as filling bounded areas with a color, and in image processing to identify regions within an image. The algorithm can be implemented using either Depth-First Search (DFS) or Breadth-First Search (BFS)."}),"\n",(0,i.jsx)(e.h3,{id:"overview",children:"Overview"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Flood Fill"})," works by starting from a given pixel or node and spreading out to adjacent nodes with the same value until the boundary or a different value is encountered."]}),"\n",(0,i.jsx)(e.h3,{id:"algorithm-steps",children:"Algorithm Steps"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Initialization"}),": Start with the initial pixel or node."]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Traversal"}),":","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"DFS"}),": Use a stack to explore all connected pixels or nodes."]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"BFS"}),": Use a queue to explore all connected pixels or nodes."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Update"}),": Change the value of the pixel or node being processed."]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Continue"}),": Process all connected pixels or nodes until the boundary is reached."]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"example-implementation",children:"Example Implementation"}),"\n",(0,i.jsx)(e.h4,{id:"using-depth-first-search-dfs",children:"Using Depth-First Search (DFS)"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Code Example"}),":"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"/**\n * Perform a flood fill operation using Depth-First Search (DFS).\n * @param {number[][]} grid - The 2D grid representing the image.\n * @param {number} sr - The starting row index.\n * @param {number} sc - The starting column index.\n * @param {number} newColor - The new color to fill.\n * @return {number[][]} - The updated grid after flood fill.\n */\nconst floodFillDFS = (grid, sr, sc, newColor) => {\n  const oldColor = grid[sr][sc];\n  if (oldColor === newColor) return grid;\n\n  const dfs = (r, c) => {\n    if (\n      r < 0 ||\n      r >= grid.length ||\n      c < 0 ||\n      c >= grid[0].length ||\n      grid[r][c] !== oldColor\n    ) {\n      return;\n    }\n    grid[r][c] = newColor;\n    dfs(r + 1, c);\n    dfs(r - 1, c);\n    dfs(r, c + 1);\n    dfs(r, c - 1);\n  };\n\n  dfs(sr, sc);\n  return grid;\n};\n\n// Example usage:\nconst image = [\n  [1, 1, 1],\n  [1, 1, 0],\n  [1, 0, 1],\n];\nconst sr = 1;\nconst sc = 1;\nconst newColor = 2;\n\nconsole.log(floodFillDFS(image, sr, sc, newColor));\n// Output: [[2, 2, 2], [2, 2, 0], [2, 0, 1]]\n"})}),"\n",(0,i.jsx)(e.h3,{id:"using-bfs",children:"Using BFS"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-JavaScript",children:"/**\n * Perform a flood fill operation using Breadth-First Search (BFS).\n * @param {number[][]} grid - The 2D grid representing the image.\n * @param {number} sr - The starting row index.\n * @param {number} sc - The starting column index.\n * @param {number} newColor - The new color to fill.\n * @return {number[][]} - The updated grid after flood fill.\n */\nconst floodFillBFS = (grid, sr, sc, newColor) => {\n  const oldColor = grid[sr][sc];\n  if (oldColor === newColor) return grid;\n\n  const queue = [[sr, sc]];\n  grid[sr][sc] = newColor;\n\n  const directions = [[1, 0], [-1, 0], [0, 1], [0, -1]];\n\n  while (queue.length > 0) {\n    const [r, c] = queue.shift();\n\n    for (const [dr, dc] of directions) {\n      const nr = r + dr;\n      const nc = c + dc;\n\n      if (nr >= 0 && nr < grid.length && nc >= 0 && nc < grid[0].length && grid[nr][nc] === oldColor) {\n        grid[nr][nc] = newColor;\n        queue.push([nr, nc]);\n      }\n    }\n  }\n\n  return grid;\n};\n\n// Example usage:\nconst image = [\n  [1, 1, 1],\n  [1, 1, 0],\n  [1, 0, 1]\n];\nconst sr = 1;\nconst sc = 1;\nconst newColor = 2;\n\nconsole.log(floodFillBFS(image, sr, sc, newColor));\n// Output: [[2, 2, 2], [2, 2, 0], [2, 0, 1]]\n\n"})})]})}function h(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(c,{...n})}):c(n)}},28453:(n,e,r)=>{r.d(e,{R:()=>t,x:()=>s});var i=r(96540);const o={},l=i.createContext(o);function t(n){const e=i.useContext(l);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:t(n.components),i.createElement(l.Provider,{value:e},n.children)}}}]);