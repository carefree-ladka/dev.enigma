"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[4270],{7162:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>c,frontMatter:()=>i,metadata:()=>a,toc:()=>d});var t=r(4848),l=r(8453);const i={},s="Binary Tree View Implementations",a={id:"DSA/DSA with Java/Binary Tree View Implementations",title:"Binary Tree View Implementations",description:"A comprehensive guide to binary tree traversal and view algorithms using ArrayDeque for optimal performance in Data Structures and Algorithms.",source:"@site/docs/DSA/DSA with Java/Binary Tree View Implementations.mdx",sourceDirName:"DSA/DSA with Java",slug:"/DSA/DSA with Java/Binary Tree View Implementations",permalink:"/js.enigma/docs/DSA/DSA with Java/Binary Tree View Implementations",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with Java/Binary Tree View Implementations.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Binary Tree Recursion",permalink:"/js.enigma/docs/DSA/DSA with Java/Binary Tree Recusion Patterns"},next:{title:"Bit Manipulation",permalink:"/js.enigma/docs/DSA/DSA with Java/Bit Manipulation"}},o={},d=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Basic Node Structures",id:"basic-node-structures",level:2},{value:"Binary Tree Node",id:"binary-tree-node",level:3},{value:"Enhanced Node with Coordinates",id:"enhanced-node-with-coordinates",level:3},{value:"Node with Horizontal Distance",id:"node-with-horizontal-distance",level:3},{value:"ArrayDeque Fundamentals",id:"arraydeque-fundamentals",level:2},{value:"Why ArrayDeque over LinkedList?",id:"why-arraydeque-over-linkedlist",level:3},{value:"ArrayDeque as Queue",id:"arraydeque-as-queue",level:3},{value:"ArrayDeque as Stack",id:"arraydeque-as-stack",level:3},{value:"ArrayDeque Performance Characteristics[3]",id:"arraydeque-performance-characteristics3",level:3},{value:"Tree Construction Helpers",id:"tree-construction-helpers",level:2},{value:"Create Tree from Array (Level Order)",id:"create-tree-from-array-level-order",level:3},{value:"Print Tree Structure",id:"print-tree-structure",level:3},{value:"Top View Implementation",id:"top-view-implementation",level:2},{value:"1. Top View (Horizontal Distance Based)",id:"1-top-view-horizontal-distance-based",level:3},{value:"2. Top View with Level Priority",id:"2-top-view-with-level-priority",level:3},{value:"Bottom View Implementation",id:"bottom-view-implementation",level:2},{value:"1. Bottom View (Always Update Strategy)",id:"1-bottom-view-always-update-strategy",level:3},{value:"2. Bottom View with Maximum Level",id:"2-bottom-view-with-maximum-level",level:3},{value:"Left View Implementation",id:"left-view-implementation",level:2},{value:"1. Left View (Level Order)",id:"1-left-view-level-order",level:3},{value:"2. Left View (Recursive DFS)",id:"2-left-view-recursive-dfs",level:3},{value:"3. Left View with Node Details",id:"3-left-view-with-node-details",level:3},{value:"Right View Implementation",id:"right-view-implementation",level:2},{value:"1. Right View (Level Order)",id:"1-right-view-level-order",level:3},{value:"2. Right View (Recursive DFS)",id:"2-right-view-recursive-dfs",level:3},{value:"3. Right View Optimized BFS",id:"3-right-view-optimized-bfs",level:3},{value:"Boundary Traversal",id:"boundary-traversal",level:2},{value:"1. Complete Boundary Traversal",id:"1-complete-boundary-traversal",level:3},{value:"2. Boundary with Specific Order",id:"2-boundary-with-specific-order",level:3},{value:"Vertical Order Traversal",id:"vertical-order-traversal",level:2},{value:"1. Vertical Order (Column-wise)",id:"1-vertical-order-column-wise",level:3},{value:"2. Vertical Order with Level Priority",id:"2-vertical-order-with-level-priority",level:3},{value:"Level Order Views",id:"level-order-views",level:2},{value:"1. Level Order Traversal",id:"1-level-order-traversal",level:3},{value:"2. Zigzag Level Order",id:"2-zigzag-level-order",level:3},{value:"3. Reverse Level Order[12]",id:"3-reverse-level-order12",level:3},{value:"Diagonal Views",id:"diagonal-views",level:2},{value:"1. Diagonal Traversal (Slope -1)",id:"1-diagonal-traversal-slope--1",level:3},{value:"2. Anti-Diagonal Traversal",id:"2-anti-diagonal-traversal",level:3},{value:"Advanced View Techniques",id:"advanced-view-techniques",level:2},{value:"1. Generic View with Custom Comparator",id:"1-generic-view-with-custom-comparator",level:3},{value:"2. View with Distance Calculation",id:"2-view-with-distance-calculation",level:3},{value:"3. Morris Traversal for Views",id:"3-morris-traversal-for-views",level:3},{value:"Usage Examples",id:"usage-examples",level:2},{value:"Time Complexity Summary",id:"time-complexity-summary",level:2},{value:"ArrayDeque vs LinkedList Performance[5]",id:"arraydeque-vs-linkedlist-performance5",level:2},{value:"Common Patterns to Remember",id:"common-patterns-to-remember",level:2},{value:"1. <strong>Horizontal Distance Pattern</strong>",id:"1-horizontal-distance-pattern",level:3},{value:"2. <strong>Level Tracking Pattern</strong>",id:"2-level-tracking-pattern",level:3},{value:"3. <strong>TreeMap with Sorting Pattern</strong>",id:"3-treemap-with-sorting-pattern",level:3},{value:"4. <strong>BFS Level Processing</strong>",id:"4-bfs-level-processing",level:3},{value:"5. <strong>ArrayDeque as Stack Pattern</strong>",id:"5-arraydeque-as-stack-pattern",level:3},{value:"Key Interview Tips",id:"key-interview-tips",level:2}];function u(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"binary-tree-view-implementations",children:"Binary Tree View Implementations"})}),"\n",(0,t.jsx)(n.p,{children:"A comprehensive guide to binary tree traversal and view algorithms using ArrayDeque for optimal performance in Data Structures and Algorithms."}),"\n",(0,t.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#basic-node-structures",children:"Basic Node Structures"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#arraydeque-fundamentals",children:"ArrayDeque Fundamentals"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#tree-construction-helpers",children:"Tree Construction Helpers"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#top-view-implementation",children:"Top View Implementation"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#bottom-view-implementation",children:"Bottom View Implementation"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#left-view-implementation",children:"Left View Implementation"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#right-view-implementation",children:"Right View Implementation"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#boundary-traversal",children:"Boundary Traversal"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#vertical-order-traversal",children:"Vertical Order Traversal"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#level-order-views",children:"Level Order Views"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#diagonal-views",children:"Diagonal Views"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#advanced-view-techniques",children:"Advanced View Techniques"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#usage-examples",children:"Usage Examples"})}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"basic-node-structures",children:"Basic Node Structures"}),"\n",(0,t.jsx)(n.p,{children:"The foundation of binary tree operations starts with node definitions:"}),"\n",(0,t.jsx)(n.h3,{id:"binary-tree-node",children:"Binary Tree Node"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    TreeNode() {}\n\n    TreeNode(int val) {\n        this.val = val;\n    }\n\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"enhanced-node-with-coordinates",children:"Enhanced Node with Coordinates"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"class TreeNodeWithCoords {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    int row;    // Level/depth\n    int col;    // Horizontal distance\n\n    TreeNodeWithCoords(int val, int row, int col) {\n        this.val = val;\n        this.row = row;\n        this.col = col;\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"node-with-horizontal-distance",children:"Node with Horizontal Distance"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"class QueueNode {\n    TreeNode node;\n    int hd;     // Horizontal Distance\n    int level;  // Level from root\n\n    QueueNode(TreeNode node, int hd) {\n        this.node = node;\n        this.hd = hd;\n    }\n\n    QueueNode(TreeNode node, int hd, int level) {\n        this.node = node;\n        this.hd = hd;\n        this.level = level;\n    }\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"arraydeque-fundamentals",children:"ArrayDeque Fundamentals"}),"\n",(0,t.jsx)(n.h3,{id:"why-arraydeque-over-linkedlist",children:"Why ArrayDeque over LinkedList?"}),"\n",(0,t.jsxs)(n.p,{children:["ArrayDeque provides ",(0,t.jsx)(n.strong,{children:"O(1)"})," operations for both ends and is ",(0,t.jsx)(n.strong,{children:"faster than LinkedList"})," for queue operations in tree traversals."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Key Advantages:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"O(1)"})," enqueue/dequeue operations"]}),"\n",(0,t.jsx)(n.li,{children:"Better cache locality than LinkedList"}),"\n",(0,t.jsx)(n.li,{children:"No node allocation overhead"}),"\n",(0,t.jsx)(n.li,{children:"Circular array implementation"}),"\n",(0,t.jsxs)(n.li,{children:["Suitable for both ",(0,t.jsx)(n.strong,{children:"Queue"})," and ",(0,t.jsx)(n.strong,{children:"Stack"})," operations"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"arraydeque-as-queue",children:"ArrayDeque as Queue"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"import java.util.ArrayDeque;\nimport java.util.Queue;\n\n// Using as Queue (FIFO)\nQueue<TreeNode> queue = new ArrayDeque<>();\nqueue.offer(node);        // Add to rear\nTreeNode current = queue.poll(); // Remove from front\n"})}),"\n",(0,t.jsx)(n.h3,{id:"arraydeque-as-stack",children:"ArrayDeque as Stack"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"import java.util.ArrayDeque;\nimport java.util.Deque;\n\n// Using as Stack (LIFO)\nDeque<TreeNode> stack = new ArrayDeque<>();\nstack.push(node);         // Add to front\nTreeNode current = stack.pop(); // Remove from front\n"})}),"\n",(0,t.jsx)(n.h3,{id:"arraydeque-performance-characteristics3",children:"ArrayDeque Performance Characteristics[3]"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{style:{textAlign:"left"},children:"Operation"}),(0,t.jsx)(n.th,{style:{textAlign:"left"},children:"Time Complexity"}),(0,t.jsx)(n.th,{style:{textAlign:"left"},children:"Space Complexity"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"offer/offerLast"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(1)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(1)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"offerFirst"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(1)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(1)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"poll/pollFirst"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(1)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(1)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"pollLast"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(1)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(1)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"peek/peekFirst"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(1)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(1)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"peekLast"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(1)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(1)"})]})]})]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"tree-construction-helpers",children:"Tree Construction Helpers"}),"\n",(0,t.jsx)(n.h3,{id:"create-tree-from-array-level-order",children:"Create Tree from Array (Level Order)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"public static TreeNode createTreeFromArray(Integer[] arr) {\n    if (arr == null || arr.length == 0) return null;\n\n    TreeNode root = new TreeNode(arr[0]);\n    Queue<TreeNode> queue = new ArrayDeque<>();\n    queue.offer(root);\n    int i = 1;\n\n    while (!queue.isEmpty() && i < arr.length) {\n        TreeNode node = queue.poll();\n\n        if (i < arr.length && arr[i] != null) {\n            node.left = new TreeNode(arr[i]);\n            queue.offer(node.left);\n        }\n        i++;\n\n        if (i < arr.length && arr[i] != null) {\n            node.right = new TreeNode(arr[i]);\n            queue.offer(node.right);\n        }\n        i++;\n    }\n\n    return root;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"print-tree-structure",children:"Print Tree Structure"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'public static void printTree(TreeNode root) {\n    printTree(root, "", true);\n}\n\nprivate static void printTree(TreeNode root, String prefix, boolean isLast) {\n    if (root == null) return;\n\n    System.out.println(prefix + (isLast ? "\u2514\u2500\u2500 " : "\u251c\u2500\u2500 ") + root.val);\n\n    List<TreeNode> children = new ArrayList<>();\n    if (root.left != null) children.add(root.left);\n    if (root.right != null) children.add(root.right);\n\n    for (int i = 0; i < children.size(); i++) {\n        boolean isLastChild = (i == children.size() - 1);\n        String newPrefix = prefix + (isLast ? "    " : "\u2502   ");\n        printTree(children.get(i), newPrefix, isLastChild);\n    }\n}\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"top-view-implementation",children:"Top View Implementation"}),"\n",(0,t.jsx)(n.h3,{id:"1-top-view-horizontal-distance-based",children:"1. Top View (Horizontal Distance Based)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Concept"}),": View the tree from above - only the topmost node at each horizontal distance is visible."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"import java.util.*;\n\npublic static List<Integer> topView(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n    if (root == null) return result;\n\n    // TreeMap to store horizontal distance -> node value\n    TreeMap<Integer, Integer> map = new TreeMap<>();\n    Queue<QueueNode> queue = new ArrayDeque<>();\n\n    queue.offer(new QueueNode(root, 0));\n\n    while (!queue.isEmpty()) {\n        QueueNode current = queue.poll();\n        int hd = current.hd;\n        TreeNode node = current.node;\n\n        // Only add if this horizontal distance hasn't been seen\n        if (!map.containsKey(hd)) {\n            map.put(hd, node.val);\n        }\n\n        if (node.left != null) {\n            queue.offer(new QueueNode(node.left, hd - 1));\n        }\n        if (node.right != null) {\n            queue.offer(new QueueNode(node.right, hd + 1));\n        }\n    }\n\n    // TreeMap automatically sorts by key (horizontal distance)\n    result.addAll(map.values());\n    return result;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Time Complexity:"})," O(n log n) | ",(0,t.jsx)(n.strong,{children:"Space Complexity:"})," O(n)"]}),"\n",(0,t.jsx)(n.h3,{id:"2-top-view-with-level-priority",children:"2. Top View with Level Priority"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"public static List<Integer> topViewWithLevel(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n    if (root == null) return result;\n\n    class NodeInfo {\n        int val, level;\n        NodeInfo(int val, int level) {\n            this.val = val;\n            this.level = level;\n        }\n    }\n\n    TreeMap<Integer, NodeInfo> map = new TreeMap<>();\n    Queue<QueueNode> queue = new ArrayDeque<>();\n\n    queue.offer(new QueueNode(root, 0, 0));\n\n    while (!queue.isEmpty()) {\n        QueueNode current = queue.poll();\n        int hd = current.hd;\n        int level = current.level;\n        TreeNode node = current.node;\n\n        if (!map.containsKey(hd) || map.get(hd).level > level) {\n            map.put(hd, new NodeInfo(node.val, level));\n        }\n\n        if (node.left != null) {\n            queue.offer(new QueueNode(node.left, hd - 1, level + 1));\n        }\n        if (node.right != null) {\n            queue.offer(new QueueNode(node.right, hd + 1, level + 1));\n        }\n    }\n\n    for (NodeInfo info : map.values()) {\n        result.add(info.val);\n    }\n    return result;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Example"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"     1\n   /   \\\n  2     3\n / \\   / \\\n4   5 6   7\n\nTop View: [4, 2, 1, 3, 7]\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"bottom-view-implementation",children:"Bottom View Implementation"}),"\n",(0,t.jsx)(n.h3,{id:"1-bottom-view-always-update-strategy",children:"1. Bottom View (Always Update Strategy)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Concept"}),": View the tree from below - only the bottommost node at each horizontal distance is visible.[7]"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"public static List<Integer> bottomView(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n    if (root == null) return result;\n\n    TreeMap<Integer, Integer> map = new TreeMap<>();\n    Queue<QueueNode> queue = new ArrayDeque<>();\n\n    queue.offer(new QueueNode(root, 0));\n\n    while (!queue.isEmpty()) {\n        QueueNode current = queue.poll();\n        int hd = current.hd;\n        TreeNode node = current.node;\n\n        // Always update - last one at this distance wins\n        map.put(hd, node.val);\n\n        if (node.left != null) {\n            queue.offer(new QueueNode(node.left, hd - 1));\n        }\n        if (node.right != null) {\n            queue.offer(new QueueNode(node.right, hd + 1));\n        }\n    }\n\n    result.addAll(map.values());\n    return result;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Time Complexity:"})," O(n log n) | ",(0,t.jsx)(n.strong,{children:"Space Complexity:"})," O(n)"]}),"\n",(0,t.jsx)(n.h3,{id:"2-bottom-view-with-maximum-level",children:"2. Bottom View with Maximum Level"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"public static List<Integer> bottomViewMaxLevel(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n    if (root == null) return result;\n\n    class NodeInfo {\n        int val, level;\n        NodeInfo(int val, int level) {\n            this.val = val;\n            this.level = level;\n        }\n    }\n\n    TreeMap<Integer, NodeInfo> map = new TreeMap<>();\n    Queue<QueueNode> queue = new ArrayDeque<>();\n\n    queue.offer(new QueueNode(root, 0, 0));\n\n    while (!queue.isEmpty()) {\n        QueueNode current = queue.poll();\n        int hd = current.hd;\n        int level = current.level;\n        TreeNode node = current.node;\n\n        if (!map.containsKey(hd) || map.get(hd).level <= level) {\n            map.put(hd, new NodeInfo(node.val, level));\n        }\n\n        if (node.left != null) {\n            queue.offer(new QueueNode(node.left, hd - 1, level + 1));\n        }\n        if (node.right != null) {\n            queue.offer(new QueueNode(node.right, hd + 1, level + 1));\n        }\n    }\n\n    for (NodeInfo info : map.values()) {\n        result.add(info.val);\n    }\n    return result;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Example"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"     1\n   /   \\\n  2     3\n / \\   / \\\n4   5 6   7\n\nBottom View: [4, 5, 6, 7]\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"left-view-implementation",children:"Left View Implementation"}),"\n",(0,t.jsx)(n.h3,{id:"1-left-view-level-order",children:"1. Left View (Level Order)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Concept"}),": View from the left side - first node encountered at each level."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"public static List<Integer> leftView(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n    if (root == null) return result;\n\n    Queue<TreeNode> queue = new ArrayDeque<>();\n    queue.offer(root);\n\n    while (!queue.isEmpty()) {\n        int levelSize = queue.size();\n\n        for (int i = 0; i < levelSize; i++) {\n            TreeNode node = queue.poll();\n\n            // First node of each level\n            if (i == 0) {\n                result.add(node.val);\n            }\n\n            if (node.left != null) queue.offer(node.left);\n            if (node.right != null) queue.offer(node.right);\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Time Complexity:"})," O(n) | ",(0,t.jsx)(n.strong,{children:"Space Complexity:"})," O(w) where w is max width"]}),"\n",(0,t.jsx)(n.h3,{id:"2-left-view-recursive-dfs",children:"2. Left View (Recursive DFS)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"public static List<Integer> leftViewRecursive(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n    leftViewHelper(root, 0, result);\n    return result;\n}\n\nprivate static void leftViewHelper(TreeNode node, int level, List<Integer> result) {\n    if (node == null) return;\n\n    // First time visiting this level\n    if (level == result.size()) {\n        result.add(node.val);\n    }\n\n    leftViewHelper(node.left, level + 1, result);   // Visit left first\n    leftViewHelper(node.right, level + 1, result);\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Time Complexity:"})," O(n) | ",(0,t.jsx)(n.strong,{children:"Space Complexity:"})," O(h) where h is height"]}),"\n",(0,t.jsx)(n.h3,{id:"3-left-view-with-node-details",children:"3. Left View with Node Details"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'public static List<Map<String, Integer>> leftViewWithDetails(TreeNode root) {\n    List<Map<String, Integer>> result = new ArrayList<>();\n    if (root == null) return result;\n\n    Queue<TreeNode> queue = new ArrayDeque<>();\n    queue.offer(root);\n    int currentLevel = 0;\n\n    while (!queue.isEmpty()) {\n        int levelSize = queue.size();\n\n        for (int i = 0; i < levelSize; i++) {\n            TreeNode node = queue.poll();\n\n            if (i == 0) {\n                Map<String, Integer> nodeInfo = new HashMap<>();\n                nodeInfo.put("val", node.val);\n                nodeInfo.put("level", currentLevel);\n                result.add(nodeInfo);\n            }\n\n            if (node.left != null) queue.offer(node.left);\n            if (node.right != null) queue.offer(node.right);\n        }\n        currentLevel++;\n    }\n\n    return result;\n}\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"right-view-implementation",children:"Right View Implementation"}),"\n",(0,t.jsx)(n.h3,{id:"1-right-view-level-order",children:"1. Right View (Level Order)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Concept"}),": View from the right side - last node encountered at each level."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"public static List<Integer> rightView(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n    if (root == null) return result;\n\n    Queue<TreeNode> queue = new ArrayDeque<>();\n    queue.offer(root);\n\n    while (!queue.isEmpty()) {\n        int levelSize = queue.size();\n\n        for (int i = 0; i < levelSize; i++) {\n            TreeNode node = queue.poll();\n\n            // Last node of each level\n            if (i == levelSize - 1) {\n                result.add(node.val);\n            }\n\n            if (node.left != null) queue.offer(node.left);\n            if (node.right != null) queue.offer(node.right);\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"2-right-view-recursive-dfs",children:"2. Right View (Recursive DFS)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"public static List<Integer> rightViewRecursive(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n    rightViewHelper(root, 0, result);\n    return result;\n}\n\nprivate static void rightViewHelper(TreeNode node, int level, List<Integer> result) {\n    if (node == null) return;\n\n    // First time visiting this level\n    if (level == result.size()) {\n        result.add(node.val);\n    }\n\n    rightViewHelper(node.right, level + 1, result);  // Visit right first\n    rightViewHelper(node.left, level + 1, result);\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"3-right-view-optimized-bfs",children:"3. Right View Optimized BFS"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"public static List<Integer> rightViewOptimized(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n    if (root == null) return result;\n\n    Queue<TreeNode> queue = new ArrayDeque<>();\n    queue.offer(root);\n\n    while (!queue.isEmpty()) {\n        int size = queue.size();\n        TreeNode rightmost = null;\n\n        // Process all nodes at current level\n        for (int i = 0; i < size; i++) {\n            TreeNode node = queue.poll();\n            rightmost = node; // Keep updating, last one will be rightmost\n\n            if (node.left != null) queue.offer(node.left);\n            if (node.right != null) queue.offer(node.right);\n        }\n\n        if (rightmost != null) {\n            result.add(rightmost.val);\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"boundary-traversal",children:"Boundary Traversal"}),"\n",(0,t.jsx)(n.h3,{id:"1-complete-boundary-traversal",children:"1. Complete Boundary Traversal"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Concept"}),": Print boundary nodes in anti-clockwise direction."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"public static List<Integer> boundaryTraversal(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n    if (root == null) return result;\n\n    // Add root if not leaf\n    if (!isLeaf(root)) {\n        result.add(root.val);\n    }\n\n    // Add left boundary (excluding root and leaves)\n    addLeftBoundary(root.left, result);\n\n    // Add all leaves\n    addLeaves(root, result);\n\n    // Add right boundary (excluding root and leaves) in reverse\n    addRightBoundary(root.right, result);\n\n    return result;\n}\n\nprivate static boolean isLeaf(TreeNode node) {\n    return node != null && node.left == null && node.right == null;\n}\n\nprivate static void addLeftBoundary(TreeNode node, List<Integer> result) {\n    while (node != null) {\n        if (!isLeaf(node)) {\n            result.add(node.val);\n        }\n\n        if (node.left != null) {\n            node = node.left;\n        } else {\n            node = node.right;\n        }\n    }\n}\n\nprivate static void addRightBoundary(TreeNode node, List<Integer> result) {\n    Deque<Integer> stack = new ArrayDeque<>();\n\n    while (node != null) {\n        if (!isLeaf(node)) {\n            stack.push(node.val);\n        }\n\n        if (node.right != null) {\n            node = node.right;\n        } else {\n            node = node.left;\n        }\n    }\n\n    // Add in reverse order\n    while (!stack.isEmpty()) {\n        result.add(stack.pop());\n    }\n}\n\nprivate static void addLeaves(TreeNode node, List<Integer> result) {\n    if (node == null) return;\n\n    if (isLeaf(node)) {\n        result.add(node.val);\n        return;\n    }\n\n    addLeaves(node.left, result);\n    addLeaves(node.right, result);\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"2-boundary-with-specific-order",children:"2. Boundary with Specific Order"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"public static List<Integer> boundaryAntiClockwise(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n    if (root == null) return result;\n\n    result.add(root.val);\n\n    // Left boundary (top to bottom, excluding root and leaves)\n    List<Integer> leftBoundary = new ArrayList<>();\n    TreeNode curr = root.left;\n    while (curr != null) {\n        if (!isLeaf(curr)) {\n            leftBoundary.add(curr.val);\n        }\n        curr = (curr.left != null) ? curr.left : curr.right;\n    }\n\n    // Leaves (left to right)\n    List<Integer> leaves = new ArrayList<>();\n    collectLeaves(root, leaves);\n\n    // Right boundary (bottom to top, excluding root and leaves)\n    List<Integer> rightBoundary = new ArrayList<>();\n    curr = root.right;\n    while (curr != null) {\n        if (!isLeaf(curr)) {\n            rightBoundary.add(curr.val);\n        }\n        curr = (curr.right != null) ? curr.right : curr.left;\n    }\n\n    result.addAll(leftBoundary);\n    for (Integer leaf : leaves) {\n        if (!leaf.equals(root.val)) {\n            result.add(leaf);\n        }\n    }\n    Collections.reverse(rightBoundary);\n    result.addAll(rightBoundary);\n\n    return result;\n}\n\nprivate static void collectLeaves(TreeNode node, List<Integer> leaves) {\n    if (node == null) return;\n\n    if (isLeaf(node)) {\n        leaves.add(node.val);\n    } else {\n        collectLeaves(node.left, leaves);\n        collectLeaves(node.right, leaves);\n    }\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"vertical-order-traversal",children:"Vertical Order Traversal"}),"\n",(0,t.jsx)(n.h3,{id:"1-vertical-order-column-wise",children:"1. Vertical Order (Column-wise)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"public static List<List<Integer>> verticalOrder(TreeNode root) {\n    List<List<Integer>> result = new ArrayList<>();\n    if (root == null) return result;\n\n    TreeMap<Integer, List<Integer>> map = new TreeMap<>();\n    Queue<QueueNode> queue = new ArrayDeque<>();\n\n    queue.offer(new QueueNode(root, 0));\n\n    while (!queue.isEmpty()) {\n        QueueNode current = queue.poll();\n        int col = current.hd;\n        TreeNode node = current.node;\n\n        map.computeIfAbsent(col, k -> new ArrayList<>()).add(node.val);\n\n        if (node.left != null) {\n            queue.offer(new QueueNode(node.left, col - 1));\n        }\n        if (node.right != null) {\n            queue.offer(new QueueNode(node.right, col + 1));\n        }\n    }\n\n    result.addAll(map.values());\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"2-vertical-order-with-level-priority",children:"2. Vertical Order with Level Priority"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"public static List<List<Integer>> verticalOrderWithLevel(TreeNode root) {\n    List<List<Integer>> result = new ArrayList<>();\n    if (root == null) return result;\n\n    class NodeInfo {\n        int val, level;\n        NodeInfo(int val, int level) {\n            this.val = val;\n            this.level = level;\n        }\n    }\n\n    TreeMap<Integer, List<NodeInfo>> map = new TreeMap<>();\n    Queue<QueueNode> queue = new ArrayDeque<>();\n\n    queue.offer(new QueueNode(root, 0, 0));\n\n    while (!queue.isEmpty()) {\n        QueueNode current = queue.poll();\n        int col = current.hd;\n        int level = current.level;\n        TreeNode node = current.node;\n\n        map.computeIfAbsent(col, k -> new ArrayList<>())\n           .add(new NodeInfo(node.val, level));\n\n        if (node.left != null) {\n            queue.offer(new QueueNode(node.left, col - 1, level + 1));\n        }\n        if (node.right != null) {\n            queue.offer(new QueueNode(node.right, col + 1, level + 1));\n        }\n    }\n\n    for (List<NodeInfo> nodes : map.values()) {\n        nodes.sort((a, b) -> {\n            if (a.level != b.level) return Integer.compare(a.level, b.level);\n            return Integer.compare(a.val, b.val);\n        });\n\n        List<Integer> column = new ArrayList<>();\n        for (NodeInfo info : nodes) {\n            column.add(info.val);\n        }\n        result.add(column);\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"level-order-views",children:"Level Order Views"}),"\n",(0,t.jsx)(n.h3,{id:"1-level-order-traversal",children:"1. Level Order Traversal"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"public static List<List<Integer>> levelOrder(TreeNode root) {\n    List<List<Integer>> result = new ArrayList<>();\n    if (root == null) return result;\n\n    Queue<TreeNode> queue = new ArrayDeque<>();\n    queue.offer(root);\n\n    while (!queue.isEmpty()) {\n        int levelSize = queue.size();\n        List<Integer> currentLevel = new ArrayList<>();\n\n        for (int i = 0; i < levelSize; i++) {\n            TreeNode node = queue.poll();\n            currentLevel.add(node.val);\n\n            if (node.left != null) queue.offer(node.left);\n            if (node.right != null) queue.offer(node.right);\n        }\n\n        result.add(currentLevel);\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"2-zigzag-level-order",children:"2. Zigzag Level Order"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"public static List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n    List<List<Integer>> result = new ArrayList<>();\n    if (root == null) return result;\n\n    Queue<TreeNode> queue = new ArrayDeque<>();\n    queue.offer(root);\n    boolean leftToRight = true;\n\n    while (!queue.isEmpty()) {\n        int levelSize = queue.size();\n        List<Integer> currentLevel = new ArrayList<>();\n\n        for (int i = 0; i < levelSize; i++) {\n            TreeNode node = queue.poll();\n\n            if (leftToRight) {\n                currentLevel.add(node.val);\n            } else {\n                currentLevel.add(0, node.val); // Add to beginning for reverse order\n            }\n\n            if (node.left != null) queue.offer(node.left);\n            if (node.right != null) queue.offer(node.right);\n        }\n\n        result.add(currentLevel);\n        leftToRight = !leftToRight;\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"3-reverse-level-order12",children:"3. Reverse Level Order[12]"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"public static List<List<Integer>> reverseLevelOrder(TreeNode root) {\n    List<List<Integer>> result = new ArrayList<>();\n    if (root == null) return result;\n\n    Queue<TreeNode> queue = new ArrayDeque<>();\n    Deque<List<Integer>> stack = new ArrayDeque<>(); // Using ArrayDeque as stack\n\n    queue.offer(root);\n\n    while (!queue.isEmpty()) {\n        int levelSize = queue.size();\n        List<Integer> currentLevel = new ArrayList<>();\n\n        for (int i = 0; i < levelSize; i++) {\n            TreeNode node = queue.poll();\n            currentLevel.add(node.val);\n\n            if (node.left != null) queue.offer(node.left);\n            if (node.right != null) queue.offer(node.right);\n        }\n\n        stack.push(currentLevel); // Push level to stack\n    }\n\n    // Pop all levels from stack to get reverse order\n    while (!stack.isEmpty()) {\n        result.add(stack.pop());\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"diagonal-views",children:"Diagonal Views"}),"\n",(0,t.jsx)(n.h3,{id:"1-diagonal-traversal-slope--1",children:"1. Diagonal Traversal (Slope -1)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"public static List<List<Integer>> diagonalTraversal(TreeNode root) {\n    List<List<Integer>> result = new ArrayList<>();\n    if (root == null) return result;\n\n    Queue<TreeNode> queue = new ArrayDeque<>();\n    queue.offer(root);\n\n    while (!queue.isEmpty()) {\n        int size = queue.size();\n        List<Integer> diagonal = new ArrayList<>();\n\n        for (int i = 0; i < size; i++) {\n            TreeNode node = queue.poll();\n\n            // Follow the diagonal (keep going right)\n            while (node != null) {\n                diagonal.add(node.val);\n\n                if (node.left != null) {\n                    queue.offer(node.left);\n                }\n\n                node = node.right;\n            }\n        }\n\n        if (!diagonal.isEmpty()) {\n            result.add(diagonal);\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"2-anti-diagonal-traversal",children:"2. Anti-Diagonal Traversal"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"public static List<List<Integer>> antiDiagonalTraversal(TreeNode root) {\n    List<List<Integer>> result = new ArrayList<>();\n    if (root == null) return result;\n\n    TreeMap<Integer, List<Integer>> map = new TreeMap<>();\n\n    antiDiagonalHelper(root, 0, map);\n\n    result.addAll(map.values());\n    return result;\n}\n\nprivate static void antiDiagonalHelper(TreeNode node, int diag,\n                                      TreeMap<Integer, List<Integer>> map) {\n    if (node == null) return;\n\n    map.computeIfAbsent(diag, k -> new ArrayList<>()).add(node.val);\n\n    antiDiagonalHelper(node.left, diag + 1, map);\n    antiDiagonalHelper(node.right, diag - 1, map);\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"advanced-view-techniques",children:"Advanced View Techniques"}),"\n",(0,t.jsx)(n.h3,{id:"1-generic-view-with-custom-comparator",children:"1. Generic View with Custom Comparator"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"public static List<Integer> customView(TreeNode root,\n                                     BiPredicate<NodeInfo, NodeInfo> shouldReplace) {\n    List<Integer> result = new ArrayList<>();\n    if (root == null) return result;\n\n    class NodeInfo {\n        int val, level;\n        NodeInfo(int val, int level) {\n            this.val = val;\n            this.level = level;\n        }\n    }\n\n    TreeMap<Integer, NodeInfo> map = new TreeMap<>();\n    Queue<QueueNode> queue = new ArrayDeque<>();\n\n    queue.offer(new QueueNode(root, 0, 0));\n\n    while (!queue.isEmpty()) {\n        QueueNode current = queue.poll();\n        int hd = current.hd;\n        int level = current.level;\n        TreeNode node = current.node;\n\n        NodeInfo candidate = new NodeInfo(node.val, level);\n\n        if (!map.containsKey(hd) || shouldReplace.test(map.get(hd), candidate)) {\n            map.put(hd, candidate);\n        }\n\n        if (node.left != null) {\n            queue.offer(new QueueNode(node.left, hd - 1, level + 1));\n        }\n        if (node.right != null) {\n            queue.offer(new QueueNode(node.right, hd + 1, level + 1));\n        }\n    }\n\n    for (NodeInfo info : map.values()) {\n        result.add(info.val);\n    }\n    return result;\n}\n\n// Usage examples:\n// Top view: customView(root, (current, candidate) -> candidate.level < current.level)\n// Bottom view: customView(root, (current, candidate) -> candidate.level >= current.level)\n"})}),"\n",(0,t.jsx)(n.h3,{id:"2-view-with-distance-calculation",children:"2. View with Distance Calculation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'public static List<Map<String, Object>> viewWithDistance(TreeNode root, String viewType) {\n    List<Map<String, Object>> result = new ArrayList<>();\n    if (root == null) return result;\n\n    class NodeInfo {\n        int val, level, distance;\n        NodeInfo(int val, int level, int distance) {\n            this.val = val;\n            this.level = level;\n            this.distance = distance;\n        }\n    }\n\n    TreeMap<Integer, NodeInfo> distances = new TreeMap<>();\n    Queue<QueueNode> queue = new ArrayDeque<>();\n\n    // QueueNode with distance from root\n    class QueueNodeWithDistance extends QueueNode {\n        int distance;\n        QueueNodeWithDistance(TreeNode node, int hd, int level, int distance) {\n            super(node, hd, level);\n            this.distance = distance;\n        }\n    }\n\n    queue.offer(new QueueNodeWithDistance(root, 0, 0, 0));\n\n    while (!queue.isEmpty()) {\n        QueueNodeWithDistance current = (QueueNodeWithDistance) queue.poll();\n        int hd = current.hd;\n        int level = current.level;\n        int distance = current.distance;\n        TreeNode node = current.node;\n\n        boolean shouldUpdate = !distances.containsKey(hd) ||\n            ("top".equals(viewType) && level < distances.get(hd).level) ||\n            ("bottom".equals(viewType) && level >= distances.get(hd).level);\n\n        if (shouldUpdate) {\n            distances.put(hd, new NodeInfo(node.val, level, distance));\n        }\n\n        if (node.left != null) {\n            queue.offer(new QueueNodeWithDistance(node.left, hd - 1, level + 1, distance + 1));\n        }\n        if (node.right != null) {\n            queue.offer(new QueueNodeWithDistance(node.right, hd + 1, level + 1, distance + 1));\n        }\n    }\n\n    for (NodeInfo info : distances.values()) {\n        Map<String, Object> nodeMap = new HashMap<>();\n        nodeMap.put("val", info.val);\n        nodeMap.put("distance", info.distance);\n        result.add(nodeMap);\n    }\n    return result;\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"3-morris-traversal-for-views",children:"3. Morris Traversal for Views"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"public static List<Integer> morrisInorderView(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n    TreeNode current = root;\n\n    while (current != null) {\n        if (current.left == null) {\n            result.add(current.val);\n            current = current.right;\n        } else {\n            // Find predecessor\n            TreeNode predecessor = current.left;\n            while (predecessor.right != null && predecessor.right != current) {\n                predecessor = predecessor.right;\n            }\n\n            if (predecessor.right == null) {\n                predecessor.right = current;\n                current = current.left;\n            } else {\n                predecessor.right = null;\n                result.add(current.val);\n                current = current.right;\n            }\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,t.jsx)(n.p,{children:"Here's how to use these view techniques:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'public class BinaryTreeViewDemo {\n    public static void main(String[] args) {\n        System.out.println("=== Binary Tree View Techniques Demo ===");\n\n        // Create sample tree\n        //       1\n        //     /   \\\n        //    2     3\n        //   / \\   / \\\n        //  4   5 6   7\n        Integer[] treeArray = {1, 2, 3, 4, 5, 6, 7};\n        TreeNode tree = createTreeFromArray(treeArray);\n\n        System.out.println("Tree structure:");\n        printTree(tree);\n\n        System.out.println("\\n=== View Results ===");\n        System.out.println("Top View: " + topView(tree));           // [4, 2, 1, 3, 7]\n        System.out.println("Bottom View: " + bottomView(tree));     // [4, 5, 6, 7]\n        System.out.println("Left View: " + leftView(tree));         // [1, 2, 4]\n        System.out.println("Right View: " + rightView(tree));       // [1, 3, 7]\n\n        List<Integer> boundary = boundaryTraversal(tree);\n        System.out.println("Boundary Traversal: " + boundary);     // [1, 2, 4, 5, 6, 7, 3]\n\n        List<List<Integer>> vertical = verticalOrder(tree);\n        System.out.println("Vertical Order: " + vertical);         // [[4], [2], [1, 5, 6], [3], [7]]\n\n        List<List<Integer>> levelOrder = levelOrder(tree);\n        System.out.println("Level Order: " + levelOrder);          // [[1], [2, 3], [4, 5, 6, 7]]\n\n        List<List<Integer>> zigzag = zigzagLevelOrder(tree);\n        System.out.println("Zigzag Order: " + zigzag);            // [[1], [3, 2], [4, 5, 6, 7]]\n\n        // More complex tree for diagonal\n        //         8\n        //       /   \\\n        //      3     10\n        //     / \\      \\\n        //    1   6     14\n        //       / \\   /\n        //      4   7 13\n        Integer[] complexArray = {8, 3, 10, 1, 6, null, 14, null, null, 4, 7, 13};\n        TreeNode complexTree = createTreeFromArray(complexArray);\n\n        List<List<Integer>> diagonal = diagonalTraversal(complexTree);\n        System.out.println("Diagonal Traversal: " + diagonal);\n\n        // Performance testing\n        System.out.println("\\n=== Performance Testing ===");\n        performanceTest();\n    }\n\n    private static void performanceTest() {\n        // Create large tree (perfect binary tree with 2^10 - 1 = 1023 nodes)\n        TreeNode largeTree = createPerfectBinaryTree(10);\n\n        long startTime = System.nanoTime();\n        topView(largeTree);\n        long endTime = System.nanoTime();\n\n        System.out.println("ArrayDeque Top View - 1023 nodes: " +\n                          (endTime - startTime) / 1_000_000 + "ms");\n\n        startTime = System.nanoTime();\n        rightView(largeTree);\n        endTime = System.nanoTime();\n\n        System.out.println("ArrayDeque Right View - 1023 nodes: " +\n                          (endTime - startTime) / 1_000_000 + "ms");\n    }\n\n    private static TreeNode createPerfectBinaryTree(int depth) {\n        if (depth == 0) return null;\n        TreeNode root = new TreeNode(depth);\n        root.left = createPerfectBinaryTree(depth - 1);\n        root.right = createPerfectBinaryTree(depth - 1);\n        return root;\n    }\n}\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"time-complexity-summary",children:"Time Complexity Summary"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{style:{textAlign:"left"},children:"View Type"}),(0,t.jsx)(n.th,{style:{textAlign:"left"},children:"Time Complexity"}),(0,t.jsx)(n.th,{style:{textAlign:"left"},children:"Space Complexity"}),(0,t.jsx)(n.th,{style:{textAlign:"left"},children:"Notes"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Top View"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(n log n)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"TreeMap sorting by HD"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Bottom View"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(n log n)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"TreeMap sorting by HD"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Left View"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(w)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"w = max width"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Right View"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(w)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"w = max width"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Boundary"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(h)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"h = height"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Vertical Order"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(n log n)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"TreeMap sorting"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Level Order"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(w)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"w = max width"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Zigzag"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(w)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"w = max width"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Diagonal"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"ArrayDeque storage"})]})]})]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"arraydeque-vs-linkedlist-performance5",children:"ArrayDeque vs LinkedList Performance[5]"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"For tree traversals with 10,000 nodes:"})}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{style:{textAlign:"left"},children:"Operation"}),(0,t.jsx)(n.th,{style:{textAlign:"left"},children:"ArrayDeque"}),(0,t.jsx)(n.th,{style:{textAlign:"left"},children:"LinkedList"}),(0,t.jsx)(n.th,{style:{textAlign:"left"},children:"Difference"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:(0,t.jsx)(n.code,{children:"offer()"})}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"~0.5ms"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"~1.2ms"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:(0,t.jsx)(n.strong,{children:"2.4x faster"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:(0,t.jsx)(n.code,{children:"poll()"})}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"~0.3ms"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"~0.8ms"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:(0,t.jsx)(n.strong,{children:"2.7x faster"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:(0,t.jsx)(n.code,{children:"peek()"})}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"~0.1ms"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"~0.2ms"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:(0,t.jsx)(n.strong,{children:"2x faster"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Total Traversal"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"~12ms"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"~28ms"}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:(0,t.jsx)(n.strong,{children:"2.3x faster"})})]})]})]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"common-patterns-to-remember",children:"Common Patterns to Remember"}),"\n",(0,t.jsxs)(n.h3,{id:"1-horizontal-distance-pattern",children:["1. ",(0,t.jsx)(n.strong,{children:"Horizontal Distance Pattern"})]}),"\n",(0,t.jsx)(n.p,{children:"Use horizontal distance for vertical views:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Left child: hd - 1, Right child: hd + 1\nif (node.left != null) queue.offer(new QueueNode(node.left, hd - 1));\nif (node.right != null) queue.offer(new QueueNode(node.right, hd + 1));\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"2-level-tracking-pattern",children:["2. ",(0,t.jsx)(n.strong,{children:"Level Tracking Pattern"})]}),"\n",(0,t.jsx)(n.p,{children:"Track levels for first/last occurrence:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"if (level == result.size()) {\n    result.add(node.val); // First occurrence at this level\n}\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"3-treemap-with-sorting-pattern",children:["3. ",(0,t.jsx)(n.strong,{children:"TreeMap with Sorting Pattern"})]}),"\n",(0,t.jsx)(n.p,{children:"Common for coordinate-based views:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"TreeMap<Integer, Integer> map = new TreeMap<>(); // Auto-sorted by key\nresult.addAll(map.values());\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"4-bfs-level-processing",children:["4. ",(0,t.jsx)(n.strong,{children:"BFS Level Processing"})]}),"\n",(0,t.jsx)(n.p,{children:"Process entire levels at once:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"while (!queue.isEmpty()) {\n    int levelSize = queue.size();\n    for (int i = 0; i < levelSize; i++) {\n        TreeNode node = queue.poll();\n        // Process node\n    }\n}\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"5-arraydeque-as-stack-pattern",children:["5. ",(0,t.jsx)(n.strong,{children:"ArrayDeque as Stack Pattern"})]}),"\n",(0,t.jsx)(n.p,{children:"Use ArrayDeque for stack operations:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"Deque<TreeNode> stack = new ArrayDeque<>();\nstack.push(node);           // Add to top\nTreeNode current = stack.pop(); // Remove from top\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"key-interview-tips",children:"Key Interview Tips"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Choose ArrayDeque"}),": Always prefer ArrayDeque over LinkedList for queue operations[4][3]"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Visualize the Tree"}),": Always draw the tree structure first"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Master Coordinates"}),": Understand horizontal distance and level concepts"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"BFS vs DFS"}),": BFS for level-based views, DFS for recursive solutions"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Handle Edge Cases"}),": Empty tree, single node, skewed trees"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"TreeMap Benefits"}),": Automatic sorting by keys eliminates manual sorting"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Memory Efficiency"}),": ArrayDeque provides better cache locality than LinkedList[5]"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Test Thoroughly"}),": Use balanced, skewed, and complete trees for validation"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Recommendation"}),": Always use ",(0,t.jsx)(n.strong,{children:"ArrayDeque"})," for tree traversals - it's faster, more memory efficient, and demonstrates understanding of optimal data structure selection for the given use case!"]})]})}function c(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>a});var t=r(6540);const l={},i=t.createContext(l);function s(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:s(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);