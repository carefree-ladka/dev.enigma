"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[79870],{28453:(e,n,i)=>{i.d(n,{R:()=>t,x:()=>l});var s=i(96540);const r={},a=s.createContext(r);function t(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),s.createElement(a.Provider,{value:n},e.children)}},91563:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>t,default:()=>h,frontMatter:()=>a,metadata:()=>l,toc:()=>o});var s=i(74848),r=i(28453);const a={},t="Java Call by Value vs Call by Reference",l={id:"Backend/Java-Fundamentals/Java/JavaCallbyValuevsCallbyReference",title:"Java Call by Value vs Call by Reference",description:"Overview",source:"@site/docs/02-Backend/Java-Fundamentals/Java/JavaCallbyValuevsCallbyReference.mdx",sourceDirName:"02-Backend/Java-Fundamentals/Java",slug:"/Backend/Java-Fundamentals/Java/JavaCallbyValuevsCallbyReference",permalink:"/docs/Backend/Java-Fundamentals/Java/JavaCallbyValuevsCallbyReference",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/02-Backend/Java-Fundamentals/Java/JavaCallbyValuevsCallbyReference.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Java Beginner's Guide",permalink:"/docs/Backend/Java-Fundamentals/Java/JavaBeginner'sGuide"},next:{title:"Java Collections Cheatsheet",permalink:"/docs/Backend/Java-Fundamentals/Java/JavaCollections"}},c={},o=[{value:"Overview",id:"overview",level:2},{value:"Key Concept: Java is Always Call by Value",id:"key-concept-java-is-always-call-by-value",level:2},{value:"Primitive Types - Call by Value",id:"primitive-types---call-by-value",level:2},{value:"Example with Primitives",id:"example-with-primitives",level:3},{value:"Memory Visualization for Primitives",id:"memory-visualization-for-primitives",level:3},{value:"Reference Types - Call by Value (of the Reference)",id:"reference-types---call-by-value-of-the-reference",level:2},{value:"Example with Objects",id:"example-with-objects",level:3},{value:"Memory Visualization for Objects",id:"memory-visualization-for-objects",level:3},{value:"Common Misconception: Reassigning References",id:"common-misconception-reassigning-references",level:2},{value:"Why Reassignment Doesn&#39;t Work",id:"why-reassignment-doesnt-work",level:3},{value:"Arrays - Special Case of Reference Types",id:"arrays---special-case-of-reference-types",level:2},{value:"String - Special Reference Type",id:"string---special-reference-type",level:2},{value:"Wrapper Classes (Integer, Double, etc.)",id:"wrapper-classes-integer-double-etc",level:2},{value:"Practical Examples and Best Practices",id:"practical-examples-and-best-practices",level:2},{value:"1. Returning Modified Objects",id:"1-returning-modified-objects",level:3},{value:"2. Defensive Copying",id:"2-defensive-copying",level:3},{value:"Summary Table",id:"summary-table",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2},{value:"Memory Management Tips",id:"memory-management-tips",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"java-call-by-value-vs-call-by-reference",children:"Java Call by Value vs Call by Reference"})}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsxs)(n.p,{children:["Java uses ",(0,s.jsx)(n.strong,{children:"call by value"})," for all parameter passing, but the behavior differs based on the type of data being passed:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Primitive types"}),": The actual value is copied"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Reference types (objects)"}),": The reference (memory address) is copied, not the object itself"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"key-concept-java-is-always-call-by-value",children:"Key Concept: Java is Always Call by Value"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"// This is the fundamental rule:\n// Java ALWAYS passes a COPY of the value to methods\n"})}),"\n",(0,s.jsx)(n.h2,{id:"primitive-types---call-by-value",children:"Primitive Types - Call by Value"}),"\n",(0,s.jsx)(n.p,{children:"When primitive types are passed to methods, a copy of the actual value is created."}),"\n",(0,s.jsx)(n.h3,{id:"example-with-primitives",children:"Example with Primitives"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'public class PrimitiveExample {\n    public static void main(String[] args) {\n        int x = 10;\n        System.out.println("Before method call: x = " + x); // x = 10\n\n        modifyPrimitive(x);\n\n        System.out.println("After method call: x = " + x);  // x = 10 (unchanged)\n    }\n\n    public static void modifyPrimitive(int num) {\n        num = 100; // This only changes the local copy\n        System.out.println("Inside method: num = " + num); // num = 100\n    }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Output:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Before method call: x = 10\nInside method: num = 100\nAfter method call: x = 10\n"})}),"\n",(0,s.jsx)(n.h3,{id:"memory-visualization-for-primitives",children:"Memory Visualization for Primitives"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Stack Memory:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 main() method   \u2502\n\u2502 x = 10          \u2502 \u2190 Original variable\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 modifyPrimitive \u2502\n\u2502 num = 10 \u2192 100  \u2502 \u2190 Copy of the value\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,s.jsx)(n.h2,{id:"reference-types---call-by-value-of-the-reference",children:"Reference Types - Call by Value (of the Reference)"}),"\n",(0,s.jsx)(n.p,{children:"When objects are passed to methods, a copy of the reference (memory address) is passed, not the object itself."}),"\n",(0,s.jsx)(n.h3,{id:"example-with-objects",children:"Example with Objects"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'class Person {\n    String name;\n    int age;\n\n    Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    @Override\n    public String toString() {\n        return "Person{name=\'" + name + "\', age=" + age + "}";\n    }\n}\n\npublic class ReferenceExample {\n    public static void main(String[] args) {\n        Person person = new Person("Alice", 25);\n        System.out.println("Before method call: " + person);\n\n        modifyObject(person);\n\n        System.out.println("After method call: " + person);\n    }\n\n    public static void modifyObject(Person p) {\n        p.name = "Bob";     // This modifies the original object\n        p.age = 30;         // This modifies the original object\n        System.out.println("Inside method: " + p);\n    }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Output:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Before method call: Person{name='Alice', age=25}\nInside method: Person{name='Bob', age=30}\nAfter method call: Person{name='Bob', age=30}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"memory-visualization-for-objects",children:"Memory Visualization for Objects"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'Stack Memory:                    Heap Memory:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 main() method   \u2502             \u2502 Person Object    \u2502\n\u2502 person = @123   \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2192  \u2502 name = "Alice"   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518             \u2502 age = 25         \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\u2502 modifyObject()  \u2502                      \u2191\n\u2502 p = @123        \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n'})}),"\n",(0,s.jsx)(n.h2,{id:"common-misconception-reassigning-references",children:"Common Misconception: Reassigning References"}),"\n",(0,s.jsx)(n.p,{children:"Many developers think Java passes references by reference, but this example proves otherwise:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'public class ReassignmentExample {\n    public static void main(String[] args) {\n        Person person1 = new Person("Alice", 25);\n        System.out.println("Before method: " + person1);\n\n        reassignReference(person1);\n\n        System.out.println("After method: " + person1); // Still Alice!\n    }\n\n    public static void reassignReference(Person p) {\n        p = new Person("Charlie", 35); // Creates new object, assigns to local copy\n        System.out.println("Inside method: " + p);\n    }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Output:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Before method: Person{name='Alice', age=25}\nInside method: Person{name='Charlie', age=35}\nAfter method: Person{name='Alice', age=25}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"why-reassignment-doesnt-work",children:"Why Reassignment Doesn't Work"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Initial State:\nStack:                          Heap:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 person1 = @123  \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2192  \u2502 Alice, 25        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 p = @123        \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2192  (same object)\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nAfter Reassignment:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 person1 = @123  \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2192  \u2502 Alice, 25        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 p = @456        \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2192  \u2502 Charlie, 35      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,s.jsx)(n.h2,{id:"arrays---special-case-of-reference-types",children:"Arrays - Special Case of Reference Types"}),"\n",(0,s.jsx)(n.p,{children:"Arrays behave like objects since they are reference types:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'public class ArrayExample {\n    public static void main(String[] args) {\n        int[] numbers = {1, 2, 3, 4, 5};\n        System.out.println("Before: " + Arrays.toString(numbers));\n\n        modifyArray(numbers);\n\n        System.out.println("After: " + Arrays.toString(numbers));\n\n        // But reassignment doesn\'t affect original\n        reassignArray(numbers);\n        System.out.println("After reassign: " + Arrays.toString(numbers));\n    }\n\n    public static void modifyArray(int[] arr) {\n        arr[0] = 100; // Modifies original array\n    }\n\n    public static void reassignArray(int[] arr) {\n        arr = new int[]{10, 20, 30}; // Only affects local copy\n    }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Output:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Before: [1, 2, 3, 4, 5]\nAfter: [100, 2, 3, 4, 5]\nAfter reassign: [100, 2, 3, 4, 5]\n"})}),"\n",(0,s.jsx)(n.h2,{id:"string---special-reference-type",children:"String - Special Reference Type"}),"\n",(0,s.jsx)(n.p,{children:"Strings are immutable, so even though they're reference types, they behave like primitives in method calls:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'public class StringExample {\n    public static void main(String[] args) {\n        String message = "Hello";\n        System.out.println("Before: " + message);\n\n        modifyString(message);\n\n        System.out.println("After: " + message); // Still "Hello"\n    }\n\n    public static void modifyString(String str) {\n        str = "World"; // Creates new String, assigns to local copy\n        System.out.println("Inside method: " + str);\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"wrapper-classes-integer-double-etc",children:"Wrapper Classes (Integer, Double, etc.)"}),"\n",(0,s.jsx)(n.p,{children:"Wrapper classes are immutable like String:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'public class WrapperExample {\n    public static void main(String[] args) {\n        Integer num = 10;\n        System.out.println("Before: " + num);\n\n        modifyWrapper(num);\n\n        System.out.println("After: " + num); // Still 10\n    }\n\n    public static void modifyWrapper(Integer n) {\n        n = 100; // Creates new Integer, assigns to local copy\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"practical-examples-and-best-practices",children:"Practical Examples and Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"1-returning-modified-objects",children:"1. Returning Modified Objects"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"public class BestPracticeExample {\n    // Good practice: Return the modified object\n    public static Person updatePersonAge(Person p, int newAge) {\n        p.age = newAge;\n        return p; // Return for method chaining\n    }\n\n    // For immutable objects, create new instances\n    public static String updateString(String str) {\n        return str.toUpperCase(); // Must return new string\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-defensive-copying",children:"2. Defensive Copying"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"public class DefensiveCopying {\n    private List<String> names = new ArrayList<>();\n\n    // Bad: Exposes internal state\n    public List<String> getNames() {\n        return names;\n    }\n\n    // Good: Return defensive copy\n    public List<String> getNamesCopy() {\n        return new ArrayList<>(names);\n    }\n\n    // Good: Accept copy to prevent external modification\n    public void setNames(List<String> names) {\n        this.names = new ArrayList<>(names);\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"summary-table",children:"Summary Table"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"What's Passed"}),(0,s.jsx)(n.th,{children:"Original Modified?"}),(0,s.jsx)(n.th,{children:"Example"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsxs)(n.td,{children:["Primitive (",(0,s.jsx)(n.code,{children:"int"}),", ",(0,s.jsx)(n.code,{children:"double"}),", ",(0,s.jsx)(n.code,{children:"boolean"}),")"]}),(0,s.jsx)(n.td,{children:"Copy of value"}),(0,s.jsx)(n.td,{children:"\u274c No"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"int x = 5"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsxs)(n.td,{children:["Mutable Object (",(0,s.jsx)(n.code,{children:"List"}),", ",(0,s.jsx)(n.code,{children:"Person"}),")"]}),(0,s.jsx)(n.td,{children:"Copy of reference"}),(0,s.jsx)(n.td,{children:"\u2705 Yes"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'person.name = "New"'})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsxs)(n.td,{children:["Immutable Object (",(0,s.jsx)(n.code,{children:"String"}),", ",(0,s.jsx)(n.code,{children:"Integer"}),")"]}),(0,s.jsx)(n.td,{children:"Copy of reference"}),(0,s.jsx)(n.td,{children:"\u274c No"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'str = "New"'})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Array"}),(0,s.jsx)(n.td,{children:"Copy of reference"}),(0,s.jsx)(n.td,{children:"\u2705 Yes"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"arr[0] = 10"})})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Java is ALWAYS call by value"})," - no exceptions"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"For primitives"}),": Value is copied, original unchanged"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"For objects"}),": Reference is copied, object can be modified through the copy"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Reassignment never affects the original"})," reference in the calling method"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Immutable objects"})," (String, wrapper classes) behave like primitives"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Arrays are objects"})," and follow object rules"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use defensive copying"})," when necessary to protect object state"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"memory-management-tips",children:"Memory Management Tips"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Understand the difference between stack (method parameters) and heap (objects)"}),"\n",(0,s.jsx)(n.li,{children:"Be careful with mutable objects in multi-threaded environments"}),"\n",(0,s.jsx)(n.li,{children:"Consider using immutable objects when possible"}),"\n",(0,s.jsx)(n.li,{children:"Use builder patterns for complex object construction"}),"\n",(0,s.jsxs)(n.li,{children:["Implement proper ",(0,s.jsx)(n.code,{children:"equals()"})," and ",(0,s.jsx)(n.code,{children:"hashCode()"})," methods for custom objects"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);