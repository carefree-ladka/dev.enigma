"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[8168],{28453:(n,e,i)=>{i.d(e,{R:()=>s,x:()=>l});var t=i(96540);const r={},a=t.createContext(r);function s(n){const e=t.useContext(a);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:s(n.components),t.createElement(a.Provider,{value:e},n.children)}},58944:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>u,contentTitle:()=>s,default:()=>o,frontMatter:()=>a,metadata:()=>l,toc:()=>d});var t=i(74848),r=i(28453);const a={},s="Array",l={id:"DSA/DSA with Java/Arrays Patterns",title:"Array",description:"Table of Contents",source:"@site/docs/DSA/DSA with Java/Arrays Patterns.mdx",sourceDirName:"DSA/DSA with Java",slug:"/DSA/DSA with Java/Arrays Patterns",permalink:"/docs/DSA/DSA with Java/Arrays Patterns",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with Java/Arrays Patterns.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"DSA with Java",permalink:"/docs/category/dsa-with-java"},next:{title:"Backtracking",permalink:"/docs/DSA/DSA with Java/Backtracking Patterns"}},u={},d=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Array Fundamentals",id:"array-fundamentals",level:2},{value:"Core Array Operations",id:"core-array-operations",level:3},{value:"Pattern 1: Two Pointers",id:"pattern-1-two-pointers",level:2},{value:"1.1 Opposite Direction Two Pointers",id:"11-opposite-direction-two-pointers",level:3},{value:"1.2 Same Direction Two Pointers",id:"12-same-direction-two-pointers",level:3},{value:"1.3 Three Sum and Four Sum Problems",id:"13-three-sum-and-four-sum-problems",level:3},{value:"Pattern 2: Sliding Window",id:"pattern-2-sliding-window",level:2},{value:"2.1 Fixed Size Sliding Window",id:"21-fixed-size-sliding-window",level:3},{value:"2.2 Variable Size Sliding Window",id:"22-variable-size-sliding-window",level:3},{value:"2.3 Sliding Window Maximum/Minimum",id:"23-sliding-window-maximumminimum",level:3},{value:"Pattern 3: Prefix Sum &amp; Cumulative Arrays",id:"pattern-3-prefix-sum--cumulative-arrays",level:2},{value:"3.1 Basic Prefix Sum",id:"31-basic-prefix-sum",level:3},{value:"3.2 2D Prefix Sum",id:"32-2d-prefix-sum",level:3},{value:"3.3 Advanced Prefix Sum Problems",id:"33-advanced-prefix-sum-problems",level:3},{value:"Pattern 4: Kadane&#39;s Algorithm (Maximum Subarray)",id:"pattern-4-kadanes-algorithm-maximum-subarray",level:2},{value:"4.1 Classic Maximum Subarray",id:"41-classic-maximum-subarray",level:3},{value:"4.2 Kadane&#39;s Algorithm Variations",id:"42-kadanes-algorithm-variations",level:3},{value:"Pattern 5: Fast &amp; Slow Pointers",id:"pattern-5-fast--slow-pointers",level:2},{value:"5.1 Cycle Detection in Arrays",id:"51-cycle-detection-in-arrays",level:3},{value:"Pattern 6: Cyclic Sort",id:"pattern-6-cyclic-sort",level:2},{value:"6.1 Missing and Duplicate Numbers",id:"61-missing-and-duplicate-numbers",level:3},{value:"Pattern 7: Merge Intervals",id:"pattern-7-merge-intervals",level:2},{value:"7.1 Basic Interval Operations",id:"71-basic-interval-operations",level:3},{value:"7.2 Advanced Interval Problems",id:"72-advanced-interval-problems",level:3},{value:"Pattern 8: Dutch National Flag",id:"pattern-8-dutch-national-flag",level:2},{value:"8.1 Three-Way Partitioning",id:"81-three-way-partitioning",level:3},{value:"Pattern 9: Binary Search in Arrays",id:"pattern-9-binary-search-in-arrays",level:2},{value:"9.1 Basic Binary Search",id:"91-basic-binary-search",level:3},{value:"9.2 Advanced Binary Search",id:"92-advanced-binary-search",level:3},{value:"Pattern 10: Subarray Problems",id:"pattern-10-subarray-problems",level:2},{value:"10.1 Subarray Sum Problems",id:"101-subarray-sum-problems",level:3},{value:"Pattern 11: Matrix Traversal",id:"pattern-11-matrix-traversal",level:2},{value:"11.1 Basic Matrix Operations",id:"111-basic-matrix-operations",level:3},{value:"Pattern 12: Advanced Array Techniques",id:"pattern-12-advanced-array-techniques",level:2},{value:"12.1 Boyer-Moore Voting Algorithm",id:"121-boyer-moore-voting-algorithm",level:3},{value:"12.2 Array Manipulation Techniques",id:"122-array-manipulation-techniques",level:3},{value:"Time &amp; Space Complexity Reference[1]",id:"time--space-complexity-reference1",level:2},{value:"Best Practices &amp; Optimization Tips",id:"best-practices--optimization-tips",level:2},{value:"Array Algorithm Guidelines",id:"array-algorithm-guidelines",level:3},{value:"Common Pitfalls to Avoid",id:"common-pitfalls-to-avoid",level:3},{value:"Interview Tips[10][11]",id:"interview-tips1011",level:3}];function m(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"array",children:"Array"})}),"\n",(0,t.jsx)(e.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#array-fundamentals",children:"Array Fundamentals"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-1-two-pointers",children:"Pattern 1: Two Pointers"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-2-sliding-window",children:"Pattern 2: Sliding Window"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-3-prefix-sum--cumulative-arrays",children:"Pattern 3: Prefix Sum & Cumulative Arrays"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-4-kadanes-algorithm-maximum-subarray",children:"Pattern 4: Kadane's Algorithm (Maximum Subarray)"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-5-fast--slow-pointers",children:"Pattern 5: Fast & Slow Pointers"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-6-cyclic-sort",children:"Pattern 6: Cyclic Sort"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-7-merge-intervals",children:"Pattern 7: Merge Intervals"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-8-dutch-national-flag",children:"Pattern 8: Dutch National Flag"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-9-binary-search-in-arrays",children:"Pattern 9: Binary Search in Arrays"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-10-subarray-problems",children:"Pattern 10: Subarray Problems"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-11-matrix-traversal",children:"Pattern 11: Matrix Traversal"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-12-advanced-array-techniques",children:"Pattern 12: Advanced Array Techniques"})}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"array-fundamentals",children:"Array Fundamentals"}),"\n",(0,t.jsx)(e.h3,{id:"core-array-operations",children:"Core Array Operations"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:'// Basic Array Operations\nclass ArrayOperations {\n\n    // Array Creation and Initialization\n    public static void arrayBasics() {\n        // Different ways to create arrays\n        int[] arr1 = new int[5];                    // Default values (0)\n        int[] arr2 = {1, 2, 3, 4, 5};             // Direct initialization\n        int[] arr3 = new int[]{1, 2, 3, 4, 5};    // Explicit initialization\n\n        // 2D Array initialization\n        int[][] matrix1 = new int[3][4];           // 3x4 matrix\n        int[][] matrix2 = {{1, 2}, {3, 4}, {5, 6}}; // Direct initialization\n    }\n\n    // Array Traversal Patterns\n    public static void traversalPatterns(int[] arr) {\n        // Forward traversal\n        for (int i = 0; i < arr.length; i++) {\n            System.out.print(arr[i] + " ");\n        }\n\n        // Backward traversal\n        for (int i = arr.length - 1; i >= 0; i--) {\n            System.out.print(arr[i] + " ");\n        }\n\n        // Enhanced for loop\n        for (int num : arr) {\n            System.out.print(num + " ");\n        }\n\n        // Two pointers traversal\n        int left = 0, right = arr.length - 1;\n        while (left <= right) {\n            System.out.println("Left: " + arr[left] + ", Right: " + arr[right]);\n            left++;\n            right--;\n        }\n    }\n\n    // Common Array Utilities\n    public static void arrayUtilities() {\n        int[] arr = {3, 1, 4, 1, 5, 9, 2, 6};\n\n        // Sorting\n        Arrays.sort(arr);\n\n        // Binary search (array must be sorted)\n        int index = Arrays.binarySearch(arr, 5);\n\n        // Copying arrays\n        int[] copy1 = Arrays.copyOf(arr, arr.length);\n        int[] copy2 = Arrays.copyOfRange(arr, 2, 6);\n\n        // Filling array\n        int[] filled = new int[10];\n        Arrays.fill(filled, 42);\n\n        // Converting to string\n        System.out.println(Arrays.toString(arr));\n\n        // Comparing arrays\n        boolean equal = Arrays.equals(arr, copy1);\n    }\n}\n\n// Dynamic Array Implementation (ArrayList alternative)\nclass DynamicArray<T> {\n    private T[] array;\n    private int size;\n    private int capacity;\n\n    @SuppressWarnings("unchecked")\n    public DynamicArray() {\n        capacity = 10;\n        array = (T[]) new Object[capacity];\n        size = 0;\n    }\n\n    public void add(T item) {\n        if (size >= capacity) {\n            resize();\n        }\n        array[size++] = item;\n    }\n\n    public T get(int index) {\n        if (index < 0 || index >= size) {\n            throw new IndexOutOfBoundsException();\n        }\n        return array[index];\n    }\n\n    public void set(int index, T item) {\n        if (index < 0 || index >= size) {\n            throw new IndexOutOfBoundsException();\n        }\n        array[index] = item;\n    }\n\n    public T remove(int index) {\n        if (index < 0 || index >= size) {\n            throw new IndexOutOfBoundsException();\n        }\n\n        T item = array[index];\n        for (int i = index; i < size - 1; i++) {\n            array[i] = array[i + 1];\n        }\n        size--;\n        return item;\n    }\n\n    @SuppressWarnings("unchecked")\n    private void resize() {\n        capacity *= 2;\n        T[] newArray = (T[]) new Object[capacity];\n        System.arraycopy(array, 0, newArray, 0, size);\n        array = newArray;\n    }\n\n    public int size() { return size; }\n    public boolean isEmpty() { return size == 0; }\n}\n'})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-1-two-pointers",children:"Pattern 1: Two Pointers"}),"\n",(0,t.jsx)(e.h3,{id:"11-opposite-direction-two-pointers",children:"1.1 Opposite Direction Two Pointers"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Two Sum in Sorted Array\npublic int[] twoSum(int[] numbers, int target) {\n    int left = 0, right = numbers.length - 1;\n\n    while (left < right) {\n        int sum = numbers[left] + numbers[right];\n\n        if (sum == target) {\n            return new int[]{left + 1, right + 1}; // 1-indexed\n        } else if (sum < target) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n\n    return new int[]{-1, -1}; // Not found\n}\n\n// Valid Palindrome\npublic boolean isPalindrome(String s) {\n    int left = 0, right = s.length() - 1;\n\n    while (left < right) {\n        while (left < right && !Character.isLetterOrDigit(s.charAt(left))) {\n            left++;\n        }\n        while (left < right && !Character.isLetterOrDigit(s.charAt(right))) {\n            right--;\n        }\n\n        if (Character.toLowerCase(s.charAt(left)) !=\n            Character.toLowerCase(s.charAt(right))) {\n            return false;\n        }\n\n        left++;\n        right--;\n    }\n\n    return true;\n}\n\n// Container With Most Water\npublic int maxArea(int[] height) {\n    int left = 0, right = height.length - 1;\n    int maxWater = 0;\n\n    while (left < right) {\n        int width = right - left;\n        int currentArea = Math.min(height[left], height[right]) * width;\n        maxWater = Math.max(maxWater, currentArea);\n\n        // Move pointer with smaller height\n        if (height[left] < height[right]) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n\n    return maxWater;\n}\n\n// Remove Duplicates from Sorted Array\npublic int removeDuplicates(int[] nums) {\n    if (nums.length == 0) return 0;\n\n    int writeIndex = 1; // Position to write next unique element\n\n    for (int readIndex = 1; readIndex < nums.length; readIndex++) {\n        if (nums[readIndex] != nums[readIndex - 1]) {\n            nums[writeIndex] = nums[readIndex];\n            writeIndex++;\n        }\n    }\n\n    return writeIndex;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"12-same-direction-two-pointers",children:"1.2 Same Direction Two Pointers"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Remove Element\npublic int removeElement(int[] nums, int val) {\n    int writeIndex = 0;\n\n    for (int readIndex = 0; readIndex < nums.length; readIndex++) {\n        if (nums[readIndex] != val) {\n            nums[writeIndex] = nums[readIndex];\n            writeIndex++;\n        }\n    }\n\n    return writeIndex;\n}\n\n// Move Zeros to End\npublic void moveZeroes(int[] nums) {\n    int writeIndex = 0;\n\n    // Move all non-zero elements to the front\n    for (int readIndex = 0; readIndex < nums.length; readIndex++) {\n        if (nums[readIndex] != 0) {\n            nums[writeIndex] = nums[readIndex];\n            writeIndex++;\n        }\n    }\n\n    // Fill remaining positions with zeros\n    while (writeIndex < nums.length) {\n        nums[writeIndex] = 0;\n        writeIndex++;\n    }\n}\n\n// Partition Array (Quick Sort Partition)\npublic int partition(int[] arr, int low, int high) {\n    int pivot = arr[high];\n    int i = low - 1; // Index of smaller element\n\n    for (int j = low; j < high; j++) {\n        if (arr[j] <= pivot) {\n            i++;\n            swap(arr, i, j);\n        }\n    }\n\n    swap(arr, i + 1, high);\n    return i + 1;\n}\n\nprivate void swap(int[] arr, int i, int j) {\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"13-three-sum-and-four-sum-problems",children:"1.3 Three Sum and Four Sum Problems"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Three Sum\npublic List<List<Integer>> threeSum(int[] nums) {\n    List<List<Integer>> result = new ArrayList<>();\n    Arrays.sort(nums);\n\n    for (int i = 0; i < nums.length - 2; i++) {\n        // Skip duplicates for first number\n        if (i > 0 && nums[i] == nums[i - 1]) continue;\n\n        int left = i + 1, right = nums.length - 1;\n        int target = -nums[i];\n\n        while (left < right) {\n            int sum = nums[left] + nums[right];\n\n            if (sum == target) {\n                result.add(Arrays.asList(nums[i], nums[left], nums[right]));\n\n                // Skip duplicates for second and third numbers\n                while (left < right && nums[left] == nums[left + 1]) left++;\n                while (left < right && nums[right] == nums[right - 1]) right--;\n\n                left++;\n                right--;\n            } else if (sum < target) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n\n    return result;\n}\n\n// Four Sum\npublic List<List<Integer>> fourSum(int[] nums, int target) {\n    List<List<Integer>> result = new ArrayList<>();\n    Arrays.sort(nums);\n\n    for (int i = 0; i < nums.length - 3; i++) {\n        if (i > 0 && nums[i] == nums[i - 1]) continue;\n\n        for (int j = i + 1; j < nums.length - 2; j++) {\n            if (j > i + 1 && nums[j] == nums[j - 1]) continue;\n\n            int left = j + 1, right = nums.length - 1;\n            long remaining = (long) target - nums[i] - nums[j];\n\n            while (left < right) {\n                int sum = nums[left] + nums[right];\n\n                if (sum == remaining) {\n                    result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\n\n                    while (left < right && nums[left] == nums[left + 1]) left++;\n                    while (left < right && nums[right] == nums[right - 1]) right--;\n\n                    left++;\n                    right--;\n                } else if (sum < remaining) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n    }\n\n    return result;\n}\n\n// Trapping Rain Water\npublic int trap(int[] height) {\n    if (height.length == 0) return 0;\n\n    int left = 0, right = height.length - 1;\n    int leftMax = 0, rightMax = 0;\n    int water = 0;\n\n    while (left < right) {\n        if (height[left] < height[right]) {\n            if (height[left] >= leftMax) {\n                leftMax = height[left];\n            } else {\n                water += leftMax - height[left];\n            }\n            left++;\n        } else {\n            if (height[right] >= rightMax) {\n                rightMax = height[right];\n            } else {\n                water += rightMax - height[right];\n            }\n            right--;\n        }\n    }\n\n    return water;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-2-sliding-window",children:"Pattern 2: Sliding Window"}),"\n",(0,t.jsx)(e.h3,{id:"21-fixed-size-sliding-window",children:"2.1 Fixed Size Sliding Window"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Maximum Sum Subarray of Size K\npublic int maxSumSubarray(int[] arr, int k) {\n    if (arr.length < k) return -1;\n\n    // Calculate sum of first window\n    int windowSum = 0;\n    for (int i = 0; i < k; i++) {\n        windowSum += arr[i];\n    }\n\n    int maxSum = windowSum;\n\n    // Slide the window\n    for (int i = k; i < arr.length; i++) {\n        windowSum = windowSum - arr[i - k] + arr[i];\n        maxSum = Math.max(maxSum, windowSum);\n    }\n\n    return maxSum;\n}\n\n// Average of Subarrays of Size K\npublic double[] findAverages(int[] arr, int k) {\n    double[] result = new double[arr.length - k + 1];\n    double windowSum = 0;\n\n    // Calculate sum of first window\n    for (int i = 0; i < k; i++) {\n        windowSum += arr[i];\n    }\n    result[0] = windowSum / k;\n\n    // Slide the window\n    for (int i = k; i < arr.length; i++) {\n        windowSum = windowSum - arr[i - k] + arr[i];\n        result[i - k + 1] = windowSum / k;\n    }\n\n    return result;\n}\n\n// First Negative Integer in Every Window of Size K\npublic int[] firstNegativeInWindow(int[] arr, int k) {\n    int[] result = new int[arr.length - k + 1];\n    Queue<Integer> negatives = new LinkedList<>(); // Store indices\n\n    // Process first window\n    for (int i = 0; i < k; i++) {\n        if (arr[i] < 0) {\n            negatives.offer(i);\n        }\n    }\n    result[0] = negatives.isEmpty() ? 0 : arr[negatives.peek()];\n\n    // Slide the window\n    for (int i = k; i < arr.length; i++) {\n        // Remove elements outside current window\n        while (!negatives.isEmpty() && negatives.peek() <= i - k) {\n            negatives.poll();\n        }\n\n        // Add current element if negative\n        if (arr[i] < 0) {\n            negatives.offer(i);\n        }\n\n        result[i - k + 1] = negatives.isEmpty() ? 0 : arr[negatives.peek()];\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"22-variable-size-sliding-window",children:"2.2 Variable Size Sliding Window"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:'// Longest Substring Without Repeating Characters\npublic int lengthOfLongestSubstring(String s) {\n    Set<Character> window = new HashSet<>();\n    int left = 0, maxLength = 0;\n\n    for (int right = 0; right < s.length(); right++) {\n        // Shrink window until no duplicates\n        while (window.contains(s.charAt(right))) {\n            window.remove(s.charAt(left));\n            left++;\n        }\n\n        window.add(s.charAt(right));\n        maxLength = Math.max(maxLength, right - left + 1);\n    }\n\n    return maxLength;\n}\n\n// Smallest Subarray with Sum >= K\npublic int minSubArrayLen(int target, int[] nums) {\n    int left = 0, sum = 0, minLength = Integer.MAX_VALUE;\n\n    for (int right = 0; right < nums.length; right++) {\n        sum += nums[right];\n\n        // Shrink window while sum >= target\n        while (sum >= target) {\n            minLength = Math.min(minLength, right - left + 1);\n            sum -= nums[left];\n            left++;\n        }\n    }\n\n    return minLength == Integer.MAX_VALUE ? 0 : minLength;\n}\n\n// Longest Subarray with At Most K Distinct Characters\npublic int lengthOfLongestSubstringKDistinct(String s, int k) {\n    if (k == 0) return 0;\n\n    Map<Character, Integer> charCount = new HashMap<>();\n    int left = 0, maxLength = 0;\n\n    for (int right = 0; right < s.length(); right++) {\n        char rightChar = s.charAt(right);\n        charCount.put(rightChar, charCount.getOrDefault(rightChar, 0) + 1);\n\n        // Shrink window if more than k distinct characters\n        while (charCount.size() > k) {\n            char leftChar = s.charAt(left);\n            charCount.put(leftChar, charCount.get(leftChar) - 1);\n            if (charCount.get(leftChar) == 0) {\n                charCount.remove(leftChar);\n            }\n            left++;\n        }\n\n        maxLength = Math.max(maxLength, right - left + 1);\n    }\n\n    return maxLength;\n}\n\n// Minimum Window Substring\npublic String minWindow(String s, String t) {\n    if (s.length() < t.length()) return "";\n\n    Map<Character, Integer> targetCount = new HashMap<>();\n    for (char c : t.toCharArray()) {\n        targetCount.put(c, targetCount.getOrDefault(c, 0) + 1);\n    }\n\n    Map<Character, Integer> windowCount = new HashMap<>();\n    int left = 0, formed = 0;\n    int minLength = Integer.MAX_VALUE, minStart = 0;\n    int required = targetCount.size();\n\n    for (int right = 0; right < s.length(); right++) {\n        char rightChar = s.charAt(right);\n        windowCount.put(rightChar, windowCount.getOrDefault(rightChar, 0) + 1);\n\n        if (targetCount.containsKey(rightChar) &&\n            windowCount.get(rightChar).intValue() == targetCount.get(rightChar).intValue()) {\n            formed++;\n        }\n\n        // Shrink window while it\'s valid\n        while (left <= right && formed == required) {\n            if (right - left + 1 < minLength) {\n                minLength = right - left + 1;\n                minStart = left;\n            }\n\n            char leftChar = s.charAt(left);\n            windowCount.put(leftChar, windowCount.get(leftChar) - 1);\n            if (targetCount.containsKey(leftChar) &&\n                windowCount.get(leftChar) < targetCount.get(leftChar)) {\n                formed--;\n            }\n            left++;\n        }\n    }\n\n    return minLength == Integer.MAX_VALUE ? "" : s.substring(minStart, minStart + minLength);\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"23-sliding-window-maximumminimum",children:"2.3 Sliding Window Maximum/Minimum"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Sliding Window Maximum (using Deque)\npublic int[] maxSlidingWindow(int[] nums, int k) {\n    Deque<Integer> deque = new ArrayDeque<>(); // Store indices\n    int[] result = new int[nums.length - k + 1];\n\n    for (int i = 0; i < nums.length; i++) {\n        // Remove indices outside current window\n        while (!deque.isEmpty() && deque.peekFirst() < i - k + 1) {\n            deque.pollFirst();\n        }\n\n        // Remove indices of smaller elements\n        while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {\n            deque.pollLast();\n        }\n\n        deque.offerLast(i);\n\n        // Add to result when window is complete\n        if (i >= k - 1) {\n            result[i - k + 1] = nums[deque.peekFirst()];\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-3-prefix-sum--cumulative-arrays",children:"Pattern 3: Prefix Sum & Cumulative Arrays"}),"\n",(0,t.jsx)(e.h3,{id:"31-basic-prefix-sum",children:"3.1 Basic Prefix Sum"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Range Sum Query - Immutable\nclass NumArray {\n    private int[] prefixSum;\n\n    public NumArray(int[] nums) {\n        prefixSum = new int[nums.length + 1];\n        for (int i = 0; i < nums.length; i++) {\n            prefixSum[i + 1] = prefixSum[i] + nums[i];\n        }\n    }\n\n    public int sumRange(int left, int right) {\n        return prefixSum[right + 1] - prefixSum[left];\n    }\n}\n\n// Subarray Sum Equals K\npublic int subarraySum(int[] nums, int k) {\n    Map<Integer, Integer> prefixSumCount = new HashMap<>();\n    prefixSumCount.put(0, 1); // Empty subarray\n\n    int count = 0, prefixSum = 0;\n\n    for (int num : nums) {\n        prefixSum += num;\n\n        // Check if (prefixSum - k) exists\n        if (prefixSumCount.containsKey(prefixSum - k)) {\n            count += prefixSumCount.get(prefixSum - k);\n        }\n\n        prefixSumCount.put(prefixSum, prefixSumCount.getOrDefault(prefixSum, 0) + 1);\n    }\n\n    return count;\n}\n\n// Continuous Subarray Sum (Multiple of K)\npublic boolean checkSubarraySum(int[] nums, int k) {\n    Map<Integer, Integer> remainderIndex = new HashMap<>();\n    remainderIndex.put(0, -1); // Handle edge case\n\n    int prefixSum = 0;\n\n    for (int i = 0; i < nums.length; i++) {\n        prefixSum += nums[i];\n        int remainder = prefixSum % k;\n\n        if (remainderIndex.containsKey(remainder)) {\n            if (i - remainderIndex.get(remainder) > 1) {\n                return true;\n            }\n        } else {\n            remainderIndex.put(remainder, i);\n        }\n    }\n\n    return false;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"32-2d-prefix-sum",children:"3.2 2D Prefix Sum"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Range Sum Query 2D - Immutable\nclass NumMatrix {\n    private int[][] prefixSum;\n\n    public NumMatrix(int[][] matrix) {\n        int m = matrix.length, n = matrix[0].length;\n        prefixSum = new int[m + 1][n + 1];\n\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                prefixSum[i][j] = matrix[i - 1][j - 1] +\n                                 prefixSum[i - 1][j] +\n                                 prefixSum[i][j - 1] -\n                                 prefixSum[i - 1][j - 1];\n            }\n        }\n    }\n\n    public int sumRegion(int row1, int col1, int row2, int col2) {\n        return prefixSum[row2 + 1][col2 + 1] -\n               prefixSum[row1][col2 + 1] -\n               prefixSum[row2 + 1][col1] +\n               prefixSum[row1][col1];\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"33-advanced-prefix-sum-problems",children:"3.3 Advanced Prefix Sum Problems"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Maximum Size Subarray Sum Equals k\npublic int maxSubArrayLen(int[] nums, int k) {\n    Map<Integer, Integer> prefixSumIndex = new HashMap<>();\n    prefixSumIndex.put(0, -1); // Empty subarray\n\n    int maxLength = 0, prefixSum = 0;\n\n    for (int i = 0; i < nums.length; i++) {\n        prefixSum += nums[i];\n\n        if (prefixSumIndex.containsKey(prefixSum - k)) {\n            maxLength = Math.max(maxLength, i - prefixSumIndex.get(prefixSum - k));\n        }\n\n        // Only store first occurrence for maximum length\n        if (!prefixSumIndex.containsKey(prefixSum)) {\n            prefixSumIndex.put(prefixSum, i);\n        }\n    }\n\n    return maxLength;\n}\n\n// Product of Array Except Self\npublic int[] productExceptSelf(int[] nums) {\n    int n = nums.length;\n    int[] result = new int[n];\n\n    // Left products\n    result[0] = 1;\n    for (int i = 1; i < n; i++) {\n        result[i] = result[i - 1] * nums[i - 1];\n    }\n\n    // Right products\n    int rightProduct = 1;\n    for (int i = n - 1; i >= 0; i--) {\n        result[i] *= rightProduct;\n        rightProduct *= nums[i];\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-4-kadanes-algorithm-maximum-subarray",children:"Pattern 4: Kadane's Algorithm (Maximum Subarray)"}),"\n",(0,t.jsx)(e.h3,{id:"41-classic-maximum-subarray",children:"4.1 Classic Maximum Subarray"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Maximum Subarray Sum (Kadane's Algorithm)\npublic int maxSubArray(int[] nums) {\n    int maxSoFar = nums[0];\n    int maxEndingHere = nums[0];\n\n    for (int i = 1; i < nums.length; i++) {\n        maxEndingHere = Math.max(nums[i], maxEndingHere + nums[i]);\n        maxSoFar = Math.max(maxSoFar, maxEndingHere);\n    }\n\n    return maxSoFar;\n}\n\n// Maximum Subarray with Indices\npublic int[] maxSubArrayWithIndices(int[] nums) {\n    int maxSum = nums[0];\n    int currentSum = nums[0];\n    int start = 0, end = 0, tempStart = 0;\n\n    for (int i = 1; i < nums.length; i++) {\n        if (currentSum < 0) {\n            currentSum = nums[i];\n            tempStart = i;\n        } else {\n            currentSum += nums[i];\n        }\n\n        if (currentSum > maxSum) {\n            maxSum = currentSum;\n            start = tempStart;\n            end = i;\n        }\n    }\n\n    return new int[]{maxSum, start, end};\n}\n\n// Maximum Product Subarray\npublic int maxProduct(int[] nums) {\n    int maxSoFar = nums[0];\n    int minSoFar = nums[0]; // Track minimum for negative numbers\n    int result = nums[0];\n\n    for (int i = 1; i < nums.length; i++) {\n        // If current number is negative, swap max and min\n        if (nums[i] < 0) {\n            int temp = maxSoFar;\n            maxSoFar = minSoFar;\n            minSoFar = temp;\n        }\n\n        maxSoFar = Math.max(nums[i], maxSoFar * nums[i]);\n        minSoFar = Math.min(nums[i], minSoFar * nums[i]);\n\n        result = Math.max(result, maxSoFar);\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"42-kadanes-algorithm-variations",children:"4.2 Kadane's Algorithm Variations"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Maximum Circular Subarray Sum\npublic int maxSubarraySumCircular(int[] arr) {\n    int maxKadane = kadaneMax(arr);\n    int totalSum = Arrays.stream(arr).sum();\n\n    // Invert all elements and find max (which is min of original)\n    for (int i = 0; i < arr.length; i++) {\n        arr[i] = -arr[i];\n    }\n    int minKadane = -kadaneMax(arr);\n\n    // Restore original array\n    for (int i = 0; i < arr.length; i++) {\n        arr[i] = -arr[i];\n    }\n\n    // If all elements are negative, return maxKadane\n    if (totalSum == minKadane) {\n        return maxKadane;\n    }\n\n    return Math.max(maxKadane, totalSum - minKadane);\n}\n\nprivate int kadaneMax(int[] arr) {\n    int maxSoFar = arr[0];\n    int maxEndingHere = arr[0];\n\n    for (int i = 1; i < arr.length; i++) {\n        maxEndingHere = Math.max(arr[i], maxEndingHere + arr[i]);\n        maxSoFar = Math.max(maxSoFar, maxEndingHere);\n    }\n\n    return maxSoFar;\n}\n\n// Maximum Sum of Non-Adjacent Elements\npublic int maxNonAdjacent(int[] nums) {\n    if (nums.length == 0) return 0;\n    if (nums.length == 1) return nums[0];\n\n    int prevPrev = nums[0];\n    int prev = Math.max(nums[0], nums[1]);\n\n    for (int i = 2; i < nums.length; i++) {\n        int current = Math.max(prev, prevPrev + nums[i]);\n        prevPrev = prev;\n        prev = current;\n    }\n\n    return prev;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-5-fast--slow-pointers",children:"Pattern 5: Fast & Slow Pointers"}),"\n",(0,t.jsx)(e.h3,{id:"51-cycle-detection-in-arrays",children:"5.1 Cycle Detection in Arrays"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Find Duplicate Number (Floyd's Algorithm)\npublic int findDuplicate(int[] nums) {\n    // Phase 1: Find intersection point\n    int slow = nums[0];\n    int fast = nums[0];\n\n    do {\n        slow = nums[slow];\n        fast = nums[nums[fast]];\n    } while (slow != fast);\n\n    // Phase 2: Find entrance to cycle\n    slow = nums[0];\n    while (slow != fast) {\n        slow = nums[slow];\n        fast = nums[fast];\n    }\n\n    return slow;\n}\n\n// Circular Array Loop\npublic boolean circularArrayLoop(int[] nums) {\n    for (int i = 0; i < nums.length; i++) {\n        if (nums[i] == 0) continue;\n\n        int slow = i, fast = i;\n        boolean forward = nums[i] > 0;\n\n        // Check if we can form a valid loop\n        while (true) {\n            slow = getNext(nums, slow, forward);\n            if (slow == -1) break;\n\n            fast = getNext(nums, fast, forward);\n            if (fast == -1) break;\n            fast = getNext(nums, fast, forward);\n            if (fast == -1) break;\n\n            if (slow == fast) return true;\n        }\n\n        // Mark visited elements\n        int curr = i;\n        while (nums[curr] != 0 && ((nums[curr] > 0) == forward)) {\n            int next = getNext(nums, curr, forward);\n            nums[curr] = 0;\n            curr = next;\n        }\n    }\n\n    return false;\n}\n\nprivate int getNext(int[] nums, int index, boolean forward) {\n    boolean direction = nums[index] > 0;\n    if (direction != forward) return -1; // Direction changed\n\n    int next = (index + nums[index]) % nums.length;\n    if (next < 0) next += nums.length;\n\n    if (next == index) return -1; // Single element loop\n\n    return next;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-6-cyclic-sort",children:"Pattern 6: Cyclic Sort"}),"\n",(0,t.jsx)(e.h3,{id:"61-missing-and-duplicate-numbers",children:"6.1 Missing and Duplicate Numbers"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Cyclic Sort\npublic void cyclicSort(int[] nums) {\n    int i = 0;\n    while (i < nums.length) {\n        int correctIndex = nums[i] - 1;\n        if (nums[i] != nums[correctIndex]) {\n            swap(nums, i, correctIndex);\n        } else {\n            i++;\n        }\n    }\n}\n\n// Find Missing Number\npublic int missingNumber(int[] nums) {\n    int i = 0;\n    while (i < nums.length) {\n        if (nums[i] < nums.length && nums[i] != nums[nums[i]]) {\n            swap(nums, i, nums[i]);\n        } else {\n            i++;\n        }\n    }\n\n    // Find the missing number\n    for (i = 0; i < nums.length; i++) {\n        if (nums[i] != i) {\n            return i;\n        }\n    }\n\n    return nums.length;\n}\n\n// Find All Missing Numbers\npublic List<Integer> findDisappearedNumbers(int[] nums) {\n    int i = 0;\n    while (i < nums.length) {\n        int correctIndex = nums[i] - 1;\n        if (nums[i] != nums[correctIndex]) {\n            swap(nums, i, correctIndex);\n        } else {\n            i++;\n        }\n    }\n\n    List<Integer> missing = new ArrayList<>();\n    for (i = 0; i < nums.length; i++) {\n        if (nums[i] != i + 1) {\n            missing.add(i + 1);\n        }\n    }\n\n    return missing;\n}\n\n// Find Duplicate Numbers\npublic List<Integer> findDuplicates(int[] nums) {\n    int i = 0;\n    while (i < nums.length) {\n        int correctIndex = nums[i] - 1;\n        if (nums[i] != nums[correctIndex]) {\n            swap(nums, i, correctIndex);\n        } else {\n            i++;\n        }\n    }\n\n    List<Integer> duplicates = new ArrayList<>();\n    for (i = 0; i < nums.length; i++) {\n        if (nums[i] != i + 1) {\n            duplicates.add(nums[i]);\n        }\n    }\n\n    return duplicates;\n}\n\nprivate void swap(int[] nums, int i, int j) {\n    int temp = nums[i];\n    nums[i] = nums[j];\n    nums[j] = temp;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-7-merge-intervals",children:"Pattern 7: Merge Intervals"}),"\n",(0,t.jsx)(e.h3,{id:"71-basic-interval-operations",children:"7.1 Basic Interval Operations"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Merge Intervals\npublic int[][] merge(int[][] intervals) {\n    if (intervals.length <= 1) return intervals;\n\n    Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));\n\n    List<int[]> merged = new ArrayList<>();\n    int[] currentInterval = intervals[0];\n\n    for (int i = 1; i < intervals.length; i++) {\n        if (currentInterval[1] >= intervals[i][0]) {\n            // Overlapping intervals, merge them\n            currentInterval[1] = Math.max(currentInterval[1], intervals[i][1]);\n        } else {\n            // Non-overlapping interval\n            merged.add(currentInterval);\n            currentInterval = intervals[i];\n        }\n    }\n\n    merged.add(currentInterval);\n    return merged.toArray(new int[merged.size()][]);\n}\n\n// Insert Interval\npublic int[][] insert(int[][] intervals, int[] newInterval) {\n    List<int[]> result = new ArrayList<>();\n    int i = 0;\n\n    // Add all intervals before the new interval\n    while (i < intervals.length && intervals[i][1] < newInterval[0]) {\n        result.add(intervals[i]);\n        i++;\n    }\n\n    // Merge overlapping intervals\n    while (i < intervals.length && intervals[i][0] <= newInterval[1]) {\n        newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\n        newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\n        i++;\n    }\n    result.add(newInterval);\n\n    // Add remaining intervals\n    while (i < intervals.length) {\n        result.add(intervals[i]);\n        i++;\n    }\n\n    return result.toArray(new int[result.size()][]);\n}\n\n// Non-overlapping Intervals (Minimum removals)\npublic int eraseOverlapIntervals(int[][] intervals) {\n    if (intervals.length <= 1) return 0;\n\n    Arrays.sort(intervals, (a, b) -> Integer.compare(a[1], b[1])); // Sort by end time\n\n    int count = 0;\n    int lastEnd = intervals[0][1];\n\n    for (int i = 1; i < intervals.length; i++) {\n        if (intervals[i][0] < lastEnd) {\n            count++; // Remove current interval\n        } else {\n            lastEnd = intervals[i][1];\n        }\n    }\n\n    return count;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"72-advanced-interval-problems",children:"7.2 Advanced Interval Problems"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Meeting Rooms\npublic boolean canAttendMeetings(int[][] intervals) {\n    Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));\n\n    for (int i = 1; i < intervals.length; i++) {\n        if (intervals[i][0] < intervals[i - 1][1]) {\n            return false; // Overlap found\n        }\n    }\n\n    return true;\n}\n\n// Meeting Rooms II (Minimum conference rooms)\npublic int minMeetingRooms(int[][] intervals) {\n    Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));\n\n    PriorityQueue<Integer> endTimes = new PriorityQueue<>();\n\n    for (int[] interval : intervals) {\n        if (!endTimes.isEmpty() && endTimes.peek() <= interval[0]) {\n            endTimes.poll(); // Room becomes available\n        }\n        endTimes.offer(interval[1]);\n    }\n\n    return endTimes.size();\n}\n\n// Interval List Intersections\npublic int[][] intervalIntersection(int[][] firstList, int[][] secondList) {\n    List<int[]> intersections = new ArrayList<>();\n    int i = 0, j = 0;\n\n    while (i < firstList.length && j < secondList.length) {\n        int start = Math.max(firstList[i][0], secondList[j][0]);\n        int end = Math.min(firstList[i][1], secondList[j][1]);\n\n        if (start <= end) {\n            intersections.add(new int[]{start, end});\n        }\n\n        // Move pointer of interval that ends first\n        if (firstList[i][1] < secondList[j][1]) {\n            i++;\n        } else {\n            j++;\n        }\n    }\n\n    return intersections.toArray(new int[intersections.size()][]);\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-8-dutch-national-flag",children:"Pattern 8: Dutch National Flag"}),"\n",(0,t.jsx)(e.h3,{id:"81-three-way-partitioning",children:"8.1 Three-Way Partitioning"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Sort Colors (Dutch National Flag)\npublic void sortColors(int[] nums) {\n    int low = 0, mid = 0, high = nums.length - 1;\n\n    while (mid <= high) {\n        if (nums[mid] == 0) {\n            swap(nums, low, mid);\n            low++;\n            mid++;\n        } else if (nums[mid] == 1) {\n            mid++;\n        } else { // nums[mid] == 2\n            swap(nums, mid, high);\n            high--;\n            // Don't increment mid as we need to check swapped element\n        }\n    }\n}\n\n// Three-Way Partitioning (Generic)\npublic void threeWayPartition(int[] arr, int a, int b) {\n    int low = 0, mid = 0, high = arr.length - 1;\n\n    while (mid <= high) {\n        if (arr[mid] < a) {\n            swap(arr, low, mid);\n            low++;\n            mid++;\n        } else if (arr[mid] > b) {\n            swap(arr, mid, high);\n            high--;\n        } else {\n            mid++;\n        }\n    }\n}\n\n// Partition Array Around Pivot\npublic int[] partitionAroundPivot(int[] arr, int pivot) {\n    int low = 0, mid = 0, high = arr.length - 1;\n\n    while (mid <= high) {\n        if (arr[mid] < pivot) {\n            swap(arr, low, mid);\n            low++;\n            mid++;\n        } else if (arr[mid] > pivot) {\n            swap(arr, mid, high);\n            high--;\n        } else {\n            mid++;\n        }\n    }\n\n    return arr;\n}\n\nprivate void swap(int[] arr, int i, int j) {\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-9-binary-search-in-arrays",children:"Pattern 9: Binary Search in Arrays"}),"\n",(0,t.jsx)(e.h3,{id:"91-basic-binary-search",children:"9.1 Basic Binary Search"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Binary Search\npublic int binarySearch(int[] arr, int target) {\n    int left = 0, right = arr.length - 1;\n\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n\n        if (arr[mid] == target) {\n            return mid;\n        } else if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    return -1; // Not found\n}\n\n// Find First and Last Position\npublic int[] searchRange(int[] nums, int target) {\n    int[] result = {-1, -1};\n\n    // Find first position\n    result[0] = findFirst(nums, target);\n    if (result[0] == -1) return result;\n\n    // Find last position\n    result[1] = findLast(nums, target);\n\n    return result;\n}\n\nprivate int findFirst(int[] nums, int target) {\n    int left = 0, right = nums.length - 1;\n    int result = -1;\n\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n\n        if (nums[mid] == target) {\n            result = mid;\n            right = mid - 1; // Continue searching left\n        } else if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    return result;\n}\n\nprivate int findLast(int[] nums, int target) {\n    int left = 0, right = nums.length - 1;\n    int result = -1;\n\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n\n        if (nums[mid] == target) {\n            result = mid;\n            left = mid + 1; // Continue searching right\n        } else if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"92-advanced-binary-search",children:"9.2 Advanced Binary Search"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Search in Rotated Sorted Array\npublic int search(int[] nums, int target) {\n    int left = 0, right = nums.length - 1;\n\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n\n        if (nums[mid] == target) return mid;\n\n        // Left half is sorted\n        if (nums[left] <= nums[mid]) {\n            if (target >= nums[left] && target < nums[mid]) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        // Right half is sorted\n        else {\n            if (target > nums[mid] && target <= nums[right]) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n\n    return -1;\n}\n\n// Find Peak Element\npublic int findPeakElement(int[] nums) {\n    int left = 0, right = nums.length - 1;\n\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n\n        if (nums[mid] > nums[mid + 1]) {\n            right = mid; // Peak is in left half (including mid)\n        } else {\n            left = mid + 1; // Peak is in right half\n        }\n    }\n\n    return left;\n}\n\n// Search Insert Position\npublic int searchInsert(int[] nums, int target) {\n    int left = 0, right = nums.length - 1;\n\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n\n        if (nums[mid] == target) {\n            return mid;\n        } else if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    return left; // Insert position\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-10-subarray-problems",children:"Pattern 10: Subarray Problems"}),"\n",(0,t.jsx)(e.h3,{id:"101-subarray-sum-problems",children:"10.1 Subarray Sum Problems"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Maximum Length of Subarray with Equal 0s and 1s\npublic int findMaxLength(int[] nums) {\n    Map<Integer, Integer> sumIndex = new HashMap<>();\n    sumIndex.put(0, -1); // Handle edge case\n\n    int maxLength = 0, sum = 0;\n\n    for (int i = 0; i < nums.length; i++) {\n        sum += (nums[i] == 1) ? 1 : -1;\n\n        if (sumIndex.containsKey(sum)) {\n            maxLength = Math.max(maxLength, i - sumIndex.get(sum));\n        } else {\n            sumIndex.put(sum, i);\n        }\n    }\n\n    return maxLength;\n}\n\n// Shortest Subarray with Sum at Least K\npublic int shortestSubarray(int[] nums, int k) {\n    int n = nums.length;\n    long[] prefixSum = new long[n + 1];\n\n    for (int i = 0; i < n; i++) {\n        prefixSum[i + 1] = prefixSum[i] + nums[i];\n    }\n\n    Deque<Integer> deque = new ArrayDeque<>();\n    int minLength = Integer.MAX_VALUE;\n\n    for (int i = 0; i <= n; i++) {\n        while (!deque.isEmpty() && prefixSum[i] - prefixSum[deque.peekFirst()] >= k) {\n            minLength = Math.min(minLength, i - deque.pollFirst());\n        }\n\n        while (!deque.isEmpty() && prefixSum[deque.peekLast()] >= prefixSum[i]) {\n            deque.pollLast();\n        }\n\n        deque.offerLast(i);\n    }\n\n    return minLength == Integer.MAX_VALUE ? -1 : minLength;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-11-matrix-traversal",children:"Pattern 11: Matrix Traversal"}),"\n",(0,t.jsx)(e.h3,{id:"111-basic-matrix-operations",children:"11.1 Basic Matrix Operations"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Rotate Image (90 degrees clockwise)\npublic void rotate(int[][] matrix) {\n    int n = matrix.length;\n\n    // Transpose matrix\n    for (int i = 0; i < n; i++) {\n        for (int j = i; j < n; j++) {\n            int temp = matrix[i][j];\n            matrix[i][j] = matrix[j][i];\n            matrix[j][i] = temp;\n        }\n    }\n\n    // Reverse each row\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n / 2; j++) {\n            int temp = matrix[i][j];\n            matrix[i][j] = matrix[i][n - 1 - j];\n            matrix[i][n - 1 - j] = temp;\n        }\n    }\n}\n\n// Spiral Matrix\npublic List<Integer> spiralOrder(int[][] matrix) {\n    List<Integer> result = new ArrayList<>();\n    if (matrix.length == 0) return result;\n\n    int top = 0, bottom = matrix.length - 1;\n    int left = 0, right = matrix[0].length - 1;\n\n    while (top <= bottom && left <= right) {\n        // Traverse right\n        for (int col = left; col <= right; col++) {\n            result.add(matrix[top][col]);\n        }\n        top++;\n\n        // Traverse down\n        for (int row = top; row <= bottom; row++) {\n            result.add(matrix[row][right]);\n        }\n        right--;\n\n        if (top <= bottom) {\n            // Traverse left\n            for (int col = right; col >= left; col--) {\n                result.add(matrix[bottom][col]);\n            }\n            bottom--;\n        }\n\n        if (left <= right) {\n            // Traverse up\n            for (int row = bottom; row >= top; row--) {\n                result.add(matrix[row][left]);\n            }\n            left++;\n        }\n    }\n\n    return result;\n}\n\n// Set Matrix Zeroes\npublic void setZeroes(int[][] matrix) {\n    boolean firstRowZero = false, firstColZero = false;\n\n    // Check if first row should be zero\n    for (int j = 0; j < matrix[0].length; j++) {\n        if (matrix[0][j] == 0) {\n            firstRowZero = true;\n            break;\n        }\n    }\n\n    // Check if first column should be zero\n    for (int i = 0; i < matrix.length; i++) {\n        if (matrix[i][0] == 0) {\n            firstColZero = true;\n            break;\n        }\n    }\n\n    // Use first row and column as markers\n    for (int i = 1; i < matrix.length; i++) {\n        for (int j = 1; j < matrix[0].length; j++) {\n            if (matrix[i][j] == 0) {\n                matrix[i][0] = 0;\n                matrix[0][j] = 0;\n            }\n        }\n    }\n\n    // Set zeros based on markers\n    for (int i = 1; i < matrix.length; i++) {\n        for (int j = 1; j < matrix[0].length; j++) {\n            if (matrix[i][0] == 0 || matrix[0][j] == 0) {\n                matrix[i][j] = 0;\n            }\n        }\n    }\n\n    // Handle first row and column\n    if (firstRowZero) {\n        for (int j = 0; j < matrix[0].length; j++) {\n            matrix[0][j] = 0;\n        }\n    }\n\n    if (firstColZero) {\n        for (int i = 0; i < matrix.length; i++) {\n            matrix[i][0] = 0;\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-12-advanced-array-techniques",children:"Pattern 12: Advanced Array Techniques"}),"\n",(0,t.jsx)(e.h3,{id:"121-boyer-moore-voting-algorithm",children:"12.1 Boyer-Moore Voting Algorithm"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Majority Element\npublic int majorityElement(int[] nums) {\n    int candidate = 0;\n    int count = 0;\n\n    // Phase 1: Find candidate\n    for (int num : nums) {\n        if (count == 0) {\n            candidate = num;\n        }\n        count += (num == candidate) ? 1 : -1;\n    }\n\n    return candidate; // Guaranteed to exist\n}\n\n// Majority Element II (More than n/3)\npublic List<Integer> majorityElement(int[] nums) {\n    int candidate1 = 0, candidate2 = 0;\n    int count1 = 0, count2 = 0;\n\n    // Phase 1: Find candidates\n    for (int num : nums) {\n        if (candidate1 == num) {\n            count1++;\n        } else if (candidate2 == num) {\n            count2++;\n        } else if (count1 == 0) {\n            candidate1 = num;\n            count1 = 1;\n        } else if (count2 == 0) {\n            candidate2 = num;\n            count2 = 1;\n        } else {\n            count1--;\n            count2--;\n        }\n    }\n\n    // Phase 2: Verify candidates\n    List<Integer> result = new ArrayList<>();\n    count1 = count2 = 0;\n\n    for (int num : nums) {\n        if (num == candidate1) count1++;\n        else if (num == candidate2) count2++;\n    }\n\n    if (count1 > nums.length / 3) result.add(candidate1);\n    if (count2 > nums.length / 3) result.add(candidate2);\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"122-array-manipulation-techniques",children:"12.2 Array Manipulation Techniques"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Next Permutation\npublic void nextPermutation(int[] nums) {\n    int i = nums.length - 2;\n\n    // Find first decreasing element from right\n    while (i >= 0 && nums[i] >= nums[i + 1]) {\n        i--;\n    }\n\n    if (i >= 0) {\n        int j = nums.length - 1;\n        // Find element just larger than nums[i]\n        while (nums[j] <= nums[i]) {\n            j--;\n        }\n        swap(nums, i, j);\n    }\n\n    // Reverse suffix\n    reverse(nums, i + 1);\n}\n\nprivate void reverse(int[] nums, int start) {\n    int end = nums.length - 1;\n    while (start < end) {\n        swap(nums, start++, end--);\n    }\n}\n\n// Gas Station\npublic int canCompleteCircuit(int[] gas, int[] cost) {\n    int totalTank = 0, currentTank = 0, startStation = 0;\n\n    for (int i = 0; i < gas.length; i++) {\n        totalTank += gas[i] - cost[i];\n        currentTank += gas[i] - cost[i];\n\n        if (currentTank < 0) {\n            startStation = i + 1;\n            currentTank = 0;\n        }\n    }\n\n    return totalTank >= 0 ? startStation : -1;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"time--space-complexity-reference1",children:"Time & Space Complexity Reference[1]"}),"\n",(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{style:{textAlign:"left"},children:"Pattern"}),(0,t.jsx)(e.th,{style:{textAlign:"left"},children:"Time Complexity"}),(0,t.jsx)(e.th,{style:{textAlign:"left"},children:"Space Complexity"}),(0,t.jsx)(e.th,{style:{textAlign:"left"},children:"Key Characteristics"})]})}),(0,t.jsxs)(e.tbody,{children:[(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Two Pointers"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(1)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Linear scan with constant space"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Sliding Window"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(1) to O(k)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Single pass with window state"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Prefix Sum"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Preprocessing for range queries"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Kadane's Algorithm"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(1)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Single pass maximum subarray"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Fast & Slow Pointers"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(1)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Cycle detection patterns"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Cyclic Sort"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(1)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"In-place sorting for specific ranges"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Merge Intervals"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(n log n)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(1) to O(n)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Sorting + linear merge"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Dutch National Flag"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(1)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Three-way partitioning"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Binary Search"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(log n)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(1)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Divide and conquer"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Matrix Operations"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(m \xd7 n)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(1) to O(m \xd7 n)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"2D array processing"})]})]})]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"best-practices--optimization-tips",children:"Best Practices & Optimization Tips"}),"\n",(0,t.jsx)(e.h3,{id:"array-algorithm-guidelines",children:"Array Algorithm Guidelines"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// 1. Always check bounds\npublic void safeBoundsCheck(int[] arr, int index) {\n    if (index < 0 || index >= arr.length) {\n        throw new ArrayIndexOutOfBoundsException();\n    }\n    // Process arr[index]\n}\n\n// 2. Use appropriate data structures\nMap<Integer, Integer> frequency = new HashMap<>(); // For counting\nSet<Integer> seen = new HashSet<>(); // For uniqueness\nDeque<Integer> window = new ArrayDeque<>(); // For sliding window\n\n// 3. Consider edge cases\npublic int[] handleEdgeCases(int[] arr) {\n    if (arr == null || arr.length == 0) {\n        return new int[0]; // or throw exception\n    }\n\n    if (arr.length == 1) {\n        return arr; // Handle single element\n    }\n\n    // Main logic\n    return arr;\n}\n\n// 4. Optimize space when possible\npublic void inPlaceOperation(int[] arr) {\n    // Modify array in-place instead of creating new array\n    int writeIndex = 0;\n    for (int readIndex = 0; readIndex < arr.length; readIndex++) {\n        if (shouldKeep(arr[readIndex])) {\n            arr[writeIndex++] = arr[readIndex];\n        }\n    }\n}\n\nboolean shouldKeep(int value) { return value != 0; }\n"})}),"\n",(0,t.jsx)(e.h3,{id:"common-pitfalls-to-avoid",children:"Common Pitfalls to Avoid"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Integer Overflow"}),": Use ",(0,t.jsx)(e.code,{children:"long"})," for sum calculations"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Off-by-one errors"}),": Careful with array bounds"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Null pointer exceptions"}),": Always check for null arrays"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Modifying array while iterating"}),": Use separate read/write pointers"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Not handling empty arrays"}),": Check length before processing"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"interview-tips1011",children:"Interview Tips[10][11]"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Identify the pattern"})," early: sorting, two pointers, sliding window, etc."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Draw examples"})," on paper to visualize the problem"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Start with brute force"})," then optimize"]}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.strong,{children:"Consider time vs space tradeoffs"})}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Test with edge cases"}),": empty arrays, single elements, duplicates"]}),"\n"]})]})}function o(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(m,{...n})}):m(n)}}}]);