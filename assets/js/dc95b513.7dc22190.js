"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[4041],{28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var i=t(96540);const s={},r=i.createContext(s);function o(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:n},e.children)}},75834:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>a,toc:()=>c});var i=t(74848),s=t(28453);const r={title:"News Feed System Design",description:"Complete system design for a scalable news feed platform (Facebook/Twitter-like)",author:"System Design Guide",date:"2025-10-07",tags:["system-design","news-feed","social-media","distributed-systems"]},o="News Feed System Design",a={id:"System-Design/System Design Problems/News Feed System Design",title:"News Feed System Design",description:"Complete system design for a scalable news feed platform (Facebook/Twitter-like)",source:"@site/docs/03-System-Design/System Design Problems/News Feed System Design.mdx",sourceDirName:"03-System-Design/System Design Problems",slug:"/System-Design/System Design Problems/News Feed System Design",permalink:"/docs/System-Design/System Design Problems/News Feed System Design",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/03-System-Design/System Design Problems/News Feed System Design.mdx",tags:[{inline:!0,label:"system-design",permalink:"/docs/tags/system-design"},{inline:!0,label:"news-feed",permalink:"/docs/tags/news-feed"},{inline:!0,label:"social-media",permalink:"/docs/tags/social-media"},{inline:!0,label:"distributed-systems",permalink:"/docs/tags/distributed-systems"}],version:"current",frontMatter:{title:"News Feed System Design",description:"Complete system design for a scalable news feed platform (Facebook/Twitter-like)",author:"System Design Guide",date:"2025-10-07",tags:["system-design","news-feed","social-media","distributed-systems"]},sidebar:"tutorialSidebar",previous:{title:"Netflix System Design",permalink:"/docs/System-Design/System Design Problems/Netflix System Design"},next:{title:"Rate Limiter System Design",permalink:"/docs/System-Design/System Design Problems/Rate Limiter System Design"}},l={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"1. Requirements (~5 minutes)",id:"1-requirements-5-minutes",level:2},{value:"Functional Requirements",id:"functional-requirements",level:3},{value:"Non-functional Requirements",id:"non-functional-requirements",level:3},{value:"Capacity Estimation",id:"capacity-estimation",level:3},{value:"2. Core Entities (~2 minutes)",id:"2-core-entities-2-minutes",level:2},{value:"User",id:"user",level:3},{value:"Post",id:"post",level:3},{value:"Interaction",id:"interaction",level:3},{value:"Comment",id:"comment",level:3},{value:"Follow",id:"follow",level:3},{value:"Feed",id:"feed",level:3},{value:"Notification",id:"notification",level:3},{value:"3. API Interface (~5 minutes)",id:"3-api-interface-5-minutes",level:2},{value:"Protocol Choice",id:"protocol-choice",level:3},{value:"API Endpoints",id:"api-endpoints",level:3},{value:"Authentication",id:"authentication",level:4},{value:"Feed Operations",id:"feed-operations",level:4},{value:"Post Creation",id:"post-creation",level:4},{value:"Interactions",id:"interactions",level:4},{value:"Social Graph",id:"social-graph",level:4},{value:"Notifications",id:"notifications",level:4},{value:"WebSocket (Real-time)",id:"websocket-real-time",level:4},{value:"4. Data Flow (~5 minutes)",id:"4-data-flow-5-minutes",level:2},{value:"Feed Generation Flow (Hybrid Approach)",id:"feed-generation-flow-hybrid-approach",level:3},{value:"5. High Level Design (~10-15 minutes)",id:"5-high-level-design-10-15-minutes",level:2},{value:"Architecture Components",id:"architecture-components",level:3},{value:"6. Architecture Diagram",id:"6-architecture-diagram",level:2},{value:"7. Deep Dives (~10 minutes)",id:"7-deep-dives-10-minutes",level:2},{value:"7.1 Feed Generation Strategies",id:"71-feed-generation-strategies",level:3},{value:"Strategy Comparison",id:"strategy-comparison",level:4},{value:"Hybrid Implementation (Spring Boot)",id:"hybrid-implementation-spring-boot",level:4},{value:"7.2 Fanout Service (Kafka Consumer)",id:"72-fanout-service-kafka-consumer",level:3},{value:"7.3 Post Service",id:"73-post-service",level:3},{value:"7.4 Interaction Service (Likes, Comments, Shares)",id:"74-interaction-service-likes-comments-shares",level:3},{value:"7.5 Ranking Service (ML-Based Feed Ranking)",id:"75-ranking-service-ml-based-feed-ranking",level:3},{value:"7.6 Social Graph Service",id:"76-social-graph-service",level:3},{value:"7.7 Notification Service",id:"77-notification-service",level:3},{value:"7.8 WebSocket Handler (Real-time Updates)",id:"78-websocket-handler-real-time-updates",level:3},{value:"7.9 Database Schema Design",id:"79-database-schema-design",level:3},{value:"PostgreSQL (Users, Posts, Comments)",id:"postgresql-users-posts-comments",level:4},{value:"Cassandra (Pre-computed Feeds, Time-series Data)",id:"cassandra-pre-computed-feeds-time-series-data",level:4},{value:"7.10 Caching Strategy",id:"710-caching-strategy",level:3},{value:"Multi-Layer Cache Architecture",id:"multi-layer-cache-architecture",level:4},{value:"Redis Caching Implementation",id:"redis-caching-implementation",level:4},{value:"7.11 Media Processing Service",id:"711-media-processing-service",level:3},{value:"7.12 Search Service (Elasticsearch)",id:"712-search-service-elasticsearch",level:3},{value:"7.13 Rate Limiting",id:"713-rate-limiting",level:3},{value:"7.14 Analytics Pipeline",id:"714-analytics-pipeline",level:3},{value:"8. Monitoring &amp; Observability",id:"8-monitoring--observability",level:2},{value:"Key Metrics to Track",id:"key-metrics-to-track",level:3},{value:"Alerting Rules",id:"alerting-rules",level:3},{value:"9. Summary",id:"9-summary",level:2},{value:"Key Design Decisions",id:"key-design-decisions",level:3},{value:"Scalability Achieved",id:"scalability-achieved",level:3},{value:"10. Trade-offs &amp; Considerations",id:"10-trade-offs--considerations",level:2},{value:"11. Key Differences from Other Systems",id:"11-key-differences-from-other-systems",level:2},{value:"12. Future Enhancements",id:"12-future-enhancements",level:2},{value:"13. Additional Considerations",id:"13-additional-considerations",level:2},{value:"Data Consistency",id:"data-consistency",level:3},{value:"Security Considerations",id:"security-considerations",level:3},{value:"Privacy Controls",id:"privacy-controls",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"news-feed-system-design",children:"News Feed System Design"})}),"\n",(0,i.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#1-requirements-5-minutes",children:"Requirements"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#functional-requirements",children:"Functional Requirements"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#non-functional-requirements",children:"Non-functional Requirements"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#capacity-estimation",children:"Capacity Estimation"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#2-core-entities-2-minutes",children:"Core Entities"})}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#3-api-interface-5-minutes",children:"API Interface"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#authentication",children:"Authentication"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#feed-operations",children:"Feed Operations"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#post-creation",children:"Post Creation"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#interactions",children:"Interactions"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#social-graph",children:"Social Graph"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#notifications",children:"Notifications"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#websocket-real-time",children:"WebSocket (Real-time)"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#4-data-flow-5-minutes",children:"Data Flow"})}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#5-high-level-design-10-15-minutes",children:"High-Level Design (HLD)"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#architecture-components",children:"Architecture Components"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#6-architecture-diagram",children:"Architecture Diagram"})}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#7-deep-dives-10-minutes",children:"Deep Dives"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#71-feed-generation-strategies",children:"7.1 Feed Generation Strategies"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#72-fanout-service-kafka-consumer",children:"7.2 Fanout Service"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#73-post-service",children:"7.3 Post Service"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#74-interaction-service-likes-comments-shares",children:"7.4 Interaction Service"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#75-ranking-service-ml-based-feed-ranking",children:"7.5 Ranking Service"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#76-social-graph-service",children:"7.6 Social Graph Service"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#77-notification-service",children:"7.7 Notification Service"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#78-websocket-handler-real-time-updates",children:"7.8 WebSocket Handler"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#79-database-schema-design",children:"7.9 Database Schema Design"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#710-caching-strategy",children:"7.10 Caching Strategy"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#711-media-processing-service",children:"7.11 Media Processing Service"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#712-search-service-elasticsearch",children:"7.12 Search Service"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#713-rate-limiting",children:"7.13 Rate Limiting"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#714-analytics-pipeline",children:"7.14 Analytics Pipeline"})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#8-monitoring--observability",children:"Monitoring & Observability"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#key-metrics-to-track",children:"Key Metrics to Track"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#alerting-rules",children:"Alerting Rules"})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#9-summary",children:"Summary"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#key-design-decisions",children:"Key Design Decisions"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#scalability-achieved",children:"Scalability Achieved"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#10-trade-offs--considerations",children:"Trade-offs & Considerations"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#11-key-differences-from-other-systems",children:"Key Differences from Other Systems"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#12-future-enhancements",children:"Future Enhancements"})}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#13-additional-considerations",children:"Additional Considerations"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#data-consistency",children:"Data Consistency"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#security-considerations",children:"Security Considerations"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#privacy-controls",children:"Privacy Controls"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"1-requirements-5-minutes",children:"1. Requirements (~5 minutes)"}),"\n",(0,i.jsx)(n.h3,{id:"functional-requirements",children:"Functional Requirements"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u2705 Users should be able to ",(0,i.jsx)(n.strong,{children:"view their personalized news feed"})," (posts from followed users/pages)"]}),"\n",(0,i.jsxs)(n.li,{children:["\u2705 Users should be able to ",(0,i.jsx)(n.strong,{children:"create posts"})," (text, images, videos, links)"]}),"\n",(0,i.jsxs)(n.li,{children:["\u2705 Users should be able to ",(0,i.jsx)(n.strong,{children:"interact with posts"})," (like, comment, share, save)"]}),"\n",(0,i.jsxs)(n.li,{children:["\u2705 Users should be able to ",(0,i.jsx)(n.strong,{children:"follow/unfollow"})," users and pages"]}),"\n",(0,i.jsxs)(n.li,{children:["\u2705 System should support ",(0,i.jsx)(n.strong,{children:"real-time notifications"})," for interactions"]}),"\n",(0,i.jsxs)(n.li,{children:["\u2705 Feed should be ",(0,i.jsx)(n.strong,{children:"ranked"})," by relevance (not just chronological)"]}),"\n",(0,i.jsxs)(n.li,{children:["\u2705 Support ",(0,i.jsx)(n.strong,{children:"hashtags, mentions, and tagging"})]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"non-functional-requirements",children:"Non-functional Requirements"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u2705 The system should prioritize ",(0,i.jsx)(n.strong,{children:"availability"})," over consistency (eventual consistency acceptable)"]}),"\n",(0,i.jsxs)(n.li,{children:["\u2705 The system should scale to support ",(0,i.jsx)(n.strong,{children:"2B+ users"})," (500M daily active)"]}),"\n",(0,i.jsxs)(n.li,{children:["\u2705 Feed generation should be ",(0,i.jsx)(n.strong,{children:"fast"})," (< 500ms P99)"]}),"\n",(0,i.jsxs)(n.li,{children:["\u2705 The system should be ",(0,i.jsx)(n.strong,{children:"highly available"})," (99.99% uptime)"]}),"\n",(0,i.jsxs)(n.li,{children:["\u2705 ",(0,i.jsx)(n.strong,{children:"Low latency"})," for post creation (< 200ms)"]}),"\n",(0,i.jsxs)(n.li,{children:["\u2705 Support for ",(0,i.jsx)(n.strong,{children:"high read-to-write ratio"})," (~100:1)"]}),"\n",(0,i.jsxs)(n.li,{children:["\u2705 Real-time feed updates for ",(0,i.jsx)(n.strong,{children:"active users"})]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"capacity-estimation",children:"Capacity Estimation"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Assumptions:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Total Users: 2B"}),"\n",(0,i.jsx)(n.li,{children:"Daily Active Users (DAU): 500M"}),"\n",(0,i.jsx)(n.li,{children:"Average posts per user: 2 posts/day"}),"\n",(0,i.jsx)(n.li,{children:"Average following: 300 connections"}),"\n",(0,i.jsx)(n.li,{children:"Average post size: 1 KB (text + metadata)"}),"\n",(0,i.jsx)(n.li,{children:"Image/video stored separately (average 2 MB)"}),"\n",(0,i.jsx)(n.li,{children:"Feed refresh: 20 times/day per user"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Storage:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Daily Posts = 500M users \xd7 2 posts = 1B posts/day\nAnnual Posts = 1B \xd7 365 = 365B posts/year\nPost Metadata = 365B \xd7 1 KB = 365 TB/year\nMedia Storage = 1B posts/day \xd7 0.5 (media posts) \xd7 2 MB = 1 PB/day\nAnnual Media = 365 PB (with compression ~180 PB)\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"QPS:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Post Creation = 1B posts/day / 86400s = ~12K writes/sec\nFeed Reads = 500M DAU \xd7 20 refreshes/day / 86400s = ~115K reads/sec\nPeak QPS (5x average) = 575K reads/sec, 60K writes/sec\nInteractions (likes/comments) = 500M \xd7 50 actions/day / 86400s = ~290K QPS\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Network:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Feed Fetch Size = 20 posts \xd7 1 KB metadata = 20 KB\nPeak Bandwidth = 575K requests/sec \xd7 20 KB = 11.5 GB/s\nMedia Bandwidth = 500M users \xd7 10 images/day \xd7 2 MB / 86400s = 115 GB/s\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"2-core-entities-2-minutes",children:"2. Core Entities (~2 minutes)"}),"\n",(0,i.jsx)(n.h3,{id:"user",children:"User"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"userId"}),", ",(0,i.jsx)(n.code,{children:"username"}),", ",(0,i.jsx)(n.code,{children:"email"}),", ",(0,i.jsx)(n.code,{children:"displayName"}),", ",(0,i.jsx)(n.code,{children:"profilePicUrl"}),", ",(0,i.jsx)(n.code,{children:"bio"}),", ",(0,i.jsx)(n.code,{children:"verified"}),", ",(0,i.jsx)(n.code,{children:"createdAt"})]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"post",children:"Post"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"postId"}),", ",(0,i.jsx)(n.code,{children:"userId"}),", ",(0,i.jsx)(n.code,{children:"content"}),", ",(0,i.jsx)(n.code,{children:"mediaUrls[]"}),", ",(0,i.jsx)(n.code,{children:"postType"})," (TEXT/IMAGE/VIDEO/LINK), ",(0,i.jsx)(n.code,{children:"visibility"})," (PUBLIC/FRIENDS/PRIVATE), ",(0,i.jsx)(n.code,{children:"createdAt"}),", ",(0,i.jsx)(n.code,{children:"editedAt"})]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"interaction",children:"Interaction"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"interactionId"}),", ",(0,i.jsx)(n.code,{children:"postId"}),", ",(0,i.jsx)(n.code,{children:"userId"}),", ",(0,i.jsx)(n.code,{children:"type"})," (LIKE/SHARE/SAVE), ",(0,i.jsx)(n.code,{children:"createdAt"})]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"comment",children:"Comment"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"commentId"}),", ",(0,i.jsx)(n.code,{children:"postId"}),", ",(0,i.jsx)(n.code,{children:"userId"}),", ",(0,i.jsx)(n.code,{children:"parentCommentId"}),", ",(0,i.jsx)(n.code,{children:"content"}),", ",(0,i.jsx)(n.code,{children:"createdAt"})]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"follow",children:"Follow"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"followerId"}),", ",(0,i.jsx)(n.code,{children:"followeeId"}),", ",(0,i.jsx)(n.code,{children:"createdAt"})]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"feed",children:"Feed"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"userId"}),", ",(0,i.jsx)(n.code,{children:"postId"}),", ",(0,i.jsx)(n.code,{children:"score"}),", ",(0,i.jsx)(n.code,{children:"generatedAt"})," (pre-computed feed)"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"notification",children:"Notification"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"notificationId"}),", ",(0,i.jsx)(n.code,{children:"userId"}),", ",(0,i.jsx)(n.code,{children:"actorId"}),", ",(0,i.jsx)(n.code,{children:"type"})," (LIKE/COMMENT/FOLLOW), ",(0,i.jsx)(n.code,{children:"postId"}),", ",(0,i.jsx)(n.code,{children:"read"}),", ",(0,i.jsx)(n.code,{children:"createdAt"})]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"3-api-interface-5-minutes",children:"3. API Interface (~5 minutes)"}),"\n",(0,i.jsx)(n.h3,{id:"protocol-choice",children:"Protocol Choice"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"REST"})," for CRUD operations"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"WebSocket"})," for real-time notifications and live feed updates"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"GraphQL"})," for flexible feed queries (optional optimization)"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"api-endpoints",children:"API Endpoints"}),"\n",(0,i.jsx)(n.h4,{id:"authentication",children:"Authentication"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-http",children:'POST /api/v1/auth/login\nRequest: { "email": "user@example.com", "password": "hashed_password" }\nResponse: { "accessToken": "jwt_token", "refreshToken": "refresh_token", "expiresIn": 3600 }\n'})}),"\n",(0,i.jsx)(n.h4,{id:"feed-operations",children:"Feed Operations"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-http",children:'GET /api/v1/feed?limit=20&cursor=eyJwb3N0SWQiOiIxMjM0NSJ9\nResponse: {\n  "posts": [\n    {\n      "postId": "12345",\n      "author": { "userId": "user-789", "username": "john_doe", "profilePicUrl": "..." },\n      "content": "Hello world!",\n      "mediaUrls": ["https://cdn.app.com/img1.jpg"],\n      "createdAt": "2025-10-07T10:30:00Z",\n      "stats": { "likes": 150, "comments": 25, "shares": 10 },\n      "userInteraction": { "liked": false, "saved": false }\n    }\n  ],\n  "nextCursor": "eyJwb3N0SWQiOiI2Nzg5MCJ9",\n  "hasMore": true\n}\n\nGET /api/v1/users/{userId}/posts?limit=20\nGET /api/v1/feed/following?limit=20  // Chronological feed\n'})}),"\n",(0,i.jsx)(n.h4,{id:"post-creation",children:"Post Creation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-http",children:'POST /api/v1/posts\nContent-Type: multipart/form-data\nRequest: {\n  "content": "Check out this amazing sunset!",\n  "mediaFiles": [<binary>],\n  "visibility": "PUBLIC",\n  "tags": ["sunset", "nature"],\n  "mentions": ["@jane_doe"]\n}\nResponse: {\n  "postId": "post-123",\n  "status": "PUBLISHED",\n  "createdAt": "2025-10-07T14:20:00Z"\n}\n\nPUT /api/v1/posts/{postId}\nDELETE /api/v1/posts/{postId}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"interactions",children:"Interactions"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-http",children:'POST /api/v1/posts/{postId}/like\nDELETE /api/v1/posts/{postId}/like\n\nPOST /api/v1/posts/{postId}/comments\nRequest: { "content": "Great post!", "parentCommentId": null }\nResponse: { "commentId": "comment-456", "createdAt": "..." }\n\nGET /api/v1/posts/{postId}/comments?limit=50&sort=top\nPOST /api/v1/posts/{postId}/share\nPOST /api/v1/posts/{postId}/save\n'})}),"\n",(0,i.jsx)(n.h4,{id:"social-graph",children:"Social Graph"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-http",children:"POST /api/v1/users/{userId}/follow\nDELETE /api/v1/users/{userId}/unfollow\nGET /api/v1/users/{userId}/followers?limit=50\nGET /api/v1/users/{userId}/following?limit=50\n"})}),"\n",(0,i.jsx)(n.h4,{id:"notifications",children:"Notifications"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-http",children:'GET /api/v1/notifications?limit=20&unreadOnly=true\nResponse: {\n  "notifications": [\n    {\n      "notificationId": "notif-789",\n      "type": "LIKE",\n      "actor": { "userId": "user-123", "username": "jane_doe" },\n      "post": { "postId": "post-456", "contentPreview": "..." },\n      "createdAt": "2025-10-07T12:00:00Z",\n      "read": false\n    }\n  ]\n}\n\nPUT /api/v1/notifications/{notificationId}/read\nPUT /api/v1/notifications/mark-all-read\n'})}),"\n",(0,i.jsx)(n.h4,{id:"websocket-real-time",children:"WebSocket (Real-time)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'WebSocket: wss://realtime.app.com/feed\nMessages: {\n  "type": "NEW_POST",\n  "data": { "postId": "...", "author": {...}, "content": "..." }\n}\n\nTypes: NEW_POST, NOTIFICATION, FEED_UPDATE\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"4-data-flow-5-minutes",children:"4. Data Flow (~5 minutes)"}),"\n",(0,i.jsx)(n.h3,{id:"feed-generation-flow-hybrid-approach",children:"Feed Generation Flow (Hybrid Approach)"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["Fanout-on-Write (Push) - For Users with Few Followers (",(0,i.jsx)(n.code,{children:"<10K"}),")"]})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"User creates post \u2192 Post Service"}),"\n",(0,i.jsx)(n.li,{children:"Post Service writes to DB"}),"\n",(0,i.jsx)(n.li,{children:"Post Service publishes event to Kafka"}),"\n",(0,i.jsx)(n.li,{children:"Fanout Service fetches user's followers"}),"\n",(0,i.jsx)(n.li,{children:"Pre-computed feeds updated in Redis/Cassandra"}),"\n",(0,i.jsx)(n.li,{children:"Followers see post instantly"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Fanout-on-Read (Pull) - For Celebrities (>10K followers)"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"User creates post \u2192 Post Service"}),"\n",(0,i.jsx)(n.li,{children:"Post Service writes to DB"}),"\n",(0,i.jsx)(n.li,{children:"When follower requests feed \u2192 Feed Service"}),"\n",(0,i.jsx)(n.li,{children:"Fetch recent posts from followed celebrities"}),"\n",(0,i.jsx)(n.li,{children:"Merge with pre-computed feed"}),"\n",(0,i.jsx)(n.li,{children:"Rank and return"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Hybrid Example:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"User requests feed \u2192\n  1. Fetch pre-computed feed (Redis) - from regular users\n  2. Fetch latest posts from celebrities (Database query)\n  3. Merge + Rank (ML model)\n  4. Cache result for 5 minutes\n  5. Return to client\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"5-high-level-design-10-15-minutes",children:"5. High Level Design (~10-15 minutes)"}),"\n",(0,i.jsx)(n.h3,{id:"architecture-components",children:"Architecture Components"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Client Layer:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Mobile Apps (iOS/Android)"}),"\n",(0,i.jsx)(n.li,{children:"Web Application (React/Next.js)"}),"\n",(0,i.jsx)(n.li,{children:"Native Desktop Apps"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Edge Layer:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"CDN (CloudFlare/Akamai) - media files, static assets"}),"\n",(0,i.jsx)(n.li,{children:"API Gateway - authentication, rate limiting, routing"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"API Layer:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Post Service"})," - create, edit, delete posts"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Feed Service"})," - generate and serve feeds"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Interaction Service"})," - likes, comments, shares"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Social Graph Service"})," - follows, friends"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Notification Service"})," - push notifications"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"User Service"})," - profiles, authentication"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Media Service"})," - upload/process images/videos"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Data Layer:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"PostgreSQL"})," - users, posts metadata (with read replicas)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Cassandra"})," - pre-computed feeds, social graph"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Redis Cluster"})," - caching, session management"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Elasticsearch"})," - search posts, users, hashtags"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"S3/Object Storage"})," - media files (images/videos)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Neo4j"})," (optional) - complex graph queries"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Processing Layer:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Kafka"})," - event streaming (post created, liked, commented)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Fanout Workers"})," - distribute posts to followers' feeds"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Ranking Service"})," - ML-based feed ranking"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Analytics Pipeline"})," - engagement metrics"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Media Processing"})," - resize images, transcode videos"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Real-time Layer:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"WebSocket Servers"})," - live updates, notifications"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Redis Pub/Sub"})," - broadcast messages"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"6-architecture-diagram",children:"6. Architecture Diagram"}),"\n",(0,i.jsx)(n.mermaid,{value:'graph TB\n    subgraph "Client Layer"\n        Mobile[Mobile Apps<br/>iOS/Android]\n        Web[Web Application]\n        Desktop[Desktop Apps]\n    end\n\n    subgraph "CDN & Edge"\n        CDN[CDN<br/>Media Files<br/>Static Assets]\n        Gateway[API Gateway<br/>Auth, Rate Limit<br/>Load Balance]\n    end\n\n    subgraph "Microservices"\n        PostSvc[Post Service<br/>Create/Edit Posts]\n        FeedSvc[Feed Service<br/>Generate Feeds]\n        InteractionSvc[Interaction Service<br/>Like/Comment/Share]\n        GraphSvc[Social Graph Service<br/>Follow/Unfollow]\n        NotifSvc[Notification Service<br/>Push Notifications]\n        UserSvc[User Service<br/>Profiles/Auth]\n        MediaSvc[Media Service<br/>Upload/Process]\n    end\n\n    subgraph "Cache Layer"\n        Redis[(Redis Cluster<br/>Feed Cache<br/>Session Cache<br/>Hot Data)]\n        RedisPubSub[Redis Pub/Sub<br/>Real-time Events]\n    end\n\n    subgraph "Database Layer"\n        Postgres[(PostgreSQL<br/>Users, Posts<br/>Metadata)]\n        Cassandra[(Cassandra<br/>Pre-computed Feeds<br/>Social Graph)]\n        Elasticsearch[(Elasticsearch<br/>Search Index<br/>Hashtags)]\n    end\n\n    subgraph "Storage Layer"\n        S3[S3/Object Storage<br/>Images/Videos<br/>Thumbnails]\n    end\n\n    subgraph "Event Processing"\n        Kafka[Kafka<br/>Event Streaming]\n        FanoutWorkers[Fanout Workers<br/>Distribute Posts]\n        RankingSvc[Ranking Service<br/>ML Feed Scoring]\n        Analytics[Analytics Pipeline<br/>Engagement Metrics]\n        MediaProcessor[Media Processor<br/>Image/Video Processing]\n    end\n\n    subgraph "Real-time Layer"\n        WSGateway[WebSocket Gateway<br/>Live Updates]\n    end\n\n    %% Client connections\n    Mobile --\x3e CDN\n    Web --\x3e CDN\n    Desktop --\x3e CDN\n    Mobile --\x3e Gateway\n    Web --\x3e Gateway\n    Desktop --\x3e Gateway\n\n    %% Gateway to services\n    Gateway --\x3e PostSvc\n    Gateway --\x3e FeedSvc\n    Gateway --\x3e InteractionSvc\n    Gateway --\x3e GraphSvc\n    Gateway --\x3e NotifSvc\n    Gateway --\x3e UserSvc\n    Gateway --\x3e MediaSvc\n\n    %% WebSocket\n    Mobile -.Real-time.-> WSGateway\n    Web -.Real-time.-> WSGateway\n    WSGateway --\x3e RedisPubSub\n    WSGateway --\x3e NotifSvc\n\n    %% Services to cache\n    FeedSvc --\x3e Redis\n    PostSvc --\x3e Redis\n    InteractionSvc --\x3e Redis\n    GraphSvc --\x3e Redis\n\n    %% Services to databases\n    PostSvc --\x3e Postgres\n    FeedSvc --\x3e Cassandra\n    FeedSvc --\x3e Redis\n    InteractionSvc --\x3e Postgres\n    GraphSvc --\x3e Cassandra\n    UserSvc --\x3e Postgres\n    NotifSvc --\x3e Cassandra\n    PostSvc --\x3e Elasticsearch\n\n    %% Media handling\n    MediaSvc --\x3e S3\n    S3 --\x3e CDN\n\n    %% Event streaming\n    PostSvc --\x3e|Post Created| Kafka\n    InteractionSvc --\x3e|Interaction Event| Kafka\n    GraphSvc --\x3e|Follow Event| Kafka\n\n    Kafka --\x3e FanoutWorkers\n    Kafka --\x3e RankingSvc\n    Kafka --\x3e Analytics\n    Kafka --\x3e MediaProcessor\n\n    FanoutWorkers --\x3e Cassandra\n    FanoutWorkers --\x3e Redis\n    RankingSvc --\x3e Redis\n    MediaProcessor --\x3e S3\n\n    style Mobile fill:#e1f5ff\n    style Web fill:#e1f5ff\n    style Desktop fill:#e1f5ff\n    style CDN fill:#fff4e1\n    style Kafka fill:#ffe1f5\n    style RankingSvc fill:#ffe1f5\n    style FanoutWorkers fill:#ffe1f5'}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"7-deep-dives-10-minutes",children:"7. Deep Dives (~10 minutes)"}),"\n",(0,i.jsx)(n.h3,{id:"71-feed-generation-strategies",children:"7.1 Feed Generation Strategies"}),"\n",(0,i.jsx)(n.h4,{id:"strategy-comparison",children:"Strategy Comparison"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Approach"}),(0,i.jsx)(n.th,{children:"Pros"}),(0,i.jsx)(n.th,{children:"Cons"}),(0,i.jsx)(n.th,{children:"Best For"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Fanout-on-Write (Push)"})}),(0,i.jsx)(n.td,{children:"Fast reads, pre-computed"}),(0,i.jsx)(n.td,{children:"Slow writes for celebrities, high storage"}),(0,i.jsx)(n.td,{children:"Regular users"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Fanout-on-Read (Pull)"})}),(0,i.jsx)(n.td,{children:"Fast writes, less storage"}),(0,i.jsx)(n.td,{children:"Slow reads, compute on demand"}),(0,i.jsx)(n.td,{children:"Celebrities"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Hybrid"})}),(0,i.jsx)(n.td,{children:"Balanced performance"}),(0,i.jsx)(n.td,{children:"Complex implementation"}),(0,i.jsx)(n.td,{children:"All users"})]})]})]}),"\n",(0,i.jsx)(n.h4,{id:"hybrid-implementation-spring-boot",children:"Hybrid Implementation (Spring Boot)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'@Service\n@Slf4j\npublic class FeedGenerationService {\n\n    @Autowired private FeedCacheRepository feedCacheRepository;\n    @Autowired private PostRepository postRepository;\n    @Autowired private FollowRepository followRepository;\n    @Autowired private RankingService rankingService;\n    @Autowired private RedisTemplate<String, Object> redisTemplate;\n\n    private static final int CELEBRITY_THRESHOLD = 10_000;\n    private static final int FEED_SIZE = 50;\n    private static final Duration CACHE_TTL = Duration.ofMinutes(5);\n\n    /**\n     * Get personalized feed for user (Hybrid approach)\n     */\n    public FeedResponse getUserFeed(Long userId, String cursor, int limit) {\n        String cacheKey = "feed:user:" + userId;\n\n        // Try cache first\n        List<Post> cachedFeed = getCachedFeed(cacheKey);\n        if (cachedFeed != null && !cachedFeed.isEmpty()) {\n            return buildFeedResponse(cachedFeed, cursor, limit);\n        }\n\n        // Hybrid approach: merge push and pull feeds\n        List<Post> pushFeed = getPreComputedFeed(userId, FEED_SIZE);\n        List<Post> pullFeed = getCelebrityPosts(userId, FEED_SIZE);\n\n        // Merge and rank\n        List<Post> mergedFeed = mergeFeds(pushFeed, pullFeed);\n        List<Post> rankedFeed = rankingService.rankPosts(mergedFeed, userId);\n\n        // Cache result\n        cacheFeed(cacheKey, rankedFeed, CACHE_TTL);\n\n        return buildFeedResponse(rankedFeed, cursor, limit);\n    }\n\n    /**\n     * Get pre-computed feed from Cassandra (Push model)\n     */\n    private List<Post> getPreComputedFeed(Long userId, int limit) {\n        List<FeedEntry> feedEntries = feedCacheRepository\n            .findByUserIdOrderByScoreDesc(userId, PageRequest.of(0, limit));\n\n        List<Long> postIds = feedEntries.stream()\n            .map(FeedEntry::getPostId)\n            .collect(Collectors.toList());\n\n        return postRepository.findAllById(postIds);\n    }\n\n    /**\n     * Fetch recent posts from celebrities (Pull model)\n     */\n    private List<Post> getCelebrityPosts(Long userId, int limit) {\n        List<Long> celebrityIds = followRepository\n            .findCelebrityFollowees(userId, CELEBRITY_THRESHOLD);\n\n        if (celebrityIds.isEmpty()) {\n            return Collections.emptyList();\n        }\n\n        return postRepository\n            .findRecentPostsByUserIds(celebrityIds, limit);\n    }\n\n    /**\n     * Merge push and pull feeds\n     */\n    private List<Post> mergeFeds(List<Post> pushFeed, List<Post> pullFeed) {\n        Set<Long> seenIds = new HashSet<>();\n        List<Post> merged = new ArrayList<>();\n\n        for (Post post : pushFeed) {\n            if (seenIds.add(post.getId())) {\n                merged.add(post);\n            }\n        }\n\n        for (Post post : pullFeed) {\n            if (seenIds.add(post.getId())) {\n                merged.add(post);\n            }\n        }\n\n        return merged;\n    }\n\n    private List<Post> getCachedFeed(String cacheKey) {\n        return (List<Post>) redisTemplate.opsForValue().get(cacheKey);\n    }\n\n    private void cacheFeed(String cacheKey, List<Post> feed, Duration ttl) {\n        redisTemplate.opsForValue().set(cacheKey, feed, ttl);\n    }\n}\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"72-fanout-service-kafka-consumer",children:"7.2 Fanout Service (Kafka Consumer)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'@Service\n@Slf4j\npublic class FanoutService {\n\n    @Autowired private FollowRepository followRepository;\n    @Autowired private FeedCacheRepository feedCacheRepository;\n    @Autowired private RankingService rankingService;\n\n    private static final int BATCH_SIZE = 1000;\n    private static final int CELEBRITY_THRESHOLD = 10_000;\n\n    /**\n     * Listen to post creation events and fanout to followers\n     */\n    @KafkaListener(topics = "post-created", groupId = "fanout-service")\n    public void handlePostCreated(PostCreatedEvent event) {\n        Long authorId = event.getAuthorId();\n        Long postId = event.getPostId();\n\n        // Check if author is celebrity\n        long followerCount = followRepository.countFollowers(authorId);\n\n        if (followerCount > CELEBRITY_THRESHOLD) {\n            log.info("Skipping fanout for celebrity user {}", authorId);\n            return; // Use pull model for celebrities\n        }\n\n        // Fanout to all followers\n        log.info("Starting fanout for post {} from user {}", postId, authorId);\n        fanoutToFollowers(authorId, postId);\n    }\n\n    /**\n     * Distribute post to all followers\' feeds\n     */\n    private void fanoutToFollowers(Long authorId, Long postId) {\n        List<Long> followerIds = followRepository.findFollowerIds(authorId);\n\n        // Process in batches to avoid memory issues\n        Lists.partition(followerIds, BATCH_SIZE).forEach(batch -> {\n            List<FeedEntry> feedEntries = batch.stream()\n                .map(followerId -> createFeedEntry(followerId, postId))\n                .collect(Collectors.toList());\n\n            feedCacheRepository.saveAll(feedEntries);\n        });\n\n        log.info("Fanout completed for post {}. Reached {} followers",\n                 postId, followerIds.size());\n    }\n\n    private FeedEntry createFeedEntry(Long userId, Long postId) {\n        double score = rankingService.calculateInitialScore(postId);\n\n        return FeedEntry.builder()\n            .userId(userId)\n            .postId(postId)\n            .score(score)\n            .generatedAt(Instant.now())\n            .build();\n    }\n}\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"73-post-service",children:"7.3 Post Service"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'@RestController\n@RequestMapping("/api/v1/posts")\n@Slf4j\npublic class PostController {\n\n    @Autowired private PostService postService;\n    @Autowired private KafkaTemplate<String, Object> kafkaTemplate;\n\n    /**\n     * Create a new post\n     */\n    @PostMapping\n    public ResponseEntity<PostResponse> createPost(\n            @RequestAttribute("userId") Long userId,\n            @RequestBody CreatePostRequest request) {\n\n        Post post = postService.createPost(userId, request);\n\n        // Publish event for fanout\n        PostCreatedEvent event = PostCreatedEvent.builder()\n            .postId(post.getId())\n            .authorId(userId)\n            .content(post.getContent())\n            .createdAt(post.getCreatedAt())\n            .build();\n\n        kafkaTemplate.send("post-created", event);\n\n        return ResponseEntity.ok(PostResponse.from(post));\n    }\n\n    /**\n     * Get a specific post with interactions\n     */\n    @GetMapping("/{postId}")\n    public ResponseEntity<PostDetailResponse> getPost(\n            @PathVariable Long postId,\n            @RequestAttribute(value = "userId", required = false) Long userId) {\n\n        Post post = postService.getPost(postId);\n        PostStats stats = postService.getPostStats(postId);\n\n        UserInteraction userInteraction = null;\n        if (userId != null) {\n            userInteraction = postService.getUserInteraction(postId, userId);\n        }\n\n        return ResponseEntity.ok(PostDetailResponse.builder()\n            .post(post)\n            .stats(stats)\n            .userInteraction(userInteraction)\n            .build());\n    }\n\n    /**\n     * Delete a post\n     */\n    @DeleteMapping("/{postId}")\n    public ResponseEntity<Void> deletePost(\n            @PathVariable Long postId,\n            @RequestAttribute("userId") Long userId) {\n\n        postService.deletePost(postId, userId);\n\n        // Publish delete event\n        PostDeletedEvent event = new PostDeletedEvent(postId, userId);\n        kafkaTemplate.send("post-deleted", event);\n\n        return ResponseEntity.noContent().build();\n    }\n}\n\n@Service\n@Transactional\npublic class PostService {\n\n    @Autowired private PostRepository postRepository;\n    @Autowired private MediaService mediaService;\n    @Autowired private RedisTemplate<String, Object> redisTemplate;\n    @Autowired private ElasticsearchOperations elasticsearchOps;\n\n    public Post createPost(Long userId, CreatePostRequest request) {\n        // Upload media files if present\n        List<String> mediaUrls = new ArrayList<>();\n        if (request.getMediaFiles() != null) {\n            mediaUrls = mediaService.uploadMedia(request.getMediaFiles());\n        }\n\n        // Create post entity\n        Post post = Post.builder()\n            .userId(userId)\n            .content(request.getContent())\n            .mediaUrls(mediaUrls)\n            .postType(determinePostType(request))\n            .visibility(request.getVisibility())\n            .createdAt(Instant.now())\n            .build();\n\n        post = postRepository.save(post);\n\n        // Index in Elasticsearch for search\n        indexPostForSearch(post);\n\n        // Cache hot post\n        cachePost(post);\n\n        return post;\n    }\n\n    public Post getPost(Long postId) {\n        String cacheKey = "post:" + postId;\n\n        // Try cache\n        Post cached = (Post) redisTemplate.opsForValue().get(cacheKey);\n        if (cached != null) {\n            return cached;\n        }\n\n        // Fetch from DB\n        Post post = postRepository.findById(postId)\n            .orElseThrow(() -> new NotFoundException("Post not found"));\n\n        cachePost(post);\n        return post;\n    }\n\n    public PostStats getPostStats(Long postId) {\n        String cacheKey = "post:stats:" + postId;\n\n        PostStats cached = (PostStats) redisTemplate.opsForValue().get(cacheKey);\n        if (cached != null) {\n            return cached;\n        }\n\n        PostStats stats = postRepository.getPostStats(postId);\n        redisTemplate.opsForValue().set(cacheKey, stats, Duration.ofMinutes(5));\n\n        return stats;\n    }\n\n    private void cachePost(Post post) {\n        String cacheKey = "post:" + post.getId();\n        redisTemplate.opsForValue().set(cacheKey, post, Duration.ofHours(1));\n    }\n\n    private void indexPostForSearch(Post post) {\n        PostSearchDocument doc = PostSearchDocument.from(post);\n        elasticsearchOps.save(doc);\n    }\n}\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"74-interaction-service-likes-comments-shares",children:"7.4 Interaction Service (Likes, Comments, Shares)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'@RestController\n@RequestMapping("/api/v1/posts/{postId}")\n@Slf4j\npublic class InteractionController {\n\n    @Autowired private InteractionService interactionService;\n    @Autowired private NotificationService notificationService;\n\n    /**\n     * Like a post\n     */\n    @PostMapping("/like")\n    public ResponseEntity<Void> likePost(\n            @PathVariable Long postId,\n            @RequestAttribute("userId") Long userId) {\n\n        interactionService.likePost(postId, userId);\n\n        // Send notification to post author\n        notificationService.sendLikeNotification(postId, userId);\n\n        return ResponseEntity.ok().build();\n    }\n\n    /**\n     * Unlike a post\n     */\n    @DeleteMapping("/like")\n    public ResponseEntity<Void> unlikePost(\n            @PathVariable Long postId,\n            @RequestAttribute("userId") Long userId) {\n\n        interactionService.unlikePost(postId, userId);\n        return ResponseEntity.ok().build();\n    }\n\n    /**\n     * Comment on a post\n     */\n    @PostMapping("/comments")\n    public ResponseEntity<CommentResponse> addComment(\n            @PathVariable Long postId,\n            @RequestAttribute("userId") Long userId,\n            @RequestBody CreateCommentRequest request) {\n\n        Comment comment = interactionService.addComment(postId, userId, request);\n\n        // Send notification\n        notificationService.sendCommentNotification(postId, userId, comment.getId());\n\n        return ResponseEntity.ok(CommentResponse.from(comment));\n    }\n\n    /**\n     * Get comments for a post\n     */\n    @GetMapping("/comments")\n    public ResponseEntity<CommentsResponse> getComments(\n            @PathVariable Long postId,\n            @RequestParam(defaultValue = "top") String sort,\n            @RequestParam(defaultValue = "0") int page,\n            @RequestParam(defaultValue = "20") int limit) {\n\n        Page<Comment> comments = interactionService.getComments(postId, sort, page, limit);\n        return ResponseEntity.ok(CommentsResponse.from(comments));\n    }\n}\n\n@Service\npublic class InteractionService {\n\n    @Autowired private InteractionRepository interactionRepository;\n    @Autowired private CommentRepository commentRepository;\n    @Autowired private RedisTemplate<String, Object> redisTemplate;\n\n    /**\n     * Like a post (idempotent)\n     */\n    @Transactional\n    public void likePost(Long postId, Long userId) {\n        String cacheKey = "like:" + postId + ":" + userId;\n\n        // Check if already liked\n        if (Boolean.TRUE.equals(redisTemplate.hasKey(cacheKey))) {\n            return;\n        }\n\n        // Create interaction\n        Interaction interaction = Interaction.builder()\n            .postId(postId)\n            .userId(userId)\n            .type(InteractionType.LIKE)\n            .createdAt(Instant.now())\n            .build();\n\n        interactionRepository.save(interaction);\n\n        // Update cache\n        redisTemplate.opsForValue().set(cacheKey, true, Duration.ofDays(7));\n\n        // Increment like count\n        incrementLikeCount(postId);\n    }\n\n    @Transactional\n    public void unlikePost(Long postId, Long userId) {\n        String cacheKey = "like:" + postId + ":" + userId;\n\n        interactionRepository.deleteByPostIdAndUserIdAndType(\n            postId, userId, InteractionType.LIKE);\n\n        redisTemplate.delete(cacheKey);\n        decrementLikeCount(postId);\n    }\n\n    public Comment addComment(Long postId, Long userId, CreateCommentRequest request) {\n        Comment comment = Comment.builder()\n            .postId(postId)\n            .userId(userId)\n            .parentCommentId(request.getParentCommentId())\n            .content(request.getContent())\n            .createdAt(Instant.now())\n            .build();\n\n        comment = commentRepository.save(comment);\n\n        // Increment comment count\n        incrementCommentCount(postId);\n\n        return comment;\n    }\n\n    public Page<Comment> getComments(Long postId, String sort, int page, int limit) {\n        Pageable pageable = PageRequest.of(page, limit);\n\n        if ("top".equals(sort)) {\n            return commentRepository.findByPostIdOrderByLikesDesc(postId, pageable);\n        } else {\n            return commentRepository.findByPostIdOrderByCreatedAtDesc(postId, pageable);\n        }\n    }\n\n    private void incrementLikeCount(Long postId) {\n        String key = "post:stats:" + postId;\n        redisTemplate.opsForHash().increment(key, "likes", 1);\n    }\n\n    private void decrementLikeCount(Long postId) {\n        String key = "post:stats:" + postId;\n        redisTemplate.opsForHash().increment(key, "likes", -1);\n    }\n\n    private void incrementCommentCount(Long postId) {\n        String key = "post:stats:" + postId;\n        redisTemplate.opsForHash().increment(key, "comments", 1);\n    }\n}\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"75-ranking-service-ml-based-feed-ranking",children:"7.5 Ranking Service (ML-Based Feed Ranking)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'@Service\n@Slf4j\npublic class RankingService {\n\n    @Autowired private PostRepository postRepository;\n    @Autowired private InteractionRepository interactionRepository;\n    @Autowired private UserRepository userRepository;\n\n    /**\n     * Rank posts using multiple signals\n     */\n    public List<Post> rankPosts(List<Post> posts, Long userId) {\n        UserPreferences prefs = getUserPreferences(userId);\n\n        return posts.stream()\n            .map(post -> {\n                double score = calculateScore(post, userId, prefs);\n                post.setRankingScore(score);\n                return post;\n            })\n            .sorted(Comparator.comparingDouble(Post::getRankingScore).reversed())\n            .collect(Collectors.toList());\n    }\n\n    /**\n     * Calculate ranking score using multiple factors\n     */\n    private double calculateScore(Post post, Long userId, UserPreferences prefs) {\n        double recencyScore = calculateRecencyScore(post);\n        double engagementScore = calculateEngagementScore(post);\n        double affinityScore = calculateAffinityScore(post, userId);\n        double contentScore = calculateContentScore(post, prefs);\n\n        // Weighted combination\n        return (0.3 * recencyScore) +\n               (0.35 * engagementScore) +\n               (0.25 * affinityScore) +\n               (0.1 * contentScore);\n    }\n\n    /**\n     * Time decay: newer posts ranked higher\n     */\n    private double calculateRecencyScore(Post post) {\n        long ageInMinutes = Duration.between(post.getCreatedAt(), Instant.now()).toMinutes();\n        return 1.0 / (1.0 + Math.log(ageInMinutes + 2));\n    }\n\n    /**\n     * Engagement: likes, comments, shares\n     */\n    private double calculateEngagementScore(Post post) {\n        PostStats stats = post.getStats();\n        if (stats == null) return 0.0;\n\n        double likes = stats.getLikes() * 1.0;\n        double comments = stats.getComments() * 2.0; // Comments weighted higher\n        double shares = stats.getShares() * 3.0; // Shares weighted highest\n\n        double totalEngagement = likes + comments + shares;\n        return Math.log(totalEngagement + 1);\n    }\n\n    /**\n     * User affinity: how much user interacts with author\n     */\n    private double calculateAffinityScore(Post post, Long userId) {\n        Long authorId = post.getUserId();\n\n        // Count past interactions with this author\n        long interactionCount = interactionRepository\n            .countUserInteractionsWithAuthor(userId, authorId);\n\n        return Math.log(interactionCount + 1) / 10.0;\n    }\n\n    /**\n     * Content relevance: match user interests\n     */\n    private double calculateContentScore(Post post, UserPreferences prefs) {\n        // Simple keyword matching (in production, use ML model)\n        Set<String> postKeywords = extractKeywords(post.getContent());\n        Set<String> userInterests = prefs.getInterests();\n\n        long matchCount = postKeywords.stream()\n            .filter(userInterests::contains)\n            .count();\n\n        return matchCount > 0 ? Math.log(matchCount + 1) : 0.0;\n    }\n\n    /**\n     * Initial score for newly created posts\n     */\n    public double calculateInitialScore(Long postId) {\n        Post post = postRepository.findById(postId).orElseThrow();\n        return calculateRecencyScore(post);\n    }\n\n    private UserPreferences getUserPreferences(Long userId) {\n        // Simplified - in production, fetch from ML service\n        return UserPreferences.builder()\n            .userId(userId)\n            .interests(Set.of("technology", "sports", "travel"))\n            .build();\n    }\n\n    private Set<String> extractKeywords(String content) {\n        // Simplified - in production, use NLP\n        return Arrays.stream(content.toLowerCase().split("\\\\s+"))\n            .filter(word -> word.length() > 3)\n            .collect(Collectors.toSet());\n    }\n}\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"76-social-graph-service",children:"7.6 Social Graph Service"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'@RestController\n@RequestMapping("/api/v1/users/{userId}")\n@Slf4j\npublic class SocialGraphController {\n\n    @Autowired private SocialGraphService socialGraphService;\n    @Autowired private NotificationService notificationService;\n\n    /**\n     * Follow a user\n     */\n    @PostMapping("/follow")\n    public ResponseEntity<Void> followUser(\n            @PathVariable Long userId,\n            @RequestAttribute("currentUserId") Long currentUserId) {\n\n        socialGraphService.follow(currentUserId, userId);\n        notificationService.sendFollowNotification(userId, currentUserId);\n\n        return ResponseEntity.ok().build();\n    }\n\n    /**\n     * Unfollow a user\n     */\n    @DeleteMapping("/unfollow")\n    public ResponseEntity<Void> unfollowUser(\n            @PathVariable Long userId,\n            @RequestAttribute("currentUserId") Long currentUserId) {\n\n        socialGraphService.unfollow(currentUserId, userId);\n        return ResponseEntity.ok().build();\n    }\n\n    /**\n     * Get followers\n     */\n    @GetMapping("/followers")\n    public ResponseEntity<FollowersResponse> getFollowers(\n            @PathVariable Long userId,\n            @RequestParam(defaultValue = "0") int page,\n            @RequestParam(defaultValue = "50") int limit) {\n\n        Page<User> followers = socialGraphService.getFollowers(userId, page, limit);\n        return ResponseEntity.ok(FollowersResponse.from(followers));\n    }\n\n    /**\n     * Get following\n     */\n    @GetMapping("/following")\n    public ResponseEntity<FollowingResponse> getFollowing(\n            @PathVariable Long userId,\n            @RequestParam(defaultValue = "0") int page,\n            @RequestParam(defaultValue = "50") int limit) {\n\n        Page<User> following = socialGraphService.getFollowing(userId, page, limit);\n        return ResponseEntity.ok(FollowingResponse.from(following));\n    }\n}\n\n@Service\npublic class SocialGraphService {\n\n    @Autowired private FollowRepository followRepository;\n    @Autowired private RedisTemplate<String, Object> redisTemplate;\n    @Autowired private KafkaTemplate<String, Object> kafkaTemplate;\n\n    /**\n     * Follow a user (idempotent)\n     */\n    @Transactional\n    public void follow(Long followerId, Long followeeId) {\n        if (followerId.equals(followeeId)) {\n            throw new BadRequestException("Cannot follow yourself");\n        }\n\n        String cacheKey = "follow:" + followerId + ":" + followeeId;\n\n        // Check if already following\n        if (Boolean.TRUE.equals(redisTemplate.hasKey(cacheKey))) {\n            return;\n        }\n\n        Follow follow = Follow.builder()\n            .followerId(followerId)\n            .followeeId(followeeId)\n            .createdAt(Instant.now())\n            .build();\n\n        followRepository.save(follow);\n\n        // Update cache\n        redisTemplate.opsForValue().set(cacheKey, true, Duration.ofDays(30));\n\n        // Publish event\n        FollowEvent event = new FollowEvent(followerId, followeeId);\n        kafkaTemplate.send("user-followed", event);\n\n        // Invalidate follower/following count cache\n        invalidateCountCache(followerId, followeeId);\n    }\n\n    @Transactional\n    public void unfollow(Long followerId, Long followeeId) {\n        String cacheKey = "follow:" + followerId + ":" + followeeId;\n\n        followRepository.deleteByFollowerIdAndFolloweeId(followerId, followeeId);\n\n        redisTemplate.delete(cacheKey);\n\n        // Publish event\n        UnfollowEvent event = new UnfollowEvent(followerId, followeeId);\n        kafkaTemplate.send("user-unfollowed", event);\n\n        invalidateCountCache(followerId, followeeId);\n    }\n\n    public Page<User> getFollowers(Long userId, int page, int limit) {\n        String cacheKey = "followers:" + userId + ":" + page;\n\n        // Try cache\n        Page<User> cached = (Page<User>) redisTemplate.opsForValue().get(cacheKey);\n        if (cached != null) {\n            return cached;\n        }\n\n        // Fetch from DB\n        Pageable pageable = PageRequest.of(page, limit);\n        Page<User> followers = followRepository.findFollowers(userId, pageable);\n\n        // Cache for 10 minutes\n        redisTemplate.opsForValue().set(cacheKey, followers, Duration.ofMinutes(10));\n\n        return followers;\n    }\n\n    public Page<User> getFollowing(Long userId, int page, int limit) {\n        String cacheKey = "following:" + userId + ":" + page;\n\n        Page<User> cached = (Page<User>) redisTemplate.opsForValue().get(cacheKey);\n        if (cached != null) {\n            return cached;\n        }\n\n        Pageable pageable = PageRequest.of(page, limit);\n        Page<User> following = followRepository.findFollowing(userId, pageable);\n\n        redisTemplate.opsForValue().set(cacheKey, following, Duration.ofMinutes(10));\n\n        return following;\n    }\n\n    private void invalidateCountCache(Long followerId, Long followeeId) {\n        redisTemplate.delete("follower:count:" + followeeId);\n        redisTemplate.delete("following:count:" + followerId);\n    }\n}\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"77-notification-service",children:"7.7 Notification Service"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'@Service\n@Slf4j\npublic class NotificationService {\n\n    @Autowired private NotificationRepository notificationRepository;\n    @Autowired private RedisTemplate<String, Object> redisTemplate;\n    @Autowired private WebSocketHandler webSocketHandler;\n    @Autowired private FCMService fcmService; // Firebase Cloud Messaging\n\n    /**\n     * Send like notification\n     */\n    public void sendLikeNotification(Long postId, Long actorId) {\n        Post post = getPost(postId);\n        Long recipientId = post.getUserId();\n\n        // Don\'t notify if user liked their own post\n        if (recipientId.equals(actorId)) {\n            return;\n        }\n\n        Notification notification = Notification.builder()\n            .userId(recipientId)\n            .actorId(actorId)\n            .type(NotificationType.LIKE)\n            .postId(postId)\n            .read(false)\n            .createdAt(Instant.now())\n            .build();\n\n        notificationRepository.save(notification);\n\n        // Send real-time notification via WebSocket\n        sendRealtimeNotification(recipientId, notification);\n\n        // Send push notification if user is offline\n        if (!isUserOnline(recipientId)) {\n            sendPushNotification(recipientId, notification);\n        }\n    }\n\n    /**\n     * Send comment notification\n     */\n    public void sendCommentNotification(Long postId, Long actorId, Long commentId) {\n        Post post = getPost(postId);\n        Long recipientId = post.getUserId();\n\n        if (recipientId.equals(actorId)) {\n            return;\n        }\n\n        Notification notification = Notification.builder()\n            .userId(recipientId)\n            .actorId(actorId)\n            .type(NotificationType.COMMENT)\n            .postId(postId)\n            .commentId(commentId)\n            .read(false)\n            .createdAt(Instant.now())\n            .build();\n\n        notificationRepository.save(notification);\n        sendRealtimeNotification(recipientId, notification);\n\n        if (!isUserOnline(recipientId)) {\n            sendPushNotification(recipientId, notification);\n        }\n    }\n\n    /**\n     * Send follow notification\n     */\n    public void sendFollowNotification(Long followeeId, Long followerId) {\n        Notification notification = Notification.builder()\n            .userId(followeeId)\n            .actorId(followerId)\n            .type(NotificationType.FOLLOW)\n            .read(false)\n            .createdAt(Instant.now())\n            .build();\n\n        notificationRepository.save(notification);\n        sendRealtimeNotification(followeeId, notification);\n\n        if (!isUserOnline(followeeId)) {\n            sendPushNotification(followeeId, notification);\n        }\n    }\n\n    /**\n     * Send real-time notification via WebSocket\n     */\n    private void sendRealtimeNotification(Long userId, Notification notification) {\n        NotificationMessage message = NotificationMessage.builder()\n            .type("NOTIFICATION")\n            .data(notification)\n            .build();\n\n        webSocketHandler.sendToUser(userId, message);\n    }\n\n    /**\n     * Send push notification to mobile devices\n     */\n    private void sendPushNotification(Long userId, Notification notification) {\n        String message = buildNotificationMessage(notification);\n        fcmService.sendToUser(userId, message);\n    }\n\n    private boolean isUserOnline(Long userId) {\n        String key = "user:online:" + userId;\n        return Boolean.TRUE.equals(redisTemplate.hasKey(key));\n    }\n\n    private String buildNotificationMessage(Notification notification) {\n        User actor = getUser(notification.getActorId());\n\n        switch (notification.getType()) {\n            case LIKE:\n                return actor.getUsername() + " liked your post";\n            case COMMENT:\n                return actor.getUsername() + " commented on your post";\n            case FOLLOW:\n                return actor.getUsername() + " started following you";\n            default:\n                return "New notification";\n        }\n    }\n\n    private Post getPost(Long postId) {\n        // Implementation\n        return null;\n    }\n\n    private User getUser(Long userId) {\n        // Implementation\n        return null;\n    }\n}\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"78-websocket-handler-real-time-updates",children:"7.8 WebSocket Handler (Real-time Updates)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'@Component\n@Slf4j\npublic class WebSocketHandler extends TextWebSocketHandler {\n\n    @Autowired private RedisTemplate<String, Object> redisTemplate;\n\n    // Store active connections: userId -> WebSocketSession\n    private final ConcurrentHashMap<Long, WebSocketSession> activeSessions =\n        new ConcurrentHashMap<>();\n\n    @Override\n    public void afterConnectionEstablished(WebSocketSession session) throws Exception {\n        Long userId = getUserIdFromSession(session);\n\n        if (userId != null) {\n            activeSessions.put(userId, session);\n            markUserOnline(userId);\n            log.info("WebSocket connected for user {}", userId);\n        }\n    }\n\n    @Override\n    public void afterConnectionClosed(WebSocketSession session, CloseStatus status)\n            throws Exception {\n        Long userId = getUserIdFromSession(session);\n\n        if (userId != null) {\n            activeSessions.remove(userId);\n            markUserOffline(userId);\n            log.info("WebSocket disconnected for user {}", userId);\n        }\n    }\n\n    @Override\n    protected void handleTextMessage(WebSocketSession session, TextMessage message)\n            throws Exception {\n        // Handle incoming messages if needed (e.g., typing indicators)\n        String payload = message.getPayload();\n        log.debug("Received message: {}", payload);\n    }\n\n    /**\n     * Send message to specific user\n     */\n    public void sendToUser(Long userId, Object message) {\n        WebSocketSession session = activeSessions.get(userId);\n\n        if (session != null && session.isOpen()) {\n            try {\n                String json = new ObjectMapper().writeValueAsString(message);\n                session.sendMessage(new TextMessage(json));\n            } catch (Exception e) {\n                log.error("Error sending WebSocket message to user {}", userId, e);\n            }\n        }\n    }\n\n    /**\n     * Broadcast to multiple users\n     */\n    public void broadcast(List<Long> userIds, Object message) {\n        userIds.forEach(userId -> sendToUser(userId, message));\n    }\n\n    private Long getUserIdFromSession(WebSocketSession session) {\n        // Extract userId from session attributes or JWT token\n        return (Long) session.getAttributes().get("userId");\n    }\n\n    private void markUserOnline(Long userId) {\n        String key = "user:online:" + userId;\n        redisTemplate.opsForValue().set(key, true, Duration.ofMinutes(5));\n    }\n\n    private void markUserOffline(Long userId) {\n        String key = "user:online:" + userId;\n        redisTemplate.delete(key);\n    }\n}\n\n@Configuration\n@EnableWebSocket\npublic class WebSocketConfig implements WebSocketConfigurer {\n\n    @Autowired private WebSocketHandler webSocketHandler;\n\n    @Override\n    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {\n        registry.addHandler(webSocketHandler, "/ws/feed")\n            .setAllowedOrigins("*")\n            .addInterceptors(new JwtHandshakeInterceptor());\n    }\n}\n\n/**\n * Intercept WebSocket handshake to authenticate user\n */\npublic class JwtHandshakeInterceptor implements HandshakeInterceptor {\n\n    @Override\n    public boolean beforeHandshake(ServerHttpRequest request,\n                                   ServerHttpResponse response,\n                                   WebSocketHandler wsHandler,\n                                   Map<String, Object> attributes) {\n\n        // Extract JWT token from query params or headers\n        String token = extractToken(request);\n\n        if (token != null) {\n            Long userId = validateTokenAndGetUserId(token);\n            if (userId != null) {\n                attributes.put("userId", userId);\n                return true;\n            }\n        }\n\n        return false; // Reject connection\n    }\n\n    @Override\n    public void afterHandshake(ServerHttpRequest request,\n                              ServerHttpResponse response,\n                              WebSocketHandler wsHandler,\n                              Exception exception) {\n        // No-op\n    }\n\n    private String extractToken(ServerHttpRequest request) {\n        // Extract from query param: ws://host/ws/feed?token=xxx\n        String query = request.getURI().getQuery();\n        if (query != null && query.startsWith("token=")) {\n            return query.substring(6);\n        }\n        return null;\n    }\n\n    private Long validateTokenAndGetUserId(String token) {\n        // Validate JWT and extract userId\n        return null; // Implementation\n    }\n}\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"79-database-schema-design",children:"7.9 Database Schema Design"}),"\n",(0,i.jsx)(n.h4,{id:"postgresql-users-posts-comments",children:"PostgreSQL (Users, Posts, Comments)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Users table\nCREATE TABLE users (\n    user_id BIGSERIAL PRIMARY KEY,\n    username VARCHAR(50) UNIQUE NOT NULL,\n    email VARCHAR(255) UNIQUE NOT NULL,\n    password_hash VARCHAR(255) NOT NULL,\n    display_name VARCHAR(100),\n    profile_pic_url TEXT,\n    bio TEXT,\n    verified BOOLEAN DEFAULT FALSE,\n    created_at TIMESTAMP NOT NULL DEFAULT NOW(),\n    updated_at TIMESTAMP NOT NULL DEFAULT NOW()\n);\n\nCREATE INDEX idx_users_username ON users(username);\nCREATE INDEX idx_users_email ON users(email);\n\n-- Posts table\nCREATE TABLE posts (\n    post_id BIGSERIAL PRIMARY KEY,\n    user_id BIGINT NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,\n    content TEXT NOT NULL,\n    media_urls TEXT[], -- Array of media URLs\n    post_type VARCHAR(20) NOT NULL, -- TEXT, IMAGE, VIDEO, LINK\n    visibility VARCHAR(20) DEFAULT 'PUBLIC', -- PUBLIC, FRIENDS, PRIVATE\n    created_at TIMESTAMP NOT NULL DEFAULT NOW(),\n    edited_at TIMESTAMP,\n    deleted_at TIMESTAMP -- Soft delete\n);\n\nCREATE INDEX idx_posts_user_id ON posts(user_id);\nCREATE INDEX idx_posts_created_at ON posts(created_at DESC);\nCREATE INDEX idx_posts_user_created ON posts(user_id, created_at DESC);\n\n-- Comments table\nCREATE TABLE comments (\n    comment_id BIGSERIAL PRIMARY KEY,\n    post_id BIGINT NOT NULL REFERENCES posts(post_id) ON DELETE CASCADE,\n    user_id BIGINT NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,\n    parent_comment_id BIGINT REFERENCES comments(comment_id) ON DELETE CASCADE,\n    content TEXT NOT NULL,\n    likes_count INT DEFAULT 0,\n    created_at TIMESTAMP NOT NULL DEFAULT NOW(),\n    deleted_at TIMESTAMP\n);\n\nCREATE INDEX idx_comments_post_id ON comments(post_id, created_at DESC);\nCREATE INDEX idx_comments_parent ON comments(parent_comment_id);\n\n-- Interactions table (likes, saves, shares)\nCREATE TABLE interactions (\n    interaction_id BIGSERIAL PRIMARY KEY,\n    post_id BIGINT NOT NULL REFERENCES posts(post_id) ON DELETE CASCADE,\n    user_id BIGINT NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,\n    interaction_type VARCHAR(20) NOT NULL, -- LIKE, SAVE, SHARE\n    created_at TIMESTAMP NOT NULL DEFAULT NOW(),\n    UNIQUE(post_id, user_id, interaction_type)\n);\n\nCREATE INDEX idx_interactions_post ON interactions(post_id);\nCREATE INDEX idx_interactions_user ON interactions(user_id, created_at DESC);\n\n-- Follows table\nCREATE TABLE follows (\n    follower_id BIGINT NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,\n    followee_id BIGINT NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,\n    created_at TIMESTAMP NOT NULL DEFAULT NOW(),\n    PRIMARY KEY (follower_id, followee_id)\n);\n\nCREATE INDEX idx_follows_follower ON follows(follower_id);\nCREATE INDEX idx_follows_followee ON follows(followee_id);\n\n-- Notifications table\nCREATE TABLE notifications (\n    notification_id BIGSERIAL PRIMARY KEY,\n    user_id BIGINT NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,\n    actor_id BIGINT NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,\n    notification_type VARCHAR(20) NOT NULL, -- LIKE, COMMENT, FOLLOW, SHARE\n    post_id BIGINT REFERENCES posts(post_id) ON DELETE CASCADE,\n    comment_id BIGINT REFERENCES comments(comment_id) ON DELETE CASCADE,\n    read BOOLEAN DEFAULT FALSE,\n    created_at TIMESTAMP NOT NULL DEFAULT NOW()\n);\n\nCREATE INDEX idx_notifications_user ON notifications(user_id, created_at DESC);\nCREATE INDEX idx_notifications_unread ON notifications(user_id, read, created_at DESC);\n"})}),"\n",(0,i.jsx)(n.h4,{id:"cassandra-pre-computed-feeds-time-series-data",children:"Cassandra (Pre-computed Feeds, Time-series Data)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cql",children:"-- Pre-computed feed entries (fanout-on-write)\nCREATE TABLE feed_entries (\n    user_id BIGINT,\n    post_id BIGINT,\n    score DOUBLE,\n    generated_at TIMESTAMP,\n    PRIMARY KEY ((user_id), score, post_id)\n) WITH CLUSTERING ORDER BY (score DESC, post_id DESC)\nAND compaction = {'class': 'TimeWindowCompactionStrategy', 'compaction_window_size': 1};\n\n-- User activity log (analytics)\nCREATE TABLE user_activity (\n    user_id BIGINT,\n    activity_date DATE,\n    activity_id TIMEUUID,\n    activity_type TEXT, -- VIEW_POST, LIKE, COMMENT, SHARE\n    post_id BIGINT,\n    metadata TEXT, -- JSON blob\n    PRIMARY KEY ((user_id, activity_date), activity_id)\n) WITH CLUSTERING ORDER BY (activity_id DESC);\n\n-- Post engagement metrics (time-series)\nCREATE TABLE post_engagement (\n    post_id BIGINT,\n    time_bucket TIMESTAMP, -- Hourly buckets\n    likes_count COUNTER,\n    comments_count COUNTER,\n    shares_count COUNTER,\n    views_count COUNTER,\n    PRIMARY KEY ((post_id), time_bucket)\n) WITH CLUSTERING ORDER BY (time_bucket DESC);\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"710-caching-strategy",children:"7.10 Caching Strategy"}),"\n",(0,i.jsx)(n.h4,{id:"multi-layer-cache-architecture",children:"Multi-Layer Cache Architecture"}),"\n",(0,i.jsx)(n.mermaid,{value:"graph TD\n    Client[Client Request] --\x3e L1[L1: CDN Cache<br/>Static Assets, Media]\n    L1 --\x3e L2[L2: Redis Cache<br/>Feed, Posts, Users]\n    L2 --\x3e L3[L3: Application Cache<br/>Caffeine, Guava]\n    L3 --\x3e DB[(Database<br/>PostgreSQL, Cassandra)]\n\n    style L1 fill:#ffe1e1\n    style L2 fill:#e1ffe1\n    style L3 fill:#e1e1ff"}),"\n",(0,i.jsx)(n.h4,{id:"redis-caching-implementation",children:"Redis Caching Implementation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'@Configuration\n@EnableCaching\npublic class CacheConfig {\n\n    @Bean\n    public RedisCacheManager cacheManager(RedisConnectionFactory factory) {\n        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()\n            .entryTtl(Duration.ofMinutes(10))\n            .serializeKeysWith(RedisSerializationContext.SerializationPair\n                .fromSerializer(new StringRedisSerializer()))\n            .serializeValuesWith(RedisSerializationContext.SerializationPair\n                .fromSerializer(new GenericJackson2JsonRedisSerializer()));\n\n        Map<String, RedisCacheConfiguration> cacheConfigurations = new HashMap<>();\n\n        // Different TTL for different cache types\n        cacheConfigurations.put("feeds", config.entryTtl(Duration.ofMinutes(5)));\n        cacheConfigurations.put("posts", config.entryTtl(Duration.ofHours(1)));\n        cacheConfigurations.put("users", config.entryTtl(Duration.ofHours(24)));\n        cacheConfigurations.put("postStats", config.entryTtl(Duration.ofMinutes(5)));\n\n        return RedisCacheManager.builder(factory)\n            .cacheDefaults(config)\n            .withInitialCacheConfigurations(cacheConfigurations)\n            .build();\n    }\n}\n\n@Service\npublic class CachingService {\n\n    @Autowired private RedisTemplate<String, Object> redisTemplate;\n\n    private static final Map<String, Duration> CACHE_TTL = Map.of(\n        "feed", Duration.ofMinutes(5),\n        "post", Duration.ofHours(1),\n        "user", Duration.ofHours(24),\n        "postStats", Duration.ofMinutes(5),\n        "followers", Duration.ofMinutes(10),\n        "following", Duration.ofMinutes(10)\n    );\n\n    /**\n     * Cache-aside pattern for posts\n     */\n    @Cacheable(value = "posts", key = "#postId")\n    public Post getPost(Long postId) {\n        // This will be called only on cache miss\n        return postRepository.findById(postId).orElseThrow();\n    }\n\n    /**\n     * Invalidate cache on update\n     */\n    @CacheEvict(value = "posts", key = "#post.id")\n    public Post updatePost(Post post) {\n        return postRepository.save(post);\n    }\n\n    /**\n     * Write-through cache for feed\n     */\n    public void cacheFeed(Long userId, List<Post> feed) {\n        String key = "feed:user:" + userId;\n        redisTemplate.opsForValue().set(key, feed, CACHE_TTL.get("feed"));\n    }\n\n    /**\n     * Cache warming for popular content\n     */\n    @Scheduled(fixedRate = 300000) // Every 5 minutes\n    public void warmPopularPostsCache() {\n        List<Long> trendingPostIds = getTrendingPostIds();\n\n        trendingPostIds.forEach(postId -> {\n            String key = "post:" + postId;\n            if (!redisTemplate.hasKey(key)) {\n                Post post = postRepository.findById(postId).orElse(null);\n                if (post != null) {\n                    redisTemplate.opsForValue().set(key, post, CACHE_TTL.get("post"));\n                }\n            }\n        });\n    }\n\n    private List<Long> getTrendingPostIds() {\n        // Fetch from analytics service\n        return Collections.emptyList();\n    }\n}\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"711-media-processing-service",children:"7.11 Media Processing Service"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'@Service\n@Slf4j\npublic class MediaService {\n\n    @Autowired private S3Client s3Client;\n    @Autowired private KafkaTemplate<String, Object> kafkaTemplate;\n\n    private static final String BUCKET_NAME = "newsfeed-media";\n    private static final long MAX_FILE_SIZE = 10 * 1024 * 1024; // 10 MB\n\n    /**\n     * Upload and process media files\n     */\n    public List<String> uploadMedia(List<MultipartFile> files) {\n        return files.stream()\n            .map(this::uploadSingleFile)\n            .collect(Collectors.toList());\n    }\n\n    private String uploadSingleFile(MultipartFile file) {\n        // Validate file\n        validateFile(file);\n\n        // Generate unique filename\n        String filename = generateFilename(file.getOriginalFilename());\n        String key = "originals/" + filename;\n\n        try {\n            // Upload to S3\n            PutObjectRequest request = PutObjectRequest.builder()\n                .bucket(BUCKET_NAME)\n                .key(key)\n                .contentType(file.getContentType())\n                .build();\n\n            s3Client.putObject(request, RequestBody.fromBytes(file.getBytes()));\n\n            // Publish event for async processing (thumbnails, compression)\n            MediaUploadedEvent event = new MediaUploadedEvent(key, file.getContentType());\n            kafkaTemplate.send("media-uploaded", event);\n\n            // Return CDN URL\n            return "https://cdn.newsfeed.com/" + key;\n\n        } catch (Exception e) {\n            log.error("Error uploading file", e);\n            throw new RuntimeException("File upload failed");\n        }\n    }\n\n    private void validateFile(MultipartFile file) {\n        if (file.isEmpty()) {\n            throw new BadRequestException("File is empty");\n        }\n\n        if (file.getSize() > MAX_FILE_SIZE) {\n            throw new BadRequestException("File too large");\n        }\n\n        String contentType = file.getContentType();\n        if (!isAllowedContentType(contentType)) {\n            throw new BadRequestException("Invalid file type");\n        }\n    }\n\n    private boolean isAllowedContentType(String contentType) {\n        return contentType != null && (\n            contentType.startsWith("image/") ||\n            contentType.startsWith("video/")\n        );\n    }\n\n    private String generateFilename(String originalFilename) {\n        String extension = originalFilename.substring(originalFilename.lastIndexOf("."));\n        return UUID.randomUUID().toString() + extension;\n    }\n}\n\n/**\n * Async media processor - listens to media upload events\n */\n@Service\n@Slf4j\npublic class MediaProcessorService {\n\n    @Autowired private S3Client s3Client;\n\n    @KafkaListener(topics = "media-uploaded", groupId = "media-processor")\n    public void processMedia(MediaUploadedEvent event) {\n        String key = event.getKey();\n        String contentType = event.getContentType();\n\n        if (contentType.startsWith("image/")) {\n            processImage(key);\n        } else if (contentType.startsWith("video/")) {\n            processVideo(key);\n        }\n    }\n\n    private void processImage(String key) {\n        try {\n            // Download original\n            byte[] imageData = downloadFromS3(key);\n\n            // Generate thumbnails\n            byte[] thumbnail = resizeImage(imageData, 300, 300);\n            byte[] medium = resizeImage(imageData, 800, 600);\n\n            // Upload processed versions\n            uploadToS3("thumbnails/" + key, thumbnail);\n            uploadToS3("medium/" + key, medium);\n\n            log.info("Image processing completed for {}", key);\n\n        } catch (Exception e) {\n            log.error("Error processing image {}", key, e);\n        }\n    }\n\n    private void processVideo(String key) {\n        // Video transcoding logic (would use AWS MediaConvert or similar)\n        log.info("Video processing queued for {}", key);\n    }\n\n    private byte[] resizeImage(byte[] imageData, int width, int height) {\n        // Use ImageMagick or Thumbnailator library\n        return imageData; // Simplified\n    }\n\n    private byte[] downloadFromS3(String key) {\n        // Download from S3\n        return new byte[0]; // Simplified\n    }\n\n    private void uploadToS3(String key, byte[] data) {\n        // Upload to S3\n    }\n}\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"712-search-service-elasticsearch",children:"7.12 Search Service (Elasticsearch)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'@Service\n@Slf4j\npublic class SearchService {\n\n    @Autowired private ElasticsearchOperations elasticsearchOps;\n    @Autowired private PostRepository postRepository;\n\n    /**\n     * Search posts by content, hashtags, mentions\n     */\n    public SearchResponse searchPosts(String query, int page, int size) {\n        NativeSearchQuery searchQuery = new NativeSearchQueryBuilder()\n            .withQuery(QueryBuilders.multiMatchQuery(query)\n                .field("content", 2.0f)  // Boost content\n                .field("author.username", 1.5f)\n                .field("hashtags", 1.0f)\n                .type(MultiMatchQueryBuilder.Type.BEST_FIELDS)\n                .fuzziness(Fuzziness.AUTO))\n            .withPageable(PageRequest.of(page, size))\n            .withHighlightFields(\n                new HighlightBuilder.Field("content")\n                    .preTags("<mark>")\n                    .postTags("</mark>"))\n            .build();\n\n        SearchHits<PostSearchDocument> hits = elasticsearchOps.search(searchQuery,\n                                                                       PostSearchDocument.class);\n\n        List<PostSearchResult> results = hits.stream()\n            .map(this::convertToResult)\n            .collect(Collectors.toList());\n\n        return SearchResponse.builder()\n            .results(results)\n            .totalHits(hits.getTotalHits())\n            .build();\n    }\n\n    /**\n     * Search by hashtag\n     */\n    public List<Post> searchByHashtag(String hashtag, int limit) {\n        NativeSearchQuery query = new NativeSearchQueryBuilder()\n            .withQuery(QueryBuilders.termQuery("hashtags", hashtag.toLowerCase()))\n            .withSort(SortBuilders.fieldSort("createdAt").order(SortOrder.DESC))\n            .withPageable(PageRequest.of(0, limit))\n            .build();\n\n        SearchHits<PostSearchDocument> hits = elasticsearchOps.search(query,\n                                                                       PostSearchDocument.class);\n\n        List<Long> postIds = hits.stream()\n            .map(hit -> hit.getContent().getPostId())\n            .collect(Collectors.toList());\n\n        return postRepository.findAllById(postIds);\n    }\n\n    /**\n     * Autocomplete suggestions\n     */\n    public List<String> autocomplete(String prefix) {\n        NativeSearchQuery query = new NativeSearchQueryBuilder()\n            .withQuery(QueryBuilders.prefixQuery("content", prefix.toLowerCase()))\n            .withFields("content")\n            .withPageable(PageRequest.of(0, 10))\n            .build();\n\n        SearchHits<PostSearchDocument> hits = elasticsearchOps.search(query,\n                                                                       PostSearchDocument.class);\n\n        return hits.stream()\n            .map(hit -> extractSuggestion(hit.getContent().getContent(), prefix))\n            .distinct()\n            .limit(10)\n            .collect(Collectors.toList());\n    }\n\n    private PostSearchResult convertToResult(SearchHit<PostSearchDocument> hit) {\n        PostSearchDocument doc = hit.getContent();\n\n        // Extract highlights\n        Map<String, List<String>> highlights = hit.getHighlightFields();\n        String highlightedContent = highlights.getOrDefault("content",\n                                                            Collections.emptyList())\n            .stream()\n            .findFirst()\n            .orElse(doc.getContent());\n\n        return PostSearchResult.builder()\n            .postId(doc.getPostId())\n            .content(highlightedContent)\n            .authorUsername(doc.getAuthorUsername())\n            .createdAt(doc.getCreatedAt())\n            .score(hit.getScore())\n            .build();\n    }\n\n    private String extractSuggestion(String content, String prefix) {\n        // Extract the word containing the prefix\n        String[] words = content.split("\\\\s+");\n        for (String word : words) {\n            if (word.toLowerCase().startsWith(prefix.toLowerCase())) {\n                return word;\n            }\n        }\n        return prefix;\n    }\n}\n\n/**\n * Elasticsearch document for posts\n */\n@Document(indexName = "posts")\n@Data\n@Builder\npublic class PostSearchDocument {\n\n    @Id\n    private String id;\n\n    @Field(type = FieldType.Long)\n    private Long postId;\n\n    @Field(type = FieldType.Text, analyzer = "standard")\n    private String content;\n\n    @Field(type = FieldType.Long)\n    private Long authorId;\n\n    @Field(type = FieldType.Keyword)\n    private String authorUsername;\n\n    @Field(type = FieldType.Keyword)\n    private List<String> hashtags;\n\n    @Field(type = FieldType.Keyword)\n    private List<String> mentions;\n\n    @Field(type = FieldType.Date)\n    private Instant createdAt;\n\n    @Field(type = FieldType.Integer)\n    private Integer popularity; // Based on engagement\n\n    public static PostSearchDocument from(Post post) {\n        return PostSearchDocument.builder()\n            .id(String.valueOf(post.getId()))\n            .postId(post.getId())\n            .content(post.getContent())\n            .authorId(post.getUserId())\n            .authorUsername(post.getAuthor().getUsername())\n            .hashtags(extractHashtags(post.getContent()))\n            .mentions(extractMentions(post.getContent()))\n            .createdAt(post.getCreatedAt())\n            .popularity(calculatePopularity(post))\n            .build();\n    }\n\n    private static List<String> extractHashtags(String content) {\n        Pattern pattern = Pattern.compile("#(\\\\w+)");\n        Matcher matcher = pattern.matcher(content);\n\n        List<String> hashtags = new ArrayList<>();\n        while (matcher.find()) {\n            hashtags.add(matcher.group(1).toLowerCase());\n        }\n        return hashtags;\n    }\n\n    private static List<String> extractMentions(String content) {\n        Pattern pattern = Pattern.compile("@(\\\\w+)");\n        Matcher matcher = pattern.matcher(content);\n\n        List<String> mentions = new ArrayList<>();\n        while (matcher.find()) {\n            mentions.add(matcher.group(1).toLowerCase());\n        }\n        return mentions;\n    }\n\n    private static Integer calculatePopularity(Post post) {\n        if (post.getStats() == null) return 0;\n\n        return post.getStats().getLikes() +\n               (post.getStats().getComments() * 2) +\n               (post.getStats().getShares() * 3);\n    }\n}\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"713-rate-limiting",children:"7.13 Rate Limiting"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'@Component\n@Slf4j\npublic class RateLimitInterceptor implements HandlerInterceptor {\n\n    @Autowired private RedisTemplate<String, Object> redisTemplate;\n\n    private static final Map<String, RateLimit> RATE_LIMITS = Map.of(\n        "POST_CREATE", new RateLimit(10, Duration.ofMinutes(1)),\n        "LIKE", new RateLimit(100, Duration.ofMinutes(1)),\n        "COMMENT", new RateLimit(30, Duration.ofMinutes(1)),\n        "FOLLOW", new RateLimit(20, Duration.ofMinutes(1)),\n        "FEED_FETCH", new RateLimit(50, Duration.ofMinutes(1))\n    );\n\n    @Override\n    public boolean preHandle(HttpServletRequest request,\n                            HttpServletResponse response,\n                            Object handler) throws Exception {\n\n        Long userId = (Long) request.getAttribute("userId");\n        if (userId == null) {\n            return true; // No user, no rate limit\n        }\n\n        String action = determineAction(request);\n        RateLimit limit = RATE_LIMITS.get(action);\n\n        if (limit != null && isRateLimited(userId, action, limit)) {\n            response.setStatus(429);\n            response.getWriter().write("{\\"error\\":\\"Rate limit exceeded\\"}");\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Token bucket algorithm using Redis\n     */\n    private boolean isRateLimited(Long userId, String action, RateLimit limit) {\n        String key = "ratelimit:" + action + ":" + userId;\n\n        Long currentCount = redisTemplate.opsForValue().increment(key);\n\n        if (currentCount == 1) {\n            // First request, set expiry\n            redisTemplate.expire(key, limit.getWindow());\n        }\n\n        boolean limited = currentCount > limit.getMaxRequests();\n\n        if (limited) {\n            log.warn("Rate limit exceeded for user {} on action {}", userId, action);\n        }\n\n        return limited;\n    }\n\n    private String determineAction(HttpServletRequest request) {\n        String method = request.getMethod();\n        String path = request.getRequestURI();\n\n        if (path.contains("/posts") && "POST".equals(method)) {\n            return "POST_CREATE";\n        } else if (path.contains("/like")) {\n            return "LIKE";\n        } else if (path.contains("/comments")) {\n            return "COMMENT";\n        } else if (path.contains("/follow")) {\n            return "FOLLOW";\n        } else if (path.contains("/feed")) {\n            return "FEED_FETCH";\n        }\n\n        return "DEFAULT";\n    }\n\n    @Data\n    @AllArgsConstructor\n    static class RateLimit {\n        private int maxRequests;\n        private Duration window;\n    }\n}\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"714-analytics-pipeline",children:"7.14 Analytics Pipeline"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'@Service\n@Slf4j\npublic class AnalyticsService {\n\n    @Autowired private CassandraOperations cassandraOps;\n    @Autowired private RedisTemplate<String, Object> redisTemplate;\n\n    /**\n     * Track post view (async)\n     */\n    @Async\n    public void trackPostView(Long postId, Long userId) {\n        UserActivity activity = UserActivity.builder()\n            .userId(userId)\n            .activityDate(LocalDate.now())\n            .activityId(UUIDs.timeBased())\n            .activityType("VIEW_POST")\n            .postId(postId)\n            .build();\n\n        cassandraOps.insert(activity);\n\n        // Increment view counter\n        incrementPostMetric(postId, "views");\n    }\n\n    /**\n     * Track engagement (like, comment, share)\n     */\n    @KafkaListener(topics = "post-engagement", groupId = "analytics")\n    public void processEngagement(EngagementEvent event) {\n        // Store in time-series table\n        Instant timeBucket = truncateToHour(event.getTimestamp());\n\n        String metric = event.getType().toLowerCase() + "s"; // likes, comments, shares\n        incrementPostEngagement(event.getPostId(), timeBucket, metric);\n\n        // Update trending score\n        updateTrendingScore(event.getPostId());\n    }\n\n    /**\n     * Calculate trending posts\n     */\n    @Scheduled(fixedRate = 300000) // Every 5 minutes\n    public void calculateTrending() {\n        Instant cutoff = Instant.now().minus(Duration.ofHours(24));\n\n        // Fetch recent posts with high engagement\n        List<PostEngagement> engagements = cassandraOps\n            .select(Query.query(Criteria.where("time_bucket").gte(cutoff)),\n                    PostEngagement.class);\n\n        // Calculate trending scores\n        Map<Long, Double> scores = engagements.stream()\n            .collect(Collectors.groupingBy(\n                PostEngagement::getPostId,\n                Collectors.summingDouble(this::calculateEngagementScore)\n            ));\n\n        // Store top 100 trending posts in Redis\n        List<Long> trending = scores.entrySet().stream()\n            .sorted(Map.Entry.<Long, Double>comparingByValue().reversed())\n            .limit(100)\n            .map(Map.Entry::getKey)\n            .collect(Collectors.toList());\n\n        redisTemplate.opsForList().rightPushAll("trending:posts", trending);\n        redisTemplate.expire("trending:posts", Duration.ofMinutes(5));\n\n        log.info("Updated trending posts: {}", trending.size());\n    }\n\n    private void incrementPostMetric(Long postId, String metric) {\n        String key = "post:metrics:" + postId;\n        redisTemplate.opsForHash().increment(key, metric, 1);\n    }\n\n    private void incrementPostEngagement(Long postId, Instant timeBucket, String metric) {\n        // Update Cassandra counter\n        Update update = QueryBuilder.update("post_engagement")\n            .increment(metric + "_count", 1)\n            .where("post_id").is(postId)\n            .and("time_bucket").is(timeBucket);\n\n        cassandraOps.getCqlOperations().execute(update.build());\n    }\n\n    private void updateTrendingScore(Long postId) {\n        String key = "trending:score:" + postId;\n        double decayedScore = getDecayedScore(key);\n        redisTemplate.opsForValue().set(key, decayedScore + 1, Duration.ofHours(24));\n    }\n\n    private double getDecayedScore(String key) {\n        Object score = redisTemplate.opsForValue().get(key);\n        if (score == null) return 0.0;\n\n        // Apply time decay\n        return ((Double) score) * 0.95;\n    }\n\n    private double calculateEngagementScore(PostEngagement e) {\n        return e.getLikesCount() + (e.getCommentsCount() * 2) + (e.getSharesCount() * 3);\n    }\n\n    private Instant truncateToHour(Instant timestamp) {\n        return timestamp.truncatedTo(ChronoUnit.HOURS);\n    }\n}\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"8-monitoring--observability",children:"8. Monitoring & Observability"}),"\n",(0,i.jsx)(n.h3,{id:"key-metrics-to-track",children:"Key Metrics to Track"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'@Component\npublic class MetricsCollector {\n\n    @Autowired private MeterRegistry meterRegistry;\n\n    /**\n     * Feed generation latency\n     */\n    public void recordFeedLatency(long milliseconds) {\n        meterRegistry.timer("feed.generation.latency")\n            .record(milliseconds, TimeUnit.MILLISECONDS);\n    }\n\n    /**\n     * Cache hit rate\n     */\n    public void recordCacheHit(String cacheType) {\n        meterRegistry.counter("cache.hits", "type", cacheType).increment();\n    }\n\n    public void recordCacheMiss(String cacheType) {\n        meterRegistry.counter("cache.misses", "type", cacheType).increment();\n    }\n\n    /**\n     * Post creation rate\n     */\n    public void recordPostCreated() {\n        meterRegistry.counter("posts.created").increment();\n    }\n\n    /**\n     * WebSocket connections\n     */\n    public void recordActiveWebSockets(int count) {\n        meterRegistry.gauge("websocket.active.connections", count);\n    }\n\n    /**\n     * Fanout performance\n     */\n    public void recordFanoutSize(int followerCount) {\n        meterRegistry.counter("fanout.size", "bucket", getBucket(followerCount))\n            .increment(followerCount);\n    }\n\n    private String getBucket(int count) {\n        if (count < 100) return "small";\n        if (count < 1000) return "medium";\n        if (count < 10000) return "large";\n        return "celebrity";\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"alerting-rules",children:"Alerting Rules"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"# Prometheus alerting rules\ngroups:\n  - name: newsfeed_alerts\n    interval: 30s\n    rules:\n      # High feed generation latency\n      - alert: HighFeedLatency\n        expr: histogram_quantile(0.99, feed_generation_latency_seconds_bucket) > 1.0\n        for: 5m\n        labels:\n          severity: warning\n        annotations:\n          summary: 'Feed generation P99 latency is high'\n          description: 'P99 latency is {{ $value }}s (threshold: 1s)'\n\n      # Low cache hit rate\n      - alert: LowCacheHitRate\n        expr: rate(cache_hits[5m]) / (rate(cache_hits[5m]) + rate(cache_misses[5m])) < 0.8\n        for: 10m\n        labels:\n          severity: warning\n        annotations:\n          summary: 'Cache hit rate is below 80%'\n\n      # High error rate\n      - alert: HighErrorRate\n        expr: rate(http_requests_total{status=~\"5..\"}[5m]) / rate(http_requests_total[5m]) > 0.01\n        for: 5m\n        labels:\n          severity: critical\n        annotations:\n          summary: 'Error rate is above 1%'\n\n      # Kafka consumer lag\n      - alert: KafkaConsumerLag\n        expr: kafka_consumer_lag > 10000\n        for: 5m\n        labels:\n          severity: warning\n        annotations:\n          summary: 'Kafka consumer lag is high'\n          description: 'Consumer lag is {{ $value }} messages'\n\n      # Database connection pool exhaustion\n      - alert: DatabasePoolExhausted\n        expr: hikaricp_connections_active / hikaricp_connections_max > 0.9\n        for: 5m\n        labels:\n          severity: critical\n        annotations:\n          summary: 'Database connection pool is nearly exhausted'\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"9-summary",children:"9. Summary"}),"\n",(0,i.jsx)(n.h3,{id:"key-design-decisions",children:"Key Design Decisions"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Hybrid Feed Generation"}),": Fanout-on-write for regular users, fanout-on-read for celebrities"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Polyglot Persistence"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"PostgreSQL for transactional data (users, posts, comments)"}),"\n",(0,i.jsx)(n.li,{children:"Cassandra for pre-computed feeds and time-series data"}),"\n",(0,i.jsx)(n.li,{children:"Redis for caching and real-time features"}),"\n",(0,i.jsx)(n.li,{children:"Elasticsearch for full-text search"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Event-Driven Architecture"}),": Kafka for async processing (fanout, analytics, notifications)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Real-Time Features"}),": WebSocket for live updates, Redis Pub/Sub for broadcasting"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Multi-Layer Caching"}),": CDN \u2192 Redis \u2192 Application \u2192 Database"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"ML-Based Ranking"}),": Multiple signals (recency, engagement, affinity, content)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Horizontal Scaling"}),": Stateless microservices with auto-scaling"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"scalability-achieved",children:"Scalability Achieved"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 2B+ users, 500M daily active users"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 < 500ms P99 feed generation latency"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 99.99% availability"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 115K reads/sec, 12K writes/sec (peak: 575K/60K)"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Real-time notifications and feed updates"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Sub-100ms search results"}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"10-trade-offs--considerations",children:"10. Trade-offs & Considerations"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Decision"}),(0,i.jsx)(n.th,{children:"Pro"}),(0,i.jsx)(n.th,{children:"Con"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Hybrid Fanout"}),(0,i.jsx)(n.td,{children:"Balanced performance for all users"}),(0,i.jsx)(n.td,{children:"Complex implementation, harder to debug"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Pre-computed Feeds"}),(0,i.jsx)(n.td,{children:"Fast read performance"}),(0,i.jsx)(n.td,{children:"Storage overhead, eventual consistency"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Event-Driven (Kafka)"}),(0,i.jsx)(n.td,{children:"Loose coupling, scalable"}),(0,i.jsx)(n.td,{children:"Added complexity, potential message lag"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"WebSocket for Real-time"}),(0,i.jsx)(n.td,{children:"Low latency, bi-directional"}),(0,i.jsx)(n.td,{children:"Connection management overhead, scaling challenges"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"ML-Based Ranking"}),(0,i.jsx)(n.td,{children:"Better engagement"}),(0,i.jsx)(n.td,{children:"Computationally expensive, requires training data"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Polyglot Persistence"}),(0,i.jsx)(n.td,{children:"Optimized for each use case"}),(0,i.jsx)(n.td,{children:"Operational complexity, data consistency challenges"})]})]})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"11-key-differences-from-other-systems",children:"11. Key Differences from Other Systems"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Aspect"}),(0,i.jsx)(n.th,{children:"News Feed"}),(0,i.jsx)(n.th,{children:"Twitter"}),(0,i.jsx)(n.th,{children:"Instagram"}),(0,i.jsx)(n.th,{children:"LinkedIn"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Feed Model"}),(0,i.jsx)(n.td,{children:"Hybrid"}),(0,i.jsx)(n.td,{children:"Mostly Pull"}),(0,i.jsx)(n.td,{children:"Push (small network)"}),(0,i.jsx)(n.td,{children:"Hybrid"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Content Type"}),(0,i.jsx)(n.td,{children:"Text, Image, Video"}),(0,i.jsx)(n.td,{children:"Short text, links"}),(0,i.jsx)(n.td,{children:"Image, Video"}),(0,i.jsx)(n.td,{children:"Professional content"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Real-time"}),(0,i.jsx)(n.td,{children:"Moderate"}),(0,i.jsx)(n.td,{children:"High (trending)"}),(0,i.jsx)(n.td,{children:"Moderate"}),(0,i.jsx)(n.td,{children:"Low"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Engagement"}),(0,i.jsx)(n.td,{children:"Likes, comments, shares"}),(0,i.jsx)(n.td,{children:"Retweets, replies"}),(0,i.jsx)(n.td,{children:"Likes, comments"}),(0,i.jsx)(n.td,{children:"Reactions, endorsements"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Graph Type"}),(0,i.jsx)(n.td,{children:"Social + Interest"}),(0,i.jsx)(n.td,{children:"Follow-based"}),(0,i.jsx)(n.td,{children:"Social + Interest"}),(0,i.jsx)(n.td,{children:"Professional network"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Search Focus"}),(0,i.jsx)(n.td,{children:"Content"}),(0,i.jsx)(n.td,{children:"Hashtags, trends"}),(0,i.jsx)(n.td,{children:"Users, hashtags"}),(0,i.jsx)(n.td,{children:"Jobs, people, content"})]})]})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"12-future-enhancements",children:"12. Future Enhancements"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Stories Feature"}),": Ephemeral content (24-hour expiry)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Live Streaming"}),": Real-time video broadcasts"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Advanced AI Moderation"}),": Detect harmful content automatically"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Augmented Reality Filters"}),": AR effects for photos/videos"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Personalized Ads"}),": Targeted advertising with privacy controls"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Group Features"}),": Private communities and forums"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Reactions Beyond Likes"}),": Multiple emotion reactions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Content Recommendations"}),": Cross-post discovery algorithms"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Blockchain Integration"}),": Decentralized content ownership"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Accessibility Features"}),": Screen reader optimization, alt text generation"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"13-additional-considerations",children:"13. Additional Considerations"}),"\n",(0,i.jsx)(n.h3,{id:"data-consistency",children:"Data Consistency"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'/**\n * Handle eventual consistency in distributed system\n */\n@Service\npublic class ConsistencyService {\n\n    /**\n     * Eventual consistency: Feed may not immediately show new post\n     * Solution: Client-side optimistic updates\n     */\n    public void handleOptimisticUpdate(Post post, Long userId) {\n        // Client shows post immediately\n        // Backend processes asynchronously\n\n        // If fanout fails, retry with exponential backoff\n        retryWithBackoff(() -> fanoutService.distribute(post), 3);\n    }\n\n    /**\n     * Strong consistency: Likes count must be accurate\n     * Solution: Use atomic operations in Redis\n     */\n    public void incrementLikeCount(Long postId) {\n        redisTemplate.opsForHash().increment("post:stats:" + postId, "likes", 1);\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n    /**\n     * Content Security Policy\n     */\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        http\n            .csrf().disable() // Use JWT tokens\n            .cors()\n            .and()\n            .authorizeHttpRequests(auth -> auth\n                .requestMatchers("/api/v1/auth/**").permitAll()\n                .requestMatchers("/api/v1/feed/**").authenticated()\n                .anyRequest().authenticated())\n            .sessionManagement()\n                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n            .and()\n            .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class);\n\n        return http.build();\n    }\n\n    /**\n     * Rate limiting per user\n     */\n    @Bean\n    public RateLimitInterceptor rateLimitInterceptor() {\n        return new RateLimitInterceptor();\n    }\n\n    /**\n     * Content validation and sanitization\n     */\n    @Bean\n    public ContentValidator contentValidator() {\n        return new ContentValidator();\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"privacy-controls",children:"Privacy Controls"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'@Service\npublic class PrivacyService {\n\n    /**\n     * Check if user can view post based on visibility settings\n     */\n    public boolean canViewPost(Post post, Long viewerId) {\n        if (post.getVisibility() == Visibility.PUBLIC) {\n            return true;\n        }\n\n        if (post.getVisibility() == Visibility.PRIVATE) {\n            return post.getUserId().equals(viewerId);\n        }\n\n        if (post.getVisibility() == Visibility.FRIENDS) {\n            return followRepository.areConnected(post.getUserId(), viewerId);\n        }\n\n        return false;\n    }\n\n    /**\n     * GDPR compliance: Export user data\n     */\n    public UserDataExport exportUserData(Long userId) {\n        return UserDataExport.builder()\n            .profile(userRepository.findById(userId).orElseThrow())\n            .posts(postRepository.findByUserId(userId))\n            .comments(commentRepository.findByUserId(userId))\n            .interactions(interactionRepository.findByUserId(userId))\n            .build();\n    }\n\n    /**\n     * GDPR compliance: Delete user data\n     */\n    @Transactional\n    public void deleteUserData(Long userId) {\n        // Soft delete posts\n        postRepository.softDeleteByUserId(userId);\n\n        // Delete interactions\n        interactionRepository.deleteByUserId(userId);\n\n        // Remove from feeds\n        feedCacheRepository.deleteByUserId(userId);\n\n        // Anonymize user profile\n        User user = userRepository.findById(userId).orElseThrow();\n        user.setEmail("deleted@example.com");\n        user.setUsername("deleted_" + userId);\n        userRepository.save(user);\n    }\n}\n'})})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);