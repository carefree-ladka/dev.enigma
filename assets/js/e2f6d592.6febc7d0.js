"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[9286],{28453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>l});var o=r(96540);const t={},i=o.createContext(t);function s(e){const n=o.useContext(i);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),o.createElement(i.Provider,{value:n},e.children)}},58511:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var o=r(74848),t=r(28453);const i={title:"Topological Sort Tutorial",description:"A comprehensive guide to Topological Sort with code examples in JavaScript."},s="Topological Sort Tutorial",l={id:"DSA/DSA with JavaScript/TopologicalSort",title:"Topological Sort Tutorial",description:"A comprehensive guide to Topological Sort with code examples in JavaScript.",source:"@site/docs/DSA/DSA with JavaScript/TopologicalSort.mdx",sourceDirName:"DSA/DSA with JavaScript",slug:"/DSA/DSA with JavaScript/TopologicalSort",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/TopologicalSort",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with JavaScript/TopologicalSort.mdx",tags:[],version:"current",frontMatter:{title:"Topological Sort Tutorial",description:"A comprehensive guide to Topological Sort with code examples in JavaScript."},sidebar:"tutorialSidebar",previous:{title:"Suffix Automaton",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/SuffixAutomata"},next:{title:"TreeMap",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/TreeMap"}},a={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Key Concepts",id:"key-concepts",level:2},{value:"Algorithms for Topological Sort",id:"algorithms-for-topological-sort",level:2},{value:"1. Kahn&#39;s Algorithm",id:"1-kahns-algorithm",level:3},{value:"2. Depth-First Search (DFS) Based Algorithm",id:"2-depth-first-search-dfs-based-algorithm",level:3},{value:"Kahn&#39;s Algorithm Implementation",id:"kahns-algorithm-implementation",level:2},{value:"Topological Sort on 2d Grid",id:"topological-sort-on-2d-grid",level:2},{value:"Topological sorting using DFS",id:"topological-sorting-using-dfs",level:2},{value:"207. Course Schedule",id:"207-course-schedule",level:2},{value:"210. Course Schedule II",id:"210-course-schedule-ii",level:2}];function h(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"topological-sort-tutorial",children:"Topological Sort Tutorial"})}),"\n",(0,o.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,o.jsx)(n.p,{children:"Topological Sort is an algorithm used to order the vertices of a Directed Acyclic Graph (DAG) in a linear sequence. In this sequence, for every directed edge ( uv ) from vertex ( u ) to vertex ( v ), ( u ) comes before ( v ). This sorting is useful in scenarios where you need to schedule tasks or resolve dependencies."}),"\n",(0,o.jsx)(n.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Directed Acyclic Graph (DAG)"}),": A graph with directed edges and no cycles."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Topological Order"}),": A linear ordering of vertices such that for every directed edge ( uv ), vertex ( u ) comes before vertex ( v )."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"algorithms-for-topological-sort",children:"Algorithms for Topological Sort"}),"\n",(0,o.jsx)(n.h3,{id:"1-kahns-algorithm",children:"1. Kahn's Algorithm"}),"\n",(0,o.jsx)(n.p,{children:"Kahn's Algorithm uses the concept of in-degrees (number of incoming edges) to determine the order of vertices. It is suitable for finding a topological sort using Breadth-First Search (BFS)."}),"\n",(0,o.jsx)(n.h3,{id:"2-depth-first-search-dfs-based-algorithm",children:"2. Depth-First Search (DFS) Based Algorithm"}),"\n",(0,o.jsx)(n.p,{children:"The DFS-based algorithm uses a stack to store the vertices in the topological order. It is suitable for finding a topological sort using Depth-First Search (DFS)."}),"\n",(0,o.jsx)(n.h2,{id:"kahns-algorithm-implementation",children:"Kahn's Algorithm Implementation"}),"\n",(0,o.jsx)(n.p,{children:"Here\u2019s a JavaScript implementation of Kahn\u2019s Algorithm for Topological Sort:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"function topologicalSortKahn(graph) {\n  const inDegree = new Array(graph.length).fill(0);\n  const queue = [];\n  const result = [];\n\n  // Compute the in-degrees of all vertices\n  for (let u = 0; u < graph.length; u++) {\n    for (const v of graph[u]) {\n      inDegree[v]++;\n    }\n  }\n\n  // Add vertices with in-degree 0 to the queue\n  for (let i = 0; i < inDegree.length; i++) {\n    if (inDegree[i] === 0) {\n      queue.push(i);\n    }\n  }\n\n  // Process the vertices in the queue\n  while (queue.length > 0) {\n    const u = queue.shift();\n    result.push(u);\n\n    for (const v of graph[u]) {\n      inDegree[v]--;\n      if (inDegree[v] === 0) {\n        queue.push(v);\n      }\n    }\n  }\n\n  // Check for cycles (if result length != graph length)\n  if (result.length !== graph.length) {\n    throw new Error('The graph contains a cycle');\n  }\n\n  return result;\n}\n\n// Example Usage\nconst graph = [\n  [1, 2], // 0 -> 1, 0 -> 2\n  [2],    // 1 -> 2\n  []      // 2\n];\n\nconsole.log(topologicalSortKahn(graph)); // Output: [0, 1, 2] or [0, 2, 1]\n"})}),"\n",(0,o.jsx)(n.h2,{id:"topological-sort-on-2d-grid",children:"Topological Sort on 2d Grid"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-JavaScript",children:"class TopologicalSort {\n    constructor(rows, cols) {\n        this.rows = rows;\n        this.cols = cols;\n        this.graph = new Map();\n        this.inDegree = new Map();\n    }\n\n    // Convert grid position to unique key\n    key(row, col) {\n        return `${row},${col}`;\n    }\n\n    // Add directed edge from (r1,c1) to (r2,c2)\n    addEdge(r1, c1, r2, c2) {\n        const from = this.key(r1, c1);\n        const to = this.key(r2, c2);\n        \n        if (!this.graph.has(from)) this.graph.set(from, []);\n        if (!this.inDegree.has(to)) this.inDegree.set(to, 0);\n        if (!this.inDegree.has(from)) this.inDegree.set(from, 0);\n        \n        this.graph.get(from).push(to);\n        this.inDegree.set(to, this.inDegree.get(to) + 1);\n    }\n\n    // Get topological ordering\n    sort() {\n        const queue = [];\n        const result = [];\n        \n        // Add all nodes with 0 in-degree\n        for (const [node, degree] of this.inDegree) {\n            if (degree === 0) queue.push(node);\n        }\n        \n        while (queue.length) {\n            const node = queue.shift();\n            result.push(node);\n            \n            if (this.graph.has(node)) {\n                for (const neighbor of this.graph.get(node)) {\n                    this.inDegree.set(neighbor, this.inDegree.get(neighbor) - 1);\n                    if (this.inDegree.get(neighbor) === 0) {\n                        queue.push(neighbor);\n                    }\n                }\n            }\n        }\n        \n        return result.length === this.inDegree.size ? result : [];\n    }\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"topological-sorting-using-dfs",children:"Topological sorting using DFS"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-JavaScript",children:"function topologicalSort(graph) {\n  const visited = new Set(); // Tracks visited nodes\n  const stack = []; // Stores the topological order\n\n  // Helper function for DFS\n  function dfs(node) {\n    if (visited.has(node)) return; // If already visited, skip\n    visited.add(node); // Mark node as visited\n\n    // Visit all its neighbors\n    for (const neighbor of graph[node]) {\n      dfs(neighbor);\n    }\n\n    // Add the node to the stack when finished\n    stack.push(node);\n  }\n\n  // Iterate through all nodes in the graph\n  for (const node of Object.keys(graph).map(Number)) {\n    if (!visited.has(node)) {\n      dfs(node);\n    }\n  }\n\n  // Reverse the stack to get the correct topological order\n  return stack.reverse();\n}\n\n// Example usage\nconst graph = {\n  5: [2, 0],\n  4: [0, 1],\n  2: [3],\n  3: [1],\n  0: [],\n  1: []\n};\n\nconsole.log(topologicalSort(graph));\n// Output: [5, 4, 2, 3, 1, 0] (One valid order)\n"})}),"\n",(0,o.jsx)(n.h2,{id:"207-course-schedule",children:"207. Course Schedule"}),"\n",(0,o.jsx)(n.p,{children:"/*\n0: Not visited\n1: Visiting (current DFS path)\n2: Fully visited (processed)\n*/"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-JavaScript",children:"function canFinish(numCourses, prerequisites) {\n  const graph = Array.from({ length: numCourses }, () => []);\n  const visited = new Array(numCourses).fill(0);\n\n  // Build adjacency list\n  for (const [course, prereq] of prerequisites) {\n    graph[prereq].push(course);\n  }\n\n  // Helper function for DFS\n  function dfs(course) {\n    if (visited[course] === 1) return false; // Cycle detected\n    if (visited[course] === 2) return true;  // Already processed\n\n    visited[course] = 1; // Mark as visiting\n\n    for (const nextCourse of graph[course]) {\n      if (!dfs(nextCourse)) return false;\n    }\n\n    visited[course] = 2; // Mark as fully visited\n    return true;\n  }\n\n  // Check all courses\n  for (let i = 0; i < numCourses; i++) {\n    if (!dfs(i)) return false;\n  }\n\n  return true;\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"210-course-schedule-ii",children:"210. Course Schedule II"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-JavaScript",children:"/**\n * @param {number} numCourses\n * @param {number[][]} prerequisites\n * @return {boolean}\n */\nvar findOrder = function (numCourses, prerequisites) {\n  const visited = {}\n  const graph = {}\n  const res = []\n\n  for (let i = 0; i < numCourses; i++) {\n    visited[i] = 0 //Unvisited\n    graph[i] = []\n  }\n\n  for (const [u, v] of prerequisites) {\n    graph[v].push(u)\n  }\n\n  const dfs = (node) => {\n    if (visited[node] === 1) return false //Visiting\n    if (visited[node] === -1) return true //Visited\n    visited[node] = 1\n\n    for (const nbr of graph[node]) {\n      if (!dfs(nbr)) return false\n    }\n\n    visited[node] = -1\n    res.push(node)\n    return true\n  }\n\n  for (let i = 0; i < numCourses; i++) {\n    if (visited[i] === 0 && !dfs(i)) return []\n  }\n  return res.reverse()\n};\n"})})]})}function d(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}}}]);