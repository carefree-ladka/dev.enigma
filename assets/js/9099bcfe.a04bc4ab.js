"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[24],{28453:(n,e,r)=>{r.d(e,{R:()=>l,x:()=>o});var i=r(96540);const t={},s=i.createContext(t);function l(n){const e=i.useContext(s);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:l(n.components),i.createElement(s.Provider,{value:e},n.children)}},70294:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>a,contentTitle:()=>l,default:()=>u,frontMatter:()=>s,metadata:()=>o,toc:()=>c});var i=r(74848),t=r(28453);const s={},l="Sorting Algorithms",o={id:"DSA/DSA with JavaScript/DSA Cheatsheets/Sorting Algorithms",title:"Sorting Algorithms",description:"A comprehensive guide to essential sorting algorithms for Data Structures and Algorithms interviews.",source:"@site/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Sorting Algorithms.mdx",sourceDirName:"DSA/DSA with JavaScript/DSA Cheatsheets",slug:"/DSA/DSA with JavaScript/DSA Cheatsheets/Sorting Algorithms",permalink:"/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Sorting Algorithms",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Sorting Algorithms.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Sliding Window",permalink:"/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Sliding Window"},next:{title:"Stack",permalink:"/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Stack"}},a={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Merge Sort",id:"merge-sort",level:2},{value:"Overview",id:"overview",level:3},{value:"When to Use Merge Sort",id:"when-to-use-merge-sort",level:3},{value:"Basic Implementation",id:"basic-implementation",level:3},{value:"In-Place Merge Sort (Space Optimized)",id:"in-place-merge-sort-space-optimized",level:3},{value:"Iterative Merge Sort (Bottom-Up)",id:"iterative-merge-sort-bottom-up",level:3},{value:"Merge Sort for Linked Lists",id:"merge-sort-for-linked-lists",level:3},{value:"Merge Sort Applications",id:"merge-sort-applications",level:3},{value:"1. Count Inversions",id:"1-count-inversions",level:4},{value:"2. Merge K Sorted Arrays",id:"2-merge-k-sorted-arrays",level:4},{value:"Quick Sort",id:"quick-sort",level:2},{value:"Overview",id:"overview-1",level:3},{value:"When to Use Quick Sort",id:"when-to-use-quick-sort",level:3},{value:"Basic Implementation (Lomuto Partition)",id:"basic-implementation-lomuto-partition",level:3},{value:"Hoare Partition Scheme",id:"hoare-partition-scheme",level:3},{value:"Randomized Quick Sort",id:"randomized-quick-sort",level:3},{value:"3-Way Quick Sort (Dutch National Flag)",id:"3-way-quick-sort-dutch-national-flag",level:3},{value:"Iterative Quick Sort",id:"iterative-quick-sort",level:3},{value:"Quick Sort Applications",id:"quick-sort-applications",level:3},{value:"1. Quick Select (Find Kth Smallest Element)",id:"1-quick-select-find-kth-smallest-element",level:4},{value:"2. Find Top K Elements",id:"2-find-top-k-elements",level:4},{value:"3. Sort Colors (3-Way Partitioning)",id:"3-sort-colors-3-way-partitioning",level:4},{value:"Optimizations",id:"optimizations",level:3},{value:"1. Hybrid Quick Sort (with Insertion Sort for small arrays)",id:"1-hybrid-quick-sort-with-insertion-sort-for-small-arrays",level:4},{value:"2. Median-of-Three Pivot Selection",id:"2-median-of-three-pivot-selection",level:4},{value:"Cyclic Sort",id:"cyclic-sort",level:2},{value:"Overview",id:"overview-2",level:3},{value:"When to Use Cyclic Sort",id:"when-to-use-cyclic-sort",level:3},{value:"Core Algorithm",id:"core-algorithm",level:3},{value:"Cyclic Sort Variations",id:"cyclic-sort-variations",level:3},{value:"For 0-indexed arrays (numbers 0 to n-1)",id:"for-0-indexed-arrays-numbers-0-to-n-1",level:4},{value:"Cyclic Sort Problems",id:"cyclic-sort-problems",level:3},{value:"1. Find Missing Number",id:"1-find-missing-number",level:4},{value:"2. Find All Missing Numbers",id:"2-find-all-missing-numbers",level:4},{value:"3. Find Duplicate Number",id:"3-find-duplicate-number",level:4},{value:"4. First Missing Positive",id:"4-first-missing-positive",level:4},{value:"Counting Sort",id:"counting-sort",level:2},{value:"Overview",id:"overview-3",level:3},{value:"When to Use Counting Sort",id:"when-to-use-counting-sort",level:3},{value:"Basic Implementation",id:"basic-implementation-1",level:3},{value:"Counting Sort for Negative Numbers",id:"counting-sort-for-negative-numbers",level:3},{value:"Counting Sort Problems",id:"counting-sort-problems",level:3},{value:"1. Sort Colors (Dutch National Flag)",id:"1-sort-colors-dutch-national-flag",level:4},{value:"2. Character Frequency Sort",id:"2-character-frequency-sort",level:4},{value:"Bucket Sort",id:"bucket-sort",level:2},{value:"Overview",id:"overview-4",level:3},{value:"When to Use Bucket Sort",id:"when-to-use-bucket-sort",level:3},{value:"Basic Implementation",id:"basic-implementation-2",level:3},{value:"Bucket Sort for Integers",id:"bucket-sort-for-integers",level:3},{value:"Bucket Sort Problems",id:"bucket-sort-problems",level:3},{value:"1. Top K Frequent Elements",id:"1-top-k-frequent-elements",level:4},{value:"2. Maximum Gap",id:"2-maximum-gap",level:4},{value:"Problem Patterns &amp; Applications",id:"problem-patterns--applications",level:2},{value:"Cyclic Sort Pattern Problems",id:"cyclic-sort-pattern-problems",level:3},{value:"Counting Sort Pattern Problems",id:"counting-sort-pattern-problems",level:3},{value:"Bucket Sort Pattern Problems",id:"bucket-sort-pattern-problems",level:3},{value:"Comparison &amp; When to Use",id:"comparison--when-to-use",level:2},{value:"Decision Tree",id:"decision-tree",level:3},{value:"Advanced Problems",id:"advanced-problems",level:2},{value:"1. Find Corrupt Pair (Cyclic Sort)",id:"1-find-corrupt-pair-cyclic-sort",level:3},{value:"2. Radix Sort (Using Counting Sort)",id:"2-radix-sort-using-counting-sort",level:3},{value:"4. Merge Intervals (Merge Sort Application)",id:"4-merge-intervals-merge-sort-application",level:3},{value:"5. Kth Largest Element in Array (Quick Select)",id:"5-kth-largest-element-in-array-quick-select",level:3},{value:"7. Sort Array by Increasing Frequency (Bucket Sort)",id:"7-sort-array-by-increasing-frequency-bucket-sort",level:3},{value:"Implementation Tips",id:"implementation-tips",level:2},{value:"Merge Sort Tips",id:"merge-sort-tips",level:3},{value:"Quick Sort Tips",id:"quick-sort-tips",level:3},{value:"Cyclic Sort Tips",id:"cyclic-sort-tips",level:3},{value:"Counting Sort Tips",id:"counting-sort-tips",level:3},{value:"Bucket Sort Tips",id:"bucket-sort-tips",level:3},{value:"Practice Problems",id:"practice-problems",level:2},{value:"Easy",id:"easy",level:3},{value:"Medium",id:"medium",level:3},{value:"Hard",id:"hard",level:3}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"sorting-algorithms",children:"Sorting Algorithms"})}),"\n",(0,i.jsx)(e.p,{children:"A comprehensive guide to essential sorting algorithms for Data Structures and Algorithms interviews."}),"\n",(0,i.jsx)(e.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#merge-sort",children:"Merge Sort"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#quick-sort",children:"Quick Sort"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#cyclic-sort",children:"Cyclic Sort"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#counting-sort",children:"Counting Sort"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#bucket-sort",children:"Bucket Sort"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#problem-patterns--applications",children:"Problem Patterns & Applications"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#comparison--when-to-use",children:"Comparison & When to Use"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#advanced-problems",children:"Advanced Problems"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#implementation-tips",children:"Implementation Tips"})}),"\n"]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"merge-sort",children:"Merge Sort"}),"\n",(0,i.jsx)(e.h3,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(e.p,{children:"Merge Sort is a stable, divide-and-conquer sorting algorithm that consistently performs in O(n log n) time. It works by recursively dividing the array into smaller subarrays, sorting them, and then merging them back together in sorted order."}),"\n",(0,i.jsx)(e.h3,{id:"when-to-use-merge-sort",children:"When to Use Merge Sort"}),"\n",(0,i.jsxs)(e.p,{children:["\u2705 ",(0,i.jsx)(e.strong,{children:"Perfect for:"})]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"When stability is required (maintains relative order of equal elements)"}),"\n",(0,i.jsx)(e.li,{children:"Large datasets where worst-case performance matters"}),"\n",(0,i.jsx)(e.li,{children:"Linked lists (no random access needed)"}),"\n",(0,i.jsx)(e.li,{children:"External sorting (sorting data that doesn't fit in memory)"}),"\n",(0,i.jsx)(e.li,{children:"When guaranteed O(n log n) performance is needed"}),"\n",(0,i.jsx)(e.li,{children:"Parallel processing scenarios"}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:["\u274c ",(0,i.jsx)(e.strong,{children:"Not suitable for:"})]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Small arrays (overhead of recursion)"}),"\n",(0,i.jsx)(e.li,{children:"Memory-constrained environments (requires O(n) extra space)"}),"\n",(0,i.jsx)(e.li,{children:"When in-place sorting is mandatory"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"basic-implementation",children:"Basic Implementation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function mergeSort(arr) {\n  // Base case: arrays with 1 or 0 elements are already sorted\n  if (arr.length <= 1) {\n    return arr;\n  }\n\n  // Divide\n  const mid = Math.floor(arr.length / 2);\n  const left = arr.slice(0, mid);\n  const right = arr.slice(mid);\n\n  // Conquer (recursively sort both halves)\n  const sortedLeft = mergeSort(left);\n  const sortedRight = mergeSort(right);\n\n  // Combine\n  return merge(sortedLeft, sortedRight);\n}\n\nfunction merge(left, right) {\n  let result = [];\n  let leftIndex = 0;\n  let rightIndex = 0;\n\n  // Merge the two sorted arrays\n  while (leftIndex < left.length && rightIndex < right.length) {\n    if (left[leftIndex] <= right[rightIndex]) {\n      result.push(left[leftIndex]);\n      leftIndex++;\n    } else {\n      result.push(right[rightIndex]);\n      rightIndex++;\n    }\n  }\n\n  // Add remaining elements\n  while (leftIndex < left.length) {\n    result.push(left[leftIndex]);\n    leftIndex++;\n  }\n\n  while (rightIndex < right.length) {\n    result.push(right[rightIndex]);\n    rightIndex++;\n  }\n\n  return result;\n}\n\n// Example usage\nconsole.log(mergeSort([64, 34, 25, 12, 22, 11, 90])); // [11, 12, 22, 25, 34, 64, 90]\n"})}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Time Complexity:"})," O(n log n) - all cases | ",(0,i.jsx)(e.strong,{children:"Space Complexity:"})," O(n)"]}),"\n",(0,i.jsx)(e.h3,{id:"in-place-merge-sort-space-optimized",children:"In-Place Merge Sort (Space Optimized)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function mergeSortInPlace(arr, left = 0, right = arr.length - 1) {\n  if (left < right) {\n    const mid = Math.floor((left + right) / 2);\n\n    // Sort both halves\n    mergeSortInPlace(arr, left, mid);\n    mergeSortInPlace(arr, mid + 1, right);\n\n    // Merge the sorted halves\n    mergeInPlace(arr, left, mid, right);\n  }\n\n  return arr;\n}\n\nfunction mergeInPlace(arr, left, mid, right) {\n  // Create temporary arrays for left and right subarrays\n  const leftArr = arr.slice(left, mid + 1);\n  const rightArr = arr.slice(mid + 1, right + 1);\n\n  let leftIndex = 0;\n  let rightIndex = 0;\n  let mergedIndex = left;\n\n  // Merge back into original array\n  while (leftIndex < leftArr.length && rightIndex < rightArr.length) {\n    if (leftArr[leftIndex] <= rightArr[rightIndex]) {\n      arr[mergedIndex] = leftArr[leftIndex];\n      leftIndex++;\n    } else {\n      arr[mergedIndex] = rightArr[rightIndex];\n      rightIndex++;\n    }\n    mergedIndex++;\n  }\n\n  // Copy remaining elements\n  while (leftIndex < leftArr.length) {\n    arr[mergedIndex] = leftArr[leftIndex];\n    leftIndex++;\n    mergedIndex++;\n  }\n\n  while (rightIndex < rightArr.length) {\n    arr[mergedIndex] = rightArr[rightIndex];\n    rightIndex++;\n    mergedIndex++;\n  }\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"iterative-merge-sort-bottom-up",children:"Iterative Merge Sort (Bottom-Up)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function mergeSortIterative(arr) {\n  const n = arr.length;\n\n  // Start with subarrays of size 1, then 2, 4, 8, ...\n  for (let size = 1; size < n; size *= 2) {\n    // Pick starting point of left subarray\n    for (let start = 0; start < n - 1; start += 2 * size) {\n      // Calculate mid and end points\n      const mid = Math.min(start + size - 1, n - 1);\n      const end = Math.min(start + 2 * size - 1, n - 1);\n\n      // Merge subarrays arr[start...mid] and arr[mid+1...end]\n      if (mid < end) {\n        mergeInPlace(arr, start, mid, end);\n      }\n    }\n  }\n\n  return arr;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"merge-sort-for-linked-lists",children:"Merge Sort for Linked Lists"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function mergeSortLinkedList(head) {\n  // Base case\n  if (!head || !head.next) {\n    return head;\n  }\n\n  // Find middle and split\n  const middle = findMiddle(head);\n  const rightHalf = middle.next;\n  middle.next = null;\n\n  // Recursively sort both halves\n  const left = mergeSortLinkedList(head);\n  const right = mergeSortLinkedList(rightHalf);\n\n  // Merge sorted halves\n  return mergeTwoSortedLists(left, right);\n}\n\nfunction findMiddle(head) {\n  let slow = head;\n  let fast = head;\n  let prev = null;\n\n  while (fast && fast.next) {\n    prev = slow;\n    slow = slow.next;\n    fast = fast.next.next;\n  }\n\n  return prev;\n}\n\nfunction mergeTwoSortedLists(l1, l2) {\n  const dummy = new ListNode(0);\n  let current = dummy;\n\n  while (l1 && l2) {\n    if (l1.val <= l2.val) {\n      current.next = l1;\n      l1 = l1.next;\n    } else {\n      current.next = l2;\n      l2 = l2.next;\n    }\n    current = current.next;\n  }\n\n  current.next = l1 || l2;\n  return dummy.next;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"merge-sort-applications",children:"Merge Sort Applications"}),"\n",(0,i.jsx)(e.h4,{id:"1-count-inversions",children:"1. Count Inversions"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function countInversions(arr) {\n  let invCount = 0;\n\n  function mergeSortAndCount(arr, temp, left, right) {\n    if (left < right) {\n      const mid = Math.floor((left + right) / 2);\n\n      invCount += mergeSortAndCount(arr, temp, left, mid);\n      invCount += mergeSortAndCount(arr, temp, mid + 1, right);\n      invCount += mergeAndCount(arr, temp, left, mid, right);\n    }\n    return invCount;\n  }\n\n  function mergeAndCount(arr, temp, left, mid, right) {\n    let i = left,\n      j = mid + 1,\n      k = left;\n    let invCount = 0;\n\n    while (i <= mid && j <= right) {\n      if (arr[i] <= arr[j]) {\n        temp[k++] = arr[i++];\n      } else {\n        temp[k++] = arr[j++];\n        invCount += mid - i + 1; // All elements from i to mid are greater than arr[j]\n      }\n    }\n\n    while (i <= mid) temp[k++] = arr[i++];\n    while (j <= right) temp[k++] = arr[j++];\n\n    for (let i = left; i <= right; i++) {\n      arr[i] = temp[i];\n    }\n\n    return invCount;\n  }\n\n  const temp = new Array(arr.length);\n  return mergeSortAndCount(arr, temp, 0, arr.length - 1);\n}\n"})}),"\n",(0,i.jsx)(e.h4,{id:"2-merge-k-sorted-arrays",children:"2. Merge K Sorted Arrays"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function mergeKSortedArrays(arrays) {\n  if (!arrays || arrays.length === 0) return [];\n\n  while (arrays.length > 1) {\n    const mergedArrays = [];\n\n    for (let i = 0; i < arrays.length; i += 2) {\n      const arr1 = arrays[i];\n      const arr2 = i + 1 < arrays.length ? arrays[i + 1] : [];\n      mergedArrays.push(merge(arr1, arr2));\n    }\n\n    arrays = mergedArrays;\n  }\n\n  return arrays[0];\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"quick-sort",children:"Quick Sort"}),"\n",(0,i.jsx)(e.h3,{id:"overview-1",children:"Overview"}),"\n",(0,i.jsx)(e.p,{children:"Quick Sort is an efficient, in-place, divide-and-conquer sorting algorithm. It works by selecting a 'pivot' element and partitioning the array around the pivot, then recursively sorting the subarrays."}),"\n",(0,i.jsx)(e.h3,{id:"when-to-use-quick-sort",children:"When to Use Quick Sort"}),"\n",(0,i.jsxs)(e.p,{children:["\u2705 ",(0,i.jsx)(e.strong,{children:"Perfect for:"})]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"General-purpose sorting (most common choice)"}),"\n",(0,i.jsx)(e.li,{children:"In-place sorting (O(log n) space complexity)"}),"\n",(0,i.jsx)(e.li,{children:"Average case performance matters more than worst case"}),"\n",(0,i.jsx)(e.li,{children:"When randomized performance is acceptable"}),"\n",(0,i.jsx)(e.li,{children:"Large datasets with good pivot selection"}),"\n",(0,i.jsx)(e.li,{children:"Cache-efficient sorting"}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:["\u274c ",(0,i.jsx)(e.strong,{children:"Not suitable for:"})]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"When stability is required"}),"\n",(0,i.jsx)(e.li,{children:"When worst-case O(n\xb2) is unacceptable"}),"\n",(0,i.jsx)(e.li,{children:"Nearly sorted data (without randomization)"}),"\n",(0,i.jsx)(e.li,{children:"When guaranteed performance is critical"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"basic-implementation-lomuto-partition",children:"Basic Implementation (Lomuto Partition)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function quickSort(arr, low = 0, high = arr.length - 1) {\n  if (low < high) {\n    // Partition the array and get pivot index\n    const pivotIndex = partition(arr, low, high);\n\n    // Recursively sort elements before and after partition\n    quickSort(arr, low, pivotIndex - 1);\n    quickSort(arr, pivotIndex + 1, high);\n  }\n\n  return arr;\n}\n\nfunction partition(arr, low, high) {\n  // Choose rightmost element as pivot\n  const pivot = arr[high];\n  let i = low - 1; // Index of smaller element\n\n  for (let j = low; j < high; j++) {\n    // If current element is smaller than or equal to pivot\n    if (arr[j] <= pivot) {\n      i++;\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n    }\n  }\n\n  // Place pivot in correct position\n  [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];\n  return i + 1;\n}\n\n// Example usage\nconsole.log(quickSort([64, 34, 25, 12, 22, 11, 90])); // [11, 12, 22, 25, 34, 64, 90]\n"})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Time Complexity:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Average: O(n log n)"}),"\n",(0,i.jsx)(e.li,{children:"Worst: O(n\xb2)"}),"\n",(0,i.jsx)(e.li,{children:"Best: O(n log n)"}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Space Complexity:"})," O(log n) average, O(n) worst case"]}),"\n",(0,i.jsx)(e.h3,{id:"hoare-partition-scheme",children:"Hoare Partition Scheme"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function quickSortHoare(arr, low = 0, high = arr.length - 1) {\n  if (low < high) {\n    const pivotIndex = hoarePartition(arr, low, high);\n\n    quickSortHoare(arr, low, pivotIndex);\n    quickSortHoare(arr, pivotIndex + 1, high);\n  }\n\n  return arr;\n}\n\nfunction hoarePartition(arr, low, high) {\n  const pivot = arr[low];\n  let i = low - 1;\n  let j = high + 1;\n\n  while (true) {\n    // Find element on left that should be on right\n    do {\n      i++;\n    } while (arr[i] < pivot);\n\n    // Find element on right that should be on left\n    do {\n      j--;\n    } while (arr[j] > pivot);\n\n    // If elements crossed, partitioning is done\n    if (i >= j) {\n      return j;\n    }\n\n    [arr[i], arr[j]] = [arr[j], arr[i]];\n  }\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"randomized-quick-sort",children:"Randomized Quick Sort"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function randomizedQuickSort(arr, low = 0, high = arr.length - 1) {\n  if (low < high) {\n    // Randomly select pivot to avoid worst case\n    const randomPivot = low + Math.floor(Math.random() * (high - low + 1));\n    [arr[randomPivot], arr[high]] = [arr[high], arr[randomPivot]];\n\n    const pivotIndex = partition(arr, low, high);\n\n    randomizedQuickSort(arr, low, pivotIndex - 1);\n    randomizedQuickSort(arr, pivotIndex + 1, high);\n  }\n\n  return arr;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"3-way-quick-sort-dutch-national-flag",children:"3-Way Quick Sort (Dutch National Flag)"}),"\n",(0,i.jsx)(e.p,{children:"Perfect for arrays with many duplicate elements:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function quickSort3Way(arr, low = 0, high = arr.length - 1) {\n  if (low < high) {\n    const [lt, gt] = partition3Way(arr, low, high);\n\n    quickSort3Way(arr, low, lt - 1);\n    quickSort3Way(arr, gt + 1, high);\n  }\n\n  return arr;\n}\n\nfunction partition3Way(arr, low, high) {\n  const pivot = arr[low];\n  let i = low;\n  let lt = low; // arr[low...lt-1] < pivot\n  let gt = high + 1; // arr[gt...high] > pivot\n\n  while (i < gt) {\n    if (arr[i] < pivot) {\n      [arr[lt], arr[i]] = [arr[i], arr[lt]];\n      lt++;\n      i++;\n    } else if (arr[i] > pivot) {\n      gt--;\n      [arr[i], arr[gt]] = [arr[gt], arr[i]];\n      // Don't increment i, as we need to examine the swapped element\n    } else {\n      i++; // arr[i] == pivot\n    }\n  }\n\n  return [lt, gt];\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"iterative-quick-sort",children:"Iterative Quick Sort"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function quickSortIterative(arr) {\n  const stack = [];\n  stack.push({ low: 0, high: arr.length - 1 });\n\n  while (stack.length > 0) {\n    const { low, high } = stack.pop();\n\n    if (low < high) {\n      const pivotIndex = partition(arr, low, high);\n\n      // Push left and right subarrays to stack\n      stack.push({ low: low, high: pivotIndex - 1 });\n      stack.push({ low: pivotIndex + 1, high: high });\n    }\n  }\n\n  return arr;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"quick-sort-applications",children:"Quick Sort Applications"}),"\n",(0,i.jsx)(e.h4,{id:"1-quick-select-find-kth-smallest-element",children:"1. Quick Select (Find Kth Smallest Element)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function quickSelect(arr, k) {\n  // Convert to 0-indexed\n  k = k - 1;\n\n  function quickSelectHelper(arr, low, high, k) {\n    if (low === high) {\n      return arr[low];\n    }\n\n    const pivotIndex = partition(arr, low, high);\n\n    if (k === pivotIndex) {\n      return arr[k];\n    } else if (k < pivotIndex) {\n      return quickSelectHelper(arr, low, pivotIndex - 1, k);\n    } else {\n      return quickSelectHelper(arr, pivotIndex + 1, high, k);\n    }\n  }\n\n  return quickSelectHelper(arr.slice(), 0, arr.length - 1, k);\n}\n\n// Example: Find 3rd smallest element\nconsole.log(quickSelect([7, 10, 4, 3, 20, 15], 3)); // 7\n"})}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Time Complexity:"})," O(n) average, O(n\xb2) worst case"]}),"\n",(0,i.jsx)(e.h4,{id:"2-find-top-k-elements",children:"2. Find Top K Elements"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function findTopKElements(arr, k) {\n  function quickSelectTopK(arr, low, high, k) {\n    if (low <= high) {\n      const pivotIndex = partitionDescending(arr, low, high);\n\n      if (pivotIndex === k - 1) {\n        return arr.slice(0, k);\n      } else if (pivotIndex < k - 1) {\n        return quickSelectTopK(arr, pivotIndex + 1, high, k);\n      } else {\n        return quickSelectTopK(arr, low, pivotIndex - 1, k);\n      }\n    }\n  }\n\n  return quickSelectTopK(arr.slice(), 0, arr.length - 1, k);\n}\n\nfunction partitionDescending(arr, low, high) {\n  const pivot = arr[high];\n  let i = low - 1;\n\n  for (let j = low; j < high; j++) {\n    if (arr[j] >= pivot) {\n      // Note: >= for descending order\n      i++;\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n    }\n  }\n\n  [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];\n  return i + 1;\n}\n"})}),"\n",(0,i.jsx)(e.h4,{id:"3-sort-colors-3-way-partitioning",children:"3. Sort Colors (3-Way Partitioning)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function sortColors(nums) {\n  let low = 0; // Boundary for 0s\n  let mid = 0; // Current element\n  let high = nums.length - 1; // Boundary for 2s\n\n  while (mid <= high) {\n    if (nums[mid] === 0) {\n      [nums[low], nums[mid]] = [nums[mid], nums[low]];\n      low++;\n      mid++;\n    } else if (nums[mid] === 1) {\n      mid++;\n    } else {\n      // nums[mid] === 2\n      [nums[mid], nums[high]] = [nums[high], nums[mid]];\n      high--;\n      // Don't increment mid, as we need to examine the swapped element\n    }\n  }\n\n  return nums;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"optimizations",children:"Optimizations"}),"\n",(0,i.jsx)(e.h4,{id:"1-hybrid-quick-sort-with-insertion-sort-for-small-arrays",children:"1. Hybrid Quick Sort (with Insertion Sort for small arrays)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function hybridQuickSort(arr, low = 0, high = arr.length - 1) {\n  const INSERTION_SORT_THRESHOLD = 10;\n\n  if (low < high) {\n    if (high - low + 1 < INSERTION_SORT_THRESHOLD) {\n      insertionSort(arr, low, high);\n    } else {\n      const pivotIndex = partition(arr, low, high);\n      hybridQuickSort(arr, low, pivotIndex - 1);\n      hybridQuickSort(arr, pivotIndex + 1, high);\n    }\n  }\n\n  return arr;\n}\n\nfunction insertionSort(arr, low, high) {\n  for (let i = low + 1; i <= high; i++) {\n    let key = arr[i];\n    let j = i - 1;\n\n    while (j >= low && arr[j] > key) {\n      arr[j + 1] = arr[j];\n      j--;\n    }\n\n    arr[j + 1] = key;\n  }\n}\n"})}),"\n",(0,i.jsx)(e.h4,{id:"2-median-of-three-pivot-selection",children:"2. Median-of-Three Pivot Selection"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function medianOfThree(arr, low, high) {\n  const mid = Math.floor((low + high) / 2);\n\n  // Sort low, mid, high\n  if (arr[mid] < arr[low]) {\n    [arr[low], arr[mid]] = [arr[mid], arr[low]];\n  }\n  if (arr[high] < arr[low]) {\n    [arr[low], arr[high]] = [arr[high], arr[low]];\n  }\n  if (arr[high] < arr[mid]) {\n    [arr[mid], arr[high]] = [arr[high], arr[mid]];\n  }\n\n  // Place median at end as pivot\n  [arr[mid], arr[high]] = [arr[high], arr[mid]];\n\n  return arr[high];\n}\n\nfunction quickSortMedianOfThree(arr, low = 0, high = arr.length - 1) {\n  if (low < high) {\n    medianOfThree(arr, low, high);\n    const pivotIndex = partition(arr, low, high);\n\n    quickSortMedianOfThree(arr, low, pivotIndex - 1);\n    quickSortMedianOfThree(arr, pivotIndex + 1, high);\n  }\n\n  return arr;\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"cyclic-sort",children:"Cyclic Sort"}),"\n",(0,i.jsx)(e.h3,{id:"overview-2",children:"Overview"}),"\n",(0,i.jsx)(e.p,{children:"Cyclic Sort is an in-place sorting algorithm that works perfectly when dealing with arrays containing numbers in a given range (usually 1 to n or 0 to n-1). It's based on the idea that we can place each number at its correct index directly."}),"\n",(0,i.jsx)(e.h3,{id:"when-to-use-cyclic-sort",children:"When to Use Cyclic Sort"}),"\n",(0,i.jsxs)(e.p,{children:["\u2705 ",(0,i.jsx)(e.strong,{children:"Perfect for:"})]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Arrays with numbers in range [1, n] or [0, n-1]"}),"\n",(0,i.jsx)(e.li,{children:"Finding missing numbers"}),"\n",(0,i.jsx)(e.li,{children:"Finding duplicate numbers"}),"\n",(0,i.jsx)(e.li,{children:"Problems requiring O(1) space complexity"}),"\n",(0,i.jsx)(e.li,{children:"When array elements represent indices"}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:["\u274c ",(0,i.jsx)(e.strong,{children:"Not suitable for:"})]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Arrays with arbitrary ranges"}),"\n",(0,i.jsx)(e.li,{children:"Arrays with many duplicates outside the expected range"}),"\n",(0,i.jsx)(e.li,{children:"When stability is required"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"core-algorithm",children:"Core Algorithm"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function cyclicSort(nums) {\n  let i = 0;\n\n  while (i < nums.length) {\n    const correctIndex = nums[i] - 1; // For 1-indexed numbers\n\n    if (nums[i] !== nums[correctIndex]) {\n      // Swap current element to its correct position\n      [nums[i], nums[correctIndex]] = [nums[correctIndex], nums[i]];\n    } else {\n      i++;\n    }\n  }\n\n  return nums;\n}\n"})}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Time Complexity:"})," O(n) | ",(0,i.jsx)(e.strong,{children:"Space Complexity:"})," O(1)"]}),"\n",(0,i.jsx)(e.h3,{id:"cyclic-sort-variations",children:"Cyclic Sort Variations"}),"\n",(0,i.jsx)(e.h4,{id:"for-0-indexed-arrays-numbers-0-to-n-1",children:"For 0-indexed arrays (numbers 0 to n-1)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function cyclicSortZeroIndexed(nums) {\n  let i = 0;\n\n  while (i < nums.length) {\n    const correctIndex = nums[i]; // For 0-indexed numbers\n\n    if (nums[i] !== nums[correctIndex]) {\n      [nums[i], nums[correctIndex]] = [nums[correctIndex], nums[i]];\n    } else {\n      i++;\n    }\n  }\n\n  return nums;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"cyclic-sort-problems",children:"Cyclic Sort Problems"}),"\n",(0,i.jsx)(e.h4,{id:"1-find-missing-number",children:"1. Find Missing Number"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Problem:"})," Given an array containing n distinct numbers taken from 0 to n, find the missing number."]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function findMissingNumber(nums) {\n  let i = 0;\n  const n = nums.length;\n\n  // Cyclic sort for numbers 0 to n-1\n  while (i < n) {\n    if (nums[i] < n && nums[i] !== nums[nums[i]]) {\n      [nums[i], nums[nums[i]]] = [nums[nums[i]], nums[i]];\n    } else {\n      i++;\n    }\n  }\n\n  // Find the missing number\n  for (let i = 0; i < n; i++) {\n    if (nums[i] !== i) {\n      return i;\n    }\n  }\n\n  return n; // If all numbers 0 to n-1 are present\n}\n\n// Example usage\nconsole.log(findMissingNumber([3, 0, 1])); // Output: 2\nconsole.log(findMissingNumber([0, 1])); // Output: 2\n"})}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Time Complexity:"})," O(n) | ",(0,i.jsx)(e.strong,{children:"Space Complexity:"})," O(1)"]}),"\n",(0,i.jsx)(e.h4,{id:"2-find-all-missing-numbers",children:"2. Find All Missing Numbers"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function findAllMissingNumbers(nums) {\n  const missing = [];\n  let i = 0;\n\n  // Cyclic sort\n  while (i < nums.length) {\n    const correctIndex = nums[i] - 1;\n    if (\n      nums[i] > 0 &&\n      nums[i] <= nums.length &&\n      nums[i] !== nums[correctIndex]\n    ) {\n      [nums[i], nums[correctIndex]] = [nums[correctIndex], nums[i]];\n    } else {\n      i++;\n    }\n  }\n\n  // Find all missing numbers\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] !== i + 1) {\n      missing.push(i + 1);\n    }\n  }\n\n  return missing;\n}\n\n// Example usage\nconsole.log(findAllMissingNumbers([4, 3, 2, 7, 8, 2, 3, 1])); // Output: [5, 6]\n"})}),"\n",(0,i.jsx)(e.h4,{id:"3-find-duplicate-number",children:"3. Find Duplicate Number"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function findDuplicate(nums) {\n  let i = 0;\n\n  while (i < nums.length) {\n    const correctIndex = nums[i] - 1;\n    if (nums[i] !== nums[correctIndex]) {\n      [nums[i], nums[correctIndex]] = [nums[correctIndex], nums[i]];\n    } else {\n      i++;\n    }\n  }\n\n  // Find the duplicate\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] !== i + 1) {\n      return nums[i];\n    }\n  }\n\n  return -1;\n}\n"})}),"\n",(0,i.jsx)(e.h4,{id:"4-first-missing-positive",children:"4. First Missing Positive"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Problem:"})," Find the smallest missing positive integer."]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function firstMissingPositive(nums) {\n  const n = nums.length;\n\n  // Cyclic sort for positive numbers\n  for (let i = 0; i < n; i++) {\n    while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] !== nums[i]) {\n      [nums[nums[i] - 1], nums[i]] = [nums[i], nums[nums[i] - 1]];\n    }\n  }\n\n  // Find first missing positive\n  for (let i = 0; i < n; i++) {\n    if (nums[i] !== i + 1) {\n      return i + 1;\n    }\n  }\n\n  return n + 1;\n}\n\n// Example usage\nconsole.log(firstMissingPositive([1, 2, 0])); // Output: 3\nconsole.log(firstMissingPositive([3, 4, -1, 1])); // Output: 2\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"counting-sort",children:"Counting Sort"}),"\n",(0,i.jsx)(e.h3,{id:"overview-3",children:"Overview"}),"\n",(0,i.jsx)(e.p,{children:"Counting Sort is a non-comparison based sorting algorithm that works by counting the number of objects having distinct key values. It's particularly efficient when the range of potential items (k) is not significantly greater than the number of items (n)."}),"\n",(0,i.jsx)(e.h3,{id:"when-to-use-counting-sort",children:"When to Use Counting Sort"}),"\n",(0,i.jsxs)(e.p,{children:["\u2705 ",(0,i.jsx)(e.strong,{children:"Perfect for:"})]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Small range of integers (k is small)"}),"\n",(0,i.jsx)(e.li,{children:"When stability is required"}),"\n",(0,i.jsx)(e.li,{children:"Frequency counting problems"}),"\n",(0,i.jsx)(e.li,{children:"Character sorting (ASCII range)"}),"\n",(0,i.jsx)(e.li,{children:"Age sorting, grade sorting"}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:["\u274c ",(0,i.jsx)(e.strong,{children:"Not suitable for:"})]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Large range of values (k >> n)"}),"\n",(0,i.jsx)(e.li,{children:"Floating-point numbers"}),"\n",(0,i.jsx)(e.li,{children:"Objects without integer keys"}),"\n",(0,i.jsx)(e.li,{children:"Memory-constrained environments"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"basic-implementation-1",children:"Basic Implementation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function countingSort(arr, maxValue = null) {\n  if (!maxValue) {\n    maxValue = Math.max(...arr);\n  }\n\n  const count = new Array(maxValue + 1).fill(0);\n  const output = new Array(arr.length);\n\n  // Count occurrences\n  for (let i = 0; i < arr.length; i++) {\n    count[arr[i]]++;\n  }\n\n  // Transform count array to actual positions\n  for (let i = 1; i <= maxValue; i++) {\n    count[i] += count[i - 1];\n  }\n\n  // Build output array (stable sorting)\n  for (let i = arr.length - 1; i >= 0; i--) {\n    output[count[arr[i]] - 1] = arr[i];\n    count[arr[i]]--;\n  }\n\n  return output;\n}\n\n// Example usage\nconsole.log(countingSort([4, 2, 2, 8, 3, 3, 1])); // [1, 2, 2, 3, 3, 4, 8]\n"})}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Time Complexity:"})," O(n + k) | ",(0,i.jsx)(e.strong,{children:"Space Complexity:"})," O(k)\nwhere k is the range of input values."]}),"\n",(0,i.jsx)(e.h3,{id:"counting-sort-for-negative-numbers",children:"Counting Sort for Negative Numbers"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function countingSortWithNegatives(arr) {\n  const min = Math.min(...arr);\n  const max = Math.max(...arr);\n  const range = max - min + 1;\n\n  const count = new Array(range).fill(0);\n  const output = new Array(arr.length);\n\n  // Count occurrences (shift by min)\n  for (let i = 0; i < arr.length; i++) {\n    count[arr[i] - min]++;\n  }\n\n  // Transform count array\n  for (let i = 1; i < range; i++) {\n    count[i] += count[i - 1];\n  }\n\n  // Build output array\n  for (let i = arr.length - 1; i >= 0; i--) {\n    output[count[arr[i] - min] - 1] = arr[i];\n    count[arr[i] - min]--;\n  }\n\n  return output;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"counting-sort-problems",children:"Counting Sort Problems"}),"\n",(0,i.jsx)(e.h4,{id:"1-sort-colors-dutch-national-flag",children:"1. Sort Colors (Dutch National Flag)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function sortColors(nums) {\n  const count = [0, 0, 0];\n\n  // Count colors\n  for (const num of nums) {\n    count[num]++;\n  }\n\n  // Fill array\n  let index = 0;\n  for (let color = 0; color < 3; color++) {\n    for (let i = 0; i < count[color]; i++) {\n      nums[index++] = color;\n    }\n  }\n\n  return nums;\n}\n"})}),"\n",(0,i.jsx)(e.h4,{id:"2-character-frequency-sort",children:"2. Character Frequency Sort"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function frequencySort(s) {\n  const count = {};\n\n  // Count characters\n  for (const char of s) {\n    count[char] = (count[char] || 0) + 1;\n  }\n\n  // Sort by frequency\n  const sorted = Object.entries(count).sort((a, b) => b[1] - a[1]);\n\n  // Build result\n  let result = '';\n  for (const [char, freq] of sorted) {\n    result += char.repeat(freq);\n  }\n\n  return result;\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"bucket-sort",children:"Bucket Sort"}),"\n",(0,i.jsx)(e.h3,{id:"overview-4",children:"Overview"}),"\n",(0,i.jsx)(e.p,{children:"Bucket Sort distributes elements into a number of buckets, sorts each bucket individually, then concatenates the sorted buckets. It's most effective when input is uniformly distributed over a range."}),"\n",(0,i.jsx)(e.h3,{id:"when-to-use-bucket-sort",children:"When to Use Bucket Sort"}),"\n",(0,i.jsxs)(e.p,{children:["\u2705 ",(0,i.jsx)(e.strong,{children:"Perfect for:"})]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Uniformly distributed data"}),"\n",(0,i.jsx)(e.li,{children:"Floating-point numbers in range [0, 1)"}),"\n",(0,i.jsx)(e.li,{children:"Large datasets that can be divided"}),"\n",(0,i.jsx)(e.li,{children:"Parallel processing scenarios"}),"\n",(0,i.jsx)(e.li,{children:"When average case O(n) is desired"}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:["\u274c ",(0,i.jsx)(e.strong,{children:"Not suitable for:"})]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Non-uniform data distribution"}),"\n",(0,i.jsx)(e.li,{children:"Unknown data range"}),"\n",(0,i.jsx)(e.li,{children:"Memory-constrained environments"}),"\n",(0,i.jsx)(e.li,{children:"Small datasets"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"basic-implementation-2",children:"Basic Implementation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function bucketSort(arr, bucketSize = 5) {\n  if (arr.length === 0) return arr;\n\n  const min = Math.min(...arr);\n  const max = Math.max(...arr);\n  const bucketCount = Math.floor((max - min) / bucketSize) + 1;\n\n  // Create empty buckets\n  const buckets = Array.from({ length: bucketCount }, () => []);\n\n  // Distribute elements into buckets\n  for (const num of arr) {\n    const bucketIndex = Math.floor((num - min) / bucketSize);\n    buckets[bucketIndex].push(num);\n  }\n\n  // Sort individual buckets and concatenate\n  let result = [];\n  for (const bucket of buckets) {\n    if (bucket.length > 0) {\n      bucket.sort((a, b) => a - b); // Use any sorting algorithm\n      result = result.concat(bucket);\n    }\n  }\n\n  return result;\n}\n\n// Example usage\nconsole.log(\n  bucketSort([0.78, 0.17, 0.39, 0.26, 0.72, 0.94, 0.21, 0.12, 0.23, 0.68])\n);\n"})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Time Complexity:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Average: O(n + k)"}),"\n",(0,i.jsx)(e.li,{children:"Worst: O(n\xb2)"}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Space Complexity:"})," O(n + k)"]}),"\n",(0,i.jsx)(e.h3,{id:"bucket-sort-for-integers",children:"Bucket Sort for Integers"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function bucketSortIntegers(arr, bucketSize = 10) {\n  if (arr.length === 0) return arr;\n\n  const min = Math.min(...arr);\n  const max = Math.max(...arr);\n  const bucketCount = Math.floor((max - min) / bucketSize) + 1;\n\n  const buckets = Array.from({ length: bucketCount }, () => []);\n\n  // Distribute elements\n  for (const num of arr) {\n    const bucketIndex = Math.floor((num - min) / bucketSize);\n    buckets[bucketIndex].push(num);\n  }\n\n  // Sort and concatenate\n  let result = [];\n  for (const bucket of buckets) {\n    if (bucket.length > 0) {\n      // Use insertion sort for small buckets\n      insertionSort(bucket);\n      result = result.concat(bucket);\n    }\n  }\n\n  return result;\n}\n\nfunction insertionSort(arr) {\n  for (let i = 1; i < arr.length; i++) {\n    let key = arr[i];\n    let j = i - 1;\n    while (j >= 0 && arr[j] > key) {\n      arr[j + 1] = arr[j];\n      j--;\n    }\n    arr[j + 1] = key;\n  }\n  return arr;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"bucket-sort-problems",children:"Bucket Sort Problems"}),"\n",(0,i.jsx)(e.h4,{id:"1-top-k-frequent-elements",children:"1. Top K Frequent Elements"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function topKFrequent(nums, k) {\n  const count = {};\n\n  // Count frequencies\n  for (const num of nums) {\n    count[num] = (count[num] || 0) + 1;\n  }\n\n  // Create buckets based on frequency\n  const buckets = Array.from({ length: nums.length + 1 }, () => []);\n\n  for (const [num, freq] of Object.entries(count)) {\n    buckets[freq].push(parseInt(num));\n  }\n\n  // Collect top k elements\n  const result = [];\n  for (let i = buckets.length - 1; i >= 0 && result.length < k; i--) {\n    if (buckets[i].length > 0) {\n      result.push(...buckets[i]);\n    }\n  }\n\n  return result.slice(0, k);\n}\n"})}),"\n",(0,i.jsx)(e.h4,{id:"2-maximum-gap",children:"2. Maximum Gap"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function maximumGap(nums) {\n  if (nums.length < 2) return 0;\n\n  const min = Math.min(...nums);\n  const max = Math.max(...nums);\n\n  if (min === max) return 0;\n\n  const n = nums.length;\n  const bucketSize = Math.max(1, Math.floor((max - min) / (n - 1)));\n  const bucketCount = Math.floor((max - min) / bucketSize) + 1;\n\n  const buckets = Array.from({ length: bucketCount }, () => ({\n    min: Infinity,\n    max: -Infinity,\n    hasNum: false,\n  }));\n\n  // Fill buckets\n  for (const num of nums) {\n    const bucketIndex = Math.floor((num - min) / bucketSize);\n    buckets[bucketIndex].hasNum = true;\n    buckets[bucketIndex].min = Math.min(buckets[bucketIndex].min, num);\n    buckets[bucketIndex].max = Math.max(buckets[bucketIndex].max, num);\n  }\n\n  // Find maximum gap\n  let maxGap = 0;\n  let prevMax = min;\n\n  for (const bucket of buckets) {\n    if (!bucket.hasNum) continue;\n\n    maxGap = Math.max(maxGap, bucket.min - prevMax);\n    prevMax = bucket.max;\n  }\n\n  return maxGap;\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"problem-patterns--applications",children:"Problem Patterns & Applications"}),"\n",(0,i.jsx)(e.h3,{id:"cyclic-sort-pattern-problems",children:"Cyclic Sort Pattern Problems"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// Pattern: Array with numbers in range [1,n] or [0,n-1]\nconst cyclicSortProblems = [\n  'Find Missing Number',\n  'Find All Missing Numbers',\n  'Find Duplicate Number',\n  'Find All Duplicates',\n  'First Missing Positive',\n  'Find Corrupt Pair',\n];\n\n// Template for cyclic sort problems\nfunction cyclicSortTemplate(nums, isOneIndexed = true) {\n  let i = 0;\n\n  while (i < nums.length) {\n    const correctIndex = isOneIndexed ? nums[i] - 1 : nums[i];\n\n    if (\n      nums[i] !== nums[correctIndex] &&\n      nums[i] > 0 &&\n      nums[i] <= nums.length\n    ) {\n      [nums[i], nums[correctIndex]] = [nums[correctIndex], nums[i]];\n    } else {\n      i++;\n    }\n  }\n\n  return nums;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"counting-sort-pattern-problems",children:"Counting Sort Pattern Problems"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"const countingSortProblems = [\n  'Sort Colors',\n  'Relative Sort Array',\n  'Sort Characters by Frequency',\n  'Custom Sort String',\n  'Rank Transform of Array',\n];\n\n// Template for counting sort problems\nfunction countingSortTemplate(arr, getKey, maxKey) {\n  const count = new Array(maxKey + 1).fill(0);\n\n  // Count frequencies\n  for (const item of arr) {\n    count[getKey(item)]++;\n  }\n\n  // Optional: convert to cumulative count for stable sorting\n  for (let i = 1; i <= maxKey; i++) {\n    count[i] += count[i - 1];\n  }\n\n  return count;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"bucket-sort-pattern-problems",children:"Bucket Sort Pattern Problems"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"const bucketSortProblems = [\n  'Top K Frequent Elements',\n  'Sort Array by Increasing Frequency',\n  'Maximum Gap',\n  'Contains Duplicate III',\n  'Group Anagrams',\n];\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"comparison--when-to-use",children:"Comparison & When to Use"}),"\n",(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:"Algorithm"}),(0,i.jsx)(e.th,{children:"Time Complexity"}),(0,i.jsx)(e.th,{children:"Space Complexity"}),(0,i.jsx)(e.th,{children:"Best For"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Merge Sort"})}),(0,i.jsx)(e.td,{children:"O(n log n) - all cases"}),(0,i.jsx)(e.td,{children:"O(n)"}),(0,i.jsx)(e.td,{children:"Stability, large datasets, linked lists"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Quick Sort"})}),(0,i.jsx)(e.td,{children:"O(n log n) avg, O(n\xb2) worst"}),(0,i.jsx)(e.td,{children:"O(log n) avg"}),(0,i.jsx)(e.td,{children:"General purpose, in-place sorting"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Cyclic Sort"})}),(0,i.jsx)(e.td,{children:"O(n)"}),(0,i.jsx)(e.td,{children:"O(1)"}),(0,i.jsx)(e.td,{children:"Numbers in range [1,n]"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Counting Sort"})}),(0,i.jsx)(e.td,{children:"O(n + k)"}),(0,i.jsx)(e.td,{children:"O(k)"}),(0,i.jsx)(e.td,{children:"Small range integers"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Bucket Sort"})}),(0,i.jsx)(e.td,{children:"O(n + k) avg, O(n\xb2) worst"}),(0,i.jsx)(e.td,{children:"O(n + k)"}),(0,i.jsx)(e.td,{children:"Uniformly distributed data"})]})]})]}),"\n",(0,i.jsx)(e.h3,{id:"decision-tree",children:"Decision Tree"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function chooseSortingAlgorithm(data, requirements = {}) {\n  const {\n    stabilityRequired = false,\n    inPlaceRequired = false,\n    guaranteedPerformance = false,\n    memoryConstrained = false,\n  } = requirements;\n\n  // Check for cyclic sort applicability\n  if (isInRange(data, 1, data.length) || isInRange(data, 0, data.length - 1)) {\n    return 'Cyclic Sort';\n  }\n\n  // Check for counting sort applicability\n  const range = Math.max(...data) - Math.min(...data) + 1;\n  if (range <= data.length * 2) {\n    return 'Counting Sort';\n  }\n\n  // Check for bucket sort applicability\n  if (isUniformlyDistributed(data) && !inPlaceRequired) {\n    return 'Bucket Sort';\n  }\n\n  // Choose between merge sort and quick sort\n  if (stabilityRequired || guaranteedPerformance) {\n    return memoryConstrained ? 'Heap Sort' : 'Merge Sort';\n  }\n\n  if (inPlaceRequired || !memoryConstrained) {\n    return 'Quick Sort';\n  }\n\n  return 'Merge Sort'; // Default safe choice\n}\n\nfunction isInRange(arr, min, max) {\n  return arr.every(num => num >= min && num <= max);\n}\n\nfunction isUniformlyDistributed(arr) {\n  // Simple heuristic - check if range/length ratio is reasonable\n  const min = Math.min(...arr);\n  const max = Math.max(...arr);\n  return (max - min) / arr.length < 10;\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"advanced-problems",children:"Advanced Problems"}),"\n",(0,i.jsx)(e.h3,{id:"1-find-corrupt-pair-cyclic-sort",children:"1. Find Corrupt Pair (Cyclic Sort)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function findErrorNums(nums) {\n  let i = 0;\n\n  // Cyclic sort\n  while (i < nums.length) {\n    const correctIndex = nums[i] - 1;\n    if (nums[i] !== nums[correctIndex]) {\n      [nums[i], nums[correctIndex]] = [nums[correctIndex], nums[i]];\n    } else {\n      i++;\n    }\n  }\n\n  // Find duplicate and missing\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] !== i + 1) {\n      return [nums[i], i + 1]; // [duplicate, missing]\n    }\n  }\n\n  return [];\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"2-radix-sort-using-counting-sort",children:"2. Radix Sort (Using Counting Sort)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function radixSort(nums) {\n  const max = Math.max(...nums);\n\n  // Sort by each digit\n  for (let exp = 1; Math.floor(max / exp) > 0; exp *= 10) {\n    countingSortByDigit(nums, exp);\n  }\n\n  return nums;\n}\n\nfunction countingSortByDigit(nums, exp) {\n  const count = new Array(10).fill(0);\n  const output = new Array(nums.length);\n\n  // Count occurrences of digits\n  for (let i = 0; i < nums.length; i++) {\n    const digit = Math.floor(nums[i] / exp) % 10;\n    count[digit]++;\n  }\n\n  // Transform to positions\n  for (let i = 1; i < 10; i++) {\n    count[i] += count[i - 1];\n  }\n\n  // Build output array\n  for (let i = nums.length - 1; i >= 0; i--) {\n    const digit = Math.floor(nums[i] / exp) % 10;\n    output[count[digit] - 1] = nums[i];\n    count[digit]--;\n  }\n\n  // Copy back to original array\n  for (let i = 0; i < nums.length; i++) {\n    nums[i] = output[i];\n  }\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"4-merge-intervals-merge-sort-application",children:"4. Merge Intervals (Merge Sort Application)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function mergeIntervals(intervals) {\n  if (intervals.length <= 1) return intervals;\n\n  // Sort intervals by start time\n  intervals.sort((a, b) => a[0] - b[0]);\n\n  const merged = [intervals[0]];\n\n  for (let i = 1; i < intervals.length; i++) {\n    const current = intervals[i];\n    const lastMerged = merged[merged.length - 1];\n\n    if (current[0] <= lastMerged[1]) {\n      // Overlapping intervals - merge them\n      lastMerged[1] = Math.max(lastMerged[1], current[1]);\n    } else {\n      // Non-overlapping interval\n      merged.push(current);\n    }\n  }\n\n  return merged;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"5-kth-largest-element-in-array-quick-select",children:"5. Kth Largest Element in Array (Quick Select)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function findKthLargest(nums, k) {\n  // Convert to finding (n-k)th smallest (0-indexed)\n  const targetIndex = nums.length - k;\n\n  function quickSelect(low, high) {\n    const pivotIndex = partition(nums, low, high);\n\n    if (pivotIndex === targetIndex) {\n      return nums[pivotIndex];\n    } else if (pivotIndex < targetIndex) {\n      return quickSelect(pivotIndex + 1, high);\n    } else {\n      return quickSelect(low, pivotIndex - 1);\n    }\n  }\n\n  return quickSelect(0, nums.length - 1);\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"7-sort-array-by-increasing-frequency-bucket-sort",children:"7. Sort Array by Increasing Frequency (Bucket Sort)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function frequencySort(nums) {\n  const count = {};\n\n  // Count frequencies\n  for (const num of nums) {\n    count[num] = (count[num] || 0) + 1;\n  }\n\n  // Create frequency buckets\n  const maxFreq = Math.max(...Object.values(count));\n  const buckets = Array.from({ length: maxFreq + 1 }, () => []);\n\n  // Group numbers by frequency\n  for (const [num, freq] of Object.entries(count)) {\n    buckets[freq].push(parseInt(num));\n  }\n\n  // Sort numbers within each frequency bucket (descending for same frequency)\n  for (const bucket of buckets) {\n    bucket.sort((a, b) => b - a);\n  }\n\n  // Build result\n  const result = [];\n  for (let freq = 1; freq <= maxFreq; freq++) {\n    for (const num of buckets[freq]) {\n      for (let i = 0; i < freq; i++) {\n        result.push(num);\n      }\n    }\n  }\n\n  return result;\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"implementation-tips",children:"Implementation Tips"}),"\n",(0,i.jsx)(e.h3,{id:"merge-sort-tips",children:"Merge Sort Tips"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Base case handling"}),": Always check for arrays of size \u2264 1"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Merge optimization"}),": Use sentinel values to avoid boundary checks"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Memory optimization"}),": Reuse temporary arrays when possible"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Stability"}),": Ensure equal elements maintain relative order in merge step"]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// Optimized merge with single temporary array\nfunction mergeOptimized(arr, left, mid, right, temp) {\n  let i = left,\n    j = mid + 1,\n    k = left;\n\n  // Copy to temp array\n  for (let idx = left; idx <= right; idx++) {\n    temp[idx] = arr[idx];\n  }\n\n  // Merge back to original array\n  while (i <= mid && j <= right) {\n    if (temp[i] <= temp[j]) {\n      arr[k++] = temp[i++];\n    } else {\n      arr[k++] = temp[j++];\n    }\n  }\n\n  while (i <= mid) arr[k++] = temp[i++];\n  while (j <= right) arr[k++] = temp[j++];\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"quick-sort-tips",children:"Quick Sort Tips"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Pivot selection"}),": Use median-of-three or randomization to avoid worst case"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Small arrays"}),": Switch to insertion sort for arrays < 10 elements"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Duplicate handling"}),": Use 3-way partitioning for arrays with many duplicates"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Tail recursion"}),": Optimize recursion for larger partition first"]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// Tail recursion optimized quicksort\nfunction quickSortTailRecursive(arr, low = 0, high = arr.length - 1) {\n  while (low < high) {\n    const pivotIndex = partition(arr, low, high);\n\n    // Recur for smaller partition and iterate for larger\n    if (pivotIndex - low < high - pivotIndex) {\n      quickSortTailRecursive(arr, low, pivotIndex - 1);\n      low = pivotIndex + 1;\n    } else {\n      quickSortTailRecursive(arr, pivotIndex + 1, high);\n      high = pivotIndex - 1;\n    }\n  }\n\n  return arr;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"cyclic-sort-tips",children:"Cyclic Sort Tips"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Always validate range"}),": Ensure numbers are in expected range before swapping"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Handle edge cases"}),": Empty arrays, single elements"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Use while loop"}),": More intuitive than for loop for this pattern"]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// Good practice template\nfunction cyclicSortSafe(nums) {\n  let i = 0;\n\n  while (i < nums.length) {\n    const correctIndex = nums[i] - 1;\n\n    // Validate before swapping\n    if (\n      nums[i] > 0 &&\n      nums[i] <= nums.length &&\n      nums[i] !== nums[correctIndex]\n    ) {\n      [nums[i], nums[correctIndex]] = [nums[correctIndex], nums[i]];\n    } else {\n      i++;\n    }\n  }\n\n  return nums;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"counting-sort-tips",children:"Counting Sort Tips"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Consider negative numbers"}),": Shift indices appropriately"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Memory optimization"}),": Use bit manipulation for boolean counting"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Stability matters"}),": Iterate backwards when building output"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"bucket-sort-tips",children:"Bucket Sort Tips"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Choose bucket size wisely"}),": Balance between memory and performance"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Handle empty buckets"}),": Check before processing"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Secondary sort"}),": Choose appropriate algorithm for individual buckets"]}),"\n"]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"practice-problems",children:"Practice Problems"}),"\n",(0,i.jsx)(e.h3,{id:"easy",children:"Easy"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Find Missing Number"}),"\n",(0,i.jsx)(e.li,{children:"Sort Colors"}),"\n",(0,i.jsx)(e.li,{children:"Missing Number"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"medium",children:"Medium"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Find All Missing Numbers"}),"\n",(0,i.jsx)(e.li,{children:"Top K Frequent Elements"}),"\n",(0,i.jsx)(e.li,{children:"Sort Characters by Frequency"}),"\n",(0,i.jsx)(e.li,{children:"Maximum Gap"}),"\n",(0,i.jsx)(e.li,{children:"Find All Duplicates in Array"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"hard",children:"Hard"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"First Missing Positive"}),"\n",(0,i.jsx)(e.li,{children:"Contains Duplicate III"}),"\n",(0,i.jsx)(e.li,{children:"Minimum Window Substring (counting pattern)"}),"\n"]}),"\n",(0,i.jsx)(e.hr,{})]})}function u(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(d,{...n})}):d(n)}}}]);