"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[6557],{28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>s});var c=t(96540);const a={},r=c.createContext(a);function o(e){const n=c.useContext(r);return c.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),c.createElement(r.Provider,{value:n},e.children)}},54033:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>b,frontMatter:()=>r,metadata:()=>s,toc:()=>i});var c=t(74848),a=t(28453);const r={title:"Object Related Problems"},o=void 0,s={id:"WebDev/JavaScript/Objects",title:"Object Related Problems",description:"Flatten an Object",source:"@site/docs/WebDev/JavaScript/Objects.mdx",sourceDirName:"WebDev/JavaScript",slug:"/WebDev/JavaScript/Objects",permalink:"/js.enigma/docs/WebDev/JavaScript/Objects",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/WebDev/JavaScript/Objects.mdx",tags:[],version:"current",frontMatter:{title:"Object Related Problems"},sidebar:"tutorialSidebar",previous:{title:"Mixins",permalink:"/js.enigma/docs/WebDev/JavaScript/Mixins"},next:{title:"Array Methods Polyfills",permalink:"/js.enigma/docs/WebDev/JavaScript/Polyfills"}},l={},i=[{value:"Flatten an Object",id:"flatten-an-object",level:3},{value:"In Place implementation",id:"in-place-implementation",level:3},{value:"Extended Version of Object Flattening",id:"extended-version-of-object-flattening",level:3},{value:"Extended Version of Object Flattening (In Place)",id:"extended-version-of-object-flattening-in-place",level:3},{value:"Group By",id:"group-by",level:3},{value:"Add Keys",id:"add-keys",level:3},{value:"Deep Copy",id:"deep-copy",level:3},{value:"Deep Equal",id:"deep-equal",level:3}];function d(e){const n={code:"code",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(n.h3,{id:"flatten-an-object",children:"Flatten an Object"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"Recursive Way"})}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-JavaScript",children:'const obj = {\n  a: 1,\n  b: {\n    c: 3,\n    d: {\n      e: 5,\n    },\n  },\n};\n\nconst flatten = (obj, sep, parent = "") => {\n  return Object.keys(obj).reduce((acc, curr) => {\n    let newKey = parent ? parent + sep + curr : curr;\n    if (typeof obj[curr] === "object" && !Array.isArray(obj[curr])) {\n      acc = {\n        ...acc,\n        ...flatten(obj[curr], sep, newKey),\n      };\n    } else acc[newKey] = obj[curr];\n    return acc;\n  }, {});\n};\n\nconsole.log(flatten(obj, ".")); //{ a: 1, \'b.c\': 3, \'b.d.e\': 5 }\n'})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"Stack Based"})}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-JavaScript",children:"function flattenObject(obj) {\n  const result = {};\n  const stack = [{ parentKey: '', value: obj }];\n\n  while (stack.length > 0) {\n    const { parentKey, value } = stack.pop();\n\n    for (const [key, val] of Object.entries(value)) {\n      const newKey = parentKey ? `${parentKey}.${key}` : key;\n\n      if (typeof val === 'object' && val !== null && !Array.isArray(val)) {\n        stack.push({ parentKey: newKey, value: val });\n      } else {\n        result[newKey] = val;\n      }\n    }\n  }\n\n  return result;\n}\n\n// Example object to flatten\nconst obj = {\n  a: 1,\n  b: {\n    c: 2,\n    d: {\n      e: 3,\n      f: 4\n    }\n  },\n  g: 5\n};\n\nconsole.log(flattenObject(obj)); //{ a: 1, g: 5, 'b.c': 2, 'b.d.e': 3, 'b.d.f': 4 }\n"})}),"\n",(0,c.jsx)(n.h3,{id:"in-place-implementation",children:"In Place implementation"}),"\n",(0,c.jsx)(n.p,{children:"We are not using extra space for this case."}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-JavaScript",children:'function flattenObjectInPlace(obj, parentKey = \'\') {\n  const keys = Object.keys(obj);\n\n  for (const key of keys) {\n    const newKey = parentKey ? `${parentKey}.${key}` : key;\n\n    if (typeof obj[key] === \'object\' && obj[key] !== null) {\n      // Recurse for nested objects\n      flattenObjectInPlace(obj[key], newKey);\n\n      // After processing nested object, copy its flattened properties up\n      for (const childKey in obj[key]) {\n        obj[childKey] = obj[key][childKey];\n      }\n      // Delete the original nested object\n      delete obj[key];\n    } else if (parentKey) {\n      // For primitive values in nested objects, move them up with the new key\n      obj[newKey] = obj[key];\n      delete obj[key];\n    }\n  }\n}\n\n// // Example usage:\nconst nestedObject = {\n  user: {\n    name: "Alice",\n    address: {\n      city: "Wonderland",\n      postalCode: "12345"\n    },\n    preferences: {\n      theme: "dark",\n      language: "en"\n    }\n  }\n};\n\nconsole.log(JSON.stringify(flattenObjectInPlace(nestedObject), null, 2));\n/* \n{\n  "user.name": "Alice",\n  "user.address.city": "Wonderland",\n  "user.address.postalCode": "12345",\n  "user.preferences.theme": "dark",\n  "user.preferences.language": "en"\n}\n*/\n'})}),"\n",(0,c.jsx)(n.h3,{id:"extended-version-of-object-flattening",children:"Extended Version of Object Flattening"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-JavaScript",children:"const obj = {\n  a: 1,\n  b: {\n    c: 2,\n    d: {\n      e: 4,\n      f: [1, 2, { g: 5, h: { i: 6, x: [22, 11] } }]\n    }\n  }\n}\n\n\nconst flattenObj = (obj, parent = \"\") => {\n  return Object.keys(obj).reduce((acc, curr) => {\n    const newKey = parent ? `${parent}.${curr}` : curr\n    if (typeof obj[curr] === 'object' && typeof obj[curr] !== null && !Array.isArray(obj[curr])) {\n      acc = {\n        ...acc,\n        ...flattenObj(obj[curr], newKey)\n      }\n    }\n\n    else if (Array.isArray(obj[curr])) {\n      obj[curr].forEach((item, index) => {\n        const newArrKey = `${newKey}[${index}]`\n        if (typeof item === 'object' && item !== null) {\n          acc = { ...acc, ...flattenObj(item, newArrKey) }\n        }\n        else acc[newArrKey] = item\n      })\n    }\n    else {\n      acc[newKey] = obj[curr]\n    }\n    return acc\n  }, {})\n\n}\n\nconsole.log(flattenObj(obj));\n\n/* \n{\n  a: 1,\n  'b.c': 2,\n  'b.d.e': 4,\n  'b.d.f[0]': 1,\n  'b.d.f[1]': 2,\n  'b.d.f[2].g': 5,\n  'b.d.f[2].h.i': 6,\n  'b.d.f[2].h.x[0]': 22,\n  'b.d.f[2].h.x[1]': 11\n}\n*/\n"})}),"\n",(0,c.jsx)(n.h3,{id:"extended-version-of-object-flattening-in-place",children:"Extended Version of Object Flattening (In Place)"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-JavaScript",children:"function flattenObject(obj, parent = '', res = obj) {\n  // Helper function to process array values\n  const processArray = (arr, parentKey) => {\n    arr.forEach((item, index) => {\n      if (typeof item === 'object' && item !== null) {\n        flattenObject(item, `${parentKey}[${index}].`, res);\n      } else {\n        res[`${parentKey}[${index}]`] = item;\n      }\n    });\n  };\n\n  // Iterate over object keys\n  Object.keys(obj).forEach(key => {\n    const value = obj[key];\n    const newKey = parent + key\n\n    if (Array.isArray(value)) {\n      // Process arrays\n      processArray(value, newKey);\n      delete obj[key]; // Remove the original array key after processing\n    } else if (typeof value === 'object' && value !== null) {\n      // Process nested objects\n      flattenObject(value, newKey + '.', res);\n      delete obj[key]; // Remove the original nested object key after processing\n    } else {\n      // Handle simple values\n      if (parent) {\n        res[newKey] = value;\n        delete obj[key]; // Remove the original key to avoid duplication\n      }\n    }\n  });\n\n  return res;\n}\n\nlet obj = {\n  a: {\n    b: 1,\n    c: {\n      d: 2,\n      e: [3, 4]\n    }\n  },\n  f: [5, { g: 6 }]\n};\n\nflattenObject(obj);\nconsole.log(obj);\n\n/* \n{\n  'a.b': 1,\n  'a.c.d': 2,\n  'a.c.e[0]': 3,\n  'a.c.e[1]': 4,\n  'f[0]': 5,\n  'f[1].g': 6\n}\n*/\n"})}),"\n",(0,c.jsx)(n.h3,{id:"group-by",children:"Group By"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-JavaScript",children:"const people = [\n  { id: 1, name: \"Alice\", age: 25, city: \"New York\" },\n  { id: 2, name: \"Bob\", age: 30, city: \"San Francisco\" },\n  { id: 3, name: \"Charlie\", age: 28, city: \"New York\" },\n  { id: 4, name: \"David\", age: 25, city: \"Los Angeles\" },\n];\n\nconst groupBy = (obj, keyGetter) => {\n  return obj.reduce((acc, curr) => {\n    const key = keyGetter(curr);\n    if (!acc[key]) acc[key] = [];\n    acc[key].push(curr);\n    return acc;\n  }, {});\n};\n\nconsole.log(groupBy(people, (item) => item.city));\n\n/* \n{\n  'New York': [\n    { id: 1, name: 'Alice', age: 25, city: 'New York' },\n    { id: 3, name: 'Charlie', age: 28, city: 'New York' }\n  ],\n  'San Francisco': [ { id: 2, name: 'Bob', age: 30, city: 'San Francisco' } ],\n  'Los Angeles': [ { id: 4, name: 'David', age: 25, city: 'Los Angeles' } ]\n}\n*/\n"})}),"\n",(0,c.jsx)(n.h3,{id:"add-keys",children:"Add Keys"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-JavaScript",children:"const obj1 = {\n  a: 1,\n  b: 2,\n  c: 4\n}\n\nconst obj2 = {\n  a: 1,\n  b: 2,\n  c: 4\n}\n\nconst obj3 = {\n  e: 2,\n}\n\nconst addKeys = (...objs) => {\n  return objs?.reduce((acc, curr) => {\n    for (const key in curr) {\n      if (!acc[key]) acc[key] = 0\n      acc[key] += curr[key]\n    }\n    return acc\n  }, {})\n}\n\nconsole.log(addKeys(obj1, obj2, obj3)); //{ a: 2, b: 4, c: 8, e: 2 }\n"})}),"\n",(0,c.jsx)(n.h3,{id:"deep-copy",children:"Deep Copy"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-JavaScript",children:'const obj = {\n  a: 1,\n  b: {\n    c: 3,\n    d: {\n      e: 5,\n    },\n  },\n};\n\nconst deepCopy = (obj) => {\n  if (typeof obj !== "object" || obj === null) return obj;\n\n  const copiedObj = Array.isArray(obj) ? [] : {};\n\n  for (const key in obj) {\n    if (Object.hasOwn(obj, key)) {\n      copiedObj[key] = deepCopy(obj[key]);\n    }\n  }\n  return copiedObj;\n};\n\nconst newObj = deepCopy(obj);\nnewObj.a = 10;\nnewObj.b.c = 11;\nnewObj.b.d.e = 15;\n\nconsole.log(obj); //{ a: 1, b: { c: 3, d: { e: 5 } } }\nconsole.log(newObj); //{ a: 10, b: { c: 11, d: { e: 15 } } }\n'})}),"\n",(0,c.jsx)(n.h3,{id:"deep-equal",children:"Deep Equal"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-JavaScript",children:"function deepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (typeof a !== 'object' || typeof b !== 'object' || a === null || b === null) {\n    return false;\n  }\n\n  // Get all property keys\n  const keysA = Object.keys(a);\n  const keysB = Object.keys(b);\n\n  // Check if the number of properties is the same\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n\n  // Check if all keys and values are equal\n  for (let key of keysA) {\n    if (!keysB.includes(key) || !deepEqual(a[key], b[key])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nconsole.log(deepEqual([1, 2, 3], [1, 2, 3])); //true\nconsole.log(deepEqual([1, 2, 3], [1, 2])); //false\nconsole.log(deepEqual({ x: 3 }, { x: 3 })); //true\nconsole.log(deepEqual({ x: 3 }, { x: 4 })); //false\n"})})]})}function b(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(d,{...e})}):d(e)}}}]);