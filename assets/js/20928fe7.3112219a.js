"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[7610],{678:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>d,toc:()=>h});var s=n(4848),r=n(8453);const i={title:"0-1 BFS Algorithm"},o=void 0,d={id:"DSA/01BFS",title:"0-1 BFS Algorithm",description:"0-1 BFS Algorithm",source:"@site/docs/DSA/01BFS.mdx",sourceDirName:"DSA",slug:"/DSA/01BFS",permalink:"/js.enigma/docs/DSA/01BFS",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/01BFS.mdx",tags:[],version:"current",frontMatter:{title:"0-1 BFS Algorithm"},sidebar:"tutorialSidebar",previous:{title:"Data Structures & Algorithms Patterns",permalink:"/js.enigma/docs/category/data-structures--algorithms-patterns"},next:{title:"2D Matrix Graph Algorithms",permalink:"/js.enigma/docs/DSA/2DGraphAlgorithms"}},a={},h=[{value:"0-1 BFS Algorithm",id:"0-1-bfs-algorithm",level:2},{value:"Concept",id:"concept",level:3},{value:"Algorithm Steps",id:"algorithm-steps",level:3},{value:"Code Example",id:"code-example",level:3},{value:"Problems:",id:"problems",level:2}];function l(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h2,{id:"0-1-bfs-algorithm",children:"0-1 BFS Algorithm"}),"\n",(0,s.jsx)(t.p,{children:"0-1 BFS is a specialized version of the Breadth-First Search (BFS) algorithm designed to handle graphs where edge weights are either 0 or 1. It efficiently finds the shortest path in such graphs by leveraging a double-ended queue (deque) to maintain a more nuanced approach to edge weights."}),"\n",(0,s.jsx)(t.h3,{id:"concept",children:"Concept"}),"\n",(0,s.jsx)(t.p,{children:"In 0-1 BFS:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Edge Weights"}),": The edge weights are either 0 or 1."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Data Structure"}),": A double-ended queue (deque) is used to optimize the traversal. Nodes connected by an edge with weight 0 are added to the front of the deque, and nodes connected by an edge with weight 1 are added to the back."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Objective"}),": To find the shortest path from a source node to all other nodes in the graph."]}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"algorithm-steps",children:"Algorithm Steps"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Initialize"}),": Start by initializing the distance for each node as infinity, except for the source node which is set to 0. Use a deque to manage the nodes to be processed."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Process Nodes"}),": Dequeue nodes and update their neighbors based on edge weights.","\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"For an edge with weight 0, update the neighbor\u2019s distance and add it to the front of the deque."}),"\n",(0,s.jsx)(t.li,{children:"For an edge with weight 1, update the neighbor\u2019s distance and add it to the back of the deque."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Continue"}),": Repeat the process until all nodes are processed."]}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"code-example",children:"Code Example"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"JavaScript Implementation"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",children:"const { Deque } = require('collections/deque');\n\n/**\n * Compute the shortest path distances from the source node using 0-1 BFS.\n * @param {number[][]} graph - Adjacency list representation of the graph with edge weights 0 or 1.\n * @param {number} source - The source node.\n * @return {number[]} - Array of shortest path distances from the source.\n */\nconst zeroOneBFS = (graph, source) => {\n  const n = graph.length;\n  const distances = Array(n).fill(Infinity);\n  const deque = new Deque();\n\n  distances[source] = 0;\n  deque.pushFront(source);\n\n  while (deque.length > 0) {\n    const node = deque.shift();\n    \n    for (const [neighbor, weight] of graph[node]) {\n      const newDist = distances[node] + weight;\n      if (newDist < distances[neighbor]) {\n        distances[neighbor] = newDist;\n        if (weight === 0) {\n          deque.pushFront(neighbor);\n        } else {\n          deque.pushBack(neighbor);\n        }\n      }\n    }\n  }\n\n  return distances;\n};\n"})}),"\n",(0,s.jsx)(t.h2,{id:"problems",children:"Problems:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"https://leetcode.com/problems/minimum-obstacle-removal-to-reach-corner",children:"https://leetcode.com/problems/minimum-obstacle-removal-to-reach-corner"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/",children:"https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"https://leetcode.com/problems/find-a-safe-walk-through-a-grid/description/",children:"https://leetcode.com/problems/find-a-safe-walk-through-a-grid/description/"})}),"\n"]})]})}function c(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>d});var s=n(6540);const r={},i=s.createContext(r);function o(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);