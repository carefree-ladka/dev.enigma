"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[3336],{28453:(n,e,r)=>{r.d(e,{R:()=>a,x:()=>l});var i=r(96540);const s={},t=i.createContext(s);function a(n){const e=i.useContext(t);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:a(n.components),i.createElement(t.Provider,{value:e},n.children)}},69961:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>u,contentTitle:()=>a,default:()=>c,frontMatter:()=>t,metadata:()=>l,toc:()=>o});var i=r(74848),s=r(28453);const t={},a="Prefix Sum",l={id:"DSA/DSA with JavaScript/DSA Cheatsheets/Prefix Sum",title:"Prefix Sum",description:"A comprehensive guide to prefix sum algorithms and techniques for Data Structures and Algorithms.",source:"@site/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Prefix Sum.mdx",sourceDirName:"DSA/DSA with JavaScript/DSA Cheatsheets",slug:"/DSA/DSA with JavaScript/DSA Cheatsheets/Prefix Sum",permalink:"/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Prefix Sum",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Prefix Sum.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"N-ary Tree",permalink:"/docs/DSA/DSA with JavaScript/DSA Cheatsheets/N-ary Tree"},next:{title:"Queue",permalink:"/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Queue Techniques"}},u={},o=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Introduction to Prefix Sum",id:"introduction-to-prefix-sum",level:2},{value:"Core Concept",id:"core-concept",level:3},{value:"When to Use Prefix Sum",id:"when-to-use-prefix-sum",level:3},{value:"Basic Template",id:"basic-template",level:3},{value:"Basic Prefix Sum",id:"basic-prefix-sum",level:2},{value:"1. Range Sum Query - Immutable",id:"1-range-sum-query---immutable",level:3},{value:"2. Running Sum of Array",id:"2-running-sum-of-array",level:3},{value:"3. Find Pivot Index",id:"3-find-pivot-index",level:3},{value:"4. Subarray Sum Equals K (Basic Approach)",id:"4-subarray-sum-equals-k-basic-approach",level:3},{value:"Prefix Sum with HashMap",id:"prefix-sum-with-hashmap",level:2},{value:"Core Principle",id:"core-principle",level:3},{value:"1. Subarray Sum Equals K (Optimized)",id:"1-subarray-sum-equals-k-optimized",level:3},{value:"2. Maximum Size Subarray Sum Equals K",id:"2-maximum-size-subarray-sum-equals-k",level:3},{value:"3. Binary Subarrays with Sum",id:"3-binary-subarrays-with-sum",level:3},{value:"4. Contiguous Array (0s and 1s Equal Count)",id:"4-contiguous-array-0s-and-1s-equal-count",level:3},{value:"5. Subarray Sums Divisible by K",id:"5-subarray-sums-divisible-by-k",level:3},{value:"6. Continuous Subarray Sum (Multiple of K)",id:"6-continuous-subarray-sum-multiple-of-k",level:3},{value:"2D Prefix Sum",id:"2d-prefix-sum",level:2},{value:"1. Range Sum Query 2D - Immutable",id:"1-range-sum-query-2d---immutable",level:3},{value:"2. Number of Submatrices That Sum to Target",id:"2-number-of-submatrices-that-sum-to-target",level:3},{value:"3. Maximum Sum Rectangle in 2D Array",id:"3-maximum-sum-rectangle-in-2d-array",level:3},{value:"Prefix XOR",id:"prefix-xor",level:2},{value:"1. XOR Queries of a Subarray",id:"1-xor-queries-of-a-subarray",level:3},{value:"2. Maximum XOR of Two Numbers in Array",id:"2-maximum-xor-of-two-numbers-in-array",level:3},{value:"3. Count Triplets with XOR Equal to Zero",id:"3-count-triplets-with-xor-equal-to-zero",level:3},{value:"Running Sum Variations",id:"running-sum-variations",level:2},{value:"1. Product of Array Except Self (Using Division)",id:"1-product-of-array-except-self-using-division",level:3},{value:"2. Maximum Product Subarray",id:"2-maximum-product-subarray",level:3},{value:"3. Minimum Operations to Make Array Equal",id:"3-minimum-operations-to-make-array-equal",level:3},{value:"Advanced Prefix Sum",id:"advanced-prefix-sum",level:2},{value:"1. Range Addition",id:"1-range-addition",level:3},{value:"2. Corporate Flight Bookings",id:"2-corporate-flight-bookings",level:3},{value:"3. Car Pooling",id:"3-car-pooling",level:3},{value:"4. Sum of All Odd Length Subarrays",id:"4-sum-of-all-odd-length-subarrays",level:3},{value:"Prefix Sum vs Other Patterns",id:"prefix-sum-vs-other-patterns",level:2},{value:"When to Use Each Pattern",id:"when-to-use-each-pattern",level:3},{value:"Comparison Example",id:"comparison-example",level:3},{value:"Usage Examples",id:"usage-examples",level:2},{value:"Time Complexity Summary",id:"time-complexity-summary",level:2},{value:"Common Patterns to Remember",id:"common-patterns-to-remember",level:2},{value:"1. <strong>Basic Prefix Sum Template</strong>",id:"1-basic-prefix-sum-template",level:3},{value:"2. <strong>Prefix Sum + HashMap Template</strong>",id:"2-prefix-sum--hashmap-template",level:3},{value:"3. <strong>2D Prefix Sum Template</strong>",id:"3-2d-prefix-sum-template",level:3},{value:"4. <strong>Difference Array Template</strong>",id:"4-difference-array-template",level:3},{value:"5. <strong>Remainder/Modulo Pattern</strong>",id:"5-remaindermodulo-pattern",level:3},{value:"6. <strong>Transform and Conquer Pattern</strong>",id:"6-transform-and-conquer-pattern",level:3},{value:"Key Interview Tips",id:"key-interview-tips",level:2},{value:"Problem Recognition Checklist",id:"problem-recognition-checklist",level:3},{value:"Common Mistakes to Avoid",id:"common-mistakes-to-avoid",level:3},{value:"Debugging Tips",id:"debugging-tips",level:3},{value:"Optimization Techniques",id:"optimization-techniques",level:3},{value:"Advanced Variations",id:"advanced-variations",level:3},{value:"Multi-dimensional Prefix Sum",id:"multi-dimensional-prefix-sum",level:4},{value:"Lazy Propagation with Prefix Sum",id:"lazy-propagation-with-prefix-sum",level:4},{value:"Practice Problems by Difficulty",id:"practice-problems-by-difficulty",level:3},{value:"Beginner",id:"beginner",level:4},{value:"Intermediate",id:"intermediate",level:4},{value:"Advanced",id:"advanced",level:4},{value:"Expert",id:"expert",level:4},{value:"Summary",id:"summary",level:2},{value:"Core Concepts",id:"core-concepts",level:3},{value:"Master These Patterns",id:"master-these-patterns",level:3},{value:"Problem Solving Strategy",id:"problem-solving-strategy",level:3}];function m(n){const e={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"prefix-sum",children:"Prefix Sum"})}),"\n",(0,i.jsx)(e.p,{children:"A comprehensive guide to prefix sum algorithms and techniques for Data Structures and Algorithms."}),"\n",(0,i.jsx)(e.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#introduction-to-prefix-sum",children:"Introduction to Prefix Sum"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#basic-prefix-sum",children:"Basic Prefix Sum"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#prefix-sum-with-hashmap",children:"Prefix Sum with HashMap"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#2d-prefix-sum",children:"2D Prefix Sum"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#prefix-xor",children:"Prefix XOR"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#running-sum-variations",children:"Running Sum Variations"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#advanced-prefix-sum",children:"Advanced Prefix Sum"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#prefix-sum-vs-other-patterns",children:"Prefix Sum vs Other Patterns"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#usage-examples",children:"Usage Examples"})}),"\n"]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"introduction-to-prefix-sum",children:"Introduction to Prefix Sum"}),"\n",(0,i.jsx)(e.p,{children:"Prefix sum (also called cumulative sum) is a preprocessing technique that allows us to answer range sum queries in O(1) time after O(n) preprocessing. It's particularly powerful when combined with hash maps for solving subarray problems."}),"\n",(0,i.jsx)(e.h3,{id:"core-concept",children:"Core Concept"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// Basic prefix sum concept\nconst arr = [1, 2, 3, 4, 5];\nconst prefixSum = [0, 1, 3, 6, 10, 15];\n//                 ^  ^  ^  ^   ^   ^\n//                 0  1  1+2 1+2+3 ... sum(0 to 4)\n\n// Range sum from index i to j: prefixSum[j+1] - prefixSum[i]\n// Sum from index 1 to 3: prefixSum[4] - prefixSum[1] = 10 - 1 = 9\n"})}),"\n",(0,i.jsx)(e.h3,{id:"when-to-use-prefix-sum",children:"When to Use Prefix Sum"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Range sum queries"})," in arrays"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Subarray sum problems"})," (equal to target, maximum, etc.)"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Cumulative frequency"})," problems"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"2D matrix"})," range sum queries"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"XOR/AND/OR"})," operations on ranges"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Problems involving difference"})," between indices"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"basic-template",children:"Basic Template"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function buildPrefixSum(arr) {\n  const prefixSum = new Array(arr.length + 1).fill(0);\n\n  for (let i = 0; i < arr.length; i++) {\n    prefixSum[i + 1] = prefixSum[i] + arr[i];\n  }\n\n  return prefixSum;\n}\n\nfunction rangeSum(prefixSum, left, right) {\n  return prefixSum[right + 1] - prefixSum[left];\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"basic-prefix-sum",children:"Basic Prefix Sum"}),"\n",(0,i.jsx)(e.h3,{id:"1-range-sum-query---immutable",children:"1. Range Sum Query - Immutable"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"class NumArray {\n  constructor(nums) {\n    this.prefixSum = new Array(nums.length + 1).fill(0);\n\n    for (let i = 0; i < nums.length; i++) {\n      this.prefixSum[i + 1] = this.prefixSum[i] + nums[i];\n    }\n  }\n\n  sumRange(left, right) {\n    return this.prefixSum[right + 1] - this.prefixSum[left];\n  }\n}\n\n// Usage\nconst numArray = new NumArray([-2, 0, 3, -5, 2, -1]);\nconsole.log(numArray.sumRange(0, 2)); // 1\nconsole.log(numArray.sumRange(2, 5)); // -1\n"})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Time Complexity:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Constructor: O(n)"}),"\n",(0,i.jsx)(e.li,{children:"Query: O(1)"}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Space Complexity:"})," O(n)"]}),"\n",(0,i.jsx)(e.h3,{id:"2-running-sum-of-array",children:"2. Running Sum of Array"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function runningSum(nums) {\n  const result = new Array(nums.length);\n  result[0] = nums[0];\n\n  for (let i = 1; i < nums.length; i++) {\n    result[i] = result[i - 1] + nums[i];\n  }\n\n  return result;\n}\n\n// In-place version\nfunction runningSumInPlace(nums) {\n  for (let i = 1; i < nums.length; i++) {\n    nums[i] += nums[i - 1];\n  }\n  return nums;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"3-find-pivot-index",children:"3. Find Pivot Index"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function pivotIndex(nums) {\n  const totalSum = nums.reduce((sum, num) => sum + num, 0);\n  let leftSum = 0;\n\n  for (let i = 0; i < nums.length; i++) {\n    const rightSum = totalSum - leftSum - nums[i];\n\n    if (leftSum === rightSum) {\n      return i;\n    }\n\n    leftSum += nums[i];\n  }\n\n  return -1;\n}\n"})}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Time Complexity:"})," O(n) | ",(0,i.jsx)(e.strong,{children:"Space Complexity:"})," O(1)"]}),"\n",(0,i.jsx)(e.h3,{id:"4-subarray-sum-equals-k-basic-approach",children:"4. Subarray Sum Equals K (Basic Approach)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function subarraySum(nums, k) {\n  let count = 0;\n\n  for (let i = 0; i < nums.length; i++) {\n    let sum = 0;\n    for (let j = i; j < nums.length; j++) {\n      sum += nums[j];\n      if (sum === k) count++;\n    }\n  }\n\n  return count;\n}\n"})}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Time Complexity:"})," O(n\xb2) | ",(0,i.jsx)(e.strong,{children:"Space Complexity:"})," O(1)"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"\ud83d\udca1 Note:"})," This can be optimized to O(n) using prefix sum with HashMap!"]}),"\n"]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"prefix-sum-with-hashmap",children:"Prefix Sum with HashMap"}),"\n",(0,i.jsx)(e.p,{children:"The combination of prefix sum with hash map is incredibly powerful for subarray problems."}),"\n",(0,i.jsx)(e.h3,{id:"core-principle",children:"Core Principle"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// If prefixSum[j] - prefixSum[i] = k\n// Then prefixSum[i] = prefixSum[j] - k\n// We can store prefix sums in a hash map and look for prefixSum[j] - k\n"})}),"\n",(0,i.jsx)(e.h3,{id:"1-subarray-sum-equals-k-optimized",children:"1. Subarray Sum Equals K (Optimized)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function subarraySum(nums, k) {\n  const prefixSumCount = new Map();\n  prefixSumCount.set(0, 1); // Important: empty subarray has sum 0\n\n  let prefixSum = 0;\n  let count = 0;\n\n  for (let i = 0; i < nums.length; i++) {\n    prefixSum += nums[i];\n\n    // Check if there's a prefix sum such that current - previous = k\n    if (prefixSumCount.has(prefixSum - k)) {\n      count += prefixSumCount.get(prefixSum - k);\n    }\n\n    // Add current prefix sum to map\n    prefixSumCount.set(prefixSum, (prefixSumCount.get(prefixSum) || 0) + 1);\n  }\n\n  return count;\n}\n"})}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Time Complexity:"})," O(n) | ",(0,i.jsx)(e.strong,{children:"Space Complexity:"})," O(n)"]}),"\n",(0,i.jsx)(e.h3,{id:"2-maximum-size-subarray-sum-equals-k",children:"2. Maximum Size Subarray Sum Equals K"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function maxSubArrayLen(nums, k) {\n  const prefixSumIndex = new Map();\n  prefixSumIndex.set(0, -1); // Empty subarray at index -1\n\n  let prefixSum = 0;\n  let maxLength = 0;\n\n  for (let i = 0; i < nums.length; i++) {\n    prefixSum += nums[i];\n\n    // Check if there's a prefix sum such that current - previous = k\n    if (prefixSumIndex.has(prefixSum - k)) {\n      maxLength = Math.max(maxLength, i - prefixSumIndex.get(prefixSum - k));\n    }\n\n    // Only store first occurrence of prefix sum for maximum length\n    if (!prefixSumIndex.has(prefixSum)) {\n      prefixSumIndex.set(prefixSum, i);\n    }\n  }\n\n  return maxLength;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"3-binary-subarrays-with-sum",children:"3. Binary Subarrays with Sum"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function numSubarraysWithSum(nums, goal) {\n  const prefixSumCount = new Map();\n  prefixSumCount.set(0, 1);\n\n  let prefixSum = 0;\n  let count = 0;\n\n  for (const num of nums) {\n    prefixSum += num;\n\n    if (prefixSumCount.has(prefixSum - goal)) {\n      count += prefixSumCount.get(prefixSum - goal);\n    }\n\n    prefixSumCount.set(prefixSum, (prefixSumCount.get(prefixSum) || 0) + 1);\n  }\n\n  return count;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"4-contiguous-array-0s-and-1s-equal-count",children:"4. Contiguous Array (0s and 1s Equal Count)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function findMaxLength(nums) {\n  const prefixSumIndex = new Map();\n  prefixSumIndex.set(0, -1); // Initial balance at index -1\n\n  let balance = 0; // +1 for 1, -1 for 0\n  let maxLength = 0;\n\n  for (let i = 0; i < nums.length; i++) {\n    balance += nums[i] === 1 ? 1 : -1;\n\n    if (prefixSumIndex.has(balance)) {\n      maxLength = Math.max(maxLength, i - prefixSumIndex.get(balance));\n    } else {\n      prefixSumIndex.set(balance, i);\n    }\n  }\n\n  return maxLength;\n}\n"})}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"\ud83d\udd27 Technique:"})," Transform the problem - treat 0 as -1 to use prefix sum!"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"5-subarray-sums-divisible-by-k",children:"5. Subarray Sums Divisible by K"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function subarraysDivByK(nums, k) {\n  const remainderCount = new Map();\n  remainderCount.set(0, 1); // Empty subarray\n\n  let prefixSum = 0;\n  let count = 0;\n\n  for (const num of nums) {\n    prefixSum += num;\n\n    // Handle negative remainders in JavaScript\n    let remainder = prefixSum % k;\n    if (remainder < 0) remainder += k;\n\n    if (remainderCount.has(remainder)) {\n      count += remainderCount.get(remainder);\n    }\n\n    remainderCount.set(remainder, (remainderCount.get(remainder) || 0) + 1);\n  }\n\n  return count;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"6-continuous-subarray-sum-multiple-of-k",children:"6. Continuous Subarray Sum (Multiple of K)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function checkSubarraySum(nums, k) {\n  const remainderIndex = new Map();\n  remainderIndex.set(0, -1); // Handle edge case\n\n  let prefixSum = 0;\n\n  for (let i = 0; i < nums.length; i++) {\n    prefixSum += nums[i];\n\n    const remainder = prefixSum % k;\n\n    if (remainderIndex.has(remainder)) {\n      // Check if subarray length is at least 2\n      if (i - remainderIndex.get(remainder) > 1) {\n        return true;\n      }\n    } else {\n      remainderIndex.set(remainder, i);\n    }\n  }\n\n  return false;\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"2d-prefix-sum",children:"2D Prefix Sum"}),"\n",(0,i.jsx)(e.p,{children:"For 2D matrix range sum queries and submatrix problems."}),"\n",(0,i.jsx)(e.h3,{id:"1-range-sum-query-2d---immutable",children:"1. Range Sum Query 2D - Immutable"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"class NumMatrix {\n  constructor(matrix) {\n    if (!matrix || matrix.length === 0 || matrix[0].length === 0) {\n      return;\n    }\n\n    const rows = matrix.length;\n    const cols = matrix[0].length;\n\n    // prefixSum[i][j] = sum of rectangle from (0,0) to (i-1,j-1)\n    this.prefixSum = Array(rows + 1)\n      .fill(null)\n      .map(() => Array(cols + 1).fill(0));\n\n    for (let i = 1; i <= rows; i++) {\n      for (let j = 1; j <= cols; j++) {\n        this.prefixSum[i][j] =\n          matrix[i - 1][j - 1] +\n          this.prefixSum[i - 1][j] +\n          this.prefixSum[i][j - 1] -\n          this.prefixSum[i - 1][j - 1];\n      }\n    }\n  }\n\n  sumRegion(row1, col1, row2, col2) {\n    return (\n      this.prefixSum[row2 + 1][col2 + 1] -\n      this.prefixSum[row1][col2 + 1] -\n      this.prefixSum[row2 + 1][col1] +\n      this.prefixSum[row1][col1]\n    );\n  }\n}\n"})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Time Complexity:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Constructor: O(m \xd7 n)"}),"\n",(0,i.jsx)(e.li,{children:"Query: O(1)"}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Space Complexity:"})," O(m \xd7 n)"]}),"\n",(0,i.jsx)(e.h3,{id:"2-number-of-submatrices-that-sum-to-target",children:"2. Number of Submatrices That Sum to Target"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function numSubmatrixSumTarget(matrix, target) {\n  const rows = matrix.length;\n  const cols = matrix[0].length;\n\n  // Build prefix sum for each row\n  for (let i = 0; i < rows; i++) {\n    for (let j = 1; j < cols; j++) {\n      matrix[i][j] += matrix[i][j - 1];\n    }\n  }\n\n  let count = 0;\n\n  // For each pair of columns\n  for (let col1 = 0; col1 < cols; col1++) {\n    for (let col2 = col1; col2 < cols; col2++) {\n      const prefixSumCount = new Map();\n      prefixSumCount.set(0, 1);\n      let prefixSum = 0;\n\n      // For each row, calculate sum between col1 and col2\n      for (let row = 0; row < rows; row++) {\n        const rowSum =\n          matrix[row][col2] - (col1 > 0 ? matrix[row][col1 - 1] : 0);\n        prefixSum += rowSum;\n\n        if (prefixSumCount.has(prefixSum - target)) {\n          count += prefixSumCount.get(prefixSum - target);\n        }\n\n        prefixSumCount.set(prefixSum, (prefixSumCount.get(prefixSum) || 0) + 1);\n      }\n    }\n  }\n\n  return count;\n}\n"})}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Time Complexity:"})," O(m \xd7 n\xb2) | ",(0,i.jsx)(e.strong,{children:"Space Complexity:"})," O(m)"]}),"\n",(0,i.jsx)(e.h3,{id:"3-maximum-sum-rectangle-in-2d-array",children:"3. Maximum Sum Rectangle in 2D Array"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function maxSumRectangle(matrix) {\n  const rows = matrix.length;\n  const cols = matrix[0].length;\n  let maxSum = -Infinity;\n\n  for (let top = 0; top < rows; top++) {\n    const temp = new Array(cols).fill(0);\n\n    for (let bottom = top; bottom < rows; bottom++) {\n      // Add current row to temp array\n      for (let i = 0; i < cols; i++) {\n        temp[i] += matrix[bottom][i];\n      }\n\n      // Find maximum subarray sum in temp (Kadane's algorithm)\n      let currentSum = 0;\n      let maxEndingHere = -Infinity;\n\n      for (let i = 0; i < cols; i++) {\n        currentSum = Math.max(temp[i], currentSum + temp[i]);\n        maxEndingHere = Math.max(maxEndingHere, currentSum);\n      }\n\n      maxSum = Math.max(maxSum, maxEndingHere);\n    }\n  }\n\n  return maxSum;\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"prefix-xor",children:"Prefix XOR"}),"\n",(0,i.jsx)(e.p,{children:"XOR prefix sums for bitwise problems."}),"\n",(0,i.jsx)(e.h3,{id:"1-xor-queries-of-a-subarray",children:"1. XOR Queries of a Subarray"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function xorQueries(arr, queries) {\n  const prefixXOR = new Array(arr.length + 1).fill(0);\n\n  // Build prefix XOR array\n  for (let i = 0; i < arr.length; i++) {\n    prefixXOR[i + 1] = prefixXOR[i] ^ arr[i];\n  }\n\n  const result = [];\n  for (const [left, right] of queries) {\n    result.push(prefixXOR[right + 1] ^ prefixXOR[left]);\n  }\n\n  return result;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"2-maximum-xor-of-two-numbers-in-array",children:"2. Maximum XOR of Two Numbers in Array"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function findMaximumXOR(nums) {\n  let maxXOR = 0;\n  let mask = 0;\n\n  // Check each bit position from left to right\n  for (let i = 30; i >= 0; i--) {\n    mask |= 1 << i;\n    const prefixes = new Set();\n\n    // Get all prefixes of length (31 - i)\n    for (const num of nums) {\n      prefixes.add(num & mask);\n    }\n\n    const candidate = maxXOR | (1 << i);\n\n    // Check if we can achieve this candidate\n    for (const prefix of prefixes) {\n      if (prefixes.has(candidate ^ prefix)) {\n        maxXOR = candidate;\n        break;\n      }\n    }\n  }\n\n  return maxXOR;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"3-count-triplets-with-xor-equal-to-zero",children:"3. Count Triplets with XOR Equal to Zero"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function countTriplets(arr) {\n  let count = 0;\n\n  for (let i = 0; i < arr.length; i++) {\n    let prefixXOR = 0;\n\n    for (let k = i + 1; k < arr.length; k++) {\n      prefixXOR ^= arr[k - 1];\n\n      // If prefix XOR from i to k-1 equals suffix XOR from k to k\n      // Then the entire range from i to k has XOR = 0\n      if (prefixXOR === 0) {\n        count += k - i;\n      }\n    }\n  }\n\n  return count;\n}\n\n// Optimized version using prefix XOR\nfunction countTripletsOptimized(arr) {\n  const n = arr.length;\n  let count = 0;\n\n  // prefix[i] = XOR of elements from 0 to i-1\n  const prefix = new Array(n + 1).fill(0);\n  for (let i = 0; i < n; i++) {\n    prefix[i + 1] = prefix[i] ^ arr[i];\n  }\n\n  for (let i = 0; i < n; i++) {\n    for (let k = i + 1; k < n; k++) {\n      // XOR from i to k should be 0\n      if (prefix[k + 1] === prefix[i]) {\n        count += k - i;\n      }\n    }\n  }\n\n  return count;\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"running-sum-variations",children:"Running Sum Variations"}),"\n",(0,i.jsx)(e.h3,{id:"1-product-of-array-except-self-using-division",children:"1. Product of Array Except Self (Using Division)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function productExceptSelf(nums) {\n  const n = nums.length;\n  const result = new Array(n);\n\n  // Left products\n  result[0] = 1;\n  for (let i = 1; i < n; i++) {\n    result[i] = result[i - 1] * nums[i - 1];\n  }\n\n  // Right products\n  let rightProduct = 1;\n  for (let i = n - 1; i >= 0; i--) {\n    result[i] *= rightProduct;\n    rightProduct *= nums[i];\n  }\n\n  return result;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"2-maximum-product-subarray",children:"2. Maximum Product Subarray"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function maxProduct(nums) {\n  let maxSoFar = nums[0];\n  let maxEndingHere = nums[0];\n  let minEndingHere = nums[0];\n\n  for (let i = 1; i < nums.length; i++) {\n    const temp = maxEndingHere;\n\n    maxEndingHere = Math.max(\n      nums[i],\n      Math.max(maxEndingHere * nums[i], minEndingHere * nums[i])\n    );\n    minEndingHere = Math.min(\n      nums[i],\n      Math.min(temp * nums[i], minEndingHere * nums[i])\n    );\n\n    maxSoFar = Math.max(maxSoFar, maxEndingHere);\n  }\n\n  return maxSoFar;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"3-minimum-operations-to-make-array-equal",children:"3. Minimum Operations to Make Array Equal"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function minOperations(n) {\n  // For array [1, 3, 5, ..., 2n-1], target is average = n\n  // We need to make operations on first half to reach target\n  let operations = 0;\n\n  for (let i = 0; i < n / 2; i++) {\n    const currentValue = 2 * i + 1;\n    operations += n - currentValue;\n  }\n\n  return operations;\n}\n\n// Alternative using mathematical formula\nfunction minOperationsFormula(n) {\n  return (n * n) / 4; // Integer division\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"advanced-prefix-sum",children:"Advanced Prefix Sum"}),"\n",(0,i.jsx)(e.h3,{id:"1-range-addition",children:"1. Range Addition"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function getModifiedArray(length, updates) {\n  const result = new Array(length).fill(0);\n\n  // Apply difference array technique\n  for (const [start, end, inc] of updates) {\n    result[start] += inc;\n    if (end + 1 < length) {\n      result[end + 1] -= inc;\n    }\n  }\n\n  // Convert difference array to actual values using prefix sum\n  for (let i = 1; i < length; i++) {\n    result[i] += result[i - 1];\n  }\n\n  return result;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"2-corporate-flight-bookings",children:"2. Corporate Flight Bookings"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function corpFlightBookings(bookings, n) {\n  const result = new Array(n + 1).fill(0);\n\n  // Use difference array\n  for (const [first, last, seats] of bookings) {\n    result[first - 1] += seats; // Convert to 0-indexed\n    result[last] -= seats;\n  }\n\n  // Apply prefix sum to get final answer\n  for (let i = 1; i < n; i++) {\n    result[i] += result[i - 1];\n  }\n\n  return result.slice(0, n); // Remove extra element\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"3-car-pooling",children:"3. Car Pooling"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function carPooling(trips, capacity) {\n  // Find maximum location\n  let maxLocation = 0;\n  for (const [passengers, from, to] of trips) {\n    maxLocation = Math.max(maxLocation, to);\n  }\n\n  const timeline = new Array(maxLocation + 1).fill(0);\n\n  // Apply difference array technique\n  for (const [passengers, from, to] of trips) {\n    timeline[from] += passengers;\n    timeline[to] -= passengers;\n  }\n\n  // Check capacity using prefix sum\n  let currentPassengers = 0;\n  for (let i = 0; i <= maxLocation; i++) {\n    currentPassengers += timeline[i];\n    if (currentPassengers > capacity) {\n      return false;\n    }\n  }\n\n  return true;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"4-sum-of-all-odd-length-subarrays",children:"4. Sum of All Odd Length Subarrays"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function sumOddLengthSubarrays(arr) {\n  let totalSum = 0;\n  const n = arr.length;\n\n  for (let i = 0; i < n; i++) {\n    // Calculate how many odd-length subarrays include arr[i]\n    const leftCount = i + 1;\n    const rightCount = n - i;\n    const totalSubarrays = leftCount * rightCount;\n\n    // Odd-length subarrays = (total + 1) / 2\n    const oddSubarrays = Math.ceil(totalSubarrays / 2);\n\n    totalSum += arr[i] * oddSubarrays;\n  }\n\n  return totalSum;\n}\n\n// Alternative approach using prefix sum\nfunction sumOddLengthSubarraysPrefix(arr) {\n  const prefixSum = [0];\n  for (const num of arr) {\n    prefixSum.push(prefixSum[prefixSum.length - 1] + num);\n  }\n\n  let totalSum = 0;\n\n  // Check all odd-length subarrays\n  for (let length = 1; length <= arr.length; length += 2) {\n    for (let i = 0; i <= arr.length - length; i++) {\n      totalSum += prefixSum[i + length] - prefixSum[i];\n    }\n  }\n\n  return totalSum;\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"prefix-sum-vs-other-patterns",children:"Prefix Sum vs Other Patterns"}),"\n",(0,i.jsx)(e.h3,{id:"when-to-use-each-pattern",children:"When to Use Each Pattern"}),"\n",(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:"Pattern"}),(0,i.jsx)(e.th,{children:"Use Case"}),(0,i.jsx)(e.th,{children:"Example Problems"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Prefix Sum"})}),(0,i.jsx)(e.td,{children:"Range sum queries, subarray sum problems"}),(0,i.jsx)(e.td,{children:"Subarray Sum Equals K, Range Sum Query"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Sliding Window"})}),(0,i.jsx)(e.td,{children:"Contiguous subarray with constraints"}),(0,i.jsx)(e.td,{children:"Longest Substring Without Repeating"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Two Pointers"})}),(0,i.jsx)(e.td,{children:"Sorted array problems, palindromes"}),(0,i.jsx)(e.td,{children:"Two Sum II, Valid Palindrome"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Hash Map"})}),(0,i.jsx)(e.td,{children:"Frequency counting, complement finding"}),(0,i.jsx)(e.td,{children:"Two Sum, Group Anagrams"})]})]})]}),"\n",(0,i.jsx)(e.h3,{id:"comparison-example",children:"Comparison Example"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// Problem: Find subarray with sum equals K\n\n// Approach 1: Brute Force - O(n\xb2)\nfunction subarraySum1(nums, k) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    let sum = 0;\n    for (let j = i; j < nums.length; j++) {\n      sum += nums[j];\n      if (sum === k) count++;\n    }\n  }\n  return count;\n}\n\n// Approach 2: Prefix Sum + HashMap - O(n)\nfunction subarraySum2(nums, k) {\n  const prefixSumCount = new Map();\n  prefixSumCount.set(0, 1);\n  let prefixSum = 0;\n  let count = 0;\n\n  for (const num of nums) {\n    prefixSum += num;\n    if (prefixSumCount.has(prefixSum - k)) {\n      count += prefixSumCount.get(prefixSum - k);\n    }\n    prefixSumCount.set(prefixSum, (prefixSumCount.get(prefixSum) || 0) + 1);\n  }\n\n  return count;\n}\n\n// Sliding window won't work here because we need exact sum,\n// not a range of sums, and array can have negatives\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"console.log('=== Prefix Sum Techniques Demo ===');\n\n// Basic prefix sum\nconst arr1 = [1, 2, 3, 4, 5];\nconst numArray = new NumArray(arr1);\nconsole.log('Range sum (1, 3):', numArray.sumRange(1, 3)); // 9\n\n// Subarray sum equals k\nconst arr2 = [1, 1, 1];\nconsole.log('Subarrays with sum 2:', subarraySum(arr2, 2)); // 2\n\n// Contiguous array (0s and 1s)\nconst arr3 = [0, 1, 0, 0, 1, 1, 0];\nconsole.log('Max length equal 0s and 1s:', findMaxLength(arr3)); // 6\n\n// 2D prefix sum\nconst matrix = [\n  [3, 0, 1, 4, 2],\n  [5, 6, 3, 2, 1],\n  [1, 2, 0, 1, 5],\n];\nconst numMatrix = new NumMatrix(matrix);\nconsole.log('2D range sum (1,1) to (2,2):', numMatrix.sumRegion(1, 1, 2, 2)); // 11\n\n// XOR queries\nconst arr4 = [1, 3, 4, 8];\nconst queries = [\n  [0, 1],\n  [1, 2],\n  [0, 3],\n  [3, 3],\n];\nconsole.log('XOR queries:', xorQueries(arr4, queries)); // [2, 7, 14, 8]\n\n// Product except self\nconst arr5 = [1, 2, 3, 4];\nconsole.log('Product except self:', productExceptSelf(arr5)); // [24, 12, 8, 6]\n\n// Pivot index\nconst arr6 = [1, 7, 3, 6, 5, 6];\nconsole.log('Pivot index:', pivotIndex(arr6)); // 3\n\n// Difference array (range updates)\nconst updates = [\n  [1, 3, 2],\n  [2, 4, 3],\n  [0, 2, -2],\n];\nconsole.log('Range addition:', getModifiedArray(5, updates)); // [-2, 0, 3, 5, 3]\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"time-complexity-summary",children:"Time Complexity Summary"}),"\n",(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:"Problem Type"}),(0,i.jsx)(e.th,{children:"Time Complexity"}),(0,i.jsx)(e.th,{children:"Space Complexity"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"Basic Range Sum"}),(0,i.jsx)(e.td,{children:"O(n) build, O(1) query"}),(0,i.jsx)(e.td,{children:"O(n)"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"Subarray Sum with HashMap"}),(0,i.jsx)(e.td,{children:"O(n)"}),(0,i.jsx)(e.td,{children:"O(n)"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"2D Range Sum"}),(0,i.jsx)(e.td,{children:"O(mn) build, O(1) query"}),(0,i.jsx)(e.td,{children:"O(mn)"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"XOR Queries"}),(0,i.jsx)(e.td,{children:"O(n) build, O(1) query"}),(0,i.jsx)(e.td,{children:"O(n)"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"Difference Array"}),(0,i.jsx)(e.td,{children:"O(n + k) for k updates"}),(0,i.jsx)(e.td,{children:"O(n)"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"Matrix Subarray Sum"}),(0,i.jsx)(e.td,{children:"O(m \xd7 n\xb2)"}),(0,i.jsx)(e.td,{children:"O(n)"})]})]})]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"common-patterns-to-remember",children:"Common Patterns to Remember"}),"\n",(0,i.jsxs)(e.h3,{id:"1-basic-prefix-sum-template",children:["1. ",(0,i.jsx)(e.strong,{children:"Basic Prefix Sum Template"})]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"const prefixSum = [0];\nfor (const num of arr) {\n  prefixSum.push(prefixSum[prefixSum.length - 1] + num);\n}\n// Range sum from i to j: prefixSum[j + 1] - prefixSum[i]\n"})}),"\n",(0,i.jsxs)(e.h3,{id:"2-prefix-sum--hashmap-template",children:["2. ",(0,i.jsx)(e.strong,{children:"Prefix Sum + HashMap Template"})]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"const prefixSumCount = new Map();\nprefixSumCount.set(0, 1); // Important for empty subarray\nlet prefixSum = 0,\n  count = 0;\n\nfor (const num of nums) {\n  prefixSum += num;\n  if (prefixSumCount.has(prefixSum - target)) {\n    count += prefixSumCount.get(prefixSum - target);\n  }\n  prefixSumCount.set(prefixSum, (prefixSumCount.get(prefixSum) || 0) + 1);\n}\n"})}),"\n",(0,i.jsxs)(e.h3,{id:"3-2d-prefix-sum-template",children:["3. ",(0,i.jsx)(e.strong,{children:"2D Prefix Sum Template"})]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"const prefixSum = Array(rows + 1)\n  .fill(null)\n  .map(() => Array(cols + 1).fill(0));\n\nfor (let i = 1; i <= rows; i++) {\n  for (let j = 1; j <= cols; j++) {\n    prefixSum[i][j] =\n      matrix[i - 1][j - 1] +\n      prefixSum[i - 1][j] +\n      prefixSum[i][j - 1] -\n      prefixSum[i - 1][j - 1];\n  }\n}\n"})}),"\n",(0,i.jsxs)(e.h3,{id:"4-difference-array-template",children:["4. ",(0,i.jsx)(e.strong,{children:"Difference Array Template"})]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"const diff = new Array(n).fill(0);\n\n// Apply updates\nfor (const [start, end, val] of updates) {\n  diff[start] += val;\n  if (end + 1 < n) diff[end + 1] -= val;\n}\n\n// Convert to final array using prefix sum\nfor (let i = 1; i < n; i++) {\n  diff[i] += diff[i - 1];\n}\n"})}),"\n",(0,i.jsxs)(e.h3,{id:"5-remaindermodulo-pattern",children:["5. ",(0,i.jsx)(e.strong,{children:"Remainder/Modulo Pattern"})]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"const remainderCount = new Map();\nremainderCount.set(0, 1); // Empty subarray\nlet prefixSum = 0;\n\nfor (const num of nums) {\n  prefixSum += num;\n  let remainder = prefixSum % k;\n  if (remainder < 0) remainder += k; // Handle negative remainders\n\n  if (remainderCount.has(remainder)) {\n    count += remainderCount.get(remainder);\n  }\n  remainderCount.set(remainder, (remainderCount.get(remainder) || 0) + 1);\n}\n"})}),"\n",(0,i.jsxs)(e.h3,{id:"6-transform-and-conquer-pattern",children:["6. ",(0,i.jsx)(e.strong,{children:"Transform and Conquer Pattern"})]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// Transform problem to use prefix sum\n// Example: Equal 0s and 1s \u2192 treat 0 as -1, find sum = 0\n// Example: Equal frequency \u2192 difference of counts\n\nfor (let i = 0; i < arr.length; i++) {\n  // Transform based on problem requirement\n  balance += arr[i] === target ? 1 : -1;\n  // Rest follows prefix sum + hashmap pattern\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"key-interview-tips",children:"Key Interview Tips"}),"\n",(0,i.jsx)(e.h3,{id:"problem-recognition-checklist",children:"Problem Recognition Checklist"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Use Prefix Sum when you see:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:'\u2705 "Subarray" with sum/XOR conditions'}),"\n",(0,i.jsx)(e.li,{children:'\u2705 "Range sum/product queries"'}),"\n",(0,i.jsx)(e.li,{children:'\u2705 "Cumulative" or "running total"'}),"\n",(0,i.jsx)(e.li,{children:'\u2705 "Count of subarrays" with constraints'}),"\n",(0,i.jsx)(e.li,{children:'\u2705 "Equal frequency" or "balanced" problems'}),"\n",(0,i.jsx)(e.li,{children:'\u2705 Matrix "rectangle sum" queries'}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Combine with HashMap when:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u2705 Need to find specific target sum"}),"\n",(0,i.jsx)(e.li,{children:"\u2705 Count occurrences of prefix sums"}),"\n",(0,i.jsx)(e.li,{children:"\u2705 Find maximum/minimum length subarrays"}),"\n",(0,i.jsx)(e.li,{children:'\u2705 Problems with "equals", "divisible by", etc.'}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"common-mistakes-to-avoid",children:"Common Mistakes to Avoid"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Forgetting empty subarray"}),": Always initialize ",(0,i.jsx)(e.code,{children:"prefixSumMap.set(0, 1)"})," or appropriate base case"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Off-by-one errors"}),": Be careful with indices in range queries"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Negative remainders"}),": In JavaScript, handle ",(0,i.jsx)(e.code,{children:"remainder < 0"})," case for modulo operations"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"First occurrence only"}),": For maximum length problems, store only first occurrence of prefix sum"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Transform problems"}),": Recognize when to convert (e.g., 0\u2192-1) to use prefix sum"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"debugging-tips",children:"Debugging Tips"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// Add logging to debug prefix sum problems\nfunction debugSubarraySum(nums, k) {\n  const prefixSumCount = new Map();\n  prefixSumCount.set(0, 1);\n\n  let prefixSum = 0;\n  let count = 0;\n\n  console.log('Initial state:', {\n    prefixSumCount: new Map(prefixSumCount),\n    prefixSum,\n    count,\n  });\n\n  for (let i = 0; i < nums.length; i++) {\n    prefixSum += nums[i];\n\n    console.log(`After adding nums[${i}]=${nums[i]}:`, { prefixSum });\n    console.log(`Looking for: ${prefixSum - k}`);\n\n    if (prefixSumCount.has(prefixSum - k)) {\n      const increment = prefixSumCount.get(prefixSum - k);\n      count += increment;\n      console.log(`Found ${increment} occurrences, count now: ${count}`);\n    }\n\n    prefixSumCount.set(prefixSum, (prefixSumCount.get(prefixSum) || 0) + 1);\n    console.log('Updated map:', new Map(prefixSumCount));\n    console.log('---');\n  }\n\n  return count;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"optimization-techniques",children:"Optimization Techniques"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Space optimization"}),": Sometimes you can avoid storing entire prefix sum array"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"In-place modifications"}),": For some problems, modify input array directly"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Early termination"}),": Add conditions to break early when possible"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Mathematical formulas"}),": Some problems have closed-form solutions"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"advanced-variations",children:"Advanced Variations"}),"\n",(0,i.jsx)(e.h4,{id:"multi-dimensional-prefix-sum",children:"Multi-dimensional Prefix Sum"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// 3D prefix sum for volume queries\nfunction build3DPrefix(matrix3D) {\n  const [x, y, z] = [\n    matrix3D.length,\n    matrix3D[0].length,\n    matrix3D[0][0].length,\n  ];\n  const prefix = Array(x + 1)\n    .fill(null)\n    .map(() =>\n      Array(y + 1)\n        .fill(null)\n        .map(() => Array(z + 1).fill(0))\n    );\n\n  for (let i = 1; i <= x; i++) {\n    for (let j = 1; j <= y; j++) {\n      for (let k = 1; k <= z; k++) {\n        prefix[i][j][k] =\n          matrix3D[i - 1][j - 1][k - 1] +\n          prefix[i - 1][j][k] +\n          prefix[i][j - 1][k] +\n          prefix[i][j][k - 1] -\n          prefix[i - 1][j - 1][k] -\n          prefix[i - 1][j][k - 1] -\n          prefix[i][j - 1][k - 1] +\n          prefix[i - 1][j - 1][k - 1];\n      }\n    }\n  }\n\n  return prefix;\n}\n"})}),"\n",(0,i.jsx)(e.h4,{id:"lazy-propagation-with-prefix-sum",children:"Lazy Propagation with Prefix Sum"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"class LazyPrefixSum {\n  constructor(n) {\n    this.n = n;\n    this.lazy = new Array(n + 1).fill(0);\n    this.computed = false;\n    this.arr = new Array(n).fill(0);\n  }\n\n  rangeUpdate(left, right, val) {\n    this.lazy[left] += val;\n    this.lazy[right + 1] -= val;\n    this.computed = false;\n  }\n\n  query(index) {\n    if (!this.computed) {\n      this.computeArray();\n    }\n    return this.arr[index];\n  }\n\n  computeArray() {\n    let sum = 0;\n    for (let i = 0; i < this.n; i++) {\n      sum += this.lazy[i];\n      this.arr[i] = sum;\n    }\n    this.computed = true;\n  }\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"practice-problems-by-difficulty",children:"Practice Problems by Difficulty"}),"\n",(0,i.jsx)(e.h4,{id:"beginner",children:"Beginner"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"Running Sum of 1d Array"}),"\n",(0,i.jsx)(e.li,{children:"Find Pivot Index"}),"\n",(0,i.jsx)(e.li,{children:"Range Sum Query - Immutable"}),"\n",(0,i.jsx)(e.li,{children:"Left and Right Sum Differences"}),"\n"]}),"\n",(0,i.jsx)(e.h4,{id:"intermediate",children:"Intermediate"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"Subarray Sum Equals K"}),"\n",(0,i.jsx)(e.li,{children:"Continuous Subarray Sum"}),"\n",(0,i.jsx)(e.li,{children:"Subarray Sums Divisible by K"}),"\n",(0,i.jsx)(e.li,{children:"Contiguous Array"}),"\n",(0,i.jsx)(e.li,{children:"Maximum Size Subarray Sum Equals K"}),"\n"]}),"\n",(0,i.jsx)(e.h4,{id:"advanced",children:"Advanced"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"Number of Submatrices That Sum to Target"}),"\n",(0,i.jsx)(e.li,{children:"Maximum XOR of Two Numbers in Array"}),"\n",(0,i.jsx)(e.li,{children:"Count of Range Sum of BST"}),"\n",(0,i.jsx)(e.li,{children:"Sum of All Odd Length Subarrays"}),"\n",(0,i.jsx)(e.li,{children:"Minimum Operations to Make Array Equal"}),"\n"]}),"\n",(0,i.jsx)(e.h4,{id:"expert",children:"Expert"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"Count Subarrays with Fixed Bounds"}),"\n",(0,i.jsx)(e.li,{children:"Number of Subsequences That Satisfy Sum Condition"}),"\n",(0,i.jsx)(e.li,{children:"Minimum Number of K Consecutive Bit Flips"}),"\n",(0,i.jsx)(e.li,{children:"Maximum Sum of 3 Non-Overlapping Subarrays"}),"\n"]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(e.p,{children:"Prefix sum is one of the most versatile techniques in competitive programming and interviews. Key takeaways:"}),"\n",(0,i.jsx)(e.h3,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Preprocessing"}),": Build prefix sum in O(n) time for O(1) queries"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"HashMap combination"}),": Enables O(n) solutions for subarray problems"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Transformation"}),": Convert problems to use prefix sum (e.g., 0\u2192-1)"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Range operations"}),": Difference arrays for efficient range updates"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"master-these-patterns",children:"Master These Patterns"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"Basic range sum queries"}),"\n",(0,i.jsx)(e.li,{children:"Subarray sum with target using HashMap"}),"\n",(0,i.jsx)(e.li,{children:"2D matrix rectangle sum queries"}),"\n",(0,i.jsx)(e.li,{children:"XOR/bitwise operations on ranges"}),"\n",(0,i.jsx)(e.li,{children:"Modulo arithmetic with remainders"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"problem-solving-strategy",children:"Problem Solving Strategy"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Identify"}),": Look for subarray/range sum keywords"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Transform"}),": Convert problem if needed (balance, frequency)"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Choose approach"}),": Basic prefix vs HashMap vs 2D vs XOR"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Handle edge cases"}),": Empty subarrays, negative numbers, modulo"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Optimize"}),": Consider space/time tradeoffs"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"Master prefix sum techniques and you'll have a powerful tool for solving a wide range of array and matrix problems efficiently!"})]})}function c(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(m,{...n})}):m(n)}}}]);