"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[9764],{28453:(n,e,t)=>{t.d(e,{R:()=>s,x:()=>c});var i=t(96540);const r={},a=i.createContext(r);function s(n){const e=i.useContext(a);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function c(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:s(n.components),i.createElement(a.Provider,{value:e},n.children)}},94182:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>a,metadata:()=>c,toc:()=>o});var i=t(74848),r=t(28453);const a={},s="Stack",c={id:"DSA/DSA with Java/Stack Patterns",title:"Stack",description:"Table of Contents",source:"@site/docs/DSA/DSA with Java/Stack Patterns.mdx",sourceDirName:"DSA/DSA with Java",slug:"/DSA/DSA with Java/Stack Patterns",permalink:"/dev.enigma/docs/DSA/DSA with Java/Stack Patterns",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with Java/Stack Patterns.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Sorting Algorithms Guide",permalink:"/dev.enigma/docs/DSA/DSA with Java/Sorting Algorithms"},next:{title:"String",permalink:"/dev.enigma/docs/DSA/DSA with Java/String Patterns"}},l={},o=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Stack Fundamentals",id:"stack-fundamentals",level:2},{value:"Core Stack Implementation",id:"core-stack-implementation",level:3},{value:"Pattern 1: Basic Stack Operations",id:"pattern-1-basic-stack-operations",level:2},{value:"1.1 Stack Using Queues",id:"11-stack-using-queues",level:3},{value:"1.2 Queue Using Stacks",id:"12-queue-using-stacks",level:3},{value:"1.3 Stack Sorting",id:"13-stack-sorting",level:3},{value:"Pattern 2: Expression Evaluation",id:"pattern-2-expression-evaluation",level:2},{value:"2.1 Arithmetic Expression Evaluation",id:"21-arithmetic-expression-evaluation",level:3},{value:"2.2 Calculator Implementation",id:"22-calculator-implementation",level:3},{value:"Pattern 3: Parentheses &amp; Bracket Matching",id:"pattern-3-parentheses--bracket-matching",level:2},{value:"3.1 Valid Parentheses",id:"31-valid-parentheses",level:3},{value:"3.2 Advanced Parentheses Problems",id:"32-advanced-parentheses-problems",level:3},{value:"Pattern 4: Monotonic Stack - Next Greater/Smaller",id:"pattern-4-monotonic-stack---next-greatersmaller",level:2},{value:"4.1 Next Greater Element",id:"41-next-greater-element",level:3},{value:"4.2 Next Smaller Element",id:"42-next-smaller-element",level:3},{value:"4.3 Daily Temperatures",id:"43-daily-temperatures",level:3},{value:"Pattern 5: Monotonic Stack - Advanced Problems",id:"pattern-5-monotonic-stack---advanced-problems",level:2},{value:"5.1 Largest Rectangle in Histogram",id:"51-largest-rectangle-in-histogram",level:3},{value:"5.2 Maximal Rectangle",id:"52-maximal-rectangle",level:3},{value:"5.3 Trapping Rain Water",id:"53-trapping-rain-water",level:3},{value:"5.4 Stock Span Problem",id:"54-stock-span-problem",level:3},{value:"Pattern 6: Stack with Enhanced Operations",id:"pattern-6-stack-with-enhanced-operations",level:2},{value:"6.1 Min Stack",id:"61-min-stack",level:3},{value:"6.2 Max Stack",id:"62-max-stack",level:3},{value:"6.3 Stack with Middle Operations",id:"63-stack-with-middle-operations",level:3},{value:"Pattern 7: Function Call Stack Simulation",id:"pattern-7-function-call-stack-simulation",level:2},{value:"7.1 Iterative Tree Traversal",id:"71-iterative-tree-traversal",level:3},{value:"7.2 DFS Graph Traversal",id:"72-dfs-graph-traversal",level:3},{value:"Pattern 8: Stack-Based String Processing",id:"pattern-8-stack-based-string-processing",level:2},{value:"8.1 String Manipulation",id:"81-string-manipulation",level:3},{value:"8.2 String Decoding",id:"82-string-decoding",level:3},{value:"Pattern 9: Stack for Tree &amp; Graph Problems",id:"pattern-9-stack-for-tree--graph-problems",level:2},{value:"9.1 Binary Tree Problems",id:"91-binary-tree-problems",level:3},{value:"9.2 Graph Algorithms",id:"92-graph-algorithms",level:3},{value:"Pattern 10: Stack-Based Optimization",id:"pattern-10-stack-based-optimization",level:2},{value:"10.1 Sliding Window Maximum",id:"101-sliding-window-maximum",level:3},{value:"10.2 Constrained Subsequence Sum",id:"102-constrained-subsequence-sum",level:3},{value:"Pattern 11: Multi-Stack Problems",id:"pattern-11-multi-stack-problems",level:2},{value:"11.1 Three Stacks in Array",id:"111-three-stacks-in-array",level:3},{value:"11.2 Set of Stacks",id:"112-set-of-stacks",level:3},{value:"Pattern 12: Advanced Stack Applications",id:"pattern-12-advanced-stack-applications",level:2},{value:"12.1 Asteroid Collision",id:"121-asteroid-collision",level:3},{value:"12.2 Car Fleet",id:"122-car-fleet",level:3},{value:"12.3 Sum of Subarray Minimums",id:"123-sum-of-subarray-minimums",level:3},{value:"Time &amp; Space Complexity Reference",id:"time--space-complexity-reference",level:2},{value:"Best Practices &amp; Optimization Tips",id:"best-practices--optimization-tips",level:2},{value:"Monotonic Stack Guidelines",id:"monotonic-stack-guidelines",level:3},{value:"Common Optimizations",id:"common-optimizations",level:3},{value:"Interview Tips",id:"interview-tips",level:3}];function p(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"stack",children:"Stack"})}),"\n",(0,i.jsx)(e.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#stack-fundamentals",children:"Stack Fundamentals"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#pattern-1-basic-stack-operations",children:"Pattern 1: Basic Stack Operations"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#pattern-2-expression-evaluation",children:"Pattern 2: Expression Evaluation"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#pattern-3-parentheses--bracket-matching",children:"Pattern 3: Parentheses & Bracket Matching"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#pattern-4-monotonic-stack---next-greatersmaller",children:"Pattern 4: Monotonic Stack - Next Greater/Smaller"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#pattern-5-monotonic-stack---advanced-problems",children:"Pattern 5: Monotonic Stack - Advanced Problems"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#pattern-6-stack-with-enhanced-operations",children:"Pattern 6: Stack with Enhanced Operations"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#pattern-7-function-call-stack-simulation",children:"Pattern 7: Function Call Stack Simulation"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#pattern-8-stack-based-string-processing",children:"Pattern 8: Stack-Based String Processing"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#pattern-9-stack-for-tree--graph-problems",children:"Pattern 9: Stack for Tree & Graph Problems"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#pattern-10-stack-based-optimization",children:"Pattern 10: Stack-Based Optimization"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#pattern-11-multi-stack-problems",children:"Pattern 11: Multi-Stack Problems"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#pattern-12-advanced-stack-applications",children:"Pattern 12: Advanced Stack Applications"})}),"\n"]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"stack-fundamentals",children:"Stack Fundamentals"}),"\n",(0,i.jsx)(e.h3,{id:"core-stack-implementation",children:"Core Stack Implementation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'// Basic Stack Interface\ninterface Stack<T> {\n    void push(T item);\n    T pop();\n    T peek();\n    boolean isEmpty();\n    int size();\n}\n\n// Array-based Stack Implementation\nclass ArrayStack<T> implements Stack<T> {\n    private T[] stack;\n    private int top;\n    private int capacity;\n\n    @SuppressWarnings("unchecked")\n    public ArrayStack(int capacity) {\n        this.capacity = capacity;\n        this.stack = (T[]) new Object[capacity];\n        this.top = -1;\n    }\n\n    @Override\n    public void push(T item) {\n        if (top >= capacity - 1) {\n            throw new StackOverflowError("Stack is full");\n        }\n        stack[++top] = item;\n    }\n\n    @Override\n    public T pop() {\n        if (isEmpty()) {\n            throw new EmptyStackException();\n        }\n        T item = stack[top];\n        stack[top--] = null; // Help GC\n        return item;\n    }\n\n    @Override\n    public T peek() {\n        if (isEmpty()) {\n            throw new EmptyStackException();\n        }\n        return stack[top];\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return top == -1;\n    }\n\n    @Override\n    public int size() {\n        return top + 1;\n    }\n}\n\n// LinkedList-based Stack Implementation\nclass LinkedStack<T> implements Stack<T> {\n    private Node<T> top;\n    private int size;\n\n    private static class Node<T> {\n        T data;\n        Node<T> next;\n\n        Node(T data) {\n            this.data = data;\n        }\n    }\n\n    @Override\n    public void push(T item) {\n        Node<T> newNode = new Node<>(item);\n        newNode.next = top;\n        top = newNode;\n        size++;\n    }\n\n    @Override\n    public T pop() {\n        if (isEmpty()) {\n            throw new EmptyStackException();\n        }\n        T data = top.data;\n        top = top.next;\n        size--;\n        return data;\n    }\n\n    @Override\n    public T peek() {\n        if (isEmpty()) {\n            throw new EmptyStackException();\n        }\n        return top.data;\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return top == null;\n    }\n\n    @Override\n    public int size() {\n        return size;\n    }\n}\n\n// Dynamic Array Stack (Resizable)\nclass DynamicStack<T> implements Stack<T> {\n    private T[] stack;\n    private int top;\n    private int capacity;\n\n    @SuppressWarnings("unchecked")\n    public DynamicStack() {\n        this.capacity = 10;\n        this.stack = (T[]) new Object[capacity];\n        this.top = -1;\n    }\n\n    @Override\n    public void push(T item) {\n        if (top >= capacity - 1) {\n            resize();\n        }\n        stack[++top] = item;\n    }\n\n    @SuppressWarnings("unchecked")\n    private void resize() {\n        capacity *= 2;\n        T[] newStack = (T[]) new Object[capacity];\n        System.arraycopy(stack, 0, newStack, 0, top + 1);\n        stack = newStack;\n    }\n\n    @Override\n    public T pop() {\n        if (isEmpty()) {\n            throw new EmptyStackException();\n        }\n        T item = stack[top];\n        stack[top--] = null;\n\n        // Shrink if necessary\n        if (top > 0 && top == capacity / 4) {\n            shrink();\n        }\n\n        return item;\n    }\n\n    @SuppressWarnings("unchecked")\n    private void shrink() {\n        capacity /= 2;\n        T[] newStack = (T[]) new Object[capacity];\n        System.arraycopy(stack, 0, newStack, 0, top + 1);\n        stack = newStack;\n    }\n\n    @Override\n    public T peek() {\n        if (isEmpty()) {\n            throw new EmptyStackException();\n        }\n        return stack[top];\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return top == -1;\n    }\n\n    @Override\n    public int size() {\n        return top + 1;\n    }\n}\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"pattern-1-basic-stack-operations",children:"Pattern 1: Basic Stack Operations"}),"\n",(0,i.jsx)(e.h3,{id:"11-stack-using-queues",children:"1.1 Stack Using Queues"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Implement Stack using Two Queues\nclass MyStack {\n    private Queue<Integer> queue1;\n    private Queue<Integer> queue2;\n\n    public MyStack() {\n        queue1 = new LinkedList<>();\n        queue2 = new LinkedList<>();\n    }\n\n    public void push(int x) {\n        queue2.offer(x);\n\n        // Move all elements from queue1 to queue2\n        while (!queue1.isEmpty()) {\n            queue2.offer(queue1.poll());\n        }\n\n        // Swap names of two queues\n        Queue<Integer> temp = queue1;\n        queue1 = queue2;\n        queue2 = temp;\n    }\n\n    public int pop() {\n        return queue1.poll();\n    }\n\n    public int top() {\n        return queue1.peek();\n    }\n\n    public boolean empty() {\n        return queue1.isEmpty();\n    }\n}\n\n// Implement Stack using Single Queue\nclass MyStackSingleQueue {\n    private Queue<Integer> queue;\n\n    public MyStackSingleQueue() {\n        queue = new LinkedList<>();\n    }\n\n    public void push(int x) {\n        int size = queue.size();\n        queue.offer(x);\n\n        // Rotate the queue\n        for (int i = 0; i < size; i++) {\n            queue.offer(queue.poll());\n        }\n    }\n\n    public int pop() {\n        return queue.poll();\n    }\n\n    public int top() {\n        return queue.peek();\n    }\n\n    public boolean empty() {\n        return queue.isEmpty();\n    }\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"12-queue-using-stacks",children:"1.2 Queue Using Stacks"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Implement Queue using Two Stacks\nclass MyQueue {\n    private Stack<Integer> input;\n    private Stack<Integer> output;\n\n    public MyQueue() {\n        input = new Stack<>();\n        output = new Stack<>();\n    }\n\n    public void push(int x) {\n        input.push(x);\n    }\n\n    public int pop() {\n        peek(); // Ensure output stack has elements\n        return output.pop();\n    }\n\n    public int peek() {\n        if (output.isEmpty()) {\n            while (!input.isEmpty()) {\n                output.push(input.pop());\n            }\n        }\n        return output.peek();\n    }\n\n    public boolean empty() {\n        return input.isEmpty() && output.isEmpty();\n    }\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"13-stack-sorting",children:"1.3 Stack Sorting"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Sort Stack using Temporary Stack\npublic Stack<Integer> sortStack(Stack<Integer> stack) {\n    Stack<Integer> tempStack = new Stack<>();\n\n    while (!stack.isEmpty()) {\n        int temp = stack.pop();\n\n        // Move elements from tempStack back to stack while temp > tempStack.peek()\n        while (!tempStack.isEmpty() && tempStack.peek() > temp) {\n            stack.push(tempStack.pop());\n        }\n\n        tempStack.push(temp);\n    }\n\n    return tempStack; // Returns sorted stack (smallest on top)\n}\n\n// Sort Stack using Recursion\npublic void sortStackRecursive(Stack<Integer> stack) {\n    if (!stack.isEmpty()) {\n        int temp = stack.pop();\n        sortStackRecursive(stack);\n        insertInSorted(stack, temp);\n    }\n}\n\nprivate void insertInSorted(Stack<Integer> stack, int element) {\n    if (stack.isEmpty() || stack.peek() <= element) {\n        stack.push(element);\n        return;\n    }\n\n    int temp = stack.pop();\n    insertInSorted(stack, element);\n    stack.push(temp);\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"pattern-2-expression-evaluation",children:"Pattern 2: Expression Evaluation"}),"\n",(0,i.jsx)(e.h3,{id:"21-arithmetic-expression-evaluation",children:"2.1 Arithmetic Expression Evaluation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Evaluate Postfix Expression\npublic int evalRPN(String[] tokens) {\n    Stack<Integer> stack = new Stack<>();\n\n    for (String token : tokens) {\n        if (isOperator(token)) {\n            int b = stack.pop();\n            int a = stack.pop();\n            int result = performOperation(a, b, token);\n            stack.push(result);\n        } else {\n            stack.push(Integer.parseInt(token));\n        }\n    }\n\n    return stack.pop();\n}\n\nprivate boolean isOperator(String token) {\n    return token.equals(\"+\") || token.equals(\"-\") ||\n           token.equals(\"*\") || token.equals(\"/\");\n}\n\nprivate int performOperation(int a, int b, String operator) {\n    switch (operator) {\n        case \"+\": return a + b;\n        case \"-\": return a - b;\n        case \"*\": return a * b;\n        case \"/\": return a / b;\n        default: throw new IllegalArgumentException(\"Invalid operator\");\n    }\n}\n\n// Infix to Postfix Conversion\npublic String infixToPostfix(String infix) {\n    StringBuilder result = new StringBuilder();\n    Stack<Character> stack = new Stack<>();\n\n    for (char c : infix.toCharArray()) {\n        if (Character.isLetterOrDigit(c)) {\n            result.append(c);\n        } else if (c == '(') {\n            stack.push(c);\n        } else if (c == ')') {\n            while (!stack.isEmpty() && stack.peek() != '(') {\n                result.append(stack.pop());\n            }\n            stack.pop(); // Remove '('\n        } else if (isOperator(String.valueOf(c))) {\n            while (!stack.isEmpty() &&\n                   getPrecedence(c) <= getPrecedence(stack.peek())) {\n                result.append(stack.pop());\n            }\n            stack.push(c);\n        }\n    }\n\n    while (!stack.isEmpty()) {\n        result.append(stack.pop());\n    }\n\n    return result.toString();\n}\n\nprivate int getPrecedence(char operator) {\n    switch (operator) {\n        case '+':\n        case '-': return 1;\n        case '*':\n        case '/': return 2;\n        case '^': return 3;\n        default: return -1;\n    }\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"22-calculator-implementation",children:"2.2 Calculator Implementation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Basic Calculator (with +, -, (, ))\npublic int calculate(String s) {\n    Stack<Integer> stack = new Stack<>();\n    int result = 0;\n    int number = 0;\n    int sign = 1;\n\n    for (int i = 0; i < s.length(); i++) {\n        char c = s.charAt(i);\n\n        if (Character.isDigit(c)) {\n            number = 10 * number + (c - '0');\n        } else if (c == '+') {\n            result += sign * number;\n            number = 0;\n            sign = 1;\n        } else if (c == '-') {\n            result += sign * number;\n            number = 0;\n            sign = -1;\n        } else if (c == '(') {\n            stack.push(result);\n            stack.push(sign);\n            result = 0;\n            sign = 1;\n        } else if (c == ')') {\n            result += sign * number;\n            number = 0;\n            result *= stack.pop(); // sign\n            result += stack.pop(); // previous result\n        }\n    }\n\n    return result + (sign * number);\n}\n\n// Basic Calculator II (with +, -, *, /)\npublic int calculateII(String s) {\n    Stack<Integer> stack = new Stack<>();\n    int number = 0;\n    char operation = '+';\n\n    for (int i = 0; i < s.length(); i++) {\n        char c = s.charAt(i);\n\n        if (Character.isDigit(c)) {\n            number = (number * 10) + (c - '0');\n        }\n\n        if (c == '+' || c == '-' || c == '*' || c == '/' || i == s.length() - 1) {\n            if (operation == '+') {\n                stack.push(number);\n            } else if (operation == '-') {\n                stack.push(-number);\n            } else if (operation == '*') {\n                stack.push(stack.pop() * number);\n            } else if (operation == '/') {\n                stack.push(stack.pop() / number);\n            }\n\n            operation = c;\n            number = 0;\n        }\n    }\n\n    int result = 0;\n    while (!stack.isEmpty()) {\n        result += stack.pop();\n    }\n\n    return result;\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"pattern-3-parentheses--bracket-matching",children:"Pattern 3: Parentheses & Bracket Matching"}),"\n",(0,i.jsx)(e.h3,{id:"31-valid-parentheses",children:"3.1 Valid Parentheses"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Basic Valid Parentheses\npublic boolean isValid(String s) {\n    Stack<Character> stack = new Stack<>();\n\n    for (char c : s.toCharArray()) {\n        if (c == '(' || c == '[' || c == '{') {\n            stack.push(c);\n        } else {\n            if (stack.isEmpty()) return false;\n\n            char top = stack.pop();\n            if ((c == ')' && top != '(') ||\n                (c == ']' && top != '[') ||\n                (c == '}' && top != '{')) {\n                return false;\n            }\n        }\n    }\n\n    return stack.isEmpty();\n}\n\n// Valid Parentheses with Map\npublic boolean isValidWithMap(String s) {\n    Map<Character, Character> mapping = new HashMap<>();\n    mapping.put(')', '(');\n    mapping.put(']', '[');\n    mapping.put('}', '{');\n\n    Stack<Character> stack = new Stack<>();\n\n    for (char c : s.toCharArray()) {\n        if (mapping.containsKey(c)) {\n            if (stack.isEmpty() || stack.pop() != mapping.get(c)) {\n                return false;\n            }\n        } else {\n            stack.push(c);\n        }\n    }\n\n    return stack.isEmpty();\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"32-advanced-parentheses-problems",children:"3.2 Advanced Parentheses Problems"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Longest Valid Parentheses\npublic int longestValidParentheses(String s) {\n    Stack<Integer> stack = new Stack<>();\n    stack.push(-1); // Base for valid substring\n    int maxLen = 0;\n\n    for (int i = 0; i < s.length(); i++) {\n        if (s.charAt(i) == '(') {\n            stack.push(i);\n        } else {\n            stack.pop();\n            if (stack.isEmpty()) {\n                stack.push(i); // New base\n            } else {\n                maxLen = Math.max(maxLen, i - stack.peek());\n            }\n        }\n    }\n\n    return maxLen;\n}\n\n// Generate Parentheses\npublic List<String> generateParenthesis(int n) {\n    List<String> result = new ArrayList<>();\n    backtrack(result, \"\", 0, 0, n);\n    return result;\n}\n\nprivate void backtrack(List<String> result, String current, int open, int close, int max) {\n    if (current.length() == max * 2) {\n        result.add(current);\n        return;\n    }\n\n    if (open < max) {\n        backtrack(result, current + \"(\", open + 1, close, max);\n    }\n\n    if (close < open) {\n        backtrack(result, current + \")\", open, close + 1, max);\n    }\n}\n\n// Remove Invalid Parentheses\npublic List<String> removeInvalidParentheses(String s) {\n    List<String> result = new ArrayList<>();\n    if (s == null) return result;\n\n    Set<String> visited = new HashSet<>();\n    Queue<String> queue = new LinkedList<>();\n\n    queue.offer(s);\n    visited.add(s);\n    boolean found = false;\n\n    while (!queue.isEmpty()) {\n        String str = queue.poll();\n\n        if (isValidParentheses(str)) {\n            result.add(str);\n            found = true;\n        }\n\n        if (found) continue; // Only find minimum removals\n\n        for (int i = 0; i < str.length(); i++) {\n            if (str.charAt(i) != '(' && str.charAt(i) != ')') continue;\n\n            String t = str.substring(0, i) + str.substring(i + 1);\n            if (!visited.contains(t)) {\n                queue.offer(t);\n                visited.add(t);\n            }\n        }\n    }\n\n    return result;\n}\n\nprivate boolean isValidParentheses(String s) {\n    int count = 0;\n    for (char c : s.toCharArray()) {\n        if (c == '(') count++;\n        else if (c == ')') count--;\n        if (count < 0) return false;\n    }\n    return count == 0;\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"pattern-4-monotonic-stack---next-greatersmaller",children:"Pattern 4: Monotonic Stack - Next Greater/Smaller"}),"\n",(0,i.jsx)(e.h3,{id:"41-next-greater-element",children:"4.1 Next Greater Element"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Next Greater Element I\npublic int[] nextGreaterElement(int[] nums1, int[] nums2) {\n    Map<Integer, Integer> map = new HashMap<>();\n    Stack<Integer> stack = new Stack<>();\n\n    // Build next greater mapping for nums2\n    for (int num : nums2) {\n        while (!stack.isEmpty() && stack.peek() < num) {\n            map.put(stack.pop(), num);\n        }\n        stack.push(num);\n    }\n\n    int[] result = new int[nums1.length];\n    for (int i = 0; i < nums1.length; i++) {\n        result[i] = map.getOrDefault(nums1[i], -1);\n    }\n\n    return result;\n}\n\n// Next Greater Element II (Circular Array)\npublic int[] nextGreaterElements(int[] nums) {\n    int n = nums.length;\n    int[] result = new int[n];\n    Arrays.fill(result, -1);\n    Stack<Integer> stack = new Stack<>(); // Store indices\n\n    // Process array twice for circular behavior\n    for (int i = 0; i < 2 * n; i++) {\n        while (!stack.isEmpty() && nums[stack.peek()] < nums[i % n]) {\n            result[stack.pop()] = nums[i % n];\n        }\n\n        if (i < n) {\n            stack.push(i);\n        }\n    }\n\n    return result;\n}\n\n// Generic Next Greater Element Template\npublic int[] nextGreater(int[] arr) {\n    int n = arr.length;\n    int[] result = new int[n];\n    Arrays.fill(result, -1);\n    Stack<Integer> stack = new Stack<>(); // Monotonic decreasing stack\n\n    for (int i = 0; i < n; i++) {\n        while (!stack.isEmpty() && arr[stack.peek()] < arr[i]) {\n            result[stack.pop()] = arr[i];\n        }\n        stack.push(i);\n    }\n\n    return result;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"42-next-smaller-element",children:"4.2 Next Smaller Element"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Next Smaller Element\npublic int[] nextSmallerElement(int[] arr) {\n    int n = arr.length;\n    int[] result = new int[n];\n    Arrays.fill(result, -1);\n    Stack<Integer> stack = new Stack<>(); // Monotonic increasing stack\n\n    for (int i = 0; i < n; i++) {\n        while (!stack.isEmpty() && arr[stack.peek()] > arr[i]) {\n            result[stack.pop()] = arr[i];\n        }\n        stack.push(i);\n    }\n\n    return result;\n}\n\n// Previous Smaller Element\npublic int[] previousSmallerElement(int[] arr) {\n    int n = arr.length;\n    int[] result = new int[n];\n    Arrays.fill(result, -1);\n    Stack<Integer> stack = new Stack<>(); // Monotonic increasing stack\n\n    for (int i = 0; i < n; i++) {\n        while (!stack.isEmpty() && arr[stack.peek()] >= arr[i]) {\n            stack.pop();\n        }\n\n        if (!stack.isEmpty()) {\n            result[i] = arr[stack.peek()];\n        }\n\n        stack.push(i);\n    }\n\n    return result;\n}\n\n// Previous Greater Element\npublic int[] previousGreaterElement(int[] arr) {\n    int n = arr.length;\n    int[] result = new int[n];\n    Arrays.fill(result, -1);\n    Stack<Integer> stack = new Stack<>(); // Monotonic decreasing stack\n\n    for (int i = 0; i < n; i++) {\n        while (!stack.isEmpty() && arr[stack.peek()] <= arr[i]) {\n            stack.pop();\n        }\n\n        if (!stack.isEmpty()) {\n            result[i] = arr[stack.peek()];\n        }\n\n        stack.push(i);\n    }\n\n    return result;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"43-daily-temperatures",children:"4.3 Daily Temperatures"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Daily Temperatures (Next Warmer Day)\npublic int[] dailyTemperatures(int[] temperatures) {\n    int n = temperatures.length;\n    int[] result = new int[n];\n    Stack<Integer> stack = new Stack<>(); // Store indices\n\n    for (int i = 0; i < n; i++) {\n        while (!stack.isEmpty() && temperatures[stack.peek()] < temperatures[i]) {\n            int idx = stack.pop();\n            result[idx] = i - idx; // Days to wait\n        }\n        stack.push(i);\n    }\n\n    return result;\n}\n\n// Optimized Daily Temperatures (Backward Pass)\npublic int[] dailyTemperaturesOptimized(int[] temperatures) {\n    int n = temperatures.length;\n    int[] result = new int[n];\n\n    for (int i = n - 2; i >= 0; i--) {\n        int j = i + 1;\n        while (j < n && temperatures[j] <= temperatures[i]) {\n            if (result[j] > 0) {\n                j += result[j];\n            } else {\n                j = n; // No warmer day found\n            }\n        }\n\n        if (j < n) {\n            result[i] = j - i;\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"pattern-5-monotonic-stack---advanced-problems",children:"Pattern 5: Monotonic Stack - Advanced Problems"}),"\n",(0,i.jsx)(e.h3,{id:"51-largest-rectangle-in-histogram",children:"5.1 Largest Rectangle in Histogram"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Largest Rectangle in Histogram\npublic int largestRectangleArea(int[] heights) {\n    Stack<Integer> stack = new Stack<>(); // Store indices\n    int maxArea = 0;\n\n    for (int i = 0; i <= heights.length; i++) {\n        int currentHeight = (i == heights.length) ? 0 : heights[i];\n\n        while (!stack.isEmpty() && heights[stack.peek()] > currentHeight) {\n            int height = heights[stack.pop()];\n            int width = stack.isEmpty() ? i : i - stack.peek() - 1;\n            maxArea = Math.max(maxArea, height * width);\n        }\n\n        stack.push(i);\n    }\n\n    return maxArea;\n}\n\n// Largest Rectangle using Previous/Next Smaller\npublic int largestRectangleAreaAlternative(int[] heights) {\n    int n = heights.length;\n    int[] prevSmaller = previousSmallerIndices(heights);\n    int[] nextSmaller = nextSmallerIndices(heights);\n\n    int maxArea = 0;\n    for (int i = 0; i < n; i++) {\n        int width = nextSmaller[i] - prevSmaller[i] - 1;\n        maxArea = Math.max(maxArea, heights[i] * width);\n    }\n\n    return maxArea;\n}\n\nprivate int[] previousSmallerIndices(int[] heights) {\n    int n = heights.length;\n    int[] result = new int[n];\n    Stack<Integer> stack = new Stack<>();\n\n    for (int i = 0; i < n; i++) {\n        while (!stack.isEmpty() && heights[stack.peek()] >= heights[i]) {\n            stack.pop();\n        }\n        result[i] = stack.isEmpty() ? -1 : stack.peek();\n        stack.push(i);\n    }\n\n    return result;\n}\n\nprivate int[] nextSmallerIndices(int[] heights) {\n    int n = heights.length;\n    int[] result = new int[n];\n    Stack<Integer> stack = new Stack<>();\n\n    for (int i = n - 1; i >= 0; i--) {\n        while (!stack.isEmpty() && heights[stack.peek()] >= heights[i]) {\n            stack.pop();\n        }\n        result[i] = stack.isEmpty() ? n : stack.peek();\n        stack.push(i);\n    }\n\n    return result;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"52-maximal-rectangle",children:"5.2 Maximal Rectangle"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Maximal Rectangle in Binary Matrix\npublic int maximalRectangle(char[][] matrix) {\n    if (matrix.length == 0) return 0;\n\n    int m = matrix.length, n = matrix[0].length;\n    int[] heights = new int[n];\n    int maxArea = 0;\n\n    for (int i = 0; i < m; i++) {\n        // Update heights array\n        for (int j = 0; j < n; j++) {\n            heights[j] = matrix[i][j] == '1' ? heights[j] + 1 : 0;\n        }\n\n        // Find max rectangle in current histogram\n        maxArea = Math.max(maxArea, largestRectangleArea(heights));\n    }\n\n    return maxArea;\n}\n\n// Using DP approach for Maximal Rectangle\npublic int maximalRectangleDP(char[][] matrix) {\n    if (matrix.length == 0) return 0;\n\n    int m = matrix.length, n = matrix[0].length;\n    int[] left = new int[n];  // Left boundary of rectangle ending at current row\n    int[] right = new int[n]; // Right boundary of rectangle ending at current row\n    int[] height = new int[n]; // Height of rectangle ending at current row\n\n    Arrays.fill(right, n);\n    int maxArea = 0;\n\n    for (int i = 0; i < m; i++) {\n        int curLeft = 0, curRight = n;\n\n        // Update height\n        for (int j = 0; j < n; j++) {\n            height[j] = matrix[i][j] == '1' ? height[j] + 1 : 0;\n        }\n\n        // Update left\n        for (int j = 0; j < n; j++) {\n            if (matrix[i][j] == '1') {\n                left[j] = Math.max(left[j], curLeft);\n            } else {\n                left[j] = 0;\n                curLeft = j + 1;\n            }\n        }\n\n        // Update right\n        for (int j = n - 1; j >= 0; j--) {\n            if (matrix[i][j] == '1') {\n                right[j] = Math.min(right[j], curRight);\n            } else {\n                right[j] = n;\n                curRight = j;\n            }\n        }\n\n        // Calculate area\n        for (int j = 0; j < n; j++) {\n            maxArea = Math.max(maxArea, (right[j] - left[j]) * height[j]);\n        }\n    }\n\n    return maxArea;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"53-trapping-rain-water",children:"5.3 Trapping Rain Water"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Trapping Rain Water using Monotonic Stack\npublic int trap(int[] height) {\n    Stack<Integer> stack = new Stack<>();\n    int water = 0;\n\n    for (int i = 0; i < height.length; i++) {\n        while (!stack.isEmpty() && height[i] > height[stack.peek()]) {\n            int top = stack.pop();\n\n            if (stack.isEmpty()) break;\n\n            int distance = i - stack.peek() - 1;\n            int boundedHeight = Math.min(height[i], height[stack.peek()]) - height[top];\n            water += distance * boundedHeight;\n        }\n\n        stack.push(i);\n    }\n\n    return water;\n}\n\n// Two Pointer Approach\npublic int trapTwoPointer(int[] height) {\n    if (height.length == 0) return 0;\n\n    int left = 0, right = height.length - 1;\n    int leftMax = 0, rightMax = 0;\n    int water = 0;\n\n    while (left < right) {\n        if (height[left] < height[right]) {\n            if (height[left] >= leftMax) {\n                leftMax = height[left];\n            } else {\n                water += leftMax - height[left];\n            }\n            left++;\n        } else {\n            if (height[right] >= rightMax) {\n                rightMax = height[right];\n            } else {\n                water += rightMax - height[right];\n            }\n            right--;\n        }\n    }\n\n    return water;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"54-stock-span-problem",children:"5.4 Stock Span Problem"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Stock Span Problem\nclass StockSpanner {\n    private Stack<int[]> stack; // [price, span]\n\n    public StockSpanner() {\n        stack = new Stack<>();\n    }\n\n    public int next(int price) {\n        int span = 1;\n\n        while (!stack.isEmpty() && stack.peek()[0] <= price) {\n            span += stack.pop()[1];\n        }\n\n        stack.push(new int[]{price, span});\n        return span;\n    }\n}\n\n// Stock Span for Array\npublic int[] stockSpan(int[] prices) {\n    int n = prices.length;\n    int[] spans = new int[n];\n    Stack<Integer> stack = new Stack<>(); // Store indices\n\n    for (int i = 0; i < n; i++) {\n        while (!stack.isEmpty() && prices[stack.peek()] <= prices[i]) {\n            stack.pop();\n        }\n\n        spans[i] = stack.isEmpty() ? i + 1 : i - stack.peek();\n        stack.push(i);\n    }\n\n    return spans;\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"pattern-6-stack-with-enhanced-operations",children:"Pattern 6: Stack with Enhanced Operations"}),"\n",(0,i.jsx)(e.h3,{id:"61-min-stack",children:"6.1 Min Stack"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Min Stack Implementation\nclass MinStack {\n    private Stack<Integer> stack;\n    private Stack<Integer> minStack;\n\n    public MinStack() {\n        stack = new Stack<>();\n        minStack = new Stack<>();\n    }\n\n    public void push(int val) {\n        stack.push(val);\n\n        if (minStack.isEmpty() || val <= minStack.peek()) {\n            minStack.push(val);\n        }\n    }\n\n    public void pop() {\n        if (!stack.isEmpty()) {\n            int popped = stack.pop();\n            if (popped == minStack.peek()) {\n                minStack.pop();\n            }\n        }\n    }\n\n    public int top() {\n        return stack.peek();\n    }\n\n    public int getMin() {\n        return minStack.peek();\n    }\n}\n\n// Space Optimized Min Stack\nclass MinStackOptimized {\n    private Stack<Long> stack;\n    private long min;\n\n    public MinStackOptimized() {\n        stack = new Stack<>();\n    }\n\n    public void push(int val) {\n        if (stack.isEmpty()) {\n            min = val;\n            stack.push(0L);\n        } else {\n            stack.push(val - min);\n            if (val < min) {\n                min = val;\n            }\n        }\n    }\n\n    public void pop() {\n        if (!stack.isEmpty()) {\n            long pop = stack.pop();\n            if (pop < 0) {\n                min = min - pop;\n            }\n        }\n    }\n\n    public int top() {\n        long top = stack.peek();\n        return (int) (top < 0 ? min : top + min);\n    }\n\n    public int getMin() {\n        return (int) min;\n    }\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"62-max-stack",children:"6.2 Max Stack"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Max Stack Implementation\nclass MaxStack {\n    private Stack<Integer> stack;\n    private Stack<Integer> maxStack;\n\n    public MaxStack() {\n        stack = new Stack<>();\n        maxStack = new Stack<>();\n    }\n\n    public void push(int x) {\n        stack.push(x);\n\n        if (maxStack.isEmpty() || x >= maxStack.peek()) {\n            maxStack.push(x);\n        }\n    }\n\n    public int pop() {\n        if (!stack.isEmpty()) {\n            int popped = stack.pop();\n            if (popped == maxStack.peek()) {\n                maxStack.pop();\n            }\n            return popped;\n        }\n        return -1;\n    }\n\n    public int top() {\n        return stack.peek();\n    }\n\n    public int peekMax() {\n        return maxStack.peek();\n    }\n\n    public int popMax() {\n        int max = maxStack.peek();\n        Stack<Integer> buffer = new Stack<>();\n\n        while (!stack.isEmpty() && stack.peek() != max) {\n            buffer.push(pop());\n        }\n\n        pop(); // Remove the max element\n\n        while (!buffer.isEmpty()) {\n            push(buffer.pop());\n        }\n\n        return max;\n    }\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"63-stack-with-middle-operations",children:"6.3 Stack with Middle Operations"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Stack with Middle Element Operations\nclass StackWithMiddle {\n    private class Node {\n        int data;\n        Node next, prev;\n\n        Node(int data) {\n            this.data = data;\n        }\n    }\n\n    private Node head, mid;\n    private int count;\n\n    public void push(int x) {\n        Node newNode = new Node(x);\n\n        if (count == 0) {\n            head = mid = newNode;\n        } else {\n            newNode.next = head;\n            head.prev = newNode;\n            head = newNode;\n\n            if (count % 2 == 1) {\n                mid = mid.prev;\n            }\n        }\n        count++;\n    }\n\n    public int pop() {\n        if (count == 0) return -1;\n\n        Node temp = head;\n        int data = temp.data;\n\n        if (count == 1) {\n            head = mid = null;\n        } else {\n            head = head.next;\n            head.prev = null;\n\n            if (count % 2 == 0) {\n                mid = mid.next;\n            }\n        }\n\n        count--;\n        return data;\n    }\n\n    public int findMiddle() {\n        return count == 0 ? -1 : mid.data;\n    }\n\n    public void deleteMiddle() {\n        if (count == 0) return;\n\n        if (count == 1) {\n            head = mid = null;\n        } else if (count == 2) {\n            head = head.next;\n            mid = head;\n            head.prev = null;\n        } else {\n            mid.next.prev = mid.prev;\n            mid.prev.next = mid.next;\n\n            if (count % 2 == 0) {\n                mid = mid.prev;\n            } else {\n                mid = mid.next;\n            }\n        }\n\n        count--;\n    }\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"pattern-7-function-call-stack-simulation",children:"Pattern 7: Function Call Stack Simulation"}),"\n",(0,i.jsx)(e.h3,{id:"71-iterative-tree-traversal",children:"7.1 Iterative Tree Traversal"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Iterative Preorder Traversal\npublic List<Integer> preorderTraversal(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n    if (root == null) return result;\n\n    Stack<TreeNode> stack = new Stack<>();\n    stack.push(root);\n\n    while (!stack.isEmpty()) {\n        TreeNode node = stack.pop();\n        result.add(node.val);\n\n        if (node.right != null) stack.push(node.right);\n        if (node.left != null) stack.push(node.left);\n    }\n\n    return result;\n}\n\n// Iterative Inorder Traversal\npublic List<Integer> inorderTraversal(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n    Stack<TreeNode> stack = new Stack<>();\n    TreeNode current = root;\n\n    while (current != null || !stack.isEmpty()) {\n        while (current != null) {\n            stack.push(current);\n            current = current.left;\n        }\n\n        current = stack.pop();\n        result.add(current.val);\n        current = current.right;\n    }\n\n    return result;\n}\n\n// Iterative Postorder Traversal\npublic List<Integer> postorderTraversal(TreeNode root) {\n    List<Integer> result = new ArrayList<>();\n    if (root == null) return result;\n\n    Stack<TreeNode> stack = new Stack<>();\n    TreeNode lastVisited = null;\n\n    while (root != null || !stack.isEmpty()) {\n        if (root != null) {\n            stack.push(root);\n            root = root.left;\n        } else {\n            TreeNode peekNode = stack.peek();\n\n            if (peekNode.right != null && lastVisited != peekNode.right) {\n                root = peekNode.right;\n            } else {\n                result.add(peekNode.val);\n                lastVisited = stack.pop();\n            }\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"72-dfs-graph-traversal",children:"7.2 DFS Graph Traversal"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'// Iterative DFS for Graph\npublic void dfsIterative(List<List<Integer>> graph, int start) {\n    boolean[] visited = new boolean[graph.size()];\n    Stack<Integer> stack = new Stack<>();\n\n    stack.push(start);\n\n    while (!stack.isEmpty()) {\n        int node = stack.pop();\n\n        if (visited[node]) continue;\n\n        visited[node] = true;\n        System.out.print(node + " ");\n\n        // Add neighbors in reverse order for consistent traversal\n        List<Integer> neighbors = graph.get(node);\n        for (int i = neighbors.size() - 1; i >= 0; i--) {\n            if (!visited[neighbors.get(i)]) {\n                stack.push(neighbors.get(i));\n            }\n        }\n    }\n}\n\n// Path Finding with Stack\npublic boolean hasPath(List<List<Integer>> graph, int start, int target) {\n    if (start == target) return true;\n\n    boolean[] visited = new boolean[graph.size()];\n    Stack<Integer> stack = new Stack<>();\n\n    stack.push(start);\n    visited[start] = true;\n\n    while (!stack.isEmpty()) {\n        int node = stack.pop();\n\n        for (int neighbor : graph.get(node)) {\n            if (neighbor == target) return true;\n\n            if (!visited[neighbor]) {\n                visited[neighbor] = true;\n                stack.push(neighbor);\n            }\n        }\n    }\n\n    return false;\n}\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"pattern-8-stack-based-string-processing",children:"Pattern 8: Stack-Based String Processing"}),"\n",(0,i.jsx)(e.h3,{id:"81-string-manipulation",children:"8.1 String Manipulation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Remove Duplicate Letters\npublic String removeDuplicateLetters(String s) {\n    int[] count = new int[26];\n    boolean[] visited = new boolean[26];\n\n    // Count frequency of each character\n    for (char c : s.toCharArray()) {\n        count[c - 'a']++;\n    }\n\n    Stack<Character> stack = new Stack<>();\n\n    for (char c : s.toCharArray()) {\n        count[c - 'a']--;\n\n        if (visited[c - 'a']) continue;\n\n        // Remove characters that are lexicographically larger and appear later\n        while (!stack.isEmpty() &&\n               stack.peek() > c &&\n               count[stack.peek() - 'a'] > 0) {\n            visited[stack.pop() - 'a'] = false;\n        }\n\n        stack.push(c);\n        visited[c - 'a'] = true;\n    }\n\n    StringBuilder result = new StringBuilder();\n    for (char c : stack) {\n        result.append(c);\n    }\n\n    return result.toString();\n}\n\n// Remove K Digits\npublic String removeKdigits(String num, int k) {\n    Stack<Character> stack = new Stack<>();\n\n    for (char digit : num.toCharArray()) {\n        while (k > 0 && !stack.isEmpty() && stack.peek() > digit) {\n            stack.pop();\n            k--;\n        }\n        stack.push(digit);\n    }\n\n    // Remove remaining digits from the end\n    while (k > 0) {\n        stack.pop();\n        k--;\n    }\n\n    // Build result\n    StringBuilder result = new StringBuilder();\n    for (char digit : stack) {\n        if (!(result.length() == 0 && digit == '0')) {\n            result.append(digit);\n        }\n    }\n\n    return result.length() == 0 ? \"0\" : result.toString();\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"82-string-decoding",children:"8.2 String Decoding"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'// Decode String\npublic String decodeString(String s) {\n    Stack<Integer> countStack = new Stack<>();\n    Stack<StringBuilder> stringStack = new Stack<>();\n    StringBuilder current = new StringBuilder();\n    int k = 0;\n\n    for (char c : s.toCharArray()) {\n        if (Character.isDigit(c)) {\n            k = k * 10 + (c - \'0\');\n        } else if (c == \'[\') {\n            countStack.push(k);\n            stringStack.push(current);\n            current = new StringBuilder();\n            k = 0;\n        } else if (c == \']\') {\n            StringBuilder temp = current;\n            current = stringStack.pop();\n            int count = countStack.pop();\n\n            for (int i = 0; i < count; i++) {\n                current.append(temp);\n            }\n        } else {\n            current.append(c);\n        }\n    }\n\n    return current.toString();\n}\n\n// Simplify Path\npublic String simplifyPath(String path) {\n    Stack<String> stack = new Stack<>();\n    String[] components = path.split("/");\n\n    for (String component : components) {\n        if (component.equals("") || component.equals(".")) {\n            continue;\n        } else if (component.equals("..")) {\n            if (!stack.isEmpty()) {\n                stack.pop();\n            }\n        } else {\n            stack.push(component);\n        }\n    }\n\n    StringBuilder result = new StringBuilder();\n    for (String dir : stack) {\n        result.append("/").append(dir);\n    }\n\n    return result.length() > 0 ? result.toString() : "/";\n}\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"pattern-9-stack-for-tree--graph-problems",children:"Pattern 9: Stack for Tree & Graph Problems"}),"\n",(0,i.jsx)(e.h3,{id:"91-binary-tree-problems",children:"9.1 Binary Tree Problems"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Flatten Binary Tree to Linked List\npublic void flatten(TreeNode root) {\n    if (root == null) return;\n\n    Stack<TreeNode> stack = new Stack<>();\n    stack.push(root);\n\n    while (!stack.isEmpty()) {\n        TreeNode current = stack.pop();\n\n        if (current.right != null) {\n            stack.push(current.right);\n        }\n        if (current.left != null) {\n            stack.push(current.left);\n        }\n\n        if (!stack.isEmpty()) {\n            current.right = stack.peek();\n        }\n        current.left = null;\n    }\n}\n\n// Binary Tree Zigzag Level Order Traversal\npublic List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n    List<List<Integer>> result = new ArrayList<>();\n    if (root == null) return result;\n\n    Stack<TreeNode> currentLevel = new Stack<>();\n    Stack<TreeNode> nextLevel = new Stack<>();\n    boolean leftToRight = true;\n\n    currentLevel.push(root);\n    List<Integer> level = new ArrayList<>();\n\n    while (!currentLevel.isEmpty()) {\n        TreeNode node = currentLevel.pop();\n        level.add(node.val);\n\n        if (leftToRight) {\n            if (node.left != null) nextLevel.push(node.left);\n            if (node.right != null) nextLevel.push(node.right);\n        } else {\n            if (node.right != null) nextLevel.push(node.right);\n            if (node.left != null) nextLevel.push(node.left);\n        }\n\n        if (currentLevel.isEmpty()) {\n            result.add(level);\n            level = new ArrayList<>();\n            Stack<TreeNode> temp = currentLevel;\n            currentLevel = nextLevel;\n            nextLevel = temp;\n            leftToRight = !leftToRight;\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"92-graph-algorithms",children:"9.2 Graph Algorithms"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Topological Sort using DFS\npublic int[] findOrder(int numCourses, int[][] prerequisites) {\n    List<List<Integer>> graph = new ArrayList<>();\n    for (int i = 0; i < numCourses; i++) {\n        graph.add(new ArrayList<>());\n    }\n\n    for (int[] prereq : prerequisites) {\n        graph.get(prereq[1]).add(prereq[0]);\n    }\n\n    int[] color = new int[numCourses]; // 0: white, 1: gray, 2: black\n    Stack<Integer> stack = new Stack<>();\n\n    for (int i = 0; i < numCourses; i++) {\n        if (color[i] == 0 && !dfsTopSort(graph, i, color, stack)) {\n            return new int[0]; // Cycle detected\n        }\n    }\n\n    int[] result = new int[numCourses];\n    for (int i = 0; i < numCourses; i++) {\n        result[i] = stack.pop();\n    }\n\n    return result;\n}\n\nprivate boolean dfsTopSort(List<List<Integer>> graph, int node, int[] color, Stack<Integer> stack) {\n    if (color[node] == 1) return false; // Cycle detected\n    if (color[node] == 2) return true;  // Already processed\n\n    color[node] = 1; // Mark as processing\n\n    for (int neighbor : graph.get(node)) {\n        if (!dfsTopSort(graph, neighbor, color, stack)) {\n            return false;\n        }\n    }\n\n    color[node] = 2; // Mark as processed\n    stack.push(node);\n    return true;\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"pattern-10-stack-based-optimization",children:"Pattern 10: Stack-Based Optimization"}),"\n",(0,i.jsx)(e.h3,{id:"101-sliding-window-maximum",children:"10.1 Sliding Window Maximum"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Sliding Window Maximum using Deque (Stack-like operations)\npublic int[] maxSlidingWindow(int[] nums, int k) {\n    Deque<Integer> deque = new ArrayDeque<>(); // Store indices\n    int[] result = new int[nums.length - k + 1];\n\n    for (int i = 0; i < nums.length; i++) {\n        // Remove elements outside window\n        while (!deque.isEmpty() && deque.peekFirst() < i - k + 1) {\n            deque.pollFirst();\n        }\n\n        // Remove smaller elements from rear\n        while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {\n            deque.pollLast();\n        }\n\n        deque.offerLast(i);\n\n        if (i >= k - 1) {\n            result[i - k + 1] = nums[deque.peekFirst()];\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"102-constrained-subsequence-sum",children:"10.2 Constrained Subsequence Sum"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Constrained Subsequence Sum\npublic int constrainedSubsetSum(int[] nums, int k) {\n    Deque<Integer> deque = new ArrayDeque<>(); // Monotonic decreasing deque\n    int[] dp = new int[nums.length];\n\n    for (int i = 0; i < nums.length; i++) {\n        // Remove elements outside window\n        while (!deque.isEmpty() && deque.peekFirst() < i - k) {\n            deque.pollFirst();\n        }\n\n        // Calculate current sum\n        dp[i] = nums[i] + (deque.isEmpty() ? 0 : Math.max(0, dp[deque.peekFirst()]));\n\n        // Maintain monotonic decreasing property\n        while (!deque.isEmpty() && dp[deque.peekLast()] <= dp[i]) {\n            deque.pollLast();\n        }\n\n        deque.offerLast(i);\n    }\n\n    return Arrays.stream(dp).max().orElse(0);\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"pattern-11-multi-stack-problems",children:"Pattern 11: Multi-Stack Problems"}),"\n",(0,i.jsx)(e.h3,{id:"111-three-stacks-in-array",children:"11.1 Three Stacks in Array"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Three Stacks in One Array\nclass ThreeStacks {\n    private int[] array;\n    private int[] tops;\n    private int stackSize;\n\n    public ThreeStacks(int stackSize) {\n        this.stackSize = stackSize;\n        this.array = new int[stackSize * 3];\n        this.tops = new int[]{-1, -1, -1};\n    }\n\n    public void push(int stackNum, int value) {\n        if (tops[stackNum] + 1 >= stackSize) {\n            throw new StackOverflowError();\n        }\n\n        tops[stackNum]++;\n        array[absTopOfStack(stackNum)] = value;\n    }\n\n    public int pop(int stackNum) {\n        if (tops[stackNum] == -1) {\n            throw new EmptyStackException();\n        }\n\n        int value = array[absTopOfStack(stackNum)];\n        array[absTopOfStack(stackNum)] = 0;\n        tops[stackNum]--;\n        return value;\n    }\n\n    public int peek(int stackNum) {\n        if (tops[stackNum] == -1) {\n            throw new EmptyStackException();\n        }\n        return array[absTopOfStack(stackNum)];\n    }\n\n    public boolean isEmpty(int stackNum) {\n        return tops[stackNum] == -1;\n    }\n\n    private int absTopOfStack(int stackNum) {\n        return stackNum * stackSize + tops[stackNum];\n    }\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"112-set-of-stacks",children:"11.2 Set of Stacks"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Set of Stacks (Stack of Plates)\nclass SetOfStacks {\n    private List<Stack<Integer>> stacks;\n    private int capacity;\n\n    public SetOfStacks(int capacity) {\n        this.capacity = capacity;\n        this.stacks = new ArrayList<>();\n    }\n\n    public void push(int value) {\n        Stack<Integer> last = getLastStack();\n        if (last != null && last.size() < capacity) {\n            last.push(value);\n        } else {\n            Stack<Integer> stack = new Stack<>();\n            stack.push(value);\n            stacks.add(stack);\n        }\n    }\n\n    public int pop() {\n        Stack<Integer> last = getLastStack();\n        if (last == null) throw new EmptyStackException();\n\n        int value = last.pop();\n        if (last.size() == 0) {\n            stacks.remove(stacks.size() - 1);\n        }\n        return value;\n    }\n\n    public int popAt(int index) {\n        return leftShift(index, true);\n    }\n\n    private int leftShift(int index, boolean removeTop) {\n        Stack<Integer> stack = stacks.get(index);\n        int removedItem;\n\n        if (removeTop) {\n            removedItem = stack.pop();\n        } else {\n            removedItem = removeBottom(stack);\n        }\n\n        if (stack.isEmpty()) {\n            stacks.remove(index);\n        } else if (stacks.size() > index + 1) {\n            int v = leftShift(index + 1, false);\n            stack.push(v);\n        }\n\n        return removedItem;\n    }\n\n    private int removeBottom(Stack<Integer> stack) {\n        if (stack.isEmpty()) return 0;\n\n        int top = stack.pop();\n        if (stack.isEmpty()) {\n            return top;\n        } else {\n            int bottom = removeBottom(stack);\n            stack.push(top);\n            return bottom;\n        }\n    }\n\n    private Stack<Integer> getLastStack() {\n        if (stacks.isEmpty()) return null;\n        return stacks.get(stacks.size() - 1);\n    }\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"pattern-12-advanced-stack-applications",children:"Pattern 12: Advanced Stack Applications"}),"\n",(0,i.jsx)(e.h3,{id:"121-asteroid-collision",children:"12.1 Asteroid Collision"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Asteroid Collision\npublic int[] asteroidCollision(int[] asteroids) {\n    Stack<Integer> stack = new Stack<>();\n\n    for (int asteroid : asteroids) {\n        boolean exploded = false;\n\n        while (!stack.isEmpty() && asteroid < 0 && stack.peek() > 0) {\n            if (stack.peek() < -asteroid) {\n                stack.pop();\n                continue;\n            } else if (stack.peek() == -asteroid) {\n                stack.pop();\n            }\n            exploded = true;\n            break;\n        }\n\n        if (!exploded) {\n            stack.push(asteroid);\n        }\n    }\n\n    return stack.stream().mapToInt(Integer::intValue).toArray();\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"122-car-fleet",children:"12.2 Car Fleet"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Car Fleet\npublic int carFleet(int target, int[] position, int[] speed) {\n    int n = position.length;\n    double[][] cars = new double[n][2];\n\n    for (int i = 0; i < n; i++) {\n        cars[i][0] = position[i];\n        cars[i][1] = (double) (target - position[i]) / speed[i]; // Time to reach target\n    }\n\n    Arrays.sort(cars, (a, b) -> Double.compare(a[0], b[0])); // Sort by position\n\n    Stack<Double> stack = new Stack<>();\n\n    for (int i = n - 1; i >= 0; i--) { // Process from closest to target\n        double time = cars[i][1];\n\n        if (stack.isEmpty() || time > stack.peek()) {\n            stack.push(time);\n        }\n        // If current car is faster, it will catch up to the fleet ahead\n    }\n\n    return stack.size();\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"123-sum-of-subarray-minimums",children:"12.3 Sum of Subarray Minimums"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Sum of Subarray Minimums\npublic int sumSubarrayMins(int[] arr) {\n    int MOD = 1000000007;\n    int n = arr.length;\n\n    // Find previous less element and next less element for each element\n    int[] prevLess = new int[n];\n    int[] nextLess = new int[n];\n\n    Arrays.fill(prevLess, -1);\n    Arrays.fill(nextLess, n);\n\n    Stack<Integer> stack = new Stack<>();\n\n    // Find previous less elements\n    for (int i = 0; i < n; i++) {\n        while (!stack.isEmpty() && arr[stack.peek()] >= arr[i]) {\n            stack.pop();\n        }\n        if (!stack.isEmpty()) {\n            prevLess[i] = stack.peek();\n        }\n        stack.push(i);\n    }\n\n    stack.clear();\n\n    // Find next less elements\n    for (int i = n - 1; i >= 0; i--) {\n        while (!stack.isEmpty() && arr[stack.peek()] > arr[i]) {\n            stack.pop();\n        }\n        if (!stack.isEmpty()) {\n            nextLess[i] = stack.peek();\n        }\n        stack.push(i);\n    }\n\n    long result = 0;\n    for (int i = 0; i < n; i++) {\n        long left = i - prevLess[i];\n        long right = nextLess[i] - i;\n        result = (result + (left * right * arr[i]) % MOD) % MOD;\n    }\n\n    return (int) result;\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"time--space-complexity-reference",children:"Time & Space Complexity Reference"}),"\n",(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{style:{textAlign:"left"},children:"Pattern"}),(0,i.jsx)(e.th,{style:{textAlign:"left"},children:"Time Complexity"}),(0,i.jsx)(e.th,{style:{textAlign:"left"},children:"Space Complexity"}),(0,i.jsx)(e.th,{style:{textAlign:"left"},children:"Key Characteristics"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"Basic Stack Ops"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"O(1) per operation"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"O(n)"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"Push, Pop, Peek in constant time"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"Expression Evaluation"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"O(n)"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"O(n)"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"Single pass with operator stack"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"Parentheses Matching"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"O(n)"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"O(n)"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"Stack depth = max nesting"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"Monotonic Stack"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"O(n)"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"O(n)"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"Each element pushed/popped once"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"Next Greater/Smaller"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"O(n)"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"O(n)"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"Amortized O(1) per element"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"Histogram Problems"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"O(n)"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"O(n)"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"Stack stores indices"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"Tree Traversal"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"O(n)"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"O(h)"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"Height-dependent space"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"String Processing"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"O(n)"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"O(n)"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"Character-by-character processing"})]})]})]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"best-practices--optimization-tips",children:"Best Practices & Optimization Tips"}),"\n",(0,i.jsx)(e.h3,{id:"monotonic-stack-guidelines",children:"Monotonic Stack Guidelines"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Template for Monotonic Stack Problems\npublic int[] monotonicStackTemplate(int[] arr) {\n    int n = arr.length;\n    int[] result = new int[n];\n    Stack<Integer> stack = new Stack<>(); // Usually store indices\n\n    for (int i = 0; i < n; i++) {\n        // Maintain monotonic property\n        while (!stack.isEmpty() && shouldPop(arr, stack.peek(), i)) {\n            int index = stack.pop();\n            result[index] = processElement(arr, index, i);\n        }\n\n        // Process current element if needed\n        if (!stack.isEmpty()) {\n            processCurrentElement(arr, stack.peek(), i, result);\n        }\n\n        stack.push(i);\n    }\n\n    return result;\n}\n\n// Helper methods (implement based on specific problem)\nboolean shouldPop(int[] arr, int stackTop, int current) {\n    // For next greater: arr[stackTop] < arr[current]\n    // For next smaller: arr[stackTop] > arr[current]\n    return false;\n}\n\nint processElement(int[] arr, int index, int currentIndex) {\n    return arr[currentIndex]; // Or currentIndex for distance\n}\n\nvoid processCurrentElement(int[] arr, int stackTop, int current, int[] result) {\n    // Process relationship between current and stack top\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"common-optimizations",children:"Common Optimizations"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// 1. Use ArrayDeque instead of Stack for better performance\nDeque<Integer> stack = new ArrayDeque<>();\n\n// 2. Store indices instead of values for flexibility\nStack<Integer> indices = new Stack<>();\n\n// 3. Combine multiple passes when possible\npublic int[] combineOperations(int[] arr) {\n    // Process next greater and previous smaller in same loop\n    Stack<Integer> stack = new Stack<>();\n    int[] nextGreater = new int[arr.length];\n    int[] prevSmaller = new int[arr.length];\n\n    for (int i = 0; i < arr.length; i++) {\n        // Process next greater\n        while (!stack.isEmpty() && arr[stack.peek()] < arr[i]) {\n            nextGreater[stack.pop()] = arr[i];\n        }\n\n        // Process previous smaller\n        while (!stack.isEmpty() && arr[stack.peek()] >= arr[i]) {\n            stack.pop();\n        }\n        prevSmaller[i] = stack.isEmpty() ? -1 : arr[stack.peek()];\n\n        stack.push(i);\n    }\n\n    return nextGreater; // or combine results as needed\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"interview-tips",children:"Interview Tips"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Identify the pattern"})," early: expression evaluation, matching, or monotonic properties"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Choose the right approach"}),": recursive problems often benefit from iterative stack solutions"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Handle edge cases"}),": empty stack, single elements, duplicate values"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Optimize space"}),": use indices instead of storing entire objects when possible"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Consider alternative data structures"}),": sometimes deque or list can be more efficient"]}),"\n"]})]})}function u(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(p,{...n})}):p(n)}}}]);