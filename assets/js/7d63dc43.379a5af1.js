"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[2371],{9229:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>i,metadata:()=>o,toc:()=>u});var r=t(4848),a=t(8453);const i={},s="Spring Boot Annotations - Complete Developer Guide",o={id:"Java/Spring Boot Annotations",title:"Spring Boot Annotations - Complete Developer Guide",description:"Table of Contents",source:"@site/docs/Java/Spring Boot Annotations.mdx",sourceDirName:"Java",slug:"/Java/Spring Boot Annotations",permalink:"/js.enigma/docs/Java/Spring Boot Annotations",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/Java/Spring Boot Annotations.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Spring & Spring Boot Detailed Cheatsheet",permalink:"/js.enigma/docs/Java/Spring & Spring Boot Detailed Cheatsheet"},next:{title:"Spring Boot Backend Interview Roadmap",permalink:"/js.enigma/docs/Java/Spring Boot Backend Interview Roadmap"}},l={},u=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Entity &amp; JPA Annotations",id:"entity--jpa-annotations",level:2},{value:"@Entity",id:"entity",level:3},{value:"@Id &amp; @GeneratedValue",id:"id--generatedvalue",level:3},{value:"@Column",id:"column",level:3},{value:"@Table",id:"table",level:3},{value:"@Temporal &amp; Date/Time Annotations",id:"temporal--datetime-annotations",level:3},{value:"@Enumerated",id:"enumerated",level:3},{value:"@Lob &amp; @Basic",id:"lob--basic",level:3},{value:"Request Mapping Annotations",id:"request-mapping-annotations",level:2},{value:"@RestController vs @Controller",id:"restcontroller-vs-controller",level:3},{value:"@RequestMapping &amp; HTTP Method Specific Annotations",id:"requestmapping--http-method-specific-annotations",level:3},{value:"Parameter Binding Annotations",id:"parameter-binding-annotations",level:2},{value:"@PathVariable",id:"pathvariable",level:3},{value:"@RequestParam",id:"requestparam",level:3},{value:"@RequestBody",id:"requestbody",level:3},{value:"@RequestHeader",id:"requestheader",level:3},{value:"@CookieValue",id:"cookievalue",level:3},{value:"@ModelAttribute",id:"modelattribute",level:3},{value:"Validation Annotations",id:"validation-annotations",level:2},{value:"Basic Validation Annotations",id:"basic-validation-annotations",level:3},{value:"Custom Validation Annotations",id:"custom-validation-annotations",level:3},{value:"Validation Groups",id:"validation-groups",level:3},{value:"Error Handling for Validations",id:"error-handling-for-validations",level:3},{value:"Relationship Mapping Annotations",id:"relationship-mapping-annotations",level:2},{value:"@OneToOne",id:"onetoone",level:3},{value:"@OneToMany &amp; @ManyToOne",id:"onetomany--manytoone",level:3},{value:"@ManyToMany",id:"manytomany",level:3},{value:"@JoinColumn &amp; @JoinTable",id:"joincolumn--jointable",level:3},{value:"Spring Core Annotations",id:"spring-core-annotations",level:2},{value:"Dependency Injection Annotations",id:"dependency-injection-annotations",level:3},{value:"Configuration Annotations",id:"configuration-annotations",level:3},{value:"Value Injection Annotations",id:"value-injection-annotations",level:3},{value:"Security Annotations",id:"security-annotations",level:2},{value:"Method-Level Security",id:"method-level-security",level:3},{value:"Testing Annotations",id:"testing-annotations",level:2},{value:"Integration Testing",id:"integration-testing",level:3},{value:"Best Practices &amp; Common Patterns",id:"best-practices--common-patterns",level:2},{value:"Controller Best Practices",id:"controller-best-practices",level:3},{value:"Service Layer Patterns",id:"service-layer-patterns",level:3},{value:"Repository Patterns",id:"repository-patterns",level:3},{value:"DTOs and Mapping",id:"dtos-and-mapping",level:3},{value:"Configuration Classes",id:"configuration-classes",level:3},{value:"Exception Handling",id:"exception-handling",level:3},{value:"Security Configuration",id:"security-configuration",level:3},{value:"Testing Patterns",id:"testing-patterns",level:3},{value:"Utility Classes",id:"utility-classes",level:3},{value:"Performance Optimization",id:"performance-optimization",level:3}];function p(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"spring-boot-annotations---complete-developer-guide",children:"Spring Boot Annotations - Complete Developer Guide"})}),"\n",(0,r.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#entity--jpa-annotations",children:"Entity & JPA Annotations"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#request-mapping-annotations",children:"Request Mapping Annotations"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#parameter-binding-annotations",children:"Parameter Binding Annotations"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#validation-annotations",children:"Validation Annotations"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#relationship-mapping-annotations",children:"Relationship Mapping Annotations"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#spring-core-annotations",children:"Spring Core Annotations"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#configuration-annotations",children:"Configuration Annotations"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#security-annotations",children:"Security Annotations"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#testing-annotations",children:"Testing Annotations"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#best-practices--common-patterns",children:"Best Practices & Common Patterns"})}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"entity--jpa-annotations",children:"Entity & JPA Annotations"}),"\n",(0,r.jsx)(n.h3,{id:"entity",children:"@Entity"}),"\n",(0,r.jsx)(n.p,{children:"Marks a class as a JPA entity (database table)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Entity\n@Table(name = "users") // Optional: specify table name\npublic class User {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    private String name;\n    private String email;\n\n    // Constructors, getters, setters\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Key Points:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Must have a no-arg constructor"}),"\n",(0,r.jsx)(n.li,{children:"All fields should have getters/setters or be public"}),"\n",(0,r.jsx)(n.li,{children:"Requires @Id annotation on primary key field"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"id--generatedvalue",children:"@Id & @GeneratedValue"}),"\n",(0,r.jsx)(n.p,{children:"Define primary key and generation strategy"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Entity\npublic class Product {\n    // Auto-increment (MySQL, PostgreSQL)\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    // Sequence-based (Oracle, PostgreSQL)\n    @Id\n    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "product_seq")\n    @SequenceGenerator(name = "product_seq", sequenceName = "product_sequence", allocationSize = 1)\n    private Long sequenceId;\n\n    // UUID generation\n    @Id\n    @GeneratedValue(strategy = GenerationType.UUID)\n    private String uuid;\n\n    // Manual assignment\n    @Id\n    private String customId;\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Generation Strategies:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"IDENTITY"}),": Auto-increment (database-dependent)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"SEQUENCE"}),": Database sequence"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"TABLE"}),": Uses a table to simulate sequences"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"UUID"}),": Generates UUID values"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"AUTO"}),": JPA provider chooses strategy"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"column",children:"@Column"}),"\n",(0,r.jsx)(n.p,{children:"Customize column mapping"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Entity\npublic class Employee {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    @Column(name = "employee_name", nullable = false, length = 100)\n    private String name;\n\n    @Column(name = "email_address", unique = true, nullable = false)\n    private String email;\n\n    @Column(columnDefinition = "TEXT")\n    private String description;\n\n    @Column(precision = 10, scale = 2) // For BigDecimal\n    private BigDecimal salary;\n\n    @Column(insertable = false, updatable = false)\n    @CreationTimestamp\n    private LocalDateTime createdAt;\n\n    @Column(columnDefinition = "BOOLEAN DEFAULT true")\n    private Boolean active;\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Common Attributes:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"name"}),": Column name in database"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"nullable"}),": Allow null values (default: true)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"unique"}),": Unique constraint"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"length"}),": String column length"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"precision/scale"}),": For decimal numbers"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"insertable/updatable"}),": Control insert/update operations"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"table",children:"@Table"}),"\n",(0,r.jsx)(n.p,{children:"Configure table-specific settings"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Entity\n@Table(\n    name = "user_profiles",\n    schema = "public",\n    indexes = {\n        @Index(name = "idx_email", columnList = "email"),\n        @Index(name = "idx_name_email", columnList = "name, email")\n    },\n    uniqueConstraints = {\n        @UniqueConstraint(name = "uk_email", columnNames = "email"),\n        @UniqueConstraint(name = "uk_username", columnNames = "username")\n    }\n)\npublic class UserProfile {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    @Column(nullable = false)\n    private String name;\n\n    @Column(unique = true, nullable = false)\n    private String email;\n\n    @Column(unique = true, nullable = false)\n    private String username;\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"temporal--datetime-annotations",children:"@Temporal & Date/Time Annotations"}),"\n",(0,r.jsx)(n.p,{children:"Handle date and time fields"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"@Entity\npublic class Event {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    // Legacy Date handling\n    @Temporal(TemporalType.DATE) // Only date\n    private Date eventDate;\n\n    @Temporal(TemporalType.TIME) // Only time\n    private Date eventTime;\n\n    @Temporal(TemporalType.TIMESTAMP) // Date and time\n    private Date eventDateTime;\n\n    // Modern Java 8+ approach (Recommended)\n    private LocalDate startDate;\n    private LocalTime startTime;\n    private LocalDateTime createdAt;\n    private ZonedDateTime scheduledAt;\n\n    // Automatic timestamps\n    @CreationTimestamp\n    private LocalDateTime createdTimestamp;\n\n    @UpdateTimestamp\n    private LocalDateTime updatedTimestamp;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"enumerated",children:"@Enumerated"}),"\n",(0,r.jsx)(n.p,{children:"Map Java enums to database"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"public enum Status {\n    ACTIVE, INACTIVE, PENDING, SUSPENDED\n}\n\npublic enum Priority {\n    LOW(1), MEDIUM(2), HIGH(3), CRITICAL(4);\n\n    private final int value;\n    Priority(int value) { this.value = value; }\n    public int getValue() { return value; }\n}\n\n@Entity\npublic class Task {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    @Enumerated(EnumType.STRING) // Stores enum name (Recommended)\n    private Status status;\n\n    @Enumerated(EnumType.ORDINAL) // Stores enum position (0, 1, 2...)\n    private Priority priority;\n\n    // Custom enum converter for complex cases\n    @Convert(converter = StatusConverter.class)\n    private Status customStatus;\n}\n\n// Custom enum converter\n@Converter(autoApply = true)\npublic class StatusConverter implements AttributeConverter<Status, String> {\n    @Override\n    public String convertToDatabaseColumn(Status status) {\n        return status != null ? status.name().toLowerCase() : null;\n    }\n\n    @Override\n    public Status convertToEntityAttribute(String value) {\n        return value != null ? Status.valueOf(value.toUpperCase()) : null;\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"lob--basic",children:"@Lob & @Basic"}),"\n",(0,r.jsx)(n.p,{children:"Handle large objects and lazy loading"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Entity\npublic class Document {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    // Large text content\n    @Lob\n    @Column(columnDefinition = "TEXT")\n    private String content;\n\n    // Binary data (files, images)\n    @Lob\n    @Basic(fetch = FetchType.LAZY) // Lazy load large data\n    private byte[] fileData;\n\n    // Control fetching behavior\n    @Basic(fetch = FetchType.EAGER, optional = false)\n    private String title;\n\n    @Basic(fetch = FetchType.LAZY, optional = true)\n    private String description;\n}\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"request-mapping-annotations",children:"Request Mapping Annotations"}),"\n",(0,r.jsx)(n.h3,{id:"restcontroller-vs-controller",children:"@RestController vs @Controller"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'// REST API controller - automatically serializes return values to JSON\n@RestController\n@RequestMapping("/api/users")\npublic class UserRestController {\n\n    @GetMapping("/{id}")\n    public ResponseEntity<User> getUser(@PathVariable Long id) {\n        // Returns JSON automatically\n        return ResponseEntity.ok(userService.findById(id));\n    }\n}\n\n// Traditional MVC controller - returns view names\n@Controller\n@RequestMapping("/users")\npublic class UserController {\n\n    @GetMapping("/{id}")\n    public String getUser(@PathVariable Long id, Model model) {\n        model.addAttribute("user", userService.findById(id));\n        return "user-detail"; // Returns view name\n    }\n\n    // For JSON response in @Controller\n    @GetMapping("/{id}/json")\n    @ResponseBody\n    public User getUserJson(@PathVariable Long id) {\n        return userService.findById(id);\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"requestmapping--http-method-specific-annotations",children:"@RequestMapping & HTTP Method Specific Annotations"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@RestController\n@RequestMapping("/api/products")\n@CrossOrigin(origins = "http://localhost:3000") // CORS support\npublic class ProductController {\n\n    // Generic mapping\n    @RequestMapping(value = "/search", method = RequestMethod.GET)\n    public List<Product> search(@RequestParam String query) {\n        return productService.search(query);\n    }\n\n    // HTTP method specific annotations (Recommended)\n    @GetMapping // GET /api/products\n    public ResponseEntity<List<Product>> getAllProducts(\n            @RequestParam(defaultValue = "0") int page,\n            @RequestParam(defaultValue = "10") int size) {\n        return ResponseEntity.ok(productService.findAll(page, size));\n    }\n\n    @GetMapping("/{id}") // GET /api/products/{id}\n    public ResponseEntity<Product> getProduct(@PathVariable Long id) {\n        return ResponseEntity.ok(productService.findById(id));\n    }\n\n    @PostMapping // POST /api/products\n    public ResponseEntity<Product> createProduct(@RequestBody @Valid CreateProductRequest request) {\n        Product created = productService.create(request);\n        return ResponseEntity.status(HttpStatus.CREATED).body(created);\n    }\n\n    @PutMapping("/{id}") // PUT /api/products/{id}\n    public ResponseEntity<Product> updateProduct(\n            @PathVariable Long id,\n            @RequestBody @Valid UpdateProductRequest request) {\n        Product updated = productService.update(id, request);\n        return ResponseEntity.ok(updated);\n    }\n\n    @PatchMapping("/{id}/status") // PATCH /api/products/{id}/status\n    public ResponseEntity<Product> updateStatus(\n            @PathVariable Long id,\n            @RequestBody Map<String, Object> updates) {\n        Product updated = productService.updateStatus(id, updates);\n        return ResponseEntity.ok(updated);\n    }\n\n    @DeleteMapping("/{id}") // DELETE /api/products/{id}\n    public ResponseEntity<Void> deleteProduct(@PathVariable Long id) {\n        productService.delete(id);\n        return ResponseEntity.noContent().build();\n    }\n\n    // Advanced mapping with headers and params\n    @GetMapping(value = "/export",\n                headers = "Accept=application/json",\n                params = "format=json")\n    public ResponseEntity<List<Product>> exportProducts() {\n        return ResponseEntity.ok(productService.findAll());\n    }\n\n    // Content type specific mapping\n    @PostMapping(value = "/upload",\n                 consumes = MediaType.MULTIPART_FORM_DATA_VALUE,\n                 produces = MediaType.APPLICATION_JSON_VALUE)\n    public ResponseEntity<String> uploadFile(@RequestParam("file") MultipartFile file) {\n        String result = fileService.upload(file);\n        return ResponseEntity.ok(result);\n    }\n}\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"parameter-binding-annotations",children:"Parameter Binding Annotations"}),"\n",(0,r.jsx)(n.h3,{id:"pathvariable",children:"@PathVariable"}),"\n",(0,r.jsx)(n.p,{children:"Extract values from URL path"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@RestController\n@RequestMapping("/api")\npublic class PathVariableExamples {\n\n    // Simple path variable\n    @GetMapping("/users/{id}")\n    public ResponseEntity<User> getUser(@PathVariable Long id) {\n        return ResponseEntity.ok(userService.findById(id));\n    }\n\n    // Multiple path variables\n    @GetMapping("/users/{userId}/orders/{orderId}")\n    public ResponseEntity<Order> getUserOrder(\n            @PathVariable Long userId,\n            @PathVariable Long orderId) {\n        return ResponseEntity.ok(orderService.findByUserAndId(userId, orderId));\n    }\n\n    // Custom variable names\n    @GetMapping("/categories/{cat-id}/products/{prod-id}")\n    public ResponseEntity<Product> getProduct(\n            @PathVariable("cat-id") Long categoryId,\n            @PathVariable("prod-id") Long productId) {\n        return ResponseEntity.ok(productService.findByCategoryAndId(categoryId, productId));\n    }\n\n    // Optional path variable with Map\n    @GetMapping({"/search", "/search/{query}"})\n    public ResponseEntity<List<Product>> search(@PathVariable Map<String, String> pathVars) {\n        String query = pathVars.getOrDefault("query", "");\n        return ResponseEntity.ok(productService.search(query));\n    }\n\n    // Regex pattern matching\n    @GetMapping("/products/{id:[0-9]+}") // Only numeric IDs\n    public ResponseEntity<Product> getProductById(@PathVariable Long id) {\n        return ResponseEntity.ok(productService.findById(id));\n    }\n\n    @GetMapping("/products/{code:[A-Z]{3}[0-9]{3}}") // Pattern: ABC123\n    public ResponseEntity<Product> getProductByCode(@PathVariable String code) {\n        return ResponseEntity.ok(productService.findByCode(code));\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"requestparam",children:"@RequestParam"}),"\n",(0,r.jsx)(n.p,{children:"Extract query parameters from URL"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@RestController\n@RequestMapping("/api/products")\npublic class RequestParamExamples {\n\n    // Simple request parameter\n    @GetMapping("/search")\n    public ResponseEntity<List<Product>> search(@RequestParam String query) {\n        return ResponseEntity.ok(productService.search(query));\n    }\n\n    // Optional parameters with defaults\n    @GetMapping\n    public ResponseEntity<Page<Product>> getProducts(\n            @RequestParam(defaultValue = "0") int page,\n            @RequestParam(defaultValue = "10") int size,\n            @RequestParam(defaultValue = "id") String sortBy,\n            @RequestParam(defaultValue = "asc") String sortDir,\n            @RequestParam(required = false) String category) {\n\n        Page<Product> products = productService.findAll(page, size, sortBy, sortDir, category);\n        return ResponseEntity.ok(products);\n    }\n\n    // Custom parameter names\n    @GetMapping("/filter")\n    public ResponseEntity<List<Product>> filter(\n            @RequestParam("min-price") BigDecimal minPrice,\n            @RequestParam("max-price") BigDecimal maxPrice,\n            @RequestParam("cat") String category) {\n        return ResponseEntity.ok(productService.findByPriceRange(minPrice, maxPrice, category));\n    }\n\n    // Multiple values for same parameter\n    @GetMapping("/by-categories")\n    public ResponseEntity<List<Product>> getByCategories(\n            @RequestParam List<String> categories) {\n        return ResponseEntity.ok(productService.findByCategories(categories));\n    }\n\n    // Map for dynamic parameters\n    @GetMapping("/dynamic-filter")\n    public ResponseEntity<List<Product>> dynamicFilter(\n            @RequestParam Map<String, String> filters) {\n        return ResponseEntity.ok(productService.findByFilters(filters));\n    }\n\n    // Date parameters\n    @GetMapping("/created-between")\n    public ResponseEntity<List<Product>> getCreatedBetween(\n            @RequestParam @DateTimeFormat(pattern = "yyyy-MM-dd") LocalDate startDate,\n            @RequestParam @DateTimeFormat(pattern = "yyyy-MM-dd") LocalDate endDate) {\n        return ResponseEntity.ok(productService.findCreatedBetween(startDate, endDate));\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"requestbody",children:"@RequestBody"}),"\n",(0,r.jsx)(n.p,{children:"Bind request body to object"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'// Request DTOs\npublic class CreateUserRequest {\n    @NotBlank(message = "Name is required")\n    private String name;\n\n    @Email(message = "Invalid email format")\n    @NotBlank(message = "Email is required")\n    private String email;\n\n    @Size(min = 8, message = "Password must be at least 8 characters")\n    private String password;\n\n    // Getters and setters\n    public String getName() { return name; }\n    public void setName(String name) { this.name = name; }\n\n    public String getEmail() { return email; }\n    public void setEmail(String email) { this.email = email; }\n\n    public String getPassword() { return password; }\n    public void setPassword(String password) { this.password = password; }\n}\n\npublic class UpdateUserRequest {\n    private String name;\n    private String email;\n\n    // Getters and setters\n    public String getName() { return name; }\n    public void setName(String name) { this.name = name; }\n\n    public String getEmail() { return email; }\n    public void setEmail(String email) { this.email = email; }\n}\n\n@RestController\n@RequestMapping("/api/users")\npublic class RequestBodyExamples {\n\n    // Simple request body binding\n    @PostMapping\n    public ResponseEntity<User> createUser(@RequestBody @Valid CreateUserRequest request) {\n        User user = userService.create(request);\n        return ResponseEntity.status(HttpStatus.CREATED).body(user);\n    }\n\n    // Partial updates\n    @PatchMapping("/{id}")\n    public ResponseEntity<User> updateUser(\n            @PathVariable Long id,\n            @RequestBody UpdateUserRequest request) {\n        User updated = userService.update(id, request);\n        return ResponseEntity.ok(updated);\n    }\n\n    // Raw JSON handling\n    @PostMapping("/raw")\n    public ResponseEntity<String> handleRawJson(@RequestBody String json) {\n        // Process raw JSON string\n        String result = jsonProcessor.process(json);\n        return ResponseEntity.ok(result);\n    }\n\n    // Map for dynamic JSON\n    @PostMapping("/dynamic")\n    public ResponseEntity<Map<String, Object>> handleDynamic(\n            @RequestBody Map<String, Object> data) {\n        Map<String, Object> result = dataProcessor.process(data);\n        return ResponseEntity.ok(result);\n    }\n\n    // List of objects\n    @PostMapping("/batch")\n    public ResponseEntity<List<User>> createUsers(\n            @RequestBody @Valid List<CreateUserRequest> requests) {\n        List<User> users = userService.createBatch(requests);\n        return ResponseEntity.status(HttpStatus.CREATED).body(users);\n    }\n\n    // Optional request body\n    @PostMapping("/optional")\n    public ResponseEntity<String> handleOptional(\n            @RequestBody(required = false) CreateUserRequest request) {\n        if (request != null) {\n            User user = userService.create(request);\n            return ResponseEntity.ok("User created: " + user.getId());\n        }\n        return ResponseEntity.ok("No data provided");\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"requestheader",children:"@RequestHeader"}),"\n",(0,r.jsx)(n.p,{children:"Access HTTP headers"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@RestController\n@RequestMapping("/api")\npublic class RequestHeaderExamples {\n\n    // Single header\n    @GetMapping("/protected")\n    public ResponseEntity<String> protectedEndpoint(\n            @RequestHeader("Authorization") String authToken) {\n        // Validate token\n        if (authService.validateToken(authToken)) {\n            return ResponseEntity.ok("Access granted");\n        }\n        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("Invalid token");\n    }\n\n    // Multiple headers\n    @PostMapping("/upload")\n    public ResponseEntity<String> uploadFile(\n            @RequestHeader("Content-Type") String contentType,\n            @RequestHeader("Content-Length") long contentLength,\n            @RequestHeader(value = "X-User-ID", required = false) String userId,\n            @RequestBody byte[] fileData) {\n\n        String result = fileService.upload(fileData, contentType, contentLength, userId);\n        return ResponseEntity.ok(result);\n    }\n\n    // Default values and optional headers\n    @GetMapping("/info")\n    public ResponseEntity<Map<String, String>> getInfo(\n            @RequestHeader(value = "User-Agent", defaultValue = "Unknown") String userAgent,\n            @RequestHeader(value = "Accept-Language", required = false) String language,\n            @RequestHeader(value = "X-Request-ID", required = false) String requestId) {\n\n        Map<String, String> info = new HashMap<>();\n        info.put("userAgent", userAgent);\n        info.put("language", language);\n        info.put("requestId", requestId);\n\n        return ResponseEntity.ok(info);\n    }\n\n    // All headers as Map\n    @GetMapping("/headers")\n    public ResponseEntity<Map<String, String>> getAllHeaders(\n            @RequestHeader Map<String, String> headers) {\n        return ResponseEntity.ok(headers);\n    }\n\n    // HttpHeaders object\n    @PostMapping("/analyze")\n    public ResponseEntity<String> analyzeRequest(\n            @RequestHeader HttpHeaders headers,\n            @RequestBody String data) {\n\n        String analysis = requestAnalyzer.analyze(headers, data);\n        return ResponseEntity.ok(analysis);\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"cookievalue",children:"@CookieValue"}),"\n",(0,r.jsx)(n.p,{children:"Access HTTP cookies"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@RestController\n@RequestMapping("/api")\npublic class CookieValueExamples {\n\n    // Simple cookie access\n    @GetMapping("/profile")\n    public ResponseEntity<User> getProfile(\n            @CookieValue("sessionId") String sessionId) {\n        User user = sessionService.getUserBySession(sessionId);\n        return ResponseEntity.ok(user);\n    }\n\n    // Optional cookie with default\n    @GetMapping("/preferences")\n    public ResponseEntity<Map<String, String>> getPreferences(\n            @CookieValue(value = "theme", defaultValue = "light") String theme,\n            @CookieValue(value = "language", required = false) String language) {\n\n        Map<String, String> preferences = new HashMap<>();\n        preferences.put("theme", theme);\n        preferences.put("language", language != null ? language : "en");\n\n        return ResponseEntity.ok(preferences);\n    }\n\n    // Set cookies in response\n    @PostMapping("/login")\n    public ResponseEntity<String> login(\n            @RequestBody LoginRequest request,\n            HttpServletResponse response) {\n\n        String sessionId = authService.authenticate(request);\n\n        // Set cookie\n        Cookie cookie = new Cookie("sessionId", sessionId);\n        cookie.setMaxAge(3600); // 1 hour\n        cookie.setPath("/");\n        cookie.setHttpOnly(true);\n        response.addCookie(cookie);\n\n        return ResponseEntity.ok("Login successful");\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"modelattribute",children:"@ModelAttribute"}),"\n",(0,r.jsx)(n.p,{children:"Bind form data and model attributes"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'// Form DTO\npublic class UserForm {\n    private String name;\n    private String email;\n    private Integer age;\n    private String address;\n\n    // Default constructor\n    public UserForm() {}\n\n    // Getters and setters\n    public String getName() { return name; }\n    public void setName(String name) { this.name = name; }\n\n    public String getEmail() { return email; }\n    public void setEmail(String email) { this.email = email; }\n\n    public Integer getAge() { return age; }\n    public void setAge(Integer age) { this.age = age; }\n\n    public String getAddress() { return address; }\n    public void setAddress(String address) { this.address = address; }\n}\n\n@Controller\n@RequestMapping("/users")\npublic class ModelAttributeExamples {\n\n    // Bind form data\n    @PostMapping("/create")\n    public String createUser(@ModelAttribute @Valid UserForm userForm,\n                           BindingResult result,\n                           Model model) {\n        if (result.hasErrors()) {\n            return "user-form";\n        }\n\n        User user = userService.create(userForm);\n        model.addAttribute("message", "User created successfully");\n        return "redirect:/users/" + user.getId();\n    }\n\n    // Custom attribute name\n    @PostMapping("/update/{id}")\n    public String updateUser(@PathVariable Long id,\n                           @ModelAttribute("updateForm") UserForm form,\n                           Model model) {\n        User updated = userService.update(id, form);\n        model.addAttribute("user", updated);\n        return "user-detail";\n    }\n\n    // Add model attributes for all methods in controller\n    @ModelAttribute("countries")\n    public List<String> getCountries() {\n        return Arrays.asList("USA", "Canada", "UK", "Australia");\n    }\n\n    @ModelAttribute("user")\n    public User getUser(@PathVariable(required = false) Long id) {\n        if (id != null) {\n            return userService.findById(id);\n        }\n        return new User();\n    }\n\n    // REST API with @ModelAttribute\n    @RestController\n    @RequestMapping("/api/users")\n    public static class UserRestController {\n\n        @PostMapping(consumes = MediaType.APPLICATION_FORM_URLENCODED_VALUE)\n        public ResponseEntity<User> createUserFromForm(@ModelAttribute @Valid UserForm form) {\n            User user = userService.create(form);\n            return ResponseEntity.status(HttpStatus.CREATED).body(user);\n        }\n    }\n}\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"validation-annotations",children:"Validation Annotations"}),"\n",(0,r.jsx)(n.h3,{id:"basic-validation-annotations",children:"Basic Validation Annotations"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'public class CreateUserRequest {\n    // Null checks\n    @NotNull(message = "ID cannot be null")\n    private Long id;\n\n    // String validations\n    @NotBlank(message = "Name is required") // Not null, not empty, not whitespace\n    @Size(min = 2, max = 50, message = "Name must be between 2 and 50 characters")\n    private String name;\n\n    @NotEmpty(message = "Email is required") // Not null and not empty\n    @Email(message = "Invalid email format")\n    private String email;\n\n    @Pattern(regexp = "^[0-9]{10}$", message = "Phone number must be 10 digits")\n    private String phoneNumber;\n\n    // Numeric validations\n    @Min(value = 18, message = "Age must be at least 18")\n    @Max(value = 120, message = "Age must be less than 120")\n    private Integer age;\n\n    @DecimalMin(value = "0.0", inclusive = false, message = "Salary must be positive")\n    @DecimalMax(value = "1000000.0", message = "Salary cannot exceed 1,000,000")\n    @Digits(integer = 7, fraction = 2, message = "Salary format: max 7 digits, 2 decimal places")\n    private BigDecimal salary;\n\n    // Boolean validation\n    @AssertTrue(message = "Must agree to terms and conditions")\n    private Boolean agreeToTerms;\n\n    @AssertFalse(message = "Cannot be a test account")\n    private Boolean isTestAccount;\n\n    // Date validations\n    @Past(message = "Birth date must be in the past")\n    private LocalDate birthDate;\n\n    @Future(message = "Event date must be in the future")\n    private LocalDateTime eventDate;\n\n    @PastOrPresent(message = "Created date must be in the past or present")\n    private LocalDateTime createdAt;\n\n    @FutureOrPresent(message = "Start date must be in the future or present")\n    private LocalDate startDate;\n\n    // Collection validations\n    @NotEmpty(message = "Skills list cannot be empty")\n    @Size(min = 1, max = 10, message = "Must have 1-10 skills")\n    private List<@NotBlank String> skills;\n\n    // Nested object validation\n    @Valid\n    @NotNull(message = "Address is required")\n    private Address address;\n\n    // Custom validation\n    @ValidPassword\n    private String password;\n\n    // Getters and setters...\n}\n\n// Nested object with validation\npublic class Address {\n    @NotBlank(message = "Street is required")\n    private String street;\n\n    @NotBlank(message = "City is required")\n    private String city;\n\n    @Pattern(regexp = "^[0-9]{5}(-[0-9]{4})?$", message = "Invalid ZIP code format")\n    private String zipCode;\n\n    @NotBlank(message = "Country is required")\n    private String country;\n\n    // Getters and setters...\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"custom-validation-annotations",children:"Custom Validation Annotations"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'// Custom validation annotation\n@Target({ElementType.FIELD, ElementType.PARAMETER})\n@Retention(RetentionPolicy.RUNTIME)\n@Constraint(validatedBy = PasswordValidator.class)\n@Documented\npublic @interface ValidPassword {\n    String message() default "Password must be at least 8 characters with uppercase, lowercase, digit and special character";\n    Class<?>[] groups() default {};\n    Class<? extends Payload>[] payload() default {};\n}\n\n// Validator implementation\npublic class PasswordValidator implements ConstraintValidator<ValidPassword, String> {\n    private static final String PASSWORD_PATTERN =\n        "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\\\d)(?=.*[@$!%*?&])[A-Za-z\\\\d@$!%*?&]{8,}$";\n\n    private final Pattern pattern = Pattern.compile(PASSWORD_PATTERN);\n\n    @Override\n    public boolean isValid(String password, ConstraintValidatorContext context) {\n        if (password == null) {\n            return false;\n        }\n        return pattern.matcher(password).matches();\n    }\n}\n\n// Class-level validation\n@ValidUserAge\npublic class User {\n    private LocalDate birthDate;\n    private Integer age;\n    // ...\n}\n\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Constraint(validatedBy = UserAgeValidator.class)\n@Documented\npublic @interface ValidUserAge {\n    String message() default "Age and birth date don\'t match";\n    Class<?>[] groups() default {};\n    Class<? extends Payload>[] payload() default {};\n}\n\npublic class UserAgeValidator implements ConstraintValidator<ValidUserAge, User> {\n    @Override\n    public boolean isValid(User user, ConstraintValidatorContext context) {\n        if (user.getBirthDate() == null || user.getAge() == null) {\n            return true; // Let other validations handle null checks\n        }\n\n        int calculatedAge = Period.between(user.getBirthDate(), LocalDate.now()).getYears();\n        return calculatedAge == user.getAge();\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"validation-groups",children:"Validation Groups"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'// Validation groups\npublic interface CreateValidation {}\npublic interface UpdateValidation {}\n\npublic class UserRequest {\n    @Null(groups = CreateValidation.class, message = "ID must be null for creation")\n    @NotNull(groups = UpdateValidation.class, message = "ID is required for update")\n    private Long id;\n\n    @NotBlank(groups = {CreateValidation.class, UpdateValidation.class},\n              message = "Name is required")\n    private String name;\n\n    @NotBlank(groups = CreateValidation.class, message = "Password is required for creation")\n    @Size(min = 8, groups = CreateValidation.class, message = "Password must be at least 8 characters")\n    private String password;\n\n    // Getters and setters...\n}\n\n@RestController\n@RequestMapping("/api/users")\n@Validated\npublic class UserController {\n\n    @PostMapping\n    public ResponseEntity<User> createUser(\n            @RequestBody @Validated(CreateValidation.class) UserRequest request) {\n        User user = userService.create(request);\n        return ResponseEntity.status(HttpStatus.CREATED).body(user);\n    }\n\n    @PutMapping("/{id}")\n    public ResponseEntity<User> updateUser(\n            @PathVariable Long id,\n            @RequestBody @Validated(UpdateValidation.class) UserRequest request) {\n        User user = userService.update(id, request);\n        return ResponseEntity.ok(user);\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"error-handling-for-validations",children:"Error Handling for Validations"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@ControllerAdvice\npublic class ValidationExceptionHandler {\n\n    // Handle @Valid and @Validated errors for @RequestBody\n    @ExceptionHandler(MethodArgumentNotValidException.class)\n    public ResponseEntity<ErrorResponse> handleValidationException(\n            MethodArgumentNotValidException ex) {\n\n        Map<String, String> errors = new HashMap<>();\n        ex.getBindingResult().getFieldErrors().forEach(error ->\n            errors.put(error.getField(), error.getDefaultMessage()));\n\n        ErrorResponse errorResponse = ErrorResponse.builder()\n            .status(HttpStatus.BAD_REQUEST.value())\n            .message("Validation failed")\n            .errors(errors)\n            .timestamp(LocalDateTime.now())\n            .build();\n\n        return ResponseEntity.badRequest().body(errorResponse);\n    }\n\n    // Handle @Validated errors for path variables and request parameters\n    @ExceptionHandler(ConstraintViolationException.class)\n    public ResponseEntity<ErrorResponse> handleConstraintViolation(\n            ConstraintViolationException ex) {\n\n        Map<String, String> errors = new HashMap<>();\n        ex.getConstraintViolations().forEach(violation -> {\n            String fieldName = violation.getPropertyPath().toString();\n            String message = violation.getMessage();\n            errors.put(fieldName, message);\n        });\n\n        ErrorResponse errorResponse = ErrorResponse.builder()\n            .status(HttpStatus.BAD_REQUEST.value())\n            .message("Constraint violation")\n            .errors(errors)\n            .timestamp(LocalDateTime.now())\n            .build();\n\n        return ResponseEntity.badRequest().body(errorResponse);\n    }\n}\n\n// Error response DTO\n@Data\n@Builder\npublic class ErrorResponse {\n    private int status;\n    private String message;\n    private Map<String, String> errors;\n    private LocalDateTime timestamp;\n}\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"relationship-mapping-annotations",children:"Relationship Mapping Annotations"}),"\n",(0,r.jsx)(n.h3,{id:"onetoone",children:"@OneToOne"}),"\n",(0,r.jsx)(n.p,{children:"One-to-one relationship mapping"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'// User entity (parent)\n@Entity\n@Table(name = "users")\npublic class User {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    private String name;\n    private String email;\n\n    // Unidirectional OneToOne\n    @OneToOne(cascade = CascadeType.ALL, fetch = FetchType.LAZY)\n    @JoinColumn(name = "profile_id", unique = true)\n    private UserProfile profile;\n\n    // Bidirectional OneToOne (owning side)\n    @OneToOne(cascade = CascadeType.ALL, fetch = FetchType.LAZY, orphanRemoval = true)\n    @JoinColumn(name = "address_id", unique = true)\n    private Address address;\n\n    // Constructors, getters, setters\n    public User() {}\n\n    public User(String name, String email) {\n        this.name = name;\n        this.email = email;\n    }\n\n    // Getters and setters...\n}\n\n// UserProfile entity (child)\n@Entity\n@Table(name = "user_profiles")\npublic class UserProfile {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    private String bio;\n    private String website;\n    private LocalDate birthDate;\n\n    // Constructors, getters, setters...\n}\n\n// Address entity (child with back-reference)\n@Entity\n@Table(name = "addresses")\npublic class Address {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    private String street;\n    private String city;\n    private String zipCode;\n    private String country;\n\n    // Bidirectional OneToOne (inverse/mapped side)\n    @OneToOne(mappedBy = "address", fetch = FetchType.LAZY)\n    private User user;\n\n    // Constructors, getters, setters...\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"onetomany--manytoone",children:"@OneToMany & @ManyToOne"}),"\n",(0,r.jsx)(n.p,{children:"One-to-many and many-to-one relationships"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'// Department entity (One side)\n@Entity\n@Table(name = "departments")\npublic class Department {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    private String name;\n    private String description;\n\n    // OneToMany (bidirectional)\n    @OneToMany(mappedBy = "department", cascade = CascadeType.ALL, fetch = FetchType.LAZY)\n    private List<Employee> employees = new ArrayList<>();\n\n    // OneToMany (unidirectional with join table)\n    @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.LAZY)\n    @JoinTable(\n        name = "department_projects",\n        joinColumns = @JoinColumn(name = "department_id"),\n        inverseJoinColumns = @JoinColumn(name = "project_id")\n    )\n    private Set<Project> projects = new HashSet<>();\n\n    // Helper methods for bidirectional relationship\n    public void addEmployee(Employee employee) {\n        employees.add(employee);\n        employee.setDepartment(this);\n    }\n\n    public void removeEmployee(Employee employee) {\n        employees.remove(employee);\n        employee.setDepartment(null);\n    }\n\n    // Constructors, getters, setters...\n}\n\n// Employee entity (Many side)\n@Entity\n@Table(name = "employees")\npublic class Employee {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    private String name;\n    private String email;\n    private BigDecimal salary;\n\n    // ManyToOne (owning side)\n    @ManyToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = "department_id", nullable = false)\n    private Department department;\n\n    // ManyToOne with custom foreign key\n    @ManyToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = "manager_id", referencedColumnName = "id")\n    private Employee manager;\n\n    // OneToMany (self-referencing)\n    @OneToMany(mappedBy = "manager", cascade = CascadeType.ALL)\n    private List<Employee> subordinates = new ArrayList<>();\n\n    // Constructors, getters, setters...\n}\n\n// Advanced OneToMany with ordering and filtering\n@Entity\npublic class Blog {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    private String title;\n\n    // Ordered collection\n    @OneToMany(mappedBy = "blog", cascade = CascadeType.ALL)\n    @OrderBy("createdAt DESC") // Order by creation date\n    private List<Post> posts = new ArrayList<>();\n\n    // Filtered collection\n    @OneToMany(mappedBy = "blog")\n    @Where(clause = "status = \'PUBLISHED\'") // Only published posts\n    private List<Post> publishedPosts = new ArrayList<>();\n\n    // Custom fetch with @Fetch\n    @OneToMany(mappedBy = "blog", fetch = FetchType.EAGER)\n    @Fetch(FetchMode.SUBSELECT) // Avoid N+1 problem\n    private Set<Category> categories = new HashSet<>();\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"manytomany",children:"@ManyToMany"}),"\n",(0,r.jsx)(n.p,{children:"Many-to-many relationship mapping"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'// Student entity\n@Entity\n@Table(name = "students")\npublic class Student {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    private String name;\n    private String email;\n\n    // ManyToMany (owning side)\n    @ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE}, fetch = FetchType.LAZY)\n    @JoinTable(\n        name = "student_courses", // Join table name\n        joinColumns = @JoinColumn(name = "student_id"), // Foreign key to Student\n        inverseJoinColumns = @JoinColumn(name = "course_id") // Foreign key to Course\n    )\n    private Set<Course> courses = new HashSet<>();\n\n    // Helper methods for bidirectional relationship\n    public void addCourse(Course course) {\n        courses.add(course);\n        course.getStudents().add(this);\n    }\n\n    public void removeCourse(Course course) {\n        courses.remove(course);\n        course.getStudents().remove(this);\n    }\n\n    // Constructors, getters, setters...\n}\n\n// Course entity\n@Entity\n@Table(name = "courses")\npublic class Course {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    private String name;\n    private String code;\n    private Integer credits;\n\n    // ManyToMany (inverse side)\n    @ManyToMany(mappedBy = "courses", fetch = FetchType.LAZY)\n    private Set<Student> students = new HashSet<>();\n\n    // Constructors, getters, setters...\n}\n\n// ManyToMany with additional attributes using @JoinTable\n@Entity\npublic class Author {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    private String name;\n\n    // ManyToMany with join entity for additional attributes\n    @OneToMany(mappedBy = "author", cascade = CascadeType.ALL)\n    private Set<BookAuthor> bookAuthors = new HashSet<>();\n\n    // Helper method\n    public void addBook(Book book, String role) {\n        BookAuthor bookAuthor = new BookAuthor(this, book, role);\n        bookAuthors.add(bookAuthor);\n        book.getBookAuthors().add(bookAuthor);\n    }\n}\n\n@Entity\npublic class Book {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    private String title;\n\n    @OneToMany(mappedBy = "book", cascade = CascadeType.ALL)\n    private Set<BookAuthor> bookAuthors = new HashSet<>();\n}\n\n// Join entity with additional attributes\n@Entity\n@Table(name = "book_authors")\npublic class BookAuthor {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    @ManyToOne\n    @JoinColumn(name = "author_id")\n    private Author author;\n\n    @ManyToOne\n    @JoinColumn(name = "book_id")\n    private Book book;\n\n    private String role; // e.g., "PRIMARY", "CO_AUTHOR", "EDITOR"\n\n    @CreationTimestamp\n    private LocalDateTime assignedAt;\n\n    // Constructors\n    public BookAuthor() {}\n\n    public BookAuthor(Author author, Book book, String role) {\n        this.author = author;\n        this.book = book;\n        this.role = role;\n    }\n\n    // Getters and setters...\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"joincolumn--jointable",children:"@JoinColumn & @JoinTable"}),"\n",(0,r.jsx)(n.p,{children:"Customize foreign key columns and join tables"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Entity\n@Table(name = "orders")\npublic class Order {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    // Custom foreign key column name\n    @ManyToOne(fetch = FetchType.LAZY)\n    @JoinColumn(\n        name = "customer_id", // Column name in orders table\n        referencedColumnName = "id", // Referenced column in customer table\n        nullable = false,\n        foreignKey = @ForeignKey(name = "fk_order_customer")\n    )\n    private Customer customer;\n\n    // Composite foreign key\n    @ManyToOne\n    @JoinColumns({\n        @JoinColumn(name = "product_code", referencedColumnName = "code"),\n        @JoinColumn(name = "product_version", referencedColumnName = "version")\n    })\n    private Product product;\n\n    // Self-referencing with custom column\n    @ManyToOne\n    @JoinColumn(name = "parent_order_id")\n    private Order parentOrder;\n\n    @OneToMany(mappedBy = "parentOrder")\n    private List<Order> subOrders = new ArrayList<>();\n}\n\n// Custom join table configuration\n@Entity\npublic class User {\n    @Id\n    private Long id;\n\n    @ManyToMany\n    @JoinTable(\n        name = "user_roles", // Custom table name\n        joinColumns = @JoinColumn(\n            name = "user_id",\n            foreignKey = @ForeignKey(name = "fk_user_role_user")\n        ),\n        inverseJoinColumns = @JoinColumn(\n            name = "role_id",\n            foreignKey = @ForeignKey(name = "fk_user_role_role")\n        ),\n        uniqueConstraints = @UniqueConstraint(\n            name = "uk_user_role",\n            columnNames = {"user_id", "role_id"}\n        ),\n        indexes = {\n            @Index(name = "idx_user_roles_user", columnList = "user_id"),\n            @Index(name = "idx_user_roles_role", columnList = "role_id")\n        }\n    )\n    private Set<Role> roles = new HashSet<>();\n}\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"spring-core-annotations",children:"Spring Core Annotations"}),"\n",(0,r.jsx)(n.h3,{id:"dependency-injection-annotations",children:"Dependency Injection Annotations"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'// Service layer\n@Service\n@Transactional\npublic class UserService {\n\n    // Field injection (not recommended in production)\n    @Autowired\n    private UserRepository userRepository;\n\n    // Constructor injection (recommended)\n    private final EmailService emailService;\n    private final ValidationService validationService;\n\n    @Autowired\n    public UserService(EmailService emailService, ValidationService validationService) {\n        this.emailService = emailService;\n        this.validationService = validationService;\n    }\n\n    // Setter injection\n    private AuditService auditService;\n\n    @Autowired\n    public void setAuditService(AuditService auditService) {\n        this.auditService = auditService;\n    }\n\n    // Qualified injection when multiple beans of same type exist\n    @Autowired\n    @Qualifier("primaryEmailService")\n    private EmailService primaryEmailService;\n\n    // Optional dependency\n    @Autowired(required = false)\n    private NotificationService notificationService;\n\n    // Collection injection\n    @Autowired\n    private List<PaymentProcessor> paymentProcessors;\n\n    @Autowired\n    private Map<String, CacheManager> cacheManagers;\n\n    public User createUser(CreateUserRequest request) {\n        validationService.validate(request);\n\n        User user = new User();\n        user.setName(request.getName());\n        user.setEmail(request.getEmail());\n\n        User savedUser = userRepository.save(user);\n\n        // Send welcome email\n        emailService.sendWelcomeEmail(savedUser);\n\n        // Optional notification\n        if (notificationService != null) {\n            notificationService.notify(savedUser);\n        }\n\n        // Audit\n        auditService.logUserCreation(savedUser);\n\n        return savedUser;\n    }\n}\n\n// Repository layer\n@Repository\npublic class CustomUserRepository {\n\n    @Autowired\n    private EntityManager entityManager;\n\n    @PersistenceContext\n    private EntityManager em; // Alternative for EntityManager injection\n\n    public List<User> findUsersByCustomCriteria(String criteria) {\n        String jpql = "SELECT u FROM User u WHERE u.name LIKE :criteria";\n        return entityManager.createQuery(jpql, User.class)\n                          .setParameter("criteria", "%" + criteria + "%")\n                          .getResultList();\n    }\n}\n\n// Component scanning and stereotypes\n@Component("userValidator")\npublic class UserValidator {\n\n    public boolean validate(User user) {\n        return user.getName() != null && user.getEmail() != null;\n    }\n}\n\n@Component\n@Primary // This bean will be preferred when multiple beans of same type exist\npublic class PrimaryEmailService implements EmailService {\n\n    @Override\n    public void sendEmail(String to, String subject, String body) {\n        // Primary email implementation\n    }\n}\n\n@Component\n@Qualifier("backup")\npublic class BackupEmailService implements EmailService {\n\n    @Override\n    public void sendEmail(String to, String subject, String body) {\n        // Backup email implementation\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"configuration-annotations",children:"Configuration Annotations"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'// Main application class\n@SpringBootApplication // Combines @Configuration, @EnableAutoConfiguration, @ComponentScan\n@EnableJpaRepositories(basePackages = "com.example.repository")\n@EnableTransactionManagement\n@EnableScheduling\n@EnableAsync\npublic class Application {\n\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n\n    // Bean definitions in main class\n    @Bean\n    @Primary\n    public PasswordEncoder passwordEncoder() {\n        return new BCryptPasswordEncoder();\n    }\n}\n\n// Configuration class\n@Configuration\n@PropertySource("classpath:custom.properties")\n@EnableConfigurationProperties({DatabaseProperties.class, EmailProperties.class})\npublic class AppConfig {\n\n    // Simple bean definition\n    @Bean\n    public RestTemplate restTemplate() {\n        return new RestTemplate();\n    }\n\n    // Bean with dependencies\n    @Bean\n    public EmailService emailService(@Value("${email.smtp.host}") String smtpHost,\n                                   @Value("${email.smtp.port}") int smtpPort) {\n        return new EmailServiceImpl(smtpHost, smtpPort);\n    }\n\n    // Conditional bean creation\n    @Bean\n    @ConditionalOnProperty(name = "cache.enabled", havingValue = "true")\n    public CacheManager cacheManager() {\n        return new ConcurrentMapCacheManager();\n    }\n\n    @Bean\n    @ConditionalOnMissingBean\n    public DefaultUserService defaultUserService() {\n        return new DefaultUserService();\n    }\n\n    // Profile-specific beans\n    @Bean\n    @Profile("development")\n    public DataSource developmentDataSource() {\n        return new EmbeddedDatabaseBuilder()\n                .setType(EmbeddedDatabaseType.H2)\n                .build();\n    }\n\n    @Bean\n    @Profile("production")\n    public DataSource productionDataSource() {\n        HikariConfig config = new HikariConfig();\n        config.setJdbcUrl("jdbc:mysql://localhost:3306/mydb");\n        config.setUsername("user");\n        config.setPassword("password");\n        return new HikariDataSource(config);\n    }\n\n    // Method-level configuration\n    @Bean\n    @Scope("prototype") // New instance for each request\n    public ShoppingCart shoppingCart() {\n        return new ShoppingCart();\n    }\n\n    @Bean\n    @Scope("request") // One instance per HTTP request\n    public RequestContext requestContext() {\n        return new RequestContext();\n    }\n\n    // Lazy initialization\n    @Bean\n    @Lazy\n    public ExpensiveService expensiveService() {\n        return new ExpensiveService();\n    }\n}\n\n// Configuration properties\n@ConfigurationProperties(prefix = "database")\n@Data\n@Component\npublic class DatabaseProperties {\n    private String url;\n    private String username;\n    private String password;\n    private int maxConnections;\n    private boolean enableSsl;\n}\n\n@ConfigurationProperties(prefix = "email")\n@Data\n@Validated\npublic class EmailProperties {\n    @NotBlank\n    private String host;\n\n    @Range(min = 1, max = 65535)\n    private int port;\n\n    @Email\n    private String from;\n\n    private boolean enabled = true;\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"value-injection-annotations",children:"Value Injection Annotations"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Component\npublic class ConfigurableService {\n\n    // Simple property injection\n    @Value("${app.name}")\n    private String appName;\n\n    // With default value\n    @Value("${app.version:1.0.0}")\n    private String appVersion;\n\n    // System property\n    @Value("${java.home}")\n    private String javaHome;\n\n    // Environment variable\n    @Value("${HOME}")\n    private String homeDirectory;\n\n    // Expression evaluation\n    @Value("#{systemProperties[\'user.home\']}")\n    private String userHome;\n\n    // Mathematical expressions\n    @Value("#{10 * 2}")\n    private int calculatedValue;\n\n    // Bean property access\n    @Value("#{databaseProperties.maxConnections}")\n    private int maxConnections;\n\n    // Collection from properties\n    @Value("${app.supported.languages}")\n    private List<String> supportedLanguages; // Comma-separated values\n\n    // Map from properties\n    @Value("#{${app.database.pools}}")\n    private Map<String, String> databasePools;\n\n    // Constructor injection with @Value\n    public ConfigurableService(@Value("${app.timeout:5000}") int timeout,\n                              @Value("${app.retry.attempts:3}") int retryAttempts) {\n        // Initialize with values\n    }\n\n    // Method parameter injection\n    @EventListener\n    public void handleEvent(@Value("${app.event.enabled:true}") boolean enabled,\n                           ApplicationEvent event) {\n        if (enabled) {\n            // Handle event\n        }\n    }\n}\n\n// Environment access\n@Service\npublic class EnvironmentService {\n\n    @Autowired\n    private Environment environment;\n\n    public void printProperties() {\n        // Get property with default\n        String appName = environment.getProperty("app.name", "Default App");\n\n        // Get required property (throws exception if not found)\n        String dbUrl = environment.getRequiredProperty("database.url");\n\n        // Get property with type conversion\n        Integer port = environment.getProperty("server.port", Integer.class, 8080);\n\n        // Check active profiles\n        String[] activeProfiles = environment.getActiveProfiles();\n\n        // Check if profile is active\n        boolean isDev = environment.acceptsProfiles("development");\n    }\n}\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"security-annotations",children:"Security Annotations"}),"\n",(0,r.jsx)(n.h3,{id:"method-level-security",children:"Method-Level Security"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@RestController\n@RequestMapping("/api/admin")\n@PreAuthorize("hasRole(\'ADMIN\')") // Apply to all methods in controller\npublic class AdminController {\n\n    // Role-based access control\n    @GetMapping("/users")\n    @PreAuthorize("hasRole(\'ADMIN\') or hasRole(\'MANAGER\')")\n    public ResponseEntity<List<User>> getAllUsers() {\n        return ResponseEntity.ok(userService.findAll());\n    }\n\n    // Authority-based access control\n    @PostMapping("/users")\n    @PreAuthorize("hasAuthority(\'USER_CREATE\')")\n    public ResponseEntity<User> createUser(@RequestBody CreateUserRequest request) {\n        return ResponseEntity.ok(userService.create(request));\n    }\n\n    // Expression-based authorization\n    @PutMapping("/users/{id}")\n    @PreAuthorize("hasRole(\'ADMIN\') or (hasRole(\'MANAGER\') and #id == authentication.principal.id)")\n    public ResponseEntity<User> updateUser(@PathVariable Long id, @RequestBody UpdateUserRequest request) {\n        return ResponseEntity.ok(userService.update(id, request));\n    }\n\n    // Post-authorization (check return value)\n    @GetMapping("/users/{id}")\n    @PostAuthorize("hasRole(\'ADMIN\') or returnObject.body.id == authentication.principal.id")\n    public ResponseEntity<User> getUser(@PathVariable Long id) {\n        return ResponseEntity.ok(userService.findById(id));\n    }\n\n    // Method parameter access control\n    @DeleteMapping("/users/{id}")\n    @PreAuthorize("hasRole(\'ADMIN\') or @userService.isOwner(#id, authentication.principal.id)")\n    public ResponseEntity<Void> deleteUser(@PathVariable Long id) {\n        userService.delete(id);\n        return ResponseEntity.noContent().build();\n    }\n}\n\n@Service\npublic class UserService {\n\n    // Filtering collections based on permissions\n    @PostFilter("hasRole(\'ADMIN\') or filterObject.department == authentication.principal.department")\n    public List<User> findAllInDepartment() {\n        return userRepository.findAll();\n    }\n\n    // Filtering method parameters\n    @PreFilter("hasRole(\'ADMIN\') or filterObject.departmentId == authentication.principal.departmentId")\n    public List<User> createUsers(List<CreateUserRequest> requests) {\n        return requests.stream()\n                      .map(this::create)\n                      .collect(Collectors.toList());\n    }\n\n    // Custom security expression\n    @PreAuthorize("@securityService.canAccessUser(authentication, #userId)")\n    public User findById(Long userId) {\n        return userRepository.findById(userId).orElse(null);\n    }\n\n    // Secured annotation (simpler alternative)\n    @Secured({"ROLE_ADMIN", "ROLE_MANAGER"})\n    public void performAdminTask() {\n        // Admin task\n    }\n\n    // JSR-250 annotations\n    @RolesAllowed({"ADMIN", "MANAGER"})\n    public void jsr250SecuredMethod() {\n        // JSR-250 secured method\n    }\n\n    @PermitAll\n    public List<User> getPublicUsers() {\n        return userRepository.findPublicUsers();\n    }\n\n    @DenyAll\n    public void restrictedMethod() {\n        // This method is never accessible\n    }\n}\n\n// Custom security service\n@Service\npublic class SecurityService {\n\n    public boolean canAccessUser(Authentication authentication, Long userId) {\n        // Custom logic to determine access\n        UserPrincipal principal = (UserPrincipal) authentication.getPrincipal();\n        return principal.hasRole("ADMIN") || principal.getId().equals(userId);\n    }\n\n    public boolean isOwner(Long resourceId, Long userId) {\n        // Check if user owns the resource\n        return resourceService.isOwner(resourceId, userId);\n    }\n}\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"testing-annotations",children:"Testing Annotations"}),"\n",(0,r.jsx)(n.h3,{id:"integration-testing",children:"Integration Testing"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'// Full Spring Boot test\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)\n@TestPropertySource(locations = "classpath:test.properties")\n@ActiveProfiles("test")\nclass UserControllerIntegrationTest {\n\n    @Autowired\n    private TestRestTemplate restTemplate;\n\n    @Autowired\n    private UserRepository userRepository;\n\n    @LocalServerPort\n    private int port;\n\n    @Test\n    void shouldCreateUser() {\n        CreateUserRequest request = new CreateUserRequest("John Doe", "john@example.com");\n\n        ResponseEntity<User> response = restTemplate.postForEntity(\n            "/api/users", request, User.class);\n\n        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.CREATED);\n        assertThat(response.getBody().getName()).isEqualTo("John Doe");\n    }\n}\n\n// Web layer test (controllers only)\n@WebMvcTest(UserController.class)\nclass UserControllerTest {\n\n    @Autowired\n    private MockMvc mockMvc;\n\n    @MockBean\n    private UserService userService;\n\n    @Test\n    void shouldReturnUser() throws Exception {\n        User user = new User(1L, "John Doe", "john@example.com");\n        given(userService.findById(1L)).willReturn(user);\n\n        mockMvc.perform(get("/api/users/1"))\n               .andExpect(status().isOk())\n               .andExpected(jsonPath("$.name").value("John Doe"))\n               .andExpected(jsonPath("$.email").value("john@example.com"));\n    }\n\n    @Test\n    void shouldCreateUser() throws Exception {\n        CreateUserRequest request = new CreateUserRequest("Jane Doe", "jane@example.com");\n        User createdUser = new User(2L, "Jane Doe", "jane@example.com");\n\n        given(userService.create(any(CreateUserRequest.class))).willReturn(createdUser);\n\n        mockMvc.perform(post("/api/users")\n                       .contentType(MediaType.APPLICATION_JSON)\n                       .content("""\n                           {\n                               "name": "Jane Doe",\n                               "email": "jane@example.com"\n                           }\n                           """))\n               .andExpected(status().isCreated())\n               .andExpected(jsonPath("$.name").value("Jane Doe"));\n    }\n}\n\n// Data layer test (repositories only)\n@DataJpaTest\n@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)\nclass UserRepositoryTest {\n\n    @Autowired\n    private TestEntityManager entityManager;\n\n    @Autowired\n    private UserRepository userRepository;\n\n    @Test\n    void shouldFindUserByEmail() {\n        // Given\n        User user = new User("John Doe", "john@example.com");\n        entityManager.persistAndFlush(user);\n\n        // When\n        Optional<User> found = userRepository.findByEmail("john@example.com");\n\n        // Then\n        assertThat(found).isPresent();\n        assertThat(found.get().getName()).isEqualTo("John Doe");\n    }\n}\n\n// Service layer test\n@ExtendWith(MockitoExtension.class)\nclass UserServiceTest {\n\n    @Mock\n    private UserRepository userRepository;\n\n    @Mock\n    private EmailService emailService;\n\n    @InjectMocks\n    private UserService userService;\n\n    @Test\n    void shouldCreateUser() {\n        // Given\n        CreateUserRequest request = new CreateUserRequest("John Doe", "john@example.com");\n        User savedUser = new User(1L, "John Doe", "john@example.com");\n\n        given(userRepository.save(any(User.class))).willReturn(savedUser);\n\n        // When\n        User result = userService.create(request);\n\n        // Then\n        assertThat(result.getName()).isEqualTo("John Doe");\n        verify(emailService).sendWelcomeEmail(savedUser);\n    }\n}\n\n// JSON serialization test\n@JsonTest\nclass UserJsonTest {\n\n    @Autowired\n    private JacksonTester<User> json;\n\n    @Test\n    void shouldSerializeUser() throws Exception {\n        User user = new User(1L, "John Doe", "john@example.com");\n\n        assertThat(json.write(user)).isEqualToJson("""\n            {\n                "id": 1,\n                "name": "John Doe",\n                "email": "john@example.com"\n            }\n            """);\n    }\n\n    @Test\n    void shouldDeserializeUser() throws Exception {\n        String content = """\n            {\n                "id": 1,\n                "name": "John Doe",\n                "email": "john@example.com"\n            }\n            """;\n\n        User user = json.parseObject(content);\n\n        assertThat(user.getId()).isEqualTo(1L);\n        assertThat(user.getName()).isEqualTo("John Doe");\n    }\n}\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"best-practices--common-patterns",children:"Best Practices & Common Patterns"}),"\n",(0,r.jsx)(n.h3,{id:"controller-best-practices",children:"Controller Best Practices"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@RestController\n@RequestMapping("/api/v1/users")\n@Validated\n@Slf4j\npublic class UserController {\n\n    private final UserService userService;\n\n    // Constructor injection (recommended)\n    public UserController(UserService userService) {\n        this.userService = userService;\n    }\n\n    @GetMapping\n    public ResponseEntity<PagedResponse<UserDto>> getUsers(\n            @RequestParam(defaultValue = "0") @Min(0) int page,\n            @RequestParam(defaultValue = "20") @Min(1) @Max(100) int size,\n            @RequestParam(required = false) String search) {\n\n        log.info("Fetching users - page: {}, size: {}, search: {}", page, size, search);\n\n        PagedResponse<UserDto> users = userService.findAll(page, size, search);\n        return ResponseEntity.ok(users);\n    }\n\n    @PostMapping\n    public ResponseEntity<UserDto> createUser(\n            @RequestBody @Valid CreateUserRequest request,\n            HttpServletRequest httpRequest) {\n\n        log.info("Creating user with email: {}", request.getEmail());\n\n        UserDto user = userService.create(request);\n\n        URI location = ServletUriComponentsBuilder\n            .fromCurrentRequest()\n            .path("/{id}")\n            .buildAndExpand(user.getId())\n            .toUri();\n\n        return ResponseEntity.created(location).body(user);\n    }\n\n    @ExceptionHandler(UserNotFoundException.class)\n    public ResponseEntity<ErrorResponse> handleUserNotFound(UserNotFoundException ex) {\n        ErrorResponse error = ErrorResponse.builder()\n            .status(HttpStatus.NOT_FOUND.value())\n            .message(ex.getMessage())\n            .timestamp(LocalDateTime.now())\n            .build();\n\n        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"service-layer-patterns",children:"Service Layer Patterns"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Service\n@Transactional(readOnly = true)\n@Slf4j\npublic class UserService {\n\n    private final UserRepository userRepository;\n    private final PasswordEncoder passwordEncoder;\n    private final EmailService emailService;\n    private final UserMapper userMapper;\n\n    public UserService(UserRepository userRepository,\n                      PasswordEncoder passwordEncoder,\n                      EmailService emailService,\n                      UserMapper userMapper) {\n        this.userRepository = userRepository;\n        this.passwordEncoder = passwordEncoder;\n        this.emailService = emailService;\n        this.userMapper = userMapper;\n    }\n\n    @Transactional\n    public UserDto create(CreateUserRequest request) {\n        validateUniqueEmail(request.getEmail());\n\n        User user = User.builder()\n            .name(request.getName())\n            .email(request.getEmail())\n            .password(passwordEncoder.encode(request.getPassword()))\n            .status(UserStatus.ACTIVE)\n            .createdAt(LocalDateTime.now())\n            .build();\n\n        User savedUser = userRepository.save(user);\n\n        // Async operations\n        emailService.sendWelcomeEmailAsync(savedUser);\n\n        log.info("User created successfully: {}", savedUser.getId());\n        return userMapper.toDto(savedUser);\n    }\n\n    private void validateUniqueEmail(String email) {\n        if (userRepository.existsByEmail(email)) {\n            throw new EmailAlreadyExistsException("Email already exists: " + email);\n        }\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"repository-patterns",children:"Repository Patterns"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Repository\npublic interface UserRepository extends JpaRepository<User, Long>, JpaSpecificationExecutor<User> {\n\n    Optional<User> findByEmail(String email);\n\n    boolean existsByEmail(String email);\n\n    @Query("SELECT u FROM User u WHERE u.status = :status")\n    List<User> findByStatus(@Param("status") UserStatus status);\n\n    @Query(value = "SELECT * FROM users u WHERE u.created_at >= :date", nativeQuery = true)\n    List<User> findUsersCreatedAfter(@Param("date") LocalDateTime date);\n\n    @Modifying\n    @Query("UPDATE User u SET u.lastLoginAt = :loginTime WHERE u.id = :userId")\n    void updateLastLoginTime(@Param("userId") Long userId, @Param("loginTime") LocalDateTime loginTime);\n}\n\n// Custom repository implementation\n@Repository\npublic class CustomUserRepositoryImpl implements CustomUserRepository {\n\n    @PersistenceContext\n    private EntityManager entityManager;\n\n    @Override\n    public Page<User> findByDynamicCriteria(UserSearchCriteria criteria, Pageable pageable) {\n        CriteriaBuilder cb = entityManager.getCriteriaBuilder();\n        CriteriaQuery<User> query = cb.createQuery(User.class);\n        Root<User> user = query.from(User.class);\n\n        List<Predicate> predicates = new ArrayList<>();\n\n        if (criteria.getName() != null) {\n            predicates.add(cb.like(cb.lower(user.get("name")),\n                                 "%" + criteria.getName().toLowerCase() + "%"));\n        }\n\n        if (criteria.getEmail() != null) {\n            predicates.add(cb.equal(user.get("email"), criteria.getEmail()));\n        }\n\n        if (!predicates.isEmpty()) {\n            query.where(cb.and(predicates.toArray(new Predicate[0])));\n        }\n\n        TypedQuery<User> typedQuery = entityManager.createQuery(query);\n        typedQuery.setFirstResult((int) pageable.getOffset());\n        typedQuery.setMaxResults(pageable.getPageSize());\n\n        List<User> users = typedQuery.getResultList();\n        long total = countByDynamicCriteria(criteria);\n\n        return new PageImpl<>(users, pageable, total);\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"dtos-and-mapping",children:"DTOs and Mapping"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'// Request DTOs\n@Data\n@Builder\n@NoArgsConstructor\n@AllArgsConstructor\npublic class CreateUserRequest {\n    @NotBlank(message = "Name is required")\n    @Size(min = 2, max = 50)\n    private String name;\n\n    @NotBlank(message = "Email is required")\n    @Email(message = "Invalid email format")\n    private String email;\n\n    @NotBlank(message = "Password is required")\n    @Size(min = 8, max = 100)\n    private String password;\n}\n\n// Response DTOs\n@Data\n@Builder\n@JsonInclude(JsonInclude.Include.NON_NULL)\npublic class UserDto {\n    private Long id;\n    private String name;\n    private String email;\n    private UserStatus status;\n\n    @JsonFormat(pattern = "yyyy-MM-dd\'T\'HH:mm:ss")\n    private LocalDateTime createdAt;\n\n    @JsonFormat(pattern = "yyyy-MM-dd\'T\'HH:mm:ss")\n    private LocalDateTime updatedAt;\n}\n\n// MapStruct mapper\n@Mapper(componentModel = "spring")\npublic interface UserMapper {\n\n    UserDto toDto(User user);\n\n    @Mapping(target = "id", ignore = true)\n    @Mapping(target = "createdAt", ignore = true)\n    @Mapping(target = "updatedAt", ignore = true)\n    User toEntity(CreateUserRequest request);\n\n    List<UserDto> toDtoList(List<User> users);\n\n    @Mapping(target = "password", ignore = true)\n    void updateUserFromDto(UpdateUserRequest request, @MappingTarget User user);\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"configuration-classes",children:"Configuration Classes"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Configuration\n@EnableConfigurationProperties({DatabaseProperties.class, EmailProperties.class})\npublic class ApplicationConfig {\n\n    @Bean\n    @Primary\n    public PasswordEncoder passwordEncoder() {\n        return new BCryptPasswordEncoder(12);\n    }\n\n    @Bean\n    public RestTemplate restTemplate() {\n        RestTemplate template = new RestTemplate();\n        template.setRequestFactory(new HttpComponentsClientHttpRequestFactory());\n        return template;\n    }\n\n    @Bean\n    @ConditionalOnProperty(name = "app.async.enabled", havingValue = "true")\n    public TaskExecutor taskExecutor() {\n        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();\n        executor.setCorePoolSize(5);\n        executor.setMaxPoolSize(10);\n        executor.setQueueCapacity(25);\n        executor.setThreadNamePrefix("async-");\n        executor.initialize();\n        return executor;\n    }\n\n    @Bean\n    public ModelMapper modelMapper() {\n        ModelMapper mapper = new ModelMapper();\n        mapper.getConfiguration()\n              .setMatchingStrategy(MatchingStrategies.STRICT)\n              .setFieldMatchingEnabled(true)\n              .setFieldAccessLevel(org.modelmapper.config.Configuration.AccessLevel.PRIVATE);\n        return mapper;\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"exception-handling",children:"Exception Handling"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@ControllerAdvice\n@Slf4j\npublic class GlobalExceptionHandler {\n\n    @ExceptionHandler(MethodArgumentNotValidException.class)\n    public ResponseEntity<ErrorResponse> handleValidationException(\n            MethodArgumentNotValidException ex) {\n\n        Map<String, String> errors = new HashMap<>();\n        ex.getBindingResult().getFieldErrors().forEach(error ->\n            errors.put(error.getField(), error.getDefaultMessage()));\n\n        ErrorResponse errorResponse = ErrorResponse.builder()\n            .status(HttpStatus.BAD_REQUEST.value())\n            .message("Validation failed")\n            .errors(errors)\n            .timestamp(LocalDateTime.now())\n            .path(getRequestPath())\n            .build();\n\n        log.warn("Validation error: {}", errors);\n        return ResponseEntity.badRequest().body(errorResponse);\n    }\n\n    @ExceptionHandler(EntityNotFoundException.class)\n    public ResponseEntity<ErrorResponse> handleEntityNotFound(\n            EntityNotFoundException ex) {\n\n        ErrorResponse errorResponse = ErrorResponse.builder()\n            .status(HttpStatus.NOT_FOUND.value())\n            .message(ex.getMessage())\n            .timestamp(LocalDateTime.now())\n            .path(getRequestPath())\n            .build();\n\n        log.warn("Entity not found: {}", ex.getMessage());\n        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(errorResponse);\n    }\n\n    @ExceptionHandler(Exception.class)\n    public ResponseEntity<ErrorResponse> handleGenericException(Exception ex) {\n        ErrorResponse errorResponse = ErrorResponse.builder()\n            .status(HttpStatus.INTERNAL_SERVER_ERROR.value())\n            .message("An unexpected error occurred")\n            .timestamp(LocalDateTime.now())\n            .path(getRequestPath())\n            .build();\n\n        log.error("Unexpected error", ex);\n        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);\n    }\n\n    private String getRequestPath() {\n        RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();\n        if (requestAttributes instanceof ServletRequestAttributes) {\n            HttpServletRequest request = ((ServletRequestAttributes) requestAttributes).getRequest();\n            return request.getRequestURI();\n        }\n        return "unknown";\n    }\n}\n\n@Data\n@Builder\npublic class ErrorResponse {\n    private int status;\n    private String message;\n    private Map<String, String> errors;\n    private LocalDateTime timestamp;\n    private String path;\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"security-configuration",children:"Security Configuration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Configuration\n@EnableWebSecurity\n@EnableMethodSecurity(prePostEnabled = true)\npublic class SecurityConfig {\n\n    private final JwtAuthenticationEntryPoint jwtAuthenticationEntryPoint;\n    private final JwtRequestFilter jwtRequestFilter;\n\n    public SecurityConfig(JwtAuthenticationEntryPoint jwtAuthenticationEntryPoint,\n                         JwtRequestFilter jwtRequestFilter) {\n        this.jwtAuthenticationEntryPoint = jwtAuthenticationEntryPoint;\n        this.jwtRequestFilter = jwtRequestFilter;\n    }\n\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        http.csrf(csrf -> csrf.disable())\n            .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))\n            .exceptionHandling(exceptions -> exceptions.authenticationEntryPoint(jwtAuthenticationEntryPoint))\n            .authorizeHttpRequests(authz -> authz\n                .requestMatchers("/api/auth/**").permitAll()\n                .requestMatchers("/api/public/**").permitAll()\n                .requestMatchers(HttpMethod.GET, "/api/users/**").hasAnyRole("USER", "ADMIN")\n                .requestMatchers(HttpMethod.POST, "/api/users/**").hasRole("ADMIN")\n                .anyRequest().authenticated()\n            );\n\n        http.addFilterBefore(jwtRequestFilter, UsernamePasswordAuthenticationFilter.class);\n        return http.build();\n    }\n\n    @Bean\n    public AuthenticationManager authenticationManager(\n            AuthenticationConfiguration authConfig) throws Exception {\n        return authConfig.getAuthenticationManager();\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"testing-patterns",children:"Testing Patterns"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@SpringBootTest\n@TestPropertySource(locations = "classpath:application-test.properties")\n@ActiveProfiles("test")\nclass UserServiceIntegrationTest {\n\n    @Autowired\n    private UserService userService;\n\n    @Autowired\n    private UserRepository userRepository;\n\n    @Autowired\n    private TestEntityManager entityManager;\n\n    @Test\n    @Transactional\n    @Rollback\n    void shouldCreateUserSuccessfully() {\n        // Given\n        CreateUserRequest request = CreateUserRequest.builder()\n            .name("John Doe")\n            .email("john@example.com")\n            .password("password123")\n            .build();\n\n        // When\n        UserDto result = userService.create(request);\n\n        // Then\n        assertThat(result).isNotNull();\n        assertThat(result.getName()).isEqualTo("John Doe");\n        assertThat(result.getEmail()).isEqualTo("john@example.com");\n\n        // Verify in database\n        Optional<User> saved = userRepository.findByEmail("john@example.com");\n        assertThat(saved).isPresent();\n        assertThat(saved.get().getName()).isEqualTo("John Doe");\n    }\n\n    @Test\n    void shouldThrowExceptionWhenEmailExists() {\n        // Given\n        User existingUser = User.builder()\n            .name("Jane Doe")\n            .email("existing@example.com")\n            .password("encoded-password")\n            .build();\n        entityManager.persistAndFlush(existingUser);\n\n        CreateUserRequest request = CreateUserRequest.builder()\n            .name("John Doe")\n            .email("existing@example.com")\n            .password("password123")\n            .build();\n\n        // When & Then\n        assertThatThrownBy(() -> userService.create(request))\n            .isInstanceOf(EmailAlreadyExistsException.class)\n            .hasMessage("Email already exists: existing@example.com");\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"utility-classes",children:"Utility Classes"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@UtilityClass\npublic class ValidationUtils {\n\n    public static boolean isValidEmail(String email) {\n        return email != null && email.matches("^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}$");\n    }\n\n    public static boolean isStrongPassword(String password) {\n        return password != null &&\n               password.length() >= 8 &&\n               password.matches(".*[A-Z].*") &&\n               password.matches(".*[a-z].*") &&\n               password.matches(".*\\\\d.*") &&\n               password.matches(".*[!@#$%^&*()_+\\\\-=\\\\[\\\\]{};\':\\"\\\\\\\\|,.<>/?].*");\n    }\n}\n\n@Component\n@Slf4j\npublic class DatabaseHealthIndicator implements HealthIndicator {\n\n    private final DataSource dataSource;\n\n    public DatabaseHealthIndicator(DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n\n    @Override\n    public Health health() {\n        try (Connection connection = dataSource.getConnection()) {\n            if (connection.isValid(1)) {\n                return Health.up()\n                    .withDetail("database", "Available")\n                    .withDetail("validationQuery", "Connection is valid")\n                    .build();\n            }\n        } catch (SQLException e) {\n            log.error("Database health check failed", e);\n        }\n\n        return Health.down()\n            .withDetail("database", "Unavailable")\n            .build();\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Service\n@Transactional(readOnly = true)\npublic class OptimizedUserService {\n\n    @Cacheable(value = "users", key = "#id")\n    public UserDto findById(Long id) {\n        return userRepository.findById(id)\n            .map(userMapper::toDto)\n            .orElseThrow(() -> new UserNotFoundException("User not found: " + id));\n    }\n\n    @CacheEvict(value = "users", key = "#result.id")\n    @Transactional\n    public UserDto update(Long id, UpdateUserRequest request) {\n        User user = userRepository.findById(id)\n            .orElseThrow(() -> new UserNotFoundException("User not found: " + id));\n\n        userMapper.updateUserFromDto(request, user);\n        User updated = userRepository.save(user);\n\n        return userMapper.toDto(updated);\n    }\n\n    // Batch operations for better performance\n    @Transactional\n    public List<UserDto> createBatch(List<CreateUserRequest> requests) {\n        List<User> users = requests.stream()\n            .map(userMapper::toEntity)\n            .collect(Collectors.toList());\n\n        List<User> savedUsers = userRepository.saveAll(users);\n        return userMapper.toDtoList(savedUsers);\n    }\n\n    // Pagination with specifications\n    public Page<UserDto> findAllWithFilters(UserSearchCriteria criteria, Pageable pageable) {\n        Specification<User> spec = UserSpecifications.withCriteria(criteria);\n        Page<User> users = userRepository.findAll(spec, pageable);\n        return users.map(userMapper::toDto);\n    }\n}\n\n// Specification pattern for dynamic queries\npublic class UserSpecifications {\n\n    public static Specification<User> withCriteria(UserSearchCriteria criteria) {\n        return (root, query, criteriaBuilder) -> {\n            List<Predicate> predicates = new ArrayList<>();\n\n            if (criteria.getName() != null && !criteria.getName().isEmpty()) {\n                predicates.add(criteriaBuilder.like(\n                    criteriaBuilder.lower(root.get("name")),\n                    "%" + criteria.getName().toLowerCase() + "%"\n                ));\n            }\n\n            if (criteria.getStatus() != null) {\n                predicates.add(criteriaBuilder.equal(root.get("status"), criteria.getStatus()));\n            }\n\n            if (criteria.getCreatedAfter() != null) {\n                predicates.add(criteriaBuilder.greaterThanOrEqualTo(\n                    root.get("createdAt"), criteria.getCreatedAfter()\n                ));\n            }\n\n            return criteriaBuilder.and(predicates.toArray(new Predicate[0]));\n        };\n    }\n}\n'})})]})}function c(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(p,{...e})}):p(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var r=t(6540);const a={},i=r.createContext(a);function s(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);