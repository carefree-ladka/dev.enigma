"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[73849],{10488:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>l,default:()=>u,frontMatter:()=>s,metadata:()=>r,toc:()=>o});var i=t(74848),a=t(28453);const s={},l="Knapsack Problems",r={id:"DSA/DSA with JavaScript/DSA Cheatsheets/Knapsack Problems",title:"Knapsack Problems",description:"A comprehensive guide to knapsack problem variations and dynamic programming techniques for Data Structures and Algorithms.",source:"@site/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Knapsack Problems.mdx",sourceDirName:"DSA/DSA with JavaScript/DSA Cheatsheets",slug:"/DSA/DSA with JavaScript/DSA Cheatsheets/Knapsack Problems",permalink:"/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Knapsack Problems",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Knapsack Problems.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Interval Problems",permalink:"/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Interval Problems"},next:{title:"Linked List",permalink:"/docs/DSA/DSA with JavaScript/DSA Cheatsheets/LinkedList"}},c={},o=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Introduction and Problem Types",id:"introduction-and-problem-types",level:2},{value:"Problem Classification",id:"problem-classification",level:3},{value:"Helper Functions",id:"helper-functions",level:3},{value:"0/1 Knapsack Problem",id:"01-knapsack-problem",level:2},{value:"1. Basic 0/1 Knapsack (2D DP)",id:"1-basic-01-knapsack-2d-dp",level:3},{value:"2. Space-Optimized 0/1 Knapsack (1D DP)",id:"2-space-optimized-01-knapsack-1d-dp",level:3},{value:"3. 0/1 Knapsack with Item Tracking",id:"3-01-knapsack-with-item-tracking",level:3},{value:"4. Recursive 0/1 Knapsack with Memoization",id:"4-recursive-01-knapsack-with-memoization",level:3},{value:"Unbounded Knapsack Problem",id:"unbounded-knapsack-problem",level:2},{value:"1. Basic Unbounded Knapsack",id:"1-basic-unbounded-knapsack",level:3},{value:"2. Unbounded Knapsack with Item Count",id:"2-unbounded-knapsack-with-item-count",level:3},{value:"3. Rod Cutting Problem (Unbounded Knapsack Variant)",id:"3-rod-cutting-problem-unbounded-knapsack-variant",level:3},{value:"Bounded Knapsack Problem",id:"bounded-knapsack-problem",level:2},{value:"1. Bounded Knapsack (Multiple Items)",id:"1-bounded-knapsack-multiple-items",level:3},{value:"2. Bounded Knapsack with Binary Lifting",id:"2-bounded-knapsack-with-binary-lifting",level:3},{value:"3. Bounded Knapsack with Item Tracking",id:"3-bounded-knapsack-with-item-tracking",level:3},{value:"Multiple Knapsacks Problem",id:"multiple-knapsacks-problem",level:2},{value:"1. Multiple Knapsacks (Greedy Approach)",id:"1-multiple-knapsacks-greedy-approach",level:3},{value:"2. Multiple Knapsacks (DP Approach)",id:"2-multiple-knapsacks-dp-approach",level:3},{value:"Fractional Knapsack Problem",id:"fractional-knapsack-problem",level:2},{value:"1. Fractional Knapsack (Greedy)",id:"1-fractional-knapsack-greedy",level:3},{value:"2. Fractional vs 0/1 Comparison",id:"2-fractional-vs-01-comparison",level:3},{value:"Subset Sum Variations",id:"subset-sum-variations",level:2},{value:"1. Subset Sum Problem",id:"1-subset-sum-problem",level:3},{value:"2. Subset Sum with Count",id:"2-subset-sum-with-count",level:3},{value:"3. Partition Problem",id:"3-partition-problem",level:3},{value:"4. Minimum Subset Sum Difference",id:"4-minimum-subset-sum-difference",level:3},{value:"Coin Change Problems",id:"coin-change-problems",level:2},{value:"1. Coin Change (Minimum Coins)",id:"1-coin-change-minimum-coins",level:3},{value:"2. Coin Change (Number of Ways)",id:"2-coin-change-number-of-ways",level:3},{value:"3. Coin Change with Limited Coins",id:"3-coin-change-with-limited-coins",level:3},{value:"Advanced Knapsack Variations",id:"advanced-knapsack-variations",level:2},{value:"1. Two-Dimensional Knapsack",id:"1-two-dimensional-knapsack",level:3},{value:"2. Knapsack with Dependencies",id:"2-knapsack-with-dependencies",level:3},{value:"3. Group Knapsack",id:"3-group-knapsack",level:3},{value:"4. Knapsack with Conflicts",id:"4-knapsack-with-conflicts",level:3},{value:"Optimization Techniques",id:"optimization-techniques",level:2},{value:"1. Meet-in-the-Middle",id:"1-meet-in-the-middle",level:3},{value:"2. Branch and Bound",id:"2-branch-and-bound",level:3},{value:"3. Approximation Algorithms",id:"3-approximation-algorithms",level:3},{value:"Usage Examples",id:"usage-examples",level:2},{value:"Time Complexity Summary",id:"time-complexity-summary",level:2},{value:"Key Patterns to Remember",id:"key-patterns-to-remember",level:2},{value:"1. <strong>DP State Transitions</strong>",id:"1-dp-state-transitions",level:3},{value:"2. <strong>Space Optimization</strong>",id:"2-space-optimization",level:3},{value:"3. <strong>Greedy vs DP</strong>",id:"3-greedy-vs-dp",level:3},{value:"4. <strong>Backtracking Pattern</strong>",id:"4-backtracking-pattern",level:3},{value:"5. <strong>Optimization Techniques</strong>",id:"5-optimization-techniques",level:3},{value:"Common Interview Patterns",id:"common-interview-patterns",level:2},{value:"1. <strong>Subset-Based Problems</strong>",id:"1-subset-based-problems",level:3},{value:"2. <strong>Coin/Change Problems</strong>",id:"2-coinchange-problems",level:3},{value:"3. <strong>Optimization Variants</strong>",id:"3-optimization-variants",level:3},{value:"4. <strong>Real-World Applications</strong>",id:"4-real-world-applications",level:3},{value:"Interview Tips",id:"interview-tips",level:2},{value:"\ud83c\udfaf Core Decision Framework",id:"-core-decision-framework",level:2},{value:"Choice: Skip or Take Current Number",id:"choice-skip-or-take-current-number",level:3},{value:"\ud83d\udd04 Bottom-Up DP Patterns",id:"-bottom-up-dp-patterns",level:2},{value:"Knapsack 0/1 (Bounded)",id:"knapsack-01-bounded",level:3},{value:"Knapsack Unbounded",id:"knapsack-unbounded",level:3},{value:"\ud83d\udd11 Memory Trick (Bottom-Up)",id:"-memory-trick-bottom-up",level:2},{value:"\ud83d\udcca Counting Ways: Combinations vs Permutations",id:"-counting-ways-combinations-vs-permutations",level:2},{value:"Combinations (Order Doesn&#39;t Matter)",id:"combinations-order-doesnt-matter",level:3},{value:"Permutations (Order Matters)",id:"permutations-order-matters",level:3},{value:"\u26a1 Loop Order Rules",id:"-loop-order-rules",level:2},{value:"\ud83d\udd04 Mapping Bottom-Up to Top-Down",id:"-mapping-bottom-up-to-top-down",level:2},{value:"\ud83c\udf92 Classic Knapsack with Weight &amp; Value",id:"-classic-knapsack-with-weight--value",level:2},{value:"0/1 Knapsack",id:"01-knapsack",level:3},{value:"Unbounded Knapsack",id:"unbounded-knapsack",level:3},{value:"\ud83d\udd0d Additional Optimization Tricks",id:"-additional-optimization-tricks",level:2},{value:"Space Optimization (0/1 Knapsack)",id:"space-optimization-01-knapsack",level:3},{value:"Path Reconstruction",id:"path-reconstruction",level:3},{value:"\ud83c\udff7\ufe0f Common DP State Patterns",id:"\ufe0f-common-dp-state-patterns",level:2},{value:"Two Parameters (i, target)",id:"two-parameters-i-target",level:3},{value:"One Parameter (target only)",id:"one-parameter-target-only",level:3},{value:"Three Parameters (i, j, target)",id:"three-parameters-i-j-target",level:3},{value:"\ud83d\udca1 Problem Recognition Patterns",id:"-problem-recognition-patterns",level:2},{value:"\u26a0\ufe0f Common Pitfalls",id:"\ufe0f-common-pitfalls",level:2}];function d(n){const e={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"knapsack-problems",children:"Knapsack Problems"})}),"\n",(0,i.jsx)(e.p,{children:"A comprehensive guide to knapsack problem variations and dynamic programming techniques for Data Structures and Algorithms."}),"\n",(0,i.jsx)(e.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#introduction-and-problem-types",children:"Introduction and Problem Types"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#01-knapsack-problem",children:"0/1 Knapsack Problem"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#unbounded-knapsack-problem",children:"Unbounded Knapsack Problem"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#bounded-knapsack-problem",children:"Bounded Knapsack Problem"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#multiple-knapsacks-problem",children:"Multiple Knapsacks Problem"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#fractional-knapsack-problem",children:"Fractional Knapsack Problem"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#subset-sum-variations",children:"Subset Sum Variations"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#coin-change-problems",children:"Coin Change Problems"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#advanced-knapsack-variations",children:"Advanced Knapsack Variations"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#optimization-techniques",children:"Optimization Techniques"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#usage-examples",children:"Usage Examples"})}),"\n"]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"introduction-and-problem-types",children:"Introduction and Problem Types"}),"\n",(0,i.jsx)(e.p,{children:"The knapsack problem is a fundamental optimization problem where we aim to maximize value while staying within weight constraints."}),"\n",(0,i.jsx)(e.h3,{id:"problem-classification",children:"Problem Classification"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// Basic knapsack structure\nclass Item {\n  constructor(weight, value, name = '') {\n    this.weight = weight;\n    this.value = value;\n    this.name = name;\n    this.ratio = value / weight; // Value-to-weight ratio\n  }\n}\n\n// Common knapsack types\nconst KNAPSACK_TYPES = {\n  ZERO_ONE: '0/1 Knapsack', // Each item can be taken 0 or 1 time\n  UNBOUNDED: 'Unbounded', // Each item can be taken multiple times\n  BOUNDED: 'Bounded', // Each item has limited quantity\n  MULTIPLE: 'Multiple Knapsacks', // Multiple knapsacks available\n  FRACTIONAL: 'Fractional', // Items can be taken partially\n};\n"})}),"\n",(0,i.jsx)(e.h3,{id:"helper-functions",children:"Helper Functions"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// Create sample items for testing\nfunction createItems(data) {\n  return data.map(([weight, value, name]) => new Item(weight, value, name));\n}\n\n// Print solution details\nfunction printSolution(items, solution, capacity, maxValue) {\n  console.log(`\\nKnapsack Solution (Capacity: ${capacity})`);\n  console.log(`Maximum Value: ${maxValue}`);\n  console.log('Selected Items:');\n\n  let totalWeight = 0;\n  let totalValue = 0;\n\n  solution.forEach((item, index) => {\n    if (item.taken > 0) {\n      console.log(\n        `  ${item.name}: weight=${item.weight}, value=${item.value}, quantity=${item.taken}`\n      );\n      totalWeight += item.weight * item.taken;\n      totalValue += item.value * item.taken;\n    }\n  });\n\n  console.log(`Total Weight: ${totalWeight}/${capacity}`);\n  console.log(`Total Value: ${totalValue}`);\n}\n\n// Validate knapsack solution\nfunction isValidSolution(items, solution, capacity) {\n  let totalWeight = 0;\n\n  for (let i = 0; i < solution.length; i++) {\n    totalWeight += items[i].weight * solution[i];\n  }\n\n  return totalWeight <= capacity;\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"01-knapsack-problem",children:"0/1 Knapsack Problem"}),"\n",(0,i.jsx)(e.p,{children:"The classic knapsack where each item can be taken at most once."}),"\n",(0,i.jsx)(e.h3,{id:"1-basic-01-knapsack-2d-dp",children:"1. Basic 0/1 Knapsack (2D DP)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function knapsack01_2D(items, capacity) {\n  const n = items.length;\n  const dp = Array.from({ length: n + 1 }, () =>\n    new Array(capacity + 1).fill(0)\n  );\n\n  // Fill the DP table\n  for (let i = 1; i <= n; i++) {\n    for (let w = 0; w <= capacity; w++) {\n      const currentItem = items[i - 1];\n\n      if (currentItem.weight <= w) {\n        // Max of taking or not taking current item\n        dp[i][w] = Math.max(\n          dp[i - 1][w], // Don't take\n          dp[i - 1][w - currentItem.weight] + currentItem.value // Take\n        );\n      } else {\n        dp[i][w] = dp[i - 1][w]; // Can't take (too heavy)\n      }\n    }\n  }\n\n  return dp[n][capacity];\n}\n"})}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Time Complexity:"})," O(n \xd7 W) | ",(0,i.jsx)(e.strong,{children:"Space Complexity:"})," O(n \xd7 W)"]}),"\n",(0,i.jsx)(e.h3,{id:"2-space-optimized-01-knapsack-1d-dp",children:"2. Space-Optimized 0/1 Knapsack (1D DP)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function knapsack01_1D(items, capacity) {\n  const dp = new Array(capacity + 1).fill(0);\n\n  for (const item of items) {\n    // Traverse backwards to avoid using updated values\n    for (let w = capacity; w >= item.weight; w--) {\n      dp[w] = Math.max(dp[w], dp[w - item.weight] + item.value);\n    }\n  }\n\n  return dp[capacity];\n}\n"})}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Time Complexity:"})," O(n \xd7 W) | ",(0,i.jsx)(e.strong,{children:"Space Complexity:"})," O(W)"]}),"\n",(0,i.jsx)(e.h3,{id:"3-01-knapsack-with-item-tracking",children:"3. 0/1 Knapsack with Item Tracking"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function knapsack01WithItems(items, capacity) {\n  const n = items.length;\n  const dp = Array.from({ length: n + 1 }, () =>\n    new Array(capacity + 1).fill(0)\n  );\n\n  // Fill DP table\n  for (let i = 1; i <= n; i++) {\n    for (let w = 0; w <= capacity; w++) {\n      const currentItem = items[i - 1];\n\n      if (currentItem.weight <= w) {\n        dp[i][w] = Math.max(\n          dp[i - 1][w],\n          dp[i - 1][w - currentItem.weight] + currentItem.value\n        );\n      } else {\n        dp[i][w] = dp[i - 1][w];\n      }\n    }\n  }\n\n  // Backtrack to find selected items\n  const selectedItems = [];\n  let w = capacity;\n\n  for (let i = n; i > 0; i--) {\n    if (dp[i][w] !== dp[i - 1][w]) {\n      selectedItems.push({\n        ...items[i - 1],\n        taken: 1,\n      });\n      w -= items[i - 1].weight;\n    } else {\n      selectedItems.push({\n        ...items[i - 1],\n        taken: 0,\n      });\n    }\n  }\n\n  return {\n    maxValue: dp[n][capacity],\n    items: selectedItems.reverse(),\n  };\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"4-recursive-01-knapsack-with-memoization",children:"4. Recursive 0/1 Knapsack with Memoization"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function knapsack01Recursive(items, capacity) {\n  const memo = new Map();\n\n  function solve(index, remainingCapacity) {\n    // Base case\n    if (index === items.length || remainingCapacity === 0) {\n      return 0;\n    }\n\n    const key = `${index}-${remainingCapacity}`;\n    if (memo.has(key)) {\n      return memo.get(key);\n    }\n\n    const currentItem = items[index];\n    let result;\n\n    if (currentItem.weight > remainingCapacity) {\n      // Can't take current item\n      result = solve(index + 1, remainingCapacity);\n    } else {\n      // Max of taking or not taking current item\n      const take =\n        currentItem.value +\n        solve(index + 1, remainingCapacity - currentItem.weight);\n      const skip = solve(index + 1, remainingCapacity);\n      result = Math.max(take, skip);\n    }\n\n    memo.set(key, result);\n    return result;\n  }\n\n  return solve(0, capacity);\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"unbounded-knapsack-problem",children:"Unbounded Knapsack Problem"}),"\n",(0,i.jsx)(e.p,{children:"Each item can be taken unlimited times."}),"\n",(0,i.jsx)(e.h3,{id:"1-basic-unbounded-knapsack",children:"1. Basic Unbounded Knapsack"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function unboundedKnapsack(items, capacity) {\n  const dp = new Array(capacity + 1).fill(0);\n\n  for (let w = 1; w <= capacity; w++) {\n    for (const item of items) {\n      if (item.weight <= w) {\n        dp[w] = Math.max(dp[w], dp[w - item.weight] + item.value);\n      }\n    }\n  }\n\n  return dp[capacity];\n}\n"})}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Time Complexity:"})," O(n \xd7 W) | ",(0,i.jsx)(e.strong,{children:"Space Complexity:"})," O(W)"]}),"\n",(0,i.jsx)(e.h3,{id:"2-unbounded-knapsack-with-item-count",children:"2. Unbounded Knapsack with Item Count"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function unboundedKnapsackWithCount(items, capacity) {\n  const dp = new Array(capacity + 1).fill(0);\n  const count = new Array(capacity + 1).fill().map(() => ({}));\n\n  for (let w = 1; w <= capacity; w++) {\n    for (let i = 0; i < items.length; i++) {\n      const item = items[i];\n\n      if (item.weight <= w) {\n        const newValue = dp[w - item.weight] + item.value;\n\n        if (newValue > dp[w]) {\n          dp[w] = newValue;\n          count[w] = { ...count[w - item.weight] };\n          count[w][i] = (count[w][i] || 0) + 1;\n        }\n      }\n    }\n  }\n\n  return {\n    maxValue: dp[capacity],\n    itemCount: count[capacity] || {},\n  };\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"3-rod-cutting-problem-unbounded-knapsack-variant",children:"3. Rod Cutting Problem (Unbounded Knapsack Variant)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function rodCutting(prices, length) {\n  const dp = new Array(length + 1).fill(0);\n  const cuts = new Array(length + 1).fill(0);\n\n  for (let i = 1; i <= length; i++) {\n    for (let j = 1; j <= Math.min(i, prices.length); j++) {\n      if (dp[i - j] + prices[j - 1] > dp[i]) {\n        dp[i] = dp[i - j] + prices[j - 1];\n        cuts[i] = j;\n      }\n    }\n  }\n\n  // Reconstruct solution\n  const solution = [];\n  let remaining = length;\n\n  while (remaining > 0) {\n    solution.push(cuts[remaining]);\n    remaining -= cuts[remaining];\n  }\n\n  return {\n    maxValue: dp[length],\n    cuts: solution,\n  };\n}\n"})}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"\ud83d\udca1 Application:"})," Rod cutting is a classic application of unbounded knapsack!"]}),"\n"]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"bounded-knapsack-problem",children:"Bounded Knapsack Problem"}),"\n",(0,i.jsx)(e.p,{children:"Each item has a limited quantity available."}),"\n",(0,i.jsx)(e.h3,{id:"1-bounded-knapsack-multiple-items",children:"1. Bounded Knapsack (Multiple Items)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function boundedKnapsack(items, quantities, capacity) {\n  const dp = new Array(capacity + 1).fill(0);\n\n  for (let i = 0; i < items.length; i++) {\n    const item = items[i];\n    const maxCount = quantities[i];\n\n    // Process each item with its quantity limit\n    for (let w = capacity; w >= item.weight; w--) {\n      for (\n        let count = 1;\n        count <= maxCount && count * item.weight <= w;\n        count++\n      ) {\n        dp[w] = Math.max(\n          dp[w],\n          dp[w - count * item.weight] + count * item.value\n        );\n      }\n    }\n  }\n\n  return dp[capacity];\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"2-bounded-knapsack-with-binary-lifting",children:"2. Bounded Knapsack with Binary Lifting"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function boundedKnapsackOptimized(items, quantities, capacity) {\n  const newItems = [];\n\n  // Convert to 0/1 knapsack using binary representation\n  for (let i = 0; i < items.length; i++) {\n    let remaining = quantities[i];\n    let multiplier = 1;\n\n    while (remaining > 0) {\n      const takeCount = Math.min(multiplier, remaining);\n      newItems.push({\n        weight: items[i].weight * takeCount,\n        value: items[i].value * takeCount,\n        name: `${items[i].name}_x${takeCount}`,\n      });\n\n      remaining -= takeCount;\n      multiplier *= 2;\n    }\n  }\n\n  // Solve as 0/1 knapsack\n  return knapsack01_1D(newItems, capacity);\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"3-bounded-knapsack-with-item-tracking",children:"3. Bounded Knapsack with Item Tracking"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function boundedKnapsackWithTracking(items, quantities, capacity) {\n  const dp = Array.from({ length: items.length + 1 }, () =>\n    new Array(capacity + 1).fill(0)\n  );\n\n  // Track the count of each item used\n  const usage = Array.from({ length: items.length + 1 }, () =>\n    Array.from({ length: capacity + 1 }, () => new Array(items.length).fill(0))\n  );\n\n  for (let i = 1; i <= items.length; i++) {\n    const item = items[i - 1];\n    const maxCount = quantities[i - 1];\n\n    for (let w = 0; w <= capacity; w++) {\n      dp[i][w] = dp[i - 1][w]; // Don't take any\n      usage[i][w] = [...usage[i - 1][w]];\n\n      // Try taking different quantities\n      for (\n        let count = 1;\n        count <= maxCount && count * item.weight <= w;\n        count++\n      ) {\n        const value = dp[i - 1][w - count * item.weight] + count * item.value;\n\n        if (value > dp[i][w]) {\n          dp[i][w] = value;\n          usage[i][w] = [...usage[i - 1][w - count * item.weight]];\n          usage[i][w][i - 1] = count;\n        }\n      }\n    }\n  }\n\n  return {\n    maxValue: dp[items.length][capacity],\n    usage: usage[items.length][capacity],\n  };\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"multiple-knapsacks-problem",children:"Multiple Knapsacks Problem"}),"\n",(0,i.jsx)(e.p,{children:"Multiple knapsacks with different capacities."}),"\n",(0,i.jsx)(e.h3,{id:"1-multiple-knapsacks-greedy-approach",children:"1. Multiple Knapsacks (Greedy Approach)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function multipleKnapsacksGreedy(items, knapsacks) {\n  // Sort items by value-to-weight ratio (descending)\n  const sortedItems = items\n    .map((item, index) => ({ ...item, originalIndex: index }))\n    .sort((a, b) => b.ratio - a.ratio);\n\n  // Sort knapsacks by capacity (descending)\n  const sortedKnapsacks = knapsacks\n    .map((capacity, index) => ({\n      capacity,\n      index,\n      items: [],\n      value: 0,\n      weight: 0,\n    }))\n    .sort((a, b) => b.capacity - a.capacity);\n\n  // Assign items to knapsacks\n  for (const item of sortedItems) {\n    for (const knapsack of sortedKnapsacks) {\n      if (knapsack.weight + item.weight <= knapsack.capacity) {\n        knapsack.items.push(item);\n        knapsack.weight += item.weight;\n        knapsack.value += item.value;\n        break;\n      }\n    }\n  }\n\n  return sortedKnapsacks.sort((a, b) => a.index - b.index);\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"2-multiple-knapsacks-dp-approach",children:"2. Multiple Knapsacks (DP Approach)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function multipleKnapsacksDP(items, knapsacks) {\n  const totalCapacity = knapsacks.reduce((sum, cap) => sum + cap, 0);\n  const k = knapsacks.length;\n\n  // dp[i][w1][w2]...[wk] = maximum value using first i items\n  // with weights w1, w2, ..., wk in knapsacks 1, 2, ..., k\n  const memo = new Map();\n\n  function solve(itemIndex, remainingCapacities) {\n    if (itemIndex === items.length) return 0;\n\n    const key = `${itemIndex}-${remainingCapacities.join(',')}`;\n    if (memo.has(key)) return memo.get(key);\n\n    let maxValue = solve(itemIndex + 1, remainingCapacities); // Skip item\n\n    // Try putting item in each knapsack\n    for (let knapsackIndex = 0; knapsackIndex < k; knapsackIndex++) {\n      const item = items[itemIndex];\n      if (remainingCapacities[knapsackIndex] >= item.weight) {\n        const newCapacities = [...remainingCapacities];\n        newCapacities[knapsackIndex] -= item.weight;\n\n        const value = item.value + solve(itemIndex + 1, newCapacities);\n        maxValue = Math.max(maxValue, value);\n      }\n    }\n\n    memo.set(key, maxValue);\n    return maxValue;\n  }\n\n  return solve(0, [...knapsacks]);\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"fractional-knapsack-problem",children:"Fractional Knapsack Problem"}),"\n",(0,i.jsx)(e.p,{children:"Items can be taken partially (greedy solution optimal)."}),"\n",(0,i.jsx)(e.h3,{id:"1-fractional-knapsack-greedy",children:"1. Fractional Knapsack (Greedy)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function fractionalKnapsack(items, capacity) {\n  // Sort by value-to-weight ratio (descending)\n  const sortedItems = items\n    .map((item, index) => ({ ...item, index }))\n    .sort((a, b) => b.ratio - a.ratio);\n\n  let remainingCapacity = capacity;\n  let totalValue = 0;\n  const solution = [];\n\n  for (const item of sortedItems) {\n    if (remainingCapacity >= item.weight) {\n      // Take entire item\n      solution.push({\n        ...item,\n        fraction: 1.0,\n        weightTaken: item.weight,\n        valueTaken: item.value,\n      });\n\n      remainingCapacity -= item.weight;\n      totalValue += item.value;\n    } else if (remainingCapacity > 0) {\n      // Take partial item\n      const fraction = remainingCapacity / item.weight;\n\n      solution.push({\n        ...item,\n        fraction,\n        weightTaken: remainingCapacity,\n        valueTaken: item.value * fraction,\n      });\n\n      totalValue += item.value * fraction;\n      remainingCapacity = 0;\n      break;\n    }\n  }\n\n  return {\n    maxValue: totalValue,\n    items: solution,\n  };\n}\n"})}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Time Complexity:"})," O(n log n) | ",(0,i.jsx)(e.strong,{children:"Space Complexity:"})," O(n)"]}),"\n",(0,i.jsx)(e.h3,{id:"2-fractional-vs-01-comparison",children:"2. Fractional vs 0/1 Comparison"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function compareKnapsackTypes(items, capacity) {\n  const fractional = fractionalKnapsack(items, capacity);\n  const zeroOne = knapsack01WithItems(items, capacity);\n\n  console.log('Fractional Knapsack Result:', fractional.maxValue);\n  console.log('0/1 Knapsack Result:', zeroOne.maxValue);\n  console.log('Difference:', fractional.maxValue - zeroOne.maxValue);\n\n  return {\n    fractional: fractional.maxValue,\n    zeroOne: zeroOne.maxValue,\n    fractionalOptimal: fractional.maxValue >= zeroOne.maxValue,\n  };\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"subset-sum-variations",children:"Subset Sum Variations"}),"\n",(0,i.jsx)(e.h3,{id:"1-subset-sum-problem",children:"1. Subset Sum Problem"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function subsetSum(nums, target) {\n  const dp = new Array(target + 1).fill(false);\n  dp[0] = true; // Empty subset sums to 0\n\n  for (const num of nums) {\n    for (let sum = target; sum >= num; sum--) {\n      dp[sum] = dp[sum] || dp[sum - num];\n    }\n  }\n\n  return dp[target];\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"2-subset-sum-with-count",children:"2. Subset Sum with Count"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function subsetSumCount(nums, target) {\n  const dp = new Array(target + 1).fill(0);\n  dp[0] = 1; // One way to make sum 0 (empty subset)\n\n  for (const num of nums) {\n    for (let sum = target; sum >= num; sum--) {\n      dp[sum] += dp[sum - num];\n    }\n  }\n\n  return dp[target];\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"3-partition-problem",children:"3. Partition Problem"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function canPartition(nums) {\n  const totalSum = nums.reduce((sum, num) => sum + num, 0);\n\n  // Can't partition if total sum is odd\n  if (totalSum % 2 !== 0) return false;\n\n  const target = totalSum / 2;\n  return subsetSum(nums, target);\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"4-minimum-subset-sum-difference",children:"4. Minimum Subset Sum Difference"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function minimumSubsetSumDifference(nums) {\n  const totalSum = nums.reduce((sum, num) => sum + num, 0);\n  const target = Math.floor(totalSum / 2);\n\n  const dp = new Array(target + 1).fill(false);\n  dp[0] = true;\n\n  for (const num of nums) {\n    for (let sum = target; sum >= num; sum--) {\n      dp[sum] = dp[sum] || dp[sum - num];\n    }\n  }\n\n  // Find the largest sum \u2264 target that's achievable\n  let maxAchievableSum = 0;\n  for (let i = target; i >= 0; i--) {\n    if (dp[i]) {\n      maxAchievableSum = i;\n      break;\n    }\n  }\n\n  return totalSum - 2 * maxAchievableSum;\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"coin-change-problems",children:"Coin Change Problems"}),"\n",(0,i.jsx)(e.h3,{id:"1-coin-change-minimum-coins",children:"1. Coin Change (Minimum Coins)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function coinChange(coins, amount) {\n  const dp = new Array(amount + 1).fill(Infinity);\n  dp[0] = 0;\n\n  for (let i = 1; i <= amount; i++) {\n    for (const coin of coins) {\n      if (coin <= i) {\n        dp[i] = Math.min(dp[i], dp[i - coin] + 1);\n      }\n    }\n  }\n\n  return dp[amount] === Infinity ? -1 : dp[amount];\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"2-coin-change-number-of-ways",children:"2. Coin Change (Number of Ways)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function coinChangeWays(coins, amount) {\n  const dp = new Array(amount + 1).fill(0);\n  dp[0] = 1; // One way to make amount 0\n\n  for (const coin of coins) {\n    for (let i = coin; i <= amount; i++) {\n      dp[i] += dp[i - coin];\n    }\n  }\n\n  return dp[amount];\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"3-coin-change-with-limited-coins",children:"3. Coin Change with Limited Coins"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function coinChangeLimited(coins, quantities, amount) {\n  const dp = new Array(amount + 1).fill(Infinity);\n  dp[0] = 0;\n\n  for (let i = 0; i < coins.length; i++) {\n    const coin = coins[i];\n    const maxCount = quantities[i];\n\n    for (let amt = amount; amt >= coin; amt--) {\n      for (let count = 1; count <= maxCount && count * coin <= amt; count++) {\n        if (dp[amt - count * coin] !== Infinity) {\n          dp[amt] = Math.min(dp[amt], dp[amt - count * coin] + count);\n        }\n      }\n    }\n  }\n\n  return dp[amount] === Infinity ? -1 : dp[amount];\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"advanced-knapsack-variations",children:"Advanced Knapsack Variations"}),"\n",(0,i.jsx)(e.h3,{id:"1-two-dimensional-knapsack",children:"1. Two-Dimensional Knapsack"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function twoDimensionalKnapsack(items, weightCapacity, volumeCapacity) {\n  const dp = Array.from({ length: weightCapacity + 1 }, () =>\n    new Array(volumeCapacity + 1).fill(0)\n  );\n\n  for (const item of items) {\n    for (let w = weightCapacity; w >= item.weight; w--) {\n      for (let v = volumeCapacity; v >= item.volume; v--) {\n        dp[w][v] = Math.max(\n          dp[w][v],\n          dp[w - item.weight][v - item.volume] + item.value\n        );\n      }\n    }\n  }\n\n  return dp[weightCapacity][volumeCapacity];\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"2-knapsack-with-dependencies",children:"2. Knapsack with Dependencies"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function knapsackWithDependencies(items, dependencies, capacity) {\n  const n = items.length;\n  const memo = new Map();\n\n  function canTake(itemIndex, taken) {\n    const deps = dependencies[itemIndex] || [];\n    return deps.every(dep => taken.has(dep));\n  }\n\n  function solve(index, remainingCapacity, taken) {\n    if (index === n) return 0;\n\n    const key = `${index}-${remainingCapacity}-${Array.from(taken).sort().join(',')}`;\n    if (memo.has(key)) return memo.get(key);\n\n    // Option 1: Skip current item\n    let maxValue = solve(index + 1, remainingCapacity, taken);\n\n    // Option 2: Take current item (if possible)\n    const item = items[index];\n    if (item.weight <= remainingCapacity && canTake(index, taken)) {\n      const newTaken = new Set([...taken, index]);\n      const value =\n        item.value +\n        solve(index + 1, remainingCapacity - item.weight, newTaken);\n      maxValue = Math.max(maxValue, value);\n    }\n\n    memo.set(key, maxValue);\n    return maxValue;\n  }\n\n  return solve(0, capacity, new Set());\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"3-group-knapsack",children:"3. Group Knapsack"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function groupKnapsack(groups, capacity) {\n  const dp = new Array(capacity + 1).fill(0);\n\n  for (const group of groups) {\n    const newDp = [...dp];\n\n    for (const item of group.items) {\n      for (let w = capacity; w >= item.weight; w--) {\n        newDp[w] = Math.max(newDp[w], dp[w - item.weight] + item.value);\n      }\n    }\n\n    // Update dp with the best choice from this group\n    for (let w = 0; w <= capacity; w++) {\n      dp[w] = newDp[w];\n    }\n  }\n\n  return dp[capacity];\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"4-knapsack-with-conflicts",children:"4. Knapsack with Conflicts"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function knapsackWithConflicts(items, conflicts, capacity) {\n  const n = items.length;\n  const conflictSet = new Set(conflicts.map(([a, b]) => `${a}-${b}`));\n\n  function hasConflict(taken) {\n    const takenItems = Array.from(taken);\n    for (let i = 0; i < takenItems.length; i++) {\n      for (let j = i + 1; j < takenItems.length; j++) {\n        const pair1 = `${takenItems[i]}-${takenItems[j]}`;\n        const pair2 = `${takenItems[j]}-${takenItems[i]}`;\n        if (conflictSet.has(pair1) || conflictSet.has(pair2)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  let maxValue = 0;\n\n  // Generate all possible subsets\n  for (let mask = 0; mask < 1 << n; mask++) {\n    const taken = new Set();\n    let totalWeight = 0;\n    let totalValue = 0;\n\n    for (let i = 0; i < n; i++) {\n      if (mask & (1 << i)) {\n        taken.add(i);\n        totalWeight += items[i].weight;\n        totalValue += items[i].value;\n      }\n    }\n\n    if (totalWeight <= capacity && !hasConflict(taken)) {\n      maxValue = Math.max(maxValue, totalValue);\n    }\n  }\n\n  return maxValue;\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"optimization-techniques",children:"Optimization Techniques"}),"\n",(0,i.jsx)(e.h3,{id:"1-meet-in-the-middle",children:"1. Meet-in-the-Middle"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function knapsackMeetInTheMiddle(items, capacity) {\n  const n = items.length;\n  const mid = Math.floor(n / 2);\n\n  const firstHalf = items.slice(0, mid);\n  const secondHalf = items.slice(mid);\n\n  // Generate all possible (weight, value) pairs for first half\n  function generateStates(itemList) {\n    const states = [];\n    const numItems = itemList.length;\n\n    for (let mask = 0; mask < 1 << numItems; mask++) {\n      let weight = 0;\n      let value = 0;\n\n      for (let i = 0; i < numItems; i++) {\n        if (mask & (1 << i)) {\n          weight += itemList[i].weight;\n          value += itemList[i].value;\n        }\n      }\n\n      if (weight <= capacity) {\n        states.push({ weight, value });\n      }\n    }\n\n    return states;\n  }\n\n  const firstStates = generateStates(firstHalf);\n  const secondStates = generateStates(secondHalf);\n\n  // Sort second states by weight for binary search\n  secondStates.sort((a, b) => a.weight - b.weight);\n\n  // For each weight, keep only the maximum value\n  const maxValueByWeight = new Map();\n  for (const state of secondStates) {\n    if (\n      !maxValueByWeight.has(state.weight) ||\n      maxValueByWeight.get(state.weight) < state.value\n    ) {\n      maxValueByWeight.set(state.weight, state.value);\n    }\n  }\n\n  let maxValue = 0;\n\n  for (const firstState of firstStates) {\n    const remainingCapacity = capacity - firstState.weight;\n\n    // Find best matching second state\n    for (const [weight, value] of maxValueByWeight) {\n      if (weight <= remainingCapacity) {\n        maxValue = Math.max(maxValue, firstState.value + value);\n      }\n    }\n  }\n\n  return maxValue;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"2-branch-and-bound",children:"2. Branch and Bound"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function knapsackBranchAndBound(items, capacity) {\n  // Sort items by value-to-weight ratio\n  const sortedItems = items\n    .map((item, index) => ({ ...item, index }))\n    .sort((a, b) => b.ratio - a.ratio);\n\n  let bestValue = 0;\n  let bestSolution = [];\n\n  function upperBound(nodeLevel, currentWeight, currentValue) {\n    let bound = currentValue;\n    let weight = currentWeight;\n    let level = nodeLevel;\n\n    // Add items greedily (fractional allowed for bound)\n    while (\n      level < sortedItems.length &&\n      weight + sortedItems[level].weight <= capacity\n    ) {\n      weight += sortedItems[level].weight;\n      bound += sortedItems[level].value;\n      level++;\n    }\n\n    // Add fractional part of next item if possible\n    if (level < sortedItems.length) {\n      const remainingCapacity = capacity - weight;\n      bound +=\n        (remainingCapacity / sortedItems[level].weight) *\n        sortedItems[level].value;\n    }\n\n    return bound;\n  }\n\n  function branchAndBound(level, currentWeight, currentValue, currentSolution) {\n    if (level === sortedItems.length) {\n      if (currentValue > bestValue) {\n        bestValue = currentValue;\n        bestSolution = [...currentSolution];\n      }\n      return;\n    }\n\n    const item = sortedItems[level];\n    const bound = upperBound(level, currentWeight, currentValue);\n\n    // Pruning: if bound is not better than current best, skip this branch\n    if (bound <= bestValue) {\n      return;\n    }\n\n    // Branch 1: Include current item (if fits)\n    if (currentWeight + item.weight <= capacity) {\n      currentSolution[item.index] = 1;\n      branchAndBound(\n        level + 1,\n        currentWeight + item.weight,\n        currentValue + item.value,\n        currentSolution\n      );\n      currentSolution[item.index] = 0;\n    }\n\n    // Branch 2: Exclude current item\n    branchAndBound(level + 1, currentWeight, currentValue, currentSolution);\n  }\n\n  const solution = new Array(items.length).fill(0);\n  branchAndBound(0, 0, 0, solution);\n\n  return {\n    maxValue: bestValue,\n    solution: bestSolution,\n  };\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"3-approximation-algorithms",children:"3. Approximation Algorithms"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function knapsackFPTAS(items, capacity, epsilon) {\n  const n = items.length;\n  const maxValue = Math.max(...items.map(item => item.value));\n\n  // Scale factor for approximation\n  const K = (epsilon * maxValue) / n;\n\n  // Scale and round values\n  const scaledItems = items.map(item => ({\n    ...item,\n    scaledValue: Math.floor(item.value / K),\n  }));\n\n  const maxScaledValue = Math.max(...scaledItems.map(item => item.scaledValue));\n  const totalScaledValue = n * maxScaledValue;\n\n  // DP on scaled values\n  const dp = Array.from({ length: n + 1 }, () =>\n    new Array(totalScaledValue + 1).fill(Infinity)\n  );\n  dp[0][0] = 0;\n\n  for (let i = 1; i <= n; i++) {\n    const item = scaledItems[i - 1];\n\n    for (let v = 0; v <= totalScaledValue; v++) {\n      // Don't take item\n      dp[i][v] = dp[i - 1][v];\n\n      // Take item\n      if (\n        v >= item.scaledValue &&\n        dp[i - 1][v - item.scaledValue] !== Infinity\n      ) {\n        dp[i][v] = Math.min(\n          dp[i][v],\n          dp[i - 1][v - item.scaledValue] + item.weight\n        );\n      }\n    }\n  }\n\n  // Find maximum value with weight <= capacity\n  let maxApproxValue = 0;\n  for (let v = 0; v <= totalScaledValue; v++) {\n    if (dp[n][v] <= capacity) {\n      maxApproxValue = Math.max(maxApproxValue, v * K);\n    }\n  }\n\n  return maxApproxValue;\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,i.jsx)(e.p,{children:"Here's how to use these knapsack variations:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"console.log('=== Knapsack Problems Demo ===');\n\n// Sample items for testing\nconst items = [\n  new Item(10, 60, 'Item 1'),\n  new Item(20, 100, 'Item 2'),\n  new Item(30, 120, 'Item 3'),\n];\n\nconst capacity = 50;\n\nconsole.log('\\n1. 0/1 Knapsack Problem');\nconst result01 = knapsack01WithItems(items, capacity);\nconsole.log('Max Value:', result01.maxValue);\nprintSolution(items, result01.items, capacity, result01.maxValue);\n\nconsole.log('\\n2. Unbounded Knapsack Problem');\nconst unboundedResult = unboundedKnapsackWithCount(items, capacity);\nconsole.log('Max Value:', unboundedResult.maxValue);\nconsole.log('Item counts:', unboundedResult.itemCount);\n\nconsole.log('\\n3. Fractional Knapsack Problem');\nconst fractionalResult = fractionalKnapsack(items, capacity);\nconsole.log('Max Value:', fractionalResult.maxValue.toFixed(2));\nfractionalResult.items.forEach(item => {\n  console.log(\n    `  ${item.name}: fraction=${item.fraction.toFixed(2)}, value=${item.valueTaken.toFixed(2)}`\n  );\n});\n\nconsole.log('\\n4. Multiple Knapsacks Problem');\nconst knapsacks = [30, 20, 25];\nconst multipleResult = multipleKnapsacksGreedy(items, knapsacks);\nmultipleResult.forEach((knapsack, index) => {\n  console.log(\n    `Knapsack ${index + 1} (capacity ${knapsack.capacity}): value=${knapsack.value}`\n  );\n});\n\nconsole.log('\\n5. Subset Sum Problem');\nconst nums = [3, 34, 4, 12, 5, 2];\nconst target = 9;\nconsole.log(`Can make sum ${target}:`, subsetSum(nums, target));\nconsole.log(`Number of ways to make ${target}:`, subsetSumCount(nums, target));\n\nconsole.log('\\n6. Coin Change Problem');\nconst coins = [1, 3, 4];\nconst amount = 6;\nconsole.log(`Min coins for amount ${amount}:`, coinChange(coins, amount));\nconsole.log(`Ways to make amount ${amount}:`, coinChangeWays(coins, amount));\n\nconsole.log('\\n7. Rod Cutting Problem');\nconst prices = [1, 5, 8, 9, 10, 17, 17, 20];\nconst rodLength = 4;\nconst rodResult = rodCutting(prices, rodLength);\nconsole.log(`Max value for rod length ${rodLength}:`, rodResult.maxValue);\nconsole.log('Cuts:', rodResult.cuts);\n\nconsole.log('\\n8. Partition Problem');\nconst partitionNums = [1, 5, 11, 5];\nconsole.log(\n  'Can partition into equal sum subsets:',\n  canPartition(partitionNums)\n);\n\nconsole.log('\\n9. Minimum Subset Sum Difference');\nconst diffNums = [1, 6, 11, 5];\nconsole.log('Minimum difference:', minimumSubsetSumDifference(diffNums));\n\n// Advanced examples\nconsole.log('\\n10. Two-Dimensional Knapsack');\nconst items2D = [\n  { weight: 10, volume: 20, value: 100, name: '2D Item 1' },\n  { weight: 20, volume: 30, value: 300, name: '2D Item 2' },\n  { weight: 30, volume: 40, value: 400, name: '2D Item 3' },\n];\nconst result2D = twoDimensionalKnapsack(items2D, 50, 60);\nconsole.log('2D Knapsack max value:', result2D);\n\nconsole.log('\\n11. Bounded Knapsack');\nconst quantities = [2, 3, 1];\nconst boundedResult = boundedKnapsackWithTracking(items, quantities, capacity);\nconsole.log('Bounded knapsack max value:', boundedResult.maxValue);\nconsole.log('Item usage:', boundedResult.usage);\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"time-complexity-summary",children:"Time Complexity Summary"}),"\n",(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:"Problem Type"}),(0,i.jsx)(e.th,{children:"Time Complexity"}),(0,i.jsx)(e.th,{children:"Space Complexity"}),(0,i.jsx)(e.th,{children:"Notes"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"0/1 Knapsack (2D)"}),(0,i.jsx)(e.td,{children:"O(nW)"}),(0,i.jsx)(e.td,{children:"O(nW)"}),(0,i.jsx)(e.td,{children:"W = capacity"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"0/1 Knapsack (1D)"}),(0,i.jsx)(e.td,{children:"O(nW)"}),(0,i.jsx)(e.td,{children:"O(W)"}),(0,i.jsx)(e.td,{children:"Space optimized"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"Unbounded Knapsack"}),(0,i.jsx)(e.td,{children:"O(nW)"}),(0,i.jsx)(e.td,{children:"O(W)"}),(0,i.jsx)(e.td,{children:"Items reusable"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"Bounded Knapsack"}),(0,i.jsx)(e.td,{children:"O(nWQ)"}),(0,i.jsx)(e.td,{children:"O(W)"}),(0,i.jsx)(e.td,{children:"Q = max quantity"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"Multiple Knapsacks"}),(0,i.jsx)(e.td,{children:"O(n \xd7 2^n)"}),(0,i.jsx)(e.td,{children:"O(2^n)"}),(0,i.jsx)(e.td,{children:"Exponential"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"Fractional Knapsack"}),(0,i.jsx)(e.td,{children:"O(n log n)"}),(0,i.jsx)(e.td,{children:"O(n)"}),(0,i.jsx)(e.td,{children:"Greedy optimal"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"Subset Sum"}),(0,i.jsx)(e.td,{children:"O(nS)"}),(0,i.jsx)(e.td,{children:"O(S)"}),(0,i.jsx)(e.td,{children:"S = target sum"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"Coin Change (Min)"}),(0,i.jsx)(e.td,{children:"O(nA)"}),(0,i.jsx)(e.td,{children:"O(A)"}),(0,i.jsx)(e.td,{children:"A = amount"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"Coin Change (Ways)"}),(0,i.jsx)(e.td,{children:"O(nA)"}),(0,i.jsx)(e.td,{children:"O(A)"}),(0,i.jsx)(e.td,{children:"Order matters"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"Meet-in-Middle"}),(0,i.jsx)(e.td,{children:"O(n \xd7 2^(n/2))"}),(0,i.jsx)(e.td,{children:"O(2^(n/2))"}),(0,i.jsx)(e.td,{children:"Space-time tradeoff"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"Branch & Bound"}),(0,i.jsx)(e.td,{children:"O(2^n)"}),(0,i.jsx)(e.td,{children:"O(n)"}),(0,i.jsx)(e.td,{children:"Best case pruning"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"FPTAS"}),(0,i.jsx)(e.td,{children:"O(n\xb3/\u03b5)"}),(0,i.jsx)(e.td,{children:"O(n\xb2/\u03b5)"}),(0,i.jsx)(e.td,{children:"\u03b5 = approximation"})]})]})]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"key-patterns-to-remember",children:"Key Patterns to Remember"}),"\n",(0,i.jsxs)(e.h3,{id:"1-dp-state-transitions",children:["1. ",(0,i.jsx)(e.strong,{children:"DP State Transitions"})]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// 0/1 Knapsack transition\ndp[i][w] = Math.max(\n  dp[i - 1][w], // Don't take item\n  dp[i - 1][w - weight[i]] + value[i] // Take item\n);\n\n// Unbounded Knapsack transition\ndp[w] = Math.max(dp[w], dp[w - weight[i]] + value[i]);\n"})}),"\n",(0,i.jsxs)(e.h3,{id:"2-space-optimization",children:["2. ",(0,i.jsx)(e.strong,{children:"Space Optimization"})]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// Process weights in reverse for 0/1 knapsack\nfor (let w = capacity; w >= item.weight; w--) {\n  dp[w] = Math.max(dp[w], dp[w - item.weight] + item.value);\n}\n"})}),"\n",(0,i.jsxs)(e.h3,{id:"3-greedy-vs-dp",children:["3. ",(0,i.jsx)(e.strong,{children:"Greedy vs DP"})]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Fractional"}),": Greedy by value/weight ratio is optimal"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"0/1"}),": DP required, greedy is not optimal"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Unbounded"}),": DP required, but greedy gives approximation"]}),"\n"]}),"\n",(0,i.jsxs)(e.h3,{id:"4-backtracking-pattern",children:["4. ",(0,i.jsx)(e.strong,{children:"Backtracking Pattern"})]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// Reconstruct solution from DP table\nlet w = capacity;\nfor (let i = n; i > 0 && w > 0; i--) {\n  if (dp[i][w] !== dp[i - 1][w]) {\n    // Item i-1 was taken\n    selectedItems.push(i - 1);\n    w -= items[i - 1].weight;\n  }\n}\n"})}),"\n",(0,i.jsxs)(e.h3,{id:"5-optimization-techniques",children:["5. ",(0,i.jsx)(e.strong,{children:"Optimization Techniques"})]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Meet-in-Middle"}),": Split items, generate all combinations"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Branch & Bound"}),": Use upper bounds for pruning"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"FPTAS"}),": Scale values for polynomial approximation"]}),"\n"]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"common-interview-patterns",children:"Common Interview Patterns"}),"\n",(0,i.jsxs)(e.h3,{id:"1-subset-based-problems",children:["1. ",(0,i.jsx)(e.strong,{children:"Subset-Based Problems"})]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Equal Sum Partition"}),"\n",(0,i.jsx)(e.li,{children:"Target Sum (assign +/- signs)"}),"\n",(0,i.jsx)(e.li,{children:"Subset Sum with specific count"}),"\n"]}),"\n",(0,i.jsxs)(e.h3,{id:"2-coinchange-problems",children:["2. ",(0,i.jsx)(e.strong,{children:"Coin/Change Problems"})]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Minimum coins needed"}),"\n",(0,i.jsx)(e.li,{children:"Number of ways to make change"}),"\n",(0,i.jsx)(e.li,{children:"Change with limited coin types"}),"\n"]}),"\n",(0,i.jsxs)(e.h3,{id:"3-optimization-variants",children:["3. ",(0,i.jsx)(e.strong,{children:"Optimization Variants"})]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Multiple constraints (weight + volume)"}),"\n",(0,i.jsx)(e.li,{children:"Item dependencies"}),"\n",(0,i.jsx)(e.li,{children:"Group selections (choose one from each group)"}),"\n"]}),"\n",(0,i.jsxs)(e.h3,{id:"4-real-world-applications",children:["4. ",(0,i.jsx)(e.strong,{children:"Real-World Applications"})]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Resource allocation"}),"\n",(0,i.jsx)(e.li,{children:"Portfolio optimization"}),"\n",(0,i.jsx)(e.li,{children:"Cutting stock problems"}),"\n",(0,i.jsx)(e.li,{children:"Task scheduling with rewards"}),"\n"]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"interview-tips",children:"Interview Tips"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Identify the variant"}),": 0/1, unbounded, or bounded?"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Check constraints"}),": Can you use space optimization?"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Consider approximation"}),": For large inputs, FPTAS might be needed"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Greedy first"}),": For fractional knapsack, greedy is optimal"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"DP table design"}),": Think about state representation"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Edge cases"}),": Zero capacity, no items, negative values"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Optimization"}),": Meet-in-middle for n \u2264 40, branch-and-bound for exact solutions"]}),"\n"]}),"\n",(0,i.jsx)(e.h1,{id:"essential-dp-knapsack-patterns--tricks",children:"Essential DP Knapsack Patterns & Tricks"}),"\n",(0,i.jsx)(e.h2,{id:"-core-decision-framework",children:"\ud83c\udfaf Core Decision Framework"}),"\n",(0,i.jsx)(e.h3,{id:"choice-skip-or-take-current-number",children:"Choice: Skip or Take Current Number"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"If elements are 0/1 choice (bounded):"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// Take and move to next element (can't reuse)\nconst skip = dfs(i + 1, t);\nconst take = dfs(i + 1, t - nums[i]);\n"})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"If elements are unbounded:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// Take and stay at same index (can reuse)\nconst skip = dfs(i + 1, t);\nconst take = dfs(i, t - nums[i]);\n"})}),"\n",(0,i.jsx)(e.h2,{id:"-bottom-up-dp-patterns",children:"\ud83d\udd04 Bottom-Up DP Patterns"}),"\n",(0,i.jsx)(e.h3,{id:"knapsack-01-bounded",children:"Knapsack 0/1 (Bounded)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function subsetSum01(nums, target) {\n  const dp = Array(target + 1).fill(false);\n  dp[0] = true; // sum 0 always possible\n\n  for (let num of nums) {\n    // BACKWARD loop prevents reuse of same element\n    for (let t = target; t >= num; t--) {\n      dp[t] = dp[t] || dp[t - num];\n    }\n  }\n  return dp[target];\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"knapsack-unbounded",children:"Knapsack Unbounded"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function subsetSumUnbounded(nums, target) {\n  const dp = Array(target + 1).fill(false);\n  dp[0] = true; // sum 0 always possible\n\n  for (let num of nums) {\n    // FORWARD loop allows reuse of same element\n    for (let t = num; t <= target; t++) {\n      dp[t] = dp[t] || dp[t - num];\n    }\n  }\n  return dp[target];\n}\n"})}),"\n",(0,i.jsx)(e.h2,{id:"-memory-trick-bottom-up",children:"\ud83d\udd11 Memory Trick (Bottom-Up)"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsxs)(e.strong,{children:["0/1 (bounded) \u2192 loop ",(0,i.jsx)(e.code,{children:"t"})," BACKWARDS \u2192 ensures each number used once"]})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsxs)(e.strong,{children:["Unbounded \u2192 loop ",(0,i.jsx)(e.code,{children:"t"})," FORWARDS \u2192 allows reusing same number multiple times"]})}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"-counting-ways-combinations-vs-permutations",children:"\ud83d\udcca Counting Ways: Combinations vs Permutations"}),"\n",(0,i.jsx)(e.h3,{id:"combinations-order-doesnt-matter",children:"Combinations (Order Doesn't Matter)"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Bottom-Up:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function countUnboundedSubsetSum(nums, target) {\n  const dp = Array(target + 1).fill(0);\n  dp[0] = 1; // one way to make 0\n\n  // Outer loop nums \u2192 inner loop target = COMBINATIONS\n  for (let num of nums) {\n    for (let t = num; t <= target; t++) {\n      dp[t] += dp[t - num];\n    }\n  }\n  return dp[target];\n}\n\nconsole.log(countUnboundedSubsetSum([3, 4, 5], 7)); // 1 \u2192 (3+4)\nconsole.log(countUnboundedSubsetSum([3, 4, 5], 11)); // 2 \u2192 (3+3+5), (4+4+3)\nconsole.log(countUnboundedSubsetSum([3, 4, 5], 2)); // 0\n"})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Top-Down:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function countCombinations(nums, target) {\n  const memo = new Map();\n\n  function dfs(i, t) {\n    if (t === 0) return 1;\n    if (i >= nums.length || t < 0) return 0;\n\n    const key = `${i},${t}`;\n    if (memo.has(key)) return memo.get(key);\n\n    // Choice: skip current num OR take it (stay at i because unbounded)\n    let ways = dfs(i + 1, t); // skip\n    ways += dfs(i, t - nums[i]); // take (reuse allowed)\n\n    memo.set(key, ways);\n    return ways;\n  }\n\n  return dfs(0, target);\n}\n\nconsole.log(countCombinations([3, 4, 5], 7)); // 1 \u2192 {3+4}\nconsole.log(countCombinations([3, 4, 5], 11)); // 2 \u2192 {3+3+5}, {4+4+3}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"permutations-order-matters",children:"Permutations (Order Matters)"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Bottom-Up:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function countPermutations(nums, target) {\n  const dp = Array(target + 1).fill(0);\n  dp[0] = 1;\n\n  // Outer loop target \u2192 inner loop nums = PERMUTATIONS\n  for (let t = 1; t <= target; t++) {\n    for (let num of nums) {\n      if (t >= num) {\n        dp[t] += dp[t - num];\n      }\n    }\n  }\n  return dp[target];\n}\n\nconsole.log(countPermutations([3, 4, 5], 7)); // 2 \u2192 [3,4], [4,3]\nconsole.log(countPermutations([3, 4, 5], 11)); // 4 \u2192 [3,3,5], [3,5,3], [5,3,3], [4,4,3]\n"})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Top-Down:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function countPermutations(nums, target) {\n  const memo = new Map();\n\n  function dfs(t) {\n    if (t === 0) return 1;\n    if (t < 0) return 0;\n    if (memo.has(t)) return memo.get(t);\n\n    let ways = 0;\n    for (let num of nums) {\n      ways += dfs(t - num); // restart loop for each num\n    }\n\n    memo.set(t, ways);\n    return ways;\n  }\n\n  return dfs(target);\n}\n"})}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"\ud83d\udc49 Key Difference:"})," No index ",(0,i.jsx)(e.code,{children:"i"})," \u2014 we try all nums every time, so [3,4] and [4,3] are treated differently."]}),"\n",(0,i.jsx)(e.h2,{id:"-loop-order-rules",children:"\u26a1 Loop Order Rules"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.strong,{children:"Outer loop nums \u2192 inner loop target = COMBINATIONS"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.strong,{children:"Outer loop target \u2192 inner loop nums = PERMUTATIONS"})}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"-mapping-bottom-up-to-top-down",children:"\ud83d\udd04 Mapping Bottom-Up to Top-Down"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Combinations:"})," Recursion keeps index ",(0,i.jsx)(e.code,{children:"i"})," (progress through nums)"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Permutations:"})," Recursion loops through all nums at each step"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"-classic-knapsack-with-weight--value",children:"\ud83c\udf92 Classic Knapsack with Weight & Value"}),"\n",(0,i.jsx)(e.h3,{id:"01-knapsack",children:"0/1 Knapsack"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function knapsack01(weights, values, capacity) {\n  const n = weights.length;\n  const dp = Array(n + 1)\n    .fill(null)\n    .map(() => Array(capacity + 1).fill(0));\n\n  for (let i = 1; i <= n; i++) {\n    for (let w = 0; w <= capacity; w++) {\n      // Don't take item i-1\n      dp[i][w] = dp[i - 1][w];\n\n      // Take item i-1 if it fits\n      if (w >= weights[i - 1]) {\n        dp[i][w] = Math.max(\n          dp[i][w],\n          dp[i - 1][w - weights[i - 1]] + values[i - 1]\n        );\n      }\n    }\n  }\n\n  return dp[n][capacity];\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"unbounded-knapsack",children:"Unbounded Knapsack"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function knapsackUnbounded(weights, values, capacity) {\n  const dp = Array(capacity + 1).fill(0);\n\n  for (let w = 1; w <= capacity; w++) {\n    for (let i = 0; i < weights.length; i++) {\n      if (w >= weights[i]) {\n        dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]);\n      }\n    }\n  }\n\n  return dp[capacity];\n}\n"})}),"\n",(0,i.jsx)(e.h2,{id:"-additional-optimization-tricks",children:"\ud83d\udd0d Additional Optimization Tricks"}),"\n",(0,i.jsx)(e.h3,{id:"space-optimization-01-knapsack",children:"Space Optimization (0/1 Knapsack)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function knapsack01Optimized(weights, values, capacity) {\n  const dp = Array(capacity + 1).fill(0);\n\n  for (let i = 0; i < weights.length; i++) {\n    // BACKWARD to avoid using updated values\n    for (let w = capacity; w >= weights[i]; w--) {\n      dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]);\n    }\n  }\n\n  return dp[capacity];\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"path-reconstruction",children:"Path Reconstruction"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function knapsackWithPath(weights, values, capacity) {\n  const n = weights.length;\n  const dp = Array(n + 1)\n    .fill(null)\n    .map(() => Array(capacity + 1).fill(0));\n\n  // Fill DP table\n  for (let i = 1; i <= n; i++) {\n    for (let w = 0; w <= capacity; w++) {\n      dp[i][w] = dp[i - 1][w];\n      if (w >= weights[i - 1]) {\n        dp[i][w] = Math.max(\n          dp[i][w],\n          dp[i - 1][w - weights[i - 1]] + values[i - 1]\n        );\n      }\n    }\n  }\n\n  // Reconstruct path\n  const path = [];\n  let i = n,\n    w = capacity;\n  while (i > 0 && w > 0) {\n    if (dp[i][w] !== dp[i - 1][w]) {\n      path.push(i - 1);\n      w -= weights[i - 1];\n    }\n    i--;\n  }\n\n  return { maxValue: dp[n][capacity], items: path.reverse() };\n}\n"})}),"\n",(0,i.jsx)(e.h2,{id:"\ufe0f-common-dp-state-patterns",children:"\ud83c\udff7\ufe0f Common DP State Patterns"}),"\n",(0,i.jsx)(e.h3,{id:"two-parameters-i-target",children:"Two Parameters (i, target)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// Most knapsack problems\nfunction dfs(i, target) {\n  // Base cases\n  // Choices: skip vs take\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"one-parameter-target-only",children:"One Parameter (target only)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// Unbounded problems, coin change\nfunction dfs(target) {\n  // Try all possible choices\n  for (let choice of choices) {\n    // recurse with target - choice\n  }\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"three-parameters-i-j-target",children:"Three Parameters (i, j, target)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// Two arrays/strings problems\nfunction dfs(i, j, target) {\n  // Process both arrays simultaneously\n}\n"})}),"\n",(0,i.jsx)(e.h2,{id:"-problem-recognition-patterns",children:"\ud83d\udca1 Problem Recognition Patterns"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:'"Exact sum"'})," \u2192 Subset sum (boolean)"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:'"Number of ways"'})," \u2192 Count combinations/permutations"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:'"Maximum value with weight limit"'})," \u2192 0/1 or unbounded knapsack"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:'"Minimum coins"'})," \u2192 Unbounded knapsack (minimize count)"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:'"Can partition"'})," \u2192 Subset sum with target = sum/2"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"\ufe0f-common-pitfalls",children:"\u26a0\ufe0f Common Pitfalls"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Loop direction matters:"})," Forward vs backward for bounded/unbounded"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Memoization key:"})," Include all changing parameters"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Base cases:"})," Handle edge cases (target=0, empty array)"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Integer overflow:"})," Use appropriate data types for large sums"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Index bounds:"})," Check array boundaries in recursive solutions"]}),"\n"]})]})}function u(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(d,{...n})}):d(n)}},28453:(n,e,t)=>{t.d(e,{R:()=>l,x:()=>r});var i=t(96540);const a={},s=i.createContext(a);function l(n){const e=i.useContext(s);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:l(n.components),i.createElement(s.Provider,{value:e},n.children)}}}]);