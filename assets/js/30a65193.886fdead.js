"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[3881],{28453:(n,e,t)=>{t.d(e,{R:()=>s,x:()=>o});var i=t(96540);const r={},a=i.createContext(r);function s(n){const e=i.useContext(a);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:s(n.components),i.createElement(a.Provider,{value:e},n.children)}},59324:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>a,metadata:()=>o,toc:()=>d});var i=t(74848),r=t(28453);const a={},s="Java DSA Cheat Sheet",o={id:"Java/JavaDSACheatSheet",title:"Java DSA Cheat Sheet",description:"Basic Syntax & Input/Output",source:"@site/docs/Java/JavaDSACheatSheet.mdx",sourceDirName:"Java",slug:"/Java/JavaDSACheatSheet",permalink:"/dev.enigma/docs/Java/JavaDSACheatSheet",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/Java/JavaDSACheatSheet.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Java Collections Cheatsheet",permalink:"/dev.enigma/docs/Java/JavaCollections"},next:{title:"Java Enums, Generics & Sorting",permalink:"/dev.enigma/docs/Java/JavaEnumsGenerics&Sorting"}},l={},d=[{value:"Basic Syntax &amp; Input/Output",id:"basic-syntax--inputoutput",level:2},{value:"Main Method &amp; Imports",id:"main-method--imports",level:3},{value:"Input/Output",id:"inputoutput",level:3},{value:"Data Types &amp; Operations",id:"data-types--operations",level:2},{value:"Primitive Types",id:"primitive-types",level:3},{value:"String Operations",id:"string-operations",level:3},{value:"Math Operations",id:"math-operations",level:3},{value:"Arrays",id:"arrays",level:2},{value:"1D Arrays",id:"1d-arrays",level:3},{value:"2D Arrays",id:"2d-arrays",level:3},{value:"Collections Framework",id:"collections-framework",level:2},{value:"ArrayList",id:"arraylist",level:3},{value:"LinkedList",id:"linkedlist",level:3},{value:"Stack",id:"stack",level:3},{value:"Queue",id:"queue",level:3},{value:"Deque (Double-ended Queue)",id:"deque-double-ended-queue",level:3},{value:"HashSet",id:"hashset",level:3},{value:"HashMap",id:"hashmap",level:3},{value:"Common DSA Patterns",id:"common-dsa-patterns",level:2},{value:"Two Pointers",id:"two-pointers",level:3},{value:"Sliding Window",id:"sliding-window",level:3},{value:"Binary Search",id:"binary-search",level:3},{value:"DFS (Depth-First Search)",id:"dfs-depth-first-search",level:3},{value:"BFS (Breadth-First Search)",id:"bfs-breadth-first-search",level:3},{value:"Union-Find (Disjoint Set)",id:"union-find-disjoint-set",level:3},{value:"Trie (Prefix Tree)",id:"trie-prefix-tree",level:3},{value:"Dynamic Programming",id:"dynamic-programming",level:2},{value:"Common DP Patterns",id:"common-dp-patterns",level:3},{value:"Useful Utilities",id:"useful-utilities",level:2},{value:"Comparators",id:"comparators",level:3},{value:"Bit Manipulation",id:"bit-manipulation",level:3},{value:"Common Edge Cases to Consider",id:"common-edge-cases-to-consider",level:3}];function c(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",pre:"pre",ul:"ul",...(0,r.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"java-dsa-cheat-sheet",children:"Java DSA Cheat Sheet"})}),"\n",(0,i.jsx)(e.h2,{id:"basic-syntax--inputoutput",children:"Basic Syntax & Input/Output"}),"\n",(0,i.jsx)(e.h3,{id:"main-method--imports",children:"Main Method & Imports"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"import java.util.*;\nimport java.io.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        // Your code here\n        sc.close();\n    }\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"inputoutput",children:"Input/Output"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'// Scanner input\nScanner sc = new Scanner(System.in);\nint n = sc.nextInt();\nString s = sc.nextLine();\nString word = sc.next();\n\n// Fast I/O for competitive programming\nBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\nBufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\nString line = br.readLine();\nint num = Integer.parseInt(br.readLine());\nbw.write("Result: " + result + "\\n");\nbw.flush();\n\n// Output\nSystem.out.println("Hello");\nSystem.out.print("No newline");\nSystem.out.printf("%d %.2f %s\\n", num, decimal, string);\n'})}),"\n",(0,i.jsx)(e.h2,{id:"data-types--operations",children:"Data Types & Operations"}),"\n",(0,i.jsx)(e.h3,{id:"primitive-types",children:"Primitive Types"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"int i = 42;                    // 32-bit: -2^31 to 2^31-1\nlong l = 42L;                  // 64-bit: -2^63 to 2^63-1\ndouble d = 3.14;               // 64-bit floating point\nchar c = 'A';                  // 16-bit Unicode\nboolean b = true;              // true/false\n\n// Constants\nfinal int MAX_SIZE = 1000;\n"})}),"\n",(0,i.jsx)(e.h3,{id:"string-operations",children:"String Operations"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'String s = "hello";\nint len = s.length();\nchar ch = s.charAt(0);\nString sub = s.substring(1, 4);        // "ell"\nString[] parts = s.split(" ");\nString joined = String.join(",", parts);\n\n// String comparison\ns1.equals(s2);                         // Content equality\ns1.compareTo(s2);                      // Lexicographic comparison\n\n// StringBuilder (mutable)\nStringBuilder sb = new StringBuilder();\nsb.append("text");\nsb.insert(0, "prefix");\nsb.deleteCharAt(0);\nString result = sb.toString();\n'})}),"\n",(0,i.jsx)(e.h3,{id:"math-operations",children:"Math Operations"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'Math.max(a, b);\nMath.min(a, b);\nMath.abs(x);\nMath.pow(base, exp);\nMath.sqrt(x);\nMath.ceil(x);\nMath.floor(x);\nMath.log(x);                           // Natural log\nMath.log10(x);                         // Base 10 log\n\n// Integer operations\nInteger.MAX_VALUE;                     // 2147483647\nInteger.MIN_VALUE;                     // -2147483648\nInteger.parseInt("123");\nString.valueOf(123);\n'})}),"\n",(0,i.jsx)(e.h2,{id:"arrays",children:"Arrays"}),"\n",(0,i.jsx)(e.h3,{id:"1d-arrays",children:"1D Arrays"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Declaration and initialization\nint[] arr = new int[5];\nint[] arr = {1, 2, 3, 4, 5};\nint[] arr = new int[]{1, 2, 3, 4, 5};\n\n// Operations\nint len = arr.length;\nArrays.fill(arr, -1);                  // Fill with value\nArrays.sort(arr);                      // Sort ascending\nArrays.sort(arr, Collections.reverseOrder()); // Sort descending (Integer[] needed)\n\n// Binary search (array must be sorted)\nint index = Arrays.binarySearch(arr, target);\n\n// Copy array\nint[] copy = Arrays.copyOf(arr, arr.length);\nint[] copy = arr.clone();\n"})}),"\n",(0,i.jsx)(e.h3,{id:"2d-arrays",children:"2D Arrays"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Declaration\nint[][] matrix = new int[rows][cols];\nint[][] matrix = {{1,2,3}, {4,5,6}};\n\n// Jagged arrays\nint[][] jagged = new int[3][];\njagged[0] = new int[2];\njagged[1] = new int[4];\n\n// Iteration\nfor(int i = 0; i < matrix.length; i++) {\n    for(int j = 0; j < matrix[i].length; j++) {\n        // matrix[i][j]\n    }\n}\n\n// Enhanced for loop\nfor(int[] row : matrix) {\n    for(int val : row) {\n        // val\n    }\n}\n"})}),"\n",(0,i.jsx)(e.h2,{id:"collections-framework",children:"Collections Framework"}),"\n",(0,i.jsx)(e.h3,{id:"arraylist",children:"ArrayList"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"ArrayList<Integer> list = new ArrayList<>();\nlist.add(1);                           // Add element\nlist.add(0, 5);                        // Add at index\nlist.get(0);                           // Get element\nlist.set(0, 10);                       // Set element\nlist.remove(0);                        // Remove by index\nlist.remove(Integer.valueOf(5));       // Remove by value\nlist.size();                           // Size\nlist.isEmpty();                        // Check if empty\nlist.contains(5);                      // Check if contains\n\n// Convert to array\nInteger[] array = list.toArray(new Integer[0]);\n\n// Sorting\nCollections.sort(list);\nCollections.sort(list, Collections.reverseOrder());\n"})}),"\n",(0,i.jsx)(e.h3,{id:"linkedlist",children:"LinkedList"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"LinkedList<Integer> ll = new LinkedList<>();\nll.addFirst(1);\nll.addLast(2);\nll.removeFirst();\nll.removeLast();\nll.peekFirst();                        // Get first without removing\nll.peekLast();                         // Get last without removing\n"})}),"\n",(0,i.jsx)(e.h3,{id:"stack",children:"Stack"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"Stack<Integer> stack = new Stack<>();\nstack.push(1);                         // Add to top\nint top = stack.pop();                 // Remove and return top\nint peek = stack.peek();               // Get top without removing\nboolean empty = stack.isEmpty();\n\n// Alternative: Use ArrayDeque\nArrayDeque<Integer> stack = new ArrayDeque<>();\nstack.push(1);\nstack.pop();\nstack.peek();\n"})}),"\n",(0,i.jsx)(e.h3,{id:"queue",children:"Queue"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"Queue<Integer> queue = new LinkedList<>();\nqueue.offer(1);                        // Add to rear\nint front = queue.poll();              // Remove and return front\nint peek = queue.peek();               // Get front without removing\nboolean empty = queue.isEmpty();\n\n// Priority Queue (Min Heap by default)\nPriorityQueue<Integer> pq = new PriorityQueue<>();\nPriorityQueue<Integer> maxPq = new PriorityQueue<>(Collections.reverseOrder());\n\npq.offer(5);\npq.offer(1);\npq.offer(3);\nint min = pq.poll();                   // Returns 1\n\n// Custom comparator\nPriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);\n"})}),"\n",(0,i.jsx)(e.h3,{id:"deque-double-ended-queue",children:"Deque (Double-ended Queue)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"ArrayDeque<Integer> deque = new ArrayDeque<>();\ndeque.addFirst(1);\ndeque.addLast(2);\ndeque.removeFirst();\ndeque.removeLast();\ndeque.peekFirst();\ndeque.peekLast();\n"})}),"\n",(0,i.jsx)(e.h3,{id:"hashset",children:"HashSet"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"HashSet<Integer> set = new HashSet<>();\nset.add(1);\nset.remove(1);\nboolean contains = set.contains(1);\nint size = set.size();\n\n// LinkedHashSet maintains insertion order\nLinkedHashSet<Integer> linkedSet = new LinkedHashSet<>();\n\n// TreeSet (sorted)\nTreeSet<Integer> treeSet = new TreeSet<>();\nint first = treeSet.first();\nint last = treeSet.last();\n"})}),"\n",(0,i.jsx)(e.h3,{id:"hashmap",children:"HashMap"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'HashMap<String, Integer> map = new HashMap<>();\nmap.put("key", 1);                     // Add/update\nint value = map.get("key");            // Get value\nint value = map.getOrDefault("key", 0); // Get with default\nboolean hasKey = map.containsKey("key");\nboolean hasValue = map.containsValue(1);\nmap.remove("key");\n\n// Iteration\nfor(String key : map.keySet()) {\n    int val = map.get(key);\n}\n\nfor(Map.Entry<String, Integer> entry : map.entrySet()) {\n    String key = entry.getKey();\n    int value = entry.getValue();\n}\n\n// TreeMap (sorted by keys)\nTreeMap<String, Integer> treeMap = new TreeMap<>();\nString firstKey = treeMap.firstKey();\nString lastKey = treeMap.lastKey();\n'})}),"\n",(0,i.jsx)(e.h2,{id:"common-dsa-patterns",children:"Common DSA Patterns"}),"\n",(0,i.jsx)(e.h3,{id:"two-pointers",children:"Two Pointers"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Array two pointers\nint left = 0, right = arr.length - 1;\nwhile(left < right) {\n    if(condition) {\n        left++;\n    } else {\n        right--;\n    }\n}\n\n// Fast and slow pointers (Floyd's algorithm)\nint slow = 0, fast = 0;\nwhile(fast < n && fast + 1 < n) {\n    slow++;\n    fast += 2;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"sliding-window",children:"Sliding Window"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"int left = 0;\nfor(int right = 0; right < arr.length; right++) {\n    // Add arr[right] to window\n\n    while(windowNotValid) {\n        // Remove arr[left] from window\n        left++;\n    }\n\n    // Process current window [left, right]\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"binary-search",children:"Binary Search"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Template for binary search\nint left = 0, right = arr.length - 1;\nwhile(left <= right) {\n    int mid = left + (right - left) / 2;\n    if(arr[mid] == target) {\n        return mid;\n    } else if(arr[mid] < target) {\n        left = mid + 1;\n    } else {\n        right = mid - 1;\n    }\n}\n\n// Find leftmost/rightmost position\nint findFirst(int[] arr, int target) {\n    int left = 0, right = arr.length - 1, result = -1;\n    while(left <= right) {\n        int mid = left + (right - left) / 2;\n        if(arr[mid] == target) {\n            result = mid;\n            right = mid - 1;  // Continue searching left\n        } else if(arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return result;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"dfs-depth-first-search",children:"DFS (Depth-First Search)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Recursive DFS\nvoid dfs(int[][] grid, int row, int col, boolean[][] visited) {\n    if(row < 0 || row >= grid.length || col < 0 || col >= grid[0].length ||\n       visited[row][col]) {\n        return;\n    }\n\n    visited[row][col] = true;\n\n    // Process current cell\n\n    // Visit neighbors\n    dfs(grid, row + 1, col, visited);\n    dfs(grid, row - 1, col, visited);\n    dfs(grid, row, col + 1, visited);\n    dfs(grid, row, col - 1, visited);\n}\n\n// Iterative DFS using stack\nStack<int[]> stack = new Stack<>();\nstack.push(new int[]{startRow, startCol});\n\nwhile(!stack.isEmpty()) {\n    int[] current = stack.pop();\n    int row = current[0], col = current[1];\n\n    if(visited[row][col]) continue;\n    visited[row][col] = true;\n\n    // Add neighbors to stack\n    // stack.push(new int[]{newRow, newCol});\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"bfs-breadth-first-search",children:"BFS (Breadth-First Search)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"Queue<int[]> queue = new LinkedList<>();\nqueue.offer(new int[]{startRow, startCol});\nvisited[startRow][startCol] = true;\n\nint level = 0;\nwhile(!queue.isEmpty()) {\n    int size = queue.size();\n\n    for(int i = 0; i < size; i++) {\n        int[] current = queue.poll();\n        int row = current[0], col = current[1];\n\n        // Process current cell\n\n        // Add unvisited neighbors\n        int[][] directions = {{0,1}, {1,0}, {0,-1}, {-1,0}};\n        for(int[] dir : directions) {\n            int newRow = row + dir[0];\n            int newCol = col + dir[1];\n\n            if(isValid(newRow, newCol) && !visited[newRow][newCol]) {\n                visited[newRow][newCol] = true;\n                queue.offer(new int[]{newRow, newCol});\n            }\n        }\n    }\n    level++;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"union-find-disjoint-set",children:"Union-Find (Disjoint Set)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"class UnionFind {\n    int[] parent, rank;\n\n    public UnionFind(int n) {\n        parent = new int[n];\n        rank = new int[n];\n        for(int i = 0; i < n; i++) {\n            parent[i] = i;\n            rank[i] = 1;\n        }\n    }\n\n    public int find(int x) {\n        if(parent[x] != x) {\n            parent[x] = find(parent[x]); // Path compression\n        }\n        return parent[x];\n    }\n\n    public boolean union(int x, int y) {\n        int rootX = find(x), rootY = find(y);\n        if(rootX == rootY) return false;\n\n        // Union by rank\n        if(rank[rootX] < rank[rootY]) {\n            parent[rootX] = rootY;\n        } else if(rank[rootX] > rank[rootY]) {\n            parent[rootY] = rootX;\n        } else {\n            parent[rootY] = rootX;\n            rank[rootX]++;\n        }\n        return true;\n    }\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"trie-prefix-tree",children:"Trie (Prefix Tree)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"class TrieNode {\n    TrieNode[] children = new TrieNode[26];\n    boolean isEnd = false;\n}\n\nclass Trie {\n    TrieNode root;\n\n    public Trie() {\n        root = new TrieNode();\n    }\n\n    public void insert(String word) {\n        TrieNode curr = root;\n        for(char c : word.toCharArray()) {\n            int index = c - 'a';\n            if(curr.children[index] == null) {\n                curr.children[index] = new TrieNode();\n            }\n            curr = curr.children[index];\n        }\n        curr.isEnd = true;\n    }\n\n    public boolean search(String word) {\n        TrieNode curr = root;\n        for(char c : word.toCharArray()) {\n            int index = c - 'a';\n            if(curr.children[index] == null) return false;\n            curr = curr.children[index];\n        }\n        return curr.isEnd;\n    }\n}\n"})}),"\n",(0,i.jsx)(e.h2,{id:"dynamic-programming",children:"Dynamic Programming"}),"\n",(0,i.jsx)(e.h3,{id:"common-dp-patterns",children:"Common DP Patterns"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'// 1D DP\nint[] dp = new int[n + 1];\ndp[0] = base_case;\nfor(int i = 1; i <= n; i++) {\n    dp[i] = // transition from previous states\n}\n\n// 2D DP\nint[][] dp = new int[m + 1][n + 1];\nfor(int i = 0; i <= m; i++) {\n    for(int j = 0; j <= n; j++) {\n        if(i == 0 || j == 0) {\n            dp[i][j] = base_case;\n        } else {\n            dp[i][j] = // transition\n        }\n    }\n}\n\n// Memoization (Top-down)\nMap<String, Integer> memo = new HashMap<>();\nint solve(int i, int j) {\n    String key = i + "," + j;\n    if(memo.containsKey(key)) return memo.get(key);\n\n    // Base cases\n    if(i == 0 || j == 0) return base_case;\n\n    int result = // recursive calls\n    memo.put(key, result);\n    return result;\n}\n'})}),"\n",(0,i.jsx)(e.h2,{id:"useful-utilities",children:"Useful Utilities"}),"\n",(0,i.jsx)(e.h3,{id:"comparators",children:"Comparators"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Sort array of arrays by first element\nArrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));\n\n// Sort in descending order\nArrays.sort(arr, (a, b) -> b - a);\n\n// Multiple criteria sorting\nArrays.sort(people, (a, b) -> {\n    if(a[0] == b[0]) return a[1] - b[1];  // Secondary sort\n    return a[0] - b[0];                   // Primary sort\n});\n\n// Custom object sorting\nCollections.sort(list, new Comparator<Person>() {\n    public int compare(Person a, Person b) {\n        return a.age - b.age;\n    }\n});\n"})}),"\n",(0,i.jsx)(e.h3,{id:"bit-manipulation",children:"Bit Manipulation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Common operations\nint setBit = n | (1 << i);            // Set i-th bit\nint clearBit = n & ~(1 << i);         // Clear i-th bit\nint toggleBit = n ^ (1 << i);         // Toggle i-th bit\nboolean isSet = (n & (1 << i)) != 0;  // Check if i-th bit is set\n\n// Useful tricks\nint rightmostSetBit = n & (-n);       // Get rightmost set bit\nint clearRightmostSetBit = n & (n-1); // Clear rightmost set bit\nboolean isPowerOfTwo = n > 0 && (n & (n-1)) == 0;\nint countSetBits = Integer.bitCount(n);\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'import java.util.*;\nimport java.util.stream.*;\n\n/**\n * Java Tips and Tricks for Data Structures and Algorithms\n * Essential patterns and shortcuts for coding interviews\n */\npublic class JavaDSATips {\n\n    // ================== 1. STRING MANIPULATION TRICKS ==================\n\n    public static void stringTricks() {\n        System.out.println("=== STRING TRICKS ===");\n\n        // Convert string to char array (most common)\n        String s = "hello";\n        char[] chars = s.toCharArray();\n\n        // Convert char array back to string\n        String result = new String(chars);\n\n        // String to integer conversion\n        String num = "123";\n        int number = Integer.parseInt(num);\n\n        // Character to digit conversion\n        char ch = \'5\';\n        int digit = ch - \'0\'; // Result: 5\n\n        // Digit to character conversion\n        int d = 7;\n        char character = (char) (d + \'0\'); // Result: \'7\'\n\n        // Check if character is alphanumeric\n        char c = \'A\';\n        boolean isAlphaNumeric = Character.isLetterOrDigit(c);\n        boolean isDigit = Character.isDigit(c);\n        boolean isLetter = Character.isLetter(c);\n\n        // String comparison (lexicographical)\n        String str1 = "abc", str2 = "def";\n        int comparison = str1.compareTo(str2); // negative if str1 < str2\n\n        // Reverse a string using StringBuilder\n        String original = "hello";\n        String reversed = new StringBuilder(original).reverse().toString();\n\n        // Check if string is palindrome\n        String palindrome = "racecar";\n        boolean isPalindrome = palindrome.equals(new StringBuilder(palindrome).reverse().toString());\n\n        System.out.println("Original: " + original + ", Reversed: " + reversed);\n        System.out.println("Is palindrome: " + isPalindrome);\n    }\n\n    // ================== 2. ARRAY MANIPULATION TRICKS ==================\n\n    public static void arrayTricks() {\n        System.out.println("\\n=== ARRAY TRICKS ===");\n\n        // Initialize array with specific value\n        int[] arr = new int[5];\n        Arrays.fill(arr, -1); // Fill with -1\n\n        // 2D array initialization\n        int[][] matrix = new int[3][4];\n        for (int[] row : matrix) {\n            Arrays.fill(row, Integer.MAX_VALUE);\n        }\n\n        // Copy array\n        int[] original = {1, 2, 3, 4, 5};\n        int[] copy = Arrays.copyOf(original, original.length);\n        int[] subArray = Arrays.copyOfRange(original, 1, 4); // [2, 3, 4]\n\n        // Sort array\n        Arrays.sort(original);\n\n        // Sort in descending order\n        Integer[] boxed = {5, 2, 8, 1, 9};\n        Arrays.sort(boxed, Collections.reverseOrder());\n\n        // Binary search (array must be sorted)\n        int[] sorted = {1, 3, 5, 7, 9};\n        int index = Arrays.binarySearch(sorted, 5); // Returns index or negative if not found\n\n        // Convert array to list\n        List<Integer> list = Arrays.asList(boxed);\n\n        // Find min and max in array\n        int min = Arrays.stream(sorted).min().orElse(Integer.MAX_VALUE);\n        int max = Arrays.stream(sorted).max().orElse(Integer.MIN_VALUE);\n\n        // Two pointers technique setup\n        int left = 0, right = sorted.length - 1;\n        while (left < right) {\n            // Process logic here\n            left++;\n            right--;\n        }\n\n        System.out.println("Subarray: " + Arrays.toString(subArray));\n        System.out.println("Min: " + min + ", Max: " + max);\n    }\n\n    // ================== 3. COLLECTIONS SHORTCUTS ==================\n\n    public static void collectionTricks() {\n        System.out.println("\\n=== COLLECTION TRICKS ===");\n\n        // List initialization shortcuts\n        List<Integer> list1 = Arrays.asList(1, 2, 3, 4, 5);\n        List<Integer> list2 = new ArrayList<>(Arrays.asList(1, 2, 3));\n        List<String> list3 = List.of("a", "b", "c"); // Java 9+ (immutable)\n\n        // Set initialization\n        Set<Integer> set1 = new HashSet<>(Arrays.asList(1, 2, 3));\n        Set<String> set2 = Set.of("x", "y", "z"); // Java 9+ (immutable)\n\n        // Map initialization\n        Map<String, Integer> map = Map.of("a", 1, "b", 2, "c", 3); // Java 9+\n\n        // Traditional map initialization\n        Map<Character, Integer> charCount = new HashMap<>();\n        String text = "hello";\n        for (char c : text.toCharArray()) {\n            charCount.put(c, charCount.getOrDefault(c, 0) + 1);\n        }\n\n        // Using computeIfAbsent for nested structures\n        Map<String, List<String>> groupMap = new HashMap<>();\n        groupMap.computeIfAbsent("key1", k -> new ArrayList<>()).add("value1");\n\n        // Priority Queue (Min Heap by default)\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>();\n\n        // Priority Queue (Max Heap)\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\n\n        // Custom comparator\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]); // Sort by second element\n\n        // Deque as stack and queue\n        Deque<Integer> stack = new ArrayDeque<>();\n        stack.push(1); // Add to top\n        stack.pop();   // Remove from top\n\n        Deque<Integer> queue = new ArrayDeque<>();\n        queue.offer(1); // Add to rear\n        queue.poll();   // Remove from front\n\n        System.out.println("Character count: " + charCount);\n    }\n\n    // ================== 4. MATHEMATICAL TRICKS ==================\n\n    public static void mathTricks() {\n        System.out.println("\\n=== MATH TRICKS ===");\n\n        // GCD and LCM\n        int a = 12, b = 18;\n        int gcd = gcd(a, b);\n        int lcm = (a * b) / gcd;\n\n        // Check if number is prime\n        boolean isPrime = isPrime(17);\n\n        // Generate all divisors\n        List<Integer> divisors = getDivisors(12);\n\n        // Check if power of 2\n        boolean isPowerOf2 = isPowerOfTwo(16);\n\n        // Bit manipulation tricks\n        int n = 5; // Binary: 101\n\n        // Check if i-th bit is set\n        boolean isBitSet = (n & (1 << 2)) != 0; // Check 2nd bit\n\n        // Set i-th bit\n        int setBit = n | (1 << 1); // Set 1st bit\n\n        // Clear i-th bit\n        int clearBit = n & ~(1 << 0); // Clear 0th bit\n\n        // Toggle i-th bit\n        int toggleBit = n ^ (1 << 1); // Toggle 1st bit\n\n        // Count set bits\n        int setBits = Integer.bitCount(n);\n\n        // Find rightmost set bit\n        int rightmostSetBit = n & -n;\n\n        System.out.println("GCD: " + gcd + ", LCM: " + lcm);\n        System.out.println("Is prime: " + isPrime);\n        System.out.println("Divisors: " + divisors);\n        System.out.println("Set bits: " + setBits);\n    }\n\n    // ================== 5. GRAPH ALGORITHMS SETUP ==================\n\n    public static void graphTricks() {\n        System.out.println("\\n=== GRAPH TRICKS ===");\n\n        // Adjacency List representation\n        int n = 5; // number of nodes\n        List<List<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            adj.add(new ArrayList<>());\n        }\n\n        // Add edge\n        int u = 0, v = 1;\n        adj.get(u).add(v);\n        adj.get(v).add(u); // For undirected graph\n\n        // BFS setup\n        Queue<Integer> queue = new LinkedList<>();\n        boolean[] visited = new boolean[n];\n        queue.offer(0);\n        visited[0] = true;\n\n        while (!queue.isEmpty()) {\n            int node = queue.poll();\n            for (int neighbor : adj.get(node)) {\n                if (!visited[neighbor]) {\n                    visited[neighbor] = true;\n                    queue.offer(neighbor);\n                }\n            }\n        }\n\n        // DFS setup\n        boolean[] vis = new boolean[n];\n        dfs(0, adj, vis);\n\n        // Directions array for 2D grid\n        int[][] directions = {{-1,0}, {1,0}, {0,-1}, {0,1}}; // up, down, left, right\n        int[][] directions8 = {{-1,-1}, {-1,0}, {-1,1}, {0,-1}, {0,1}, {1,-1}, {1,0}, {1,1}}; // 8 directions\n\n        System.out.println("Graph setup complete");\n    }\n\n    // ================== 6. TREE ALGORITHMS ==================\n\n    static class TreeNode {\n        int val;\n        TreeNode left, right;\n        TreeNode(int val) { this.val = val; }\n    }\n\n    public static void treeTricks() {\n        System.out.println("\\n=== TREE TRICKS ===");\n\n        TreeNode root = new TreeNode(1);\n        root.left = new TreeNode(2);\n        root.right = new TreeNode(3);\n\n        // Inorder traversal (iterative)\n        List<Integer> inorder = inorderTraversal(root);\n\n        // Level order traversal\n        List<List<Integer>> levelOrder = levelOrderTraversal(root);\n\n        // Tree height\n        int height = getHeight(root);\n\n        System.out.println("Inorder: " + inorder);\n        System.out.println("Height: " + height);\n    }\n\n    // ================== 7. SORTING AND SEARCHING TRICKS ==================\n\n    public static void sortingTricks() {\n        System.out.println("\\n=== SORTING TRICKS ===");\n\n        // Custom sorting\n        int[][] intervals = {{1,3}, {2,6}, {8,10}, {15,18}};\n\n        // Sort by start time\n        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\n\n        // Sort by end time\n        Arrays.sort(intervals, (a, b) -> a[1] - b[1]);\n\n        // Sort strings by length\n        String[] words = {"apple", "pie", "washington", "book"};\n        Arrays.sort(words, (a, b) -> a.length() - b.length());\n\n        // Sort with multiple criteria\n        Arrays.sort(intervals, (a, b) -> {\n            if (a[0] != b[0]) return a[0] - b[0]; // First by start time\n            return a[1] - b[1]; // Then by end time\n        });\n\n        // Binary search variations\n        int[] arr = {1, 2, 2, 2, 3, 4, 5};\n        int target = 2;\n\n        // Find leftmost occurrence\n        int leftmost = findLeftmost(arr, target);\n\n        // Find rightmost occurrence\n        int rightmost = findRightmost(arr, target);\n\n        System.out.println("Leftmost index of " + target + ": " + leftmost);\n        System.out.println("Rightmost index of " + target + ": " + rightmost);\n    }\n\n    // ================== 8. DYNAMIC PROGRAMMING PATTERNS ==================\n\n    public static void dpTricks() {\n        System.out.println("\\n=== DP TRICKS ===");\n\n        // 1D DP initialization\n        int n = 10;\n        int[] dp = new int[n + 1];\n        Arrays.fill(dp, -1); // For memoization\n\n        // 2D DP initialization\n        int m = 5;\n        int[][] dp2d = new int[n][m];\n        for (int[] row : dp2d) {\n            Arrays.fill(row, -1);\n        }\n\n        // Fibonacci example (bottom-up)\n        dp[0] = 0;\n        dp[1] = 1;\n        for (int i = 2; i <= n; i++) {\n            dp[i] = dp[i-1] + dp[i-2];\n        }\n\n        // Space optimization technique\n        int prev2 = 0, prev1 = 1, curr = 0;\n        for (int i = 2; i <= n; i++) {\n            curr = prev1 + prev2;\n            prev2 = prev1;\n            prev1 = curr;\n        }\n\n        System.out.println("10th Fibonacci: " + dp[n]);\n    }\n\n    // ================== 9. UTILITY HELPER METHODS ==================\n\n    // GCD using Euclidean algorithm\n    public static int gcd(int a, int b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n\n    // Check if number is prime\n    public static boolean isPrime(int n) {\n        if (n <= 1) return false;\n        if (n <= 3) return true;\n        if (n % 2 == 0 || n % 3 == 0) return false;\n\n        for (int i = 5; i * i <= n; i += 6) {\n            if (n % i == 0 || n % (i + 2) == 0) return false;\n        }\n        return true;\n    }\n\n    // Get all divisors\n    public static List<Integer> getDivisors(int n) {\n        List<Integer> divisors = new ArrayList<>();\n        for (int i = 1; i * i <= n; i++) {\n            if (n % i == 0) {\n                divisors.add(i);\n                if (i != n / i) {\n                    divisors.add(n / i);\n                }\n            }\n        }\n        Collections.sort(divisors);\n        return divisors;\n    }\n\n    // Check if power of 2\n    public static boolean isPowerOfTwo(int n) {\n        return n > 0 && (n & (n - 1)) == 0;\n    }\n\n    // DFS helper\n    public static void dfs(int node, List<List<Integer>> adj, boolean[] visited) {\n        visited[node] = true;\n        for (int neighbor : adj.get(node)) {\n            if (!visited[neighbor]) {\n                dfs(neighbor, adj, visited);\n            }\n        }\n    }\n\n    // Tree traversal helpers\n    public static List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> result = new ArrayList<>();\n        Stack<TreeNode> stack = new Stack<>();\n        TreeNode curr = root;\n\n        while (curr != null || !stack.isEmpty()) {\n            while (curr != null) {\n                stack.push(curr);\n                curr = curr.left;\n            }\n            curr = stack.pop();\n            result.add(curr.val);\n            curr = curr.right;\n        }\n        return result;\n    }\n\n    public static List<List<Integer>> levelOrderTraversal(TreeNode root) {\n        List<List<Integer>> result = new ArrayList<>();\n        if (root == null) return result;\n\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            List<Integer> level = new ArrayList<>();\n\n            for (int i = 0; i < size; i++) {\n                TreeNode node = queue.poll();\n                level.add(node.val);\n\n                if (node.left != null) queue.offer(node.left);\n                if (node.right != null) queue.offer(node.right);\n            }\n            result.add(level);\n        }\n        return result;\n    }\n\n    public static int getHeight(TreeNode root) {\n        if (root == null) return 0;\n        return 1 + Math.max(getHeight(root.left), getHeight(root.right));\n    }\n\n    // Binary search variants\n    public static int findLeftmost(int[] arr, int target) {\n        int left = 0, right = arr.length - 1, result = -1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (arr[mid] == target) {\n                result = mid;\n                right = mid - 1; // Continue searching left\n            } else if (arr[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        return result;\n    }\n\n    public static int findRightmost(int[] arr, int target) {\n        int left = 0, right = arr.length - 1, result = -1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (arr[mid] == target) {\n                result = mid;\n                left = mid + 1; // Continue searching right\n            } else if (arr[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        return result;\n    }\n\n    // ================== 10. COMMON PATTERNS & TEMPLATES ==================\n\n    public static void commonPatterns() {\n        System.out.println("\\n=== COMMON PATTERNS ===");\n\n        // Sliding window pattern\n        String s = "abcabcbb";\n        int maxLength = longestSubstringWithoutRepeating(s);\n\n        // Two sum pattern\n        int[] nums = {2, 7, 11, 15};\n        int target = 9;\n        int[] twoSumResult = twoSum(nums, target);\n\n        // Fast and slow pointers (Floyd\'s cycle detection)\n        // Useful for linked lists and arrays\n\n        System.out.println("Longest substring length: " + maxLength);\n        System.out.println("Two sum result: " + Arrays.toString(twoSumResult));\n    }\n\n    // Sliding window example\n    public static int longestSubstringWithoutRepeating(String s) {\n        Set<Character> set = new HashSet<>();\n        int left = 0, maxLen = 0;\n\n        for (int right = 0; right < s.length(); right++) {\n            while (set.contains(s.charAt(right))) {\n                set.remove(s.charAt(left));\n                left++;\n            }\n            set.add(s.charAt(right));\n            maxLen = Math.max(maxLen, right - left + 1);\n        }\n        return maxLen;\n    }\n\n    // Two sum with HashMap\n    public static int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[]{map.get(complement), i};\n            }\n            map.put(nums[i], i);\n        }\n        return new int[0];\n    }\n\n    // ================== MAIN METHOD ==================\n\n    public static void main(String[] args) {\n        stringTricks();\n        arrayTricks();\n        collectionTricks();\n        mathTricks();\n        graphTricks();\n        treeTricks();\n        sortingTricks();\n        dpTricks();\n        commonPatterns();\n\n        System.out.println("\\n=== QUICK REFERENCE COMPLETED ===");\n        System.out.println("Remember: Practice these patterns until they become muscle memory!");\n    }\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"common-edge-cases-to-consider",children:"Common Edge Cases to Consider"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Empty arrays/strings"}),"\n",(0,i.jsx)(e.li,{children:"Single element arrays"}),"\n",(0,i.jsxs)(e.li,{children:["Integer overflow (use ",(0,i.jsx)(e.code,{children:"long"})," when needed)"]}),"\n",(0,i.jsx)(e.li,{children:"Null inputs"}),"\n",(0,i.jsx)(e.li,{children:"Negative numbers"}),"\n",(0,i.jsx)(e.li,{children:"Duplicate elements"}),"\n",(0,i.jsx)(e.li,{children:"Array bounds checking"}),"\n"]})]})}function u(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(c,{...n})}):c(n)}}}]);