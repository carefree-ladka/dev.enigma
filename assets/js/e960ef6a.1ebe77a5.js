"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[6421],{28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>i});var r=t(96540);const o={},c=r.createContext(o);function s(e){const n=r.useContext(c);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),r.createElement(c.Provider,{value:n},e.children)}},47917:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>s,default:()=>l,frontMatter:()=>c,metadata:()=>i,toc:()=>u});var r=t(74848),o=t(28453);const c={},s="Redux Toolkit Testing",i={id:"WebDev/React/ReduxToolkitTesting",title:"Redux Toolkit Testing",description:"",source:"@site/docs/WebDev/React/ReduxToolkitTesting.mdx",sourceDirName:"WebDev/React",slug:"/WebDev/React/ReduxToolkitTesting",permalink:"/dev.enigma/docs/WebDev/React/ReduxToolkitTesting",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/WebDev/React/ReduxToolkitTesting.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Redux Toolkit",permalink:"/dev.enigma/docs/WebDev/React/ReduxToolkit"},next:{title:"Redux vs Context API",permalink:"/dev.enigma/docs/WebDev/React/ReduxVSContext"}},a={},u=[];function d(e){const n={code:"code",h1:"h1",header:"header",pre:"pre",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"redux-toolkit-testing",children:"Redux Toolkit Testing"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-JavaScript",children:"// Redux Toolkit Testing Guide\n\n// 1. Setting Up Test Environment\nimport { configureStore } from '@reduxjs/toolkit';\nimport { render } from '@testing-library/react';\nimport { Provider } from 'react-redux';\n\n// Sample slice\nimport { createSlice } from '@reduxjs/toolkit';\n\nconst counterSlice = createSlice({\n  name: 'counter',\n  initialState: { value: 0 },\n  reducers: {\n    increment: (state) => {\n      state.value += 1;\n    },\n    decrementByAmount: (state, action) => {\n      state.value -= action.payload;\n    },\n  },\n});\n\n// 2. Testing Reducers\ndescribe('counterSlice reducers', () => {\n  const initialState = { value: 0 };\n\n  test('should handle increment', () => {\n    expect(\n      counterSlice.reducer(initialState, counterSlice.actions.increment())\n    ).toEqual({ value: 1 });\n  });\n\n  test('should handle decrementByAmount', () => {\n    expect(\n      counterSlice.reducer(initialState, counterSlice.actions.decrementByAmount(2))\n    ).toEqual({ value: -2 });\n  });\n\n  test('should handle unknown action', () => {\n    expect(\n      counterSlice.reducer(initialState, { type: 'unknown' })\n    ).toEqual(initialState);\n  });\n});\n\n// 3. Testing Async Thunks\n// Example thunk\nconst fetchUserById = createAsyncThunk(\n  'users/fetchById',\n  async (userId, thunkAPI) => {\n    const response = await fetch(`/api/users/${userId}`);\n    return response.json();\n  }\n);\n\n// Testing thunk\ndescribe('fetchUserById thunk', () => {\n  test('successful fetch', async () => {\n    const user = { id: 1, name: 'John' };\n\n    // Mock fetch\n    global.fetch = jest.fn(() =>\n      Promise.resolve({\n        json: () => Promise.resolve(user),\n      })\n    );\n\n    const dispatch = jest.fn();\n    const thunk = fetchUserById(1);\n\n    await thunk(dispatch, () => ({}));\n\n    const { calls } = dispatch.mock;\n    expect(calls[0][0].type).toBe('users/fetchById/pending');\n    expect(calls[1][0].type).toBe('users/fetchById/fulfilled');\n    expect(calls[1][0].payload).toEqual(user);\n  });\n\n  test('failed fetch', async () => {\n    const error = new Error('Network error');\n\n    global.fetch = jest.fn(() => Promise.reject(error));\n\n    const dispatch = jest.fn();\n    const thunk = fetchUserById(1);\n\n    await thunk(dispatch, () => ({}));\n\n    const { calls } = dispatch.mock;\n    expect(calls[0][0].type).toBe('users/fetchById/pending');\n    expect(calls[1][0].type).toBe('users/fetchById/rejected');\n    expect(calls[1][0].error.message).toBe('Network error');\n  });\n});\n\n// 4. Testing Selectors\nconst selectCount = (state) => state.counter.value;\n\ndescribe('selectors', () => {\n  const state = {\n    counter: { value: 42 }\n  };\n\n  test('should select counter value', () => {\n    expect(selectCount(state)).toBe(42);\n  });\n});\n\n// 5. Testing Connected Components\nfunction renderWithProviders(\n  ui,\n  {\n    preloadedState = {},\n    store = configureStore({\n      reducer: { counter: counterSlice.reducer },\n      preloadedState,\n    }),\n    ...renderOptions\n  } = {}\n) {\n  function Wrapper({ children }) {\n    return <Provider store={store}>{children}</Provider>;\n  }\n\n  return {\n    store,\n    ...render(ui, { wrapper: Wrapper, ...renderOptions }),\n  };\n}\n\n// Example component test\nimport { screen, fireEvent } from '@testing-library/react';\n\ndescribe('Counter component', () => {\n  test('renders with redux provider', () => {\n    renderWithProviders(<Counter />, {\n      preloadedState: {\n        counter: { value: 5 },\n      },\n    });\n\n    expect(screen.getByText('Count: 5')).toBeInTheDocument();\n  });\n\n  test('increments value', () => {\n    const { store } = renderWithProviders(<Counter />, {\n      preloadedState: {\n        counter: { value: 5 },\n      },\n    });\n\n    fireEvent.click(screen.getByText('Increment'));\n\n    expect(store.getState().counter.value).toBe(6);\n  });\n});\n\n// 6. Testing Store Configuration\ndescribe('store configuration', () => {\n  test('should handle initial state', () => {\n    const store = configureStore({\n      reducer: {\n        counter: counterSlice.reducer,\n      },\n    });\n\n    expect(store.getState().counter.value).toBe(0);\n  });\n\n  test('should handle multiple dispatches', () => {\n    const store = configureStore({\n      reducer: {\n        counter: counterSlice.reducer,\n      },\n    });\n\n    store.dispatch(counterSlice.actions.increment());\n    store.dispatch(counterSlice.actions.increment());\n    store.dispatch(counterSlice.actions.decrementByAmount(1));\n\n    expect(store.getState().counter.value).toBe(1);\n  });\n});\n\n// 7. Testing Middleware\nconst customMiddleware = (store) => (next) => (action) => {\n  if (action.type === 'counter/increment') {\n    // Custom logic\n    console.log('Increment detected');\n  }\n  return next(action);\n};\n\ndescribe('middleware', () => {\n  test('custom middleware intercepts actions', () => {\n    const consoleSpy = jest.spyOn(console, 'log');\n\n    const store = configureStore({\n      reducer: { counter: counterSlice.reducer },\n      middleware: (getDefaultMiddleware) =>\n        getDefaultMiddleware().concat(customMiddleware),\n    });\n\n    store.dispatch(counterSlice.actions.increment());\n\n    expect(consoleSpy).toHaveBeenCalledWith('Increment detected');\n  });\n});\n\n// 8. Testing RTK Query\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';\n\nconst api = createApi({\n  baseQuery: fetchBaseQuery({ baseUrl: '/api' }),\n  endpoints: (builder) => ({\n    getUser: builder.query({\n      query: (id) => `users/${id}`,\n    }),\n  }),\n});\n\ndescribe('RTK Query', () => {\n  test('endpoint definition', () => {\n    expect(api.endpoints.getUser.query(1)).toBe('users/1');\n  });\n\n  test('should generate hooks', () => {\n    expect(typeof api.useGetUserQuery).toBe('function');\n  });\n});\n"})})]})}function l(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);