"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[9377],{6179:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>t,default:()=>h,frontMatter:()=>l,metadata:()=>o,toc:()=>a});var s=r(4848),i=r(8453);const l={title:"Operating Systems"},t=void 0,o={id:"College Revision/OperatingSystems",title:"Operating Systems",description:"1. Deadlock",source:"@site/docs/College Revision/OperatingSystems.mdx",sourceDirName:"College Revision",slug:"/College Revision/OperatingSystems",permalink:"/js.enigma/docs/College Revision/OperatingSystems",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/College Revision/OperatingSystems.mdx",tags:[],version:"current",frontMatter:{title:"Operating Systems"},sidebar:"tutorialSidebar",previous:{title:"Object-Oriented Programming (OOP)",permalink:"/js.enigma/docs/College Revision/OOPS"},next:{title:"Web Development",permalink:"/js.enigma/docs/category/web-development"}},c={},a=[{value:"1. Deadlock",id:"1-deadlock",level:2},{value:"2. Virtual Memory",id:"2-virtual-memory",level:2},{value:"Components:",id:"components",level:3},{value:"Page Replacement Algorithms:",id:"page-replacement-algorithms",level:3},{value:"Example:",id:"example",level:3},{value:"3. Semaphores",id:"3-semaphores",level:2},{value:"Types of Semaphores:",id:"types-of-semaphores",level:3},{value:"Operations:",id:"operations",level:3},{value:"Thread Synchronization",id:"thread-synchronization",level:2},{value:"Basic Concepts",id:"basic-concepts",level:3},{value:"Key Aspects",id:"key-aspects",level:3},{value:"Synchronization Mechanisms",id:"synchronization-mechanisms",level:3},{value:"Producer-Consumer Problem",id:"producer-consumer-problem",level:2},{value:"Problem Statement",id:"problem-statement",level:3},{value:"Components",id:"components-1",level:3},{value:"Implementation",id:"implementation",level:2},{value:"Common Scenarios",id:"common-scenarios",level:3},{value:"1. Single Producer-Single Consumer",id:"1-single-producer-single-consumer",level:4},{value:"2. Multiple Producers-Single Consumer",id:"2-multiple-producers-single-consumer",level:4},{value:"3. Single Producer-Multiple Consumers",id:"3-single-producer-multiple-consumers",level:4},{value:"4. Multiple Producers-Multiple Consumers",id:"4-multiple-producers-multiple-consumers",level:4},{value:"Implementation Considerations",id:"implementation-considerations",level:3},{value:"Example Implementation",id:"example-implementation",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Common Pitfalls",id:"common-pitfalls",level:2}];function d(e){const n={code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"1-deadlock",children:"1. Deadlock"}),"\n",(0,s.jsx)(n.p,{children:"Deadlock is a situation in operating systems where two or more processes are blocked forever because they are waiting for each other to release resources."}),"\n",(0,s.jsx)(n.p,{children:"Conditions for Deadlock:"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"1. Mutual Exclusion:"})," At least one resource must be held in a non-shareable mode (i.e., only one process can use the resource at any given time)."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"2. Hold and Wait:"})," A process is holding at least one resource and is waiting to acquire additional resources that are currently being held by other processes."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"3. No Preemption:"})," Resources cannot be preempted (taken away) from processes; they must be released voluntarily."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"4. Circular Wait:"})," A set of processes exists such that each process is waiting for a resource held by the next process in the set."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Deadlock Prevention:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Avoiding Circular Wait:"})," One strategy is to impose a total order on all resources and require that processes request resources in an increasing order of enumeration."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Preemptive Resource Allocation:"})," If a process is holding resources and cannot proceed, the system can preempt its resources and give them to other processes."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"2-virtual-memory",children:"2. Virtual Memory"}),"\n",(0,s.jsx)(n.p,{children:"Virtual memory allows programs to execute without requiring all of their data to be loaded into physical memory at once. It uses a combination of physical memory (RAM) and disk storage to create the illusion of a large, contiguous block of memory."}),"\n",(0,s.jsx)(n.h3,{id:"components",children:"Components:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Page Table"}),": Maps virtual memory addresses to physical addresses."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Paging"}),": The memory is divided into fixed-size blocks called pages. When a process accesses a page not currently in memory, a page fault occurs, and the operating system must load the required page from disk."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"page-replacement-algorithms",children:"Page Replacement Algorithms:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"LRU (Least Recently Used)"}),": Replaces the page that hasn\u2019t been used for the longest period."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"FIFO (First In, First Out)"}),": Replaces the oldest page in memory."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"example",children:"Example:"}),"\n",(0,s.jsx)(n.p,{children:"If your program accesses memory addresses outside the current physical memory allocation, the OS will trigger a page fault and load the required pages into memory."}),"\n",(0,s.jsx)(n.h2,{id:"3-semaphores",children:"3. Semaphores"}),"\n",(0,s.jsx)(n.p,{children:"A semaphore is a synchronization tool used to manage access to shared resources in a concurrent system. It maintains a count that is used to signal whether a resource is available or not."}),"\n",(0,s.jsx)(n.h3,{id:"types-of-semaphores",children:"Types of Semaphores:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Binary Semaphore (Mutex)"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["It has two values: ",(0,s.jsx)(n.code,{children:"0"})," or ",(0,s.jsx)(n.code,{children:"1"}),"."]}),"\n",(0,s.jsx)(n.li,{children:"Often used for mutual exclusion to ensure that only one process can access a critical section at a time."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Counting Semaphore"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"It can take any non-negative integer value."}),"\n",(0,s.jsx)(n.li,{children:"It is useful for managing a set of resources, such as managing access to a pool of database connections."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"operations",children:"Operations:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"P (Proberen)"}),": Decreases the semaphore's value. If the value is less than 0, the process will block until the value is greater than or equal to 0."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"V (Verhogen)"}),": Increases the semaphore\u2019s value. If there are processes waiting on the semaphore, one of them is unblocked."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example Code (Binary Semaphore):"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-JavaScript",children:'let semaphore = 1;  // Semaphore initialized to 1\r\n\r\nfunction P() {\r\n  if (semaphore > 0) {\r\n    semaphore--;  // Enter critical section\r\n  } else {\r\n    console.log("Waiting...");\r\n  }\r\n}\r\n\r\nfunction V() {\r\n  semaphore++;  // Exit critical section\r\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"thread-synchronization",children:"Thread Synchronization"}),"\n",(0,s.jsx)(n.h3,{id:"basic-concepts",children:"Basic Concepts"}),"\n",(0,s.jsx)(n.p,{children:"Thread synchronization ensures orderly access to shared resources in a multi-threaded environment."}),"\n",(0,s.jsx)(n.h3,{id:"key-aspects",children:"Key Aspects"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Resource Sharing"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Multiple threads accessing shared resources"}),"\n",(0,s.jsx)(n.li,{children:"Need for controlled access to prevent data corruption"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Critical Section"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Section of code accessing shared resources"}),"\n",(0,s.jsx)(n.li,{children:"Must be protected from concurrent access"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Race Conditions"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Occur when multiple threads access shared data simultaneously"}),"\n",(0,s.jsx)(n.li,{children:"Result depends on timing of thread execution"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"synchronization-mechanisms",children:"Synchronization Mechanisms"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Mutex"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Binary semaphore"}),"\n",(0,s.jsx)(n.li,{children:"Locks resource for exclusive access"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"class Mutex {\r\n    constructor() {\r\n        this.locked = false;\r\n    }\r\n    \r\n    acquire() {\r\n        while(this.locked) {\r\n            // wait\r\n        }\r\n        this.locked = true;\r\n    }\r\n    \r\n    release() {\r\n        this.locked = false;\r\n    }\r\n}\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Semaphores"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Counter for resource management"}),"\n",(0,s.jsx)(n.li,{children:"Controls access to finite resources"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"class Semaphore {\r\n    constructor(initial) {\r\n        this.value = initial;\r\n    }\r\n    \r\n    wait() {\r\n        while(this.value <= 0) {\r\n            // wait\r\n        }\r\n        this.value--;\r\n    }\r\n    \r\n    signal() {\r\n        this.value++;\r\n    }\r\n}\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"producer-consumer-problem",children:"Producer-Consumer Problem"}),"\n",(0,s.jsx)(n.h3,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Producers create data items and store in buffer"}),"\n",(0,s.jsx)(n.li,{children:"Consumers remove items from buffer"}),"\n",(0,s.jsx)(n.li,{children:"Need to synchronize access to shared buffer"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"components-1",children:"Components"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Buffer"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Shared data structure"}),"\n",(0,s.jsx)(n.li,{children:"Limited capacity in bounded version"}),"\n",(0,s.jsx)(n.li,{children:"Unlimited in unbounded version"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Producer"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Creates items"}),"\n",(0,s.jsx)(n.li,{children:"Adds to buffer when space available"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"async function produce(buffer, item) {\r\n    await buffer.notFull.wait();\r\n    await buffer.mutex.acquire();\r\n    buffer.add(item);\r\n    buffer.mutex.release();\r\n    buffer.notEmpty.signal();\r\n}\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Consumer"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Removes items"}),"\n",(0,s.jsx)(n.li,{children:"Waits when buffer empty"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"async function consume(buffer) {\r\n    await buffer.notEmpty.wait();\r\n    await buffer.mutex.acquire();\r\n    const item = buffer.remove();\r\n    buffer.mutex.release();\r\n    buffer.notFull.signal();\r\n    return item;\r\n}\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"implementation",children:"Implementation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-JavaScript",children:"// Mutex implementation\r\nclass Mutex {\r\n  constructor() {\r\n    this.locked = false;\r\n    this.waitingQueue = [];\r\n  }\r\n\r\n  async acquire() {\r\n    if (!this.locked) {\r\n      this.locked = true;\r\n      return;\r\n    }\r\n\r\n    return new Promise(resolve => {\r\n      this.waitingQueue.push(resolve);\r\n    });\r\n  }\r\n\r\n  release() {\r\n    if (this.waitingQueue.length > 0) {\r\n      const resolve = this.waitingQueue.shift();\r\n      resolve();\r\n    } else {\r\n      this.locked = false;\r\n    }\r\n  }\r\n}\r\n\r\n// Semaphore implementation\r\nclass Semaphore {\r\n  constructor(count) {\r\n    this.count = count;\r\n    this.waitingQueue = [];\r\n  }\r\n\r\n  async wait() {\r\n    if (this.count > 0) {\r\n      this.count--;\r\n      return;\r\n    }\r\n\r\n    return new Promise(resolve => {\r\n      this.waitingQueue.push(resolve);\r\n    });\r\n  }\r\n\r\n  signal() {\r\n    if (this.waitingQueue.length > 0) {\r\n      const resolve = this.waitingQueue.shift();\r\n      resolve();\r\n    } else {\r\n      this.count++;\r\n    }\r\n  }\r\n}\r\n\r\n// Bounded Buffer implementation\r\nclass BoundedBuffer {\r\n  constructor(capacity) {\r\n    this.buffer = [];\r\n    this.capacity = capacity;\r\n    this.mutex = new Mutex();\r\n    this.notFull = new Semaphore(capacity);\r\n    this.notEmpty = new Semaphore(0);\r\n  }\r\n\r\n  async produce(item) {\r\n    await this.notFull.wait();\r\n    await this.mutex.acquire();\r\n\r\n    this.buffer.push(item);\r\n    console.log(`Produced: ${item}. Buffer size: ${this.buffer.length}`);\r\n\r\n    this.mutex.release();\r\n    this.notEmpty.signal();\r\n  }\r\n\r\n  async consume() {\r\n    await this.notEmpty.wait();\r\n    await this.mutex.acquire();\r\n\r\n    const item = this.buffer.shift();\r\n    console.log(`Consumed: ${item}. Buffer size: ${this.buffer.length}`);\r\n\r\n    this.mutex.release();\r\n    this.notFull.signal();\r\n    return item;\r\n  }\r\n\r\n  getBufferState() {\r\n    return [...this.buffer];\r\n  }\r\n}\r\n\r\n// Helper function to delay execution\r\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms));\r\n\r\n// Producer function\r\nasync function producer(buffer, id, items) {\r\n  for (const item of items) {\r\n    try {\r\n      await buffer.produce(`P${id}-${item}`);\r\n      await delay(Math.random() * 1000); // Random delay between 0-1000ms\r\n    } catch (error) {\r\n      console.error(`Producer ${id} error:`, error);\r\n    }\r\n  }\r\n  console.log(`Producer ${id} finished`);\r\n}\r\n\r\n// Consumer function\r\nasync function consumer(buffer, id, count) {\r\n  for (let i = 0; i < count; i++) {\r\n    try {\r\n      await buffer.consume();\r\n      await delay(Math.random() * 2000); // Random delay between 0-2000ms\r\n    } catch (error) {\r\n      console.error(`Consumer ${id} error:`, error);\r\n    }\r\n  }\r\n  console.log(`Consumer ${id} finished`);\r\n}\r\n\r\n// Main execution\r\nasync function main() {\r\n  const buffer = new BoundedBuffer(5); // Buffer capacity of 5\r\n\r\n  // Create multiple producers and consumers\r\n  const producers = [\r\n    producer(buffer, 1, [1, 2, 3, 4, 5]),\r\n    producer(buffer, 2, [6, 7, 8, 9, 10])\r\n  ];\r\n\r\n  const consumers = [\r\n    consumer(buffer, 1, 5),\r\n    consumer(buffer, 2, 5)\r\n  ];\r\n\r\n  // Wait for all producers and consumers to finish\r\n  await Promise.all([...producers, ...consumers]);\r\n  console.log('All producers and consumers finished');\r\n}\r\n\r\n// Run the program\r\nmain().catch(console.error);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"common-scenarios",children:"Common Scenarios"}),"\n",(0,s.jsx)(n.h4,{id:"1-single-producer-single-consumer",children:"1. Single Producer-Single Consumer"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Simplest case"}),"\n",(0,s.jsxs)(n.li,{children:["Needs:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"One mutex for buffer access"}),"\n",(0,s.jsx)(n.li,{children:"Two semaphores (empty, full)"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"2-multiple-producers-single-consumer",children:"2. Multiple Producers-Single Consumer"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Multiple threads adding items"}),"\n",(0,s.jsxs)(n.li,{children:["Needs:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Mutex for producer synchronization"}),"\n",(0,s.jsx)(n.li,{children:"Buffer bounds checking"}),"\n",(0,s.jsx)(n.li,{children:"Consumer flow control"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"3-single-producer-multiple-consumers",children:"3. Single Producer-Multiple Consumers"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Multiple threads removing items"}),"\n",(0,s.jsxs)(n.li,{children:["Needs:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Mutex for consumer synchronization"}),"\n",(0,s.jsx)(n.li,{children:"Empty buffer handling"}),"\n",(0,s.jsx)(n.li,{children:"Producer flow control"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"4-multiple-producers-multiple-consumers",children:"4. Multiple Producers-Multiple Consumers"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Most complex scenario"}),"\n",(0,s.jsxs)(n.li,{children:["Needs:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Full synchronization mechanism"}),"\n",(0,s.jsx)(n.li,{children:"Race condition prevention"}),"\n",(0,s.jsx)(n.li,{children:"Fair access policies"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"implementation-considerations",children:"Implementation Considerations"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Buffer Design"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Choose appropriate data structure"}),"\n",(0,s.jsx)(n.li,{children:"Consider memory constraints"}),"\n",(0,s.jsx)(n.li,{children:"Handle overflow/underflow"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Synchronization"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Prevent deadlocks"}),"\n",(0,s.jsx)(n.li,{children:"Ensure thread safety"}),"\n",(0,s.jsx)(n.li,{children:"Maintain data consistency"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Performance"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Balance throughput and latency"}),"\n",(0,s.jsx)(n.li,{children:"Minimize blocking time"}),"\n",(0,s.jsx)(n.li,{children:"Optimize resource usage"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"example-implementation",children:"Example Implementation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"class BoundedBuffer {\r\n    constructor(size) {\r\n        this.buffer = [];\r\n        this.size = size;\r\n        this.mutex = new Mutex();\r\n        this.notFull = new Semaphore(size);\r\n        this.notEmpty = new Semaphore(0);\r\n    }\r\n\r\n    async produce(item) {\r\n        await this.notFull.wait();\r\n        await this.mutex.acquire();\r\n        \r\n        this.buffer.push(item);\r\n        \r\n        this.mutex.release();\r\n        this.notEmpty.signal();\r\n    }\r\n\r\n    async consume() {\r\n        await this.notEmpty.wait();\r\n        await this.mutex.acquire();\r\n        \r\n        const item = this.buffer.shift();\r\n        \r\n        this.mutex.release();\r\n        this.notFull.signal();\r\n        \r\n        return item;\r\n    }\r\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Always Release Resources"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Use try-finally blocks"}),"\n",(0,s.jsx)(n.li,{children:"Prevent resource leaks"}),"\n",(0,s.jsx)(n.li,{children:"Handle errors properly"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Avoid Nested Locks"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Prevent deadlocks"}),"\n",(0,s.jsx)(n.li,{children:"Maintain simple locking hierarchy"}),"\n",(0,s.jsx)(n.li,{children:"Release locks in reverse order"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Use Appropriate Mechanisms"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Choose right synchronization tool"}),"\n",(0,s.jsx)(n.li,{children:"Consider problem requirements"}),"\n",(0,s.jsx)(n.li,{children:"Balance complexity and needs"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Error Handling"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Handle timeout scenarios"}),"\n",(0,s.jsx)(n.li,{children:"Implement recovery mechanisms"}),"\n",(0,s.jsx)(n.li,{children:"Log synchronization issues"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"common-pitfalls",children:"Common Pitfalls"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Deadlock"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Circular resource waiting"}),"\n",(0,s.jsx)(n.li,{children:"Improper lock ordering"}),"\n",(0,s.jsx)(n.li,{children:"Resource starvation"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Race Conditions"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Unsynchronized access"}),"\n",(0,s.jsx)(n.li,{children:"Timing-dependent bugs"}),"\n",(0,s.jsx)(n.li,{children:"Inconsistent state"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Priority Inversion"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Lower priority task holds resource"}),"\n",(0,s.jsx)(n.li,{children:"Higher priority task blocked"}),"\n",(0,s.jsx)(n.li,{children:"System performance impact"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Buffer Problems"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Overflow/underflow"}),"\n",(0,s.jsx)(n.li,{children:"Memory leaks"}),"\n",(0,s.jsx)(n.li,{children:"Performance bottlenecks****"}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>t,x:()=>o});var s=r(6540);const i={},l=s.createContext(i);function t(e){const n=s.useContext(l);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),s.createElement(l.Provider,{value:n},e.children)}}}]);