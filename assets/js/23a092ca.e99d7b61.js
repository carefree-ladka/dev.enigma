"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[14844],{4884:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>o,frontMatter:()=>a,metadata:()=>r,toc:()=>h});var i=t(74848),s=t(28453);const a={},c="LRU Cache Cheatsheet (JavaScript)",r={id:"Interview Prep 2026/LRU Cache Cheatsheet (JavaScript)",title:"LRU Cache Cheatsheet (JavaScript)",description:"Table of Contents",source:"@site/docs/08-Interview Prep 2026/LRU Cache Cheatsheet (JavaScript).mdx",sourceDirName:"08-Interview Prep 2026",slug:"/Interview Prep 2026/LRU Cache Cheatsheet (JavaScript)",permalink:"/docs/Interview Prep 2026/LRU Cache Cheatsheet (JavaScript)",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/08-Interview Prep 2026/LRU Cache Cheatsheet (JavaScript).mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"JavaScript Web API Dimensions Guide",permalink:"/docs/Interview Prep 2026/JavaScript Web API Dimensions Guide"},next:{title:"Learn Web Accessibility",permalink:"/docs/Interview Prep 2026/Learn Web Accessibility"}},l={},h=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Theory &amp; Concepts",id:"theory--concepts",level:2},{value:"What is LRU Cache?",id:"what-is-lru-cache",level:3},{value:"Key Properties",id:"key-properties",level:3},{value:"Operation Flow",id:"operation-flow",level:3},{value:"Why LRU Cache?",id:"why-lru-cache",level:2},{value:"Problem It Solves",id:"problem-it-solves",level:3},{value:"Real-World Examples",id:"real-world-examples",level:3},{value:"Data Structures Used",id:"data-structures-used",level:2},{value:"Option 1: Map + Doubly Linked List (Classic)",id:"option-1-map--doubly-linked-list-classic",level:3},{value:"Option 2: ES6 Map Only",id:"option-2-es6-map-only",level:3},{value:"Implementation: Map + Doubly Linked List",id:"implementation-map--doubly-linked-list",level:2},{value:"Full Implementation",id:"full-implementation",level:3},{value:"Usage Example",id:"usage-example",level:3},{value:"Implementation: Map Only (ES6 Ordered Map)",id:"implementation-map-only-es6-ordered-map",level:2},{value:"Simpler Implementation",id:"simpler-implementation",level:3},{value:"Usage Example",id:"usage-example-1",level:3},{value:"Time &amp; Space Complexity",id:"time--space-complexity",level:2},{value:"Map + Doubly Linked List",id:"map--doubly-linked-list",level:3},{value:"Map Only",id:"map-only",level:3},{value:"Use Cases",id:"use-cases",level:2},{value:"1. Database Query Cache",id:"1-database-query-cache",level:3},{value:"2. API Response Cache",id:"2-api-response-cache",level:3},{value:"3. Memoization",id:"3-memoization",level:3},{value:"Interview Tips",id:"interview-tips",level:2},{value:"Common Questions",id:"common-questions",level:3},{value:"What Interviewers Look For",id:"what-interviewers-look-for",level:3},{value:"Edge Cases to Consider",id:"edge-cases-to-consider",level:3},{value:"Common Variations",id:"common-variations",level:2},{value:"LRU with Expiration Time",id:"lru-with-expiration-time",level:3},{value:"LRU with Size Limit (Bytes)",id:"lru-with-size-limit-bytes",level:3},{value:"LFU Cache (Alternative Eviction Policy)",id:"lfu-cache-alternative-eviction-policy",level:3},{value:"Quick Reference",id:"quick-reference",level:2},{value:"When to Use Which Implementation?",id:"when-to-use-which-implementation",level:3},{value:"Cheat Sheet Summary",id:"cheat-sheet-summary",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"lru-cache-cheatsheet-javascript",children:"LRU Cache Cheatsheet (JavaScript)"})}),"\n",(0,i.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#theory--concepts",children:"Theory & Concepts"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#why-lru-cache",children:"Why LRU Cache?"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#data-structures-used",children:"Data Structures Used"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#implementation-map--doubly-linked-list",children:"Implementation: Map + Doubly Linked List"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#implementation-map-only-es6-ordered-map",children:"Implementation: Map Only (ES6 Ordered Map)"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#time--space-complexity",children:"Time & Space Complexity"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#use-cases",children:"Use Cases"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#interview-tips",children:"Interview Tips"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#common-variations",children:"Common Variations"})}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"theory--concepts",children:"Theory & Concepts"}),"\n",(0,i.jsx)(n.h3,{id:"what-is-lru-cache",children:"What is LRU Cache?"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"LRU (Least Recently Used)"})," is a cache eviction policy that removes the least recently accessed item when the cache reaches its capacity."]}),"\n",(0,i.jsx)(n.h3,{id:"key-properties",children:"Key Properties"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Fixed capacity"}),": Cache has a maximum size"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Fast access"}),": O(1) read and write operations"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Eviction policy"}),": When full, remove the least recently used item"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Recently used tracking"}),": Both reads and writes update recency"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"operation-flow",children:"Operation Flow"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'Cache Operations:\n1. GET(key) \u2192 Returns value, moves item to "most recent"\n2. PUT(key, value) \u2192 Adds/updates item, moves to "most recent"\n                   \u2192 If full, removes "least recent" item first\n\nAccess Order: [Least Recent] \u2190 ... \u2190 [Most Recent]\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"why-lru-cache",children:"Why LRU Cache?"}),"\n",(0,i.jsx)(n.h3,{id:"problem-it-solves",children:"Problem It Solves"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Memory constraints"}),": Limited storage for frequently accessed data"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Performance optimization"}),": Reduces expensive operations (DB queries, API calls)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Predictive efficiency"}),": Recently used items are likely to be used again"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"real-world-examples",children:"Real-World Examples"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Browser cache (web pages, images)"}),"\n",(0,i.jsx)(n.li,{children:"Database query result caching"}),"\n",(0,i.jsx)(n.li,{children:"Operating system page replacement"}),"\n",(0,i.jsx)(n.li,{children:"CDN content caching"}),"\n",(0,i.jsx)(n.li,{children:"Application-level data caching"}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"data-structures-used",children:"Data Structures Used"}),"\n",(0,i.jsx)(n.h3,{id:"option-1-map--doubly-linked-list-classic",children:"Option 1: Map + Doubly Linked List (Classic)"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Map"}),": O(1) key lookup\n",(0,i.jsx)(n.strong,{children:"Doubly Linked List"}),": O(1) insertion/deletion at both ends"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Map: { key \u2192 Node }\nDLL: [Head] \u2194 [Node] \u2194 [Node] \u2194 [Tail]\n     (LRU)                      (MRU)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"option-2-es6-map-only",children:"Option 2: ES6 Map Only"}),"\n",(0,i.jsx)(n.p,{children:"JavaScript Maps maintain insertion order, allowing simpler implementation."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Map: { key1: val1, key2: val2, ... }\n     (oldest)              (newest)\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"implementation-map--doubly-linked-list",children:"Implementation: Map + Doubly Linked List"}),"\n",(0,i.jsx)(n.h3,{id:"full-implementation",children:"Full Implementation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"class Node {\n  constructor(key, value) {\n    this.key = key;\n    this.value = value;\n    this.prev = null;\n    this.next = null;\n  }\n}\n\nclass LRUCache {\n  constructor(capacity) {\n    this.capacity = capacity;\n    this.cache = new Map(); // key \u2192 Node\n\n    // Dummy head and tail for easier list manipulation\n    this.head = new Node(0, 0); // LRU side\n    this.tail = new Node(0, 0); // MRU side\n    this.head.next = this.tail;\n    this.tail.prev = this.head;\n  }\n\n  get(key) {\n    if (!this.cache.has(key)) {\n      return -1;\n    }\n\n    const node = this.cache.get(key);\n    this.removeNode(node);\n    this.addToTail(node);\n\n    return node.value;\n  }\n\n  put(key, value) {\n    // Update existing key\n    if (this.cache.has(key)) {\n      const node = this.cache.get(key);\n      node.value = value;\n      this.removeNode(node);\n      this.addToTail(node);\n      return;\n    }\n\n    // Add new key\n    const newNode = new Node(key, value);\n    this.cache.set(key, newNode);\n    this.addToTail(newNode);\n\n    // Check capacity and evict if needed\n    if (this.cache.size > this.capacity) {\n      const lruNode = this.head.next;\n      this.removeNode(lruNode);\n      this.cache.delete(lruNode.key);\n    }\n  }\n\n  // Helper: Remove node from list\n  removeNode(node) {\n    const prevNode = node.prev;\n    const nextNode = node.next;\n    prevNode.next = nextNode;\n    nextNode.prev = prevNode;\n  }\n\n  // Helper: Add node to tail (most recent)\n  addToTail(node) {\n    const prevNode = this.tail.prev;\n    prevNode.next = node;\n    node.prev = prevNode;\n    node.next = this.tail;\n    this.tail.prev = node;\n  }\n\n  // Optional: Display current cache state\n  display() {\n    let current = this.head.next;\n    const items = [];\n    while (current !== this.tail) {\n      items.push(`${current.key}:${current.value}`);\n      current = current.next;\n    }\n    console.log('[LRU] ' + items.join(' \u2194 ') + ' [MRU]');\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"usage-example",children:"Usage Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"const cache = new LRUCache(3);\n\ncache.put(1, 'A');  // Cache: [1:A]\ncache.put(2, 'B');  // Cache: [1:A, 2:B]\ncache.put(3, 'C');  // Cache: [1:A, 2:B, 3:C]\n\ncache.get(1);       // Returns 'A', Cache: [2:B, 3:C, 1:A]\n\ncache.put(4, 'D');  // Evicts key 2, Cache: [3:C, 1:A, 4:D]\n\ncache.get(2);       // Returns -1 (not found)\n\ncache.put(5, 'E');  // Evicts key 3, Cache: [1:A, 4:D, 5:E]\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"implementation-map-only-es6-ordered-map",children:"Implementation: Map Only (ES6 Ordered Map)"}),"\n",(0,i.jsx)(n.h3,{id:"simpler-implementation",children:"Simpler Implementation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"class LRUCache {\n  constructor(capacity) {\n    this.capacity = capacity;\n    this.cache = new Map();\n  }\n\n  get(key) {\n    if (!this.cache.has(key)) {\n      return -1;\n    }\n\n    // Remove and re-insert to move to end (most recent)\n    const value = this.cache.get(key);\n    this.cache.delete(key);\n    this.cache.set(key, value);\n\n    return value;\n  }\n\n  put(key, value) {\n    // If key exists, delete it first\n    if (this.cache.has(key)) {\n      this.cache.delete(key);\n    }\n\n    // Add to end (most recent)\n    this.cache.set(key, value);\n\n    // Evict least recent if over capacity\n    if (this.cache.size > this.capacity) {\n      const firstKey = this.cache.keys().next().value;\n      this.cache.delete(firstKey);\n    }\n  }\n\n  // Optional: Display cache\n  display() {\n    console.log('[LRU]', Array.from(this.cache.entries()), '[MRU]');\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"usage-example-1",children:"Usage Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"const cache = new LRUCache(2);\n\ncache.put(1, 1);    // Cache: {1=1}\ncache.put(2, 2);    // Cache: {1=1, 2=2}\ncache.get(1);       // Returns 1, Cache: {2=2, 1=1}\ncache.put(3, 3);    // Evicts 2, Cache: {1=1, 3=3}\ncache.get(2);       // Returns -1 (not found)\ncache.put(4, 4);    // Evicts 1, Cache: {3=3, 4=4}\ncache.get(1);       // Returns -1 (not found)\ncache.get(3);       // Returns 3, Cache: {4=4, 3=3}\ncache.get(4);       // Returns 4, Cache: {3=3, 4=4}\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"time--space-complexity",children:"Time & Space Complexity"}),"\n",(0,i.jsx)(n.h3,{id:"map--doubly-linked-list",children:"Map + Doubly Linked List"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Operation"}),(0,i.jsx)(n.th,{children:"Time Complexity"}),(0,i.jsx)(n.th,{children:"Explanation"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"get(key)"})}),(0,i.jsx)(n.td,{children:"O(1)"}),(0,i.jsx)(n.td,{children:"Map lookup + DLL reordering"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"put(key, value)"})}),(0,i.jsx)(n.td,{children:"O(1)"}),(0,i.jsx)(n.td,{children:"Map insertion + DLL operations"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Space"}),(0,i.jsx)(n.td,{children:"O(capacity)"}),(0,i.jsx)(n.td,{children:"Map + DLL nodes"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"map-only",children:"Map Only"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Operation"}),(0,i.jsx)(n.th,{children:"Time Complexity"}),(0,i.jsx)(n.th,{children:"Explanation"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"get(key)"})}),(0,i.jsx)(n.td,{children:"O(1) amortized"}),(0,i.jsx)(n.td,{children:"Map delete + set operations"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"put(key, value)"})}),(0,i.jsx)(n.td,{children:"O(1) amortized"}),(0,i.jsx)(n.td,{children:"Map delete + set operations"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Space"}),(0,i.jsx)(n.td,{children:"O(capacity)"}),(0,i.jsx)(n.td,{children:"Map storage only"})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Note"}),": Map-only approach is simpler but has slightly more overhead per operation due to delete/re-insert."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"use-cases",children:"Use Cases"}),"\n",(0,i.jsx)(n.h3,{id:"1-database-query-cache",children:"1. Database Query Cache"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"class DatabaseCache {\n  constructor(capacity = 100) {\n    this.cache = new LRUCache(capacity);\n  }\n\n  async query(sql) {\n    const cached = this.cache.get(sql);\n    if (cached !== -1) {\n      console.log('Cache hit!');\n      return cached;\n    }\n\n    console.log('Cache miss, querying database...');\n    const result = await database.execute(sql);\n    this.cache.put(sql, result);\n    return result;\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-api-response-cache",children:"2. API Response Cache"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"class APICache {\n  constructor(capacity = 50) {\n    this.cache = new LRUCache(capacity);\n  }\n\n  async fetchUser(userId) {\n    const cached = this.cache.get(userId);\n    if (cached !== -1) return cached;\n\n    const userData = await fetch(`/api/users/${userId}`).then(r => r.json());\n    this.cache.put(userId, userData);\n    return userData;\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"3-memoization",children:"3. Memoization"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"function memoize(fn, capacity = 100) {\n  const cache = new LRUCache(capacity);\n\n  return function(...args) {\n    const key = JSON.stringify(args);\n    const cached = cache.get(key);\n\n    if (cached !== -1) return cached;\n\n    const result = fn.apply(this, args);\n    cache.put(key, result);\n    return result;\n  };\n}\n\n// Usage\nconst expensiveFunction = memoize((n) => {\n  console.log('Computing...');\n  return n * n;\n}, 10);\n\nexpensiveFunction(5); // Computing... \u2192 25\nexpensiveFunction(5); // \u2192 25 (cached)\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"interview-tips",children:"Interview Tips"}),"\n",(0,i.jsx)(n.h3,{id:"common-questions",children:"Common Questions"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:'"Why not use a regular object or Map without eviction?"'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Unbounded growth leads to memory issues"}),"\n",(0,i.jsx)(n.li,{children:"LRU provides automatic memory management"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:'"Why doubly linked list instead of array?"'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Array deletion is O(n)"}),"\n",(0,i.jsx)(n.li,{children:"DLL allows O(1) removal from middle"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:'"Can you implement LFU instead?"'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"LFU (Least Frequently Used) tracks access count"}),"\n",(0,i.jsx)(n.li,{children:"More complex: requires frequency tracking + min-heap"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:'"How would you make it thread-safe?"'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Add locking mechanisms (mutex/semaphore)"}),"\n",(0,i.jsx)(n.li,{children:"Consider ConcurrentHashMap in other languages"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"what-interviewers-look-for",children:"What Interviewers Look For"}),"\n",(0,i.jsx)(n.p,{children:"\u2705 Understanding of both data structures\n\u2705 Clean code with helper methods\n\u2705 Edge case handling (capacity = 1, updating existing keys)\n\u2705 Ability to explain trade-offs\n\u2705 Time/space complexity analysis"}),"\n",(0,i.jsx)(n.h3,{id:"edge-cases-to-consider",children:"Edge Cases to Consider"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// Capacity = 1\nconst cache = new LRUCache(1);\ncache.put(1, 1);\ncache.put(2, 2); // Should evict 1\n\n// Update existing key\ncache.put(1, 'A');\ncache.put(1, 'B'); // Should update, not add new\n\n// Get non-existent key\ncache.get(999); // Should return -1 or null\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"common-variations",children:"Common Variations"}),"\n",(0,i.jsx)(n.h3,{id:"lru-with-expiration-time",children:"LRU with Expiration Time"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"class LRUCacheWithTTL {\n  constructor(capacity, ttl = 60000) { // 60s default\n    this.capacity = capacity;\n    this.ttl = ttl;\n    this.cache = new Map();\n  }\n\n  get(key) {\n    if (!this.cache.has(key)) return -1;\n\n    const { value, timestamp } = this.cache.get(key);\n\n    // Check if expired\n    if (Date.now() - timestamp > this.ttl) {\n      this.cache.delete(key);\n      return -1;\n    }\n\n    // Refresh timestamp and move to end\n    this.cache.delete(key);\n    this.cache.set(key, { value, timestamp: Date.now() });\n\n    return value;\n  }\n\n  put(key, value) {\n    if (this.cache.has(key)) {\n      this.cache.delete(key);\n    }\n\n    this.cache.set(key, { value, timestamp: Date.now() });\n\n    if (this.cache.size > this.capacity) {\n      const firstKey = this.cache.keys().next().value;\n      this.cache.delete(firstKey);\n    }\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"lru-with-size-limit-bytes",children:"LRU with Size Limit (Bytes)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"class SizeLimitedLRUCache {\n  constructor(maxBytes) {\n    this.maxBytes = maxBytes;\n    this.currentBytes = 0;\n    this.cache = new Map();\n  }\n\n  getSize(value) {\n    return JSON.stringify(value).length;\n  }\n\n  put(key, value) {\n    const size = this.getSize(value);\n\n    if (this.cache.has(key)) {\n      const oldSize = this.getSize(this.cache.get(key));\n      this.currentBytes -= oldSize;\n      this.cache.delete(key);\n    }\n\n    // Evict until there's space\n    while (this.currentBytes + size > this.maxBytes && this.cache.size > 0) {\n      const [firstKey, firstValue] = this.cache.entries().next().value;\n      this.currentBytes -= this.getSize(firstValue);\n      this.cache.delete(firstKey);\n    }\n\n    if (size <= this.maxBytes) {\n      this.cache.set(key, value);\n      this.currentBytes += size;\n    }\n  }\n\n  get(key) {\n    if (!this.cache.has(key)) return -1;\n\n    const value = this.cache.get(key);\n    this.cache.delete(key);\n    this.cache.set(key, value);\n\n    return value;\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"lfu-cache-alternative-eviction-policy",children:"LFU Cache (Alternative Eviction Policy)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"class LFUCache {\n  constructor(capacity) {\n    this.capacity = capacity;\n    this.cache = new Map(); // key \u2192 { value, freq }\n    this.freqMap = new Map(); // freq \u2192 Set of keys\n    this.minFreq = 0;\n  }\n\n  get(key) {\n    if (!this.cache.has(key)) return -1;\n\n    const { value, freq } = this.cache.get(key);\n\n    // Update frequency\n    this.freqMap.get(freq).delete(key);\n    if (this.freqMap.get(freq).size === 0 && freq === this.minFreq) {\n      this.minFreq++;\n    }\n\n    const newFreq = freq + 1;\n    if (!this.freqMap.has(newFreq)) {\n      this.freqMap.set(newFreq, new Set());\n    }\n    this.freqMap.get(newFreq).add(key);\n\n    this.cache.set(key, { value, freq: newFreq });\n\n    return value;\n  }\n\n  put(key, value) {\n    if (this.capacity === 0) return;\n\n    if (this.cache.has(key)) {\n      const { freq } = this.cache.get(key);\n      this.cache.set(key, { value, freq });\n      this.get(key); // Update frequency\n      return;\n    }\n\n    if (this.cache.size >= this.capacity) {\n      // Evict least frequent\n      const keyToDelete = this.freqMap.get(this.minFreq).values().next().value;\n      this.freqMap.get(this.minFreq).delete(keyToDelete);\n      this.cache.delete(keyToDelete);\n    }\n\n    this.cache.set(key, { value, freq: 1 });\n    if (!this.freqMap.has(1)) {\n      this.freqMap.set(1, new Set());\n    }\n    this.freqMap.get(1).add(key);\n    this.minFreq = 1;\n  }\n}\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"quick-reference",children:"Quick Reference"}),"\n",(0,i.jsx)(n.h3,{id:"when-to-use-which-implementation",children:"When to Use Which Implementation?"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Implementation"}),(0,i.jsx)(n.th,{children:"Best For"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Map + DLL"})}),(0,i.jsx)(n.td,{children:"Technical interviews, learning fundamentals"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Map Only"})}),(0,i.jsx)(n.td,{children:"Production code, simpler maintenance"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"With TTL"})}),(0,i.jsx)(n.td,{children:"Session storage, temporary caching"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Size-based"})}),(0,i.jsx)(n.td,{children:"Memory-constrained environments"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"LFU"})}),(0,i.jsx)(n.td,{children:"Access patterns where frequency matters more"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"cheat-sheet-summary",children:"Cheat Sheet Summary"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// Map + DLL (Classic Interview Solution)\nclass LRUCache {\n  constructor(capacity) { /* ... */ }\n  get(key) { /* Map lookup + move to tail */ }\n  put(key, value) { /* Add to tail + evict head if needed */ }\n  removeNode(node) { /* Update prev/next pointers */ }\n  addToTail(node) { /* Insert before tail */ }\n}\n\n// Map Only (Modern ES6 Solution)\nclass LRUCache {\n  constructor(capacity) { this.cache = new Map(); }\n  get(key) { delete + set to move to end }\n  put(key, value) { set + evict first key if needed }\n}\n\n// Key Insight: Map maintains insertion order!\n"})})]})}function o(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>r});var i=t(96540);const s={},a=i.createContext(s);function c(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);