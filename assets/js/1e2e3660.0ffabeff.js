"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[1083],{1802:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>d,contentTitle:()=>s,default:()=>c,frontMatter:()=>a,metadata:()=>o,toc:()=>l});var t=i(74848),r=i(28453);const a={},s="Graph",o={id:"DSA/DSA with Java/Graph Patterns",title:"Graph",description:"This comprehensive guide covers fundamental to advanced graph algorithms with Java implementations, organized into clear patterns for efficient learning and interview preparation.",source:"@site/docs/DSA/DSA with Java/Graph Patterns.mdx",sourceDirName:"DSA/DSA with Java",slug:"/DSA/DSA with Java/Graph Patterns",permalink:"/dev.enigma/docs/DSA/DSA with Java/Graph Patterns",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with Java/Graph Patterns.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Dynamic Programming",permalink:"/dev.enigma/docs/DSA/DSA with Java/Dynamic Programming"},next:{title:"Grid-Based Graph",permalink:"/dev.enigma/docs/DSA/DSA with Java/Grid Based Graph Patterns"}},d={},l=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Graph Representation",id:"graph-representation",level:2},{value:"Pattern 1: DFS Traversal",id:"pattern-1-dfs-traversal",level:2},{value:"1.1 Basic DFS (Recursive)",id:"11-basic-dfs-recursive",level:3},{value:"1.2 DFS (Iterative with Stack)",id:"12-dfs-iterative-with-stack",level:3},{value:"1.3 DFS with Path Tracking",id:"13-dfs-with-path-tracking",level:3},{value:"1.4 Count All Paths",id:"14-count-all-paths",level:3},{value:"1.5 Number of Islands (DFS Grid)",id:"15-number-of-islands-dfs-grid",level:3},{value:"Pattern 2: BFS Traversal",id:"pattern-2-bfs-traversal",level:2},{value:"2.1 Basic BFS",id:"21-basic-bfs",level:3},{value:"2.2 BFS Level Order",id:"22-bfs-level-order",level:3},{value:"2.3 Shortest Path (Unweighted)",id:"23-shortest-path-unweighted",level:3},{value:"2.4 Shortest Path with Parent Tracking",id:"24-shortest-path-with-parent-tracking",level:3},{value:"2.5 Word Ladder (BFS Application)",id:"25-word-ladder-bfs-application",level:3},{value:"Pattern 3: Connected Components",id:"pattern-3-connected-components",level:2},{value:"3.1 Count Connected Components (DFS)",id:"31-count-connected-components-dfs",level:3},{value:"3.2 Count Components (Union-Find)",id:"32-count-components-union-find",level:3},{value:"Pattern 4: Cycle Detection",id:"pattern-4-cycle-detection",level:2},{value:"4.1 Cycle Detection (Undirected Graph - DFS)",id:"41-cycle-detection-undirected-graph---dfs",level:3},{value:"4.2 Cycle Detection (Directed Graph - DFS)",id:"42-cycle-detection-directed-graph---dfs",level:3},{value:"4.3 Cycle Detection (Union-Find)",id:"43-cycle-detection-union-find",level:3},{value:"Pattern 5: Topological Sort",id:"pattern-5-topological-sort",level:2},{value:"5.1 Topological Sort (DFS)",id:"51-topological-sort-dfs",level:3},{value:"5.2 Topological Sort (Kahn&#39;s Algorithm - BFS)",id:"52-topological-sort-kahns-algorithm---bfs",level:3},{value:"5.3 Course Schedule",id:"53-course-schedule",level:3},{value:"Pattern 6: Shortest Path",id:"pattern-6-shortest-path",level:2},{value:"6.1 Dijkstra&#39;s Algorithm",id:"61-dijkstras-algorithm",level:3},{value:"6.2 Bellman-Ford Algorithm",id:"62-bellman-ford-algorithm",level:3},{value:"6.3 Floyd-Warshall Algorithm",id:"63-floyd-warshall-algorithm",level:3},{value:"Pattern 7: Minimum Spanning Tree",id:"pattern-7-minimum-spanning-tree",level:2},{value:"7.1 Kruskal&#39;s Algorithm",id:"71-kruskals-algorithm",level:3},{value:"7.2 Prim&#39;s Algorithm",id:"72-prims-algorithm",level:3},{value:"Pattern 8: Union Find (Disjoint Set)",id:"pattern-8-union-find-disjoint-set",level:2},{value:"8.1 Optimized Union-Find Implementation",id:"81-optimized-union-find-implementation",level:3},{value:"8.2 Redundant Connection",id:"82-redundant-connection",level:3},{value:"8.3 Number of Provinces",id:"83-number-of-provinces",level:3},{value:"Pattern 9: Bipartite Graphs",id:"pattern-9-bipartite-graphs",level:2},{value:"9.1 Check if Bipartite (BFS)",id:"91-check-if-bipartite-bfs",level:3},{value:"9.2 Check if Bipartite (DFS)",id:"92-check-if-bipartite-dfs",level:3},{value:"9.3 Maximum Bipartite Matching",id:"93-maximum-bipartite-matching",level:3},{value:"Pattern 10: Strongly Connected Components",id:"pattern-10-strongly-connected-components",level:2},{value:"10.1 Kosaraju&#39;s Algorithm",id:"101-kosarajus-algorithm",level:3},{value:"10.2 Tarjan&#39;s Algorithm",id:"102-tarjans-algorithm",level:3},{value:"Pattern 11: Graph Coloring",id:"pattern-11-graph-coloring",level:2},{value:"11.1 Graph Coloring (Greedy)",id:"111-graph-coloring-greedy",level:3},{value:"11.2 Chromatic Number (Min Colors)",id:"112-chromatic-number-min-colors",level:3},{value:"11.3 Graph Coloring with K Colors",id:"113-graph-coloring-with-k-colors",level:3},{value:"Pattern 12: Advanced Problems",id:"pattern-12-advanced-problems",level:2},{value:"12.1 Bridge Finding (Tarjan)",id:"121-bridge-finding-tarjan",level:3},{value:"12.2 Articulation Points",id:"122-articulation-points",level:3},{value:"12.3 Eulerian Path/Circuit",id:"123-eulerian-pathcircuit",level:3},{value:"12.4 Traveling Salesman Problem (DP + Bitmask)",id:"124-traveling-salesman-problem-dp--bitmask",level:3},{value:"Pattern 13: Graph Neural Networks &amp; Machine Learning",id:"pattern-13-graph-neural-networks--machine-learning",level:2},{value:"13.1 Node2Vec Implementation[^1_3]",id:"131-node2vec-implementation1_3",level:3},{value:"13.2 Graph Embedding with Random Walks",id:"132-graph-embedding-with-random-walks",level:3},{value:"Pattern 14: Dynamic Graph Algorithms",id:"pattern-14-dynamic-graph-algorithms",level:2},{value:"14.1 Dynamic Connectivity[^1_3]",id:"141-dynamic-connectivity1_3",level:3},{value:"14.2 Dynamic PageRank[^1_3]",id:"142-dynamic-pagerank1_3",level:3},{value:"Pattern 15: Network Flow &amp; Matching",id:"pattern-15-network-flow--matching",level:2},{value:"15.1 Maximum Flow (Ford-Fulkerson with Edmonds-Karp)",id:"151-maximum-flow-ford-fulkerson-with-edmonds-karp",level:3},{value:"15.2 Hungarian Algorithm for Assignment Problem",id:"152-hungarian-algorithm-for-assignment-problem",level:3},{value:"Time Complexity Cheat Sheet",id:"time-complexity-cheat-sheet",level:2},{value:"Advanced Applications",id:"advanced-applications",level:2},{value:"Real-World Use Cases",id:"real-world-use-cases",level:3},{value:"Common Tricks &amp; Tips",id:"common-tricks--tips",level:2},{value:"Implementation Guidelines",id:"implementation-guidelines",level:3},{value:"Interview Preparation",id:"interview-preparation",level:3}];function h(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"graph",children:"Graph"})}),"\n",(0,t.jsx)(e.p,{children:"This comprehensive guide covers fundamental to advanced graph algorithms with Java implementations, organized into clear patterns for efficient learning and interview preparation."}),"\n",(0,t.jsx)(e.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#graph-representation",children:"Graph Representation"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-1-dfs-traversal",children:"Pattern 1: DFS Traversal"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-2-bfs-traversal",children:"Pattern 2: BFS Traversal"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-3-connected-components",children:"Pattern 3: Connected Components"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-4-cycle-detection",children:"Pattern 4: Cycle Detection"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-5-topological-sort",children:"Pattern 5: Topological Sort"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-6-shortest-path",children:"Pattern 6: Shortest Path"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-7-minimum-spanning-tree",children:"Pattern 7: Minimum Spanning Tree"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-8-union-find",children:"Pattern 8: Union Find (Disjoint Set)"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-9-bipartite-graphs",children:"Pattern 9: Bipartite Graphs"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-10-strongly-connected-components",children:"Pattern 10: Strongly Connected Components"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-11-graph-coloring",children:"Pattern 11: Graph Coloring"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-12-advanced-problems",children:"Pattern 12: Advanced Problems"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-13-graph-neural-networks--machine-learning",children:"Pattern 13: Graph Neural Networks & Machine Learning"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-14-dynamic-graph-algorithms",children:"Pattern 14: Dynamic Graph Algorithms"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#pattern-15-network-flow--matching",children:"Pattern 15: Network Flow & Matching"})}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"graph-representation",children:"Graph Representation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Adjacency List (Most Common)\nclass Graph {\n    int V;\n    List<List<Integer>> adj;\n\n    Graph(int V) {\n        this.V = V;\n        adj = new ArrayList<>();\n        for (int i = 0; i < V; i++) {\n            adj.add(new ArrayList<>());\n        }\n    }\n\n    void addEdge(int u, int v) {\n        adj.get(u).add(v);\n        adj.get(v).add(u); // For undirected\n    }\n}\n\n// Weighted Graph\nclass WeightedGraph {\n    int V;\n    List<List<Edge>> adj;\n\n    class Edge {\n        int dest, weight;\n        Edge(int dest, int weight) {\n            this.dest = dest;\n            this.weight = weight;\n        }\n    }\n\n    WeightedGraph(int V) {\n        this.V = V;\n        adj = new ArrayList<>();\n        for (int i = 0; i < V; i++) {\n            adj.add(new ArrayList<>());\n        }\n    }\n\n    void addEdge(int u, int v, int weight) {\n        adj.get(u).add(new Edge(v, weight));\n        adj.get(v).add(new Edge(u, weight)); // For undirected\n    }\n}\n\n// Adjacency Matrix\nclass GraphMatrix {\n    int[][] matrix;\n    int V;\n\n    GraphMatrix(int V) {\n        this.V = V;\n        matrix = new int[V][V];\n    }\n\n    void addEdge(int u, int v) {\n        matrix[u][v] = 1;\n        matrix[v][u] = 1; // For undirected\n    }\n}\n\n// Edge List (for Union-Find)\nclass Edge {\n    int src, dest, weight;\n    Edge(int src, int dest, int weight) {\n        this.src = src;\n        this.dest = dest;\n        this.weight = weight;\n    }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-1-dfs-traversal",children:"Pattern 1: DFS Traversal"}),"\n",(0,t.jsx)(e.h3,{id:"11-basic-dfs-recursive",children:"1.1 Basic DFS (Recursive)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:'void dfs(List<List<Integer>> graph, int node, boolean[] visited) {\n    visited[node] = true;\n    System.out.print(node + " ");\n\n    for (int neighbor : graph.get(node)) {\n        if (!visited[neighbor]) {\n            dfs(graph, neighbor, visited);\n        }\n    }\n}\n\n// All components\nvoid dfsAll(List<List<Integer>> graph) {\n    int n = graph.size();\n    boolean[] visited = new boolean[n];\n\n    for (int i = 0; i < n; i++) {\n        if (!visited[i]) {\n            dfs(graph, i, visited);\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"12-dfs-iterative-with-stack",children:"1.2 DFS (Iterative with Stack)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:'void dfsIterative(List<List<Integer>> graph, int start) {\n    boolean[] visited = new boolean[graph.size()];\n    Deque<Integer> stack = new ArrayDeque<>();\n\n    stack.push(start);\n\n    while (!stack.isEmpty()) {\n        int node = stack.pop();\n\n        if (visited[node]) continue;\n\n        visited[node] = true;\n        System.out.print(node + " ");\n\n        for (int neighbor : graph.get(node)) {\n            if (!visited[neighbor]) {\n                stack.push(neighbor);\n            }\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"13-dfs-with-path-tracking",children:"1.3 DFS with Path Tracking"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"boolean dfsPath(List<List<Integer>> graph, int curr, int target,\n                boolean[] visited, List<Integer> path) {\n    visited[curr] = true;\n    path.add(curr);\n\n    if (curr == target) return true;\n\n    for (int neighbor : graph.get(curr)) {\n        if (!visited[neighbor]) {\n            if (dfsPath(graph, neighbor, target, visited, path)) {\n                return true;\n            }\n        }\n    }\n\n    path.remove(path.size() - 1);\n    return false;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"14-count-all-paths",children:"1.4 Count All Paths"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"int countPaths(List<List<Integer>> graph, int curr, int target,\n               boolean[] visited) {\n    if (curr == target) return 1;\n\n    visited[curr] = true;\n    int count = 0;\n\n    for (int neighbor : graph.get(curr)) {\n        if (!visited[neighbor]) {\n            count += countPaths(graph, neighbor, target, visited);\n        }\n    }\n\n    visited[curr] = false; // Backtrack\n    return count;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"15-number-of-islands-dfs-grid",children:"1.5 Number of Islands (DFS Grid)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"int numIslands(char[][] grid) {\n    if (grid == null || grid.length == 0) return 0;\n\n    int islands = 0;\n    for (int i = 0; i < grid.length; i++) {\n        for (int j = 0; j < grid[^1_0].length; j++) {\n            if (grid[i][j] == '1') {\n                islands++;\n                dfsIsland(grid, i, j);\n            }\n        }\n    }\n    return islands;\n}\n\nvoid dfsIsland(char[][] grid, int i, int j) {\n    if (i < 0 || i >= grid.length || j < 0 || j >= grid[^1_0].length ||\n        grid[i][j] == '0') {\n        return;\n    }\n\n    grid[i][j] = '0'; // Mark as visited\n\n    dfsIsland(grid, i + 1, j);\n    dfsIsland(grid, i - 1, j);\n    dfsIsland(grid, i, j + 1);\n    dfsIsland(grid, i, j - 1);\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-2-bfs-traversal",children:"Pattern 2: BFS Traversal"}),"\n",(0,t.jsx)(e.h3,{id:"21-basic-bfs",children:"2.1 Basic BFS"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:'void bfs(List<List<Integer>> graph, int start) {\n    boolean[] visited = new boolean[graph.size()];\n    Queue<Integer> queue = new LinkedList<>();\n\n    visited[start] = true;\n    queue.offer(start);\n\n    while (!queue.isEmpty()) {\n        int node = queue.poll();\n        System.out.print(node + " ");\n\n        for (int neighbor : graph.get(node)) {\n            if (!visited[neighbor]) {\n                visited[neighbor] = true;\n                queue.offer(neighbor);\n            }\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"22-bfs-level-order",children:"2.2 BFS Level Order"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"List<List<Integer>> bfsLevelOrder(List<List<Integer>> graph, int start) {\n    List<List<Integer>> result = new ArrayList<>();\n    boolean[] visited = new boolean[graph.size()];\n    Queue<Integer> queue = new LinkedList<>();\n\n    visited[start] = true;\n    queue.offer(start);\n\n    while (!queue.isEmpty()) {\n        int size = queue.size();\n        List<Integer> level = new ArrayList<>();\n\n        for (int i = 0; i < size; i++) {\n            int node = queue.poll();\n            level.add(node);\n\n            for (int neighbor : graph.get(node)) {\n                if (!visited[neighbor]) {\n                    visited[neighbor] = true;\n                    queue.offer(neighbor);\n                }\n            }\n        }\n        result.add(level);\n    }\n    return result;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"23-shortest-path-unweighted",children:"2.3 Shortest Path (Unweighted)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"int shortestPath(List<List<Integer>> graph, int start, int end) {\n    boolean[] visited = new boolean[graph.size()];\n    Queue<Integer> queue = new LinkedList<>();\n\n    visited[start] = true;\n    queue.offer(start);\n    int distance = 0;\n\n    while (!queue.isEmpty()) {\n        int size = queue.size();\n\n        for (int i = 0; i < size; i++) {\n            int node = queue.poll();\n            if (node == end) return distance;\n\n            for (int neighbor : graph.get(node)) {\n                if (!visited[neighbor]) {\n                    visited[neighbor] = true;\n                    queue.offer(neighbor);\n                }\n            }\n        }\n        distance++;\n    }\n    return -1;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"24-shortest-path-with-parent-tracking",children:"2.4 Shortest Path with Parent Tracking"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"List<Integer> shortestPathWithPath(List<List<Integer>> graph,\n                                   int start, int end) {\n    int n = graph.size();\n    int[] parent = new int[n];\n    Arrays.fill(parent, -1);\n\n    boolean[] visited = new boolean[n];\n    Queue<Integer> queue = new LinkedList<>();\n\n    visited[start] = true;\n    queue.offer(start);\n\n    while (!queue.isEmpty()) {\n        int node = queue.poll();\n        if (node == end) break;\n\n        for (int neighbor : graph.get(node)) {\n            if (!visited[neighbor]) {\n                visited[neighbor] = true;\n                parent[neighbor] = node;\n                queue.offer(neighbor);\n            }\n        }\n    }\n\n    // Reconstruct path\n    List<Integer> path = new ArrayList<>();\n    for (int at = end; at != -1; at = parent[at]) {\n        path.add(at);\n    }\n    Collections.reverse(path);\n    return path;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"25-word-ladder-bfs-application",children:"2.5 Word Ladder (BFS Application)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"int ladderLength(String beginWord, String endWord, List<String> wordList) {\n    Set<String> wordSet = new HashSet<>(wordList);\n    if (!wordSet.contains(endWord)) return 0;\n\n    Queue<String> queue = new LinkedList<>();\n    queue.offer(beginWord);\n    int level = 1;\n\n    while (!queue.isEmpty()) {\n        int size = queue.size();\n\n        for (int i = 0; i < size; i++) {\n            String word = queue.poll();\n            if (word.equals(endWord)) return level;\n\n            char[] chars = word.toCharArray();\n            for (int j = 0; j < chars.length; j++) {\n                char original = chars[j];\n\n                for (char c = 'a'; c <= 'z'; c++) {\n                    chars[j] = c;\n                    String newWord = new String(chars);\n\n                    if (wordSet.contains(newWord)) {\n                        queue.offer(newWord);\n                        wordSet.remove(newWord);\n                    }\n                }\n                chars[j] = original;\n            }\n        }\n        level++;\n    }\n    return 0;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-3-connected-components",children:"Pattern 3: Connected Components"}),"\n",(0,t.jsx)(e.h3,{id:"31-count-connected-components-dfs",children:"3.1 Count Connected Components (DFS)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"int countComponents(int n, int[][] edges) {\n    List<List<Integer>> graph = new ArrayList<>();\n    for (int i = 0; i < n; i++) {\n        graph.add(new ArrayList<>());\n    }\n\n    for (int[] edge : edges) {\n        graph.get(edge[0]).add(edge[1]);\n        graph.get(edge[1]).add(edge[0]);\n    }\n\n    boolean[] visited = new boolean[n];\n    int count = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (!visited[i]) {\n            dfs(graph, i, visited);\n            count++;\n        }\n    }\n    return count;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"32-count-components-union-find",children:"3.2 Count Components (Union-Find)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"int countComponentsUF(int n, int[][] edges) {\n    UnionFind uf = new UnionFind(n);\n\n    for (int[] edge : edges) {\n        uf.union(edge[0], edge[1]);\n    }\n\n    return uf.getCount();\n}\n\nclass UnionFind {\n    int[] parent, size;\n    int count;\n\n    UnionFind(int n) {\n        parent = new int[n];\n        size = new int[n];\n        count = n;\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n            size[i] = 1;\n        }\n    }\n\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    boolean union(int x, int y) {\n        int px = find(x), py = find(y);\n        if (px == py) return false;\n\n        if (size[px] < size[py]) {\n            parent[px] = py;\n            size[py] += size[px];\n        } else {\n            parent[py] = px;\n            size[px] += size[py];\n        }\n        count--;\n        return true;\n    }\n\n    int getCount() {\n        return count;\n    }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-4-cycle-detection",children:"Pattern 4: Cycle Detection"}),"\n",(0,t.jsx)(e.h3,{id:"41-cycle-detection-undirected-graph---dfs",children:"4.1 Cycle Detection (Undirected Graph - DFS)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"boolean hasCycleUndirected(List<List<Integer>> graph) {\n    boolean[] visited = new boolean[graph.size()];\n\n    for (int i = 0; i < graph.size(); i++) {\n        if (!visited[i]) {\n            if (dfsCycleUndirected(graph, i, -1, visited)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nboolean dfsCycleUndirected(List<List<Integer>> graph, int node, int parent,\n                          boolean[] visited) {\n    visited[node] = true;\n\n    for (int neighbor : graph.get(node)) {\n        if (!visited[neighbor]) {\n            if (dfsCycleUndirected(graph, neighbor, node, visited)) {\n                return true;\n            }\n        } else if (neighbor != parent) {\n            return true;\n        }\n    }\n    return false;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"42-cycle-detection-directed-graph---dfs",children:"4.2 Cycle Detection (Directed Graph - DFS)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"boolean hasCycleDirected(List<List<Integer>> graph) {\n    int n = graph.size();\n    int[] color = new int[n]; // 0: white, 1: gray, 2: black\n\n    for (int i = 0; i < n; i++) {\n        if (color[i] == 0) {\n            if (dfsCycleDirected(graph, i, color)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nboolean dfsCycleDirected(List<List<Integer>> graph, int node, int[] color) {\n    color[node] = 1; // Gray\n\n    for (int neighbor : graph.get(node)) {\n        if (color[neighbor] == 1) {\n            return true; // Back edge\n        }\n        if (color[neighbor] == 0 && dfsCycleDirected(graph, neighbor, color)) {\n            return true;\n        }\n    }\n\n    color[node] = 2; // Black\n    return false;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"43-cycle-detection-union-find",children:"4.3 Cycle Detection (Union-Find)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"boolean hasCycleUF(int n, int[][] edges) {\n    UnionFind uf = new UnionFind(n);\n\n    for (int[] edge : edges) {\n        if (!uf.union(edge[0], edge[1])) {\n            return true; // Cycle detected\n        }\n    }\n    return false;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-5-topological-sort",children:"Pattern 5: Topological Sort"}),"\n",(0,t.jsx)(e.h3,{id:"51-topological-sort-dfs",children:"5.1 Topological Sort (DFS)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"List<Integer> topologicalSort(List<List<Integer>> graph) {\n    int n = graph.size();\n    boolean[] visited = new boolean[n];\n    Deque<Integer> stack = new ArrayDeque<>();\n\n    for (int i = 0; i < n; i++) {\n        if (!visited[i]) {\n            dfsTopological(graph, i, visited, stack);\n        }\n    }\n\n    List<Integer> result = new ArrayList<>();\n    while (!stack.isEmpty()) {\n        result.add(stack.pop());\n    }\n    return result;\n}\n\nvoid dfsTopological(List<List<Integer>> graph, int node, boolean[] visited,\n                   Deque<Integer> stack) {\n    visited[node] = true;\n\n    for (int neighbor : graph.get(node)) {\n        if (!visited[neighbor]) {\n            dfsTopological(graph, neighbor, visited, stack);\n        }\n    }\n\n    stack.push(node);\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"52-topological-sort-kahns-algorithm---bfs",children:"5.2 Topological Sort (Kahn's Algorithm - BFS)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"List<Integer> topologicalSortBFS(List<List<Integer>> graph) {\n    int n = graph.size();\n    int[] indegree = new int[n];\n\n    // Calculate indegree\n    for (int u = 0; u < n; u++) {\n        for (int v : graph.get(u)) {\n            indegree[v]++;\n        }\n    }\n\n    Queue<Integer> queue = new LinkedList<>();\n    for (int i = 0; i < n; i++) {\n        if (indegree[i] == 0) {\n            queue.offer(i);\n        }\n    }\n\n    List<Integer> result = new ArrayList<>();\n    while (!queue.isEmpty()) {\n        int node = queue.poll();\n        result.add(node);\n\n        for (int neighbor : graph.get(node)) {\n            indegree[neighbor]--;\n            if (indegree[neighbor] == 0) {\n                queue.offer(neighbor);\n            }\n        }\n    }\n\n    return result.size() == n ? result : new ArrayList<>(); // Cycle exists\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"53-course-schedule",children:"5.3 Course Schedule"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"boolean canFinish(int numCourses, int[][] prerequisites) {\n    List<List<Integer>> graph = new ArrayList<>();\n    for (int i = 0; i < numCourses; i++) {\n        graph.add(new ArrayList<>());\n    }\n\n    int[] indegree = new int[numCourses];\n    for (int[] prereq : prerequisites) {\n        graph.get(prereq[1]).add(prereq[0]);\n        indegree[prereq[0]]++;\n    }\n\n    Queue<Integer> queue = new LinkedList<>();\n    for (int i = 0; i < numCourses; i++) {\n        if (indegree[i] == 0) {\n            queue.offer(i);\n        }\n    }\n\n    int count = 0;\n    while (!queue.isEmpty()) {\n        int course = queue.poll();\n        count++;\n\n        for (int next : graph.get(course)) {\n            indegree[next]--;\n            if (indegree[next] == 0) {\n                queue.offer(next);\n            }\n        }\n    }\n\n    return count == numCourses;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-6-shortest-path",children:"Pattern 6: Shortest Path"}),"\n",(0,t.jsx)(e.h3,{id:"61-dijkstras-algorithm",children:"6.1 Dijkstra's Algorithm"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"int[] dijkstra(List<List<Edge>> graph, int start) {\n    int n = graph.size();\n    int[] dist = new int[n];\n    Arrays.fill(dist, Integer.MAX_VALUE);\n    dist[start] = 0;\n\n    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\n    pq.offer(new int[]{start, 0});\n\n    while (!pq.isEmpty()) {\n        int[] curr = pq.poll();\n        int node = curr[0], d = curr[1];\n\n        if (d > dist[node]) continue;\n\n        for (Edge edge : graph.get(node)) {\n            int newDist = dist[node] + edge.weight;\n            if (newDist < dist[edge.dest]) {\n                dist[edge.dest] = newDist;\n                pq.offer(new int[]{edge.dest, newDist});\n            }\n        }\n    }\n\n    return dist;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"62-bellman-ford-algorithm",children:"6.2 Bellman-Ford Algorithm"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"boolean bellmanFord(List<Edge> edges, int n, int start, int[] dist) {\n    Arrays.fill(dist, Integer.MAX_VALUE);\n    dist[start] = 0;\n\n    // Relax edges n-1 times\n    for (int i = 0; i < n - 1; i++) {\n        for (Edge edge : edges) {\n            if (dist[edge.src] != Integer.MAX_VALUE &&\n                dist[edge.src] + edge.weight < dist[edge.dest]) {\n                dist[edge.dest] = dist[edge.src] + edge.weight;\n            }\n        }\n    }\n\n    // Check for negative cycles\n    for (Edge edge : edges) {\n        if (dist[edge.src] != Integer.MAX_VALUE &&\n            dist[edge.src] + edge.weight < dist[edge.dest]) {\n            return false; // Negative cycle exists\n        }\n    }\n\n    return true;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"63-floyd-warshall-algorithm",children:"6.3 Floyd-Warshall Algorithm"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"void floydWarshall(int[][] graph) {\n    int n = graph.length;\n\n    for (int k = 0; k < n; k++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (graph[i][k] != Integer.MAX_VALUE &&\n                    graph[k][j] != Integer.MAX_VALUE &&\n                    graph[i][k] + graph[k][j] < graph[i][j]) {\n                    graph[i][j] = graph[i][k] + graph[k][j];\n                }\n            }\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-7-minimum-spanning-tree",children:"Pattern 7: Minimum Spanning Tree"}),"\n",(0,t.jsx)(e.h3,{id:"71-kruskals-algorithm",children:"7.1 Kruskal's Algorithm"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"List<Edge> kruskalMST(int n, List<Edge> edges) {\n    edges.sort((a, b) -> a.weight - b.weight);\n    UnionFind uf = new UnionFind(n);\n    List<Edge> mst = new ArrayList<>();\n\n    for (Edge edge : edges) {\n        if (uf.union(edge.src, edge.dest)) {\n            mst.add(edge);\n            if (mst.size() == n - 1) break;\n        }\n    }\n\n    return mst;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"72-prims-algorithm",children:"7.2 Prim's Algorithm"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"List<Edge> primMST(List<List<Edge>> graph, int start) {\n    int n = graph.size();\n    boolean[] inMST = new boolean[n];\n    PriorityQueue<Edge> pq = new PriorityQueue<>((a, b) -> a.weight - b.weight);\n    List<Edge> mst = new ArrayList<>();\n\n    inMST[start] = true;\n    for (Edge edge : graph.get(start)) {\n        pq.offer(edge);\n    }\n\n    while (!pq.isEmpty() && mst.size() < n - 1) {\n        Edge edge = pq.poll();\n\n        if (inMST[edge.dest]) continue;\n\n        inMST[edge.dest] = true;\n        mst.add(edge);\n\n        for (Edge nextEdge : graph.get(edge.dest)) {\n            if (!inMST[nextEdge.dest]) {\n                pq.offer(nextEdge);\n            }\n        }\n    }\n\n    return mst;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-8-union-find-disjoint-set",children:"Pattern 8: Union Find (Disjoint Set)"}),"\n",(0,t.jsx)(e.h3,{id:"81-optimized-union-find-implementation",children:"8.1 Optimized Union-Find Implementation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"class UnionFind {\n    int[] parent, rank;\n    int count;\n\n    UnionFind(int n) {\n        parent = new int[n];\n        rank = new int[n];\n        count = n;\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n    }\n\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]); // Path compression\n        }\n        return parent[x];\n    }\n\n    boolean union(int x, int y) {\n        int px = find(x), py = find(y);\n        if (px == py) return false;\n\n        // Union by rank\n        if (rank[px] < rank[py]) {\n            parent[px] = py;\n        } else if (rank[px] > rank[py]) {\n            parent[py] = px;\n        } else {\n            parent[py] = px;\n            rank[px]++;\n        }\n        count--;\n        return true;\n    }\n\n    boolean connected(int x, int y) {\n        return find(x) == find(y);\n    }\n\n    int getCount() {\n        return count;\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"82-redundant-connection",children:"8.2 Redundant Connection"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"int[] findRedundantConnection(int[][] edges) {\n    int n = edges.length;\n    UnionFind uf = new UnionFind(n + 1);\n\n    for (int[] edge : edges) {\n        if (!uf.union(edge[0], edge[1])) {\n            return edge; // This edge creates a cycle\n        }\n    }\n    return new int[^1_0];\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"83-number-of-provinces",children:"8.3 Number of Provinces"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"int findCircleNum(int[][] isConnected) {\n    int n = isConnected.length;\n    UnionFind uf = new UnionFind(n);\n\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (isConnected[i][j] == 1) {\n                uf.union(i, j);\n            }\n        }\n    }\n\n    Set<Integer> provinces = new HashSet<>();\n    for (int i = 0; i < n; i++) {\n        provinces.add(uf.find(i));\n    }\n\n    return provinces.size();\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-9-bipartite-graphs",children:"Pattern 9: Bipartite Graphs"}),"\n",(0,t.jsx)(e.h3,{id:"91-check-if-bipartite-bfs",children:"9.1 Check if Bipartite (BFS)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"boolean isBipartite(List<List<Integer>> graph) {\n    int n = graph.size();\n    int[] color = new int[n];\n    Arrays.fill(color, -1);\n\n    for (int i = 0; i < n; i++) {\n        if (color[i] == -1) {\n            if (!bfsBipartite(graph, i, color)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nboolean bfsBipartite(List<List<Integer>> graph, int start, int[] color) {\n    Queue<Integer> queue = new LinkedList<>();\n    queue.offer(start);\n    color[start] = 0;\n\n    while (!queue.isEmpty()) {\n        int node = queue.poll();\n\n        for (int neighbor : graph.get(node)) {\n            if (color[neighbor] == -1) {\n                color[neighbor] = 1 - color[node];\n                queue.offer(neighbor);\n            } else if (color[neighbor] == color[node]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"92-check-if-bipartite-dfs",children:"9.2 Check if Bipartite (DFS)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"boolean isBipartiteDFS(List<List<Integer>> graph) {\n    int n = graph.size();\n    int[] color = new int[n];\n    Arrays.fill(color, -1);\n\n    for (int i = 0; i < n; i++) {\n        if (color[i] == -1) {\n            if (!dfsBipartite(graph, i, 0, color)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nboolean dfsBipartite(List<List<Integer>> graph, int node,\n                    int c, int[] color) {\n    color[node] = c;\n\n    for (int neighbor : graph.get(node)) {\n        if (color[neighbor] == -1) {\n            if (!dfsBipartite(graph, neighbor, 1 - c, color)) {\n                return false;\n            }\n        } else if (color[neighbor] == color[node]) {\n            return false;\n        }\n    }\n    return true;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"93-maximum-bipartite-matching",children:"9.3 Maximum Bipartite Matching"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"int maxBipartiteMatching(List<List<Integer>> graph, int leftSize) {\n    int[] match = new int[graph.size()];\n    Arrays.fill(match, -1);\n    int result = 0;\n\n    for (int u = 0; u < leftSize; u++) {\n        boolean[] visited = new boolean[graph.size()];\n        if (dfsMatching(graph, u, visited, match)) {\n            result++;\n        }\n    }\n    return result;\n}\n\nboolean dfsMatching(List<List<Integer>> graph, int u, boolean[] visited, int[] match) {\n    for (int v : graph.get(u)) {\n        if (visited[v]) continue;\n        visited[v] = true;\n\n        if (match[v] == -1 || dfsMatching(graph, match[v], visited, match)) {\n            match[v] = u;\n            return true;\n        }\n    }\n    return false;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-10-strongly-connected-components",children:"Pattern 10: Strongly Connected Components"}),"\n",(0,t.jsx)(e.h3,{id:"101-kosarajus-algorithm",children:"10.1 Kosaraju's Algorithm"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"List<List<Integer>> kosarajuSCC(List<List<Integer>> graph) {\n    int n = graph.size();\n    boolean[] visited = new boolean[n];\n    Deque<Integer> stack = new ArrayDeque<>();\n\n    // First DFS to fill stack\n    for (int i = 0; i < n; i++) {\n        if (!visited[i]) {\n            dfsKosaraju1(graph, i, visited, stack);\n        }\n    }\n\n    // Create transpose graph\n    List<List<Integer>> transpose = new ArrayList<>();\n    for (int i = 0; i < n; i++) {\n        transpose.add(new ArrayList<>());\n    }\n    for (int u = 0; u < n; u++) {\n        for (int v : graph.get(u)) {\n            transpose.get(v).add(u);\n        }\n    }\n\n    // Second DFS on transpose\n    Arrays.fill(visited, false);\n    List<List<Integer>> sccs = new ArrayList<>();\n\n    while (!stack.isEmpty()) {\n        int node = stack.pop();\n        if (!visited[node]) {\n            List<Integer> scc = new ArrayList<>();\n            dfsKosaraju2(transpose, node, visited, scc);\n            sccs.add(scc);\n        }\n    }\n\n    return sccs;\n}\n\nvoid dfsKosaraju1(List<List<Integer>> graph, int node,\n                 boolean[] visited, Deque<Integer> stack) {\n    visited[node] = true;\n\n    for (int neighbor : graph.get(node)) {\n        if (!visited[neighbor]) {\n            dfsKosaraju1(graph, neighbor, visited, stack);\n        }\n    }\n\n    stack.push(node);\n}\n\nvoid dfsKosaraju2(List<List<Integer>> graph, int node,\n                 boolean[] visited, List<Integer> scc) {\n    visited[node] = true;\n    scc.add(node);\n\n    for (int neighbor : graph.get(node)) {\n        if (!visited[neighbor]) {\n            dfsKosaraju2(graph, neighbor, visited, scc);\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"102-tarjans-algorithm",children:"10.2 Tarjan's Algorithm"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"List<List<Integer>> tarjanSCC(List<List<Integer>> graph) {\n    int n = graph.size();\n    int[] ids = new int[n];\n    int[] low = new int[n];\n    boolean[] onStack = new boolean[n];\n    Arrays.fill(ids, -1);\n\n    Deque<Integer> stack = new ArrayDeque<>();\n    List<List<Integer>> sccs = new ArrayList<>();\n    int[] id = {0};\n\n    for (int i = 0; i < n; i++) {\n        if (ids[i] == -1) {\n            dfsTarjan(graph, i, ids, low, onStack, stack, sccs, id);\n        }\n    }\n\n    return sccs;\n}\n\nvoid dfsTarjan(List<List<Integer>> graph, int node, int[] ids, int[] low,\n              boolean[] onStack, Deque<Integer> stack,\n              List<List<Integer>> sccs, int[] id) {\n    ids[node] = low[node] = id[^1_0]++;\n    stack.push(node);\n    onStack[node] = true;\n\n    for (int neighbor : graph.get(node)) {\n        if (ids[neighbor] == -1) {\n            dfsTarjan(graph, neighbor, ids, low, onStack, stack, sccs, id);\n        }\n        if (onStack[neighbor]) {\n            low[node] = Math.min(low[node], low[neighbor]);\n        }\n    }\n\n    if (ids[node] == low[node]) {\n        List<Integer> scc = new ArrayList<>();\n        while (true) {\n            int n = stack.pop();\n            onStack[n] = false;\n            scc.add(n);\n            if (n == node) break;\n        }\n        sccs.add(scc);\n    }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-11-graph-coloring",children:"Pattern 11: Graph Coloring"}),"\n",(0,t.jsx)(e.h3,{id:"111-graph-coloring-greedy",children:"11.1 Graph Coloring (Greedy)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"int[] graphColoring(List<List<Integer>> graph) {\n    int n = graph.size();\n    int[] color = new int[n];\n    Arrays.fill(color, -1);\n\n    for (int node = 0; node < n; node++) {\n        Set<Integer> usedColors = new HashSet<>();\n\n        for (int neighbor : graph.get(node)) {\n            if (color[neighbor] != -1) {\n                usedColors.add(color[neighbor]);\n            }\n        }\n\n        int c = 0;\n        while (usedColors.contains(c)) {\n            c++;\n        }\n        color[node] = c;\n    }\n\n    return color;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"112-chromatic-number-min-colors",children:"11.2 Chromatic Number (Min Colors)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"int chromaticNumber(List<List<Integer>> graph) {\n    int[] coloring = graphColoring(graph);\n    int maxColor = 0;\n\n    for (int c : coloring) {\n        maxColor = Math.max(maxColor, c);\n    }\n\n    return maxColor + 1;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"113-graph-coloring-with-k-colors",children:"11.3 Graph Coloring with K Colors"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"boolean canColorWithKColors(List<List<Integer>> graph, int k) {\n    int n = graph.size();\n    int[] color = new int[n];\n    Arrays.fill(color, -1);\n\n    return backtrackColoring(graph, 0, k, color);\n}\n\nboolean backtrackColoring(List<List<Integer>> graph, int node, int k, int[] color) {\n    if (node == graph.size()) return true;\n\n    for (int c = 0; c < k; c++) {\n        if (isColorSafe(graph, node, c, color)) {\n            color[node] = c;\n            if (backtrackColoring(graph, node + 1, k, color)) {\n                return true;\n            }\n            color[node] = -1;\n        }\n    }\n    return false;\n}\n\nboolean isColorSafe(List<List<Integer>> graph, int node, int c, int[] color) {\n    for (int neighbor : graph.get(node)) {\n        if (color[neighbor] == c) {\n            return false;\n        }\n    }\n    return true;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-12-advanced-problems",children:"Pattern 12: Advanced Problems"}),"\n",(0,t.jsx)(e.h3,{id:"121-bridge-finding-tarjan",children:"12.1 Bridge Finding (Tarjan)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"List<int[]> findBridges(List<List<Integer>> graph) {\n    int n = graph.size();\n    int[] ids = new int[n];\n    int[] low = new int[n];\n    boolean[] visited = new boolean[n];\n    Arrays.fill(ids, -1);\n\n    List<int[]> bridges = new ArrayList<>();\n    int[] id = {0};\n\n    for (int i = 0; i < n; i++) {\n        if (!visited[i]) {\n            dfsBridges(graph, i, -1, ids, low, visited, bridges, id);\n        }\n    }\n\n    return bridges;\n}\n\nvoid dfsBridges(List<List<Integer>> graph, int node, int parent,\n               int[] ids, int[] low, boolean[] visited,\n               List<int[]> bridges, int[] id) {\n    visited[node] = true;\n    ids[node] = low[node] = id[^1_0]++;\n\n    for (int neighbor : graph.get(node)) {\n        if (neighbor == parent) continue;\n\n        if (!visited[neighbor]) {\n            dfsBridges(graph, neighbor, node, ids, low, visited, bridges, id);\n            low[node] = Math.min(low[node], low[neighbor]);\n\n            if (ids[node] < low[neighbor]) {\n                bridges.add(new int[]{node, neighbor});\n            }\n        } else {\n            low[node] = Math.min(low[node], ids[neighbor]);\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"122-articulation-points",children:"12.2 Articulation Points"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"List<Integer> findArticulationPoints(List<List<Integer>> graph) {\n    int n = graph.size();\n    int[] ids = new int[n];\n    int[] low = new int[n];\n    boolean[] visited = new boolean[n];\n    boolean[] isAP = new boolean[n];\n    Arrays.fill(ids, -1);\n\n    int[] id = {0};\n\n    for (int i = 0; i < n; i++) {\n        if (!visited[i]) {\n            dfsAP(graph, i, -1, ids, low, visited, isAP, id);\n        }\n    }\n\n    List<Integer> result = new ArrayList<>();\n    for (int i = 0; i < n; i++) {\n        if (isAP[i]) result.add(i);\n    }\n\n    return result;\n}\n\nvoid dfsAP(List<List<Integer>> graph, int node, int parent,\n          int[] ids, int[] low, boolean[] visited, boolean[] isAP, int[] id) {\n    visited[node] = true;\n    ids[node] = low[node] = id[^1_0]++;\n    int children = 0;\n\n    for (int neighbor : graph.get(node)) {\n        if (neighbor == parent) continue;\n\n        if (!visited[neighbor]) {\n            children++;\n            dfsAP(graph, neighbor, node, ids, low, visited, isAP, id);\n            low[node] = Math.min(low[node], low[neighbor]);\n\n            if (parent != -1 && ids[node] <= low[neighbor]) {\n                isAP[node] = true;\n            }\n        } else {\n            low[node] = Math.min(low[node], ids[neighbor]);\n        }\n    }\n\n    if (parent == -1 && children > 1) {\n        isAP[node] = true;\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"123-eulerian-pathcircuit",children:"12.3 Eulerian Path/Circuit"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"List<Integer> findEulerianPath(List<List<Integer>> graph) {\n    int n = graph.size();\n    int[] inDegree = new int[n];\n    int[] outDegree = new int[n];\n\n    for (int u = 0; u < n; u++) {\n        outDegree[u] = graph.get(u).size();\n        for (int v : graph.get(u)) {\n            inDegree[v]++;\n        }\n    }\n\n    int startNode = 0;\n    int endNodes = 0, startNodes = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (outDegree[i] - inDegree[i] == 1) {\n            startNodes++;\n            startNode = i;\n        } else if (inDegree[i] - outDegree[i] == 1) {\n            endNodes++;\n        } else if (inDegree[i] != outDegree[i]) {\n            return new ArrayList<>(); // No Eulerian path\n        }\n    }\n\n    if ((startNodes == 0 && endNodes == 0) ||\n        (startNodes == 1 && endNodes == 1)) {\n        List<Integer> path = new ArrayList<>();\n        Deque<Integer> stack = new ArrayDeque<>();\n\n        Map<Integer, Deque<Integer>> adj = new HashMap<>();\n        for (int u = 0; u < n; u++) {\n            adj.put(u, new ArrayDeque<>(graph.get(u)));\n        }\n\n        stack.push(startNode);\n\n        while (!stack.isEmpty()) {\n            int node = stack.peek();\n            if (adj.get(node).isEmpty()) {\n                path.add(stack.pop());\n            } else {\n                stack.push(adj.get(node).poll());\n            }\n        }\n\n        Collections.reverse(path);\n        return path;\n    }\n\n    return new ArrayList<>();\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"124-traveling-salesman-problem-dp--bitmask",children:"12.4 Traveling Salesman Problem (DP + Bitmask)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"int tsp(int[][] dist) {\n    int n = dist.length;\n    int[][] dp = new int[1 << n][n];\n\n    for (int[] row : dp) {\n        Arrays.fill(row, Integer.MAX_VALUE / 2);\n    }\n\n    dp[1][0] = 0;\n\n    for (int mask = 1; mask < (1 << n); mask++) {\n        for (int u = 0; u < n; u++) {\n            if ((mask & (1 << u)) == 0) continue;\n\n            for (int v = 0; v < n; v++) {\n                if ((mask & (1 << v)) != 0) continue;\n\n                int newMask = mask | (1 << v);\n                dp[newMask][v] = Math.min(dp[newMask][v],\n                                         dp[mask][u] + dist[u][v]);\n            }\n        }\n    }\n\n    int ans = Integer.MAX_VALUE;\n    for (int i = 1; i < n; i++) {\n        ans = Math.min(ans, dp[(1 << n) - 1][i] + dist[i][^1_0]);\n    }\n\n    return ans;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-13-graph-neural-networks--machine-learning",children:"Pattern 13: Graph Neural Networks & Machine Learning"}),"\n",(0,t.jsx)(e.h3,{id:"131-node2vec-implementation1_3",children:"13.1 Node2Vec Implementation[^1_3]"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"class Node2Vec {\n    private final List<List<Integer>> graph;\n    private final int walkLength;\n    private final int numWalks;\n    private final double p; // Return parameter\n    private final double q; // In-out parameter\n\n    Node2Vec(List<List<Integer>> graph, int walkLength, int numWalks, double p, double q) {\n        this.graph = graph;\n        this.walkLength = walkLength;\n        this.numWalks = numWalks;\n        this.p = p;\n        this.q = q;\n    }\n\n    List<List<Integer>> generateWalks() {\n        List<List<Integer>> walks = new ArrayList<>();\n        Random random = new Random();\n\n        for (int node = 0; node < graph.size(); node++) {\n            for (int walk = 0; walk < numWalks; walk++) {\n                List<Integer> path = simulateWalk(node, random);\n                walks.add(path);\n            }\n        }\n\n        return walks;\n    }\n\n    private List<Integer> simulateWalk(int startNode, Random random) {\n        List<Integer> walk = new ArrayList<>();\n        walk.add(startNode);\n\n        int current = startNode;\n        int previous = -1;\n\n        for (int step = 1; step < walkLength; step++) {\n            List<Integer> neighbors = graph.get(current);\n            if (neighbors.isEmpty()) break;\n\n            int next = getNextNode(current, previous, neighbors, random);\n            walk.add(next);\n            previous = current;\n            current = next;\n        }\n\n        return walk;\n    }\n\n    private int getNextNode(int current, int previous, List<Integer> neighbors, Random random) {\n        List<Double> weights = new ArrayList<>();\n        double totalWeight = 0;\n\n        for (int neighbor : neighbors) {\n            double weight;\n            if (neighbor == previous) {\n                weight = 1.0 / p; // Return to previous node\n            } else if (graph.get(previous).contains(neighbor)) {\n                weight = 1.0; // Stay in neighborhood\n            } else {\n                weight = 1.0 / q; // Move away\n            }\n            weights.add(weight);\n            totalWeight += weight;\n        }\n\n        double randomValue = random.nextDouble() * totalWeight;\n        double cumulativeWeight = 0;\n\n        for (int i = 0; i < neighbors.size(); i++) {\n            cumulativeWeight += weights.get(i);\n            if (randomValue <= cumulativeWeight) {\n                return neighbors.get(i);\n            }\n        }\n\n        return neighbors.get(neighbors.size() - 1);\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"132-graph-embedding-with-random-walks",children:"13.2 Graph Embedding with Random Walks"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"class GraphEmbedding {\n    private final Map<Integer, double[]> embeddings;\n    private final int dimensions;\n\n    GraphEmbedding(int dimensions) {\n        this.dimensions = dimensions;\n        this.embeddings = new HashMap<>();\n    }\n\n    void trainEmbeddings(List<List<Integer>> walks, int epochs) {\n        initializeEmbeddings(walks);\n\n        for (int epoch = 0; epoch < epochs; epoch++) {\n            for (List<Integer> walk : walks) {\n                for (int i = 0; i < walk.size(); i++) {\n                    int centerNode = walk.get(i);\n                    updateEmbedding(centerNode, walk, i);\n                }\n            }\n        }\n    }\n\n    private void initializeEmbeddings(List<List<Integer>> walks) {\n        Set<Integer> nodes = new HashSet<>();\n        for (List<Integer> walk : walks) {\n            nodes.addAll(walk);\n        }\n\n        Random random = new Random();\n        for (int node : nodes) {\n            double[] embedding = new double[dimensions];\n            for (int i = 0; i < dimensions; i++) {\n                embedding[i] = (random.nextGaussian() - 0.5) / dimensions;\n            }\n            embeddings.put(node, embedding);\n        }\n    }\n\n    private void updateEmbedding(int centerNode, List<Integer> walk, int position) {\n        int windowSize = 5;\n        double learningRate = 0.025;\n\n        for (int i = Math.max(0, position - windowSize);\n             i < Math.min(walk.size(), position + windowSize + 1); i++) {\n            if (i == position) continue;\n\n            int contextNode = walk.get(i);\n            double[] centerEmb = embeddings.get(centerNode);\n            double[] contextEmb = embeddings.get(contextNode);\n\n            // Skip-gram with negative sampling (simplified)\n            double dotProduct = 0;\n            for (int d = 0; d < dimensions; d++) {\n                dotProduct += centerEmb[d] * contextEmb[d];\n            }\n\n            double sigmoid = 1.0 / (1.0 + Math.exp(-dotProduct));\n            double gradient = learningRate * (1 - sigmoid);\n\n            for (int d = 0; d < dimensions; d++) {\n                centerEmb[d] += gradient * contextEmb[d];\n                contextEmb[d] += gradient * centerEmb[d];\n            }\n        }\n    }\n\n    double[] getEmbedding(int node) {\n        return embeddings.get(node);\n    }\n\n    double cosineSimilarity(int node1, int node2) {\n        double[] emb1 = embeddings.get(node1);\n        double[] emb2 = embeddings.get(node2);\n\n        if (emb1 == null || emb2 == null) return 0;\n\n        double dotProduct = 0, norm1 = 0, norm2 = 0;\n        for (int i = 0; i < dimensions; i++) {\n            dotProduct += emb1[i] * emb2[i];\n            norm1 += emb1[i] * emb1[i];\n            norm2 += emb2[i] * emb2[i];\n        }\n\n        return dotProduct / (Math.sqrt(norm1) * Math.sqrt(norm2));\n    }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-14-dynamic-graph-algorithms",children:"Pattern 14: Dynamic Graph Algorithms"}),"\n",(0,t.jsx)(e.h3,{id:"141-dynamic-connectivity1_3",children:"14.1 Dynamic Connectivity[^1_3]"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:'class DynamicConnectivity {\n    private final UnionFind uf;\n    private final Map<String, Boolean> edges;\n\n    DynamicConnectivity(int n) {\n        this.uf = new UnionFind(n);\n        this.edges = new HashMap<>();\n    }\n\n    void addEdge(int u, int v) {\n        String edge = getEdgeKey(u, v);\n        if (!edges.containsKey(edge)) {\n            edges.put(edge, true);\n            uf.union(u, v);\n        }\n    }\n\n    void removeEdge(int u, int v) {\n        String edge = getEdgeKey(u, v);\n        if (edges.containsKey(edge)) {\n            edges.remove(edge);\n            // For deletion, we need to rebuild the union-find structure\n            rebuildUnionFind();\n        }\n    }\n\n    boolean isConnected(int u, int v) {\n        return uf.connected(u, v);\n    }\n\n    int getComponents() {\n        return uf.getCount();\n    }\n\n    private String getEdgeKey(int u, int v) {\n        return Math.min(u, v) + "-" + Math.max(u, v);\n    }\n\n    private void rebuildUnionFind() {\n        uf.reset();\n        for (String edgeKey : edges.keySet()) {\n            String[] parts = edgeKey.split("-");\n            int u = Integer.parseInt(parts[0]);\n            int v = Integer.parseInt(parts[1]);\n            uf.union(u, v);\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"142-dynamic-pagerank1_3",children:"14.2 Dynamic PageRank[^1_3]"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"class DynamicPageRank {\n    private final Map<Integer, Double> pagerank;\n    private final Map<Integer, Set<Integer>> graph;\n    private final Map<Integer, Set<Integer>> reverseGraph;\n    private final double dampingFactor;\n    private final double epsilon;\n\n    DynamicPageRank(double dampingFactor, double epsilon) {\n        this.pagerank = new HashMap<>();\n        this.graph = new HashMap<>();\n        this.reverseGraph = new HashMap<>();\n        this.dampingFactor = dampingFactor;\n        this.epsilon = epsilon;\n    }\n\n    void addNode(int node) {\n        if (!pagerank.containsKey(node)) {\n            pagerank.put(node, 1.0);\n            graph.put(node, new HashSet<>());\n            reverseGraph.put(node, new HashSet<>());\n        }\n    }\n\n    void addEdge(int from, int to) {\n        addNode(from);\n        addNode(to);\n\n        if (!graph.get(from).contains(to)) {\n            graph.get(from).add(to);\n            reverseGraph.get(to).add(from);\n            updatePageRankIncremental(from, to);\n        }\n    }\n\n    void removeEdge(int from, int to) {\n        if (graph.containsKey(from) && graph.get(from).contains(to)) {\n            graph.get(from).remove(to);\n            reverseGraph.get(to).remove(from);\n            updatePageRankIncremental(from, to);\n        }\n    }\n\n    private void updatePageRankIncremental(int affectedFrom, int affectedTo) {\n        Set<Integer> nodesToUpdate = new HashSet<>();\n        nodesToUpdate.add(affectedTo);\n\n        // BFS to find nodes that might be affected\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(affectedTo);\n\n        while (!queue.isEmpty()) {\n            int node = queue.poll();\n            for (int neighbor : graph.getOrDefault(node, new HashSet<>())) {\n                if (!nodesToUpdate.contains(neighbor)) {\n                    nodesToUpdate.add(neighbor);\n                    queue.offer(neighbor);\n                }\n            }\n        }\n\n        // Update PageRank for affected nodes\n        for (int iterations = 0; iterations < 10; iterations++) {\n            Map<Integer, Double> newRanks = new HashMap<>(pagerank);\n\n            for (int node : nodesToUpdate) {\n                double rank = (1 - dampingFactor);\n                for (int predecessor : reverseGraph.getOrDefault(node, new HashSet<>())) {\n                    int outDegree = graph.get(predecessor).size();\n                    if (outDegree > 0) {\n                        rank += dampingFactor * pagerank.get(predecessor) / outDegree;\n                    }\n                }\n                newRanks.put(node, rank);\n            }\n\n            // Check convergence\n            boolean converged = true;\n            for (int node : nodesToUpdate) {\n                if (Math.abs(newRanks.get(node) - pagerank.get(node)) > epsilon) {\n                    converged = false;\n                    break;\n                }\n            }\n\n            pagerank.putAll(newRanks);\n            if (converged) break;\n        }\n    }\n\n    double getPageRank(int node) {\n        return pagerank.getOrDefault(node, 0.0);\n    }\n\n    Map<Integer, Double> getAllPageRanks() {\n        return new HashMap<>(pagerank);\n    }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"pattern-15-network-flow--matching",children:"Pattern 15: Network Flow & Matching"}),"\n",(0,t.jsx)(e.h3,{id:"151-maximum-flow-ford-fulkerson-with-edmonds-karp",children:"15.1 Maximum Flow (Ford-Fulkerson with Edmonds-Karp)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"class MaxFlow {\n    private final int[][] capacity;\n    private final int n;\n\n    MaxFlow(int n) {\n        this.n = n;\n        this.capacity = new int[n][n];\n    }\n\n    void addEdge(int from, int to, int cap) {\n        capacity[from][to] += cap;\n    }\n\n    int maxFlow(int source, int sink) {\n        int[][] residual = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            System.arraycopy(capacity[i], 0, residual[i], 0, n);\n        }\n\n        int maxFlow = 0;\n        int[] parent = new int[n];\n\n        while (bfsFlow(residual, source, sink, parent)) {\n            int pathFlow = Integer.MAX_VALUE;\n\n            for (int v = sink; v != source; v = parent[v]) {\n                int u = parent[v];\n                pathFlow = Math.min(pathFlow, residual[u][v]);\n            }\n\n            for (int v = sink; v != source; v = parent[v]) {\n                int u = parent[v];\n                residual[u][v] -= pathFlow;\n                residual[v][u] += pathFlow;\n            }\n\n            maxFlow += pathFlow;\n        }\n\n        return maxFlow;\n    }\n\n    private boolean bfsFlow(int[][] residual, int source, int sink, int[] parent) {\n        boolean[] visited = new boolean[n];\n        Queue<Integer> queue = new LinkedList<>();\n\n        queue.offer(source);\n        visited[source] = true;\n        parent[source] = -1;\n\n        while (!queue.isEmpty()) {\n            int u = queue.poll();\n\n            for (int v = 0; v < n; v++) {\n                if (!visited[v] && residual[u][v] > 0) {\n                    queue.offer(v);\n                    visited[v] = true;\n                    parent[v] = u;\n                    if (v == sink) return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    List<int[]> getMinCut(int source, int sink) {\n        maxFlow(source, sink); // Run max flow first\n\n        int[][] residual = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            System.arraycopy(capacity[i], 0, residual[i], 0, n);\n        }\n\n        // Find reachable nodes from source\n        boolean[] reachable = new boolean[n];\n        dfsReachable(residual, source, reachable);\n\n        List<int[]> minCutEdges = new ArrayList<>();\n        for (int u = 0; u < n; u++) {\n            for (int v = 0; v < n; v++) {\n                if (reachable[u] && !reachable[v] && capacity[u][v] > 0) {\n                    minCutEdges.add(new int[]{u, v});\n                }\n            }\n        }\n\n        return minCutEdges;\n    }\n\n    private void dfsReachable(int[][] residual, int u, boolean[] reachable) {\n        reachable[u] = true;\n        for (int v = 0; v < n; v++) {\n            if (!reachable[v] && residual[u][v] > 0) {\n                dfsReachable(residual, v, reachable);\n            }\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"152-hungarian-algorithm-for-assignment-problem",children:"15.2 Hungarian Algorithm for Assignment Problem"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"class HungarianAlgorithm {\n    private final int[][] cost;\n    private final int n;\n\n    HungarianAlgorithm(int[][] cost) {\n        this.n = cost.length;\n        this.cost = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            System.arraycopy(cost[i], 0, this.cost[i], 0, n);\n        }\n    }\n\n    int[] solve() {\n        // Step 1: Subtract row minimums\n        for (int i = 0; i < n; i++) {\n            int minVal = Arrays.stream(cost[i]).min().orElse(0);\n            for (int j = 0; j < n; j++) {\n                cost[i][j] -= minVal;\n            }\n        }\n\n        // Step 2: Subtract column minimums\n        for (int j = 0; j < n; j++) {\n            int minVal = Integer.MAX_VALUE;\n            for (int i = 0; i < n; i++) {\n                minVal = Math.min(minVal, cost[i][j]);\n            }\n            for (int i = 0; i < n; i++) {\n                cost[i][j] -= minVal;\n            }\n        }\n\n        // Step 3: Find optimal assignment using augmenting paths\n        int[] assignment = new int[n];\n        Arrays.fill(assignment, -1);\n\n        for (int worker = 0; worker < n; worker++) {\n            boolean[] visited = new boolean[n];\n            augment(worker, visited, assignment);\n        }\n\n        return assignment;\n    }\n\n    private boolean augment(int worker, boolean[] visited, int[] assignment) {\n        for (int job = 0; job < n; job++) {\n            if (cost[worker][job] == 0 && !visited[job]) {\n                visited[job] = true;\n\n                if (assignment[job] == -1 ||\n                    augment(assignment[job], visited, assignment)) {\n                    assignment[job] = worker;\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    int getMinCost(int[] assignment) {\n        int totalCost = 0;\n        for (int job = 0; job < n; job++) {\n            if (assignment[job] != -1) {\n                totalCost += cost[assignment[job]][job];\n            }\n        }\n        return totalCost;\n    }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"time-complexity-cheat-sheet",children:"Time Complexity Cheat Sheet"}),"\n",(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{style:{textAlign:"left"},children:"Algorithm"}),(0,t.jsx)(e.th,{style:{textAlign:"left"},children:"Time Complexity"}),(0,t.jsx)(e.th,{style:{textAlign:"left"},children:"Space Complexity"}),(0,t.jsx)(e.th,{style:{textAlign:"left"},children:"Use Case"})]})}),(0,t.jsxs)(e.tbody,{children:[(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"DFS"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(V + E)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(V)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Path finding, cycle detection"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"BFS"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(V + E)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(V)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Shortest path (unweighted)"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Dijkstra"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O((V + E) log V)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(V)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Shortest path (weighted)"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Bellman-Ford"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(V \xd7 E)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(V)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Negative weight edges"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Floyd-Warshall"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(V\xb3)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(V\xb2)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"All-pairs shortest paths"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Kruskal's MST"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(E log E)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(V)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Minimum spanning tree"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Prim's MST"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O((V + E) log V)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(V)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Minimum spanning tree (dense)"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Topological Sort"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(V + E)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(V)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Dependency resolution"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Tarjan's SCC"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(V + E)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(V)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Strongly connected components"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Union-Find"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(\u03b1(n)) per op"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(n)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Dynamic connectivity"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Max Flow"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(V \xd7 E\xb2)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(V\xb2)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Network flow problems"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Hungarian"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(n\xb3)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"O(n\xb2)"}),(0,t.jsx)(e.td,{style:{textAlign:"left"},children:"Assignment problems"})]})]})]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"advanced-applications",children:"Advanced Applications"}),"\n",(0,t.jsx)(e.h3,{id:"real-world-use-cases",children:"Real-World Use Cases"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Social Networks"}),": Community detection, influence analysis, recommendation systems[^1_4][^1_3]"]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Transportation"}),": Route optimization, traffic flow analysis, logistics planning[^1_5]"]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Biology"}),": Protein interaction networks, gene regulatory networks, phylogenetic analysis[^1_6]"]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Finance"}),": Risk assessment, fraud detection, market analysis[^1_3]"]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Machine Learning"}),": Graph neural networks, knowledge graphs, recommendation engines[^1_4][^1_3]"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"common-tricks--tips",children:"Common Tricks & Tips"}),"\n",(0,t.jsx)(e.h3,{id:"implementation-guidelines",children:"Implementation Guidelines"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Visited Array"}),": Always use for avoiding infinite loops"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Parent Tracking"}),": Essential for path reconstruction"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Distance Array"}),": Required for shortest path algorithms"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Indegree Array"}),": Critical for topological sort"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Dummy Source/Sink"}),": Simplifies multi-source problems"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Reverse Graph"}),": Used in Kosaraju's algorithm"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Bitmask DP"}),": For state compression in TSP-like problems"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Union-Find"}),": Optimal for dynamic connectivity queries"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Priority Queue"}),": Essential for Dijkstra and Prim's algorithms"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Level-Order BFS"}),": Use queue size for level tracking"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"interview-preparation",children:"Interview Preparation"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Most Important Patterns"}),": DFS/BFS traversals, shortest path algorithms, and Union-Find are fundamental for technical interviews"]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"System Design Applications"}),": Understanding graph algorithms is crucial for designing scalable backend systems, especially for social networks, recommendation systems, and distributed systems"]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Java-Specific"}),": Focus on ArrayList representations, PriorityQueue usage, and efficient data structure choices for competitive programming"]}),"\n",(0,t.jsx)(e.p,{children:"This comprehensive reference provides both fundamental concepts and advanced techniques essential for mastering graph algorithms in technical interviews and real-world applications."})]})}function c(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(h,{...n})}):h(n)}},28453:(n,e,i)=>{i.d(e,{R:()=>s,x:()=>o});var t=i(96540);const r={},a=t.createContext(r);function s(n){const e=t.useContext(a);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:s(n.components),t.createElement(a.Provider,{value:e},n.children)}}}]);