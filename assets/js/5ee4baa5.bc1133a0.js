"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[6535],{8759:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>a,contentTitle:()=>s,default:()=>u,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var o=n(4848),t=n(8453);const i={title:"Topological Sort Tutorial",description:"A comprehensive guide to Topological Sort with code examples in JavaScript."},s="Topological Sort Tutorial",l={id:"DSA/TopologicalSort",title:"Topological Sort Tutorial",description:"A comprehensive guide to Topological Sort with code examples in JavaScript.",source:"@site/docs/DSA/TopologicalSort.mdx",sourceDirName:"DSA",slug:"/DSA/TopologicalSort",permalink:"/js.enigma/docs/DSA/TopologicalSort",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/TopologicalSort.mdx",tags:[],version:"current",frontMatter:{title:"Topological Sort Tutorial",description:"A comprehensive guide to Topological Sort with code examples in JavaScript."},sidebar:"tutorialSidebar",previous:{title:"Suffix Automaton",permalink:"/js.enigma/docs/DSA/SuffixAutomata"},next:{title:"TreeMap",permalink:"/js.enigma/docs/DSA/TreeMap"}},a={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Key Concepts",id:"key-concepts",level:2},{value:"Algorithms for Topological Sort",id:"algorithms-for-topological-sort",level:2},{value:"1. Kahn&#39;s Algorithm",id:"1-kahns-algorithm",level:3},{value:"2. Depth-First Search (DFS) Based Algorithm",id:"2-depth-first-search-dfs-based-algorithm",level:3},{value:"Kahn&#39;s Algorithm Implementation",id:"kahns-algorithm-implementation",level:2},{value:"Topological sorting using DFS",id:"topological-sorting-using-dfs",level:2},{value:"207. Course Schedule",id:"207-course-schedule",level:2},{value:"210. Course Schedule II",id:"210-course-schedule-ii",level:2}];function d(e){const r={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(r.header,{children:(0,o.jsx)(r.h1,{id:"topological-sort-tutorial",children:"Topological Sort Tutorial"})}),"\n",(0,o.jsx)(r.h2,{id:"introduction",children:"Introduction"}),"\n",(0,o.jsx)(r.p,{children:"Topological Sort is an algorithm used to order the vertices of a Directed Acyclic Graph (DAG) in a linear sequence. In this sequence, for every directed edge ( uv ) from vertex ( u ) to vertex ( v ), ( u ) comes before ( v ). This sorting is useful in scenarios where you need to schedule tasks or resolve dependencies."}),"\n",(0,o.jsx)(r.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,o.jsxs)(r.ol,{children:["\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Directed Acyclic Graph (DAG)"}),": A graph with directed edges and no cycles."]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Topological Order"}),": A linear ordering of vertices such that for every directed edge ( uv ), vertex ( u ) comes before vertex ( v )."]}),"\n"]}),"\n",(0,o.jsx)(r.h2,{id:"algorithms-for-topological-sort",children:"Algorithms for Topological Sort"}),"\n",(0,o.jsx)(r.h3,{id:"1-kahns-algorithm",children:"1. Kahn's Algorithm"}),"\n",(0,o.jsx)(r.p,{children:"Kahn's Algorithm uses the concept of in-degrees (number of incoming edges) to determine the order of vertices. It is suitable for finding a topological sort using Breadth-First Search (BFS)."}),"\n",(0,o.jsx)(r.h3,{id:"2-depth-first-search-dfs-based-algorithm",children:"2. Depth-First Search (DFS) Based Algorithm"}),"\n",(0,o.jsx)(r.p,{children:"The DFS-based algorithm uses a stack to store the vertices in the topological order. It is suitable for finding a topological sort using Depth-First Search (DFS)."}),"\n",(0,o.jsx)(r.h2,{id:"kahns-algorithm-implementation",children:"Kahn's Algorithm Implementation"}),"\n",(0,o.jsx)(r.p,{children:"Here\u2019s a JavaScript implementation of Kahn\u2019s Algorithm for Topological Sort:"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-javascript",children:"function topologicalSortKahn(graph) {\r\n  const inDegree = new Array(graph.length).fill(0);\r\n  const queue = [];\r\n  const result = [];\r\n\r\n  // Compute the in-degrees of all vertices\r\n  for (let u = 0; u < graph.length; u++) {\r\n    for (const v of graph[u]) {\r\n      inDegree[v]++;\r\n    }\r\n  }\r\n\r\n  // Add vertices with in-degree 0 to the queue\r\n  for (let i = 0; i < inDegree.length; i++) {\r\n    if (inDegree[i] === 0) {\r\n      queue.push(i);\r\n    }\r\n  }\r\n\r\n  // Process the vertices in the queue\r\n  while (queue.length > 0) {\r\n    const u = queue.shift();\r\n    result.push(u);\r\n\r\n    for (const v of graph[u]) {\r\n      inDegree[v]--;\r\n      if (inDegree[v] === 0) {\r\n        queue.push(v);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Check for cycles (if result length != graph length)\r\n  if (result.length !== graph.length) {\r\n    throw new Error('The graph contains a cycle');\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n// Example Usage\r\nconst graph = [\r\n  [1, 2], // 0 -> 1, 0 -> 2\r\n  [2],    // 1 -> 2\r\n  []      // 2\r\n];\r\n\r\nconsole.log(topologicalSortKahn(graph)); // Output: [0, 1, 2] or [0, 2, 1]\n"})}),"\n",(0,o.jsx)(r.h2,{id:"topological-sorting-using-dfs",children:"Topological sorting using DFS"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-JavaScript",children:"function topologicalSort(graph) {\r\n  const visited = new Set(); // Tracks visited nodes\r\n  const stack = []; // Stores the topological order\r\n\r\n  // Helper function for DFS\r\n  function dfs(node) {\r\n    if (visited.has(node)) return; // If already visited, skip\r\n    visited.add(node); // Mark node as visited\r\n\r\n    // Visit all its neighbors\r\n    for (const neighbor of graph[node]) {\r\n      dfs(neighbor);\r\n    }\r\n\r\n    // Add the node to the stack when finished\r\n    stack.push(node);\r\n  }\r\n\r\n  // Iterate through all nodes in the graph\r\n  for (const node of Object.keys(graph).map(Number)) {\r\n    if (!visited.has(node)) {\r\n      dfs(node);\r\n    }\r\n  }\r\n\r\n  // Reverse the stack to get the correct topological order\r\n  return stack.reverse();\r\n}\r\n\r\n// Example usage\r\nconst graph = {\r\n  5: [2, 0],\r\n  4: [0, 1],\r\n  2: [3],\r\n  3: [1],\r\n  0: [],\r\n  1: []\r\n};\r\n\r\nconsole.log(topologicalSort(graph));\r\n// Output: [5, 4, 2, 3, 1, 0] (One valid order)\n"})}),"\n",(0,o.jsx)(r.h2,{id:"207-course-schedule",children:"207. Course Schedule"}),"\n",(0,o.jsx)(r.p,{children:"/*\r\n0: Not visited\r\n1: Visiting (current DFS path)\r\n2: Fully visited (processed)\r\n*/"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-JavaScript",children:"function canFinish(numCourses, prerequisites) {\r\n  const graph = Array.from({ length: numCourses }, () => []);\r\n  const visited = new Array(numCourses).fill(0);\r\n\r\n  // Build adjacency list\r\n  for (const [course, prereq] of prerequisites) {\r\n    graph[prereq].push(course);\r\n  }\r\n\r\n  // Helper function for DFS\r\n  function dfs(course) {\r\n    if (visited[course] === 1) return false; // Cycle detected\r\n    if (visited[course] === 2) return true;  // Already processed\r\n\r\n    visited[course] = 1; // Mark as visiting\r\n\r\n    for (const nextCourse of graph[course]) {\r\n      if (!dfs(nextCourse)) return false;\r\n    }\r\n\r\n    visited[course] = 2; // Mark as fully visited\r\n    return true;\r\n  }\r\n\r\n  // Check all courses\r\n  for (let i = 0; i < numCourses; i++) {\r\n    if (!dfs(i)) return false;\r\n  }\r\n\r\n  return true;\r\n}\n"})}),"\n",(0,o.jsx)(r.h2,{id:"210-course-schedule-ii",children:"210. Course Schedule II"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-JavaScript",children:"/**\r\n * @param {number} numCourses\r\n * @param {number[][]} prerequisites\r\n * @return {boolean}\r\n */\r\nvar findOrder = function (numCourses, prerequisites) {\r\n  const visited = {}\r\n  const graph = {}\r\n  const res = []\r\n\r\n  for (let i = 0; i < numCourses; i++) {\r\n    visited[i] = 0 //Unvisited\r\n    graph[i] = []\r\n  }\r\n\r\n  for (const [u, v] of prerequisites) {\r\n    graph[v].push(u)\r\n  }\r\n\r\n  const dfs = (node) => {\r\n    if (visited[node] === 1) return false //Visiting\r\n    if (visited[node] === -1) return true //Visited\r\n    visited[node] = 1\r\n\r\n    for (const nbr of graph[node]) {\r\n      if (!dfs(nbr)) return false\r\n    }\r\n\r\n    visited[node] = -1\r\n    res.push(node)\r\n    return true\r\n  }\r\n\r\n  for (let i = 0; i < numCourses; i++) {\r\n    if (visited[i] === 0 && !dfs(i)) return []\r\n  }\r\n  return res.reverse()\r\n};\n"})})]})}function u(e={}){const{wrapper:r}={...(0,t.R)(),...e.components};return r?(0,o.jsx)(r,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>s,x:()=>l});var o=n(6540);const t={},i=o.createContext(t);function s(e){const r=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function l(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),o.createElement(i.Provider,{value:r},e.children)}}}]);