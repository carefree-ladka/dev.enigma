"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[6828],{28453:(n,e,i)=>{i.d(e,{R:()=>o,x:()=>a});var s=i(96540);const t={},r=s.createContext(t);function o(n){const e=s.useContext(r);return s.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:o(n.components),s.createElement(r.Provider,{value:e},n.children)}},49332:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>a,toc:()=>c});var s=i(74848),t=i(28453);const r={},o="Bit Manipulation",a={id:"DSA/DSA with JavaScript/DSA Cheatsheets/Bit Manipulation",title:"Bit Manipulation",description:"A comprehensive guide to bit manipulation algorithms and techniques for Data Structures and Algorithms.",source:"@site/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Bit Manipulation.mdx",sourceDirName:"DSA/DSA with JavaScript/DSA Cheatsheets",slug:"/DSA/DSA with JavaScript/DSA Cheatsheets/Bit Manipulation",permalink:"/dev.enigma/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Bit Manipulation",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Bit Manipulation.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Binary Tree View Implementations",permalink:"/dev.enigma/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Binary Tree View Implementations"},next:{title:"Dynamic Programming",permalink:"/dev.enigma/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Dynamic Programming"}},l={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Binary Basics and Operations",id:"binary-basics-and-operations",level:2},{value:"Binary Number System",id:"binary-number-system",level:3},{value:"Basic Bitwise Operations",id:"basic-bitwise-operations",level:3},{value:"Helper Functions",id:"helper-functions",level:3},{value:"Essential Bit Manipulation Techniques",id:"essential-bit-manipulation-techniques",level:2},{value:"1. Check if Number is Even or Odd",id:"1-check-if-number-is-even-or-odd",level:3},{value:"2. Multiply and Divide by Powers of 2",id:"2-multiply-and-divide-by-powers-of-2",level:3},{value:"3. Swap Two Numbers",id:"3-swap-two-numbers",level:3},{value:"4. Find Absolute Value",id:"4-find-absolute-value",level:3},{value:"5. Check if Two Numbers Have Same Sign",id:"5-check-if-two-numbers-have-same-sign",level:3},{value:"Single Number Problems",id:"single-number-problems",level:2},{value:"1. Single Number I",id:"1-single-number-i",level:3},{value:"2. Single Number II",id:"2-single-number-ii",level:3},{value:"3. Single Number III",id:"3-single-number-iii",level:3},{value:"Bit Counting and Parity",id:"bit-counting-and-parity",level:2},{value:"1. Count Set Bits (Hamming Weight)",id:"1-count-set-bits-hamming-weight",level:3},{value:"2. Check Parity (Even/Odd number of 1s)",id:"2-check-parity-evenodd-number-of-1s",level:3},{value:"3. Find Position of Rightmost Set Bit",id:"3-find-position-of-rightmost-set-bit",level:3},{value:"Power of Two Operations",id:"power-of-two-operations",level:2},{value:"1. Check if Power of Two",id:"1-check-if-power-of-two",level:3},{value:"2. Next Power of Two",id:"2-next-power-of-two",level:3},{value:"3. Previous Power of Two",id:"3-previous-power-of-two",level:3},{value:"4. Find Log Base 2",id:"4-find-log-base-2",level:3},{value:"Subset Generation",id:"subset-generation",level:2},{value:"1. Generate All Subsets",id:"1-generate-all-subsets",level:3},{value:"2. Generate K-Size Subsets",id:"2-generate-k-size-subsets",level:3},{value:"3. Iterate Through Subsets of a Set",id:"3-iterate-through-subsets-of-a-set",level:3},{value:"Binary Tree and Graph Applications",id:"binary-tree-and-graph-applications",level:2},{value:"1. Binary Tree Path Sum",id:"1-binary-tree-path-sum",level:3},{value:"2. Graph Coloring with Bitmask",id:"2-graph-coloring-with-bitmask",level:3},{value:"3. Traveling Salesman with Bitmask DP",id:"3-traveling-salesman-with-bitmask-dp",level:3},{value:"Advanced Bit Tricks",id:"advanced-bit-tricks",level:2},{value:"1. Reverse Bits",id:"1-reverse-bits",level:3},{value:"2. Gray Code Generation",id:"2-gray-code-generation",level:3},{value:"3. Find Missing Number",id:"3-find-missing-number",level:3},{value:"4. Maximum XOR of Two Numbers",id:"4-maximum-xor-of-two-numbers",level:3},{value:"Common Bit Patterns",id:"common-bit-patterns",level:2},{value:"1. Bit Manipulation Patterns",id:"1-bit-manipulation-patterns",level:3},{value:"2. Common Bitmask Patterns",id:"2-common-bitmask-patterns",level:3},{value:"Usage Examples",id:"usage-examples",level:2},{value:"Time Complexity Summary",id:"time-complexity-summary",level:2},{value:"Key Patterns to Remember",id:"key-patterns-to-remember",level:2},{value:"1. <strong>XOR Properties</strong>",id:"1-xor-properties",level:3},{value:"2. <strong>Bit Isolation</strong>",id:"2-bit-isolation",level:3},{value:"3. <strong>Power of 2 Check</strong>",id:"3-power-of-2-check",level:3},{value:"4. <strong>Bitmask for Subsets</strong>",id:"4-bitmask-for-subsets",level:3},{value:"5. <strong>Bit Counting Optimization</strong>",id:"5-bit-counting-optimization",level:3},{value:"Common Interview Patterns",id:"common-interview-patterns",level:2},{value:"1. <strong>State Compression</strong>",id:"1-state-compression",level:3},{value:"2. <strong>Set Operations</strong>",id:"2-set-operations",level:3},{value:"3. <strong>Parity and Checksums</strong>",id:"3-parity-and-checksums",level:3},{value:"4. <strong>Optimization Tricks</strong>",id:"4-optimization-tricks",level:3},{value:"Interview Tips",id:"interview-tips",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"bit-manipulation",children:"Bit Manipulation"})}),"\n",(0,s.jsx)(e.p,{children:"A comprehensive guide to bit manipulation algorithms and techniques for Data Structures and Algorithms."}),"\n",(0,s.jsx)(e.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#binary-basics-and-operations",children:"Binary Basics and Operations"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#essential-bit-manipulation-techniques",children:"Essential Bit Manipulation Techniques"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#single-number-problems",children:"Single Number Problems"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#bit-counting-and-parity",children:"Bit Counting and Parity"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#power-of-two-operations",children:"Power of Two Operations"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#subset-generation",children:"Subset Generation"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#binary-tree-and-graph-applications",children:"Binary Tree and Graph Applications"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#advanced-bit-tricks",children:"Advanced Bit Tricks"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#common-bit-patterns",children:"Common Bit Patterns"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#usage-examples",children:"Usage Examples"})}),"\n"]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"binary-basics-and-operations",children:"Binary Basics and Operations"}),"\n",(0,s.jsx)(e.p,{children:"Understanding binary representation and basic operations is fundamental to bit manipulation."}),"\n",(0,s.jsx)(e.h3,{id:"binary-number-system",children:"Binary Number System"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:'// Binary representation examples\nconsole.log((5).toString(2));    // "101"\nconsole.log((15).toString(2));   // "1111"\nconsole.log(parseInt("101", 2)); // 5\n\n// Common powers of 2\nconst powers = {\n    1: 0b1,        // 2^0 = 1\n    2: 0b10,       // 2^1 = 2\n    4: 0b100,      // 2^2 = 4\n    8: 0b1000,     // 2^3 = 8\n    16: 0b10000,   // 2^4 = 16\n    32: 0b100000,  // 2^5 = 32\n};\n'})}),"\n",(0,s.jsx)(e.h3,{id:"basic-bitwise-operations",children:"Basic Bitwise Operations"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"// AND (&) - Both bits must be 1\nconsole.log(5 & 3);  // 101 & 011 = 001 = 1\n\n// OR (|) - At least one bit must be 1\nconsole.log(5 | 3);  // 101 | 011 = 111 = 7\n\n// XOR (^) - Bits must be different\nconsole.log(5 ^ 3);  // 101 ^ 011 = 110 = 6\n\n// NOT (~) - Flip all bits\nconsole.log(~5);     // ~101 = ...11111010 = -6 (two's complement)\n\n// Left Shift (<<) - Multiply by 2^n\nconsole.log(5 << 1); // 101 << 1 = 1010 = 10\n\n// Right Shift (>>) - Divide by 2^n\nconsole.log(10 >> 1); // 1010 >> 1 = 101 = 5\n\n// Unsigned Right Shift (>>>) - Fill with zeros\nconsole.log(-5 >>> 1); // Fills with 0s from left\n"})}),"\n",(0,s.jsx)(e.h3,{id:"helper-functions",children:"Helper Functions"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"// Get bit at position i (0-indexed from right)\nfunction getBit(num, i) {\n    return (num & (1 << i)) !== 0;\n}\n\n// Set bit at position i to 1\nfunction setBit(num, i) {\n    return num | (1 << i);\n}\n\n// Clear bit at position i (set to 0)\nfunction clearBit(num, i) {\n    return num & ~(1 << i);\n}\n\n// Toggle bit at position i\nfunction toggleBit(num, i) {\n    return num ^ (1 << i);\n}\n\n// Update bit at position i with value\nfunction updateBit(num, i, value) {\n    return value ? setBit(num, i) : clearBit(num, i);\n}\n\n// Print binary representation (for debugging)\nfunction printBinary(num, bits = 8) {\n    return num.toString(2).padStart(bits, '0');\n}\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"essential-bit-manipulation-techniques",children:"Essential Bit Manipulation Techniques"}),"\n",(0,s.jsx)(e.h3,{id:"1-check-if-number-is-even-or-odd",children:"1. Check if Number is Even or Odd"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function isEven(num) {\n    return (num & 1) === 0;\n}\n\nfunction isOdd(num) {\n    return (num & 1) === 1;\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Time Complexity:"})," O(1) | ",(0,s.jsx)(e.strong,{children:"Space Complexity:"})," O(1)"]}),"\n",(0,s.jsx)(e.h3,{id:"2-multiply-and-divide-by-powers-of-2",children:"2. Multiply and Divide by Powers of 2"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"// Multiply by 2^n\nfunction multiplyByPowerOf2(num, n) {\n    return num << n;\n}\n\n// Divide by 2^n\nfunction divideByPowerOf2(num, n) {\n    return num >> n;\n}\n\n// Examples\nconsole.log(multiplyByPowerOf2(5, 2)); // 5 * 4 = 20\nconsole.log(divideByPowerOf2(20, 2));  // 20 / 4 = 5\n"})}),"\n",(0,s.jsx)(e.h3,{id:"3-swap-two-numbers",children:"3. Swap Two Numbers"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function swapWithoutTemp(a, b) {\n    a = a ^ b;\n    b = a ^ b; // b = (a^b)^b = a\n    a = a ^ b; // a = (a^b)^a = b\n    return [a, b];\n}\n\n// One-liner version\nfunction swap(a, b) {\n    return [a ^ b, a ^ (a ^ b)];\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"4-find-absolute-value",children:"4. Find Absolute Value"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function absoluteValue(num) {\n    const mask = num >> 31; // Get sign bit (all 1s if negative, all 0s if positive)\n    return (num + mask) ^ mask;\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"5-check-if-two-numbers-have-same-sign",children:"5. Check if Two Numbers Have Same Sign"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function haveSameSign(a, b) {\n    return (a ^ b) >= 0;\n}\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"single-number-problems",children:"Single Number Problems"}),"\n",(0,s.jsx)(e.p,{children:"These are classic interview problems that showcase the power of XOR operations."}),"\n",(0,s.jsx)(e.h3,{id:"1-single-number-i",children:"1. Single Number I"}),"\n",(0,s.jsx)(e.p,{children:"Find the number that appears once when all others appear twice:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function singleNumber(nums) {\n    let result = 0;\n    for (const num of nums) {\n        result ^= num;\n    }\n    return result;\n}\n\n// Example: [2,2,1] \u2192 1\n// 2 ^ 2 ^ 1 = 0 ^ 1 = 1\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Time Complexity:"})," O(n) | ",(0,s.jsx)(e.strong,{children:"Space Complexity:"})," O(1)"]}),"\n",(0,s.jsx)(e.h3,{id:"2-single-number-ii",children:"2. Single Number II"}),"\n",(0,s.jsx)(e.p,{children:"Find the number that appears once when all others appear three times:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function singleNumberII(nums) {\n    let ones = 0, twos = 0;\n\n    for (const num of nums) {\n        ones = (ones ^ num) & ~twos;\n        twos = (twos ^ num) & ~ones;\n    }\n\n    return ones;\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"3-single-number-iii",children:"3. Single Number III"}),"\n",(0,s.jsx)(e.p,{children:"Find two numbers that appear once when all others appear twice:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function singleNumberIII(nums) {\n    let xor = 0;\n    for (const num of nums) {\n        xor ^= num;\n    }\n\n    // Find rightmost set bit\n    const rightmostBit = xor & (-xor);\n\n    let num1 = 0, num2 = 0;\n    for (const num of nums) {\n        if (num & rightmostBit) {\n            num1 ^= num;\n        } else {\n            num2 ^= num;\n        }\n    }\n\n    return [num1, num2];\n}\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"bit-counting-and-parity",children:"Bit Counting and Parity"}),"\n",(0,s.jsx)(e.h3,{id:"1-count-set-bits-hamming-weight",children:"1. Count Set Bits (Hamming Weight)"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Method 1: Brian Kernighan's Algorithm"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function countSetBits(n) {\n    let count = 0;\n    while (n) {\n        n &= (n - 1); // Remove rightmost set bit\n        count++;\n    }\n    return count;\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Method 2: Built-in Method"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function countSetBitsBuiltIn(n) {\n    return n.toString(2).split('1').length - 1;\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Method 3: Lookup Table"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function countSetBitsLookup(n) {\n    const table = [0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4];\n    let count = 0;\n\n    while (n) {\n        count += table[n & 0xF]; // Check last 4 bits\n        n >>= 4;\n    }\n\n    return count;\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"2-check-parity-evenodd-number-of-1s",children:"2. Check Parity (Even/Odd number of 1s)"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function hasEvenParity(n) {\n    let parity = 0;\n    while (n) {\n        parity ^= 1;\n        n &= (n - 1);\n    }\n    return parity === 0;\n}\n\n// Optimized version using built-in\nfunction hasEvenParityFast(n) {\n    return (countSetBits(n) & 1) === 0;\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"3-find-position-of-rightmost-set-bit",children:"3. Find Position of Rightmost Set Bit"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function rightmostSetBit(n) {\n    if (n === 0) return -1;\n\n    // Method 1: Using isolation\n    const isolated = n & (-n);\n    return Math.log2(isolated);\n}\n\nfunction rightmostSetBitPosition(n) {\n    let position = 1;\n    while ((n & 1) === 0) {\n        n >>= 1;\n        position++;\n    }\n    return position;\n}\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"power-of-two-operations",children:"Power of Two Operations"}),"\n",(0,s.jsx)(e.h3,{id:"1-check-if-power-of-two",children:"1. Check if Power of Two"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function isPowerOfTwo(n) {\n    return n > 0 && (n & (n - 1)) === 0;\n}\n\n// Examples:\n// 8 = 1000, 8-1 = 0111, 1000 & 0111 = 0000 \u2713\n// 6 = 0110, 6-1 = 0101, 0110 & 0101 = 0100 \u2717\n"})}),"\n",(0,s.jsx)(e.h3,{id:"2-next-power-of-two",children:"2. Next Power of Two"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function nextPowerOfTwo(n) {\n    if (n <= 1) return 1;\n\n    n--;\n    n |= n >> 1;\n    n |= n >> 2;\n    n |= n >> 4;\n    n |= n >> 8;\n    n |= n >> 16;\n\n    return n + 1;\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"3-previous-power-of-two",children:"3. Previous Power of Two"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function previousPowerOfTwo(n) {\n    if (n <= 1) return 1;\n\n    let power = 1;\n    while (power * 2 <= n) {\n        power *= 2;\n    }\n\n    return power;\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"4-find-log-base-2",children:"4. Find Log Base 2"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function log2Floor(n) {\n    if (n <= 0) return -1;\n\n    let result = 0;\n    while (n > 1) {\n        n >>= 1;\n        result++;\n    }\n\n    return result;\n}\n\n// Using built-in\nfunction log2FloorBuiltIn(n) {\n    return Math.floor(Math.log2(n));\n}\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"subset-generation",children:"Subset Generation"}),"\n",(0,s.jsx)(e.h3,{id:"1-generate-all-subsets",children:"1. Generate All Subsets"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function generateSubsets(nums) {\n    const n = nums.length;\n    const totalSubsets = 1 << n; // 2^n\n    const result = [];\n\n    for (let mask = 0; mask < totalSubsets; mask++) {\n        const subset = [];\n\n        for (let i = 0; i < n; i++) {\n            if (mask & (1 << i)) {\n                subset.push(nums[i]);\n            }\n        }\n\n        result.push(subset);\n    }\n\n    return result;\n}\n\n// Example: [1,2,3] generates:\n// 000 \u2192 []\n// 001 \u2192 [1]\n// 010 \u2192 [2]\n// 011 \u2192 [1,2]\n// 100 \u2192 [3]\n// 101 \u2192 [1,3]\n// 110 \u2192 [2,3]\n// 111 \u2192 [1,2,3]\n"})}),"\n",(0,s.jsx)(e.h3,{id:"2-generate-k-size-subsets",children:"2. Generate K-Size Subsets"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function generateKSizeSubsets(nums, k) {\n    const n = nums.length;\n    const result = [];\n\n    for (let mask = 0; mask < (1 << n); mask++) {\n        if (countSetBits(mask) === k) {\n            const subset = [];\n            for (let i = 0; i < n; i++) {\n                if (mask & (1 << i)) {\n                    subset.push(nums[i]);\n                }\n            }\n            result.push(subset);\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"3-iterate-through-subsets-of-a-set",children:"3. Iterate Through Subsets of a Set"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function iterateSubsets(mask) {\n    const subsets = [];\n    let submask = mask;\n\n    do {\n        subsets.push(submask);\n        submask = (submask - 1) & mask;\n    } while (submask !== mask);\n\n    return subsets;\n}\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"binary-tree-and-graph-applications",children:"Binary Tree and Graph Applications"}),"\n",(0,s.jsx)(e.h3,{id:"1-binary-tree-path-sum",children:"1. Binary Tree Path Sum"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function hasPathSum(root, targetSum) {\n    function dfs(node, currentPath, currentSum) {\n        if (!node) return false;\n\n        currentPath = currentPath * 2 + (node.val % 2);\n        currentSum += node.val;\n\n        if (!node.left && !node.right) {\n            return currentSum === targetSum;\n        }\n\n        return dfs(node.left, currentPath, currentSum) ||\n               dfs(node.right, currentPath, currentSum);\n    }\n\n    return dfs(root, 0, 0);\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"2-graph-coloring-with-bitmask",children:"2. Graph Coloring with Bitmask"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function canColor(graph, colors) {\n    const n = graph.length;\n    const dp = new Array(1 << n).fill(0);\n    dp[0] = 1;\n\n    for (let mask = 0; mask < (1 << n); mask++) {\n        if (dp[mask] === 0) continue;\n\n        const node = countSetBits(mask);\n        if (node === n) return true;\n\n        for (let color = 1; color <= colors; color++) {\n            let canUseColor = true;\n\n            for (let neighbor of graph[node]) {\n                if ((mask & (1 << neighbor)) &&\n                    ((dp[mask] >> (neighbor * 2)) & 3) === color) {\n                    canUseColor = false;\n                    break;\n                }\n            }\n\n            if (canUseColor) {\n                const newMask = mask | (1 << node);\n                dp[newMask] = dp[mask] | (color << (node * 2));\n            }\n        }\n    }\n\n    return false;\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"3-traveling-salesman-with-bitmask-dp",children:"3. Traveling Salesman with Bitmask DP"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function tsp(graph) {\n    const n = graph.length;\n    const dp = Array.from({ length: 1 << n },\n        () => new Array(n).fill(Infinity));\n\n    dp[1][0] = 0; // Start from city 0\n\n    for (let mask = 1; mask < (1 << n); mask++) {\n        for (let u = 0; u < n; u++) {\n            if (!(mask & (1 << u))) continue;\n\n            for (let v = 0; v < n; v++) {\n                if (u === v || !(mask & (1 << v))) continue;\n\n                const prevMask = mask ^ (1 << u);\n                if (dp[prevMask][v] !== Infinity) {\n                    dp[mask][u] = Math.min(dp[mask][u],\n                        dp[prevMask][v] + graph[v][u]);\n                }\n            }\n        }\n    }\n\n    let result = Infinity;\n    const finalMask = (1 << n) - 1;\n\n    for (let i = 1; i < n; i++) {\n        if (dp[finalMask][i] !== Infinity) {\n            result = Math.min(result, dp[finalMask][i] + graph[i][0]);\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"advanced-bit-tricks",children:"Advanced Bit Tricks"}),"\n",(0,s.jsx)(e.h3,{id:"1-reverse-bits",children:"1. Reverse Bits"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function reverseBits(n) {\n    let result = 0;\n\n    for (let i = 0; i < 32; i++) {\n        result = (result << 1) | (n & 1);\n        n >>= 1;\n    }\n\n    return result >>> 0; // Convert to unsigned 32-bit\n}\n\n// Optimized version using lookup table\nfunction reverseBitsLookup(n) {\n    const lookup = new Array(256);\n\n    // Initialize lookup table\n    for (let i = 0; i < 256; i++) {\n        let rev = 0;\n        for (let j = 0; j < 8; j++) {\n            if (i & (1 << j)) {\n                rev |= 1 << (7 - j);\n            }\n        }\n        lookup[i] = rev;\n    }\n\n    return (lookup[n & 0xFF] << 24) |\n           (lookup[(n >> 8) & 0xFF] << 16) |\n           (lookup[(n >> 16) & 0xFF] << 8) |\n           (lookup[(n >> 24) & 0xFF]);\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"2-gray-code-generation",children:"2. Gray Code Generation"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function grayCode(n) {\n    const result = [];\n    const totalCodes = 1 << n;\n\n    for (let i = 0; i < totalCodes; i++) {\n        result.push(i ^ (i >> 1));\n    }\n\n    return result;\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"3-find-missing-number",children:"3. Find Missing Number"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function findMissingNumber(nums) {\n    const n = nums.length;\n    let missing = n; // Start with n\n\n    for (let i = 0; i < n; i++) {\n        missing ^= i ^ nums[i];\n    }\n\n    return missing;\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"4-maximum-xor-of-two-numbers",children:"4. Maximum XOR of Two Numbers"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function findMaximumXOR(nums) {\n    let maxResult = 0;\n    let mask = 0;\n\n    for (let i = 30; i >= 0; i--) {\n        mask |= (1 << i);\n        const prefixes = new Set();\n\n        for (const num of nums) {\n            prefixes.add(num & mask);\n        }\n\n        const candidate = maxResult | (1 << i);\n\n        for (const prefix of prefixes) {\n            if (prefixes.has(candidate ^ prefix)) {\n                maxResult = candidate;\n                break;\n            }\n        }\n    }\n\n    return maxResult;\n}\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"common-bit-patterns",children:"Common Bit Patterns"}),"\n",(0,s.jsx)(e.h3,{id:"1-bit-manipulation-patterns",children:"1. Bit Manipulation Patterns"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"// Check if bit i is set\nconst isSet = (num, i) => (num & (1 << i)) !== 0;\n\n// Set bit i\nconst setBit = (num, i) => num | (1 << i);\n\n// Clear bit i\nconst clearBit = (num, i) => num & ~(1 << i);\n\n// Toggle bit i\nconst toggleBit = (num, i) => num ^ (1 << i);\n\n// Clear all bits from i to 0\nconst clearBitsFromITo0 = (num, i) => num & (~((1 << (i + 1)) - 1));\n\n// Clear all bits from MSB to i\nconst clearBitsFromMSBToI = (num, i) => num & ((1 << i) - 1);\n\n// Get rightmost set bit\nconst getRightmostSetBit = (num) => num & (-num);\n\n// Clear rightmost set bit\nconst clearRightmostSetBit = (num) => num & (num - 1);\n\n// Check if only one bit is set (power of 2)\nconst isOnlyOneBitSet = (num) => num > 0 && (num & (num - 1)) === 0;\n"})}),"\n",(0,s.jsx)(e.h3,{id:"2-common-bitmask-patterns",children:"2. Common Bitmask Patterns"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"// Full mask with n bits\nconst fullMask = (n) => (1 << n) - 1;\n\n// Alternating pattern masks\nconst alternating1 = 0x55555555; // 01010101...\nconst alternating2 = 0xAAAAAAAA; // 10101010...\n\n// Every 2nd bit pattern\nconst every2ndBit = 0x33333333; // 00110011...\n\n// Every 4th bit pattern\nconst every4thBit = 0x0F0F0F0F; // 00001111...\n\n// Check if mask is subset of another mask\nconst isSubset = (subset, superset) => (subset & superset) === subset;\n\n// Get complement of mask\nconst complement = (mask, totalBits) => (~mask) & ((1 << totalBits) - 1);\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,s.jsx)(e.p,{children:"Here's how to use these bit manipulation techniques:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:'console.log("=== Bit Manipulation Techniques Demo ===");\n\n// Basic operations\nconsole.log("5 in binary:", printBinary(5, 4));        // 0101\nconsole.log("3 in binary:", printBinary(3, 4));        // 0011\nconsole.log("5 & 3 =", 5 & 3, printBinary(5 & 3, 4)); // 1, 0001\nconsole.log("5 | 3 =", 5 | 3, printBinary(5 | 3, 4)); // 7, 0111\nconsole.log("5 ^ 3 =", 5 ^ 3, printBinary(5 ^ 3, 4)); // 6, 0110\n\n// Bit manipulation functions\nconsole.log("Get bit 2 of 5:", getBit(5, 2));          // true (101, bit 2 is 1)\nconsole.log("Set bit 1 of 5:", setBit(5, 1));          // 7 (101 -> 111)\nconsole.log("Clear bit 2 of 5:", clearBit(5, 2));      // 1 (101 -> 001)\nconsole.log("Toggle bit 1 of 5:", toggleBit(5, 1));    // 7 (101 -> 111)\n\n// Power of 2 operations\nconsole.log("Is 8 power of 2:", isPowerOfTwo(8));      // true\nconsole.log("Is 6 power of 2:", isPowerOfTwo(6));      // false\nconsole.log("Next power of 2 after 10:", nextPowerOfTwo(10)); // 16\n\n// Counting operations\nconsole.log("Count set bits in 7:", countSetBits(7));   // 3 (111 has 3 ones)\nconsole.log("Count set bits in 8:", countSetBits(8));   // 1 (1000 has 1 one)\n\n// Single number problems\nconsole.log("Single number in [2,2,1]:", singleNumber([2,2,1])); // 1\nconsole.log("Single numbers in [1,2,1,3,2,5]:", singleNumberIII([1,2,1,3,2,5])); // [3,5]\n\n// Subset generation\nconst nums = [1, 2, 3];\nconsole.log("All subsets of [1,2,3]:", generateSubsets(nums));\n\n// Advanced operations\nconsole.log("Reverse bits of 5:", reverseBits(5));\nconsole.log("Gray code for n=3:", grayCode(3));\n\n// Swap without temp\nlet a = 10, b = 20;\n[a, b] = swapWithoutTemp(a, b);\nconsole.log("After swap:", a, b); // 20, 10\n\n// Missing number\nconsole.log("Missing number in [3,0,1]:", findMissingNumber([3,0,1])); // 2\n\n// Practical applications\nconst bitmask = 0b1011; // 11 in decimal\nconsole.log("Iterating through subsets of", printBinary(bitmask, 4));\nconst subsets = iterateSubsets(bitmask);\nsubsets.forEach(subset => console.log("  Subset:", printBinary(subset, 4)));\n'})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"time-complexity-summary",children:"Time Complexity Summary"}),"\n",(0,s.jsxs)(e.table,{children:[(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"Operation"}),(0,s.jsx)(e.th,{children:"Time Complexity"}),(0,s.jsx)(e.th,{children:"Space Complexity"})]})}),(0,s.jsxs)(e.tbody,{children:[(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Basic Bit Operations"}),(0,s.jsx)(e.td,{children:"O(1)"}),(0,s.jsx)(e.td,{children:"O(1)"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Count Set Bits"}),(0,s.jsx)(e.td,{children:"O(log n)"}),(0,s.jsx)(e.td,{children:"O(1)"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Check Power of 2"}),(0,s.jsx)(e.td,{children:"O(1)"}),(0,s.jsx)(e.td,{children:"O(1)"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Generate All Subsets"}),(0,s.jsx)(e.td,{children:"O(n \xd7 2^n)"}),(0,s.jsx)(e.td,{children:"O(2^n)"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Single Number"}),(0,s.jsx)(e.td,{children:"O(n)"}),(0,s.jsx)(e.td,{children:"O(1)"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Reverse Bits"}),(0,s.jsx)(e.td,{children:"O(log n)"}),(0,s.jsx)(e.td,{children:"O(1)"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Find Maximum XOR"}),(0,s.jsx)(e.td,{children:"O(n \xd7 log(max))"}),(0,s.jsx)(e.td,{children:"O(n)"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Gray Code"}),(0,s.jsx)(e.td,{children:"O(2^n)"}),(0,s.jsx)(e.td,{children:"O(2^n)"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Missing Number"}),(0,s.jsx)(e.td,{children:"O(n)"}),(0,s.jsx)(e.td,{children:"O(1)"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Subset Iteration"}),(0,s.jsx)(e.td,{children:"O(3^n)"}),(0,s.jsx)(e.td,{children:"O(1)"})]})]})]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"key-patterns-to-remember",children:"Key Patterns to Remember"}),"\n",(0,s.jsxs)(e.h3,{id:"1-xor-properties",children:["1. ",(0,s.jsx)(e.strong,{children:"XOR Properties"})]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.code,{children:"a ^ a = 0"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.code,{children:"a ^ 0 = a"})}),"\n",(0,s.jsx)(e.li,{children:"XOR is commutative and associative"}),"\n",(0,s.jsx)(e.li,{children:"Perfect for finding single numbers"}),"\n"]}),"\n",(0,s.jsxs)(e.h3,{id:"2-bit-isolation",children:["2. ",(0,s.jsx)(e.strong,{children:"Bit Isolation"})]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"// Get rightmost set bit\nconst rightmost = n & (-n);\n\n// Clear rightmost set bit\nconst cleared = n & (n - 1);\n"})}),"\n",(0,s.jsxs)(e.h3,{id:"3-power-of-2-check",children:["3. ",(0,s.jsx)(e.strong,{children:"Power of 2 Check"})]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"const isPowerOf2 = n > 0 && (n & (n - 1)) === 0;\n"})}),"\n",(0,s.jsxs)(e.h3,{id:"4-bitmask-for-subsets",children:["4. ",(0,s.jsx)(e.strong,{children:"Bitmask for Subsets"})]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"// Check if element i is in subset\nconst inSubset = (mask, i) => (mask & (1 << i)) !== 0;\n"})}),"\n",(0,s.jsxs)(e.h3,{id:"5-bit-counting-optimization",children:["5. ",(0,s.jsx)(e.strong,{children:"Bit Counting Optimization"})]}),"\n",(0,s.jsxs)(e.p,{children:["Use Brian Kernighan's algorithm: ",(0,s.jsx)(e.code,{children:"n & (n-1)"})," removes rightmost set bit"]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"common-interview-patterns",children:"Common Interview Patterns"}),"\n",(0,s.jsxs)(e.h3,{id:"1-state-compression",children:["1. ",(0,s.jsx)(e.strong,{children:"State Compression"})]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Use bitmasks to represent states in DP"}),"\n",(0,s.jsx)(e.li,{children:"Traveling salesman, subset sum, etc."}),"\n"]}),"\n",(0,s.jsxs)(e.h3,{id:"2-set-operations",children:["2. ",(0,s.jsx)(e.strong,{children:"Set Operations"})]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["Union: ",(0,s.jsx)(e.code,{children:"a | b"})]}),"\n",(0,s.jsxs)(e.li,{children:["Intersection: ",(0,s.jsx)(e.code,{children:"a & b"})]}),"\n",(0,s.jsxs)(e.li,{children:["Difference: ",(0,s.jsx)(e.code,{children:"a & (~b)"})]}),"\n"]}),"\n",(0,s.jsxs)(e.h3,{id:"3-parity-and-checksums",children:["3. ",(0,s.jsx)(e.strong,{children:"Parity and Checksums"})]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"XOR for detecting errors"}),"\n",(0,s.jsx)(e.li,{children:"Even/odd parity checks"}),"\n"]}),"\n",(0,s.jsxs)(e.h3,{id:"4-optimization-tricks",children:["4. ",(0,s.jsx)(e.strong,{children:"Optimization Tricks"})]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Multiply/divide by powers of 2 using shifts"}),"\n",(0,s.jsx)(e.li,{children:"Swap without temporary variables"}),"\n",(0,s.jsxs)(e.li,{children:["Fast modulo for powers of 2: ",(0,s.jsx)(e.code,{children:"n & (p-1)"})," where p is power of 2"]}),"\n"]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"interview-tips",children:"Interview Tips"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Master the basics"}),": AND, OR, XOR, shifts"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Know common patterns"}),": Power of 2, bit counting, XOR properties"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Practice visualization"}),": Draw out bit patterns"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Handle edge cases"}),": Zero, negative numbers, overflow"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Optimize when possible"}),": Bit operations are faster than arithmetic"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Use built-in functions wisely"}),": Sometimes clarity is better than bit tricks"]}),"\n"]})]})}function u(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}}}]);