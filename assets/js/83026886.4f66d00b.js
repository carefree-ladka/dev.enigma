"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[5242],{28453:(n,e,i)=>{i.d(e,{R:()=>a,x:()=>l});var t=i(96540);const r={},s=t.createContext(r);function a(n){const e=t.useContext(s);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:a(n.components),t.createElement(s.Provider,{value:e},n.children)}},66366:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>o,contentTitle:()=>a,default:()=>m,frontMatter:()=>s,metadata:()=>l,toc:()=>c});var t=i(74848),r=i(28453);const s={},a="Dynamic Programming",l={id:"DSA/DSA with JavaScript/DSA Cheatsheets/Dynamic Programming",title:"Dynamic Programming",description:"A comprehensive guide to dynamic programming algorithms and techniques for Data Structures and Algorithms.",source:"@site/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Dynamic Programming.mdx",sourceDirName:"DSA/DSA with JavaScript/DSA Cheatsheets",slug:"/DSA/DSA with JavaScript/DSA Cheatsheets/Dynamic Programming",permalink:"/dev.enigma/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Dynamic Programming",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Dynamic Programming.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Bit Manipulation",permalink:"/dev.enigma/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Bit Manipulation"},next:{title:"Graph",permalink:"/dev.enigma/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Graph"}},o={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Introduction to Dynamic Programming",id:"introduction-to-dynamic-programming",level:2},{value:"Core Concepts",id:"core-concepts",level:3},{value:"DP Approaches",id:"dp-approaches",level:3},{value:"Basic Template",id:"basic-template",level:3},{value:"Core Principles and Patterns",id:"core-principles-and-patterns",level:2},{value:"1. Decision Pattern",id:"1-decision-pattern",level:3},{value:"2. State Machine Pattern",id:"2-state-machine-pattern",level:3},{value:"3. Range Pattern",id:"3-range-pattern",level:3},{value:"1D Dynamic Programming",id:"1d-dynamic-programming",level:2},{value:"1. Fibonacci Sequence",id:"1-fibonacci-sequence",level:3},{value:"2. Climbing Stairs",id:"2-climbing-stairs",level:3},{value:"3. House Robber",id:"3-house-robber",level:3},{value:"4. House Robber II (Circular)",id:"4-house-robber-ii-circular",level:3},{value:"5. Maximum Subarray (Kadane&#39;s Algorithm)",id:"5-maximum-subarray-kadanes-algorithm",level:3},{value:"6. Coin Change",id:"6-coin-change",level:3},{value:"7. Perfect Squares",id:"7-perfect-squares",level:3},{value:"2D Dynamic Programming",id:"2d-dynamic-programming",level:2},{value:"1. Unique Paths",id:"1-unique-paths",level:3},{value:"2. Unique Paths II (With Obstacles)",id:"2-unique-paths-ii-with-obstacles",level:3},{value:"3. Minimum Path Sum",id:"3-minimum-path-sum",level:3},{value:"4. Longest Common Subsequence (LCS)",id:"4-longest-common-subsequence-lcs",level:3},{value:"5. 0/1 Knapsack",id:"5-01-knapsack",level:3},{value:"6. Edit Distance",id:"6-edit-distance",level:3},{value:"String Dynamic Programming",id:"string-dynamic-programming",level:2},{value:"1. Palindromic Substrings",id:"1-palindromic-substrings",level:3},{value:"2. Longest Palindromic Substring",id:"2-longest-palindromic-substring",level:3},{value:"3. Decode Ways",id:"3-decode-ways",level:3},{value:"4. Word Break",id:"4-word-break",level:3},{value:"Tree Dynamic Programming",id:"tree-dynamic-programming",level:2},{value:"1. Binary Tree Maximum Path Sum",id:"1-binary-tree-maximum-path-sum",level:3},{value:"2. House Robber III (Binary Tree)",id:"2-house-robber-iii-binary-tree",level:3},{value:"3. Diameter of Binary Tree",id:"3-diameter-of-binary-tree",level:3},{value:"Advanced DP Patterns",id:"advanced-dp-patterns",level:2},{value:"1. Matrix Chain Multiplication",id:"1-matrix-chain-multiplication",level:3},{value:"2. Burst Balloons",id:"2-burst-balloons",level:3},{value:"3. Regular Expression Matching",id:"3-regular-expression-matching",level:3},{value:"4. Wildcard Matching",id:"4-wildcard-matching",level:3},{value:"Space Optimization Techniques",id:"space-optimization-techniques",level:2},{value:"1. Rolling Array Pattern",id:"1-rolling-array-pattern",level:3},{value:"2. Single Array Optimization",id:"2-single-array-optimization",level:3},{value:"DP on Subsequences and Substrings",id:"dp-on-subsequences-and-substrings",level:2},{value:"1. Longest Increasing Subsequence",id:"1-longest-increasing-subsequence",level:3},{value:"2. Longest Common Substring",id:"2-longest-common-substring",level:3},{value:"3. Count Distinct Subsequences",id:"3-count-distinct-subsequences",level:3},{value:"4. Palindromic Subsequences",id:"4-palindromic-subsequences",level:3},{value:"Game Theory DP",id:"game-theory-dp",level:2},{value:"1. Stone Game",id:"1-stone-game",level:3},{value:"2. Predict the Winner",id:"2-predict-the-winner",level:3},{value:"3. Nim Game",id:"3-nim-game",level:3},{value:"Digit DP",id:"digit-dp",level:2},{value:"1. Count Numbers with Digit Sum",id:"1-count-numbers-with-digit-sum",level:3},{value:"2. Numbers At Most N Given Digit Set",id:"2-numbers-at-most-n-given-digit-set",level:3},{value:"Common Optimization Tricks",id:"common-optimization-tricks",level:2},{value:"1. State Compression",id:"1-state-compression",level:3},{value:"2. Coordinate Compression",id:"2-coordinate-compression",level:3},{value:"3. Monotonic Queue Optimization",id:"3-monotonic-queue-optimization",level:3},{value:"4. Convex Hull Trick",id:"4-convex-hull-trick",level:3},{value:"Problem-Solving Strategy",id:"problem-solving-strategy",level:2},{value:"1. Identify DP Problems",id:"1-identify-dp-problems",level:3},{value:"2. DP Development Process",id:"2-dp-development-process",level:3},{value:"3. Common Pitfalls",id:"3-common-pitfalls",level:3},{value:"4. Testing Strategy",id:"4-testing-strategy",level:3},{value:"Conclusion",id:"conclusion",level:2}];function d(n){const e={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"dynamic-programming",children:"Dynamic Programming"})}),"\n",(0,t.jsx)(e.p,{children:"A comprehensive guide to dynamic programming algorithms and techniques for Data Structures and Algorithms."}),"\n",(0,t.jsx)(e.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#introduction-to-dynamic-programming",children:"Introduction to Dynamic Programming"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#core-principles-and-patterns",children:"Core Principles and Patterns"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#1d-dynamic-programming",children:"1D Dynamic Programming"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#2d-dynamic-programming",children:"2D Dynamic Programming"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#string-dynamic-programming",children:"String Dynamic Programming"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#tree-dynamic-programming",children:"Tree Dynamic Programming"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#advanced-dp-patterns",children:"Advanced DP Patterns"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#space-optimization-techniques",children:"Space Optimization Techniques"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#dp-on-subsequences-and-substrings",children:"DP on Subsequences and Substrings"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#game-theory-dp",children:"Game Theory DP"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#digit-dp",children:"Digit DP"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"#common-optimization-tricks",children:"Common Optimization Tricks"})}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"introduction-to-dynamic-programming",children:"Introduction to Dynamic Programming"}),"\n",(0,t.jsx)(e.p,{children:"Dynamic Programming (DP) is an algorithmic technique for solving optimization problems by breaking them down into simpler subproblems. It is applicable when the subproblems overlap and have optimal substructure."}),"\n",(0,t.jsx)(e.h3,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Optimal Substructure:"})," The optimal solution to a problem contains optimal solutions to subproblems."]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Overlapping Subproblems:"})," The same subproblems are solved multiple times in a naive recursive approach."]}),"\n",(0,t.jsx)(e.h3,{id:"dp-approaches",children:"DP Approaches"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Top-Down (Memoization):"})," Solve recursively and cache results"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Bottom-Up (Tabulation):"})," Build solution iteratively from base cases"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"basic-template",children:"Basic Template"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Top-Down Memoization\nfunction dpTopDown(params, memo = new Map()) {\n  // Base case\n  if (baseCondition) return baseValue;\n\n  // Check memo\n  const key = createKey(params);\n  if (memo.has(key)) return memo.get(key);\n\n  // Recursive relation\n  let result = computeFromSubproblems();\n\n  // Store and return\n  memo.set(key, result);\n  return result;\n}\n\n// Bottom-Up Tabulation\nfunction dpBottomUp(params) {\n  // Initialize DP table\n  const dp = new Array(size).fill(baseValue);\n\n  // Fill base cases\n  dp[0] = baseValue;\n\n  // Fill DP table\n  for (let i = 1; i < size; i++) {\n    dp[i] = computeFromPrevious(dp, i);\n  }\n\n  return dp[size - 1];\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"core-principles-and-patterns",children:"Core Principles and Patterns"}),"\n",(0,t.jsx)(e.h3,{id:"1-decision-pattern",children:"1. Decision Pattern"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"When to use:"})," Problems involving choices at each step."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function decisionDP(i, state) {\n  if (i === n) return baseCase;\n\n  // Try all possible decisions\n  let result = initialValue;\n  for (const decision of possibleDecisions) {\n    const subResult = decisionDP(i + 1, newState);\n    result = optimize(result, subResult + cost);\n  }\n\n  return result;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-state-machine-pattern",children:"2. State Machine Pattern"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"When to use:"})," Problems with different states/modes."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function stateMachineDP(i, currentState) {\n  if (i === n) return baseCase;\n\n  let result = initialValue;\n  for (const nextState of possibleStates) {\n    if (canTransition(currentState, nextState)) {\n      const subResult = stateMachineDP(i + 1, nextState);\n      result = optimize(result, subResult + transitionCost);\n    }\n  }\n\n  return result;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-range-pattern",children:"3. Range Pattern"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"When to use:"})," Problems on intervals/ranges."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function rangeDP(left, right) {\n  if (left >= right) return baseCase;\n\n  let result = initialValue;\n  for (let k = left; k < right; k++) {\n    const leftResult = rangeDP(left, k);\n    const rightResult = rangeDP(k + 1, right);\n    result = optimize(result, leftResult + rightResult + mergeCost);\n  }\n\n  return result;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"1d-dynamic-programming",children:"1D Dynamic Programming"}),"\n",(0,t.jsx)(e.h3,{id:"1-fibonacci-sequence",children:"1. Fibonacci Sequence"}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Classic example of overlapping subproblems:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Top-Down\nfunction fibMemo(n, memo = {}) {\n  if (n <= 1) return n;\n  if (memo[n]) return memo[n];\n\n  memo[n] = fibMemo(n - 1, memo) + fibMemo(n - 2, memo);\n  return memo[n];\n}\n\n// Bottom-Up\nfunction fibTabulation(n) {\n  if (n <= 1) return n;\n\n  const dp = new Array(n + 1);\n  dp[0] = 0;\n  dp[1] = 1;\n\n  for (let i = 2; i <= n; i++) {\n    dp[i] = dp[i - 1] + dp[i - 2];\n  }\n\n  return dp[n];\n}\n\n// Space Optimized\nfunction fibOptimized(n) {\n  if (n <= 1) return n;\n\n  let prev2 = 0,\n    prev1 = 1;\n\n  for (let i = 2; i <= n; i++) {\n    const curr = prev1 + prev2;\n    prev2 = prev1;\n    prev1 = curr;\n  }\n\n  return prev1;\n}\n"})}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Time Complexity:"})," O(n) | ",(0,t.jsx)(e.strong,{children:"Space Complexity:"})," O(1) optimized"]}),"\n",(0,t.jsx)(e.h3,{id:"2-climbing-stairs",children:"2. Climbing Stairs"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function climbStairs(n) {\n  if (n <= 2) return n;\n\n  let oneStep = 1,\n    twoStep = 2;\n\n  for (let i = 3; i <= n; i++) {\n    const current = oneStep + twoStep;\n    oneStep = twoStep;\n    twoStep = current;\n  }\n\n  return twoStep;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-house-robber",children:"3. House Robber"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function rob(nums) {\n  if (nums.length === 0) return 0;\n  if (nums.length === 1) return nums[0];\n\n  let prev2 = 0,\n    prev1 = 0;\n\n  for (const num of nums) {\n    const current = Math.max(prev1, prev2 + num);\n    prev2 = prev1;\n    prev1 = current;\n  }\n\n  return prev1;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"4-house-robber-ii-circular",children:"4. House Robber II (Circular)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function robCircular(nums) {\n  if (nums.length === 1) return nums[0];\n\n  const robRange = (start, end) => {\n    let prev2 = 0,\n      prev1 = 0;\n\n    for (let i = start; i <= end; i++) {\n      const current = Math.max(prev1, prev2 + nums[i]);\n      prev2 = prev1;\n      prev1 = current;\n    }\n\n    return prev1;\n  };\n\n  // Either rob houses 0 to n-2 or 1 to n-1\n  return Math.max(robRange(0, nums.length - 2), robRange(1, nums.length - 1));\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"5-maximum-subarray-kadanes-algorithm",children:"5. Maximum Subarray (Kadane's Algorithm)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function maxSubArray(nums) {\n  let maxSoFar = nums[0];\n  let maxEndingHere = nums[0];\n\n  for (let i = 1; i < nums.length; i++) {\n    maxEndingHere = Math.max(nums[i], maxEndingHere + nums[i]);\n    maxSoFar = Math.max(maxSoFar, maxEndingHere);\n  }\n\n  return maxSoFar;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"6-coin-change",children:"6. Coin Change"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function coinChange(coins, amount) {\n  const dp = new Array(amount + 1).fill(Infinity);\n  dp[0] = 0;\n\n  for (let i = 1; i <= amount; i++) {\n    for (const coin of coins) {\n      if (coin <= i) {\n        dp[i] = Math.min(dp[i], dp[i - coin] + 1);\n      }\n    }\n  }\n\n  return dp[amount] === Infinity ? -1 : dp[amount];\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"7-perfect-squares",children:"7. Perfect Squares"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function numSquares(n) {\n  const dp = new Array(n + 1).fill(Infinity);\n  dp[0] = 0;\n\n  for (let i = 1; i <= n; i++) {\n    for (let j = 1; j * j <= i; j++) {\n      dp[i] = Math.min(dp[i], dp[i - j * j] + 1);\n    }\n  }\n\n  return dp[n];\n}\n"})}),"\n",(0,t.jsxs)(e.blockquote,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"\ud83d\udca1 Pattern Recognition:"})," Most 1D DP problems involve making decisions at each position based on previous positions."]}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"2d-dynamic-programming",children:"2D Dynamic Programming"}),"\n",(0,t.jsx)(e.h3,{id:"1-unique-paths",children:"1. Unique Paths"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function uniquePaths(m, n) {\n  const dp = Array(m)\n    .fill()\n    .map(() => Array(n).fill(1));\n\n  for (let i = 1; i < m; i++) {\n    for (let j = 1; j < n; j++) {\n      dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n    }\n  }\n\n  return dp[m - 1][n - 1];\n}\n\n// Space Optimized\nfunction uniquePathsOptimized(m, n) {\n  let dp = new Array(n).fill(1);\n\n  for (let i = 1; i < m; i++) {\n    for (let j = 1; j < n; j++) {\n      dp[j] += dp[j - 1];\n    }\n  }\n\n  return dp[n - 1];\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-unique-paths-ii-with-obstacles",children:"2. Unique Paths II (With Obstacles)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function uniquePathsWithObstacles(obstacleGrid) {\n  const m = obstacleGrid.length;\n  const n = obstacleGrid[0].length;\n\n  if (obstacleGrid[0][0] === 1) return 0;\n\n  const dp = Array(m)\n    .fill()\n    .map(() => Array(n).fill(0));\n  dp[0][0] = 1;\n\n  // Fill first row\n  for (let j = 1; j < n; j++) {\n    dp[0][j] = obstacleGrid[0][j] === 1 ? 0 : dp[0][j - 1];\n  }\n\n  // Fill first column\n  for (let i = 1; i < m; i++) {\n    dp[i][0] = obstacleGrid[i][0] === 1 ? 0 : dp[i - 1][0];\n  }\n\n  // Fill rest of the grid\n  for (let i = 1; i < m; i++) {\n    for (let j = 1; j < n; j++) {\n      if (obstacleGrid[i][j] === 1) {\n        dp[i][j] = 0;\n      } else {\n        dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n      }\n    }\n  }\n\n  return dp[m - 1][n - 1];\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-minimum-path-sum",children:"3. Minimum Path Sum"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function minPathSum(grid) {\n  const m = grid.length;\n  const n = grid[0].length;\n\n  const dp = Array(m)\n    .fill()\n    .map(() => Array(n).fill(0));\n  dp[0][0] = grid[0][0];\n\n  // Fill first row\n  for (let j = 1; j < n; j++) {\n    dp[0][j] = dp[0][j - 1] + grid[0][j];\n  }\n\n  // Fill first column\n  for (let i = 1; i < m; i++) {\n    dp[i][0] = dp[i - 1][0] + grid[i][0];\n  }\n\n  // Fill rest\n  for (let i = 1; i < m; i++) {\n    for (let j = 1; j < n; j++) {\n      dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\n    }\n  }\n\n  return dp[m - 1][n - 1];\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"4-longest-common-subsequence-lcs",children:"4. Longest Common Subsequence (LCS)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function longestCommonSubsequence(text1, text2) {\n  const m = text1.length;\n  const n = text2.length;\n\n  const dp = Array(m + 1)\n    .fill()\n    .map(() => Array(n + 1).fill(0));\n\n  for (let i = 1; i <= m; i++) {\n    for (let j = 1; j <= n; j++) {\n      if (text1[i - 1] === text2[j - 1]) {\n        dp[i][j] = dp[i - 1][j - 1] + 1;\n      } else {\n        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n      }\n    }\n  }\n\n  return dp[m][n];\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"5-01-knapsack",children:"5. 0/1 Knapsack"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function knapsack(weights, values, capacity) {\n  const n = weights.length;\n  const dp = Array(n + 1)\n    .fill()\n    .map(() => Array(capacity + 1).fill(0));\n\n  for (let i = 1; i <= n; i++) {\n    for (let w = 1; w <= capacity; w++) {\n      if (weights[i - 1] <= w) {\n        // Take or don't take the item\n        dp[i][w] = Math.max(\n          dp[i - 1][w], // Don't take\n          dp[i - 1][w - weights[i - 1]] + values[i - 1] // Take\n        );\n      } else {\n        dp[i][w] = dp[i - 1][w]; // Can't take\n      }\n    }\n  }\n\n  return dp[n][capacity];\n}\n\n// Space Optimized\nfunction knapsackOptimized(weights, values, capacity) {\n  let dp = new Array(capacity + 1).fill(0);\n\n  for (let i = 0; i < weights.length; i++) {\n    for (let w = capacity; w >= weights[i]; w--) {\n      dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]);\n    }\n  }\n\n  return dp[capacity];\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"6-edit-distance",children:"6. Edit Distance"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function minDistance(word1, word2) {\n  const m = word1.length;\n  const n = word2.length;\n\n  const dp = Array(m + 1)\n    .fill()\n    .map(() => Array(n + 1).fill(0));\n\n  // Base cases\n  for (let i = 0; i <= m; i++) dp[i][0] = i;\n  for (let j = 0; j <= n; j++) dp[0][j] = j;\n\n  for (let i = 1; i <= m; i++) {\n    for (let j = 1; j <= n; j++) {\n      if (word1[i - 1] === word2[j - 1]) {\n        dp[i][j] = dp[i - 1][j - 1];\n      } else {\n        dp[i][j] = Math.min(\n          dp[i - 1][j] + 1, // Delete\n          dp[i][j - 1] + 1, // Insert\n          dp[i - 1][j - 1] + 1 // Replace\n        );\n      }\n    }\n  }\n\n  return dp[m][n];\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"string-dynamic-programming",children:"String Dynamic Programming"}),"\n",(0,t.jsx)(e.h3,{id:"1-palindromic-substrings",children:"1. Palindromic Substrings"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function countSubstrings(s) {\n  const n = s.length;\n  let count = 0;\n\n  // dp[i][j] represents if substring from i to j is palindrome\n  const dp = Array(n)\n    .fill()\n    .map(() => Array(n).fill(false));\n\n  // Single characters are palindromes\n  for (let i = 0; i < n; i++) {\n    dp[i][i] = true;\n    count++;\n  }\n\n  // Check for 2-character palindromes\n  for (let i = 0; i < n - 1; i++) {\n    if (s[i] === s[i + 1]) {\n      dp[i][i + 1] = true;\n      count++;\n    }\n  }\n\n  // Check for palindromes of length 3 or more\n  for (let len = 3; len <= n; len++) {\n    for (let i = 0; i <= n - len; i++) {\n      const j = i + len - 1;\n\n      if (s[i] === s[j] && dp[i + 1][j - 1]) {\n        dp[i][j] = true;\n        count++;\n      }\n    }\n  }\n\n  return count;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-longest-palindromic-substring",children:"2. Longest Palindromic Substring"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function longestPalindrome(s) {\n  const n = s.length;\n  if (n === 0) return '';\n\n  const dp = Array(n)\n    .fill()\n    .map(() => Array(n).fill(false));\n  let start = 0,\n    maxLen = 1;\n\n  // Single characters\n  for (let i = 0; i < n; i++) {\n    dp[i][i] = true;\n  }\n\n  // Two characters\n  for (let i = 0; i < n - 1; i++) {\n    if (s[i] === s[i + 1]) {\n      dp[i][i + 1] = true;\n      start = i;\n      maxLen = 2;\n    }\n  }\n\n  // Three or more characters\n  for (let len = 3; len <= n; len++) {\n    for (let i = 0; i <= n - len; i++) {\n      const j = i + len - 1;\n\n      if (s[i] === s[j] && dp[i + 1][j - 1]) {\n        dp[i][j] = true;\n        if (len > maxLen) {\n          start = i;\n          maxLen = len;\n        }\n      }\n    }\n  }\n\n  return s.substring(start, start + maxLen);\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-decode-ways",children:"3. Decode Ways"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function numDecodings(s) {\n  if (s[0] === '0') return 0;\n\n  const n = s.length;\n  const dp = new Array(n + 1).fill(0);\n  dp[0] = 1; // Empty string\n  dp[1] = 1; // First character (non-zero)\n\n  for (let i = 2; i <= n; i++) {\n    const oneDigit = parseInt(s[i - 1]);\n    const twoDigit = parseInt(s.substring(i - 2, i));\n\n    if (oneDigit >= 1) {\n      dp[i] += dp[i - 1];\n    }\n\n    if (twoDigit >= 10 && twoDigit <= 26) {\n      dp[i] += dp[i - 2];\n    }\n  }\n\n  return dp[n];\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"4-word-break",children:"4. Word Break"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function wordBreak(s, wordDict) {\n  const wordSet = new Set(wordDict);\n  const n = s.length;\n  const dp = new Array(n + 1).fill(false);\n  dp[0] = true; // Empty string can always be segmented\n\n  for (let i = 1; i <= n; i++) {\n    for (let j = 0; j < i; j++) {\n      if (dp[j] && wordSet.has(s.substring(j, i))) {\n        dp[i] = true;\n        break;\n      }\n    }\n  }\n\n  return dp[n];\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"tree-dynamic-programming",children:"Tree Dynamic Programming"}),"\n",(0,t.jsx)(e.h3,{id:"1-binary-tree-maximum-path-sum",children:"1. Binary Tree Maximum Path Sum"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function maxPathSum(root) {\n  let maxSum = -Infinity;\n\n  function maxGain(node) {\n    if (!node) return 0;\n\n    // Max sum on the left and right sub-trees\n    const leftGain = Math.max(maxGain(node.left), 0);\n    const rightGain = Math.max(maxGain(node.right), 0);\n\n    // Max path sum including current node\n    const currentMax = node.val + leftGain + rightGain;\n    maxSum = Math.max(maxSum, currentMax);\n\n    // Return max gain if continuing path through current node\n    return node.val + Math.max(leftGain, rightGain);\n  }\n\n  maxGain(root);\n  return maxSum;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-house-robber-iii-binary-tree",children:"2. House Robber III (Binary Tree)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function robTree(root) {\n  function dfs(node) {\n    if (!node) return [0, 0]; // [rob, not_rob]\n\n    const [leftRob, leftNotRob] = dfs(node.left);\n    const [rightRob, rightNotRob] = dfs(node.right);\n\n    // If we rob current node, we can't rob children\n    const rob = node.val + leftNotRob + rightNotRob;\n\n    // If we don't rob current, we can take max from children\n    const notRob =\n      Math.max(leftRob, leftNotRob) + Math.max(rightRob, rightNotRob);\n\n    return [rob, notRob];\n  }\n\n  const [rob, notRob] = dfs(root);\n  return Math.max(rob, notRob);\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-diameter-of-binary-tree",children:"3. Diameter of Binary Tree"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function diameterOfBinaryTree(root) {\n  let diameter = 0;\n\n  function depth(node) {\n    if (!node) return 0;\n\n    const leftDepth = depth(node.left);\n    const rightDepth = depth(node.right);\n\n    // Update diameter if path through current node is longer\n    diameter = Math.max(diameter, leftDepth + rightDepth);\n\n    return Math.max(leftDepth, rightDepth) + 1;\n  }\n\n  depth(root);\n  return diameter;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"advanced-dp-patterns",children:"Advanced DP Patterns"}),"\n",(0,t.jsx)(e.h3,{id:"1-matrix-chain-multiplication",children:"1. Matrix Chain Multiplication"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function matrixChainOrder(dimensions) {\n  const n = dimensions.length - 1; // Number of matrices\n\n  // dp[i][j] = minimum cost to multiply matrices from i to j\n  const dp = Array(n)\n    .fill()\n    .map(() => Array(n).fill(0));\n\n  // l is chain length\n  for (let l = 2; l <= n; l++) {\n    for (let i = 0; i <= n - l; i++) {\n      const j = i + l - 1;\n      dp[i][j] = Infinity;\n\n      for (let k = i; k < j; k++) {\n        const cost =\n          dp[i][k] +\n          dp[k + 1][j] +\n          dimensions[i] * dimensions[k + 1] * dimensions[j + 1];\n        dp[i][j] = Math.min(dp[i][j], cost);\n      }\n    }\n  }\n\n  return dp[0][n - 1];\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-burst-balloons",children:"2. Burst Balloons"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function maxCoins(nums) {\n  // Add boundary balloons with value 1\n  const balloons = [1, ...nums, 1];\n  const n = balloons.length;\n\n  // dp[i][j] = max coins from balloons between i and j (exclusive)\n  const dp = Array(n)\n    .fill()\n    .map(() => Array(n).fill(0));\n\n  for (let len = 2; len < n; len++) {\n    for (let left = 0; left < n - len; left++) {\n      const right = left + len;\n\n      for (let k = left + 1; k < right; k++) {\n        const coins = balloons[left] * balloons[k] * balloons[right];\n        dp[left][right] = Math.max(\n          dp[left][right],\n          dp[left][k] + dp[k][right] + coins\n        );\n      }\n    }\n  }\n\n  return dp[0][n - 1];\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-regular-expression-matching",children:"3. Regular Expression Matching"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function isMatch(s, p) {\n  const m = s.length;\n  const n = p.length;\n\n  const dp = Array(m + 1)\n    .fill()\n    .map(() => Array(n + 1).fill(false));\n\n  // Base case: empty pattern matches empty string\n  dp[0][0] = true;\n\n  // Handle patterns like a*, a*b*, a*b*c*\n  for (let j = 2; j <= n; j += 2) {\n    if (p[j - 1] === '*') {\n      dp[0][j] = dp[0][j - 2];\n    }\n  }\n\n  for (let i = 1; i <= m; i++) {\n    for (let j = 1; j <= n; j++) {\n      if (p[j - 1] === '*') {\n        // Zero occurrences\n        dp[i][j] = dp[i][j - 2];\n\n        // One or more occurrences\n        if (s[i - 1] === p[j - 2] || p[j - 2] === '.') {\n          dp[i][j] = dp[i][j] || dp[i - 1][j];\n        }\n      } else if (s[i - 1] === p[j - 1] || p[j - 1] === '.') {\n        dp[i][j] = dp[i - 1][j - 1];\n      }\n    }\n  }\n\n  return dp[m][n];\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"4-wildcard-matching",children:"4. Wildcard Matching"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function isMatchWildcard(s, p) {\n  const m = s.length;\n  const n = p.length;\n\n  const dp = Array(m + 1)\n    .fill()\n    .map(() => Array(n + 1).fill(false));\n\n  dp[0][0] = true;\n\n  // Handle patterns starting with *\n  for (let j = 1; j <= n; j++) {\n    if (p[j - 1] === '*') {\n      dp[0][j] = dp[0][j - 1];\n    }\n  }\n\n  for (let i = 1; i <= m; i++) {\n    for (let j = 1; j <= n; j++) {\n      if (p[j - 1] === '*') {\n        dp[i][j] = dp[i - 1][j] || dp[i][j - 1];\n      } else if (s[i - 1] === p[j - 1] || p[j - 1] === '?') {\n        dp[i][j] = dp[i - 1][j - 1];\n      }\n    }\n  }\n\n  return dp[m][n];\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"space-optimization-techniques",children:"Space Optimization Techniques"}),"\n",(0,t.jsx)(e.h3,{id:"1-rolling-array-pattern",children:"1. Rolling Array Pattern"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function optimizedDP(input) {\n  const n = input.length;\n\n  // Instead of dp[i][j], use current and previous\n  let prev = new Array(n).fill(0);\n  let curr = new Array(n).fill(0);\n\n  // Initialize base cases\n  prev[0] = baseValue;\n\n  for (let i = 1; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      curr[j] = computeFromPrevious(prev, j);\n    }\n\n    [prev, curr] = [curr, prev]; // Swap arrays\n  }\n\n  return prev[n - 1];\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-single-array-optimization",children:"2. Single Array Optimization"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function singleArrayDP(input) {\n  const n = input.length;\n  let dp = new Array(n).fill(initialValue);\n\n  // Process in reverse order to avoid overwriting needed values\n  for (let i = 0; i < n; i++) {\n    for (let j = n - 1; j >= 0; j--) {\n      dp[j] = computeNewValue(dp, j);\n    }\n  }\n\n  return dp[target];\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"dp-on-subsequences-and-substrings",children:"DP on Subsequences and Substrings"}),"\n",(0,t.jsx)(e.h3,{id:"1-longest-increasing-subsequence",children:"1. Longest Increasing Subsequence"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function lengthOfLIS(nums) {\n  if (nums.length === 0) return 0;\n\n  const dp = new Array(nums.length).fill(1);\n\n  for (let i = 1; i < nums.length; i++) {\n    for (let j = 0; j < i; j++) {\n      if (nums[j] < nums[i]) {\n        dp[i] = Math.max(dp[i], dp[j] + 1);\n      }\n    }\n  }\n\n  return Math.max(...dp);\n}\n\n// Optimized O(n log n) solution\nfunction lengthOfLISOptimized(nums) {\n  const tails = [];\n\n  for (const num of nums) {\n    let left = 0,\n      right = tails.length;\n\n    while (left < right) {\n      const mid = Math.floor((left + right) / 2);\n      if (tails[mid] < num) {\n        left = mid + 1;\n      } else {\n        right = mid;\n      }\n    }\n\n    if (left === tails.length) {\n      tails.push(num);\n    } else {\n      tails[left] = num;\n    }\n  }\n\n  return tails.length;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-longest-common-substring",children:"2. Longest Common Substring"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function longestCommonSubstring(text1, text2) {\n  const m = text1.length;\n  const n = text2.length;\n\n  const dp = Array(m + 1)\n    .fill()\n    .map(() => Array(n + 1).fill(0));\n  let maxLength = 0;\n\n  for (let i = 1; i <= m; i++) {\n    for (let j = 1; j <= n; j++) {\n      if (text1[i - 1] === text2[j - 1]) {\n        dp[i][j] = dp[i - 1][j - 1] + 1;\n        maxLength = Math.max(maxLength, dp[i][j]);\n      }\n    }\n  }\n\n  return maxLength;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-count-distinct-subsequences",children:"3. Count Distinct Subsequences"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function numDistinct(s, t) {\n  const m = s.length;\n  const n = t.length;\n\n  const dp = Array(m + 1)\n    .fill()\n    .map(() => Array(n + 1).fill(0));\n\n  // Empty string t can be formed from any string in one way\n  for (let i = 0; i <= m; i++) {\n    dp[i][0] = 1;\n  }\n\n  for (let i = 1; i <= m; i++) {\n    for (let j = 1; j <= n; j++) {\n      // Don't use current character from s\n      dp[i][j] = dp[i - 1][j];\n\n      // Use current character if it matches\n      if (s[i - 1] === t[j - 1]) {\n        dp[i][j] += dp[i - 1][j - 1];\n      }\n    }\n  }\n\n  return dp[m][n];\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"4-palindromic-subsequences",children:"4. Palindromic Subsequences"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function countPalindromicSubsequences(s) {\n  const n = s.length;\n  const MOD = 1000000007;\n\n  // dp[i][j] = number of distinct palindromic subsequences in s[i:j+1]\n  const dp = Array(n)\n    .fill()\n    .map(() => Array(n).fill(0));\n\n  // Single characters\n  for (let i = 0; i < n; i++) {\n    dp[i][i] = 1;\n  }\n\n  for (let len = 2; len <= n; len++) {\n    for (let i = 0; i <= n - len; i++) {\n      const j = i + len - 1;\n\n      if (s[i] === s[j]) {\n        dp[i][j] = (2 * dp[i + 1][j - 1]) % MOD;\n\n        // Find first and last occurrence of s[i] in s[i+1:j]\n        let left = i + 1,\n          right = j - 1;\n        while (left <= right && s[left] !== s[i]) left++;\n        while (left <= right && s[right] !== s[i]) right--;\n\n        if (left > right) {\n          dp[i][j] = (dp[i][j] + 2) % MOD;\n        } else if (left === right) {\n          dp[i][j] = (dp[i][j] + 1) % MOD;\n        } else {\n          dp[i][j] = (dp[i][j] - dp[left + 1][right - 1] + MOD) % MOD;\n        }\n      } else {\n        dp[i][j] = (dp[i + 1][j] + dp[i][j - 1] - dp[i + 1][j - 1] + MOD) % MOD;\n      }\n    }\n  }\n\n  return dp[0][n - 1];\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"game-theory-dp",children:"Game Theory DP"}),"\n",(0,t.jsx)(e.h3,{id:"1-stone-game",children:"1. Stone Game"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function stoneGame(piles) {\n  const n = piles.length;\n\n  // dp[i][j] = max difference (first player - second player)\n  // when playing optimally on piles[i:j+1]\n  const dp = Array(n)\n    .fill()\n    .map(() => Array(n).fill(0));\n\n  // Base case: single pile\n  for (let i = 0; i < n; i++) {\n    dp[i][i] = piles[i];\n  }\n\n  for (let len = 2; len <= n; len++) {\n    for (let i = 0; i <= n - len; i++) {\n      const j = i + len - 1;\n\n      // Take left pile or right pile\n      dp[i][j] = Math.max(\n        piles[i] - dp[i + 1][j], // Take left\n        piles[j] - dp[i][j - 1] // Take right\n      );\n    }\n  }\n\n  return dp[0][n - 1] > 0;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-predict-the-winner",children:"2. Predict the Winner"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function PredictTheWinner(nums) {\n  const n = nums.length;\n  const dp = Array(n)\n    .fill()\n    .map(() => Array(n).fill(0));\n\n  // Base case\n  for (let i = 0; i < n; i++) {\n    dp[i][i] = nums[i];\n  }\n\n  for (let len = 2; len <= n; len++) {\n    for (let i = 0; i <= n - len; i++) {\n      const j = i + len - 1;\n      dp[i][j] = Math.max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);\n    }\n  }\n\n  return dp[0][n - 1] >= 0;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-nim-game",children:"3. Nim Game"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function canWinNim(n) {\n  // If n is divisible by 4, first player loses\n  return n % 4 !== 0;\n}\n\n// For more complex Nim variants\nfunction nimGame(piles) {\n  let xor = 0;\n  for (const pile of piles) {\n    xor ^= pile;\n  }\n  return xor !== 0; // First player wins if XOR is non-zero\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"digit-dp",children:"Digit DP"}),"\n",(0,t.jsx)(e.h3,{id:"1-count-numbers-with-digit-sum",children:"1. Count Numbers with Digit Sum"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function countNumbersWithSum(n, targetSum) {\n  const str = n.toString();\n  const len = str.length;\n\n  // Memoization: [position][sum][tight][started]\n  const memo = new Map();\n\n  function dp(pos, sum, tight, started) {\n    if (pos === len) {\n      return started && sum === targetSum ? 1 : 0;\n    }\n\n    const key = `${pos}-${sum}-${tight}-${started}`;\n    if (memo.has(key)) return memo.get(key);\n\n    let result = 0;\n    const limit = tight ? parseInt(str[pos]) : 9;\n\n    for (let digit = 0; digit <= limit; digit++) {\n      const newSum = sum + digit;\n      const newTight = tight && digit === limit;\n      const newStarted = started || digit > 0;\n\n      if (!newStarted || newSum <= targetSum) {\n        result += dp(pos + 1, newSum, newTight, newStarted);\n      }\n    }\n\n    memo.set(key, result);\n    return result;\n  }\n\n  return dp(0, 0, true, false);\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-numbers-at-most-n-given-digit-set",children:"2. Numbers At Most N Given Digit Set"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function atMostNGivenDigitSet(digits, n) {\n  const nStr = n.toString();\n  const len = nStr.length;\n  const digitSet = new Set(digits);\n\n  // Count numbers with fewer digits\n  let result = 0;\n  for (let i = 1; i < len; i++) {\n    result += Math.pow(digits.length, i);\n  }\n\n  // Count numbers with same number of digits\n  for (let i = 0; i < len; i++) {\n    const currentDigit = nStr[i];\n    let count = 0;\n\n    for (const digit of digits) {\n      if (digit < currentDigit) {\n        count++;\n      }\n    }\n\n    result += count * Math.pow(digits.length, len - i - 1);\n\n    if (!digitSet.has(currentDigit)) {\n      break;\n    }\n\n    if (i === len - 1) {\n      result++; // The number n itself\n    }\n  }\n\n  return result;\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"common-optimization-tricks",children:"Common Optimization Tricks"}),"\n",(0,t.jsx)(e.h3,{id:"1-state-compression",children:"1. State Compression"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Use bitmask to represent states\nfunction tsp(graph) {\n  const n = graph.length;\n  const memo = new Map();\n\n  function dp(mask, pos) {\n    if (mask === (1 << n) - 1) {\n      return graph[pos][0]; // Return to start\n    }\n\n    const key = `${mask}-${pos}`;\n    if (memo.has(key)) return memo.get(key);\n\n    let result = Infinity;\n    for (let city = 0; city < n; city++) {\n      if ((mask & (1 << city)) === 0) {\n        const newMask = mask | (1 << city);\n        result = Math.min(result, graph[pos][city] + dp(newMask, city));\n      }\n    }\n\n    memo.set(key, result);\n    return result;\n  }\n\n  return dp(1, 0); // Start from city 0\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-coordinate-compression",children:"2. Coordinate Compression"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function compressCoordinates(points) {\n  const xCoords = [...new Set(points.map(p => p[0]))].sort((a, b) => a - b);\n  const yCoords = [...new Set(points.map(p => p[1]))].sort((a, b) => a - b);\n\n  const xMap = new Map();\n  const yMap = new Map();\n\n  xCoords.forEach((x, i) => xMap.set(x, i));\n  yCoords.forEach((y, i) => yMap.set(y, i));\n\n  return points.map(([x, y]) => [xMap.get(x), yMap.get(y)]);\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-monotonic-queue-optimization",children:"3. Monotonic Queue Optimization"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function maxSlidingWindow(nums, k) {\n  const result = [];\n  const deque = []; // Store indices\n\n  for (let i = 0; i < nums.length; i++) {\n    // Remove elements outside window\n    while (deque.length && deque[0] <= i - k) {\n      deque.shift();\n    }\n\n    // Remove smaller elements\n    while (deque.length && nums[deque[deque.length - 1]] <= nums[i]) {\n      deque.pop();\n    }\n\n    deque.push(i);\n\n    if (i >= k - 1) {\n      result.push(nums[deque[0]]);\n    }\n  }\n\n  return result;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"4-convex-hull-trick",children:"4. Convex Hull Trick"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// For problems with recurrence: dp[i] = min(dp[j] + cost(j, i))\nclass ConvexHullTrick {\n  constructor() {\n    this.lines = []; // [slope, intercept, index]\n  }\n\n  addLine(slope, intercept, index) {\n    const newLine = [slope, intercept, index];\n\n    // Remove lines that become irrelevant\n    while (this.lines.length >= 2) {\n      const [s1, b1] = this.lines[this.lines.length - 2];\n      const [s2, b2] = this.lines[this.lines.length - 1];\n      const [s3, b3] = newLine;\n\n      // Check if middle line is redundant\n      if ((b3 - b1) * (s1 - s2) >= (b2 - b1) * (s1 - s3)) {\n        this.lines.pop();\n      } else {\n        break;\n      }\n    }\n\n    this.lines.push(newLine);\n  }\n\n  query(x) {\n    let left = 0,\n      right = this.lines.length - 1;\n\n    while (left < right) {\n      const mid = Math.floor((left + right) / 2);\n      const val1 = this.lines[mid][0] * x + this.lines[mid][1];\n      const val2 = this.lines[mid + 1][0] * x + this.lines[mid + 1][1];\n\n      if (val1 <= val2) {\n        right = mid;\n      } else {\n        left = mid + 1;\n      }\n    }\n\n    return [this.lines[left][0] * x + this.lines[left][1], this.lines[left][2]];\n  }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"problem-solving-strategy",children:"Problem-Solving Strategy"}),"\n",(0,t.jsx)(e.h3,{id:"1-identify-dp-problems",children:"1. Identify DP Problems"}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Signs that a problem might use DP:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Optimization problems (min/max)"}),"\n",(0,t.jsx)(e.li,{children:"Counting problems"}),"\n",(0,t.jsx)(e.li,{children:"Decision problems (yes/no)"}),"\n",(0,t.jsx)(e.li,{children:"Problems with overlapping subproblems"}),"\n",(0,t.jsx)(e.li,{children:"Problems with optimal substructure"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"2-dp-development-process",children:"2. DP Development Process"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Define the state:"})," What parameters uniquely identify a subproblem?"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Write the recurrence relation:"})," How does the current state relate to previous states?"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Identify base cases:"})," What are the simplest subproblems?"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Implement:"})," Choose between top-down (memoization) or bottom-up (tabulation)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Optimize:"})," Can you reduce space complexity?"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"3-common-pitfalls",children:"3. Common Pitfalls"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Incorrect state definition:"})," Make sure your state captures all necessary information"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Wrong base cases:"})," Double-check your base cases"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Off-by-one errors:"})," Be careful with array indices"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Overflow issues:"})," Use appropriate data types and modular arithmetic when needed"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Time/space complexity:"})," Consider if your solution is efficient enough"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"4-testing-strategy",children:"4. Testing Strategy"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function testDP(dpFunction, testCases) {\n  for (const [input, expected] of testCases) {\n    const result = dpFunction(...input);\n    console.log(`Input: ${JSON.stringify(input)}`);\n    console.log(`Expected: ${expected}, Got: ${result}`);\n    console.log(`\u2705 ${result === expected ? 'PASS' : 'FAIL'}\\n`);\n  }\n}\n\n// Example usage\nconst fibTestCases = [\n  [[0], 0],\n  [[1], 1],\n  [[5], 5],\n  [[10], 55],\n];\n\ntestDP(fibOptimized, fibTestCases);\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsx)(e.p,{children:"Dynamic Programming is a powerful technique that can solve complex problems efficiently by breaking them down into simpler subproblems. The key to mastering DP is:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Practice pattern recognition"})," - Learn to identify when DP is applicable"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Master state definition"})," - The most crucial step in DP problem solving"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Understand space-time tradeoffs"})," - When to use memoization vs tabulation"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Learn optimization techniques"})," - Space optimization, monotonic queues, convex hull tricks"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Build intuition through practice"})," - Solve problems across different categories"]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"Remember: DP problems often have multiple valid approaches. Focus on correctness first, then optimize for time and space complexity."}),"\n",(0,t.jsxs)(e.blockquote,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"\ud83d\udca1 Pro Tip:"})," When stuck on a DP problem, try working backwards from the desired result to understand what information you need to track in your state."]}),"\n"]})]})}function m(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}}}]);