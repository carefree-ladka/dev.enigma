"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[5206],{8812:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>t,metadata:()=>o,toc:()=>h});var l=i(4848),s=i(8453);const t={},r="Graham's Scan Algorithm & Convex Hull",o={id:"DSA/DSA with JavaScript/ConvexHull",title:"Graham's Scan Algorithm & Convex Hull",description:"Theory",source:"@site/docs/DSA/DSA with JavaScript/ConvexHull.mdx",sourceDirName:"DSA/DSA with JavaScript",slug:"/DSA/DSA with JavaScript/ConvexHull",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/ConvexHull",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with JavaScript/ConvexHull.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Combinations and Modular Inverse",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/Combinatrix"},next:{title:"Counting Sort",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/CountingSort"}},c={},h=[{value:"Theory",id:"theory",level:2},{value:"Key Concepts",id:"key-concepts",level:3},{value:"Graham&#39;s Scan Algorithm Steps",id:"grahams-scan-algorithm-steps",level:3},{value:"Implementation",id:"implementation",level:2},{value:"Time &amp; Space Complexity",id:"time--space-complexity",level:2},{value:"LeetCode Problems Using Convex Hull",id:"leetcode-problems-using-convex-hull",level:2},{value:"Common Variations &amp; Extensions",id:"common-variations--extensions",level:2},{value:"Tips for Implementation",id:"tips-for-implementation",level:2},{value:"Common Mistakes to Avoid",id:"common-mistakes-to-avoid",level:2}];function a(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(e.header,{children:(0,l.jsx)(e.h1,{id:"grahams-scan-algorithm--convex-hull",children:"Graham's Scan Algorithm & Convex Hull"})}),"\n",(0,l.jsx)(e.h2,{id:"theory",children:"Theory"}),"\n",(0,l.jsx)(e.p,{children:"A convex hull is the smallest convex polygon that can contain all points in a given set. Think of it as wrapping a rubber band around all the points - the shape it forms is the convex hull."}),"\n",(0,l.jsx)(e.h3,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,l.jsxs)(e.ol,{children:["\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsxs)(e.p,{children:[(0,l.jsx)(e.strong,{children:"Convex Polygon"}),": A polygon where:"]}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"All interior angles are less than 180 degrees"}),"\n",(0,l.jsx)(e.li,{children:"Any line segment between two points inside the polygon lies entirely inside the polygon"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsxs)(e.p,{children:[(0,l.jsx)(e.strong,{children:"Properties"}),":"]}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Every point in the set is either inside the hull or on its boundary"}),"\n",(0,l.jsx)(e.li,{children:"The hull vertices are a subset of the original points"}),"\n",(0,l.jsx)(e.li,{children:"The hull is unique for a given set of points"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(e.h3,{id:"grahams-scan-algorithm-steps",children:"Graham's Scan Algorithm Steps"}),"\n",(0,l.jsxs)(e.ol,{children:["\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Find Anchor Point"})}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Select the point with lowest y-coordinate (leftmost point if tie)"}),"\n",(0,l.jsx)(e.li,{children:"This point is guaranteed to be on the hull"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Sort Points"})}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Sort remaining points by polar angle relative to anchor point"}),"\n",(0,l.jsx)(e.li,{children:"If angles are equal, sort by distance from anchor"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Build Hull"})}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Push first three points onto stack"}),"\n",(0,l.jsxs)(e.li,{children:["For each remaining point:","\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"While the last three points make a non-left turn, pop the middle point"}),"\n",(0,l.jsx)(e.li,{children:"Push current point"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Handle Collinear Points"})}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Special care needed when multiple points have same angle"}),"\n",(0,l.jsx)(e.li,{children:"Include all collinear points in final hull"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(e.h2,{id:"implementation",children:"Implementation"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-JavaScript",children:'class Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n}\n\n// Compute cross product to determine orientation\nconst crossProduct = (p, q, r) => (q.x - p.x) * (r.y - p.y) - (q.y - p.y) * (r.x - p.x);\n\n// Compute squared distance between two points\nconst distSq = (p1, p2) => (p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2;\n\n// Graham\'s Scan algorithm\nconst convexHull = (points) => {\n  if (points.length < 3) return points;\n\n  // Find pivot (lowest y, then lowest x if tie)\n  const pivot = points.reduce((a, b) => (b.y < a.y || (b.y === a.y && b.x < a.x) ? b : a));\n\n  // Sort by polar angle (remove collinear points)\n  points.sort((a, b) => {\n    let order = crossProduct(pivot, a, b);\n    return order === 0 ? distSq(pivot, a) - distSq(pivot, b) : -order;\n  });\n\n  // Construct hull using stack\n  return points.reduce((hull, p) => {\n    while (hull.length > 1 && crossProduct(hull[hull.length - 2], hull[hull.length - 1], p) <= 0) {\n      hull.pop();\n    }\n    hull.push(p);\n    return hull;\n  }, []);\n};\n\n// Example usage\nconst points = [\n  new Point(0, 3), new Point(1, 1), new Point(2, 2),\n  new Point(4, 4), new Point(0, 0), new Point(1, 2),\n  new Point(3, 1), new Point(3, 3)\n];\n\nconst convexHullPoints = convexHull(points);\nconsole.log("Convex Hull Points:", convexHullPoints.map(p => `(${p.x}, ${p.y})`));\n'})}),"\n",(0,l.jsx)(e.h2,{id:"time--space-complexity",children:"Time & Space Complexity"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:["Time Complexity: O(n log n)","\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Sorting points takes O(n log n)"}),"\n",(0,l.jsx)(e.li,{children:"Building hull takes O(n)"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(e.li,{children:["Space Complexity: O(n)","\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Stack storage"}),"\n",(0,l.jsx)(e.li,{children:"Sorted array storage"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(e.h2,{id:"leetcode-problems-using-convex-hull",children:"LeetCode Problems Using Convex Hull"}),"\n",(0,l.jsxs)(e.ol,{children:["\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsxs)(e.p,{children:[(0,l.jsx)(e.strong,{children:"587. Erect the Fence"})," (Hard)"]}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Direct application of convex hull"}),"\n",(0,l.jsx)(e.li,{children:"Need to handle collinear points carefully"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsxs)(e.p,{children:[(0,l.jsx)(e.strong,{children:"1937. Maximum Number of Points with Cost"})," (Medium)"]}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Can be optimized using convex hull concept"}),"\n",(0,l.jsx)(e.li,{children:"Dynamic programming with geometric properties"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsxs)(e.p,{children:[(0,l.jsx)(e.strong,{children:"483. Smallest Good Base"})," (Hard)"]}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"While not directly using convex hull, uses similar geometric concepts"}),"\n",(0,l.jsx)(e.li,{children:"Binary search with geometric properties"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsxs)(e.p,{children:[(0,l.jsx)(e.strong,{children:"456. 132 Pattern"})," (Medium)"]}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Can be solved using monotonic stack (similar principle to Graham's Scan)"}),"\n",(0,l.jsx)(e.li,{children:"Stack maintenance similar to convex hull building"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(e.h2,{id:"common-variations--extensions",children:"Common Variations & Extensions"}),"\n",(0,l.jsxs)(e.ol,{children:["\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Monotone Chain Algorithm"})}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Alternative to Graham's Scan"}),"\n",(0,l.jsx)(e.li,{children:"Builds upper and lower hulls separately"}),"\n",(0,l.jsx)(e.li,{children:"Often simpler to implement"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Dynamic Convex Hull"})}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Maintain hull as points are added/removed"}),"\n",(0,l.jsx)(e.li,{children:"More complex but useful for streaming data"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Closest Pair of Points"})}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Can be solved using convex hull techniques"}),"\n",(0,l.jsx)(e.li,{children:"Often combined with divide-and-conquer"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(e.h2,{id:"tips-for-implementation",children:"Tips for Implementation"}),"\n",(0,l.jsxs)(e.ol,{children:["\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Handle Edge Cases"})}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Less than 3 points"}),"\n",(0,l.jsx)(e.li,{children:"Collinear points"}),"\n",(0,l.jsx)(e.li,{children:"Duplicate points"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Numerical Precision"})}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Use appropriate epsilon for floating-point comparisons"}),"\n",(0,l.jsx)(e.li,{children:"Consider integer-only implementations when possible"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"Optimization Opportunities"})}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Pre-compute angles/distances"}),"\n",(0,l.jsx)(e.li,{children:"Use array instead of stack for better cache performance"}),"\n",(0,l.jsx)(e.li,{children:"Consider removing redundant calculations"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(e.h2,{id:"common-mistakes-to-avoid",children:"Common Mistakes to Avoid"}),"\n",(0,l.jsxs)(e.ol,{children:["\n",(0,l.jsx)(e.li,{children:"Not handling collinear points correctly"}),"\n",(0,l.jsx)(e.li,{children:"Incorrect anchor point selection"}),"\n",(0,l.jsx)(e.li,{children:"Wrong turn detection implementation"}),"\n",(0,l.jsx)(e.li,{children:"Not handling edge cases"}),"\n",(0,l.jsx)(e.li,{children:"Poor floating-point comparisons"}),"\n"]}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:(0,l.jsx)(e.a,{href:"https://www.geeksforgeeks.org/convex-hull-using-graham-scan/",children:"https://www.geeksforgeeks.org/convex-hull-using-graham-scan/"})}),"\n",(0,l.jsx)(e.li,{children:(0,l.jsx)(e.a,{href:"https://medium.com/@madhavyadav4595/graham-scan-algorithm-5c287ef00ecd",children:"https://medium.com/@madhavyadav4595/graham-scan-algorithm-5c287ef00ecd"})}),"\n",(0,l.jsx)(e.li,{children:(0,l.jsx)(e.a,{href:"https://cp-algorithms.com/geometry/convex-hull.html",children:"https://cp-algorithms.com/geometry/convex-hull.html"})}),"\n",(0,l.jsx)(e.li,{children:(0,l.jsx)(e.a,{href:"https://en.wikipedia.org/wiki/Graham_scan",children:"https://en.wikipedia.org/wiki/Graham_scan"})}),"\n"]})]})}function d(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,l.jsx)(e,{...n,children:(0,l.jsx)(a,{...n})}):a(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>r,x:()=>o});var l=i(6540);const s={},t=l.createContext(s);function r(n){const e=l.useContext(t);return l.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:r(n.components),l.createElement(t.Provider,{value:e},n.children)}}}]);