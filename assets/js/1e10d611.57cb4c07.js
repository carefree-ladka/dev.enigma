"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[3486],{1888:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>i,contentTitle:()=>l,default:()=>m,frontMatter:()=>o,metadata:()=>c,toc:()=>a});var s=n(4848),t=n(8453);const o={title:"Promise Polyfills"},l=void 0,c={id:"WebDev/JavaScript/PromisePolyfills",title:"Promise Polyfills",description:"Promise",source:"@site/docs/WebDev/JavaScript/PromisePolyfills.mdx",sourceDirName:"WebDev/JavaScript",slug:"/WebDev/JavaScript/PromisePolyfills",permalink:"/js.enigma/docs/WebDev/JavaScript/PromisePolyfills",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/WebDev/JavaScript/PromisePolyfills.mdx",tags:[],version:"current",frontMatter:{title:"Promise Polyfills"},sidebar:"tutorialSidebar",previous:{title:"Promise Based Outputs",permalink:"/js.enigma/docs/WebDev/JavaScript/PromiseBased"},next:{title:"__proto__ vs prototype",permalink:"/js.enigma/docs/WebDev/JavaScript/ProtoVSPrototype"}},i={},a=[{value:"Promise",id:"promise",level:3},{value:"Promise.all",id:"promiseall",level:3},{value:"Promise.allSettled",id:"promiseallsettled",level:3},{value:"Promise Any",id:"promise-any",level:3},{value:"Promise Race",id:"promise-race",level:3},{value:"Fetch with Retry",id:"fetch-with-retry",level:3},{value:"Sleep",id:"sleep",level:3},{value:"Retry Callback",id:"retry-callback",level:3},{value:"Example Usage",id:"example-usage",level:3}];function u(e){const r={code:"code",h3:"h3",pre:"pre",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.h3,{id:"promise",children:"Promise"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-JavaScript",children:'const STATE = Object.freeze({\r\n  PENDING: "pending",\r\n  SUCCESS: "fulfilled",\r\n  REJECTED: "rejected",\r\n});\r\n\r\nclass MyPromise {\r\n  #value = null;\r\n  #state = STATE.PENDING;\r\n  #successcbs = [];\r\n  #rejectedcbs = [];\r\n  constructor(executor) {\r\n    try {\r\n      executor(\r\n        (val) => this.#resolve(val),\r\n        (val) => this.#reject(val)\r\n      );\r\n    } catch (e) {\r\n      this.#reject(e);\r\n    }\r\n  }\r\n\r\n  #resolve(val) {\r\n    this.#value = val;\r\n    this.#state = STATE.SUCCESS;\r\n    this.#successcbs.forEach((cb) => cb());\r\n  }\r\n\r\n  #reject(val) {\r\n    this.#value = val;\r\n    this.#state = STATE.REJECTED;\r\n    this.#rejectedcbs.forEach((cb) => cb());\r\n  }\r\n\r\n  then(onFulfilled, onRejected) {\r\n    return new MyPromise((resolve, reject) => {\r\n      const successCb = () => {\r\n        if (!onFulfilled) return resolve(this.#value);\r\n        queueMicrotask(() => {\r\n          try {\r\n            resolve(onFulfilled(this.#value));\r\n          } catch (e) {\r\n            reject(e);\r\n          }\r\n        });\r\n      };\r\n\r\n      const rejectCb = () => {\r\n        if (!onRejected) return reject(this.#value);\r\n        queueMicrotask(() => {\r\n          try {\r\n            resolve(onRejected(this.#value));\r\n          } catch (e) {\r\n            reject(e);\r\n          }\r\n        });\r\n      };\r\n\r\n      switch (this.#state) {\r\n        case STATE.PENDING:\r\n          this.#successcbs.push(successCb);\r\n          this.#rejectedcbs.push(rejectCb);\r\n          break;\r\n        case STATE.SUCCESS:\r\n          successCb();\r\n          break;\r\n        case STATE.REJECTED:\r\n          rejectCb();\r\n          break;\r\n        default:\r\n          throw new Error("unknown state...");\r\n      }\r\n    });\r\n  }\r\n\r\n  catch(onRejected) {\r\n    return this.then(null, onRejected);\r\n  }\r\n\r\n  finally(onFinally) {\r\n    return this.then(\r\n      (value) => {\r\n        return MyPromise.resolve(onFinally()).then(() => value);\r\n      },\r\n      (reason) => {\r\n        return MyPromise.resolve(onFinally()).then(() => {\r\n          throw reason;\r\n        });\r\n      }\r\n    );\r\n  }\r\n\r\n  static resolve(value) {\r\n    return new MyPromise((resolve) => resolve(value));\r\n  }\r\n\r\n  static reject(reason) {\r\n    return new MyPromise((_, reject) => reject(reason));\r\n  }\r\n}\r\n\r\nconst getUser = () => {\r\n  return new MyPromise((resolve, reject) => {\r\n    if (Math.random() * 5 > 6) {\r\n      resolve("Hiii");\r\n    } else {\r\n      reject("Byeee");\r\n    }\r\n  });\r\n};\r\n\r\ngetUser()\r\n  .then((x) => console.log(x))\r\n  .catch((e) => console.log(e))\r\n  .finally(() => console.log("next..."))\r\n  .finally(() => console.log(\'lol\'))\n'})}),"\n",(0,s.jsx)(r.h3,{id:"promiseall",children:"Promise.all"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-JavaScript",children:"Promise.myAll = function (promises = []) {\r\n  return new Promise((resolve, reject) => {\r\n    if (!promises.length) resolve([])\r\n    const result = []\r\n    let count = 0\r\n    promises.forEach((promise, index) => {\r\n      Promise.resolve(promise).then((value) => {\r\n        result[index] = value\r\n        count++\r\n        if (count === promises.length) {\r\n          resolve(result)\r\n        }\r\n      }).catch((error) => reject(error))\r\n    })\r\n  })\r\n}\r\n\r\n// Example usage:\r\nconst p1 = Promise.reject(3);\r\nconst p2 = 42;\r\nconst p3 = new Promise((resolve, reject) => {\r\n  setTimeout(resolve, 100, 'foo');\r\n});\r\n\r\nPromise.myAll([p1, p2, p3])\r\n  .then((values) => {\r\n    console.log(values); // [3, 42, \"foo\"]\r\n  })\r\n  .catch((error) => {\r\n    console.error(error);\r\n  });\n"})}),"\n",(0,s.jsx)(r.h3,{id:"promiseallsettled",children:"Promise.allSettled"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-JavaScript",children:"Promise.myAllSettled = function (promises = []) {\r\n  return Promise.all(\r\n    promises.map(promise => {\r\n      return Promise.resolve(promise).then((value) => ({\r\n        status: 'fulfilled', value\r\n      })).catch((reason => ({\r\n        status: 'rejected', reason\r\n      })))\r\n    })\r\n  )\r\n}\r\n\r\n// Example usage:\r\nconst p1 = Promise.resolve(3);\r\nconst p2 = Promise.reject('An error occurred');\r\nconst p3 = new Promise((resolve, reject) => {\r\n  setTimeout(resolve, 100, 'foo');\r\n});\r\n\r\nPromise.myAllSettled([p1, p2, p3])\r\n  .then(results => {\r\n    console.log(results);\r\n    // [\r\n    //   { status: 'fulfilled', value: 3 },\r\n    //   { status: 'rejected', reason: 'An error occurred' },\r\n    //   { status: 'fulfilled', value: 'foo' }\r\n    // ]\r\n  });\n"})}),"\n",(0,s.jsx)(r.h3,{id:"promise-any",children:"Promise Any"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-JavaScript",children:"Promise.myAny = function (promises = []) {\r\n  return new Promise((resolve, reject) => {\r\n    let errors = [];\r\n    let rejectedCount = 0;\r\n    const totalPromises = promises.length;\r\n\r\n    if (!totalPromises) {\r\n      return reject(new AggregateError(errors, \"All promises were rejected\"));\r\n    }\r\n\r\n    promises.forEach((promise, index) => {\r\n      Promise.resolve(promise)\r\n        .then(value => {\r\n          resolve(value);\r\n        })\r\n        .catch(error => {\r\n          errors[index] = error;\r\n          rejectedCount++;\r\n\r\n          if (rejectedCount === totalPromises) {\r\n            reject(new AggregateError(errors, \"All promises were rejected\"));\r\n          }\r\n        });\r\n    });\r\n  });\r\n};\r\n\r\n// Example usage:\r\nconst p1 = Promise.reject('Error 1');\r\nconst p2 = new Promise((resolve) => setTimeout(resolve, 100, 'Success 2'));\r\nconst p3 = new Promise((resolve) => setTimeout(resolve, 200, 'Success 3'));\r\n\r\nPromise.myAny([p1, p2, p3])\r\n  .then(value => {\r\n    console.log('Resolved with value:', value); // \"Resolved with value: Success 2\"\r\n  })\r\n  .catch(error => {\r\n    console.error('Rejected with error:', error);\r\n  });\n"})}),"\n",(0,s.jsx)(r.h3,{id:"promise-race",children:"Promise Race"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-JavaScript",children:"Promise.myRace = function (promises = []) {\r\n  return new Promise((resolve, reject) => {\r\n    promises.forEach(promise => {\r\n      Promise.resolve(promise)\r\n        .then(resolve)\r\n        .catch(reject);\r\n    });\r\n  });\r\n};\r\n\r\n// Example usage:\r\nconst p1 = new Promise((resolve) => setTimeout(resolve, 500, 'Success 1'));\r\nconst p2 = new Promise((resolve, reject) => setTimeout(reject, 100, 'Error 2'));\r\nconst p3 = new Promise((resolve) => setTimeout(resolve, 200, 'Success 3'));\r\n\r\nPromise.myRace([p1, p2, p3])\r\n  .then(value => {\r\n    console.log('Resolved with value:', value); // \"Resolved with value: Success 2\"\r\n  })\r\n  .catch(error => {\r\n    console.error('Rejected with error:', error); // \"Rejected with error: Error 2\"\r\n  });\n"})}),"\n",(0,s.jsx)(r.h3,{id:"fetch-with-retry",children:"Fetch with Retry"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-JavaScript",children:"const fetchWithRetry = async (fetcher, maxRetry = 3, currentRetry = 0) => {\r\n  try {\r\n    const response = await fetcher()\r\n    if (response.ok) {\r\n      return await response.json()\r\n    }\r\n  }\r\n  catch (err) {\r\n    console.log('err', err);\r\n    if (maxRetry > 0) {\r\n      return fetchWithRetry(fetcher, maxRetry - 1, currentRetry + 1)\r\n    }\r\n  }\r\n  throw new Error(`Failed to fetch after ${currentRetry} retries`)\r\n}\r\n\r\n\r\n//Usage \r\nconst url = 'https://api.example.com'\r\n\r\nconst fetchData = async () => fetchWithRetry(() => fetch(url), 3)\r\n\r\n\r\nfetchData()\r\n  .then(res => res.json())\r\n  .then(data => console.log(data))\r\n  .catch(error => console.log('failed to fetch', error))\n"})}),"\n",(0,s.jsx)(r.h3,{id:"sleep",children:"Sleep"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-JavaScript",children:"const sleep = (wait) => new Promise(res => setTimeout(res, wait))\r\n\r\nasync function fix() {\r\n  console.log('Start');\r\n  await sleep(2000); // Sleep for 2 seconds\r\n  console.log('End');\r\n}\r\n\r\nfix();\n"})}),"\n",(0,s.jsx)(r.h3,{id:"retry-callback",children:"Retry Callback"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-JavaScript",children:"function retry(fn, retries = 3, delay = 1000) {\r\n    const attempt = (triesLeft, resolve, reject, args) => {\r\n        fn(...args)\r\n            .then(resolve)\r\n            .catch(error => {\r\n                if (triesLeft === 0) {\r\n                    reject(`Failed after ${retries} attempts: ${error}`);\r\n                } else {\r\n                    console.log(`Retrying... Attempts left: ${triesLeft}`);\r\n                    setTimeout(() => attempt(triesLeft - 1, resolve, reject, args), delay);\r\n                }\r\n            });\r\n    };\r\n\r\n    return (...args) => new Promise((resolve, reject) => attempt(retries, resolve, reject, args));\r\n}\n"})}),"\n",(0,s.jsx)(r.h3,{id:"example-usage",children:"Example Usage"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-JavaScript",children:'function unreliableFunction() {\r\n    return new Promise((resolve, reject) => {\r\n        const success = Math.random() > 0.7;  // 30% chance of success\r\n        if (success) {\r\n            resolve("Success!");\r\n        } else {\r\n            reject("Random failure");\r\n        }\r\n    });\r\n}\r\n\r\nconst retryUnreliable = retry(unreliableFunction, 3, 1000);\r\n\r\nretryUnreliable()\r\n    .then(result => console.log(result))\r\n    .catch(error => console.error(error));\r\n\r\n/* \r\nRetrying... Attempts left: 3\r\nRetrying... Attempts left: 2\r\nRetrying... Attempts left: 1\r\nFailed after 3 attempts: Random failure\r\n*/\n'})})]})}function m(e={}){const{wrapper:r}={...(0,t.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>l,x:()=>c});var s=n(6540);const t={},o=s.createContext(t);function l(e){const r=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function c(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),s.createElement(o.Provider,{value:r},e.children)}}}]);