"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[2226],{2250:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>a,metadata:()=>h,toc:()=>d});var t=i(4848),s=i(8453);const a={},r="Heap",h={id:"DSA/DSA Cheatsheets/Heap",title:"Heap",description:"A comprehensive guide to heap algorithms and techniques for Data Structures and Algorithms in JavaScript.",source:"@site/docs/DSA/DSA Cheatsheets/Heap.mdx",sourceDirName:"DSA/DSA Cheatsheets",slug:"/DSA/DSA Cheatsheets/Heap",permalink:"/js.enigma/docs/DSA/DSA Cheatsheets/Heap",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA Cheatsheets/Heap.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Grid-Based Graph",permalink:"/js.enigma/docs/DSA/DSA Cheatsheets/Grid-Based Graph"},next:{title:"Interval Problems",permalink:"/js.enigma/docs/DSA/DSA Cheatsheets/Interval Problems"}},l={},d=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Basic Heap Concepts",id:"basic-heap-concepts",level:2},{value:"Heap Properties",id:"heap-properties",level:3},{value:"Array Representation",id:"array-representation",level:3},{value:"Heap Implementation",id:"heap-implementation",level:2},{value:"Basic Heap Class",id:"basic-heap-class",level:3},{value:"Max Heap Implementation",id:"max-heap-implementation",level:3},{value:"Basic Heap Operations",id:"basic-heap-operations",level:2},{value:"1. Insert (Add Element)",id:"1-insert-add-element",level:3},{value:"2. Extract Min/Max (Remove Root)",id:"2-extract-minmax-remove-root",level:3},{value:"3. Build Heap from Array",id:"3-build-heap-from-array",level:3},{value:"Priority Queue Implementation",id:"priority-queue-implementation",level:2},{value:"Basic Priority Queue",id:"basic-priority-queue",level:3},{value:"Priority Queue with Objects",id:"priority-queue-with-objects",level:3},{value:"Heap Sort Algorithm",id:"heap-sort-algorithm",level:2},{value:"In-place Heap Sort",id:"in-place-heap-sort",level:3},{value:"K-way Problems",id:"k-way-problems",level:2},{value:"1. Find K Largest Elements",id:"1-find-k-largest-elements",level:3},{value:"2. Find K Smallest Elements",id:"2-find-k-smallest-elements",level:3},{value:"3. Kth Largest Element",id:"3-kth-largest-element",level:3},{value:"4. Top K Frequent Elements",id:"4-top-k-frequent-elements",level:3},{value:"5. Merge K Sorted Arrays",id:"5-merge-k-sorted-arrays",level:3},{value:"Advanced Heap Techniques",id:"advanced-heap-techniques",level:2},{value:"1. Running Median",id:"1-running-median",level:3},{value:"2. Task Scheduler with Cooling Period",id:"2-task-scheduler-with-cooling-period",level:3},{value:"3. Sliding Window Maximum",id:"3-sliding-window-maximum",level:3},{value:"4. Meeting Rooms II (Minimum Conference Rooms)",id:"4-meeting-rooms-ii-minimum-conference-rooms",level:3},{value:"Custom Comparator Heaps",id:"custom-comparator-heaps",level:2},{value:"1. Custom Object Heap",id:"1-custom-object-heap",level:3},{value:"2. Distance-based Heap",id:"2-distance-based-heap",level:3},{value:"3. String Length Heap",id:"3-string-length-heap",level:3},{value:"Usage Examples",id:"usage-examples",level:2},{value:"Time Complexity Summary",id:"time-complexity-summary",level:2},{value:"Common Patterns to Remember",id:"common-patterns-to-remember",level:2},{value:"1. <strong>Min Heap for K Largest</strong>",id:"1-min-heap-for-k-largest",level:3},{value:"2. <strong>Max Heap for K Smallest</strong>",id:"2-max-heap-for-k-smallest",level:3},{value:"3. <strong>Two Heaps for Median</strong>",id:"3-two-heaps-for-median",level:3},{value:"4. <strong>Priority Queue Pattern</strong>",id:"4-priority-queue-pattern",level:3},{value:"5. <strong>Heap with Index Tracking</strong>",id:"5-heap-with-index-tracking",level:3},{value:"Key Interview Tips",id:"key-interview-tips",level:2},{value:"Advanced Problem Patterns",id:"advanced-problem-patterns",level:2},{value:"1. <strong>Interval Scheduling Pattern</strong>",id:"1-interval-scheduling-pattern",level:3},{value:"2. <strong>Multi-way Merge Pattern</strong>",id:"2-multi-way-merge-pattern",level:3},{value:"3. <strong>Top-K Pattern</strong>",id:"3-top-k-pattern",level:3},{value:"Real-World Applications",id:"real-world-applications",level:2},{value:"1. <strong>CPU Task Scheduling</strong>",id:"1-cpu-task-scheduling",level:3},{value:"2. <strong>Network Request Prioritization</strong>",id:"2-network-request-prioritization",level:3},{value:"3. <strong>Event Simulation</strong>",id:"3-event-simulation",level:3},{value:"Optimization Techniques",id:"optimization-techniques",level:2},{value:"1. <strong>Lazy Deletion</strong>",id:"1-lazy-deletion",level:3},{value:"2. <strong>Batch Operations</strong>",id:"2-batch-operations",level:3},{value:"Common Mistakes to Avoid",id:"common-mistakes-to-avoid",level:2},{value:"1. <strong>Wrong Heap Type</strong>",id:"1-wrong-heap-type",level:3},{value:"2. <strong>Incorrect Heapify Direction</strong>",id:"2-incorrect-heapify-direction",level:3},{value:"3. <strong>Forgetting Edge Cases</strong>",id:"3-forgetting-edge-cases",level:3},{value:"Testing Your Heap Implementation",id:"testing-your-heap-implementation",level:2},{value:"Practice Problems",id:"practice-problems",level:2},{value:"Easy Level",id:"easy-level",level:3},{value:"Medium Level",id:"medium-level",level:3},{value:"Hard Level",id:"hard-level",level:3}];function o(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"heap",children:"Heap"})}),"\n",(0,t.jsx)(n.p,{children:"A comprehensive guide to heap algorithms and techniques for Data Structures and Algorithms in JavaScript."}),"\n",(0,t.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#basic-heap-concepts",children:"Basic Heap Concepts"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#heap-implementation",children:"Heap Implementation"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#basic-heap-operations",children:"Basic Heap Operations"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#priority-queue-implementation",children:"Priority Queue Implementation"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#heap-sort-algorithm",children:"Heap Sort Algorithm"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#k-way-problems",children:"K-way Problems"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#advanced-heap-techniques",children:"Advanced Heap Techniques"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#custom-comparator-heaps",children:"Custom Comparator Heaps"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#usage-examples",children:"Usage Examples"})}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"basic-heap-concepts",children:"Basic Heap Concepts"}),"\n",(0,t.jsx)(n.p,{children:"A heap is a complete binary tree that satisfies the heap property. It's commonly implemented using arrays for efficiency."}),"\n",(0,t.jsx)(n.h3,{id:"heap-properties",children:"Heap Properties"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Max Heap"}),": Parent \u2265 Children (root is maximum)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Min Heap"}),": Parent \u2264 Children (root is minimum)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Complete Binary Tree"}),": All levels filled except possibly the last, which fills left to right"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"array-representation",children:"Array Representation"}),"\n",(0,t.jsxs)(n.p,{children:["For a node at index ",(0,t.jsx)(n.code,{children:"i"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Parent: ",(0,t.jsx)(n.code,{children:"Math.floor((i - 1) / 2)"})]}),"\n",(0,t.jsxs)(n.li,{children:["Left Child: ",(0,t.jsx)(n.code,{children:"2 * i + 1"})]}),"\n",(0,t.jsxs)(n.li,{children:["Right Child: ",(0,t.jsx)(n.code,{children:"2 * i + 2"})]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"heap-implementation",children:"Heap Implementation"}),"\n",(0,t.jsx)(n.h3,{id:"basic-heap-class",children:"Basic Heap Class"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'class MinHeap {\n    constructor() {\n        this.heap = [];\n    }\n\n    // Get parent, left child, right child indices\n    getParentIndex(index) {\n        return Math.floor((index - 1) / 2);\n    }\n\n    getLeftChildIndex(index) {\n        return 2 * index + 1;\n    }\n\n    getRightChildIndex(index) {\n        return 2 * index + 2;\n    }\n\n    // Check if indices exist\n    hasParent(index) {\n        return this.getParentIndex(index) >= 0;\n    }\n\n    hasLeftChild(index) {\n        return this.getLeftChildIndex(index) < this.heap.length;\n    }\n\n    hasRightChild(index) {\n        return this.getRightChildIndex(index) < this.heap.length;\n    }\n\n    // Get values\n    parent(index) {\n        return this.heap[this.getParentIndex(index)];\n    }\n\n    leftChild(index) {\n        return this.heap[this.getLeftChildIndex(index)];\n    }\n\n    rightChild(index) {\n        return this.heap[this.getRightChildIndex(index)];\n    }\n\n    // Utility methods\n    swap(index1, index2) {\n        [this.heap[index1], this.heap[index2]] = [this.heap[index2], this.heap[index1]];\n    }\n\n    peek() {\n        if (this.heap.length === 0) throw new Error("Heap is empty");\n        return this.heap[0];\n    }\n\n    size() {\n        return this.heap.length;\n    }\n\n    isEmpty() {\n        return this.heap.length === 0;\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"max-heap-implementation",children:"Max Heap Implementation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'class MaxHeap {\n    constructor() {\n        this.heap = [];\n    }\n\n    getParentIndex(index) {\n        return Math.floor((index - 1) / 2);\n    }\n\n    getLeftChildIndex(index) {\n        return 2 * index + 1;\n    }\n\n    getRightChildIndex(index) {\n        return 2 * index + 2;\n    }\n\n    hasParent(index) {\n        return this.getParentIndex(index) >= 0;\n    }\n\n    hasLeftChild(index) {\n        return this.getLeftChildIndex(index) < this.heap.length;\n    }\n\n    hasRightChild(index) {\n        return this.getRightChildIndex(index) < this.heap.length;\n    }\n\n    parent(index) {\n        return this.heap[this.getParentIndex(index)];\n    }\n\n    leftChild(index) {\n        return this.heap[this.getLeftChildIndex(index)];\n    }\n\n    rightChild(index) {\n        return this.heap[this.getRightChildIndex(index)];\n    }\n\n    swap(index1, index2) {\n        [this.heap[index1], this.heap[index2]] = [this.heap[index2], this.heap[index1]];\n    }\n\n    peek() {\n        if (this.heap.length === 0) throw new Error("Heap is empty");\n        return this.heap[0];\n    }\n\n    size() {\n        return this.heap.length;\n    }\n\n    isEmpty() {\n        return this.heap.length === 0;\n    }\n}\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"basic-heap-operations",children:"Basic Heap Operations"}),"\n",(0,t.jsx)(n.h3,{id:"1-insert-add-element",children:"1. Insert (Add Element)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// MinHeap insert\ninsert(item) {\n    this.heap.push(item);\n    this.heapifyUp();\n}\n\nheapifyUp() {\n    let index = this.heap.length - 1;\n\n    while (this.hasParent(index) && this.parent(index) > this.heap[index]) {\n        this.swap(this.getParentIndex(index), index);\n        index = this.getParentIndex(index);\n    }\n}\n\n// MaxHeap insert\ninsert(item) {\n    this.heap.push(item);\n    this.heapifyUp();\n}\n\nheapifyUp() {\n    let index = this.heap.length - 1;\n\n    while (this.hasParent(index) && this.parent(index) < this.heap[index]) {\n        this.swap(this.getParentIndex(index), index);\n        index = this.getParentIndex(index);\n    }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Time Complexity:"})," O(log n)"]}),"\n",(0,t.jsx)(n.h3,{id:"2-extract-minmax-remove-root",children:"2. Extract Min/Max (Remove Root)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'// MinHeap extract\nextractMin() {\n    if (this.heap.length === 0) throw new Error("Heap is empty");\n\n    const item = this.heap[0];\n    this.heap[0] = this.heap[this.heap.length - 1];\n    this.heap.pop();\n\n    if (this.heap.length > 0) {\n        this.heapifyDown();\n    }\n\n    return item;\n}\n\nheapifyDown() {\n    let index = 0;\n\n    while (this.hasLeftChild(index)) {\n        let smallerChildIndex = this.getLeftChildIndex(index);\n\n        if (this.hasRightChild(index) &&\n            this.rightChild(index) < this.leftChild(index)) {\n            smallerChildIndex = this.getRightChildIndex(index);\n        }\n\n        if (this.heap[index] < this.heap[smallerChildIndex]) {\n            break;\n        } else {\n            this.swap(index, smallerChildIndex);\n        }\n\n        index = smallerChildIndex;\n    }\n}\n\n// MaxHeap extract\nextractMax() {\n    if (this.heap.length === 0) throw new Error("Heap is empty");\n\n    const item = this.heap[0];\n    this.heap[0] = this.heap[this.heap.length - 1];\n    this.heap.pop();\n\n    if (this.heap.length > 0) {\n        this.heapifyDown();\n    }\n\n    return item;\n}\n\nheapifyDown() {\n    let index = 0;\n\n    while (this.hasLeftChild(index)) {\n        let largerChildIndex = this.getLeftChildIndex(index);\n\n        if (this.hasRightChild(index) &&\n            this.rightChild(index) > this.leftChild(index)) {\n            largerChildIndex = this.getRightChildIndex(index);\n        }\n\n        if (this.heap[index] > this.heap[largerChildIndex]) {\n            break;\n        } else {\n            this.swap(index, largerChildIndex);\n        }\n\n        index = largerChildIndex;\n    }\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Time Complexity:"})," O(log n)"]}),"\n",(0,t.jsx)(n.h3,{id:"3-build-heap-from-array",children:"3. Build Heap from Array"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"buildHeap(array) {\n    this.heap = [...array];\n\n    // Start from last non-leaf node and heapify down\n    for (let i = Math.floor(this.heap.length / 2) - 1; i >= 0; i--) {\n        this.heapifyDownFrom(i);\n    }\n}\n\nheapifyDownFrom(index) {\n    while (this.hasLeftChild(index)) {\n        let smallerChildIndex = this.getLeftChildIndex(index);\n\n        if (this.hasRightChild(index) &&\n            this.rightChild(index) < this.leftChild(index)) {\n            smallerChildIndex = this.getRightChildIndex(index);\n        }\n\n        if (this.heap[index] < this.heap[smallerChildIndex]) {\n            break;\n        } else {\n            this.swap(index, smallerChildIndex);\n        }\n\n        index = smallerChildIndex;\n    }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Time Complexity:"})," O(n)"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"\ud83d\udca1 Pro Tip:"})," Building a heap from an array is more efficient than inserting elements one by one!"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"priority-queue-implementation",children:"Priority Queue Implementation"}),"\n",(0,t.jsx)(n.h3,{id:"basic-priority-queue",children:"Basic Priority Queue"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"class PriorityQueue {\n    constructor(compareFn) {\n        this.heap = [];\n        this.compare = compareFn || ((a, b) => a - b); // Default: min heap\n    }\n\n    insert(item) {\n        this.heap.push(item);\n        this.heapifyUp();\n    }\n\n    extractTop() {\n        if (this.heap.length === 0) return null;\n\n        const top = this.heap[0];\n        const last = this.heap.pop();\n\n        if (this.heap.length > 0) {\n            this.heap[0] = last;\n            this.heapifyDown();\n        }\n\n        return top;\n    }\n\n    peek() {\n        return this.heap.length > 0 ? this.heap[0] : null;\n    }\n\n    size() {\n        return this.heap.length;\n    }\n\n    isEmpty() {\n        return this.heap.length === 0;\n    }\n\n    heapifyUp() {\n        let index = this.heap.length - 1;\n\n        while (index > 0) {\n            const parentIndex = Math.floor((index - 1) / 2);\n\n            if (this.compare(this.heap[index], this.heap[parentIndex]) >= 0) {\n                break;\n            }\n\n            [this.heap[index], this.heap[parentIndex]] =\n            [this.heap[parentIndex], this.heap[index]];\n\n            index = parentIndex;\n        }\n    }\n\n    heapifyDown() {\n        let index = 0;\n\n        while (2 * index + 1 < this.heap.length) {\n            let childIndex = 2 * index + 1;\n\n            if (2 * index + 2 < this.heap.length &&\n                this.compare(this.heap[2 * index + 2], this.heap[childIndex]) < 0) {\n                childIndex = 2 * index + 2;\n            }\n\n            if (this.compare(this.heap[index], this.heap[childIndex]) <= 0) {\n                break;\n            }\n\n            [this.heap[index], this.heap[childIndex]] =\n            [this.heap[childIndex], this.heap[index]];\n\n            index = childIndex;\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"priority-queue-with-objects",children:"Priority Queue with Objects"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"class TaskPriorityQueue {\n    constructor() {\n        this.heap = [];\n    }\n\n    enqueue(task, priority) {\n        const node = { task, priority };\n        this.heap.push(node);\n        this.heapifyUp();\n    }\n\n    dequeue() {\n        if (this.isEmpty()) return null;\n\n        const top = this.heap[0];\n        const last = this.heap.pop();\n\n        if (!this.isEmpty()) {\n            this.heap[0] = last;\n            this.heapifyDown();\n        }\n\n        return top.task;\n    }\n\n    heapifyUp() {\n        let index = this.heap.length - 1;\n\n        while (index > 0) {\n            const parentIndex = Math.floor((index - 1) / 2);\n\n            if (this.heap[parentIndex].priority <= this.heap[index].priority) {\n                break;\n            }\n\n            [this.heap[index], this.heap[parentIndex]] =\n            [this.heap[parentIndex], this.heap[index]];\n\n            index = parentIndex;\n        }\n    }\n\n    heapifyDown() {\n        let index = 0;\n\n        while (2 * index + 1 < this.heap.length) {\n            let childIndex = 2 * index + 1;\n\n            if (2 * index + 2 < this.heap.length &&\n                this.heap[2 * index + 2].priority < this.heap[childIndex].priority) {\n                childIndex = 2 * index + 2;\n            }\n\n            if (this.heap[index].priority <= this.heap[childIndex].priority) {\n                break;\n            }\n\n            [this.heap[index], this.heap[childIndex]] =\n            [this.heap[childIndex], this.heap[index]];\n\n            index = childIndex;\n        }\n    }\n\n    isEmpty() {\n        return this.heap.length === 0;\n    }\n\n    size() {\n        return this.heap.length;\n    }\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"heap-sort-algorithm",children:"Heap Sort Algorithm"}),"\n",(0,t.jsx)(n.h3,{id:"in-place-heap-sort",children:"In-place Heap Sort"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function heapSort(arr) {\n    const n = arr.length;\n\n    // Build max heap\n    for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {\n        heapify(arr, n, i);\n    }\n\n    // Extract elements one by one\n    for (let i = n - 1; i > 0; i--) {\n        // Move current root to end\n        [arr[0], arr[i]] = [arr[i], arr[0]];\n\n        // Call heapify on the reduced heap\n        heapify(arr, i, 0);\n    }\n\n    return arr;\n}\n\nfunction heapify(arr, heapSize, rootIndex) {\n    let largest = rootIndex;\n    let left = 2 * rootIndex + 1;\n    let right = 2 * rootIndex + 2;\n\n    // If left child is larger than root\n    if (left < heapSize && arr[left] > arr[largest]) {\n        largest = left;\n    }\n\n    // If right child is larger than largest so far\n    if (right < heapSize && arr[right] > arr[largest]) {\n        largest = right;\n    }\n\n    // If largest is not root\n    if (largest !== rootIndex) {\n        [arr[rootIndex], arr[largest]] = [arr[largest], arr[rootIndex]];\n\n        // Recursively heapify the affected sub-tree\n        heapify(arr, heapSize, largest);\n    }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Time Complexity:"})," O(n log n) | ",(0,t.jsx)(n.strong,{children:"Space Complexity:"})," O(1)"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"k-way-problems",children:"K-way Problems"}),"\n",(0,t.jsx)(n.h3,{id:"1-find-k-largest-elements",children:"1. Find K Largest Elements"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function findKLargest(arr, k) {\n    const minHeap = new MinHeap();\n\n    for (const num of arr) {\n        if (minHeap.size() < k) {\n            minHeap.insert(num);\n        } else if (num > minHeap.peek()) {\n            minHeap.extractMin();\n            minHeap.insert(num);\n        }\n    }\n\n    const result = [];\n    while (!minHeap.isEmpty()) {\n        result.unshift(minHeap.extractMin());\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"2-find-k-smallest-elements",children:"2. Find K Smallest Elements"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function findKSmallest(arr, k) {\n    const maxHeap = new MaxHeap();\n\n    for (const num of arr) {\n        if (maxHeap.size() < k) {\n            maxHeap.insert(num);\n        } else if (num < maxHeap.peek()) {\n            maxHeap.extractMax();\n            maxHeap.insert(num);\n        }\n    }\n\n    const result = [];\n    while (!maxHeap.isEmpty()) {\n        result.push(maxHeap.extractMax());\n    }\n\n    return result.reverse();\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"3-kth-largest-element",children:"3. Kth Largest Element"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function findKthLargest(nums, k) {\n    const minHeap = new MinHeap();\n\n    for (const num of nums) {\n        minHeap.insert(num);\n\n        if (minHeap.size() > k) {\n            minHeap.extractMin();\n        }\n    }\n\n    return minHeap.peek();\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"4-top-k-frequent-elements",children:"4. Top K Frequent Elements"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function topKFrequent(nums, k) {\n    // Count frequencies\n    const freqMap = new Map();\n    for (const num of nums) {\n        freqMap.set(num, (freqMap.get(num) || 0) + 1);\n    }\n\n    // Use min heap to keep track of top k frequent elements\n    const minHeap = new PriorityQueue((a, b) => a[1] - b[1]);\n\n    for (const [num, freq] of freqMap) {\n        minHeap.insert([num, freq]);\n\n        if (minHeap.size() > k) {\n            minHeap.extractTop();\n        }\n    }\n\n    const result = [];\n    while (!minHeap.isEmpty()) {\n        result.unshift(minHeap.extractTop()[0]);\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"5-merge-k-sorted-arrays",children:"5. Merge K Sorted Arrays"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function mergeKSortedArrays(arrays) {\n    const minHeap = new PriorityQueue((a, b) => a.val - b.val);\n    const result = [];\n\n    // Initialize heap with first element from each array\n    for (let i = 0; i < arrays.length; i++) {\n        if (arrays[i].length > 0) {\n            minHeap.insert({\n                val: arrays[i][0],\n                arrayIndex: i,\n                elementIndex: 0\n            });\n        }\n    }\n\n    while (!minHeap.isEmpty()) {\n        const { val, arrayIndex, elementIndex } = minHeap.extractTop();\n        result.push(val);\n\n        // Add next element from same array if available\n        if (elementIndex + 1 < arrays[arrayIndex].length) {\n            minHeap.insert({\n                val: arrays[arrayIndex][elementIndex + 1],\n                arrayIndex: arrayIndex,\n                elementIndex: elementIndex + 1\n            });\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"advanced-heap-techniques",children:"Advanced Heap Techniques"}),"\n",(0,t.jsx)(n.h3,{id:"1-running-median",children:"1. Running Median"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"class MedianFinder {\n    constructor() {\n        this.maxHeap = new MaxHeap(); // For smaller half\n        this.minHeap = new MinHeap(); // For larger half\n    }\n\n    addNum(num) {\n        // Add to max heap first\n        this.maxHeap.insert(num);\n\n        // Move the largest from max heap to min heap\n        this.minHeap.insert(this.maxHeap.extractMax());\n\n        // Balance the heaps\n        if (this.minHeap.size() > this.maxHeap.size()) {\n            this.maxHeap.insert(this.minHeap.extractMin());\n        }\n    }\n\n    findMedian() {\n        if (this.maxHeap.size() > this.minHeap.size()) {\n            return this.maxHeap.peek();\n        }\n\n        return (this.maxHeap.peek() + this.minHeap.peek()) / 2.0;\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"2-task-scheduler-with-cooling-period",children:"2. Task Scheduler with Cooling Period"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function leastInterval(tasks, n) {\n    const freqMap = new Map();\n\n    // Count task frequencies\n    for (const task of tasks) {\n        freqMap.set(task, (freqMap.get(task) || 0) + 1);\n    }\n\n    // Max heap for frequencies\n    const maxHeap = new MaxHeap();\n    for (const freq of freqMap.values()) {\n        maxHeap.insert(freq);\n    }\n\n    const queue = []; // [frequency, available_time]\n    let time = 0;\n\n    while (!maxHeap.isEmpty() || queue.length > 0) {\n        time++;\n\n        // Add back tasks that are available\n        if (queue.length > 0 && queue[0][1] === time) {\n            maxHeap.insert(queue.shift()[0]);\n        }\n\n        if (!maxHeap.isEmpty()) {\n            const freq = maxHeap.extractMax() - 1;\n\n            if (freq > 0) {\n                queue.push([freq, time + n + 1]);\n            }\n        }\n    }\n\n    return time;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"3-sliding-window-maximum",children:"3. Sliding Window Maximum"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function maxSlidingWindow(nums, k) {\n    const result = [];\n    const maxHeap = new PriorityQueue((a, b) => b.val - a.val);\n\n    for (let i = 0; i < nums.length; i++) {\n        // Add current element\n        maxHeap.insert({ val: nums[i], index: i });\n\n        // Remove elements outside window\n        while (!maxHeap.isEmpty() && maxHeap.peek().index <= i - k) {\n            maxHeap.extractTop();\n        }\n\n        // Add to result if window is complete\n        if (i >= k - 1) {\n            result.push(maxHeap.peek().val);\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"4-meeting-rooms-ii-minimum-conference-rooms",children:"4. Meeting Rooms II (Minimum Conference Rooms)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function minMeetingRooms(intervals) {\n    if (intervals.length === 0) return 0;\n\n    // Sort by start time\n    intervals.sort((a, b) => a[0] - b[0]);\n\n    // Min heap to track end times\n    const minHeap = new MinHeap();\n\n    for (const interval of intervals) {\n        // If current meeting starts after earliest ending meeting\n        if (!minHeap.isEmpty() && minHeap.peek() <= interval[0]) {\n            minHeap.extractMin();\n        }\n\n        // Add current meeting's end time\n        minHeap.insert(interval[1]);\n    }\n\n    return minHeap.size();\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"custom-comparator-heaps",children:"Custom Comparator Heaps"}),"\n",(0,t.jsx)(n.h3,{id:"1-custom-object-heap",children:"1. Custom Object Heap"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"class CustomHeap {\n    constructor(compareFn) {\n        this.heap = [];\n        this.compare = compareFn;\n    }\n\n    insert(item) {\n        this.heap.push(item);\n        this.heapifyUp();\n    }\n\n    extractTop() {\n        if (this.heap.length === 0) return null;\n\n        const top = this.heap[0];\n        const last = this.heap.pop();\n\n        if (this.heap.length > 0) {\n            this.heap[0] = last;\n            this.heapifyDown();\n        }\n\n        return top;\n    }\n\n    heapifyUp() {\n        let index = this.heap.length - 1;\n\n        while (index > 0) {\n            const parentIndex = Math.floor((index - 1) / 2);\n\n            if (this.compare(this.heap[index], this.heap[parentIndex]) >= 0) {\n                break;\n            }\n\n            [this.heap[index], this.heap[parentIndex]] =\n            [this.heap[parentIndex], this.heap[index]];\n\n            index = parentIndex;\n        }\n    }\n\n    heapifyDown() {\n        let index = 0;\n\n        while (2 * index + 1 < this.heap.length) {\n            let childIndex = 2 * index + 1;\n\n            if (2 * index + 2 < this.heap.length &&\n                this.compare(this.heap[2 * index + 2], this.heap[childIndex]) < 0) {\n                childIndex = 2 * index + 2;\n            }\n\n            if (this.compare(this.heap[index], this.heap[childIndex]) <= 0) {\n                break;\n            }\n\n            [this.heap[index], this.heap[childIndex]] =\n            [this.heap[childIndex], this.heap[index]];\n\n            index = childIndex;\n        }\n    }\n\n    peek() {\n        return this.heap.length > 0 ? this.heap[0] : null;\n    }\n\n    size() {\n        return this.heap.length;\n    }\n\n    isEmpty() {\n        return this.heap.length === 0;\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"2-distance-based-heap",children:"2. Distance-based Heap"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// Find K closest points to origin\nfunction kClosest(points, k) {\n    const distance = (point) => point[0] * point[0] + point[1] * point[1];\n\n    const maxHeap = new CustomHeap((a, b) => distance(b) - distance(a));\n\n    for (const point of points) {\n        maxHeap.insert(point);\n\n        if (maxHeap.size() > k) {\n            maxHeap.extractTop();\n        }\n    }\n\n    const result = [];\n    while (!maxHeap.isEmpty()) {\n        result.push(maxHeap.extractTop());\n    }\n\n    return result;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"3-string-length-heap",children:"3. String Length Heap"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// Custom heap for string lengths\nfunction organizeStrings(strings) {\n    const lengthHeap = new CustomHeap((a, b) => a.length - b.length);\n\n    for (const str of strings) {\n        lengthHeap.insert(str);\n    }\n\n    const organized = [];\n    while (!lengthHeap.isEmpty()) {\n        organized.push(lengthHeap.extractTop());\n    }\n\n    return organized;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'console.log("=== Heap Techniques Demo ===");\n\n// Basic Min Heap\nconst minHeap = new MinHeap();\n[3, 1, 4, 1, 5, 9, 2, 6].forEach(num => minHeap.insert(num));\nconsole.log("Min Heap peek:", minHeap.peek()); // 1\n\n// Basic Max Heap\nconst maxHeap = new MaxHeap();\n[3, 1, 4, 1, 5, 9, 2, 6].forEach(num => maxHeap.insert(num));\nconsole.log("Max Heap peek:", maxHeap.peek()); // 9\n\n// Priority Queue\nconst pq = new TaskPriorityQueue();\npq.enqueue("Low priority task", 3);\npq.enqueue("High priority task", 1);\npq.enqueue("Medium priority task", 2);\n\nconsole.log("Priority Queue order:");\nwhile (!pq.isEmpty()) {\n    console.log(pq.dequeue());\n}\n// Output: High priority task, Medium priority task, Low priority task\n\n// Heap Sort\nconst unsorted = [64, 34, 25, 12, 22, 11, 90];\nconsole.log("Original array:", unsorted);\nconsole.log("Heap sorted:", heapSort([...unsorted]));\n\n// K largest elements\nconst numbers = [3, 2, 1, 5, 6, 4];\nconsole.log("3 largest elements:", findKLargest(numbers, 3)); // [6, 5, 4]\n\n// Running median\nconst medianFinder = new MedianFinder();\n[1, 2, 3, 4, 5].forEach(num => {\n    medianFinder.addNum(num);\n    console.log(`After adding ${num}, median:`, medianFinder.findMedian());\n});\n\n// Top K frequent elements\nconst nums = [1, 1, 1, 2, 2, 3];\nconsole.log("Top 2 frequent:", topKFrequent(nums, 2)); // [1, 2]\n\n// Merge K sorted arrays\nconst sortedArrays = [[1, 4, 5], [1, 3, 4], [2, 6]];\nconsole.log("Merged arrays:", mergeKSortedArrays(sortedArrays)); // [1,1,2,3,4,4,5,6]\n\n// Custom heap demo\nconst customHeap = new CustomHeap((a, b) => a.priority - b.priority);\ncustomHeap.insert({ name: "Task A", priority: 3 });\ncustomHeap.insert({ name: "Task B", priority: 1 });\ncustomHeap.insert({ name: "Task C", priority: 2 });\n\nconsole.log("Custom heap order:");\nwhile (!customHeap.isEmpty()) {\n    console.log(customHeap.extractTop().name);\n}\n// Output: Task B, Task C, Task A\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"time-complexity-summary",children:"Time Complexity Summary"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Operation"}),(0,t.jsx)(n.th,{children:"Time Complexity"}),(0,t.jsx)(n.th,{children:"Space Complexity"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Insert"}),(0,t.jsx)(n.td,{children:"O(log n)"}),(0,t.jsx)(n.td,{children:"O(1)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Extract Min/Max"}),(0,t.jsx)(n.td,{children:"O(log n)"}),(0,t.jsx)(n.td,{children:"O(1)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Peek"}),(0,t.jsx)(n.td,{children:"O(1)"}),(0,t.jsx)(n.td,{children:"O(1)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Build Heap"}),(0,t.jsx)(n.td,{children:"O(n)"}),(0,t.jsx)(n.td,{children:"O(1)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Heap Sort"}),(0,t.jsx)(n.td,{children:"O(n log n)"}),(0,t.jsx)(n.td,{children:"O(1)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Find K Largest"}),(0,t.jsx)(n.td,{children:"O(n log k)"}),(0,t.jsx)(n.td,{children:"O(k)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Merge K Arrays"}),(0,t.jsx)(n.td,{children:"O(n log k)"}),(0,t.jsx)(n.td,{children:"O(k)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Running Median"}),(0,t.jsx)(n.td,{children:"O(log n) insert"}),(0,t.jsx)(n.td,{children:"O(n)"})]})]})]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"common-patterns-to-remember",children:"Common Patterns to Remember"}),"\n",(0,t.jsxs)(n.h3,{id:"1-min-heap-for-k-largest",children:["1. ",(0,t.jsx)(n.strong,{children:"Min Heap for K Largest"})]}),"\n",(0,t.jsx)(n.p,{children:"Use min heap of size k to find k largest elements:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"if (minHeap.size() < k) {\n    minHeap.insert(element);\n} else if (element > minHeap.peek()) {\n    minHeap.extractMin();\n    minHeap.insert(element);\n}\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"2-max-heap-for-k-smallest",children:["2. ",(0,t.jsx)(n.strong,{children:"Max Heap for K Smallest"})]}),"\n",(0,t.jsx)(n.p,{children:"Use max heap of size k to find k smallest elements:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"if (maxHeap.size() < k) {\n    maxHeap.insert(element);\n} else if (element < maxHeap.peek()) {\n    maxHeap.extractMax();\n    maxHeap.insert(element);\n}\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"3-two-heaps-for-median",children:["3. ",(0,t.jsx)(n.strong,{children:"Two Heaps for Median"})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Max heap for smaller half"}),"\n",(0,t.jsx)(n.li,{children:"Min heap for larger half"}),"\n",(0,t.jsx)(n.li,{children:"Balance: max heap size \u2265 min heap size"}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"4-priority-queue-pattern",children:["4. ",(0,t.jsx)(n.strong,{children:"Priority Queue Pattern"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"while (!pq.isEmpty()) {\n    const current = pq.extractTop();\n    // Process current\n    // Add new elements to pq based on processing\n}\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"5-heap-with-index-tracking",children:["5. ",(0,t.jsx)(n.strong,{children:"Heap with Index Tracking"})]}),"\n",(0,t.jsx)(n.p,{children:"For sliding window problems:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"heap.insert({ value: nums[i], index: i });\n// Remove elements outside window\nwhile (heap.peek().index <= i - k) {\n    heap.extractTop();\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"key-interview-tips",children:"Key Interview Tips"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Choose the right heap"}),": Min heap for k largest, max heap for k smallest"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Two heaps pattern"}),": For median problems, use one max heap and one min heap"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Custom comparators"}),": Define comparison logic for complex objects"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Index tracking"}),": For sliding window problems, store both value and index"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Build vs Insert"}),": Building heap from array is O(n), inserting n elements is O(n log n)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Priority queues"}),": Heaps are perfect for implementing priority queues"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Memory efficiency"}),": Heaps use less memory than balanced BSTs for similar operations"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"advanced-problem-patterns",children:"Advanced Problem Patterns"}),"\n",(0,t.jsxs)(n.h3,{id:"1-interval-scheduling-pattern",children:["1. ",(0,t.jsx)(n.strong,{children:"Interval Scheduling Pattern"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// Sort by start time, use min heap for end times\nintervals.sort((a, b) => a[0] - b[0]);\nconst endTimes = new MinHeap();\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"2-multi-way-merge-pattern",children:["2. ",(0,t.jsx)(n.strong,{children:"Multi-way Merge Pattern"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// Initialize heap with first element from each source\nfor (let i = 0; i < sources.length; i++) {\n    if (sources[i].length > 0) {\n        heap.insert({ val: sources[i][0], sourceIndex: i, elementIndex: 0 });\n    }\n}\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"3-top-k-pattern",children:["3. ",(0,t.jsx)(n.strong,{children:"Top-K Pattern"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// Maintain heap of size k\nif (heap.size() < k) {\n    heap.insert(element);\n} else if (shouldReplace(element, heap.peek())) {\n    heap.extractTop();\n    heap.insert(element);\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"real-world-applications",children:"Real-World Applications"}),"\n",(0,t.jsxs)(n.h3,{id:"1-cpu-task-scheduling",children:["1. ",(0,t.jsx)(n.strong,{children:"CPU Task Scheduling"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"class CPUScheduler {\n    constructor() {\n        this.taskQueue = new PriorityQueue((a, b) => a.priority - b.priority);\n    }\n\n    addTask(task, priority) {\n        this.taskQueue.insert({ task, priority, timestamp: Date.now() });\n    }\n\n    getNextTask() {\n        return this.taskQueue.isEmpty() ? null : this.taskQueue.extractTop();\n    }\n}\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"2-network-request-prioritization",children:["2. ",(0,t.jsx)(n.strong,{children:"Network Request Prioritization"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"class NetworkManager {\n    constructor() {\n        this.requestQueue = new PriorityQueue((a, b) => {\n            // Higher priority first, then by timestamp for fairness\n            if (a.priority !== b.priority) {\n                return a.priority - b.priority;\n            }\n            return a.timestamp - b.timestamp;\n        });\n    }\n\n    enqueueRequest(request, priority) {\n        this.requestQueue.insert({\n            ...request,\n            priority,\n            timestamp: Date.now()\n        });\n    }\n\n    processNextRequest() {\n        return this.requestQueue.extractTop();\n    }\n}\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"3-event-simulation",children:["3. ",(0,t.jsx)(n.strong,{children:"Event Simulation"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"class EventSimulator {\n    constructor() {\n        this.eventQueue = new PriorityQueue((a, b) => a.time - b.time);\n        this.currentTime = 0;\n    }\n\n    scheduleEvent(event, time) {\n        this.eventQueue.insert({ ...event, time });\n    }\n\n    runSimulation() {\n        while (!this.eventQueue.isEmpty()) {\n            const event = this.eventQueue.extractTop();\n            this.currentTime = event.time;\n            this.processEvent(event);\n        }\n    }\n\n    processEvent(event) {\n        // Process event and potentially schedule new events\n        console.log(`Processing ${event.type} at time ${event.time}`);\n    }\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"optimization-techniques",children:"Optimization Techniques"}),"\n",(0,t.jsxs)(n.h3,{id:"1-lazy-deletion",children:["1. ",(0,t.jsx)(n.strong,{children:"Lazy Deletion"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"class LazyHeap {\n    constructor() {\n        this.heap = [];\n        this.deleted = new Set();\n    }\n\n    insert(item) {\n        this.heap.push(item);\n        this.heapifyUp();\n    }\n\n    delete(item) {\n        this.deleted.add(item);\n    }\n\n    extractTop() {\n        while (!this.isEmpty() && this.deleted.has(this.heap[0])) {\n            const top = this.heap[0];\n            this.heap[0] = this.heap[this.heap.length - 1];\n            this.heap.pop();\n            this.deleted.delete(top);\n            if (!this.isEmpty()) {\n                this.heapifyDown();\n            }\n        }\n\n        if (this.isEmpty()) return null;\n\n        const top = this.heap[0];\n        this.heap[0] = this.heap[this.heap.length - 1];\n        this.heap.pop();\n        if (!this.isEmpty()) {\n            this.heapifyDown();\n        }\n\n        return top;\n    }\n}\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"2-batch-operations",children:["2. ",(0,t.jsx)(n.strong,{children:"Batch Operations"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"class BatchHeap {\n    constructor() {\n        this.heap = [];\n        this.pendingInserts = [];\n    }\n\n    insert(item) {\n        this.pendingInserts.push(item);\n    }\n\n    flush() {\n        if (this.pendingInserts.length > 0) {\n            this.heap.push(...this.pendingInserts);\n            this.buildHeap();\n            this.pendingInserts = [];\n        }\n    }\n\n    extractTop() {\n        this.flush();\n        if (this.heap.length === 0) return null;\n\n        const top = this.heap[0];\n        this.heap[0] = this.heap[this.heap.length - 1];\n        this.heap.pop();\n        if (this.heap.length > 0) {\n            this.heapifyDown();\n        }\n\n        return top;\n    }\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"common-mistakes-to-avoid",children:"Common Mistakes to Avoid"}),"\n",(0,t.jsxs)(n.h3,{id:"1-wrong-heap-type",children:["1. ",(0,t.jsx)(n.strong,{children:"Wrong Heap Type"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// \u274c Wrong: Using max heap for k smallest\nconst maxHeap = new MaxHeap();\nfor (const num of nums) {\n    maxHeap.insert(num);\n    if (maxHeap.size() > k) {\n        maxHeap.extractMax(); // This removes largest, not what we want!\n    }\n}\n\n// \u2705 Correct: Using max heap for k smallest\nconst maxHeap = new MaxHeap();\nfor (const num of nums) {\n    if (maxHeap.size() < k) {\n        maxHeap.insert(num);\n    } else if (num < maxHeap.peek()) {\n        maxHeap.extractMax();\n        maxHeap.insert(num);\n    }\n}\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"2-incorrect-heapify-direction",children:["2. ",(0,t.jsx)(n.strong,{children:"Incorrect Heapify Direction"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// \u274c Wrong: Not handling parent-child relationship correctly\nheapifyUp() {\n    let index = this.heap.length - 1;\n    while (index > 0 && this.heap[index] < this.heap[index - 1]) { // Wrong comparison\n        // This compares with previous element, not parent!\n    }\n}\n\n// \u2705 Correct: Compare with actual parent\nheapifyUp() {\n    let index = this.heap.length - 1;\n    while (index > 0) {\n        const parentIndex = Math.floor((index - 1) / 2);\n        if (this.heap[index] >= this.heap[parentIndex]) break;\n        [this.heap[index], this.heap[parentIndex]] = [this.heap[parentIndex], this.heap[index]];\n        index = parentIndex;\n    }\n}\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"3-forgetting-edge-cases",children:["3. ",(0,t.jsx)(n.strong,{children:"Forgetting Edge Cases"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'// \u2705 Always check for empty heap\npeek() {\n    if (this.heap.length === 0) {\n        throw new Error("Heap is empty");\n    }\n    return this.heap[0];\n}\n\nextractTop() {\n    if (this.heap.length === 0) {\n        return null; // or throw error\n    }\n    // ... rest of implementation\n}\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"testing-your-heap-implementation",children:"Testing Your Heap Implementation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'function testHeap() {\n    console.log("=== Testing Heap Implementation ===");\n\n    // Test Min Heap\n    const minHeap = new MinHeap();\n    const testData = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5];\n\n    console.log("Inserting:", testData);\n    testData.forEach(num => minHeap.insert(num));\n\n    console.log("Extracting in ascending order:");\n    const extracted = [];\n    while (!minHeap.isEmpty()) {\n        extracted.push(minHeap.extractMin());\n    }\n    console.log(extracted);\n\n    // Test should show sorted array\n    const sorted = [...testData].sort((a, b) => a - b);\n    console.log("Expected:", sorted);\n    console.log("Test passed:", JSON.stringify(extracted) === JSON.stringify(sorted));\n\n    // Test Priority Queue\n    const pq = new PriorityQueue((a, b) => a.priority - b.priority);\n    pq.insert({ task: "Low", priority: 3 });\n    pq.insert({ task: "High", priority: 1 });\n    pq.insert({ task: "Medium", priority: 2 });\n\n    console.log("\\nPriority Queue test:");\n    while (!pq.isEmpty()) {\n        console.log(pq.extractTop());\n    }\n}\n\n// Run tests\ntestHeap();\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"practice-problems",children:"Practice Problems"}),"\n",(0,t.jsx)(n.h3,{id:"easy-level",children:"Easy Level"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Kth Largest Element in Array"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Last Stone Weight"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Find K Largest Elements"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Merge Two Sorted Lists"})}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"medium-level",children:"Medium Level"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Top K Frequent Elements"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Meeting Rooms II"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Task Scheduler"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Find Median from Data Stream"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Kth Smallest Element in Sorted Matrix"})}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"hard-level",children:"Hard Level"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Merge K Sorted Lists"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Sliding Window Maximum"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Smallest Range Covering Elements from K Lists"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Trapping Rain Water II"})}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This comprehensive guide covers all essential heap concepts and techniques needed for coding interviews and competitive programming. The key is understanding when to use heaps and which type (min/max) is appropriate for each problem!"})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>h});var t=i(6540);const s={},a=t.createContext(s);function r(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function h(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);