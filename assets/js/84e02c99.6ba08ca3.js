"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[3959],{5585:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>a,metadata:()=>s,toc:()=>l});var i=t(4848),r=t(8453);const a={},o="Common Design Patterns in Java",s={id:"Low Level design/Common Design Patterns in Java",title:"Common Design Patterns in Java",description:"Table of Contents",source:"@site/docs/Low Level design/Common Design Patterns in Java.mdx",sourceDirName:"Low Level design",slug:"/Low Level design/Common Design Patterns in Java",permalink:"/js.enigma/docs/Low Level design/Common Design Patterns in Java",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/Low Level design/Common Design Patterns in Java.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Low Level Design",permalink:"/js.enigma/docs/category/low-level-design"},next:{title:"LLD Interview Cheat Sheet",permalink:"/js.enigma/docs/Low Level design/LLD Interview Cheat Sheet"}},c={},l=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Introduction to Design Patterns",id:"introduction-to-design-patterns",level:2},{value:"What are Design Patterns?",id:"what-are-design-patterns",level:3},{value:"Benefits",id:"benefits",level:3},{value:"Categories",id:"categories",level:3},{value:"Creational Patterns",id:"creational-patterns",level:2},{value:"1. Singleton Pattern",id:"1-singleton-pattern",level:3},{value:"Thread-Safe Singleton Implementation",id:"thread-safe-singleton-implementation",level:4},{value:"Enum Singleton (Recommended)",id:"enum-singleton-recommended",level:4},{value:"2. Factory Method Pattern",id:"2-factory-method-pattern",level:3},{value:"3. Abstract Factory Pattern",id:"3-abstract-factory-pattern",level:3},{value:"4. Builder Pattern",id:"4-builder-pattern",level:3},{value:"Structural Patterns",id:"structural-patterns",level:2},{value:"5. Adapter Pattern",id:"5-adapter-pattern",level:3},{value:"6. Decorator Pattern",id:"6-decorator-pattern",level:3},{value:"7. Facade Pattern",id:"7-facade-pattern",level:3},{value:"Behavioral Patterns",id:"behavioral-patterns",level:2},{value:"8. Observer Pattern",id:"8-observer-pattern",level:3},{value:"9. Strategy Pattern",id:"9-strategy-pattern",level:3},{value:"10. Command Pattern",id:"10-command-pattern",level:3},{value:"11. Template Method Pattern",id:"11-template-method-pattern",level:3},{value:"12. State Pattern",id:"12-state-pattern",level:3},{value:"Pattern Relationships",id:"pattern-relationships",level:2},{value:"Pattern Combinations",id:"pattern-combinations",level:3},{value:"1. Observer + Command",id:"1-observer--command",level:4},{value:"2. Factory + Singleton",id:"2-factory--singleton",level:4},{value:"3. &quot;Design a payment processing system&quot;",id:"3-design-a-payment-processing-system",level:4},{value:"4. &quot;How would you implement undo functionality?&quot;",id:"4-how-would-you-implement-undo-functionality",level:4},{value:"5. &quot;Design a file processing system for different formats&quot;",id:"5-design-a-file-processing-system-for-different-formats",level:4},{value:"Pattern Identification Questions",id:"pattern-identification-questions",level:3},{value:"Question: &quot;What patterns can you identify in this code?&quot;",id:"question-what-patterns-can-you-identify-in-this-code",level:4},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Pattern Selection Guidelines",id:"1-pattern-selection-guidelines",level:3},{value:"Do Use Patterns When:",id:"do-use-patterns-when",level:4},{value:"Don&#39;t Use Patterns When:",id:"dont-use-patterns-when",level:4},{value:"2. Implementation Best Practices",id:"2-implementation-best-practices",level:3},{value:"Singleton Pattern",id:"singleton-pattern",level:4},{value:"Factory Pattern",id:"factory-pattern",level:4},{value:"Observer Pattern",id:"observer-pattern",level:4},{value:"3. Performance Considerations",id:"3-performance-considerations",level:3},{value:"Memory Usage",id:"memory-usage",level:4},{value:"Lazy Initialization",id:"lazy-initialization",level:4},{value:"4. Testing Patterns",id:"4-testing-patterns",level:3},{value:"Dependency Injection for Testability",id:"dependency-injection-for-testability",level:4},{value:"5. Common Mistakes",id:"5-common-mistakes",level:3},{value:"Mistake 1: Overusing Singleton",id:"mistake-1-overusing-singleton",level:4},{value:"Mistake 2: Not Following SOLID Principles",id:"mistake-2-not-following-solid-principles",level:4},{value:"Mistake 3: Ignoring Thread Safety",id:"mistake-3-ignoring-thread-safety",level:4},{value:"Summary",id:"summary",level:2},{value:"Key Takeaways",id:"key-takeaways",level:3},{value:"Pattern Categories Quick Reference",id:"pattern-categories-quick-reference",level:3},{value:"Creational (Object Creation)",id:"creational-object-creation",level:4},{value:"Structural (Object Composition)",id:"structural-object-composition",level:4},{value:"Behavioral (Object Interaction)",id:"behavioral-object-interaction",level:4},{value:"Interview Preparation Tips",id:"interview-preparation-tips",level:3}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"common-design-patterns-in-java",children:"Common Design Patterns in Java"})}),"\n",(0,i.jsx)(e.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#introduction-to-design-patterns",children:"Introduction to Design Patterns"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#creational-patterns",children:"Creational Patterns"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#structural-patterns",children:"Structural Patterns"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#behavioral-patterns",children:"Behavioral Patterns"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#pattern-relationships",children:"Pattern Relationships"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#when-to-use-which-pattern",children:"When to Use Which Pattern"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#interview-questions",children:"Interview Questions"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#best-practices",children:"Best Practices"})}),"\n"]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"introduction-to-design-patterns",children:"Introduction to Design Patterns"}),"\n",(0,i.jsx)(e.h3,{id:"what-are-design-patterns",children:"What are Design Patterns?"}),"\n",(0,i.jsxs)(e.p,{children:["Design patterns are ",(0,i.jsx)(e.strong,{children:"reusable solutions to commonly occurring problems"})," in software design. They represent best practices and provide a common vocabulary for developers."]}),"\n",(0,i.jsx)(e.h3,{id:"benefits",children:"Benefits"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Reusability"})," - Proven solutions"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Communication"})," - Common vocabulary"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Best Practices"})," - Time-tested approaches"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Maintainability"})," - Well-structured code"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"categories",children:"Categories"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Creational"})," - Object creation mechanisms"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Structural"})," - Object composition"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Behavioral"})," - Object interaction and responsibilities"]}),"\n"]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"creational-patterns",children:"Creational Patterns"}),"\n",(0,i.jsx)(e.h3,{id:"1-singleton-pattern",children:"1. Singleton Pattern"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Intent:"})," Ensure a class has only one instance and provide global access to it."]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"When to Use:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Database connections"}),"\n",(0,i.jsx)(e.li,{children:"Logger instances"}),"\n",(0,i.jsx)(e.li,{children:"Configuration settings"}),"\n",(0,i.jsx)(e.li,{children:"Thread pools"}),"\n"]}),"\n",(0,i.jsx)(e.h4,{id:"thread-safe-singleton-implementation",children:"Thread-Safe Singleton Implementation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'public class DatabaseConnection {\n    // Volatile ensures visibility across threads\n    private static volatile DatabaseConnection instance;\n    private Connection connection;\n\n    // Private constructor prevents instantiation\n    private DatabaseConnection() {\n        // Initialize database connection\n        this.connection = createConnection();\n    }\n\n    // Double-checked locking for thread safety\n    public static DatabaseConnection getInstance() {\n        if (instance == null) {\n            synchronized (DatabaseConnection.class) {\n                if (instance == null) {\n                    instance = new DatabaseConnection();\n                }\n            }\n        }\n        return instance;\n    }\n\n    public Connection getConnection() {\n        return connection;\n    }\n\n    private Connection createConnection() {\n        // Database connection logic\n        return DriverManager.getConnection("jdbc:mysql://localhost/db");\n    }\n}\n'})}),"\n",(0,i.jsx)(e.h4,{id:"enum-singleton-recommended",children:"Enum Singleton (Recommended)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'public enum Logger {\n    INSTANCE;\n\n    public void log(String message) {\n        System.out.println(new Date() + ": " + message);\n    }\n\n    public void error(String message) {\n        System.err.println(new Date() + " ERROR: " + message);\n    }\n}\n\n// Usage\nLogger.INSTANCE.log("Application started");\n'})}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Pros:"})," Thread-safe, simple, prevents reflection attacks\n",(0,i.jsx)(e.strong,{children:"Cons:"})," Cannot be extended, difficult to unit test"]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h3,{id:"2-factory-method-pattern",children:"2. Factory Method Pattern"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Intent:"})," Create objects without specifying their exact classes."]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"When to Use:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"When you don't know the exact types beforehand"}),"\n",(0,i.jsx)(e.li,{children:"When you want to delegate object creation"}),"\n",(0,i.jsx)(e.li,{children:"When you need to extend object creation logic"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'// Product interface\ninterface Vehicle {\n    void start();\n    void stop();\n    int getMaxSpeed();\n}\n\n// Concrete products\nclass Car implements Vehicle {\n    @Override\n    public void start() {\n        System.out.println("Car engine started");\n    }\n\n    @Override\n    public void stop() {\n        System.out.println("Car engine stopped");\n    }\n\n    @Override\n    public int getMaxSpeed() {\n        return 200;\n    }\n}\n\nclass Motorcycle implements Vehicle {\n    @Override\n    public void start() {\n        System.out.println("Motorcycle engine started");\n    }\n\n    @Override\n    public void stop() {\n        System.out.println("Motorcycle engine stopped");\n    }\n\n    @Override\n    public int getMaxSpeed() {\n        return 180;\n    }\n}\n\nclass Truck implements Vehicle {\n    @Override\n    public void start() {\n        System.out.println("Truck engine started");\n    }\n\n    @Override\n    public void stop() {\n        System.out.println("Truck engine stopped");\n    }\n\n    @Override\n    public int getMaxSpeed() {\n        return 120;\n    }\n}\n\n// Factory class\nclass VehicleFactory {\n    public static Vehicle createVehicle(String type) {\n        switch (type.toLowerCase()) {\n            case "car":\n                return new Car();\n            case "motorcycle":\n                return new Motorcycle();\n            case "truck":\n                return new Truck();\n            default:\n                throw new IllegalArgumentException("Unknown vehicle type: " + type);\n        }\n    }\n\n    // Alternative factory method with enum\n    public enum VehicleType {\n        CAR, MOTORCYCLE, TRUCK\n    }\n\n    public static Vehicle createVehicle(VehicleType type) {\n        switch (type) {\n            case CAR:\n                return new Car();\n            case MOTORCYCLE:\n                return new Motorcycle();\n            case TRUCK:\n                return new Truck();\n            default:\n                throw new IllegalArgumentException("Unknown vehicle type");\n        }\n    }\n}\n\n// Usage\npublic class FactoryExample {\n    public static void main(String[] args) {\n        Vehicle car = VehicleFactory.createVehicle("car");\n        car.start();\n        System.out.println("Max speed: " + car.getMaxSpeed());\n        car.stop();\n\n        Vehicle truck = VehicleFactory.createVehicle(VehicleType.TRUCK);\n        truck.start();\n        truck.stop();\n    }\n}\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h3,{id:"3-abstract-factory-pattern",children:"3. Abstract Factory Pattern"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Intent:"})," Create families of related objects without specifying their concrete classes."]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"When to Use:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"When you need to create families of related objects"}),"\n",(0,i.jsx)(e.li,{children:"When you want to ensure objects from a family work together"}),"\n",(0,i.jsx)(e.li,{children:"When you want to switch between different product families"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'// Abstract products\ninterface Button {\n    void click();\n    void render();\n}\n\ninterface Checkbox {\n    void check();\n    void render();\n}\n\n// Concrete products for Windows\nclass WindowsButton implements Button {\n    @Override\n    public void click() {\n        System.out.println("Windows button clicked");\n    }\n\n    @Override\n    public void render() {\n        System.out.println("Rendering Windows-style button");\n    }\n}\n\nclass WindowsCheckbox implements Checkbox {\n    @Override\n    public void check() {\n        System.out.println("Windows checkbox checked");\n    }\n\n    @Override\n    public void render() {\n        System.out.println("Rendering Windows-style checkbox");\n    }\n}\n\n// Concrete products for Mac\nclass MacButton implements Button {\n    @Override\n    public void click() {\n        System.out.println("Mac button clicked");\n    }\n\n    @Override\n    public void render() {\n        System.out.println("Rendering Mac-style button");\n    }\n}\n\nclass MacCheckbox implements Checkbox {\n    @Override\n    public void check() {\n        System.out.println("Mac checkbox checked");\n    }\n\n    @Override\n    public void render() {\n        System.out.println("Rendering Mac-style checkbox");\n    }\n}\n\n// Abstract factory\ninterface GUIFactory {\n    Button createButton();\n    Checkbox createCheckbox();\n}\n\n// Concrete factories\nclass WindowsFactory implements GUIFactory {\n    @Override\n    public Button createButton() {\n        return new WindowsButton();\n    }\n\n    @Override\n    public Checkbox createCheckbox() {\n        return new WindowsCheckbox();\n    }\n}\n\nclass MacFactory implements GUIFactory {\n    @Override\n    public Button createButton() {\n        return new MacButton();\n    }\n\n    @Override\n    public Checkbox createCheckbox() {\n        return new MacCheckbox();\n    }\n}\n\n// Client code\nclass Application {\n    private Button button;\n    private Checkbox checkbox;\n\n    public Application(GUIFactory factory) {\n        button = factory.createButton();\n        checkbox = factory.createCheckbox();\n    }\n\n    public void render() {\n        button.render();\n        checkbox.render();\n    }\n\n    public void interact() {\n        button.click();\n        checkbox.check();\n    }\n}\n\n// Usage\npublic class AbstractFactoryExample {\n    public static void main(String[] args) {\n        String osName = System.getProperty("os.name").toLowerCase();\n        GUIFactory factory;\n\n        if (osName.contains("windows")) {\n            factory = new WindowsFactory();\n        } else if (osName.contains("mac")) {\n            factory = new MacFactory();\n        } else {\n            factory = new WindowsFactory(); // Default\n        }\n\n        Application app = new Application(factory);\n        app.render();\n        app.interact();\n    }\n}\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h3,{id:"4-builder-pattern",children:"4. Builder Pattern"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Intent:"})," Construct complex objects step by step."]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"When to Use:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Objects with many optional parameters"}),"\n",(0,i.jsx)(e.li,{children:"Objects requiring complex construction logic"}),"\n",(0,i.jsx)(e.li,{children:"When you want to create different representations"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'// Product class\nclass Computer {\n    private String CPU;\n    private String RAM;\n    private String storage;\n    private String GPU;\n    private String motherboard;\n    private boolean isBluetoothEnabled;\n    private boolean isWifiEnabled;\n\n    // Private constructor - only builder can create\n    private Computer(ComputerBuilder builder) {\n        this.CPU = builder.CPU;\n        this.RAM = builder.RAM;\n        this.storage = builder.storage;\n        this.GPU = builder.GPU;\n        this.motherboard = builder.motherboard;\n        this.isBluetoothEnabled = builder.isBluetoothEnabled;\n        this.isWifiEnabled = builder.isWifiEnabled;\n    }\n\n    // Getters\n    public String getCPU() { return CPU; }\n    public String getRAM() { return RAM; }\n    public String getStorage() { return storage; }\n    public String getGPU() { return GPU; }\n    public String getMotherboard() { return motherboard; }\n    public boolean isBluetoothEnabled() { return isBluetoothEnabled; }\n    public boolean isWifiEnabled() { return isWifiEnabled; }\n\n    @Override\n    public String toString() {\n        return "Computer{" +\n                "CPU=\'" + CPU + \'\\\'\' +\n                ", RAM=\'" + RAM + \'\\\'\' +\n                ", storage=\'" + storage + \'\\\'\' +\n                ", GPU=\'" + GPU + \'\\\'\' +\n                ", motherboard=\'" + motherboard + \'\\\'\' +\n                ", isBluetoothEnabled=" + isBluetoothEnabled +\n                ", isWifiEnabled=" + isWifiEnabled +\n                \'}\';\n    }\n\n    // Builder class\n    public static class ComputerBuilder {\n        // Required parameters\n        private String CPU;\n        private String RAM;\n\n        // Optional parameters - initialized to default values\n        private String storage = "500GB HDD";\n        private String GPU = "Integrated";\n        private String motherboard = "Standard";\n        private boolean isBluetoothEnabled = false;\n        private boolean isWifiEnabled = true;\n\n        // Constructor with required parameters\n        public ComputerBuilder(String CPU, String RAM) {\n            this.CPU = CPU;\n            this.RAM = RAM;\n        }\n\n        // Setter methods for optional parameters - return builder for chaining\n        public ComputerBuilder setStorage(String storage) {\n            this.storage = storage;\n            return this;\n        }\n\n        public ComputerBuilder setGPU(String GPU) {\n            this.GPU = GPU;\n            return this;\n        }\n\n        public ComputerBuilder setMotherboard(String motherboard) {\n            this.motherboard = motherboard;\n            return this;\n        }\n\n        public ComputerBuilder setBluetoothEnabled(boolean bluetoothEnabled) {\n            isBluetoothEnabled = bluetoothEnabled;\n            return this;\n        }\n\n        public ComputerBuilder setWifiEnabled(boolean wifiEnabled) {\n            isWifiEnabled = wifiEnabled;\n            return this;\n        }\n\n        // Build method to create the final object\n        public Computer build() {\n            return new Computer(this);\n        }\n    }\n}\n\n// Usage\npublic class BuilderExample {\n    public static void main(String[] args) {\n        // Creating a basic computer\n        Computer basicComputer = new Computer.ComputerBuilder("Intel i5", "8GB")\n                .build();\n\n        // Creating a gaming computer\n        Computer gamingComputer = new Computer.ComputerBuilder("Intel i9", "32GB")\n                .setStorage("1TB SSD")\n                .setGPU("NVIDIA RTX 4090")\n                .setMotherboard("ASUS ROG")\n                .setBluetoothEnabled(true)\n                .setWifiEnabled(true)\n                .build();\n\n        // Creating a server computer\n        Computer server = new Computer.ComputerBuilder("AMD Ryzen 9", "64GB")\n                .setStorage("2TB SSD")\n                .setMotherboard("Server Grade")\n                .setWifiEnabled(false)\n                .build();\n\n        System.out.println("Basic Computer: " + basicComputer);\n        System.out.println("Gaming Computer: " + gamingComputer);\n        System.out.println("Server: " + server);\n    }\n}\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"structural-patterns",children:"Structural Patterns"}),"\n",(0,i.jsx)(e.h3,{id:"5-adapter-pattern",children:"5. Adapter Pattern"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Intent:"})," Allow incompatible interfaces to work together."]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"When to Use:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"When you want to use an existing class with incompatible interface"}),"\n",(0,i.jsx)(e.li,{children:"When you want to create reusable class that cooperates with unrelated classes"}),"\n",(0,i.jsx)(e.li,{children:"Legacy code integration"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'// Target interface that client expects\ninterface MediaPlayer {\n    void play(String audioType, String fileName);\n}\n\n// Adaptee classes with incompatible interfaces\nclass Mp3Player {\n    public void playMp3(String fileName) {\n        System.out.println("Playing mp3 file: " + fileName);\n    }\n}\n\nclass Mp4Player {\n    public void playMp4(String fileName) {\n        System.out.println("Playing mp4 file: " + fileName);\n    }\n}\n\nclass VlcPlayer {\n    public void playVlc(String fileName) {\n        System.out.println("Playing vlc file: " + fileName);\n    }\n}\n\n// Adapter interface\ninterface AdvancedMediaPlayer {\n    void playVlc(String fileName);\n    void playMp4(String fileName);\n}\n\n// Adapter class\nclass MediaAdapter implements AdvancedMediaPlayer {\n    private Mp4Player mp4Player;\n    private VlcPlayer vlcPlayer;\n\n    public MediaAdapter(String audioType) {\n        if (audioType.equalsIgnoreCase("vlc")) {\n            vlcPlayer = new VlcPlayer();\n        } else if (audioType.equalsIgnoreCase("mp4")) {\n            mp4Player = new Mp4Player();\n        }\n    }\n\n    @Override\n    public void playVlc(String fileName) {\n        vlcPlayer.playVlc(fileName);\n    }\n\n    @Override\n    public void playMp4(String fileName) {\n        mp4Player.playMp4(fileName);\n    }\n}\n\n// Concrete implementation of target interface\nclass AudioPlayer implements MediaPlayer {\n    private MediaAdapter mediaAdapter;\n    private Mp3Player mp3Player;\n\n    public AudioPlayer() {\n        mp3Player = new Mp3Player();\n    }\n\n    @Override\n    public void play(String audioType, String fileName) {\n        // Built-in support for mp3\n        if (audioType.equalsIgnoreCase("mp3")) {\n            mp3Player.playMp3(fileName);\n        }\n        // Using adapter for other formats\n        else if (audioType.equalsIgnoreCase("vlc") ||\n                 audioType.equalsIgnoreCase("mp4")) {\n            mediaAdapter = new MediaAdapter(audioType);\n            if (audioType.equalsIgnoreCase("vlc")) {\n                mediaAdapter.playVlc(fileName);\n            } else if (audioType.equalsIgnoreCase("mp4")) {\n                mediaAdapter.playMp4(fileName);\n            }\n        } else {\n            System.out.println("Invalid media. " + audioType + " format not supported");\n        }\n    }\n}\n\n// Usage\npublic class AdapterExample {\n    public static void main(String[] args) {\n        AudioPlayer audioPlayer = new AudioPlayer();\n\n        audioPlayer.play("mp3", "beyond_the_horizon.mp3");\n        audioPlayer.play("mp4", "alone.mp4");\n        audioPlayer.play("vlc", "far_far_away.vlc");\n        audioPlayer.play("avi", "mind_me.avi");\n    }\n}\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h3,{id:"6-decorator-pattern",children:"6. Decorator Pattern"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Intent:"})," Add new functionality to objects dynamically without altering their structure."]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"When to Use:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"When you want to add responsibilities to objects dynamically"}),"\n",(0,i.jsx)(e.li,{children:"When extension by subclassing is impractical"}),"\n",(0,i.jsx)(e.li,{children:"When you need to add features that can be withdrawn"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'// Component interface\ninterface Coffee {\n    String getDescription();\n    double getCost();\n}\n\n// Concrete component\nclass SimpleCoffee implements Coffee {\n    @Override\n    public String getDescription() {\n        return "Simple Coffee";\n    }\n\n    @Override\n    public double getCost() {\n        return 2.0;\n    }\n}\n\n// Abstract decorator\nabstract class CoffeeDecorator implements Coffee {\n    protected Coffee decoratedCoffee;\n\n    public CoffeeDecorator(Coffee coffee) {\n        this.decoratedCoffee = coffee;\n    }\n\n    @Override\n    public String getDescription() {\n        return decoratedCoffee.getDescription();\n    }\n\n    @Override\n    public double getCost() {\n        return decoratedCoffee.getCost();\n    }\n}\n\n// Concrete decorators\nclass MilkDecorator extends CoffeeDecorator {\n    public MilkDecorator(Coffee coffee) {\n        super(coffee);\n    }\n\n    @Override\n    public String getDescription() {\n        return decoratedCoffee.getDescription() + ", Milk";\n    }\n\n    @Override\n    public double getCost() {\n        return decoratedCoffee.getCost() + 0.5;\n    }\n}\n\nclass SugarDecorator extends CoffeeDecorator {\n    public SugarDecorator(Coffee coffee) {\n        super(coffee);\n    }\n\n    @Override\n    public String getDescription() {\n        return decoratedCoffee.getDescription() + ", Sugar";\n    }\n\n    @Override\n    public double getCost() {\n        return decoratedCoffee.getCost() + 0.3;\n    }\n}\n\nclass WhipDecorator extends CoffeeDecorator {\n    public WhipDecorator(Coffee coffee) {\n        super(coffee);\n    }\n\n    @Override\n    public String getDescription() {\n        return decoratedCoffee.getDescription() + ", Whip";\n    }\n\n    @Override\n    public double getCost() {\n        return decoratedCoffee.getCost() + 0.7;\n    }\n}\n\nclass VanillaDecorator extends CoffeeDecorator {\n    public VanillaDecorator(Coffee coffee) {\n        super(coffee);\n    }\n\n    @Override\n    public String getDescription() {\n        return decoratedCoffee.getDescription() + ", Vanilla";\n    }\n\n    @Override\n    public double getCost() {\n        return decoratedCoffee.getCost() + 0.6;\n    }\n}\n\n// Usage\npublic class DecoratorExample {\n    public static void main(String[] args) {\n        // Simple coffee\n        Coffee coffee = new SimpleCoffee();\n        System.out.println(coffee.getDescription() + " - $" + coffee.getCost());\n\n        // Coffee with milk\n        coffee = new MilkDecorator(coffee);\n        System.out.println(coffee.getDescription() + " - $" + coffee.getCost());\n\n        // Coffee with milk and sugar\n        coffee = new SugarDecorator(coffee);\n        System.out.println(coffee.getDescription() + " - $" + coffee.getCost());\n\n        // Coffee with milk, sugar, and whip\n        coffee = new WhipDecorator(coffee);\n        System.out.println(coffee.getDescription() + " - $" + coffee.getCost());\n\n        // Ultimate coffee\n        Coffee ultimateCoffee = new VanillaDecorator(\n                new WhipDecorator(\n                    new SugarDecorator(\n                        new MilkDecorator(\n                            new SimpleCoffee()))));\n\n        System.out.println("\\nUltimate: " + ultimateCoffee.getDescription() +\n                          " - $" + ultimateCoffee.getCost());\n    }\n}\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h3,{id:"7-facade-pattern",children:"7. Facade Pattern"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Intent:"})," Provide a simplified interface to a complex subsystem."]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"When to Use:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"When you want to hide complexity of subsystems"}),"\n",(0,i.jsx)(e.li,{children:"When you want to layer your subsystems"}),"\n",(0,i.jsx)(e.li,{children:"When there are many dependencies between clients and implementation classes"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'// Complex subsystem classes\nclass CPU {\n    public void freeze() {\n        System.out.println("CPU: Freezing processor");\n    }\n\n    public void jump(long position) {\n        System.out.println("CPU: Jumping to position " + position);\n    }\n\n    public void execute() {\n        System.out.println("CPU: Executing instructions");\n    }\n}\n\nclass Memory {\n    public void load(long position, byte[] data) {\n        System.out.println("Memory: Loading data at position " + position);\n    }\n}\n\nclass HardDrive {\n    public byte[] read(long lba, int size) {\n        System.out.println("HardDrive: Reading " + size + " bytes from LBA " + lba);\n        return new byte[size];\n    }\n}\n\nclass NetworkInterface {\n    public void connect(String address) {\n        System.out.println("Network: Connecting to " + address);\n    }\n\n    public void disconnect() {\n        System.out.println("Network: Disconnecting");\n    }\n}\n\nclass GraphicsCard {\n    public void initialize() {\n        System.out.println("Graphics: Initializing graphics card");\n    }\n\n    public void render() {\n        System.out.println("Graphics: Rendering display");\n    }\n}\n\n// Facade class\nclass ComputerFacade {\n    private CPU cpu;\n    private Memory memory;\n    private HardDrive hardDrive;\n    private NetworkInterface networkInterface;\n    private GraphicsCard graphicsCard;\n\n    public ComputerFacade() {\n        this.cpu = new CPU();\n        this.memory = new Memory();\n        this.hardDrive = new HardDrive();\n        this.networkInterface = new NetworkInterface();\n        this.graphicsCard = new GraphicsCard();\n    }\n\n    public void startComputer() {\n        System.out.println("Starting computer...");\n        cpu.freeze();\n        memory.load(0, hardDrive.read(0, 1024));\n        cpu.jump(0);\n        graphicsCard.initialize();\n        cpu.execute();\n        graphicsCard.render();\n        System.out.println("Computer started successfully!\\n");\n    }\n\n    public void shutdownComputer() {\n        System.out.println("Shutting down computer...");\n        System.out.println("Saving work...");\n        System.out.println("Closing applications...");\n        networkInterface.disconnect();\n        System.out.println("Computer shutdown complete!\\n");\n    }\n\n    public void connectToInternet(String address) {\n        System.out.println("Connecting to internet...");\n        networkInterface.connect(address);\n        System.out.println("Connected to internet!\\n");\n    }\n\n    public void restartComputer() {\n        System.out.println("Restarting computer...");\n        shutdownComputer();\n        startComputer();\n    }\n}\n\n// Usage\npublic class FacadeExample {\n    public static void main(String[] args) {\n        ComputerFacade computer = new ComputerFacade();\n\n        // Simple operations hide complex subsystem interactions\n        computer.startComputer();\n        computer.connectToInternet("www.example.com");\n        computer.restartComputer();\n        computer.shutdownComputer();\n    }\n}\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"behavioral-patterns",children:"Behavioral Patterns"}),"\n",(0,i.jsx)(e.h3,{id:"8-observer-pattern",children:"8. Observer Pattern"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Intent:"})," Define a one-to-many dependency between objects so that when one object changes state, all dependents are notified."]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"When to Use:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"When changes to one object require changing many objects"}),"\n",(0,i.jsx)(e.li,{children:"When an object should notify other objects without knowing who they are"}),"\n",(0,i.jsx)(e.li,{children:"Event handling systems"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'import java.util.*;\n\n// Observer interface\ninterface Observer {\n    void update(String message);\n}\n\n// Subject interface\ninterface Subject {\n    void registerObserver(Observer observer);\n    void removeObserver(Observer observer);\n    void notifyObservers();\n}\n\n// Concrete Subject\nclass NewsAgency implements Subject {\n    private List<Observer> observers;\n    private String latestNews;\n\n    public NewsAgency() {\n        this.observers = new ArrayList<>();\n    }\n\n    @Override\n    public void registerObserver(Observer observer) {\n        observers.add(observer);\n        System.out.println("Observer registered: " + observer.getClass().getSimpleName());\n    }\n\n    @Override\n    public void removeObserver(Observer observer) {\n        observers.remove(observer);\n        System.out.println("Observer removed: " + observer.getClass().getSimpleName());\n    }\n\n    @Override\n    public void notifyObservers() {\n        System.out.println("\\n--- Broadcasting News ---");\n        for (Observer observer : observers) {\n            observer.update(latestNews);\n        }\n        System.out.println("--- End Broadcast ---\\n");\n    }\n\n    public void setNews(String news) {\n        this.latestNews = news;\n        notifyObservers();\n    }\n\n    public String getLatestNews() {\n        return latestNews;\n    }\n}\n\n// Concrete Observers\nclass NewsChannel implements Observer {\n    private String channelName;\n    private String news;\n\n    public NewsChannel(String channelName) {\n        this.channelName = channelName;\n    }\n\n    @Override\n    public void update(String message) {\n        this.news = message;\n        System.out.println(channelName + " received news: " + news);\n    }\n\n    public String getNews() {\n        return news;\n    }\n}\n\nclass NewspaperAgency implements Observer {\n    private String agencyName;\n    private String news;\n\n    public NewspaperAgency(String agencyName) {\n        this.agencyName = agencyName;\n    }\n\n    @Override\n    public void update(String message) {\n        this.news = message;\n        System.out.println(agencyName + " printing news: " + news);\n    }\n}\n\nclass MobileApp implements Observer {\n    private String appName;\n    private List<String> notifications;\n\n    public MobileApp(String appName) {\n        this.appName = appName;\n        this.notifications = new ArrayList<>();\n    }\n\n    @Override\n    public void update(String message) {\n        notifications.add(message);\n        System.out.println(appName + " push notification: " + message);\n    }\n\n    public List<String> getNotifications() {\n        return notifications;\n    }\n}\n\n// Usage\npublic class ObserverExample {\n    public static void main(String[] args) {\n        // Create subject\n        NewsAgency newsAgency = new NewsAgency();\n\n        // Create observers\n        NewsChannel cnn = new NewsChannel("CNN");\n        NewsChannel bbc = new NewsChannel("BBC");\n        NewspaperAgency nytimes = new NewspaperAgency("New York Times");\n        MobileApp newsApp = new MobileApp("NewsApp");\n\n        // Register observers\n        newsAgency.registerObserver(cnn);\n        newsAgency.registerObserver(bbc);\n        newsAgency.registerObserver(nytimes);\n        newsAgency.registerObserver(newsApp);\n\n        // Publish news\n        newsAgency.setNews("Breaking: New technology breakthrough announced!");\n\n        // Remove an observer\n        newsAgency.removeObserver(bbc);\n\n        // Publish more news\n        newsAgency.setNews("Update: Stock market reaches all-time high!");\n\n        // Show mobile app notifications\n        System.out.println("\\nMobile app notifications:");\n        for (String notification : newsApp.getNotifications()) {\n            System.out.println("- " + notification);\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h3,{id:"9-strategy-pattern",children:"9. Strategy Pattern"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Intent:"})," Define a family of algorithms, encapsulate each one, and make them interchangeable."]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"When to Use:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"When you have multiple ways to perform a task"}),"\n",(0,i.jsx)(e.li,{children:"When you want to avoid conditional statements"}),"\n",(0,i.jsx)(e.li,{children:"When algorithms should be selected at runtime"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'// Strategy interface\ninterface PaymentStrategy {\n    void pay(double amount);\n    boolean validate();\n}\n\n// Concrete strategies\nclass CreditCardPayment implements PaymentStrategy {\n    private String cardNumber;\n    private String cvv;\n    private String expiryDate;\n\n    public CreditCardPayment(String cardNumber, String cvv, String expiryDate) {\n        this.cardNumber = cardNumber;\n        this.cvv = cvv;\n        this.expiryDate = expiryDate;\n    }\n\n    @Override\n    public boolean validate() {\n        // Validate credit card details\n        if (cardNumber.length() != 16) {\n            System.out.println("Invalid card number");\n            return false;\n        }\n        if (cvv.length() != 3) {\n            System.out.println("Invalid CVV");\n            return false;\n        }\n        System.out.println("Credit card validation successful");\n        return true;\n    }\n\n    @Override\n    public void pay(double amount) {\n        if (validate()) {\n            System.out.println("Paid $" + amount + " using Credit Card ending in " +\n                             cardNumber.substring(12));\n        }\n    }\n}\n\nclass PayPalPayment implements PaymentStrategy {\n    private String email;\n    private String password;\n\n    public PayPalPayment(String email, String password) {\n        this.email = email;\n        this.password = password;\n    }\n\n    @Override\n    public boolean validate() {\n        // Validate PayPal credentials\n        if (!email.contains("@")) {\n            System.out.println("Invalid email address");\n            return false;\n        }\n        if (password.length() < 8) {\n            System.out.println("Password too short");\n            return false;\n        }\n        System.out.println("PayPal validation successful");\n        return true;\n    }\n\n    @Override\n    public void pay(double amount) {\n        if (validate()) {\n            System.out.println("Paid $" + amount + " using PayPal account: " + email);\n        }\n    }\n}\n\nclass BankTransferPayment implements PaymentStrategy {\n    private String accountNumber;\n    private String routingNumber;\n\n    public BankTransferPayment(String accountNumber, String routingNumber) {\n        this.accountNumber = accountNumber;\n        this.routingNumber = routingNumber;\n    }\n\n    @Override\n    public boolean validate() {\n        // Validate bank details\n        if (accountNumber.length() < 8) {\n            System.out.println("Invalid account number");\n            return false;\n        }\n        if (routingNumber.length() != 9) {\n            System.out.println("Invalid routing number");\n            return false;\n        }\n        System.out.println("Bank transfer validation successful");\n        return true;\n    }\n\n    @Override\n    public void pay(double amount) {\n        if (validate()) {\n            System.out.println("Paid $" + amount + " via Bank Transfer from account: " +\n                             accountNumber);\n        }\n    }\n}\n\nclass CryptocurrencyPayment implements PaymentStrategy {\n    private String walletAddress;\n    private String privateKey;\n\n    public CryptocurrencyPayment(String walletAddress, String privateKey) {\n        this.walletAddress = walletAddress;\n        this.privateKey = privateKey;\n    }\n\n    @Override\n    public boolean validate() {\n        // Validate cryptocurrency wallet\n        if (walletAddress.length() < 26) {\n            System.out.println("Invalid wallet address");\n            return false;\n        }\n        if (privateKey.length() < 51) {\n            System.out.println("Invalid private key");\n            return false;\n        }\n        System.out.println("Cryptocurrency wallet validation successful");\n        return true;\n    }\n\n    @Override\n    public void pay(double amount) {\n        if (validate()) {\n            System.out.println("Paid $" + amount + " using Cryptocurrency from wallet: " +\n                             walletAddress.substring(0, 10) + "...");\n        }\n    }\n}\n\n// Context class\nclass PaymentContext {\n    private PaymentStrategy paymentStrategy;\n\n    public void setPaymentStrategy(PaymentStrategy paymentStrategy) {\n        this.paymentStrategy = paymentStrategy;\n    }\n\n    public void processPayment(double amount) {\n        if (paymentStrategy == null) {\n            System.out.println("No payment method selected");\n            return;\n        }\n        paymentStrategy.pay(amount);\n    }\n}\n\n// Usage\npublic class StrategyExample {\n    public static void main(String[] args) {\n        PaymentContext paymentContext = new PaymentContext();\n\n        // Pay with credit card\n        PaymentStrategy creditCard = new CreditCardPayment("1234567890123456", "123", "12/25");\n        paymentContext.setPaymentStrategy(creditCard);\n        paymentContext.processPayment(100.0);\n\n        System.out.println();\n\n        // Pay with PayPal\n        PaymentStrategy paypal = new PayPalPayment("user@example.com", "password123");\n        paymentContext.setPaymentStrategy(paypal);\n        paymentContext.processPayment(75.5);\n\n        System.out.println();\n\n        // Pay with Bank Transfer\n        PaymentStrategy bankTransfer = new BankTransferPayment("12345678", "123456789");\n        paymentContext.setPaymentStrategy(bankTransfer);\n        paymentContext.processPayment(200.0);\n\n        System.out.println();\n\n        // Pay with Cryptocurrency\n        PaymentStrategy crypto = new CryptocurrencyPayment("1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa",\n                "5HueCGU8rMjxEXxiPuD5BDku4MkFqeZyd4dZ1jvhTVqvbTLvyTJ");\n        paymentContext.setPaymentStrategy(crypto);\n        paymentContext.processPayment(50.0);\n    }\n}\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h3,{id:"10-command-pattern",children:"10. Command Pattern"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Intent:"})," Encapsulate a request as an object, allowing you to parameterize clients with different requests, queue operations, and support undo."]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"When to Use:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"When you want to parameterize objects with operations"}),"\n",(0,i.jsx)(e.li,{children:"When you want to queue operations, schedule operations, or support undo"}),"\n",(0,i.jsx)(e.li,{children:"When you want to structure a system around high-level operations built on primitive operations"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'// Command interface\ninterface Command {\n    void execute();\n    void undo();\n}\n\n// Receiver classes\nclass Light {\n    private String location;\n    private boolean isOn;\n\n    public Light(String location) {\n        this.location = location;\n        this.isOn = false;\n    }\n\n    public void turnOn() {\n        isOn = true;\n        System.out.println(location + " light is ON");\n    }\n\n    public void turnOff() {\n        isOn = false;\n        System.out.println(location + " light is OFF");\n    }\n\n    public boolean isOn() {\n        return isOn;\n    }\n}\n\nclass Fan {\n    private String location;\n    private int speed; // 0 = off, 1 = low, 2 = medium, 3 = high\n\n    public Fan(String location) {\n        this.location = location;\n        this.speed = 0;\n    }\n\n    public void turnOn() {\n        speed = 1;\n        System.out.println(location + " fan is ON (Low speed)");\n    }\n\n    public void turnOff() {\n        speed = 0;\n        System.out.println(location + " fan is OFF");\n    }\n\n    public void increaseSpeed() {\n        if (speed < 3) {\n            speed++;\n            String[] speedNames = {"OFF", "Low", "Medium", "High"};\n            System.out.println(location + " fan speed: " + speedNames[speed]);\n        }\n    }\n\n    public void decreaseSpeed() {\n        if (speed > 0) {\n            speed--;\n            String[] speedNames = {"OFF", "Low", "Medium", "High"};\n            System.out.println(location + " fan speed: " + speedNames[speed]);\n        }\n    }\n\n    public int getSpeed() {\n        return speed;\n    }\n}\n\nclass Stereo {\n    private String location;\n    private boolean isOn;\n    private int volume;\n\n    public Stereo(String location) {\n        this.location = location;\n        this.isOn = false;\n        this.volume = 0;\n    }\n\n    public void turnOn() {\n        isOn = true;\n        System.out.println(location + " stereo is ON");\n    }\n\n    public void turnOff() {\n        isOn = false;\n        volume = 0;\n        System.out.println(location + " stereo is OFF");\n    }\n\n    public void setVolume(int volume) {\n        this.volume = volume;\n        System.out.println(location + " stereo volume set to " + volume);\n    }\n\n    public int getVolume() {\n        return volume;\n    }\n\n    public boolean isOn() {\n        return isOn;\n    }\n}\n\n// Concrete Commands\nclass LightOnCommand implements Command {\n    private Light light;\n\n    public LightOnCommand(Light light) {\n        this.light = light;\n    }\n\n    @Override\n    public void execute() {\n        light.turnOn();\n    }\n\n    @Override\n    public void undo() {\n        light.turnOff();\n    }\n}\n\nclass LightOffCommand implements Command {\n    private Light light;\n\n    public LightOffCommand(Light light) {\n        this.light = light;\n    }\n\n    @Override\n    public void execute() {\n        light.turnOff();\n    }\n\n    @Override\n    public void undo() {\n        light.turnOn();\n    }\n}\n\nclass FanOnCommand implements Command {\n    private Fan fan;\n\n    public FanOnCommand(Fan fan) {\n        this.fan = fan;\n    }\n\n    @Override\n    public void execute() {\n        fan.turnOn();\n    }\n\n    @Override\n    public void undo() {\n        fan.turnOff();\n    }\n}\n\nclass FanOffCommand implements Command {\n    private Fan fan;\n\n    public FanOffCommand(Fan fan) {\n        this.fan = fan;\n    }\n\n    @Override\n    public void execute() {\n        fan.turnOff();\n    }\n\n    @Override\n    public void undo() {\n        fan.turnOn();\n    }\n}\n\nclass StereoOnWithVolumeCommand implements Command {\n    private Stereo stereo;\n    private int previousVolume;\n\n    public StereoOnWithVolumeCommand(Stereo stereo) {\n        this.stereo = stereo;\n    }\n\n    @Override\n    public void execute() {\n        previousVolume = stereo.getVolume();\n        stereo.turnOn();\n        stereo.setVolume(11);\n    }\n\n    @Override\n    public void undo() {\n        stereo.turnOff();\n    }\n}\n\n// No Operation Command (Null Object Pattern)\nclass NoCommand implements Command {\n    @Override\n    public void execute() {\n        // Do nothing\n    }\n\n    @Override\n    public void undo() {\n        // Do nothing\n    }\n}\n\n// Macro Command - executes multiple commands\nclass MacroCommand implements Command {\n    private Command[] commands;\n\n    public MacroCommand(Command[] commands) {\n        this.commands = commands;\n    }\n\n    @Override\n    public void execute() {\n        for (Command command : commands) {\n            command.execute();\n        }\n    }\n\n    @Override\n    public void undo() {\n        // Undo in reverse order\n        for (int i = commands.length - 1; i >= 0; i--) {\n            commands[i].undo();\n        }\n    }\n}\n\n// Invoker - Remote Control\nclass RemoteControl {\n    private Command[] onCommands;\n    private Command[] offCommands;\n    private Command undoCommand;\n\n    public RemoteControl() {\n        onCommands = new Command[7];\n        offCommands = new Command[7];\n\n        Command noCommand = new NoCommand();\n        for (int i = 0; i < 7; i++) {\n            onCommands[i] = noCommand;\n            offCommands[i] = noCommand;\n        }\n        undoCommand = noCommand;\n    }\n\n    public void setCommand(int slot, Command onCommand, Command offCommand) {\n        onCommands[slot] = onCommand;\n        offCommands[slot] = offCommand;\n    }\n\n    public void onButtonPressed(int slot) {\n        if (slot >= 0 && slot < onCommands.length) {\n            onCommands[slot].execute();\n            undoCommand = onCommands[slot];\n        }\n    }\n\n    public void offButtonPressed(int slot) {\n        if (slot >= 0 && slot < offCommands.length) {\n            offCommands[slot].execute();\n            undoCommand = offCommands[slot];\n        }\n    }\n\n    public void undoButtonPressed() {\n        undoCommand.undo();\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append("\\n------ Remote Control ------\\n");\n        for (int i = 0; i < onCommands.length; i++) {\n            sb.append("[slot ").append(i).append("] ")\n              .append(onCommands[i].getClass().getSimpleName())\n              .append("    ")\n              .append(offCommands[i].getClass().getSimpleName()).append("\\n");\n        }\n        sb.append("[undo] ").append(undoCommand.getClass().getSimpleName()).append("\\n");\n        return sb.toString();\n    }\n}\n\n// Usage\npublic class CommandExample {\n    public static void main(String[] args) {\n        // Create remote control\n        RemoteControl remote = new RemoteControl();\n\n        // Create devices\n        Light livingRoomLight = new Light("Living Room");\n        Light kitchenLight = new Light("Kitchen");\n        Fan bedroomFan = new Fan("Bedroom");\n        Stereo livingRoomStereo = new Stereo("Living Room");\n\n        // Create commands\n        LightOnCommand livingRoomLightOn = new LightOnCommand(livingRoomLight);\n        LightOffCommand livingRoomLightOff = new LightOffCommand(livingRoomLight);\n\n        LightOnCommand kitchenLightOn = new LightOnCommand(kitchenLight);\n        LightOffCommand kitchenLightOff = new LightOffCommand(kitchenLight);\n\n        FanOnCommand bedroomFanOn = new FanOnCommand(bedroomFan);\n        FanOffCommand bedroomFanOff = new FanOffCommand(bedroomFan);\n\n        StereoOnWithVolumeCommand stereoOnWithVolume = new StereoOnWithVolumeCommand(livingRoomStereo);\n\n        // Set commands to remote\n        remote.setCommand(0, livingRoomLightOn, livingRoomLightOff);\n        remote.setCommand(1, kitchenLightOn, kitchenLightOff);\n        remote.setCommand(2, bedroomFanOn, bedroomFanOff);\n        remote.setCommand(3, stereoOnWithVolume, new NoCommand());\n\n        // Create macro command for party mode\n        Command[] partyOn = {livingRoomLightOn, stereoOnWithVolume, bedroomFanOn};\n        Command[] partyOff = {livingRoomLightOff, new NoCommand(), bedroomFanOff};\n\n        MacroCommand partyOnMacro = new MacroCommand(partyOn);\n        MacroCommand partyOffMacro = new MacroCommand(partyOff);\n\n        remote.setCommand(4, partyOnMacro, partyOffMacro);\n\n        System.out.println(remote);\n\n        // Test individual commands\n        System.out.println("--- Testing Individual Commands ---");\n        remote.onButtonPressed(0);  // Living room light on\n        remote.offButtonPressed(0); // Living room light off\n        remote.undoButtonPressed(); // Undo (light back on)\n\n        System.out.println();\n        remote.onButtonPressed(2);  // Bedroom fan on\n        remote.undoButtonPressed(); // Undo (fan off)\n\n        // Test macro command\n        System.out.println("\\n--- Testing Macro Command (Party Mode) ---");\n        remote.onButtonPressed(4);  // Party mode on\n        System.out.println("\\nParty\'s over...");\n        remote.offButtonPressed(4); // Party mode off\n        remote.undoButtonPressed(); // Undo party off (party back on)\n    }\n}\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h3,{id:"11-template-method-pattern",children:"11. Template Method Pattern"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Intent:"})," Define the skeleton of an algorithm in a base class, letting subclasses override specific steps without changing the algorithm's structure."]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"When to Use:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"When you have an algorithm with invariant parts and variant parts"}),"\n",(0,i.jsx)(e.li,{children:"When you want to avoid code duplication in similar algorithms"}),"\n",(0,i.jsx)(e.li,{children:"When you want to control which parts of an algorithm can be extended"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'// Abstract class defining template method\nabstract class DataProcessor {\n\n    // Template method - defines the algorithm skeleton\n    public final void processData() {\n        readData();\n        processDataSpecific();\n        if (shouldValidate()) {\n            validateData();\n        }\n        saveData();\n        if (shouldNotify()) {\n            sendNotification();\n        }\n    }\n\n    // Common step - same for all implementations\n    private void readData() {\n        System.out.println("Reading data from source...");\n    }\n\n    // Abstract method - must be implemented by subclasses\n    protected abstract void processDataSpecific();\n\n    // Hook method - optional override\n    protected boolean shouldValidate() {\n        return true; // Default behavior\n    }\n\n    // Abstract method\n    protected abstract void validateData();\n\n    // Common step\n    private void saveData() {\n        System.out.println("Saving processed data...");\n    }\n\n    // Hook method - optional override\n    protected boolean shouldNotify() {\n        return false; // Default behavior\n    }\n\n    // Hook method with default implementation\n    protected void sendNotification() {\n        System.out.println("Sending notification...");\n    }\n}\n\n// Concrete implementations\nclass CSVDataProcessor extends DataProcessor {\n\n    @Override\n    protected void processDataSpecific() {\n        System.out.println("Processing CSV data:");\n        System.out.println("- Parsing CSV format");\n        System.out.println("- Converting to internal format");\n        System.out.println("- Handling CSV-specific rules");\n    }\n\n    @Override\n    protected void validateData() {\n        System.out.println("Validating CSV data:");\n        System.out.println("- Checking column count");\n        System.out.println("- Validating data types");\n        System.out.println("- Checking for required fields");\n    }\n\n    @Override\n    protected boolean shouldNotify() {\n        return true; // CSV processing should send notifications\n    }\n\n    @Override\n    protected void sendNotification() {\n        System.out.println("Sending CSV processing completion email...");\n    }\n}\n\nclass JSONDataProcessor extends DataProcessor {\n\n    @Override\n    protected void processDataSpecific() {\n        System.out.println("Processing JSON data:");\n        System.out.println("- Parsing JSON format");\n        System.out.println("- Extracting nested objects");\n        System.out.println("- Handling JSON arrays");\n    }\n\n    @Override\n    protected void validateData() {\n        System.out.println("Validating JSON data:");\n        System.out.println("- Checking JSON schema");\n        System.out.println("- Validating required properties");\n        System.out.println("- Checking data constraints");\n    }\n}\n\nclass XMLDataProcessor extends DataProcessor {\n\n    @Override\n    protected void processDataSpecific() {\n        System.out.println("Processing XML data:");\n        System.out.println("- Parsing XML structure");\n        System.out.println("- Processing XML attributes");\n        System.out.println("- Handling XML namespaces");\n    }\n\n    @Override\n    protected void validateData() {\n        System.out.println("Validating XML data:");\n        System.out.println("- Checking XML schema (XSD)");\n        System.out.println("- Validating XML structure");\n        System.out.println("- Checking element constraints");\n    }\n\n    @Override\n    protected boolean shouldValidate() {\n        return false; // Skip validation for XML (handled by XSD)\n    }\n\n    @Override\n    protected boolean shouldNotify() {\n        return true;\n    }\n\n    @Override\n    protected void sendNotification() {\n        System.out.println("Sending XML processing status to monitoring system...");\n    }\n}\n\n// Usage\npublic class TemplateMethodExample {\n    public static void main(String[] args) {\n        System.out.println("=== Processing CSV Data ===");\n        DataProcessor csvProcessor = new CSVDataProcessor();\n        csvProcessor.processData();\n\n        System.out.println("\\n=== Processing JSON Data ===");\n        DataProcessor jsonProcessor = new JSONDataProcessor();\n        jsonProcessor.processData();\n\n        System.out.println("\\n=== Processing XML Data ===");\n        DataProcessor xmlProcessor = new XMLDataProcessor();\n        xmlProcessor.processData();\n    }\n}\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h3,{id:"12-state-pattern",children:"12. State Pattern"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Intent:"})," Allow an object to alter its behavior when its internal state changes."]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"When to Use:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"When an object's behavior changes based on its state"}),"\n",(0,i.jsx)(e.li,{children:"When you have complex conditional statements based on object state"}),"\n",(0,i.jsx)(e.li,{children:"When state transitions are well-defined"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'// State interface\ninterface VendingMachineState {\n    void insertCoin(VendingMachine machine);\n    void pressButton(VendingMachine machine);\n    void dispense(VendingMachine machine);\n    void refund(VendingMachine machine);\n}\n\n// Context class\nclass VendingMachine {\n    private VendingMachineState currentState;\n    private VendingMachineState readyState;\n    private VendingMachineState coinInsertedState;\n    private VendingMachineState itemDispensedState;\n    private VendingMachineState outOfStockState;\n\n    private int coinCount;\n    private int itemCount;\n\n    public VendingMachine(int itemCount) {\n        this.itemCount = itemCount;\n        this.coinCount = 0;\n\n        // Initialize states\n        readyState = new ReadyState();\n        coinInsertedState = new CoinInsertedState();\n        itemDispensedState = new ItemDispensedState();\n        outOfStockState = new OutOfStockState();\n\n        // Set initial state\n        if (itemCount > 0) {\n            currentState = readyState;\n        } else {\n            currentState = outOfStockState;\n        }\n    }\n\n    // State transition methods\n    public void setState(VendingMachineState state) {\n        this.currentState = state;\n    }\n\n    // Delegate to current state\n    public void insertCoin() {\n        currentState.insertCoin(this);\n    }\n\n    public void pressButton() {\n        currentState.pressButton(this);\n    }\n\n    public void dispense() {\n        currentState.dispense(this);\n    }\n\n    public void refund() {\n        currentState.refund(this);\n    }\n\n    // Getters for states\n    public VendingMachineState getReadyState() { return readyState; }\n    public VendingMachineState getCoinInsertedState() { return coinInsertedState; }\n    public VendingMachineState getItemDispensedState() { return itemDispensedState; }\n    public VendingMachineState getOutOfStockState() { return outOfStockState; }\n\n    // Getters and setters\n    public int getCoinCount() { return coinCount; }\n    public void setCoinCount(int coinCount) { this.coinCount = coinCount; }\n    public int getItemCount() { return itemCount; }\n    public void setItemCount(int itemCount) { this.itemCount = itemCount; }\n\n    public void addCoin() { coinCount++; }\n    public void removeCoin() { if (coinCount > 0) coinCount--; }\n    public void removeItem() { if (itemCount > 0) itemCount--; }\n\n    public String getCurrentStateName() {\n        return currentState.getClass().getSimpleName();\n    }\n\n    public void displayStatus() {\n        System.out.println("--- Vending Machine Status ---");\n        System.out.println("Current State: " + getCurrentStateName());\n        System.out.println("Coins: " + coinCount);\n        System.out.println("Items: " + itemCount);\n        System.out.println("-----------------------------");\n    }\n}\n\n// Concrete states\nclass ReadyState implements VendingMachineState {\n    @Override\n    public void insertCoin(VendingMachine machine) {\n        System.out.println("Coin inserted. Ready to make selection.");\n        machine.addCoin();\n        machine.setState(machine.getCoinInsertedState());\n    }\n\n    @Override\n    public void pressButton(VendingMachine machine) {\n        System.out.println("Please insert coin first.");\n    }\n\n    @Override\n    public void dispense(VendingMachine machine) {\n        System.out.println("Please insert coin and press button first.");\n    }\n\n    @Override\n    public void refund(VendingMachine machine) {\n        System.out.println("No coins to refund.");\n    }\n}\n\nclass CoinInsertedState implements VendingMachineState {\n    @Override\n    public void insertCoin(VendingMachine machine) {\n        System.out.println("Coin already inserted. Press button to select item.");\n        machine.addCoin();\n    }\n\n    @Override\n    public void pressButton(VendingMachine machine) {\n        System.out.println("Button pressed. Dispensing item...");\n        machine.setState(machine.getItemDispensedState());\n        machine.dispense(); // Trigger dispense\n    }\n\n    @Override\n    public void dispense(VendingMachine machine) {\n        System.out.println("Press button first.");\n    }\n\n    @Override\n    public void refund(VendingMachine machine) {\n        System.out.println("Coin refunded.");\n        machine.removeCoin();\n        if (machine.getItemCount() > 0) {\n            machine.setState(machine.getReadyState());\n        } else {\n            machine.setState(machine.getOutOfStockState());\n        }\n    }\n}\n\nclass ItemDispensedState implements VendingMachineState {\n    @Override\n    public void insertCoin(VendingMachine machine) {\n        System.out.println("Please wait, dispensing in progress.");\n    }\n\n    @Override\n    public void pressButton(VendingMachine machine) {\n        System.out.println("Please wait, dispensing in progress.");\n    }\n\n    @Override\n    public void dispense(VendingMachine machine) {\n        System.out.println("Item dispensed! Enjoy your purchase.");\n        machine.removeItem();\n        machine.removeCoin();\n\n        if (machine.getItemCount() > 0) {\n            machine.setState(machine.getReadyState());\n        } else {\n            System.out.println("Machine is now out of stock.");\n            machine.setState(machine.getOutOfStockState());\n        }\n    }\n\n    @Override\n    public void refund(VendingMachine machine) {\n        System.out.println("Cannot refund. Item is being dispensed.");\n    }\n}\n\nclass OutOfStockState implements VendingMachineState {\n    @Override\n    public void insertCoin(VendingMachine machine) {\n        System.out.println("Machine is out of stock. Coin returned.");\n    }\n\n    @Override\n    public void pressButton(VendingMachine machine) {\n        System.out.println("Machine is out of stock.");\n    }\n\n    @Override\n    public void dispense(VendingMachine machine) {\n        System.out.println("Machine is out of stock.");\n    }\n\n    @Override\n    public void refund(VendingMachine machine) {\n        if (machine.getCoinCount() > 0) {\n            System.out.println("Refunding coins due to out of stock.");\n            machine.setCoinCount(0);\n        } else {\n            System.out.println("No coins to refund.");\n        }\n    }\n}\n\n// Usage\npublic class StateExample {\n    public static void main(String[] args) {\n        System.out.println("=== Vending Machine State Pattern Demo ===\\n");\n\n        VendingMachine machine = new VendingMachine(2);\n        machine.displayStatus();\n\n        // Normal purchase flow\n        System.out.println("\\n--- Normal Purchase Flow ---");\n        machine.insertCoin();\n        machine.displayStatus();\n\n        machine.pressButton();\n        machine.displayStatus();\n\n        // Second purchase\n        System.out.println("\\n--- Second Purchase ---");\n        machine.insertCoin();\n        machine.pressButton();\n        machine.displayStatus();\n\n        // Try to purchase when out of stock\n        System.out.println("\\n--- Out of Stock Scenario ---");\n        machine.insertCoin();\n        machine.pressButton();\n        machine.displayStatus();\n\n        // Test refund functionality\n        System.out.println("\\n--- Testing Refund ---");\n        VendingMachine machine2 = new VendingMachine(5);\n        machine2.insertCoin();\n        machine2.insertCoin(); // Insert multiple coins\n        machine2.displayStatus();\n\n        machine2.refund();\n        machine2.displayStatus();\n    }\n}\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"pattern-relationships",children:"Pattern Relationships"}),"\n",(0,i.jsx)(e.h3,{id:"pattern-combinations",children:"Pattern Combinations"}),"\n",(0,i.jsx)(e.h4,{id:"1-observer--command",children:"1. Observer + Command"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Commands that can be observed\nabstract class ObservableCommand implements Command {\n    private List<CommandObserver> observers = new ArrayList<>();\n\n    public void addObserver(CommandObserver observer) {\n        observers.add(observer);\n    }\n\n    protected void notifyExecution(String commandName) {\n        for (CommandObserver observer : observers) {\n            observer.onCommandExecuted(commandName);\n        }\n    }\n}\n\ninterface CommandObserver {\n    void onCommandExecuted(String commandName);\n}\n"})}),"\n",(0,i.jsx)(e.h4,{id:"2-factory--singleton",children:"2. Factory + Singleton"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'class DatabaseConnectionFactory {\n    private static DatabaseConnectionFactory instance;\n    private Map<String, Connection> connections;\n\n    private DatabaseConnectionFactory() {\n        connections = new HashMap<>();\n    }\n\n    public static DatabaseConnectionFactory getInstance() {\n        if (instance == null) {\n            synchronized (DatabaseConnectionFactory.class) {\n                if (instance == null) {\n                    instance = new DatabaseConnectionFactory();\n                }\n            }\n        }\n        return instance;\n    }\n\n    public Connection getConnection(String dbType) {\n        return connections.computeIfAbsent(dbType, this::createConnection);\n    }\n\n    private Connection createConnection(String dbType) {\n        // Factory logic to create different database connections\n        switch (dbType) {\n            case "mysql": return new MySQLConnection();\n            case "postgres": return new PostgreSQLConnection();\n            default: throw new IllegalArgumentException("Unknown database type");\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(e.h4,{id:"3-design-a-payment-processing-system",children:'3. "Design a payment processing system"'}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Use Strategy + Factory patterns\nclass PaymentProcessor {\n    private PaymentStrategyFactory factory;\n\n    public void processPayment(PaymentRequest request) {\n        PaymentStrategy strategy = factory.createStrategy(request.getPaymentType());\n        strategy.pay(request.getAmount());\n    }\n}\n"})}),"\n",(0,i.jsx)(e.h4,{id:"4-how-would-you-implement-undo-functionality",children:'4. "How would you implement undo functionality?"'}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Use Command pattern with history\nclass CommandManager {\n    private Stack<Command> history = new Stack<>();\n\n    public void execute(Command command) {\n        command.execute();\n        history.push(command);\n    }\n\n    public void undo() {\n        if (!history.isEmpty()) {\n            Command command = history.pop();\n            command.undo();\n        }\n    }\n}\n"})}),"\n",(0,i.jsx)(e.h4,{id:"5-design-a-file-processing-system-for-different-formats",children:'5. "Design a file processing system for different formats"'}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// Use Template Method + Strategy\nabstract class FileProcessor {\n    public final void processFile(String filename) {\n        File file = readFile(filename);\n        ProcessingStrategy strategy = getStrategy(getFileExtension(filename));\n        ProcessedData data = strategy.process(file);\n        saveProcessedData(data);\n    }\n\n    protected abstract ProcessingStrategy getStrategy(String extension);\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"pattern-identification-questions",children:"Pattern Identification Questions"}),"\n",(0,i.jsx)(e.h4,{id:"question-what-patterns-can-you-identify-in-this-code",children:'Question: "What patterns can you identify in this code?"'}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'public class DatabaseManager {\n    private static DatabaseManager instance;\n    private ConnectionFactory factory;\n    private List<ConnectionObserver> observers = new ArrayList<>();\n\n    private DatabaseManager() {\n        factory = new ConnectionFactory();\n    }\n\n    public static DatabaseManager getInstance() {\n        if (instance == null) {\n            synchronized (DatabaseManager.class) {\n                if (instance == null) {\n                    instance = new DatabaseManager();\n                }\n            }\n        }\n        return instance;\n    }\n\n    public Connection getConnection(String type) {\n        Connection conn = factory.createConnection(type);\n        notifyObservers("Connection created: " + type);\n        return conn;\n    }\n\n    public void addObserver(ConnectionObserver observer) {\n        observers.add(observer);\n    }\n\n    private void notifyObservers(String message) {\n        for (ConnectionObserver observer : observers) {\n            observer.update(message);\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Answer:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Singleton Pattern"}),": ",(0,i.jsx)(e.code,{children:"getInstance()"})," method with double-checked locking"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Factory Pattern"}),": ",(0,i.jsx)(e.code,{children:"ConnectionFactory"})," creating different connection types"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Observer Pattern"}),": ",(0,i.jsx)(e.code,{children:"observers"})," list and ",(0,i.jsx)(e.code,{children:"notifyObservers()"})," method"]}),"\n"]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsx)(e.h3,{id:"1-pattern-selection-guidelines",children:"1. Pattern Selection Guidelines"}),"\n",(0,i.jsx)(e.h4,{id:"do-use-patterns-when",children:"Do Use Patterns When:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Problem fits naturally"}),": Don't force patterns"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Code becomes simpler"}),": Pattern reduces complexity"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Future flexibility needed"}),": Anticipating changes"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Team understands pattern"}),": Common vocabulary"]}),"\n"]}),"\n",(0,i.jsx)(e.h4,{id:"dont-use-patterns-when",children:"Don't Use Patterns When:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Over-engineering"}),": Simple problems don't need complex solutions"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Performance critical"}),": Some patterns add overhead"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Team unfamiliar"}),": Learning curve affects productivity"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"2-implementation-best-practices",children:"2. Implementation Best Practices"}),"\n",(0,i.jsx)(e.h4,{id:"singleton-pattern",children:"Singleton Pattern"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// \u2705 GOOD - Enum singleton\npublic enum ConfigManager {\n    INSTANCE;\n\n    private Properties config;\n\n    ConfigManager() {\n        loadConfig();\n    }\n\n    public String getProperty(String key) {\n        return config.getProperty(key);\n    }\n}\n\n// \u274c BAD - Not thread-safe\npublic class ConfigManager {\n    private static ConfigManager instance;\n\n    public static ConfigManager getInstance() {\n        if (instance == null) {\n            instance = new ConfigManager(); // Race condition!\n        }\n        return instance;\n    }\n}\n"})}),"\n",(0,i.jsx)(e.h4,{id:"factory-pattern",children:"Factory Pattern"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'// \u2705 GOOD - Extensible design\npublic class ShapeFactory {\n    private static final Map<String, Supplier<Shape>> shapeMap = new HashMap<>();\n\n    static {\n        shapeMap.put("circle", Circle::new);\n        shapeMap.put("square", Square::new);\n        shapeMap.put("triangle", Triangle::new);\n    }\n\n    public static Shape createShape(String type) {\n        Supplier<Shape> supplier = shapeMap.get(type.toLowerCase());\n        if (supplier != null) {\n            return supplier.get();\n        }\n        throw new IllegalArgumentException("Unknown shape type: " + type);\n    }\n\n    // Easy to add new shapes\n    public static void registerShape(String type, Supplier<Shape> supplier) {\n        shapeMap.put(type, supplier);\n    }\n}\n\n// \u274c BAD - Hard to extend\npublic class ShapeFactory {\n    public static Shape createShape(String type) {\n        if ("circle".equals(type)) {\n            return new Circle();\n        } else if ("square".equals(type)) {\n            return new Square();\n        }\n        // Need to modify this method for new shapes\n        return null;\n    }\n}\n'})}),"\n",(0,i.jsx)(e.h4,{id:"observer-pattern",children:"Observer Pattern"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'// \u2705 GOOD - Generic and type-safe\npublic class EventPublisher<T> {\n    private final List<EventListener<T>> listeners = new CopyOnWriteArrayList<>();\n\n    public void subscribe(EventListener<T> listener) {\n        listeners.add(listener);\n    }\n\n    public void unsubscribe(EventListener<T> listener) {\n        listeners.remove(listener);\n    }\n\n    public void publish(T event) {\n        for (EventListener<T> listener : listeners) {\n            try {\n                listener.onEvent(event);\n            } catch (Exception e) {\n                // Log error but don\'t stop other listeners\n                System.err.println("Error in listener: " + e.getMessage());\n            }\n        }\n    }\n}\n\n@FunctionalInterface\npublic interface EventListener<T> {\n    void onEvent(T event);\n}\n\n// \u274c BAD - Not thread-safe, no error handling\npublic class EventPublisher {\n    private List<Observer> observers = new ArrayList<>(); // Not thread-safe!\n\n    public void notifyObservers(Object event) {\n        for (Observer observer : observers) {\n            observer.update(event); // If one fails, all fail\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"3-performance-considerations",children:"3. Performance Considerations"}),"\n",(0,i.jsx)(e.h4,{id:"memory-usage",children:"Memory Usage"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// \u2705 GOOD - Flyweight pattern for memory efficiency\npublic class CharacterFactory {\n    private static final Map<Character, CharacterFlyweight> flyweights = new HashMap<>();\n\n    public static CharacterFlyweight getCharacter(char c) {\n        return flyweights.computeIfAbsent(c, CharacterFlyweight::new);\n    }\n}\n\n// Context contains extrinsic state\npublic class TextDocument {\n    private List<CharacterContext> characters = new ArrayList<>();\n\n    public void addCharacter(char c, Font font, Color color, int position) {\n        CharacterFlyweight flyweight = CharacterFactory.getCharacter(c);\n        characters.add(new CharacterContext(flyweight, font, color, position));\n    }\n}\n"})}),"\n",(0,i.jsx)(e.h4,{id:"lazy-initialization",children:"Lazy Initialization"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'// \u2705 GOOD - Lazy loading with caching\npublic class ExpensiveResourceFactory {\n    private static final Map<String, ExpensiveResource> cache = new ConcurrentHashMap<>();\n\n    public static ExpensiveResource getResource(String key) {\n        return cache.computeIfAbsent(key, k -> {\n            System.out.println("Creating expensive resource for: " + k);\n            return new ExpensiveResource(k);\n        });\n    }\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"4-testing-patterns",children:"4. Testing Patterns"}),"\n",(0,i.jsx)(e.h4,{id:"dependency-injection-for-testability",children:"Dependency Injection for Testability"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// \u2705 GOOD - Testable design\npublic class OrderService {\n    private final PaymentProcessor paymentProcessor;\n    private final InventoryService inventoryService;\n    private final NotificationService notificationService;\n\n    public OrderService(PaymentProcessor paymentProcessor,\n                       InventoryService inventoryService,\n                       NotificationService notificationService) {\n        this.paymentProcessor = paymentProcessor;\n        this.inventoryService = inventoryService;\n        this.notificationService = notificationService;\n    }\n\n    public void processOrder(Order order) {\n        inventoryService.reserve(order.getItems());\n        paymentProcessor.processPayment(order.getPayment());\n        notificationService.sendConfirmation(order);\n    }\n}\n\n// Easy to test with mocks\n@Test\npublic void testOrderProcessing() {\n    PaymentProcessor mockPayment = mock(PaymentProcessor.class);\n    InventoryService mockInventory = mock(InventoryService.class);\n    NotificationService mockNotification = mock(NotificationService.class);\n\n    OrderService service = new OrderService(mockPayment, mockInventory, mockNotification);\n\n    Order order = new Order(/* ... */);\n    service.processOrder(order);\n\n    verify(mockPayment).processPayment(order.getPayment());\n    verify(mockInventory).reserve(order.getItems());\n    verify(mockNotification).sendConfirmation(order);\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"5-common-mistakes",children:"5. Common Mistakes"}),"\n",(0,i.jsx)(e.h4,{id:"mistake-1-overusing-singleton",children:"Mistake 1: Overusing Singleton"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// \u274c BAD - Everything as singleton\npublic class UserSingleton {\n    private static UserSingleton instance;\n    // User should be a regular object, not singleton\n}\n\n// \u2705 GOOD - Use singleton only when needed\npublic class ApplicationConfig {\n    // Config should be singleton - shared application state\n}\n\npublic class User {\n    // Regular object - multiple instances needed\n}\n"})}),"\n",(0,i.jsx)(e.h4,{id:"mistake-2-not-following-solid-principles",children:"Mistake 2: Not Following SOLID Principles"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'// \u274c BAD - Violates Open/Closed Principle\npublic class DiscountCalculator {\n    public double calculate(Customer customer, double amount) {\n        if (customer.getType().equals("REGULAR")) {\n            return amount * 0.95;\n        } else if (customer.getType().equals("PREMIUM")) {\n            return amount * 0.90;\n        } else if (customer.getType().equals("VIP")) {\n            return amount * 0.85;\n        }\n        return amount; // Need to modify for new customer types\n    }\n}\n\n// \u2705 GOOD - Strategy pattern following Open/Closed\npublic interface DiscountStrategy {\n    double calculate(double amount);\n}\n\npublic class RegularCustomerDiscount implements DiscountStrategy {\n    public double calculate(double amount) { return amount * 0.95; }\n}\n\npublic class DiscountCalculator {\n    public double calculate(DiscountStrategy strategy, double amount) {\n        return strategy.calculate(amount);\n    }\n}\n'})}),"\n",(0,i.jsx)(e.h4,{id:"mistake-3-ignoring-thread-safety",children:"Mistake 3: Ignoring Thread Safety"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// \u274c BAD - Not thread-safe\npublic class CounterSingleton {\n    private static CounterSingleton instance;\n    private int count = 0;\n\n    public static CounterSingleton getInstance() {\n        if (instance == null) {\n            instance = new CounterSingleton(); // Race condition\n        }\n        return instance;\n    }\n\n    public void increment() {\n        count++; // Race condition\n    }\n}\n\n// \u2705 GOOD - Thread-safe\npublic enum CounterSingleton {\n    INSTANCE;\n\n    private final AtomicInteger count = new AtomicInteger(0);\n\n    public void increment() {\n        count.incrementAndGet();\n    }\n\n    public int getCount() {\n        return count.get();\n    }\n}\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(e.h3,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Design patterns are tools, not rules"})," - Use them when they solve real problems"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Understand the intent"})," - Don't just memorize implementations"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Consider trade-offs"})," - Every pattern has costs and benefits"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Start simple"})," - Add patterns when complexity justifies them"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Team knowledge matters"})," - Use patterns the team understands"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"pattern-categories-quick-reference",children:"Pattern Categories Quick Reference"}),"\n",(0,i.jsx)(e.h4,{id:"creational-object-creation",children:"Creational (Object Creation)"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Singleton"}),": One instance only"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Factory Method"}),": Create objects without specifying exact classes"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Abstract Factory"}),": Create families of related objects"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Builder"}),": Construct complex objects step by step"]}),"\n"]}),"\n",(0,i.jsx)(e.h4,{id:"structural-object-composition",children:"Structural (Object Composition)"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Adapter"}),": Make incompatible interfaces work together"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Decorator"}),": Add behavior dynamically"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Facade"}),": Simplify complex subsystems"]}),"\n"]}),"\n",(0,i.jsx)(e.h4,{id:"behavioral-object-interaction",children:"Behavioral (Object Interaction)"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Observer"}),": Notify multiple objects of changes"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Strategy"}),": Select algorithms at runtime"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Command"}),": Encapsulate requests as objects"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Template Method"}),": Define algorithm skeleton"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"State"}),": Change behavior based on internal state"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"interview-preparation-tips",children:"Interview Preparation Tips"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Practice implementation"})," - Write code, don't just read"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Understand when to use"})," - Know the problems each pattern solves"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Know alternatives"})," - Understand trade-offs between patterns"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Real-world examples"})," - Think of examples from actual systems"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Combination patterns"})," - Understand how patterns work together"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"Remember: The goal is not to use every pattern, but to use the right pattern for the right problem. Focus on writing clean, maintainable code that solves real problems effectively.. Strategy + Template Method"})]})}function p(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(d,{...n})}):d(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>o,x:()=>s});var i=t(6540);const r={},a=i.createContext(r);function o(n){const e=i.useContext(a);return i.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:o(n.components),i.createElement(a.Provider,{value:e},n.children)}}}]);