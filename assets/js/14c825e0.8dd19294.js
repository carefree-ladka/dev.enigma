"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[197],{7087:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>d,default:()=>c,frontMatter:()=>l,metadata:()=>s,toc:()=>o});var r=t(4848),i=t(8453);const l={},d="LinkedList",s={id:"DSA/DSA with Java/LinkedList Patterns",title:"LinkedList",description:"Table of Contents",source:"@site/docs/DSA/DSA with Java/LinkedList Patterns.mdx",sourceDirName:"DSA/DSA with Java",slug:"/DSA/DSA with Java/LinkedList Patterns",permalink:"/js.enigma/docs/DSA/DSA with Java/LinkedList Patterns",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with Java/LinkedList Patterns.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Knapsack Problems",permalink:"/js.enigma/docs/DSA/DSA with Java/Knapsack Patterns"},next:{title:"N-ary Tree",permalink:"/js.enigma/docs/DSA/DSA with Java/Nary Tree Patterns"}},a={},o=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Node Definition",id:"node-definition",level:2},{value:"Pattern 1: Two Pointer Technique",id:"pattern-1-two-pointer-technique",level:2},{value:"1.1 Find Middle of LinkedList",id:"11-find-middle-of-linkedlist",level:3},{value:"1.2 Nth Node from End",id:"12-nth-node-from-end",level:3},{value:"1.3 Remove Nth Node from End",id:"13-remove-nth-node-from-end",level:3},{value:"1.4 Find Length of LinkedList",id:"14-find-length-of-linkedlist",level:3},{value:"1.5 Check if Length is Even or Odd",id:"15-check-if-length-is-even-or-odd",level:3},{value:"Pattern 2: Fast &amp; Slow Pointer (Cycle Detection)",id:"pattern-2-fast--slow-pointer-cycle-detection",level:2},{value:"2.1 Detect Cycle (Floyd&#39;s Algorithm)",id:"21-detect-cycle-floyds-algorithm",level:3},{value:"2.2 Find Start of Cycle",id:"22-find-start-of-cycle",level:3},{value:"2.3 Find Length of Cycle",id:"23-find-length-of-cycle",level:3},{value:"2.4 Remove Cycle",id:"24-remove-cycle",level:3},{value:"2.5 Happy Number (Cycle Detection Application)",id:"25-happy-number-cycle-detection-application",level:3},{value:"Pattern 3: Reversal Patterns",id:"pattern-3-reversal-patterns",level:2},{value:"3.1 Reverse Entire LinkedList",id:"31-reverse-entire-linkedlist",level:3},{value:"3.2 Reverse in Groups of K",id:"32-reverse-in-groups-of-k",level:3},{value:"3.3 Reverse Between Left and Right",id:"33-reverse-between-left-and-right",level:3},{value:"3.4 Reverse Alternate K Nodes",id:"34-reverse-alternate-k-nodes",level:3},{value:"3.5 Reverse Nodes in Even Length Groups",id:"35-reverse-nodes-in-even-length-groups",level:3},{value:"Pattern 4: Merging Patterns",id:"pattern-4-merging-patterns",level:2},{value:"4.1 Merge Two Sorted Lists",id:"41-merge-two-sorted-lists",level:3},{value:"4.2 Merge K Sorted Lists",id:"42-merge-k-sorted-lists",level:3},{value:"4.3 Merge In Between Linked Lists",id:"43-merge-in-between-linked-lists",level:3},{value:"4.4 Flatten Multilevel Doubly LinkedList",id:"44-flatten-multilevel-doubly-linkedlist",level:3},{value:"Pattern 5: Intersection &amp; Union",id:"pattern-5-intersection--union",level:2},{value:"5.1 Intersection of Two Linked Lists",id:"51-intersection-of-two-linked-lists",level:3},{value:"5.2 Union of Two Linked Lists",id:"52-union-of-two-linked-lists",level:3},{value:"Pattern 6: Removal Patterns",id:"pattern-6-removal-patterns",level:2},{value:"6.1 Remove Duplicates from Sorted List",id:"61-remove-duplicates-from-sorted-list",level:3},{value:"6.2 Remove All Duplicates from Sorted List",id:"62-remove-all-duplicates-from-sorted-list",level:3},{value:"6.3 Remove Elements with Given Value",id:"63-remove-elements-with-given-value",level:3},{value:"6.4 Remove Nodes with Greater Value on Right",id:"64-remove-nodes-with-greater-value-on-right",level:3},{value:"6.5 Delete Middle Node",id:"65-delete-middle-node",level:3},{value:"6.6 Remove Zero Sum Consecutive Nodes",id:"66-remove-zero-sum-consecutive-nodes",level:3},{value:"Pattern 7: Partition &amp; Splitting",id:"pattern-7-partition--splitting",level:2},{value:"7.1 Partition List",id:"71-partition-list",level:3},{value:"7.2 Odd Even Linked List",id:"72-odd-even-linked-list",level:3},{value:"7.3 Split List into Parts",id:"73-split-list-into-parts",level:3},{value:"7.4 Separate Even and Odd Values",id:"74-separate-even-and-odd-values",level:3},{value:"Pattern 8: Addition &amp; Arithmetic",id:"pattern-8-addition--arithmetic",level:2},{value:"8.1 Add Two Numbers",id:"81-add-two-numbers",level:3},{value:"8.2 Add Two Numbers II (Most significant digit first)",id:"82-add-two-numbers-ii-most-significant-digit-first",level:3},{value:"8.3 Multiply Two Numbers Represented by LinkedLists",id:"83-multiply-two-numbers-represented-by-linkedlists",level:3},{value:"8.4 Subtract Two Numbers",id:"84-subtract-two-numbers",level:3},{value:"Pattern 9: Deep Copy &amp; Cloning",id:"pattern-9-deep-copy--cloning",level:2},{value:"9.1 Copy List with Random Pointer",id:"91-copy-list-with-random-pointer",level:3},{value:"9.2 Clone Linked List with Arbitrary Pointer",id:"92-clone-linked-list-with-arbitrary-pointer",level:3},{value:"Pattern 10: Rotation &amp; Shifting",id:"pattern-10-rotation--shifting",level:2},{value:"10.1 Rotate List",id:"101-rotate-list",level:3},{value:"10.2 Rotate List to Left",id:"102-rotate-list-to-left",level:3},{value:"10.3 Swap Nodes in Pairs",id:"103-swap-nodes-in-pairs",level:3},{value:"10.4 Swap Kth Node from Beginning and End",id:"104-swap-kth-node-from-beginning-and-end",level:3},{value:"10.5 Reorder List (L0 \u2192 Ln \u2192 L1 \u2192 Ln-1...)",id:"105-reorder-list-l0--ln--l1--ln-1",level:3},{value:"Pattern 11: Palindrome Checking",id:"pattern-11-palindrome-checking",level:2},{value:"11.1 Palindrome Linked List",id:"111-palindrome-linked-list",level:3},{value:"11.2 Check if Palindrome after Removing One Node",id:"112-check-if-palindrome-after-removing-one-node",level:3},{value:"Pattern 12: Sorting Patterns",id:"pattern-12-sorting-patterns",level:2},{value:"12.1 Insertion Sort List",id:"121-insertion-sort-list",level:3},{value:"12.2 Merge Sort List",id:"122-merge-sort-list",level:3},{value:"12.3 Quick Sort List",id:"123-quick-sort-list",level:3},{value:"12.4 Sort List with 0s, 1s, and 2s",id:"124-sort-list-with-0s-1s-and-2s",level:3},{value:"Pattern 13: Advanced Problems",id:"pattern-13-advanced-problems",level:2},{value:"13.1 LRU Cache Implementation",id:"131-lru-cache-implementation",level:3},{value:"13.2 Flatten a Binary Tree to Linked List",id:"132-flatten-a-binary-tree-to-linked-list",level:3},{value:"13.3 Convert Binary Tree to Doubly Linked List",id:"133-convert-binary-tree-to-doubly-linked-list",level:3},{value:"13.4 Design Browser History",id:"134-design-browser-history",level:3},{value:"13.5 Design Skiplist",id:"135-design-skiplist",level:3},{value:"13.6 Reverse Nodes in k-Group (Hard)",id:"136-reverse-nodes-in-k-group-hard",level:3},{value:"Time Complexity Cheat Sheet",id:"time-complexity-cheat-sheet",level:2},{value:"Common Tricks &amp; Tips",id:"common-tricks--tips",level:2}];function u(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"linkedlist",children:"LinkedList"})}),"\n",(0,r.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#node-definition",children:"Node Definition"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#pattern-1-two-pointer-technique",children:"Pattern 1: Two Pointer Technique"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#pattern-2-fast--slow-pointer-cycle-detection",children:"Pattern 2: Fast & Slow Pointer (Cycle Detection)"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#pattern-3-reversal-patterns",children:"Pattern 3: Reversal Patterns"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#pattern-4-merging-patterns",children:"Pattern 4: Merging Patterns"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#pattern-5-intersection--union",children:"Pattern 5: Intersection & Union"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#pattern-6-removal-patterns",children:"Pattern 6: Removal Patterns"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#pattern-7-partition--splitting",children:"Pattern 7: Partition & Splitting"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#pattern-8-addition--arithmetic",children:"Pattern 8: Addition & Arithmetic"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#pattern-9-deep-copy--cloning",children:"Pattern 9: Deep Copy & Cloning"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#pattern-10-rotation--shifting",children:"Pattern 10: Rotation & Shifting"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#pattern-11-palindrome-checking",children:"Pattern 11: Palindrome Checking"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#pattern-12-sorting-patterns",children:"Pattern 12: Sorting Patterns"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#pattern-13-advanced-problems",children:"Pattern 13: Advanced Problems"})}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"node-definition",children:"Node Definition"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"class ListNode {\n    int val;\n    ListNode next;\n\n    ListNode(int val) {\n        this.val = val;\n    }\n\n    ListNode(int val, ListNode next) {\n        this.val = val;\n        this.next = next;\n    }\n}\n\n// Node with random pointer\nclass Node {\n    int val;\n    Node next;\n    Node random;\n\n    Node(int val) {\n        this.val = val;\n    }\n}\n\n// Doubly LinkedList Node\nclass DNode {\n    int val;\n    DNode prev;\n    DNode next;\n\n    DNode(int val) {\n        this.val = val;\n    }\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"pattern-1-two-pointer-technique",children:"Pattern 1: Two Pointer Technique"}),"\n",(0,r.jsx)(n.h3,{id:"11-find-middle-of-linkedlist",children:"1.1 Find Middle of LinkedList"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"ListNode findMiddle(ListNode head) {\n    if (head == null) return null;\n\n    ListNode slow = head;\n    ListNode fast = head;\n\n    while (fast != null && fast.next != null) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n\n    return slow;\n}\n\n// Return first middle if even number of nodes\nListNode findMiddleFirst(ListNode head) {\n    if (head == null) return null;\n\n    ListNode slow = head;\n    ListNode fast = head.next;\n\n    while (fast != null && fast.next != null) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n\n    return slow;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"12-nth-node-from-end",children:"1.2 Nth Node from End"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"ListNode nthFromEnd(ListNode head, int n) {\n    ListNode first = head;\n    ListNode second = head;\n\n    // Move first pointer n steps ahead\n    for (int i = 0; i < n; i++) {\n        if (first == null) return null;\n        first = first.next;\n    }\n\n    // Move both pointers until first reaches end\n    while (first != null) {\n        first = first.next;\n        second = second.next;\n    }\n\n    return second;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"13-remove-nth-node-from-end",children:"1.3 Remove Nth Node from End"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"ListNode removeNthFromEnd(ListNode head, int n) {\n    ListNode dummy = new ListNode(0);\n    dummy.next = head;\n\n    ListNode first = dummy;\n    ListNode second = dummy;\n\n    // Move first n+1 steps ahead\n    for (int i = 0; i <= n; i++) {\n        first = first.next;\n    }\n\n    // Move both until first reaches end\n    while (first != null) {\n        first = first.next;\n        second = second.next;\n    }\n\n    // Remove nth node\n    second.next = second.next.next;\n\n    return dummy.next;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"14-find-length-of-linkedlist",children:"1.4 Find Length of LinkedList"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"int length(ListNode head) {\n    int count = 0;\n    ListNode curr = head;\n\n    while (curr != null) {\n        count++;\n        curr = curr.next;\n    }\n\n    return count;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"15-check-if-length-is-even-or-odd",children:"1.5 Check if Length is Even or Odd"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"boolean isLengthEven(ListNode head) {\n    ListNode curr = head;\n\n    while (curr != null && curr.next != null) {\n        curr = curr.next.next;\n    }\n\n    return curr == null; // Even if null, odd if not null\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"pattern-2-fast--slow-pointer-cycle-detection",children:"Pattern 2: Fast & Slow Pointer (Cycle Detection)"}),"\n",(0,r.jsx)(n.h3,{id:"21-detect-cycle-floyds-algorithm",children:"2.1 Detect Cycle (Floyd's Algorithm)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"boolean hasCycle(ListNode head) {\n    if (head == null) return false;\n\n    ListNode slow = head;\n    ListNode fast = head;\n\n    while (fast != null && fast.next != null) {\n        slow = slow.next;\n        fast = fast.next.next;\n\n        if (slow == fast) {\n            return true;\n        }\n    }\n\n    return false;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"22-find-start-of-cycle",children:"2.2 Find Start of Cycle"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"ListNode detectCycle(ListNode head) {\n    if (head == null) return null;\n\n    ListNode slow = head;\n    ListNode fast = head;\n\n    // Find meeting point\n    while (fast != null && fast.next != null) {\n        slow = slow.next;\n        fast = fast.next.next;\n\n        if (slow == fast) {\n            // Cycle detected, find start\n            ListNode start = head;\n            while (start != slow) {\n                start = start.next;\n                slow = slow.next;\n            }\n            return start;\n        }\n    }\n\n    return null;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"23-find-length-of-cycle",children:"2.3 Find Length of Cycle"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"int lengthOfCycle(ListNode head) {\n    if (head == null) return 0;\n\n    ListNode slow = head;\n    ListNode fast = head;\n\n    // Detect cycle\n    while (fast != null && fast.next != null) {\n        slow = slow.next;\n        fast = fast.next.next;\n\n        if (slow == fast) {\n            // Count cycle length\n            int count = 1;\n            ListNode temp = slow.next;\n            while (temp != slow) {\n                count++;\n                temp = temp.next;\n            }\n            return count;\n        }\n    }\n\n    return 0;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"24-remove-cycle",children:"2.4 Remove Cycle"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"void removeCycle(ListNode head) {\n    if (head == null) return;\n\n    ListNode slow = head;\n    ListNode fast = head;\n\n    // Detect cycle\n    while (fast != null && fast.next != null) {\n        slow = slow.next;\n        fast = fast.next.next;\n\n        if (slow == fast) {\n            // Find start of cycle\n            ListNode start = head;\n            ListNode prev = null;\n\n            if (start == slow) {\n                // Special case: cycle starts at head\n                while (slow.next != start) {\n                    slow = slow.next;\n                }\n                slow.next = null;\n            } else {\n                while (start != slow) {\n                    prev = slow;\n                    start = start.next;\n                    slow = slow.next;\n                }\n                prev.next = null;\n            }\n            return;\n        }\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"25-happy-number-cycle-detection-application",children:"2.5 Happy Number (Cycle Detection Application)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"boolean isHappy(int n) {\n    int slow = n;\n    int fast = n;\n\n    do {\n        slow = sumOfSquares(slow);\n        fast = sumOfSquares(sumOfSquares(fast));\n    } while (slow != fast);\n\n    return slow == 1;\n}\n\nint sumOfSquares(int n) {\n    int sum = 0;\n    while (n > 0) {\n        int digit = n % 10;\n        sum += digit * digit;\n        n /= 10;\n    }\n    return sum;\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"pattern-3-reversal-patterns",children:"Pattern 3: Reversal Patterns"}),"\n",(0,r.jsx)(n.h3,{id:"31-reverse-entire-linkedlist",children:"3.1 Reverse Entire LinkedList"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"// Iterative\nListNode reverseList(ListNode head) {\n    ListNode prev = null;\n    ListNode curr = head;\n\n    while (curr != null) {\n        ListNode next = curr.next;\n        curr.next = prev;\n        prev = curr;\n        curr = next;\n    }\n\n    return prev;\n}\n\n// Recursive\nListNode reverseListRecursive(ListNode head) {\n    if (head == null || head.next == null) {\n        return head;\n    }\n\n    ListNode newHead = reverseListRecursive(head.next);\n    head.next.next = head;\n    head.next = null;\n\n    return newHead;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"32-reverse-in-groups-of-k",children:"3.2 Reverse in Groups of K"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"ListNode reverseKGroup(ListNode head, int k) {\n    ListNode curr = head;\n    int count = 0;\n\n    // Check if we have k nodes\n    while (curr != null && count < k) {\n        curr = curr.next;\n        count++;\n    }\n\n    if (count == k) {\n        // Reverse first k nodes\n        curr = reverseK(head, k);\n\n        // Recursively reverse remaining\n        head.next = reverseKGroup(curr, k);\n        return curr;\n    }\n\n    return head;\n}\n\nListNode reverseK(ListNode head, int k) {\n    ListNode prev = null;\n    ListNode curr = head;\n\n    while (k > 0) {\n        ListNode next = curr.next;\n        curr.next = prev;\n        prev = curr;\n        curr = next;\n        k--;\n    }\n\n    return prev;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"33-reverse-between-left-and-right",children:"3.3 Reverse Between Left and Right"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"ListNode reverseBetween(ListNode head, int left, int right) {\n    if (head == null || left == right) return head;\n\n    ListNode dummy = new ListNode(0);\n    dummy.next = head;\n    ListNode prev = dummy;\n\n    // Move to position before left\n    for (int i = 1; i < left; i++) {\n        prev = prev.next;\n    }\n\n    // Reverse from left to right\n    ListNode curr = prev.next;\n    for (int i = 0; i < right - left; i++) {\n        ListNode next = curr.next;\n        curr.next = next.next;\n        next.next = prev.next;\n        prev.next = next;\n    }\n\n    return dummy.next;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"34-reverse-alternate-k-nodes",children:"3.4 Reverse Alternate K Nodes"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"ListNode reverseAlternateK(ListNode head, int k) {\n    if (head == null) return null;\n\n    ListNode curr = head;\n    ListNode prev = null;\n    int count = 0;\n\n    // Reverse first k nodes\n    while (curr != null && count < k) {\n        ListNode next = curr.next;\n        curr.next = prev;\n        prev = curr;\n        curr = next;\n        count++;\n    }\n\n    if (head != null) {\n        // Skip next k nodes\n        head.next = curr;\n        count = 0;\n        while (curr != null && count < k - 1) {\n            curr = curr.next;\n            count++;\n        }\n\n        // Recursively reverse remaining\n        if (curr != null) {\n            curr.next = reverseAlternateK(curr.next, k);\n        }\n    }\n\n    return prev;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"35-reverse-nodes-in-even-length-groups",children:"3.5 Reverse Nodes in Even Length Groups"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"ListNode reverseEvenLengthGroups(ListNode head) {\n    ListNode dummy = new ListNode(0, head);\n    ListNode prev = dummy;\n    int groupLen = 1;\n\n    while (prev.next != null) {\n        ListNode groupStart = prev.next;\n        ListNode curr = groupStart;\n        int actualLen = 0;\n\n        // Count actual group length\n        while (curr != null && actualLen < groupLen) {\n            curr = curr.next;\n            actualLen++;\n        }\n\n        // Reverse if even length\n        if (actualLen % 2 == 0) {\n            ListNode groupEnd = reverse(groupStart, actualLen);\n            prev.next = groupEnd;\n            prev = groupStart;\n        } else {\n            for (int i = 0; i < actualLen; i++) {\n                prev = prev.next;\n            }\n        }\n\n        groupLen++;\n    }\n\n    return dummy.next;\n}\n\nListNode reverse(ListNode head, int k) {\n    ListNode prev = null;\n    ListNode curr = head;\n\n    while (k > 0) {\n        ListNode next = curr.next;\n        curr.next = prev;\n        prev = curr;\n        curr = next;\n        k--;\n    }\n\n    head.next = curr;\n    return prev;\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"pattern-4-merging-patterns",children:"Pattern 4: Merging Patterns"}),"\n",(0,r.jsx)(n.h3,{id:"41-merge-two-sorted-lists",children:"4.1 Merge Two Sorted Lists"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n    ListNode dummy = new ListNode(0);\n    ListNode curr = dummy;\n\n    while (l1 != null && l2 != null) {\n        if (l1.val <= l2.val) {\n            curr.next = l1;\n            l1 = l1.next;\n        } else {\n            curr.next = l2;\n            l2 = l2.next;\n        }\n        curr = curr.next;\n    }\n\n    curr.next = (l1 != null) ? l1 : l2;\n\n    return dummy.next;\n}\n\n// Recursive\nListNode mergeTwoListsRecursive(ListNode l1, ListNode l2) {\n    if (l1 == null) return l2;\n    if (l2 == null) return l1;\n\n    if (l1.val <= l2.val) {\n        l1.next = mergeTwoListsRecursive(l1.next, l2);\n        return l1;\n    } else {\n        l2.next = mergeTwoListsRecursive(l1, l2.next);\n        return l2;\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"42-merge-k-sorted-lists",children:"4.2 Merge K Sorted Lists"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"// Using Min Heap\nListNode mergeKLists(ListNode[] lists) {\n    if (lists == null || lists.length == 0) return null;\n\n    PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n\n    // Add first node of each list\n    for (ListNode list : lists) {\n        if (list != null) {\n            pq.offer(list);\n        }\n    }\n\n    ListNode dummy = new ListNode(0);\n    ListNode curr = dummy;\n\n    while (!pq.isEmpty()) {\n        ListNode node = pq.poll();\n        curr.next = node;\n        curr = curr.next;\n\n        if (node.next != null) {\n            pq.offer(node.next);\n        }\n    }\n\n    return dummy.next;\n}\n\n// Divide and Conquer\nListNode mergeKListsDivideConquer(ListNode[] lists) {\n    if (lists == null || lists.length == 0) return null;\n    return mergeHelper(lists, 0, lists.length - 1);\n}\n\nListNode mergeHelper(ListNode[] lists, int left, int right) {\n    if (left == right) return lists[left];\n\n    int mid = left + (right - left) / 2;\n    ListNode l1 = mergeHelper(lists, left, mid);\n    ListNode l2 = mergeHelper(lists, mid + 1, right);\n\n    return mergeTwoLists(l1, l2);\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"43-merge-in-between-linked-lists",children:"4.3 Merge In Between Linked Lists"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\n    ListNode curr = list1;\n\n    // Move to node before position a\n    for (int i = 0; i < a - 1; i++) {\n        curr = curr.next;\n    }\n\n    ListNode nodeBeforeA = curr;\n\n    // Move to node at position b\n    for (int i = a - 1; i <= b; i++) {\n        curr = curr.next;\n    }\n\n    ListNode nodeAfterB = curr;\n\n    // Connect list2\n    nodeBeforeA.next = list2;\n\n    // Find end of list2\n    while (list2.next != null) {\n        list2 = list2.next;\n    }\n\n    list2.next = nodeAfterB;\n\n    return list1;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"44-flatten-multilevel-doubly-linkedlist",children:"4.4 Flatten Multilevel Doubly LinkedList"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"class Node {\n    int val;\n    Node prev, next, child;\n}\n\nNode flatten(Node head) {\n    if (head == null) return null;\n\n    Node curr = head;\n\n    while (curr != null) {\n        if (curr.child != null) {\n            Node next = curr.next;\n            Node child = flatten(curr.child);\n\n            curr.next = child;\n            child.prev = curr;\n            curr.child = null;\n\n            // Find end of child list\n            while (curr.next != null) {\n                curr = curr.next;\n            }\n\n            if (next != null) {\n                curr.next = next;\n                next.prev = curr;\n            }\n        }\n        curr = curr.next;\n    }\n\n    return head;\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"pattern-5-intersection--union",children:"Pattern 5: Intersection & Union"}),"\n",(0,r.jsx)(n.h3,{id:"51-intersection-of-two-linked-lists",children:"5.1 Intersection of Two Linked Lists"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n    if (headA == null || headB == null) return null;\n\n    ListNode a = headA;\n    ListNode b = headB;\n\n    // When a reaches end, redirect to headB\n    // When b reaches end, redirect to headA\n    // They will meet at intersection or null\n    while (a != b) {\n        a = (a == null) ? headB : a.next;\n        b = (b == null) ? headA : b.next;\n    }\n\n    return a;\n}\n\n// Using length difference\nListNode getIntersectionNode2(ListNode headA, ListNode headB) {\n    int lenA = length(headA);\n    int lenB = length(headB);\n\n    // Move longer list's pointer ahead\n    while (lenA > lenB) {\n        headA = headA.next;\n        lenA--;\n    }\n\n    while (lenB > lenA) {\n        headB = headB.next;\n        lenB--;\n    }\n\n    // Move both together\n    while (headA != headB) {\n        headA = headA.next;\n        headB = headB.next;\n    }\n\n    return headA;\n}\n\nint length(ListNode head) {\n    int count = 0;\n    while (head != null) {\n        count++;\n        head = head.next;\n    }\n    return count;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"52-union-of-two-linked-lists",children:"5.2 Union of Two Linked Lists"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"ListNode union(ListNode head1, ListNode head2) {\n    HashSet<Integer> set = new HashSet<>();\n    ListNode curr = head1;\n\n    while (curr != null) {\n        set.add(curr.val);\n        curr = curr.next;\n    }\n\n    curr = head2;\n    while (curr != null) {\n        set.add(curr.val);\n        curr = curr.next;\n    }\n\n    // Create result list\n    ListNode dummy = new ListNode(0);\n    curr = dummy;\n\n    for (int val : set) {\n        curr.next = new ListNode(val);\n        curr = curr.next;\n    }\n\n    return dummy.next;\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"pattern-6-removal-patterns",children:"Pattern 6: Removal Patterns"}),"\n",(0,r.jsx)(n.h3,{id:"61-remove-duplicates-from-sorted-list",children:"6.1 Remove Duplicates from Sorted List"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"ListNode deleteDuplicates(ListNode head) {\n    ListNode curr = head;\n\n    while (curr != null && curr.next != null) {\n        if (curr.val == curr.next.val) {\n            curr.next = curr.next.next;\n        } else {\n            curr = curr.next;\n        }\n    }\n\n    return head;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"62-remove-all-duplicates-from-sorted-list",children:"6.2 Remove All Duplicates from Sorted List"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"ListNode deleteDuplicates(ListNode head) {\n    ListNode dummy = new ListNode(0);\n    dummy.next = head;\n    ListNode prev = dummy;\n\n    while (head != null) {\n        // Skip all duplicates\n        if (head.next != null && head.val == head.next.val) {\n            while (head.next != null && head.val == head.next.val) {\n                head = head.next;\n            }\n            prev.next = head.next;\n        } else {\n            prev = prev.next;\n        }\n        head = head.next;\n    }\n\n    return dummy.next;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"63-remove-elements-with-given-value",children:"6.3 Remove Elements with Given Value"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"ListNode removeElements(ListNode head, int val) {\n    ListNode dummy = new ListNode(0);\n    dummy.next = head;\n    ListNode curr = dummy;\n\n    while (curr.next != null) {\n        if (curr.next.val == val) {\n            curr.next = curr.next.next;\n        } else {\n            curr = curr.next;\n        }\n    }\n\n    return dummy.next;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"64-remove-nodes-with-greater-value-on-right",children:"6.4 Remove Nodes with Greater Value on Right"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"ListNode removeNodes(ListNode head) {\n    if (head == null) return null;\n\n    // Reverse the list\n    head = reverseList(head);\n\n    ListNode curr = head;\n    int max = head.val;\n\n    while (curr.next != null) {\n        if (curr.next.val < max) {\n            curr.next = curr.next.next;\n        } else {\n            max = curr.next.val;\n            curr = curr.next;\n        }\n    }\n\n    // Reverse back\n    return reverseList(head);\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"65-delete-middle-node",children:"6.5 Delete Middle Node"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"ListNode deleteMiddle(ListNode head) {\n    if (head == null || head.next == null) return null;\n\n    ListNode slow = head;\n    ListNode fast = head;\n    ListNode prev = null;\n\n    while (fast != null && fast.next != null) {\n        prev = slow;\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n\n    prev.next = slow.next;\n    return head;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"66-remove-zero-sum-consecutive-nodes",children:"6.6 Remove Zero Sum Consecutive Nodes"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"ListNode removeZeroSumSublists(ListNode head) {\n    ListNode dummy = new ListNode(0);\n    dummy.next = head;\n\n    HashMap<Integer, ListNode> map = new HashMap<>();\n    int prefixSum = 0;\n\n    for (ListNode curr = dummy; curr != null; curr = curr.next) {\n        prefixSum += curr.val;\n        map.put(prefixSum, curr);\n    }\n\n    prefixSum = 0;\n    for (ListNode curr = dummy; curr != null; curr = curr.next) {\n        prefixSum += curr.val;\n        curr.next = map.get(prefixSum).next;\n    }\n\n    return dummy.next;\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"pattern-7-partition--splitting",children:"Pattern 7: Partition & Splitting"}),"\n",(0,r.jsx)(n.h3,{id:"71-partition-list",children:"7.1 Partition List"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"ListNode partition(ListNode head, int x) {\n    ListNode lessHead = new ListNode(0);\n    ListNode greaterHead = new ListNode(0);\n\n    ListNode less = lessHead;\n    ListNode greater = greaterHead;\n\n    while (head != null) {\n        if (head.val < x) {\n            less.next = head;\n            less = less.next;\n        } else {\n            greater.next = head;\n            greater = greater.next;\n        }\n        head = head.next;\n    }\n\n    greater.next = null;\n    less.next = greaterHead.next;\n\n    return lessHead.next;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"72-odd-even-linked-list",children:"7.2 Odd Even Linked List"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"ListNode oddEvenList(ListNode head) {\n    if (head == null) return null;\n\n    ListNode odd = head;\n    ListNode even = head.next;\n    ListNode evenHead = even;\n\n    while (even != null && even.next != null) {\n        odd.next = even.next;\n        odd = odd.next;\n        even.next = odd.next;\n        even = even.next;\n    }\n\n    odd.next = evenHead;\n    return head;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"73-split-list-into-parts",children:"7.3 Split List into Parts"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"ListNode[] splitListToParts(ListNode head, int k) {\n    int len = 0;\n    ListNode curr = head;\n    while (curr != null) {\n        len++;\n        curr = curr.next;\n    }\n\n    int partSize = len / k;\n    int extra = len % k;\n\n    ListNode[] result = new ListNode[k];\n    curr = head;\n\n    for (int i = 0; i < k; i++) {\n        result[i] = curr;\n        int currentPartSize = partSize + (extra > 0 ? 1 : 0);\n        extra--;\n\n        for (int j = 0; j < currentPartSize - 1 && curr != null; j++) {\n            curr = curr.next;\n        }\n\n        if (curr != null) {\n            ListNode next = curr.next;\n            curr.next = null;\n            curr = next;\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"74-separate-even-and-odd-values",children:"7.4 Separate Even and Odd Values"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"ListNode[] separateEvenOdd(ListNode head) {\n    ListNode evenHead = new ListNode(0);\n    ListNode oddHead = new ListNode(0);\n\n    ListNode even = evenHead;\n    ListNode odd = oddHead;\n\n    while (head != null) {\n        if (head.val % 2 == 0) {\n            even.next = head;\n            even = even.next;\n        } else {\n            odd.next = head;\n            odd = odd.next;\n        }\n        head = head.next;\n    }\n\n    even.next = null;\n    odd.next = null;\n\n    return new ListNode[]{evenHead.next, oddHead.next};\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"pattern-8-addition--arithmetic",children:"Pattern 8: Addition & Arithmetic"}),"\n",(0,r.jsx)(n.h3,{id:"81-add-two-numbers",children:"8.1 Add Two Numbers"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n    ListNode dummy = new ListNode(0);\n    ListNode curr = dummy;\n    int carry = 0;\n\n    while (l1 != null || l2 != null || carry != 0) {\n        int sum = carry;\n\n        if (l1 != null) {\n            sum += l1.val;\n            l1 = l1.next;\n        }\n\n        if (l2 != null) {\n            sum += l2.val;\n            l2 = l2.next;\n        }\n\n        carry = sum / 10;\n        curr.next = new ListNode(sum % 10);\n        curr = curr.next;\n    }\n\n    return dummy.next;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"82-add-two-numbers-ii-most-significant-digit-first",children:"8.2 Add Two Numbers II (Most significant digit first)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n    // Reverse both lists\n    l1 = reverseList(l1);\n    l2 = reverseList(l2);\n\n    // Add reversed lists\n    ListNode result = addTwoNumbers(l1, l2);\n\n    // Reverse result\n    return reverseList(result);\n}\n\n// Alternative: Using Stack\nListNode addTwoNumbersStack(ListNode l1, ListNode l2) {\n    Deque<Integer> s1 = new ArrayDeque<>();\n    Deque<Integer> s2 = new ArrayDeque<>();\n\n    while (l1 != null) {\n        s1.push(l1.val);\n        l1 = l1.next;\n    }\n\n    while (l2 != null) {\n        s2.push(l2.val);\n        l2 = l2.next;\n    }\n\n    ListNode head = null;\n    int carry = 0;\n\n    while (!s1.isEmpty() || !s2.isEmpty() || carry != 0) {\n        int sum = carry;\n\n        if (!s1.isEmpty()) sum += s1.pop();\n        if (!s2.isEmpty()) sum += s2.pop();\n\n        ListNode node = new ListNode(sum % 10);\n        node.next = head;\n        head = node;\n\n        carry = sum / 10;\n    }\n\n    return head;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"83-multiply-two-numbers-represented-by-linkedlists",children:"8.3 Multiply Two Numbers Represented by LinkedLists"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"long multiplyTwoLists(ListNode l1, ListNode l2) {\n    long num1 = 0, num2 = 0;\n    long MOD = 1000000007;\n\n    while (l1 != null) {\n        num1 = ((num1 * 10) + l1.val) % MOD;\n        l1 = l1.next;\n    }\n\n    while (l2 != null) {\n        num2 = ((num2 * 10) + l2.val) % MOD;\n        l2 = l2.next;\n    }\n\n    return (num1 * num2) % MOD;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"84-subtract-two-numbers",children:"8.4 Subtract Two Numbers"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"ListNode subtract(ListNode l1, ListNode l2) {\n    // Reverse both lists\n    l1 = reverseList(l1);\n    l2 = reverseList(l2);\n\n    ListNode dummy = new ListNode(0);\n    ListNode curr = dummy;\n    int borrow = 0;\n\n    while (l1 != null) {\n        int diff = l1.val - borrow;\n\n        if (l2 != null) {\n            diff -= l2.val;\n            l2 = l2.next;\n        }\n\n        if (diff < 0) {\n            diff += 10;\n            borrow = 1;\n        } else {\n            borrow = 0;\n        }\n\n        curr.next = new ListNode(diff);\n        curr = curr.next;\n        l1 = l1.next;\n    }\n\n    // Reverse result and remove leading zeros\n    ListNode result = reverseList(dummy.next);\n    while (result != null && result.val == 0 && result.next != null) {\n        result = result.next;\n    }\n\n    return result;\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"pattern-9-deep-copy--cloning",children:"Pattern 9: Deep Copy & Cloning"}),"\n",(0,r.jsx)(n.h3,{id:"91-copy-list-with-random-pointer",children:"9.1 Copy List with Random Pointer"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"Node copyRandomList(Node head) {\n    if (head == null) return null;\n\n    // Step 1: Create copy nodes interleaved with original\n    Node curr = head;\n    while (curr != null) {\n        Node copy = new Node(curr.val);\n        copy.next = curr.next;\n        curr.next = copy;\n        curr = copy.next;\n    }\n\n    // Step 2: Assign random pointers\n    curr = head;\n    while (curr != null) {\n        if (curr.random != null) {\n            curr.next.random = curr.random.next;\n        }\n        curr = curr.next.next;\n    }\n\n    // Step 3: Separate the lists\n    curr = head;\n    Node copyHead = head.next;\n    Node copyCurr = copyHead;\n\n    while (curr != null) {\n        curr.next = curr.next.next;\n        if (copyCurr.next != null) {\n            copyCurr.next = copyCurr.next.next;\n        }\n        curr = curr.next;\n        copyCurr = copyCurr.next;\n    }\n\n    return copyHead;\n}\n\n// Using HashMap\nNode copyRandomListHashMap(Node head) {\n    if (head == null) return null;\n\n    HashMap<Node, Node> map = new HashMap<>();\n    Node curr = head;\n\n    // First pass: create all nodes\n    while (curr != null) {\n        map.put(curr, new Node(curr.val));\n        curr = curr.next;\n    }\n\n    // Second pass: assign next and random\n    curr = head;\n    while (curr != null) {\n        map.get(curr).next = map.get(curr.next);\n        map.get(curr).random = map.get(curr.random);\n        curr = curr.next;\n    }\n\n    return map.get(head);\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"92-clone-linked-list-with-arbitrary-pointer",children:"9.2 Clone Linked List with Arbitrary Pointer"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"Node cloneLinkedList(Node head) {\n    if (head == null) return null;\n\n    HashMap<Node, Node> map = new HashMap<>();\n    Node curr = head;\n\n    // Create all nodes\n    while (curr != null) {\n        map.put(curr, new Node(curr.val));\n        curr = curr.next;\n    }\n\n    // Link all pointers\n    curr = head;\n    while (curr != null) {\n        Node clone = map.get(curr);\n        clone.next = map.get(curr.next);\n        clone.random = map.get(curr.random);\n        curr = curr.next;\n    }\n\n    return map.get(head);\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"pattern-10-rotation--shifting",children:"Pattern 10: Rotation & Shifting"}),"\n",(0,r.jsx)(n.h3,{id:"101-rotate-list",children:"10.1 Rotate List"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"ListNode rotateRight(ListNode head, int k) {\n    if (head == null || head.next == null || k == 0) return head;\n\n    // Find length and connect to make circular\n    int len = 1;\n    ListNode tail = head;\n    while (tail.next != null) {\n        tail = tail.next;\n        len++;\n    }\n\n    tail.next = head;\n\n    // Find new tail position\n    k = k % len;\n    int stepsToNewTail = len - k;\n\n    ListNode newTail = head;\n    for (int i = 1; i < stepsToNewTail; i++) {\n        newTail = newTail.next;\n    }\n\n    ListNode newHead = newTail.next;\n    newTail.next = null;\n\n    return newHead;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"102-rotate-list-to-left",children:"10.2 Rotate List to Left"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"ListNode rotateLeft(ListNode head, int k) {\n    if (head == null || head.next == null || k == 0) return head;\n\n    int len = 1;\n    ListNode tail = head;\n    while (tail.next != null) {\n        tail = tail.next;\n        len++;\n    }\n\n    k = k % len;\n    if (k == 0) return head;\n\n    // Find new tail\n    ListNode newTail = head;\n    for (int i = 1; i < k; i++) {\n        newTail = newTail.next;\n    }\n\n    ListNode newHead = newTail.next;\n    newTail.next = null;\n    tail.next = head;\n\n    return newHead;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"103-swap-nodes-in-pairs",children:"10.3 Swap Nodes in Pairs"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"ListNode swapPairs(ListNode head) {\n    if (head == null || head.next == null) return head;\n\n    ListNode dummy = new ListNode(0);\n    dummy.next = head;\n    ListNode prev = dummy;\n\n    while (head != null && head.next != null) {\n        ListNode first = head;\n        ListNode second = head.next;\n\n        // Swap\n        prev.next = second;\n        first.next = second.next;\n        second.next = first;\n\n        // Move pointers\n        prev = first;\n        head = first.next;\n    }\n\n    return dummy.next;\n}\n\n// Recursive\nListNode swapPairsRecursive(ListNode head) {\n    if (head == null || head.next == null) return head;\n\n    ListNode newHead = head.next;\n    head.next = swapPairsRecursive(newHead.next);\n    newHead.next = head;\n\n    return newHead;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"104-swap-kth-node-from-beginning-and-end",children:"10.4 Swap Kth Node from Beginning and End"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"ListNode swapNodes(ListNode head, int k) {\n    ListNode first = head;\n    ListNode second = head;\n    ListNode curr = head;\n\n    // Move to kth node from beginning\n    for (int i = 1; i < k; i++) {\n        curr = curr.next;\n    }\n    first = curr;\n\n    // Find kth from end\n    while (curr.next != null) {\n        curr = curr.next;\n        second = second.next;\n    }\n\n    // Swap values\n    int temp = first.val;\n    first.val = second.val;\n    second.val = temp;\n\n    return head;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"105-reorder-list-l0--ln--l1--ln-1",children:"10.5 Reorder List (L0 \u2192 Ln \u2192 L1 \u2192 Ln-1...)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"void reorderList(ListNode head) {\n    if (head == null || head.next == null) return;\n\n    // Find middle\n    ListNode slow = head;\n    ListNode fast = head;\n    while (fast.next != null && fast.next.next != null) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n\n    // Reverse second half\n    ListNode second = reverseList(slow.next);\n    slow.next = null;\n\n    // Merge two halves\n    ListNode first = head;\n    while (second != null) {\n        ListNode temp1 = first.next;\n        ListNode temp2 = second.next;\n\n        first.next = second;\n        second.next = temp1;\n\n        first = temp1;\n        second = temp2;\n    }\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"pattern-11-palindrome-checking",children:"Pattern 11: Palindrome Checking"}),"\n",(0,r.jsx)(n.h3,{id:"111-palindrome-linked-list",children:"11.1 Palindrome Linked List"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"boolean isPalindrome(ListNode head) {\n    if (head == null || head.next == null) return true;\n\n    // Find middle\n    ListNode slow = head;\n    ListNode fast = head;\n    while (fast.next != null && fast.next.next != null) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n\n    // Reverse second half\n    ListNode secondHalf = reverseList(slow.next);\n\n    // Compare\n    ListNode p1 = head;\n    ListNode p2 = secondHalf;\n\n    while (p2 != null) {\n        if (p1.val != p2.val) {\n            return false;\n        }\n        p1 = p1.next;\n        p2 = p2.next;\n    }\n\n    return true;\n}\n\n// Using Stack\nboolean isPalindromeStack(ListNode head) {\n    Deque<Integer> stack = new ArrayDeque<>();\n    ListNode curr = head;\n\n    while (curr != null) {\n        stack.push(curr.val);\n        curr = curr.next;\n    }\n\n    curr = head;\n    while (curr != null) {\n        if (curr.val != stack.pop()) {\n            return false;\n        }\n        curr = curr.next;\n    }\n\n    return true;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"112-check-if-palindrome-after-removing-one-node",children:"11.2 Check if Palindrome after Removing One Node"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"boolean isPalindromeAfterRemoval(ListNode head) {\n    List<Integer> list = new ArrayList<>();\n    ListNode curr = head;\n\n    while (curr != null) {\n        list.add(curr.val);\n        curr = curr.next;\n    }\n\n    // Try removing each node\n    for (int i = 0; i < list.size(); i++) {\n        if (isPalindromeList(list, i)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nboolean isPalindromeList(List<Integer> list, int skip) {\n    int left = 0, right = list.size() - 1;\n\n    while (left < right) {\n        if (left == skip) left++;\n        if (right == skip) right--;\n\n        if (left < right && !list.get(left).equals(list.get(right))) {\n            return false;\n        }\n\n        left++;\n        right--;\n    }\n\n    return true;\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"pattern-12-sorting-patterns",children:"Pattern 12: Sorting Patterns"}),"\n",(0,r.jsx)(n.h3,{id:"121-insertion-sort-list",children:"12.1 Insertion Sort List"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"ListNode insertionSortList(ListNode head) {\n    ListNode dummy = new ListNode(0);\n    ListNode curr = head;\n\n    while (curr != null) {\n        ListNode prev = dummy;\n\n        // Find position to insert\n        while (prev.next != null && prev.next.val < curr.val) {\n            prev = prev.next;\n        }\n\n        // Insert\n        ListNode next = curr.next;\n        curr.next = prev.next;\n        prev.next = curr;\n        curr = next;\n    }\n\n    return dummy.next;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"122-merge-sort-list",children:"12.2 Merge Sort List"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"ListNode sortList(ListNode head) {\n    if (head == null || head.next == null) return head;\n\n    // Find middle\n    ListNode slow = head;\n    ListNode fast = head;\n    ListNode prev = null;\n\n    while (fast != null && fast.next != null) {\n        prev = slow;\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n\n    prev.next = null;\n\n    // Sort both halves\n    ListNode left = sortList(head);\n    ListNode right = sortList(slow);\n\n    // Merge\n    return mergeTwoLists(left, right);\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"123-quick-sort-list",children:"12.3 Quick Sort List"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"ListNode quickSort(ListNode head) {\n    if (head == null || head.next == null) return head;\n\n    // Choose pivot (last node)\n    ListNode pivot = getTail(head);\n\n    // Partition\n    ListNode[] partitions = partition(head, pivot);\n    ListNode less = partitions[0];\n    ListNode equal = partitions[1];\n    ListNode greater = partitions[2];\n\n    // Recursively sort\n    less = quickSort(less);\n    greater = quickSort(greater);\n\n    // Combine\n    return combine(less, equal, greater);\n}\n\nListNode getTail(ListNode head) {\n    while (head.next != null) {\n        head = head.next;\n    }\n    return head;\n}\n\nListNode[] partition(ListNode head, ListNode pivot) {\n    ListNode lessHead = new ListNode(0);\n    ListNode equalHead = new ListNode(0);\n    ListNode greaterHead = new ListNode(0);\n\n    ListNode less = lessHead;\n    ListNode equal = equalHead;\n    ListNode greater = greaterHead;\n\n    while (head != null) {\n        if (head.val < pivot.val) {\n            less.next = head;\n            less = less.next;\n        } else if (head.val > pivot.val) {\n            greater.next = head;\n            greater = greater.next;\n        } else {\n            equal.next = head;\n            equal = equal.next;\n        }\n        head = head.next;\n    }\n\n    less.next = null;\n    equal.next = null;\n    greater.next = null;\n\n    return new ListNode[]{lessHead.next, equalHead.next, greaterHead.next};\n}\n\nListNode combine(ListNode less, ListNode equal, ListNode greater) {\n    ListNode dummy = new ListNode(0);\n    ListNode curr = dummy;\n\n    if (less != null) {\n        curr.next = less;\n        while (curr.next != null) curr = curr.next;\n    }\n\n    if (equal != null) {\n        curr.next = equal;\n        while (curr.next != null) curr = curr.next;\n    }\n\n    if (greater != null) {\n        curr.next = greater;\n    }\n\n    return dummy.next;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"124-sort-list-with-0s-1s-and-2s",children:"12.4 Sort List with 0s, 1s, and 2s"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"ListNode sortList012(ListNode head) {\n    int[] count = new int[3];\n    ListNode curr = head;\n\n    // Count occurrences\n    while (curr != null) {\n        count[curr.val]++;\n        curr = curr.next;\n    }\n\n    // Reconstruct list\n    curr = head;\n    int i = 0;\n    while (curr != null) {\n        if (count[i] == 0) {\n            i++;\n        } else {\n            curr.val = i;\n            count[i]--;\n            curr = curr.next;\n        }\n    }\n\n    return head;\n}\n\n// Without modifying data (rearranging pointers)\nListNode sortList012Pointers(ListNode head) {\n    ListNode zeroHead = new ListNode(0);\n    ListNode oneHead = new ListNode(0);\n    ListNode twoHead = new ListNode(0);\n\n    ListNode zero = zeroHead;\n    ListNode one = oneHead;\n    ListNode two = twoHead;\n\n    while (head != null) {\n        if (head.val == 0) {\n            zero.next = head;\n            zero = zero.next;\n        } else if (head.val == 1) {\n            one.next = head;\n            one = one.next;\n        } else {\n            two.next = head;\n            two = two.next;\n        }\n        head = head.next;\n    }\n\n    zero.next = oneHead.next != null ? oneHead.next : twoHead.next;\n    one.next = twoHead.next;\n    two.next = null;\n\n    return zeroHead.next;\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"pattern-13-advanced-problems",children:"Pattern 13: Advanced Problems"}),"\n",(0,r.jsx)(n.h3,{id:"131-lru-cache-implementation",children:"13.1 LRU Cache Implementation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"class LRUCache {\n    class Node {\n        int key, value;\n        Node prev, next;\n\n        Node(int key, int value) {\n            this.key = key;\n            this.value = value;\n        }\n    }\n\n    private HashMap<Integer, Node> map;\n    private Node head, tail;\n    private int capacity;\n\n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        map = new HashMap<>();\n        head = new Node(0, 0);\n        tail = new Node(0, 0);\n        head.next = tail;\n        tail.prev = head;\n    }\n\n    public int get(int key) {\n        if (!map.containsKey(key)) return -1;\n\n        Node node = map.get(key);\n        remove(node);\n        addToHead(node);\n\n        return node.value;\n    }\n\n    public void put(int key, int value) {\n        if (map.containsKey(key)) {\n            Node node = map.get(key);\n            node.value = value;\n            remove(node);\n            addToHead(node);\n        } else {\n            if (map.size() == capacity) {\n                Node lru = tail.prev;\n                remove(lru);\n                map.remove(lru.key);\n            }\n\n            Node node = new Node(key, value);\n            map.put(key, node);\n            addToHead(node);\n        }\n    }\n\n    private void remove(Node node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n\n    private void addToHead(Node node) {\n        node.next = head.next;\n        node.prev = head;\n        head.next.prev = node;\n        head.next = node;\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"132-flatten-a-binary-tree-to-linked-list",children:"13.2 Flatten a Binary Tree to Linked List"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"void flatten(TreeNode root) {\n    if (root == null) return;\n\n    flatten(root.left);\n    flatten(root.right);\n\n    TreeNode right = root.right;\n    root.right = root.left;\n    root.left = null;\n\n    TreeNode curr = root;\n    while (curr.right != null) {\n        curr = curr.right;\n    }\n    curr.right = right;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"133-convert-binary-tree-to-doubly-linked-list",children:"13.3 Convert Binary Tree to Doubly Linked List"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"class TreeNode {\n    int val;\n    TreeNode left, right;\n    TreeNode(int val) { this.val = val; }\n}\n\nTreeNode prev = null;\n\nTreeNode treeToDoublyList(TreeNode root) {\n    if (root == null) return null;\n\n    TreeNode dummy = new TreeNode(0);\n    prev = dummy;\n\n    inorder(root);\n\n    // Make circular\n    prev.right = dummy.right;\n    dummy.right.left = prev;\n\n    return dummy.right;\n}\n\nvoid inorder(TreeNode node) {\n    if (node == null) return;\n\n    inorder(node.left);\n\n    prev.right = node;\n    node.left = prev;\n    prev = node;\n\n    inorder(node.right);\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"134-design-browser-history",children:"13.4 Design Browser History"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"class BrowserHistory {\n    class Node {\n        String url;\n        Node prev, next;\n\n        Node(String url) {\n            this.url = url;\n        }\n    }\n\n    Node current;\n\n    public BrowserHistory(String homepage) {\n        current = new Node(homepage);\n    }\n\n    public void visit(String url) {\n        Node newNode = new Node(url);\n        current.next = newNode;\n        newNode.prev = current;\n        current = newNode;\n    }\n\n    public String back(int steps) {\n        while (steps > 0 && current.prev != null) {\n            current = current.prev;\n            steps--;\n        }\n        return current.url;\n    }\n\n    public String forward(int steps) {\n        while (steps > 0 && current.next != null) {\n            current = current.next;\n            steps--;\n        }\n        return current.url;\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"135-design-skiplist",children:"13.5 Design Skiplist"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"class Skiplist {\n    class Node {\n        int val;\n        Node[] next;\n\n        Node(int val, int level) {\n            this.val = val;\n            next = new Node[level + 1];\n        }\n    }\n\n    private static final int MAX_LEVEL = 16;\n    private Node head;\n    private int level;\n\n    public Skiplist() {\n        head = new Node(-1, MAX_LEVEL);\n        level = 0;\n    }\n\n    public boolean search(int target) {\n        Node curr = head;\n\n        for (int i = level; i >= 0; i--) {\n            while (curr.next[i] != null && curr.next[i].val < target) {\n                curr = curr.next[i];\n            }\n        }\n\n        curr = curr.next[0];\n        return curr != null && curr.val == target;\n    }\n\n    public void add(int num) {\n        Node[] update = new Node[MAX_LEVEL + 1];\n        Node curr = head;\n\n        for (int i = level; i >= 0; i--) {\n            while (curr.next[i] != null && curr.next[i].val < num) {\n                curr = curr.next[i];\n            }\n            update[i] = curr;\n        }\n\n        int newLevel = randomLevel();\n        if (newLevel > level) {\n            for (int i = level + 1; i <= newLevel; i++) {\n                update[i] = head;\n            }\n            level = newLevel;\n        }\n\n        Node newNode = new Node(num, newLevel);\n        for (int i = 0; i <= newLevel; i++) {\n            newNode.next[i] = update[i].next[i];\n            update[i].next[i] = newNode;\n        }\n    }\n\n    public boolean erase(int num) {\n        Node[] update = new Node[MAX_LEVEL + 1];\n        Node curr = head;\n\n        for (int i = level; i >= 0; i--) {\n            while (curr.next[i] != null && curr.next[i].val < num) {\n                curr = curr.next[i];\n            }\n            update[i] = curr;\n        }\n\n        curr = curr.next[0];\n\n        if (curr == null || curr.val != num) {\n            return false;\n        }\n\n        for (int i = 0; i <= level; i++) {\n            if (update[i].next[i] != curr) break;\n            update[i].next[i] = curr.next[i];\n        }\n\n        while (level > 0 && head.next[level] == null) {\n            level--;\n        }\n\n        return true;\n    }\n\n    private int randomLevel() {\n        int lvl = 0;\n        while (Math.random() < 0.5 && lvl < MAX_LEVEL) {\n            lvl++;\n        }\n        return lvl;\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"136-reverse-nodes-in-k-group-hard",children:"13.6 Reverse Nodes in k-Group (Hard)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"ListNode reverseKGroup(ListNode head, int k) {\n    ListNode dummy = new ListNode(0);\n    dummy.next = head;\n    ListNode prev = dummy;\n\n    while (true) {\n        ListNode kth = getKth(prev, k);\n        if (kth == null) break;\n\n        ListNode groupNext = kth.next;\n\n        // Reverse group\n        ListNode curr = prev.next;\n        ListNode next = curr.next;\n\n        while (next != groupNext) {\n            curr.next = next.next;\n            next.next = prev.next;\n            prev.next = next;\n            next = curr.next;\n        }\n\n        prev = curr;\n    }\n\n    return dummy.next;\n}\n\nListNode getKth(ListNode curr, int k) {\n    while (curr != null && k > 0) {\n        curr = curr.next;\n        k--;\n    }\n    return curr;\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"time-complexity-cheat-sheet",children:"Time Complexity Cheat Sheet"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Operation"}),(0,r.jsx)(n.th,{children:"Time Complexity"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Access nth node"}),(0,r.jsx)(n.td,{children:"O(n)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Search"}),(0,r.jsx)(n.td,{children:"O(n)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Insert at head"}),(0,r.jsx)(n.td,{children:"O(1)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Insert at tail"}),(0,r.jsx)(n.td,{children:"O(n) without tail pointer"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Insert at position"}),(0,r.jsx)(n.td,{children:"O(n)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Delete at head"}),(0,r.jsx)(n.td,{children:"O(1)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Delete at tail"}),(0,r.jsx)(n.td,{children:"O(n)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Delete at position"}),(0,r.jsx)(n.td,{children:"O(n)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Reverse"}),(0,r.jsx)(n.td,{children:"O(n)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Detect cycle"}),(0,r.jsx)(n.td,{children:"O(n)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Merge two lists"}),(0,r.jsx)(n.td,{children:"O(n + m)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Sort"}),(0,r.jsx)(n.td,{children:"O(n log n)"})]})]})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"common-tricks--tips",children:"Common Tricks & Tips"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Dummy Node"}),": Use for easier edge case handling"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Two Pointers"}),": Fast & slow for finding middle, cycle detection"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Reversal"}),": Many problems solved by reversing part/all of list"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"HashMap"}),": For cloning with random pointers, finding intersections"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Stack"}),": For palindrome checking, reversing without modifying"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Recursion"}),": For elegant reversal, merging solutions"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Length Calculation"}),": Often needed for nth from end problems"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Circular Connection"}),": Useful for rotation problems"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{})]})}function c(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>d,x:()=>s});var r=t(6540);const i={},l=r.createContext(i);function d(e){const n=r.useContext(l);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:d(e.components),r.createElement(l.Provider,{value:n},e.children)}}}]);