"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[971],{28453:(n,t,e)=>{e.d(t,{R:()=>a,x:()=>l});var i=e(96540);const r={},s=i.createContext(r);function a(n){const t=i.useContext(s);return i.useMemo(function(){return"function"==typeof n?n(t):{...t,...n}},[t,n])}function l(n){let t;return t=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:a(n.components),i.createElement(s.Provider,{value:t},n.children)}},88351:(n,t,e)=>{e.r(t),e.d(t,{assets:()=>o,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>l,toc:()=>u});var i=e(74848),r=e(28453);const s={},a="Two Pointers",l={id:"DSA/DSA with Java/Two Pointers",title:"Two Pointers",description:"Table of Contents",source:"@site/docs/DSA/DSA with Java/Two Pointers.mdx",sourceDirName:"DSA/DSA with Java",slug:"/DSA/DSA with Java/Two Pointers",permalink:"/dev.enigma/docs/DSA/DSA with Java/Two Pointers",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with Java/Two Pointers.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Trie Patterns",permalink:"/dev.enigma/docs/DSA/DSA with Java/Trie Patterns"},next:{title:"DSA Cheatsheets",permalink:"/dev.enigma/docs/category/dsa-cheatsheets"}},o={},u=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Two Pointers Fundamentals",id:"two-pointers-fundamentals",level:2},{value:"Core Concepts and Implementation",id:"core-concepts-and-implementation",level:3},{value:"Pattern 1: Opposite Direction Pointers",id:"pattern-1-opposite-direction-pointers",level:2},{value:"1.1 Two Sum Problems",id:"11-two-sum-problems",level:3},{value:"1.2 Advanced Opposite Direction Problems",id:"12-advanced-opposite-direction-problems",level:3},{value:"Pattern 2: Same Direction Pointers",id:"pattern-2-same-direction-pointers",level:2},{value:"2.1 Array Modification Problems",id:"21-array-modification-problems",level:3},{value:"2.2 Advanced Same Direction Problems",id:"22-advanced-same-direction-problems",level:3},{value:"Pattern 3: Fast and Slow Pointers",id:"pattern-3-fast-and-slow-pointers",level:2},{value:"3.1 Linked List Cycle Detection",id:"31-linked-list-cycle-detection",level:3},{value:"3.2 Advanced Fast and Slow Pointer Problems",id:"32-advanced-fast-and-slow-pointer-problems",level:3},{value:"Two Pointers Guidelines",id:"two-pointers-guidelines",level:3},{value:"Pattern 4: Two Pointers for Sorting",id:"pattern-4-two-pointers-for-sorting",level:2},{value:"4.1 Partitioning and Sorting Problems",id:"41-partitioning-and-sorting-problems",level:3},{value:"4.2 Advanced Sorting Applications",id:"42-advanced-sorting-applications",level:3},{value:"Pattern 5: Two Pointers with HashMap",id:"pattern-5-two-pointers-with-hashmap",level:2},{value:"5.1 Frequency and Counting Problems",id:"51-frequency-and-counting-problems",level:3},{value:"Pattern 6: Multiple Arrays Two Pointers",id:"pattern-6-multiple-arrays-two-pointers",level:2},{value:"6.1 Merging and Intersection Problems",id:"61-merging-and-intersection-problems",level:3},{value:"Pattern 7: Linked List Two Pointers",id:"pattern-7-linked-list-two-pointers",level:2},{value:"7.1 Advanced Linked List Operations",id:"71-advanced-linked-list-operations",level:3},{value:"Pattern 8: String Manipulation with Two Pointers",id:"pattern-8-string-manipulation-with-two-pointers",level:2},{value:"8.1 String Processing and Validation",id:"81-string-processing-and-validation",level:3},{value:"Pattern 9: Advanced Two Pointers Techniques",id:"pattern-9-advanced-two-pointers-techniques",level:2},{value:"9.1 Complex Algorithm Applications",id:"91-complex-algorithm-applications",level:3},{value:"Pattern 10: Matrix and 2D Two Pointers",id:"pattern-10-matrix-and-2d-two-pointers",level:2},{value:"10.1 2D Array Problems",id:"101-2d-array-problems",level:3},{value:"Pattern 11: Optimization Techniques",id:"pattern-11-optimization-techniques",level:2},{value:"11.1 Performance and Memory Optimizations",id:"111-performance-and-memory-optimizations",level:3},{value:"Summary and Conclusion",id:"summary-and-conclusion",level:2},{value:"Two Pointers Pattern Recognition",id:"two-pointers-pattern-recognition",level:3},{value:"Time &amp; Space Complexity Reference",id:"time--space-complexity-reference",level:2}];function h(n){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"two-pointers",children:"Two Pointers"})}),"\n",(0,i.jsx)(t.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#two-pointers-fundamentals",children:"Two Pointers Fundamentals"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#pattern-1-opposite-direction-pointers",children:"Pattern 1: Opposite Direction Pointers"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#pattern-2-same-direction-pointers",children:"Pattern 2: Same Direction Pointers"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#pattern-3-fast-and-slow-pointers",children:"Pattern 3: Fast and Slow Pointers"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#pattern-4-two-pointers-for-sorting",children:"Pattern 4: Two Pointers for Sorting"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#pattern-5-two-pointers-with-hashmap",children:"Pattern 5: Two Pointers with HashMap"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#pattern-6-multiple-arrays-two-pointers",children:"Pattern 6: Multiple Arrays Two Pointers"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#pattern-7-linked-list-two-pointers",children:"Pattern 7: Linked List Two Pointers"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#pattern-8-string-manipulation-with-two-pointers",children:"Pattern 8: String Manipulation with Two Pointers"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#pattern-9-advanced-two-pointers-techniques",children:"Pattern 9: Advanced Two Pointers Techniques"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#pattern-10-matrix-and-2d-two-pointers",children:"Pattern 10: Matrix and 2D Two Pointers"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"#pattern-11-optimization-techniques",children:"Pattern 11: Optimization Techniques"})}),"\n"]}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"two-pointers-fundamentals",children:"Two Pointers Fundamentals"}),"\n",(0,i.jsx)(t.h3,{id:"core-concepts-and-implementation",children:"Core Concepts and Implementation"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-java",children:'// Basic Two Pointers Implementation Templates\npublic class TwoPointersFundamentals {\n\n    // Template 1: Opposite Direction Pointers (Meet in the middle)\n    public static class OppositeDirectionTemplate {\n\n        // Generic template for opposite direction pointers\n        public boolean oppositeDirectionTemplate(int[] nums, int target) {\n            int left = 0;\n            int right = nums.length - 1;\n\n            while (left < right) {\n                int sum = nums[left] + nums[right];\n\n                if (sum == target) {\n                    return true;\n                } else if (sum < target) {\n                    left++; // Need larger sum\n                } else {\n                    right--; // Need smaller sum\n                }\n            }\n\n            return false;\n        }\n\n        // Two Sum in sorted array\n        public int[] twoSum(int[] nums, int target) {\n            int left = 0, right = nums.length - 1;\n\n            while (left < right) {\n                int sum = nums[left] + nums[right];\n\n                if (sum == target) {\n                    return new int[]{left, right};\n                } else if (sum < target) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n\n            return new int[]{-1, -1};\n        }\n\n        // Valid Palindrome\n        public boolean isPalindrome(String s) {\n            int left = 0, right = s.length() - 1;\n\n            while (left < right) {\n                // Skip non-alphanumeric characters\n                while (left < right && !Character.isAlphaNumeric(s.charAt(left))) {\n                    left++;\n                }\n                while (left < right && !Character.isAlphaNumeric(s.charAt(right))) {\n                    right--;\n                }\n\n                if (Character.toLowerCase(s.charAt(left)) !=\n                    Character.toLowerCase(s.charAt(right))) {\n                    return false;\n                }\n\n                left++;\n                right--;\n            }\n\n            return true;\n        }\n    }\n\n    // Template 2: Same Direction Pointers\n    public static class SameDirectionTemplate {\n\n        // Generic template for same direction pointers\n        public int sameDirectionTemplate(int[] nums, int condition) {\n            int slow = 0; // Slow pointer for valid elements\n\n            for (int fast = 0; fast < nums.length; fast++) {\n                if (nums[fast] != condition) { // or any other condition\n                    nums[slow] = nums[fast];\n                    slow++;\n                }\n            }\n\n            return slow; // New length or count\n        }\n\n        // Remove Element\n        public int removeElement(int[] nums, int val) {\n            int slow = 0;\n\n            for (int fast = 0; fast < nums.length; fast++) {\n                if (nums[fast] != val) {\n                    nums[slow] = nums[fast];\n                    slow++;\n                }\n            }\n\n            return slow;\n        }\n\n        // Remove Duplicates from Sorted Array\n        public int removeDuplicates(int[] nums) {\n            if (nums.length == 0) return 0;\n\n            int slow = 1; // Start from second position\n\n            for (int fast = 1; fast < nums.length; fast++) {\n                if (nums[fast] != nums[fast - 1]) {\n                    nums[slow] = nums[fast];\n                    slow++;\n                }\n            }\n\n            return slow;\n        }\n    }\n\n    // Template 3: Fast and Slow Pointers (Floyd\'s Algorithm)\n    public static class FastSlowTemplate {\n\n        // Generic cycle detection template\n        public boolean hasCycle(ListNode head) {\n            if (head == null || head.next == null) return false;\n\n            ListNode slow = head;\n            ListNode fast = head;\n\n            while (fast != null && fast.next != null) {\n                slow = slow.next;        // Move slow pointer one step\n                fast = fast.next.next;   // Move fast pointer two steps\n\n                if (slow == fast) {\n                    return true; // Cycle detected\n                }\n            }\n\n            return false;\n        }\n\n        // Find middle of linked list\n        public ListNode findMiddle(ListNode head) {\n            if (head == null) return null;\n\n            ListNode slow = head;\n            ListNode fast = head;\n\n            while (fast != null && fast.next != null) {\n                slow = slow.next;\n                fast = fast.next.next;\n            }\n\n            return slow; // Middle node\n        }\n    }\n\n    // Utility class for common two pointers operations\n    public static class TwoPointersUtils {\n\n        // Check if two pointers technique is applicable\n        public static boolean isApplicable(String problemDescription) {\n            String[] keywords = {\n                "two sum", "pair", "sorted array", "palindrome",\n                "remove", "duplicate", "cycle", "middle",\n                "merge", "intersection", "triplet"\n            };\n\n            String lowerDesc = problemDescription.toLowerCase();\n            return Arrays.stream(keywords).anyMatch(lowerDesc::contains);\n        }\n\n        // Determine appropriate two pointers technique\n        public static String determineTechnique(boolean isSorted, boolean sameDirNeeded,\n                                               boolean cycleDetection) {\n            if (cycleDetection) {\n                return "Fast and Slow Pointers";\n            } else if (isSorted) {\n                return "Opposite Direction Pointers";\n            } else if (sameDirNeeded) {\n                return "Same Direction Pointers";\n            } else {\n                return "Custom Two Pointers Approach";\n            }\n        }\n\n        // Debug helper for two pointers\n        public static void debugPointers(int[] nums, int left, int right, String operation) {\n            System.out.printf("%s: left=%d (val=%d), right=%d (val=%d)%n",\n                            operation, left,\n                            left < nums.length ? nums[left] : -1,\n                            right,\n                            right < nums.length ? nums[right] : -1);\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"pattern-1-opposite-direction-pointers",children:"Pattern 1: Opposite Direction Pointers"}),"\n",(0,i.jsx)(t.h3,{id:"11-two-sum-problems",children:"1.1 Two Sum Problems"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-java",children:"// Opposite direction pointers for sorted arrays\npublic class OppositeDirectionPointers {\n\n    // Two Sum in sorted array\n    public int[] twoSum(int[] numbers, int target) {\n        int left = 0, right = numbers.length - 1;\n\n        while (left < right) {\n            int sum = numbers[left] + numbers[right];\n\n            if (sum == target) {\n                return new int[]{left + 1, right + 1}; // 1-indexed\n            } else if (sum < target) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n\n        return new int[]{-1, -1}; // No solution found\n    }\n\n    // Three Sum\n    public List<List<Integer>> threeSum(int[] nums) {\n        Arrays.sort(nums);\n        List<List<Integer>> result = new ArrayList<>();\n\n        for (int i = 0; i < nums.length - 2; i++) {\n            // Skip duplicates for first element\n            if (i > 0 && nums[i] == nums[i - 1]) continue;\n\n            int left = i + 1, right = nums.length - 1;\n            int target = -nums[i];\n\n            while (left < right) {\n                int sum = nums[left] + nums[right];\n\n                if (sum == target) {\n                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));\n\n                    // Skip duplicates\n                    while (left < right && nums[left] == nums[left + 1]) left++;\n                    while (left < right && nums[right] == nums[right - 1]) right--;\n\n                    left++;\n                    right--;\n                } else if (sum < target) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n\n        return result;\n    }\n\n    // Three Sum Closest\n    public int threeSumClosest(int[] nums, int target) {\n        Arrays.sort(nums);\n        int closestSum = nums[^20_0] + nums[^20_1] + nums[^20_2];\n\n        for (int i = 0; i < nums.length - 2; i++) {\n            int left = i + 1, right = nums.length - 1;\n\n            while (left < right) {\n                int currentSum = nums[i] + nums[left] + nums[right];\n\n                if (Math.abs(currentSum - target) < Math.abs(closestSum - target)) {\n                    closestSum = currentSum;\n                }\n\n                if (currentSum < target) {\n                    left++;\n                } else if (currentSum > target) {\n                    right--;\n                } else {\n                    return currentSum; // Exact match\n                }\n            }\n        }\n\n        return closestSum;\n    }\n\n    // Four Sum\n    public List<List<Integer>> fourSum(int[] nums, int target) {\n        Arrays.sort(nums);\n        List<List<Integer>> result = new ArrayList<>();\n\n        for (int i = 0; i < nums.length - 3; i++) {\n            if (i > 0 && nums[i] == nums[i - 1]) continue;\n\n            for (int j = i + 1; j < nums.length - 2; j++) {\n                if (j > i + 1 && nums[j] == nums[j - 1]) continue;\n\n                int left = j + 1, right = nums.length - 1;\n                long remaining = (long) target - nums[i] - nums[j];\n\n                while (left < right) {\n                    long sum = nums[left] + nums[right];\n\n                    if (sum == remaining) {\n                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\n\n                        while (left < right && nums[left] == nums[left + 1]) left++;\n                        while (left < right && nums[right] == nums[right - 1]) right--;\n\n                        left++;\n                        right--;\n                    } else if (sum < remaining) {\n                        left++;\n                    } else {\n                        right--;\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n\n    // Container With Most Water\n    public int maxArea(int[] height) {\n        int left = 0, right = height.length - 1;\n        int maxWater = 0;\n\n        while (left < right) {\n            int width = right - left;\n            int currentWater = Math.min(height[left], height[right]) * width;\n            maxWater = Math.max(maxWater, currentWater);\n\n            // Move pointer with smaller height\n            if (height[left] < height[right]) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n\n        return maxWater;\n    }\n\n    // Trapping Rain Water\n    public int trap(int[] height) {\n        if (height.length < 3) return 0;\n\n        int left = 0, right = height.length - 1;\n        int leftMax = 0, rightMax = 0;\n        int water = 0;\n\n        while (left < right) {\n            if (height[left] < height[right]) {\n                if (height[left] >= leftMax) {\n                    leftMax = height[left];\n                } else {\n                    water += leftMax - height[left];\n                }\n                left++;\n            } else {\n                if (height[right] >= rightMax) {\n                    rightMax = height[right];\n                } else {\n                    water += rightMax - height[right];\n                }\n                right--;\n            }\n        }\n\n        return water;\n    }\n\n    // Valid Palindrome\n    public boolean isPalindrome(String s) {\n        int left = 0, right = s.length() - 1;\n\n        while (left < right) {\n            while (left < right && !Character.isAlphabetic(s.charAt(left)) &&\n                   !Character.isDigit(s.charAt(left))) {\n                left++;\n            }\n\n            while (left < right && !Character.isAlphabetic(s.charAt(right)) &&\n                   !Character.isDigit(s.charAt(right))) {\n                right--;\n            }\n\n            if (Character.toLowerCase(s.charAt(left)) !=\n                Character.toLowerCase(s.charAt(right))) {\n                return false;\n            }\n\n            left++;\n            right--;\n        }\n\n        return true;\n    }\n\n    // Reverse String\n    public void reverseString(char[] s) {\n        int left = 0, right = s.length - 1;\n\n        while (left < right) {\n            char temp = s[left];\n            s[left] = s[right];\n            s[right] = temp;\n\n            left++;\n            right--;\n        }\n    }\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"12-advanced-opposite-direction-problems",children:"1.2 Advanced Opposite Direction Problems"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-java",children:'// Advanced opposite direction pointer problems\npublic class AdvancedOppositeDirection {\n\n    // Squares of a Sorted Array\n    public int[] sortedSquares(int[] nums) {\n        int[] result = new int[nums.length];\n        int left = 0, right = nums.length - 1;\n        int index = nums.length - 1; // Fill from the end\n\n        while (left <= right) {\n            int leftSquare = nums[left] * nums[left];\n            int rightSquare = nums[right] * nums[right];\n\n            if (leftSquare > rightSquare) {\n                result[index] = leftSquare;\n                left++;\n            } else {\n                result[index] = rightSquare;\n                right--;\n            }\n            index--;\n        }\n\n        return result;\n    }\n\n    // Sort Colors (Dutch National Flag)\n    public void sortColors(int[] nums) {\n        int low = 0, mid = 0, high = nums.length - 1;\n\n        while (mid <= high) {\n            if (nums[mid] == 0) {\n                swap(nums, low, mid);\n                low++;\n                mid++;\n            } else if (nums[mid] == 1) {\n                mid++;\n            } else { // nums[mid] == 2\n                swap(nums, mid, high);\n                high--;\n                // Don\'t increment mid as we need to check swapped element\n            }\n        }\n    }\n\n    private void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n\n    // Next Permutation\n    public void nextPermutation(int[] nums) {\n        int i = nums.length - 2;\n\n        // Find first decreasing element from right\n        while (i >= 0 && nums[i] >= nums[i + 1]) {\n            i--;\n        }\n\n        if (i >= 0) {\n            int j = nums.length - 1;\n            // Find element just larger than nums[i]\n            while (nums[j] <= nums[i]) {\n                j--;\n            }\n            swap(nums, i, j);\n        }\n\n        // Reverse the suffix\n        reverse(nums, i + 1, nums.length - 1);\n    }\n\n    private void reverse(int[] nums, int start, int end) {\n        while (start < end) {\n            swap(nums, start, end);\n            start++;\n            end--;\n        }\n    }\n\n    // Minimum Window Substring\n    public String minWindow(String s, String t) {\n        Map<Character, Integer> targetCount = new HashMap<>();\n        for (char c : t.toCharArray()) {\n            targetCount.put(c, targetCount.getOrDefault(c, 0) + 1);\n        }\n\n        Map<Character, Integer> windowCount = new HashMap<>();\n        int left = 0, minLength = Integer.MAX_VALUE, minStart = 0;\n        int formed = 0, required = targetCount.size();\n\n        for (int right = 0; right < s.length(); right++) {\n            char c = s.charAt(right);\n            windowCount.put(c, windowCount.getOrDefault(c, 0) + 1);\n\n            if (targetCount.containsKey(c) &&\n                windowCount.get(c).intValue() == targetCount.get(c).intValue()) {\n                formed++;\n            }\n\n            // Shrink window while valid\n            while (left <= right && formed == required) {\n                if (right - left + 1 < minLength) {\n                    minLength = right - left + 1;\n                    minStart = left;\n                }\n\n                char leftChar = s.charAt(left);\n                windowCount.put(leftChar, windowCount.get(leftChar) - 1);\n                if (targetCount.containsKey(leftChar) &&\n                    windowCount.get(leftChar) < targetCount.get(leftChar)) {\n                    formed--;\n                }\n                left++;\n            }\n        }\n\n        return minLength == Integer.MAX_VALUE ? "" : s.substring(minStart, minStart + minLength);\n    }\n\n    // 3Sum Smaller\n    public int threeSumSmaller(int[] nums, int target) {\n        Arrays.sort(nums);\n        int count = 0;\n\n        for (int i = 0; i < nums.length - 2; i++) {\n            int left = i + 1, right = nums.length - 1;\n\n            while (left < right) {\n                int sum = nums[i] + nums[left] + nums[right];\n\n                if (sum < target) {\n                    // All pairs between left and right are valid\n                    count += right - left;\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n\n        return count;\n    }\n\n    // Boats to Save People\n    public int numRescueBoats(int[] people, int limit) {\n        Arrays.sort(people);\n        int left = 0, right = people.length - 1;\n        int boats = 0;\n\n        while (left <= right) {\n            if (left == right) {\n                boats++;\n                break;\n            }\n\n            if (people[left] + people[right] <= limit) {\n                left++; // Both people can go\n            }\n            right--; // Heavier person always goes\n            boats++;\n        }\n\n        return boats;\n    }\n\n    // Partition Labels\n    public List<Integer> partitionLabels(String s) {\n        Map<Character, Integer> lastIndex = new HashMap<>();\n\n        // Record last occurrence of each character\n        for (int i = 0; i < s.length(); i++) {\n            lastIndex.put(s.charAt(i), i);\n        }\n\n        List<Integer> result = new ArrayList<>();\n        int start = 0, end = 0;\n\n        for (int i = 0; i < s.length(); i++) {\n            end = Math.max(end, lastIndex.get(s.charAt(i)));\n\n            if (i == end) {\n                result.add(end - start + 1);\n                start = end + 1;\n            }\n        }\n\n        return result;\n    }\n}\n'})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"pattern-2-same-direction-pointers",children:"Pattern 2: Same Direction Pointers"}),"\n",(0,i.jsx)(t.h3,{id:"21-array-modification-problems",children:"2.1 Array Modification Problems"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-java",children:"// Same direction pointers for in-place array modifications\npublic class SameDirectionPointers {\n\n    // Remove Element\n    public int removeElement(int[] nums, int val) {\n        int slow = 0; // Position for next valid element\n\n        for (int fast = 0; fast < nums.length; fast++) {\n            if (nums[fast] != val) {\n                nums[slow] = nums[fast];\n                slow++;\n            }\n        }\n\n        return slow;\n    }\n\n    // Remove Duplicates from Sorted Array\n    public int removeDuplicates(int[] nums) {\n        if (nums.length == 0) return 0;\n\n        int slow = 1; // Start from second position\n\n        for (int fast = 1; fast < nums.length; fast++) {\n            if (nums[fast] != nums[fast - 1]) {\n                nums[slow] = nums[fast];\n                slow++;\n            }\n        }\n\n        return slow;\n    }\n\n    // Remove Duplicates II (allow at most 2 duplicates)\n    public int removeDuplicates2(int[] nums) {\n        if (nums.length <= 2) return nums.length;\n\n        int slow = 2; // Start from third position\n\n        for (int fast = 2; fast < nums.length; fast++) {\n            if (nums[fast] != nums[slow - 2]) {\n                nums[slow] = nums[fast];\n                slow++;\n            }\n        }\n\n        return slow;\n    }\n\n    // Move Zeroes\n    public void moveZeroes(int[] nums) {\n        int slow = 0; // Position for next non-zero element\n\n        // Move all non-zero elements to front\n        for (int fast = 0; fast < nums.length; fast++) {\n            if (nums[fast] != 0) {\n                nums[slow] = nums[fast];\n                slow++;\n            }\n        }\n\n        // Fill remaining positions with zeros\n        while (slow < nums.length) {\n            nums[slow] = 0;\n            slow++;\n        }\n    }\n\n    // Move Zeroes (optimized with swapping)\n    public void moveZeroesOptimized(int[] nums) {\n        int slow = 0;\n\n        for (int fast = 0; fast < nums.length; fast++) {\n            if (nums[fast] != 0) {\n                if (slow != fast) { // Avoid unnecessary swaps\n                    int temp = nums[slow];\n                    nums[slow] = nums[fast];\n                    nums[fast] = temp;\n                }\n                slow++;\n            }\n        }\n    }\n\n    // Sort Array by Parity\n    public int[] sortArrayByParity(int[] nums) {\n        int slow = 0; // Position for next even number\n\n        for (int fast = 0; fast < nums.length; fast++) {\n            if (nums[fast] % 2 == 0) { // Even number\n                int temp = nums[slow];\n                nums[slow] = nums[fast];\n                nums[fast] = temp;\n                slow++;\n            }\n        }\n\n        return nums;\n    }\n\n    // Sort Array by Parity II\n    public int[] sortArrayByParityII(int[] nums) {\n        int evenIndex = 0, oddIndex = 1;\n        int[] result = new int[nums.length];\n\n        for (int num : nums) {\n            if (num % 2 == 0) {\n                result[evenIndex] = num;\n                evenIndex += 2;\n            } else {\n                result[oddIndex] = num;\n                oddIndex += 2;\n            }\n        }\n\n        return result;\n    }\n\n    // Backspace String Compare\n    public boolean backspaceCompare(String s, String t) {\n        return processString(s).equals(processString(t));\n    }\n\n    private String processString(String str) {\n        StringBuilder sb = new StringBuilder();\n\n        for (char c : str.toCharArray()) {\n            if (c == '#') {\n                if (sb.length() > 0) {\n                    sb.deleteCharAt(sb.length() - 1);\n                }\n            } else {\n                sb.append(c);\n            }\n        }\n\n        return sb.toString();\n    }\n\n    // Backspace String Compare (optimized with two pointers)\n    public boolean backspaceCompareOptimized(String s, String t) {\n        int i = s.length() - 1;\n        int j = t.length() - 1;\n\n        while (i >= 0 || j >= 0) {\n            i = getNextValidIndex(s, i);\n            j = getNextValidIndex(t, j);\n\n            if (i < 0 && j < 0) return true;\n            if (i < 0 || j < 0) return false;\n            if (s.charAt(i) != t.charAt(j)) return false;\n\n            i--;\n            j--;\n        }\n\n        return true;\n    }\n\n    private int getNextValidIndex(String str, int index) {\n        int skip = 0;\n\n        while (index >= 0) {\n            if (str.charAt(index) == '#') {\n                skip++;\n            } else if (skip > 0) {\n                skip--;\n            } else {\n                break;\n            }\n            index--;\n        }\n\n        return index;\n    }\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"22-advanced-same-direction-problems",children:"2.2 Advanced Same Direction Problems"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-java",children:"// Advanced same direction pointer problems\npublic class AdvancedSameDirection {\n\n    // Shortest Unsorted Continuous Subarray\n    public int findUnsortedSubarray(int[] nums) {\n        int n = nums.length;\n        int left = -1, right = -1;\n        int max = Integer.MIN_VALUE, min = Integer.MAX_VALUE;\n\n        // Find rightmost element that's out of place\n        for (int i = 0; i < n; i++) {\n            if (nums[i] >= max) {\n                max = nums[i];\n            } else {\n                right = i;\n            }\n        }\n\n        // Find leftmost element that's out of place\n        for (int i = n - 1; i >= 0; i--) {\n            if (nums[i] <= min) {\n                min = nums[i];\n            } else {\n                left = i;\n            }\n        }\n\n        return left == -1 ? 0 : right - left + 1;\n    }\n\n    // Merge Sorted Array\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        int i = m - 1, j = n - 1, k = m + n - 1;\n\n        // Merge from the end to avoid overwriting\n        while (i >= 0 && j >= 0) {\n            if (nums1[i] > nums2[j]) {\n                nums1[k] = nums1[i];\n                i--;\n            } else {\n                nums1[k] = nums2[j];\n                j--;\n            }\n            k--;\n        }\n\n        // Copy remaining elements from nums2\n        while (j >= 0) {\n            nums1[k] = nums2[j];\n            j--;\n            k--;\n        }\n    }\n\n    // Find All Duplicates in Array\n    public List<Integer> findDuplicates(int[] nums) {\n        List<Integer> result = new ArrayList<>();\n\n        // Use array indices as hash keys\n        for (int i = 0; i < nums.length; i++) {\n            int index = Math.abs(nums[i]) - 1;\n\n            if (nums[index] < 0) {\n                result.add(Math.abs(nums[i])); // Duplicate found\n            } else {\n                nums[index] = -nums[index]; // Mark as seen\n            }\n        }\n\n        return result;\n    }\n\n    // First Missing Positive\n    public int firstMissingPositive(int[] nums) {\n        int n = nums.length;\n\n        // Replace negative numbers and zeros with n+1\n        for (int i = 0; i < n; i++) {\n            if (nums[i] <= 0) {\n                nums[i] = n + 1;\n            }\n        }\n\n        // Mark presence of numbers\n        for (int i = 0; i < n; i++) {\n            int num = Math.abs(nums[i]);\n            if (num <= n) {\n                nums[num - 1] = -Math.abs(nums[num - 1]);\n            }\n        }\n\n        // Find first positive number\n        for (int i = 0; i < n; i++) {\n            if (nums[i] > 0) {\n                return i + 1;\n            }\n        }\n\n        return n + 1;\n    }\n\n    // Array Partition I\n    public int arrayPairSum(int[] nums) {\n        Arrays.sort(nums);\n        int sum = 0;\n\n        // Take every alternate element starting from first\n        for (int i = 0; i < nums.length; i += 2) {\n            sum += nums[i];\n        }\n\n        return sum;\n    }\n\n    // Max Consecutive Ones\n    public int findMaxConsecutiveOnes(int[] nums) {\n        int maxCount = 0, currentCount = 0;\n\n        for (int num : nums) {\n            if (num == 1) {\n                currentCount++;\n                maxCount = Math.max(maxCount, currentCount);\n            } else {\n                currentCount = 0;\n            }\n        }\n\n        return maxCount;\n    }\n\n    // Max Consecutive Ones II (with at most one flip)\n    public int findMaxConsecutiveOnesII(int[] nums) {\n        int maxLength = 0, zeroCount = 0;\n        int left = 0;\n\n        for (int right = 0; right < nums.length; right++) {\n            if (nums[right] == 0) {\n                zeroCount++;\n            }\n\n            // Shrink window if more than one zero\n            while (zeroCount > 1) {\n                if (nums[left] == 0) {\n                    zeroCount--;\n                }\n                left++;\n            }\n\n            maxLength = Math.max(maxLength, right - left + 1);\n        }\n\n        return maxLength;\n    }\n\n    // Minimum Size Subarray Sum\n    public int minSubArrayLen(int target, int[] nums) {\n        int left = 0, sum = 0;\n        int minLength = Integer.MAX_VALUE;\n\n        for (int right = 0; right < nums.length; right++) {\n            sum += nums[right];\n\n            while (sum >= target) {\n                minLength = Math.min(minLength, right - left + 1);\n                sum -= nums[left];\n                left++;\n            }\n        }\n\n        return minLength == Integer.MAX_VALUE ? 0 : minLength;\n    }\n}\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"pattern-3-fast-and-slow-pointers",children:"Pattern 3: Fast and Slow Pointers"}),"\n",(0,i.jsx)(t.h3,{id:"31-linked-list-cycle-detection",children:"3.1 Linked List Cycle Detection"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-java",children:"// Fast and slow pointers for linked list problems\npublic class FastSlowPointers {\n\n    static class ListNode {\n        int val;\n        ListNode next;\n\n        ListNode() {}\n        ListNode(int val) { this.val = val; }\n        ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n    }\n\n    // Linked List Cycle\n    public boolean hasCycle(ListNode head) {\n        if (head == null || head.next == null) return false;\n\n        ListNode slow = head;\n        ListNode fast = head;\n\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n\n            if (slow == fast) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    // Linked List Cycle II (find start of cycle)\n    public ListNode detectCycle(ListNode head) {\n        if (head == null || head.next == null) return null;\n\n        ListNode slow = head;\n        ListNode fast = head;\n\n        // Find meeting point\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n\n            if (slow == fast) {\n                break;\n            }\n        }\n\n        if (fast == null || fast.next == null) return null; // No cycle\n\n        // Find start of cycle\n        slow = head;\n        while (slow != fast) {\n            slow = slow.next;\n            fast = fast.next;\n        }\n\n        return slow;\n    }\n\n    // Middle of Linked List\n    public ListNode middleNode(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n\n        return slow;\n    }\n\n    // Palindrome Linked List\n    public boolean isPalindrome(ListNode head) {\n        if (head == null || head.next == null) return true;\n\n        // Find middle\n        ListNode slow = head;\n        ListNode fast = head;\n\n        while (fast.next != null && fast.next.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n\n        // Reverse second half\n        ListNode secondHalf = reverseList(slow.next);\n\n        // Compare both halves\n        ListNode firstHalf = head;\n        while (secondHalf != null) {\n            if (firstHalf.val != secondHalf.val) {\n                return false;\n            }\n            firstHalf = firstHalf.next;\n            secondHalf = secondHalf.next;\n        }\n\n        return true;\n    }\n\n    private ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode current = head;\n\n        while (current != null) {\n            ListNode next = current.next;\n            current.next = prev;\n            prev = current;\n            current = next;\n        }\n\n        return prev;\n    }\n\n    // Remove Nth Node From End\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n\n        ListNode slow = dummy;\n        ListNode fast = dummy;\n\n        // Move fast pointer n+1 steps ahead\n        for (int i = 0; i <= n; i++) {\n            fast = fast.next;\n        }\n\n        // Move both pointers until fast reaches end\n        while (fast != null) {\n            slow = slow.next;\n            fast = fast.next;\n        }\n\n        // Remove nth node\n        slow.next = slow.next.next;\n\n        return dummy.next;\n    }\n\n    // Reorder List\n    public void reorderList(ListNode head) {\n        if (head == null || head.next == null) return;\n\n        // Find middle\n        ListNode slow = head;\n        ListNode fast = head;\n\n        while (fast.next != null && fast.next.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n\n        // Split and reverse second half\n        ListNode secondHalf = reverseList(slow.next);\n        slow.next = null;\n\n        // Merge two halves\n        ListNode first = head;\n        while (secondHalf != null) {\n            ListNode temp1 = first.next;\n            ListNode temp2 = secondHalf.next;\n\n            first.next = secondHalf;\n            secondHalf.next = temp1;\n\n            first = temp1;\n            secondHalf = temp2;\n        }\n    }\n\n    // Intersection of Two Linked Lists\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null) return null;\n\n        ListNode ptrA = headA;\n        ListNode ptrB = headB;\n\n        // When one pointer reaches end, redirect to other list's head\n        while (ptrA != ptrB) {\n            ptrA = (ptrA == null) ? headB : ptrA.next;\n            ptrB = (ptrB == null) ? headA : ptrB.next;\n        }\n\n        return ptrA; // Either intersection point or null\n    }\n\n    // Happy Number (cycle detection in numbers)\n    public boolean isHappy(int n) {\n        int slow = n;\n        int fast = n;\n\n        do {\n            slow = getNext(slow);\n            fast = getNext(getNext(fast));\n        } while (slow != fast);\n\n        return slow == 1;\n    }\n\n    private int getNext(int n) {\n        int totalSum = 0;\n        while (n > 0) {\n            int digit = n % 10;\n            totalSum += digit * digit;\n            n /= 10;\n        }\n        return totalSum;\n    }\n\n    // Find Duplicate Number (Floyd's Algorithm)\n    public int findDuplicate(int[] nums) {\n        // Phase 1: Find intersection point\n        int slow = nums[^20_0];\n        int fast = nums[^20_0];\n\n        do {\n            slow = nums[slow];\n            fast = nums[nums[fast]];\n        } while (slow != fast);\n\n        // Phase 2: Find entrance to cycle\n        slow = nums[^20_0];\n        while (slow != fast) {\n            slow = nums[slow];\n            fast = nums[fast];\n        }\n\n        return slow;\n    }\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"32-advanced-fast-and-slow-pointer-problems",children:"3.2 Advanced Fast and Slow Pointer Problems"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-java",children:"// Advanced fast and slow pointer applications\npublic class AdvancedFastSlowPointers {\n\n    // Circular Array Loop\n    public boolean circularArrayLoop(int[] nums) {\n        int n = nums.length;\n\n        for (int i = 0; i < n; i++) {\n            if (nums[i] == 0) continue;\n\n            int slow = i, fast = i;\n            boolean isForward = nums[i] > 0;\n\n            // Check for cycle using Floyd's algorithm\n            do {\n                slow = getNextIndex(nums, slow, isForward);\n                if (slow == -1) break;\n\n                fast = getNextIndex(nums, fast, isForward);\n                if (fast == -1) break;\n\n                fast = getNextIndex(nums, fast, isForward);\n                if (fast == -1) break;\n\n            } while (slow != fast);\n\n            if (slow != -1 && slow == fast) {\n                return true;\n            }\n\n            // Mark visited elements as 0\n            int curr = i;\n            while (nums[curr] != 0 && ((nums[curr] > 0) == isForward)) {\n                int next = getNextIndex(nums, curr, isForward);\n                nums[curr] = 0;\n                curr = next;\n            }\n        }\n\n        return false;\n    }\n\n    private int getNextIndex(int[] nums, int curr, boolean isForward) {\n        boolean direction = nums[curr] > 0;\n\n        if (direction != isForward) return -1; // Direction change\n\n        int next = (curr + nums[curr]) % nums.length;\n        if (next < 0) next += nums.length;\n\n        if (next == curr) return -1; // Single element loop\n\n        return next;\n    }\n\n    // Rotate Array\n    public void rotate(int[] nums, int k) {\n        k = k % nums.length;\n        if (k == 0) return;\n\n        // Use cycle detection approach\n        int count = 0;\n\n        for (int start = 0; count < nums.length; start++) {\n            int current = start;\n            int prev = nums[start];\n\n            do {\n                int next = (current + k) % nums.length;\n                int temp = nums[next];\n                nums[next] = prev;\n                prev = temp;\n                current = next;\n                count++;\n            } while (start != current);\n        }\n    }\n\n    // Split Linked List in Parts\n    public ListNode[] splitListToParts(ListNode head, int k) {\n        // Count total length\n        int length = 0;\n        ListNode curr = head;\n        while (curr != null) {\n            length++;\n            curr = curr.next;\n        }\n\n        int partSize = length / k;\n        int extraParts = length % k;\n\n        ListNode[] result = new ListNode[k];\n        curr = head;\n\n        for (int i = 0; i < k && curr != null; i++) {\n            result[i] = curr;\n            int currentPartSize = partSize + (i < extraParts ? 1 : 0);\n\n            for (int j = 1; j < currentPartSize; j++) {\n                curr = curr.next;\n            }\n\n            ListNode next = curr.next;\n            curr.next = null;\n            curr = next;\n        }\n\n        return result;\n    }\n\n    // Swap Nodes in Pairs\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) return head;\n\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode prev = dummy;\n\n        while (prev.next != null && prev.next.next != null) {\n            ListNode first = prev.next;\n            ListNode second = prev.next.next;\n\n            // Swap\n            prev.next = second;\n            first.next = second.next;\n            second.next = first;\n\n            prev = first;\n        }\n\n        return dummy.next;\n    }\n\n    // Odd Even Linked List\n    public ListNode oddEvenList(ListNode head) {\n        if (head == null || head.next == null) return head;\n\n        ListNode odd = head;\n        ListNode even = head.next;\n        ListNode evenHead = even;\n\n        while (even != null && even.next != null) {\n            odd.next = even.next;\n            odd = odd.next;\n            even.next = odd.next;\n            even = even.next;\n        }\n\n        odd.next = evenHead;\n        return head;\n    }\n\n    // Design Linked List\n    public static class MyLinkedList {\n        private ListNode head;\n        private int size;\n\n        public MyLinkedList() {\n            head = null;\n            size = 0;\n        }\n\n        public int get(int index) {\n            if (index < 0 || index >= size) return -1;\n\n            ListNode curr = head;\n            for (int i = 0; i < index; i++) {\n                curr = curr.next;\n            }\n            return curr.val;\n        }\n\n        public void addAtHead(int val) {\n            ListNode newNode = new ListNode(val);\n            newNode.next = head;\n            head = newNode;\n            size++;\n        }\n\n        public void addAtTail(int val) {\n            if (head == null) {\n                addAtHead(val);\n                return;\n            }\n\n            ListNode curr = head;\n            while (curr.next != null) {\n                curr = curr.next;\n            }\n            curr.next = new ListNode(val);\n            size++;\n        }\n\n        public void addAtIndex(int index, int val) {\n            if (index < 0 || index > size) return;\n\n            if (index == 0) {\n                addAtHead(val);\n                return;\n            }\n\n            ListNode curr = head;\n            for (int i = 0; i < index - 1; i++) {\n                curr = curr.next;\n            }\n\n            ListNode newNode = new ListNode(val);\n            newNode.next = curr.next;\n            curr.next = newNode;\n            size++;\n        }\n\n        public void deleteAtIndex(int index) {\n            if (index < 0 || index >= size) return;\n\n            if (index == 0) {\n                head = head.next;\n                size--;\n                return;\n            }\n\n            ListNode curr = head;\n            for (int i = 0; i < index - 1; i++) {\n                curr = curr.next;\n            }\n\n            curr.next = curr.next.next;\n            size--;\n        }\n    }\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"two-pointers-guidelines",children:"Two Pointers Guidelines"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-java",children:'// 1. Problem identification\npublic class TwoPointersBestPractices {\n\n    // Identify when to use two pointers\n    public boolean shouldUseTwoPointers(String problem) {\n        String[] indicators = {\n            "sorted array", "palindrome", "pair", "triplet",\n            "remove duplicates", "cycle", "middle",\n            "merge", "partition", "in-place"\n        };\n\n        String lowerProblem = problem.toLowerCase();\n        return Arrays.stream(indicators).anyMatch(lowerProblem::contains);\n    }\n\n    // Choose the right approach\n    public String selectApproach(boolean sorted, boolean inPlace,\n                               boolean cycleDetection, boolean merging) {\n        if (cycleDetection) return "Fast and Slow Pointers";\n        if (sorted && !inPlace) return "Opposite Direction";\n        if (inPlace) return "Same Direction";\n        if (merging) return "Multiple Arrays Two Pointers";\n        return "Custom Approach";\n    }\n\n    // Common edge cases to handle\n    public void handleEdgeCases() {\n        // 1. Empty arrays or null inputs\n        // 2. Single element arrays\n        // 3. All elements identical\n        // 4. Already sorted/processed arrays\n        // 5. Integer overflow for sum problems\n        // 6. Pointer boundary conditions\n    }\n\n    // Debug helper\n    public void debugTwoPointers(int[] arr, int left, int right, String step) {\n        System.out.printf("%s: left=%d, right=%d, values=[%d, %d]%n",\n                         step, left, right,\n                         left < arr.length ? arr[left] : -1,\n                         right < arr.length ? arr[right] : -1);\n    }\n}\n'})}),"\n",(0,i.jsx)(t.h2,{id:"pattern-4-two-pointers-for-sorting",children:"Pattern 4: Two Pointers for Sorting"}),"\n",(0,i.jsx)(t.h3,{id:"41-partitioning-and-sorting-problems",children:"4.1 Partitioning and Sorting Problems"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-java",children:"// Two pointers for sorting and partitioning problems\npublic class TwoPointersSorting {\n\n    // Quick Sort Partition\n    public int partition(int[] nums, int low, int high) {\n        int pivot = nums[high];\n        int i = low - 1; // Pointer for smaller elements\n\n        for (int j = low; j < high; j++) {\n            if (nums[j] <= pivot) {\n                i++;\n                swap(nums, i, j);\n            }\n        }\n\n        swap(nums, i + 1, high);\n        return i + 1;\n    }\n\n    // Dutch National Flag (3-way partitioning)\n    public void sortColors(int[] nums) {\n        int low = 0, mid = 0, high = nums.length - 1;\n\n        while (mid <= high) {\n            if (nums[mid] == 0) {\n                swap(nums, low, mid);\n                low++;\n                mid++;\n            } else if (nums[mid] == 1) {\n                mid++;\n            } else { // nums[mid] == 2\n                swap(nums, mid, high);\n                high--;\n                // Don't increment mid as we need to check swapped element\n            }\n        }\n    }\n\n    // Wiggle Sort\n    public void wiggleSort(int[] nums) {\n        for (int i = 1; i < nums.length; i++) {\n            if ((i % 2 == 1 && nums[i] < nums[i - 1]) ||\n                (i % 2 == 0 && nums[i] > nums[i - 1])) {\n                swap(nums, i, i - 1);\n            }\n        }\n    }\n\n    // Pancake Sorting\n    public List<Integer> pancakeSort(int[] arr) {\n        List<Integer> result = new ArrayList<>();\n\n        for (int targetSize = arr.length; targetSize > 1; targetSize--) {\n            // Find index of maximum element in first targetSize elements\n            int maxIndex = 0;\n            for (int i = 1; i < targetSize; i++) {\n                if (arr[i] > arr[maxIndex]) {\n                    maxIndex = i;\n                }\n            }\n\n            if (maxIndex != targetSize - 1) {\n                // Flip to bring max to front (if not already there)\n                if (maxIndex != 0) {\n                    flip(arr, maxIndex);\n                    result.add(maxIndex + 1);\n                }\n\n                // Flip to bring max to its correct position\n                flip(arr, targetSize - 1);\n                result.add(targetSize);\n            }\n        }\n\n        return result;\n    }\n\n    private void flip(int[] arr, int k) {\n        int left = 0, right = k;\n        while (left < right) {\n            swap(arr, left, right);\n            left++;\n            right--;\n        }\n    }\n\n    // Sort Array by Parity\n    public int[] sortArrayByParity(int[] nums) {\n        int left = 0, right = nums.length - 1;\n\n        while (left < right) {\n            if (nums[left] % 2 == 0) {\n                left++;\n            } else if (nums[right] % 2 == 1) {\n                right--;\n            } else {\n                swap(nums, left, right);\n                left++;\n                right--;\n            }\n        }\n\n        return nums;\n    }\n\n    // Kth Largest Element (Quick Select)\n    public int findKthLargest(int[] nums, int k) {\n        return quickSelect(nums, 0, nums.length - 1, nums.length - k);\n    }\n\n    private int quickSelect(int[] nums, int left, int right, int k) {\n        if (left == right) return nums[left];\n\n        int pivotIndex = partition(nums, left, right);\n\n        if (pivotIndex == k) {\n            return nums[pivotIndex];\n        } else if (pivotIndex < k) {\n            return quickSelect(nums, pivotIndex + 1, right, k);\n        } else {\n            return quickSelect(nums, left, pivotIndex - 1, k);\n        }\n    }\n\n    // Top K Frequent Elements\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> count = new HashMap<>();\n        for (int num : nums) {\n            count.put(num, count.getOrDefault(num, 0) + 1);\n        }\n\n        int[] unique = new int[count.size()];\n        int i = 0;\n        for (int num : count.keySet()) {\n            unique[i++] = num;\n        }\n\n        quickSelectByFreq(unique, 0, unique.length - 1, unique.length - k, count);\n\n        return Arrays.copyOfRange(unique, unique.length - k, unique.length);\n    }\n\n    private void quickSelectByFreq(int[] nums, int left, int right, int k,\n                                   Map<Integer, Integer> count) {\n        if (left >= right) return;\n\n        int pivotIndex = partitionByFreq(nums, left, right, count);\n\n        if (pivotIndex == k) {\n            return;\n        } else if (pivotIndex < k) {\n            quickSelectByFreq(nums, pivotIndex + 1, right, k, count);\n        } else {\n            quickSelectByFreq(nums, left, pivotIndex - 1, k, count);\n        }\n    }\n\n    private int partitionByFreq(int[] nums, int left, int right, Map<Integer, Integer> count) {\n        int pivot = count.get(nums[right]);\n        int i = left;\n\n        for (int j = left; j < right; j++) {\n            if (count.get(nums[j]) <= pivot) {\n                swap(nums, i, j);\n                i++;\n            }\n        }\n\n        swap(nums, i, right);\n        return i;\n    }\n\n    private void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"42-advanced-sorting-applications",children:"4.2 Advanced Sorting Applications"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-java",children:"// Advanced sorting applications with two pointers\npublic class AdvancedSortingTwoPointers {\n\n    // Meeting Rooms II\n    public int minMeetingRooms(int[][] intervals) {\n        if (intervals.length == 0) return 0;\n\n        int[] starts = new int[intervals.length];\n        int[] ends = new int[intervals.length];\n\n        for (int i = 0; i < intervals.length; i++) {\n            starts[i] = intervals[i][0];\n            ends[i] = intervals[i][1];\n        }\n\n        Arrays.sort(starts);\n        Arrays.sort(ends);\n\n        int rooms = 0, endPtr = 0;\n\n        for (int start : starts) {\n            if (start >= ends[endPtr]) {\n                endPtr++;\n            } else {\n                rooms++;\n            }\n        }\n\n        return rooms;\n    }\n\n    // Minimum Number of Arrows to Burst Balloons\n    public int findMinArrowShots(int[][] points) {\n        if (points.length == 0) return 0;\n\n        // Sort by end point\n        Arrays.sort(points, (a, b) -> Integer.compare(a[1], b[1]));\n\n        int arrows = 1;\n        int end = points[0][1];\n\n        for (int i = 1; i < points.length; i++) {\n            if (points[i][0] > end) {\n                arrows++;\n                end = points[i][1];\n            }\n        }\n\n        return arrows;\n    }\n\n    // Non-overlapping Intervals\n    public int eraseOverlapIntervals(int[][] intervals) {\n        if (intervals.length == 0) return 0;\n\n        Arrays.sort(intervals, (a, b) -> Integer.compare(a[1], b[1]));\n\n        int count = 1;\n        int end = intervals[0][1];\n\n        for (int i = 1; i < intervals.length; i++) {\n            if (intervals[i][0] >= end) {\n                count++;\n                end = intervals[i][1];\n            }\n        }\n\n        return intervals.length - count;\n    }\n\n    // Insert Interval\n    public int[][] insert(int[][] intervals, int[] newInterval) {\n        List<int[]> result = new ArrayList<>();\n        int i = 0;\n\n        // Add all intervals before newInterval\n        while (i < intervals.length && intervals[i][1] < newInterval[0]) {\n            result.add(intervals[i]);\n            i++;\n        }\n\n        // Merge overlapping intervals\n        while (i < intervals.length && intervals[i][0] <= newInterval[1]) {\n            newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\n            newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\n            i++;\n        }\n        result.add(newInterval);\n\n        // Add remaining intervals\n        while (i < intervals.length) {\n            result.add(intervals[i]);\n            i++;\n        }\n\n        return result.toArray(new int[result.size()][]);\n    }\n\n    // Merge Intervals\n    public int[][] merge(int[][] intervals) {\n        if (intervals.length <= 1) return intervals;\n\n        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));\n\n        List<int[]> result = new ArrayList<>();\n        int[] current = intervals[0];\n\n        for (int i = 1; i < intervals.length; i++) {\n            if (current[1] >= intervals[i][0]) {\n                // Merge intervals\n                current[1] = Math.max(current[1], intervals[i][1]);\n            } else {\n                result.add(current);\n                current = intervals[i];\n            }\n        }\n\n        result.add(current);\n        return result.toArray(new int[result.size()][]);\n    }\n\n    // Car Pooling\n    public boolean carPooling(int[][] trips, int capacity) {\n        // Create events for passenger changes\n        List<int[]> events = new ArrayList<>();\n\n        for (int[] trip : trips) {\n            events.add(new int[]{trip[1], trip[0]}); // start, +passengers\n            events.add(new int[]{trip[2], -trip[0]}); // end, -passengers\n        }\n\n        // Sort by location\n        events.sort((a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);\n\n        int passengers = 0;\n        for (int[] event : events) {\n            passengers += event[1];\n            if (passengers > capacity) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    // Advantage Shuffle (Greedy Two Pointers)\n    public int[] advantageCount(int[] nums1, int[] nums2) {\n        int n = nums1.length;\n        Integer[] idx = new Integer[n];\n        for (int i = 0; i < n; i++) idx[i] = i;\n\n        Arrays.sort(nums1);\n        Arrays.sort(idx, (i, j) -> nums2[i] - nums2[j]);\n\n        int[] result = new int[n];\n        int left = 0, right = n - 1;\n\n        for (int num : nums1) {\n            if (num > nums2[idx[left]]) {\n                result[idx[left++]] = num;\n            } else {\n                result[idx[right--]] = num;\n            }\n        }\n\n        return result;\n    }\n}\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"pattern-5-two-pointers-with-hashmap",children:"Pattern 5: Two Pointers with HashMap"}),"\n",(0,i.jsx)(t.h3,{id:"51-frequency-and-counting-problems",children:"5.1 Frequency and Counting Problems"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-java",children:'// Two pointers combined with HashMap for frequency tracking\npublic class TwoPointersHashMap {\n\n    // Longest Substring Without Repeating Characters\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> charIndex = new HashMap<>();\n        int left = 0, maxLength = 0;\n\n        for (int right = 0; right < s.length(); right++) {\n            char c = s.charAt(right);\n\n            if (charIndex.containsKey(c) && charIndex.get(c) >= left) {\n                left = charIndex.get(c) + 1;\n            }\n\n            charIndex.put(c, right);\n            maxLength = Math.max(maxLength, right - left + 1);\n        }\n\n        return maxLength;\n    }\n\n    // Longest Substring with At Most K Distinct Characters\n    public int lengthOfLongestSubstringKDistinct(String s, int k) {\n        if (k == 0) return 0;\n\n        Map<Character, Integer> charCount = new HashMap<>();\n        int left = 0, maxLength = 0;\n\n        for (int right = 0; right < s.length(); right++) {\n            char c = s.charAt(right);\n            charCount.put(c, charCount.getOrDefault(c, 0) + 1);\n\n            while (charCount.size() > k) {\n                char leftChar = s.charAt(left);\n                charCount.put(leftChar, charCount.get(leftChar) - 1);\n                if (charCount.get(leftChar) == 0) {\n                    charCount.remove(leftChar);\n                }\n                left++;\n            }\n\n            maxLength = Math.max(maxLength, right - left + 1);\n        }\n\n        return maxLength;\n    }\n\n    // Subarrays with K Different Integers\n    public int subarraysWithKDistinct(int[] nums, int k) {\n        return atMostK(nums, k) - atMostK(nums, k - 1);\n    }\n\n    private int atMostK(int[] nums, int k) {\n        Map<Integer, Integer> count = new HashMap<>();\n        int left = 0, result = 0;\n\n        for (int right = 0; right < nums.length; right++) {\n            count.put(nums[right], count.getOrDefault(nums[right], 0) + 1);\n\n            while (count.size() > k) {\n                count.put(nums[left], count.get(nums[left]) - 1);\n                if (count.get(nums[left]) == 0) {\n                    count.remove(nums[left]);\n                }\n                left++;\n            }\n\n            result += right - left + 1;\n        }\n\n        return result;\n    }\n\n    // Find All Anagrams in a String\n    public List<Integer> findAnagrams(String s, String p) {\n        List<Integer> result = new ArrayList<>();\n        if (s.length() < p.length()) return result;\n\n        Map<Character, Integer> pCount = new HashMap<>();\n        for (char c : p.toCharArray()) {\n            pCount.put(c, pCount.getOrDefault(c, 0) + 1);\n        }\n\n        Map<Character, Integer> windowCount = new HashMap<>();\n        int windowSize = p.length();\n\n        // Process first window\n        for (int i = 0; i < windowSize; i++) {\n            char c = s.charAt(i);\n            windowCount.put(c, windowCount.getOrDefault(c, 0) + 1);\n        }\n\n        if (windowCount.equals(pCount)) {\n            result.add(0);\n        }\n\n        // Slide the window\n        for (int i = windowSize; i < s.length(); i++) {\n            // Add new character\n            char newChar = s.charAt(i);\n            windowCount.put(newChar, windowCount.getOrDefault(newChar, 0) + 1);\n\n            // Remove old character\n            char oldChar = s.charAt(i - windowSize);\n            windowCount.put(oldChar, windowCount.get(oldChar) - 1);\n            if (windowCount.get(oldChar) == 0) {\n                windowCount.remove(oldChar);\n            }\n\n            if (windowCount.equals(pCount)) {\n                result.add(i - windowSize + 1);\n            }\n        }\n\n        return result;\n    }\n\n    // Permutation in String\n    public boolean checkInclusion(String s1, String s2) {\n        if (s1.length() > s2.length()) return false;\n\n        Map<Character, Integer> s1Count = new HashMap<>();\n        for (char c : s1.toCharArray()) {\n            s1Count.put(c, s1Count.getOrDefault(c, 0) + 1);\n        }\n\n        Map<Character, Integer> windowCount = new HashMap<>();\n        int windowSize = s1.length();\n\n        // Process first window\n        for (int i = 0; i < windowSize; i++) {\n            char c = s2.charAt(i);\n            windowCount.put(c, windowCount.getOrDefault(c, 0) + 1);\n        }\n\n        if (windowCount.equals(s1Count)) return true;\n\n        // Slide the window\n        for (int i = windowSize; i < s2.length(); i++) {\n            // Add new character\n            char newChar = s2.charAt(i);\n            windowCount.put(newChar, windowCount.getOrDefault(newChar, 0) + 1);\n\n            // Remove old character\n            char oldChar = s2.charAt(i - windowSize);\n            windowCount.put(oldChar, windowCount.get(oldChar) - 1);\n            if (windowCount.get(oldChar) == 0) {\n                windowCount.remove(oldChar);\n            }\n\n            if (windowCount.equals(s1Count)) return true;\n        }\n\n        return false;\n    }\n\n    // Minimum Window Substring\n    public String minWindow(String s, String t) {\n        Map<Character, Integer> targetCount = new HashMap<>();\n        for (char c : t.toCharArray()) {\n            targetCount.put(c, targetCount.getOrDefault(c, 0) + 1);\n        }\n\n        Map<Character, Integer> windowCount = new HashMap<>();\n        int left = 0, minLength = Integer.MAX_VALUE, minStart = 0;\n        int formed = 0, required = targetCount.size();\n\n        for (int right = 0; right < s.length(); right++) {\n            char c = s.charAt(right);\n            windowCount.put(c, windowCount.getOrDefault(c, 0) + 1);\n\n            if (targetCount.containsKey(c) &&\n                windowCount.get(c).intValue() == targetCount.get(c).intValue()) {\n                formed++;\n            }\n\n            while (left <= right && formed == required) {\n                if (right - left + 1 < minLength) {\n                    minLength = right - left + 1;\n                    minStart = left;\n                }\n\n                char leftChar = s.charAt(left);\n                windowCount.put(leftChar, windowCount.get(leftChar) - 1);\n                if (targetCount.containsKey(leftChar) &&\n                    windowCount.get(leftChar) < targetCount.get(leftChar)) {\n                    formed--;\n                }\n                left++;\n            }\n        }\n\n        return minLength == Integer.MAX_VALUE ? "" : s.substring(minStart, minStart + minLength);\n    }\n\n    // Fruit Into Baskets (At Most 2 Types)\n    public int totalFruit(int[] fruits) {\n        Map<Integer, Integer> fruitCount = new HashMap<>();\n        int left = 0, maxFruits = 0;\n\n        for (int right = 0; right < fruits.length; right++) {\n            fruitCount.put(fruits[right], fruitCount.getOrDefault(fruits[right], 0) + 1);\n\n            while (fruitCount.size() > 2) {\n                int leftFruit = fruits[left];\n                fruitCount.put(leftFruit, fruitCount.get(leftFruit) - 1);\n                if (fruitCount.get(leftFruit) == 0) {\n                    fruitCount.remove(leftFruit);\n                }\n                left++;\n            }\n\n            maxFruits = Math.max(maxFruits, right - left + 1);\n        }\n\n        return maxFruits;\n    }\n}\n'})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"pattern-6-multiple-arrays-two-pointers",children:"Pattern 6: Multiple Arrays Two Pointers"}),"\n",(0,i.jsx)(t.h3,{id:"61-merging-and-intersection-problems",children:"6.1 Merging and Intersection Problems"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-java",children:'// Two pointers for multiple arrays operations\npublic class MultipleArraysTwoPointers {\n\n    // Merge Two Sorted Arrays\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        int i = m - 1, j = n - 1, k = m + n - 1;\n\n        while (i >= 0 && j >= 0) {\n            if (nums1[i] > nums2[j]) {\n                nums1[k--] = nums1[i--];\n            } else {\n                nums1[k--] = nums2[j--];\n            }\n        }\n\n        while (j >= 0) {\n            nums1[k--] = nums2[j--];\n        }\n    }\n\n    // Intersection of Two Arrays\n    public int[] intersection(int[] nums1, int[] nums2) {\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n\n        Set<Integer> result = new HashSet<>();\n        int i = 0, j = 0;\n\n        while (i < nums1.length && j < nums2.length) {\n            if (nums1[i] == nums2[j]) {\n                result.add(nums1[i]);\n                i++;\n                j++;\n            } else if (nums1[i] < nums2[j]) {\n                i++;\n            } else {\n                j++;\n            }\n        }\n\n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n\n    // Intersection of Two Arrays II\n    public int[] intersect(int[] nums1, int[] nums2) {\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n\n        List<Integer> result = new ArrayList<>();\n        int i = 0, j = 0;\n\n        while (i < nums1.length && j < nums2.length) {\n            if (nums1[i] == nums2[j]) {\n                result.add(nums1[i]);\n                i++;\n                j++;\n            } else if (nums1[i] < nums2[j]) {\n                i++;\n            } else {\n                j++;\n            }\n        }\n\n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n\n    // Merge k Sorted Arrays\n    public int[] mergeKSortedArrays(int[][] arrays) {\n        PriorityQueue<ArrayElement> pq = new PriorityQueue<>((a, b) -> a.value - b.value);\n\n        // Initialize with first element from each array\n        for (int i = 0; i < arrays.length; i++) {\n            if (arrays[i].length > 0) {\n                pq.offer(new ArrayElement(arrays[i][0], i, 0));\n            }\n        }\n\n        List<Integer> result = new ArrayList<>();\n\n        while (!pq.isEmpty()) {\n            ArrayElement current = pq.poll();\n            result.add(current.value);\n\n            // Add next element from the same array\n            if (current.index + 1 < arrays[current.arrayId].length) {\n                pq.offer(new ArrayElement(\n                    arrays[current.arrayId][current.index + 1],\n                    current.arrayId,\n                    current.index + 1\n                ));\n            }\n        }\n\n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n\n    static class ArrayElement {\n        int value;\n        int arrayId;\n        int index;\n\n        ArrayElement(int value, int arrayId, int index) {\n            this.value = value;\n            this.arrayId = arrayId;\n            this.index = index;\n        }\n    }\n\n    // Find Median of Two Sorted Arrays\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        if (nums1.length > nums2.length) {\n            return findMedianSortedArrays(nums2, nums1);\n        }\n\n        int m = nums1.length, n = nums2.length;\n        int left = 0, right = m;\n\n        while (left <= right) {\n            int partition1 = (left + right) / 2;\n            int partition2 = (m + n + 1) / 2 - partition1;\n\n            int maxLeft1 = (partition1 == 0) ? Integer.MIN_VALUE : nums1[partition1 - 1];\n            int maxLeft2 = (partition2 == 0) ? Integer.MIN_VALUE : nums2[partition2 - 1];\n\n            int minRight1 = (partition1 == m) ? Integer.MAX_VALUE : nums1[partition1];\n            int minRight2 = (partition2 == n) ? Integer.MAX_VALUE : nums2[partition2];\n\n            if (maxLeft1 <= minRight2 && maxLeft2 <= minRight1) {\n                if ((m + n) % 2 == 0) {\n                    return (Math.max(maxLeft1, maxLeft2) + Math.min(minRight1, minRight2)) / 2.0;\n                } else {\n                    return Math.max(maxLeft1, maxLeft2);\n                }\n            } else if (maxLeft1 > minRight2) {\n                right = partition1 - 1;\n            } else {\n                left = partition1 + 1;\n            }\n        }\n\n        throw new IllegalArgumentException("Arrays are not sorted");\n    }\n\n    // Next Greater Element I\n    public int[] nextGreaterElement(int[] nums1, int[] nums2) {\n        Map<Integer, Integer> nextGreater = new HashMap<>();\n        Stack<Integer> stack = new Stack<>();\n\n        // Build next greater map for nums2\n        for (int num : nums2) {\n            while (!stack.isEmpty() && stack.peek() < num) {\n                nextGreater.put(stack.pop(), num);\n            }\n            stack.push(num);\n        }\n\n        // Find results for nums1\n        int[] result = new int[nums1.length];\n        for (int i = 0; i < nums1.length; i++) {\n            result[i] = nextGreater.getOrDefault(nums1[i], -1);\n        }\n\n        return result;\n    }\n\n    // Smallest Range Covering Elements from K Lists\n    public int[] smallestRange(List<List<Integer>> nums) {\n        PriorityQueue<Element> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        int max = Integer.MIN_VALUE;\n\n        // Initialize with first element from each list\n        for (int i = 0; i < nums.size(); i++) {\n            if (nums.get(i).size() > 0) {\n                int val = nums.get(i).get(0);\n                pq.offer(new Element(val, i, 0));\n                max = Math.max(max, val);\n            }\n        }\n\n        int rangeStart = 0, rangeEnd = Integer.MAX_VALUE;\n\n        while (pq.size() == nums.size()) {\n            Element current = pq.poll();\n\n            if (max - current.val < rangeEnd - rangeStart) {\n                rangeStart = current.val;\n                rangeEnd = max;\n            }\n\n            if (current.idx + 1 < nums.get(current.row).size()) {\n                int nextVal = nums.get(current.row).get(current.idx + 1);\n                pq.offer(new Element(nextVal, current.row, current.idx + 1));\n                max = Math.max(max, nextVal);\n            }\n        }\n\n        return new int[]{rangeStart, rangeEnd};\n    }\n\n    static class Element {\n        int val;\n        int row;\n        int idx;\n\n        Element(int val, int row, int idx) {\n            this.val = val;\n            this.row = row;\n            this.idx = idx;\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"pattern-7-linked-list-two-pointers",children:"Pattern 7: Linked List Two Pointers"}),"\n",(0,i.jsx)(t.h3,{id:"71-advanced-linked-list-operations",children:"7.1 Advanced Linked List Operations"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-java",children:"// Advanced linked list operations using two pointers\npublic class LinkedListTwoPointers {\n\n    static class ListNode {\n        int val;\n        ListNode next;\n        ListNode() {}\n        ListNode(int val) { this.val = val; }\n        ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n    }\n\n    // Merge Two Sorted Lists\n    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n        ListNode dummy = new ListNode(0);\n        ListNode current = dummy;\n\n        while (list1 != null && list2 != null) {\n            if (list1.val <= list2.val) {\n                current.next = list1;\n                list1 = list1.next;\n            } else {\n                current.next = list2;\n                list2 = list2.next;\n            }\n            current = current.next;\n        }\n\n        // Attach remaining nodes\n        current.next = (list1 != null) ? list1 : list2;\n\n        return dummy.next;\n    }\n\n    // Merge k Sorted Lists\n    public ListNode mergeKLists(ListNode[] lists) {\n        if (lists == null || lists.length == 0) return null;\n\n        while (lists.length > 1) {\n            List<ListNode> mergedLists = new ArrayList<>();\n\n            for (int i = 0; i < lists.length; i += 2) {\n                ListNode l1 = lists[i];\n                ListNode l2 = (i + 1 < lists.length) ? lists[i + 1] : null;\n                mergedLists.add(mergeTwoLists(l1, l2));\n            }\n\n            lists = mergedLists.toArray(new ListNode[0]);\n        }\n\n        return lists[0];\n    }\n\n    // Add Two Numbers\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode dummy = new ListNode(0);\n        ListNode current = dummy;\n        int carry = 0;\n\n        while (l1 != null || l2 != null || carry != 0) {\n            int sum = carry;\n\n            if (l1 != null) {\n                sum += l1.val;\n                l1 = l1.next;\n            }\n\n            if (l2 != null) {\n                sum += l2.val;\n                l2 = l2.next;\n            }\n\n            carry = sum / 10;\n            current.next = new ListNode(sum % 10);\n            current = current.next;\n        }\n\n        return dummy.next;\n    }\n\n    // Remove Duplicates from Sorted List II\n    public ListNode deleteDuplicates(ListNode head) {\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode prev = dummy;\n\n        while (head != null) {\n            if (head.next != null && head.val == head.next.val) {\n                // Skip all nodes with same value\n                while (head.next != null && head.val == head.next.val) {\n                    head = head.next;\n                }\n                prev.next = head.next;\n            } else {\n                prev = prev.next;\n            }\n            head = head.next;\n        }\n\n        return dummy.next;\n    }\n\n    // Partition List\n    public ListNode partition(ListNode head, int x) {\n        ListNode beforeHead = new ListNode(0);\n        ListNode afterHead = new ListNode(0);\n        ListNode before = beforeHead;\n        ListNode after = afterHead;\n\n        while (head != null) {\n            if (head.val < x) {\n                before.next = head;\n                before = before.next;\n            } else {\n                after.next = head;\n                after = after.next;\n            }\n            head = head.next;\n        }\n\n        after.next = null;\n        before.next = afterHead.next;\n\n        return beforeHead.next;\n    }\n\n    // Rotate List\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null || k == 0) return head;\n\n        // Find length and connect to form cycle\n        int length = 1;\n        ListNode tail = head;\n        while (tail.next != null) {\n            tail = tail.next;\n            length++;\n        }\n        tail.next = head;\n\n        // Find new tail (length - k % length - 1 steps from head)\n        k = k % length;\n        int stepsToNewTail = length - k;\n\n        ListNode newTail = head;\n        for (int i = 1; i < stepsToNewTail; i++) {\n            newTail = newTail.next;\n        }\n\n        ListNode newHead = newTail.next;\n        newTail.next = null;\n\n        return newHead;\n    }\n\n    // Copy List with Random Pointer\n    static class Node {\n        int val;\n        Node next;\n        Node random;\n\n        public Node(int val) {\n            this.val = val;\n            this.next = null;\n            this.random = null;\n        }\n    }\n\n    public Node copyRandomList(Node head) {\n        if (head == null) return null;\n\n        Map<Node, Node> map = new HashMap<>();\n\n        // First pass: create all nodes\n        Node curr = head;\n        while (curr != null) {\n            map.put(curr, new Node(curr.val));\n            curr = curr.next;\n        }\n\n        // Second pass: link next and random pointers\n        curr = head;\n        while (curr != null) {\n            map.get(curr).next = map.get(curr.next);\n            map.get(curr).random = map.get(curr.random);\n            curr = curr.next;\n        }\n\n        return map.get(head);\n    }\n\n    // Reverse Nodes in k-Group\n    public ListNode reverseKGroup(ListNode head, int k) {\n        // Check if there are at least k nodes\n        ListNode curr = head;\n        int count = 0;\n        while (curr != null && count < k) {\n            curr = curr.next;\n            count++;\n        }\n\n        if (count == k) {\n            // Reverse first k nodes\n            curr = reverseKGroup(curr, k);\n\n            while (count > 0) {\n                ListNode next = head.next;\n                head.next = curr;\n                curr = head;\n                head = next;\n                count--;\n            }\n            head = curr;\n        }\n\n        return head;\n    }\n}\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"pattern-8-string-manipulation-with-two-pointers",children:"Pattern 8: String Manipulation with Two Pointers"}),"\n",(0,i.jsx)(t.h3,{id:"81-string-processing-and-validation",children:"8.1 String Processing and Validation"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-java",children:"// String manipulation using two pointers\npublic class StringTwoPointers {\n\n    // Valid Palindrome II (at most one deletion)\n    public boolean validPalindrome(String s) {\n        int left = 0, right = s.length() - 1;\n\n        while (left < right) {\n            if (s.charAt(left) != s.charAt(right)) {\n                // Try deleting left character or right character\n                return isPalindrome(s, left + 1, right) || isPalindrome(s, left, right - 1);\n            }\n            left++;\n            right--;\n        }\n\n        return true;\n    }\n\n    private boolean isPalindrome(String s, int left, int right) {\n        while (left < right) {\n            if (s.charAt(left) != s.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        return true;\n    }\n\n    // Reverse Words in a String III\n    public String reverseWords(String s) {\n        char[] chars = s.toCharArray();\n        int left = 0;\n\n        for (int right = 0; right <= chars.length; right++) {\n            if (right == chars.length || chars[right] == ' ') {\n                reverse(chars, left, right - 1);\n                left = right + 1;\n            }\n        }\n\n        return new String(chars);\n    }\n\n    private void reverse(char[] chars, int left, int right) {\n        while (left < right) {\n            char temp = chars[left];\n            chars[left] = chars[right];\n            chars[right] = temp;\n            left++;\n            right--;\n        }\n    }\n\n    // Longest Palindromic Substring\n    public String longestPalindrome(String s) {\n        if (s == null || s.length() < 2) return s;\n\n        int start = 0, maxLength = 1;\n\n        for (int i = 0; i < s.length(); i++) {\n            // Check for odd length palindromes\n            int len1 = expandAroundCenter(s, i, i);\n            // Check for even length palindromes\n            int len2 = expandAroundCenter(s, i, i + 1);\n\n            int len = Math.max(len1, len2);\n            if (len > maxLength) {\n                maxLength = len;\n                start = i - (len - 1) / 2;\n            }\n        }\n\n        return s.substring(start, start + maxLength);\n    }\n\n    private int expandAroundCenter(String s, int left, int right) {\n        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\n            left--;\n            right++;\n        }\n        return right - left - 1;\n    }\n\n    // String Compression\n    public int compress(char[] chars) {\n        int write = 0, anchor = 0;\n\n        for (int read = 0; read <= chars.length; read++) {\n            if (read == chars.length || chars[read] != chars[anchor]) {\n                chars[write++] = chars[anchor];\n\n                if (read - anchor > 1) {\n                    for (char c : String.valueOf(read - anchor).toCharArray()) {\n                        chars[write++] = c;\n                    }\n                }\n                anchor = read;\n            }\n        }\n\n        return write;\n    }\n\n    // Remove Duplicate Letters\n    public String removeDuplicateLetters(String s) {\n        Map<Character, Integer> lastIndex = new HashMap<>();\n        Set<Character> inStack = new HashSet<>();\n        Stack<Character> stack = new Stack<>();\n\n        // Record last occurrence of each character\n        for (int i = 0; i < s.length(); i++) {\n            lastIndex.put(s.charAt(i), i);\n        }\n\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n\n            if (inStack.contains(c)) continue;\n\n            // Remove characters that are greater than current and appear later\n            while (!stack.isEmpty() && stack.peek() > c && lastIndex.get(stack.peek()) > i) {\n                inStack.remove(stack.pop());\n            }\n\n            stack.push(c);\n            inStack.add(c);\n        }\n\n        StringBuilder sb = new StringBuilder();\n        for (char c : stack) {\n            sb.append(c);\n        }\n\n        return sb.toString();\n    }\n\n    // Compare Version Numbers\n    public int compareVersion(String version1, String version2) {\n        int i = 0, j = 0;\n\n        while (i < version1.length() || j < version2.length()) {\n            int num1 = 0, num2 = 0;\n\n            // Extract next number from version1\n            while (i < version1.length() && version1.charAt(i) != '.') {\n                num1 = num1 * 10 + (version1.charAt(i) - '0');\n                i++;\n            }\n\n            // Extract next number from version2\n            while (j < version2.length() && version2.charAt(j) != '.') {\n                num2 = num2 * 10 + (version2.charAt(j) - '0');\n                j++;\n            }\n\n            if (num1 < num2) return -1;\n            if (num1 > num2) return 1;\n\n            i++; // Skip dot\n            j++; // Skip dot\n        }\n\n        return 0;\n    }\n\n    // One Edit Distance\n    public boolean isOneEditDistance(String s, String t) {\n        if (Math.abs(s.length() - t.length()) > 1) return false;\n        if (s.equals(t)) return false;\n\n        if (s.length() > t.length()) {\n            return isOneEditDistance(t, s);\n        }\n\n        // s.length() <= t.length()\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) != t.charAt(i)) {\n                if (s.length() == t.length()) {\n                    // Replace operation\n                    return s.substring(i + 1).equals(t.substring(i + 1));\n                } else {\n                    // Insert operation\n                    return s.substring(i).equals(t.substring(i + 1));\n                }\n            }\n        }\n\n        // All characters match, check if exactly one insertion needed\n        return t.length() - s.length() == 1;\n    }\n\n    // Shortest Way to Form String\n    public int shortestWay(String source, String target) {\n        Set<Character> sourceChars = new HashSet<>();\n        for (char c : source.toCharArray()) {\n            sourceChars.add(c);\n        }\n\n        int sourcePtr = 0, targetPtr = 0, count = 0;\n\n        while (targetPtr < target.length()) {\n            if (!sourceChars.contains(target.charAt(targetPtr))) {\n                return -1; // Impossible to form target\n            }\n\n            int oldTargetPtr = targetPtr;\n\n            while (sourcePtr < source.length() && targetPtr < target.length()) {\n                if (source.charAt(sourcePtr) == target.charAt(targetPtr)) {\n                    targetPtr++;\n                }\n                sourcePtr++;\n            }\n\n            if (oldTargetPtr == targetPtr) {\n                return -1; // No progress made\n            }\n\n            count++;\n            sourcePtr = 0; // Reset source pointer\n        }\n\n        return count;\n    }\n}\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"pattern-9-advanced-two-pointers-techniques",children:"Pattern 9: Advanced Two Pointers Techniques"}),"\n",(0,i.jsx)(t.h3,{id:"91-complex-algorithm-applications",children:"9.1 Complex Algorithm Applications"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-java",children:'// Advanced two pointers techniques for complex problems\npublic class AdvancedTwoPointersTechniques {\n\n    // Longest Mountain in Array\n    public int longestMountain(int[] arr) {\n        if (arr.length < 3) return 0;\n\n        int maxLength = 0;\n\n        for (int i = 1; i < arr.length - 1; i++) {\n            // Check if current position can be a peak\n            if (arr[i - 1] < arr[i] && arr[i] > arr[i + 1]) {\n                int left = i - 1, right = i + 1;\n\n                // Expand left\n                while (left > 0 && arr[left - 1] < arr[left]) {\n                    left--;\n                }\n\n                // Expand right\n                while (right < arr.length - 1 && arr[right] > arr[right + 1]) {\n                    right++;\n                }\n\n                maxLength = Math.max(maxLength, right - left + 1);\n            }\n        }\n\n        return maxLength;\n    }\n\n    // Minimum Operations to Reduce X to Zero\n    public int minOperations(int[] nums, int x) {\n        int target = Arrays.stream(nums).sum() - x;\n        if (target < 0) return -1;\n        if (target == 0) return nums.length;\n\n        // Find longest subarray with sum = target\n        Map<Integer, Integer> prefixSumIndex = new HashMap<>();\n        prefixSumIndex.put(0, -1);\n\n        int sum = 0, maxLength = -1;\n\n        for (int i = 0; i < nums.length; i++) {\n            sum += nums[i];\n\n            if (prefixSumIndex.containsKey(sum - target)) {\n                maxLength = Math.max(maxLength, i - prefixSumIndex.get(sum - target));\n            }\n\n            prefixSumIndex.put(sum, i);\n        }\n\n        return maxLength == -1 ? -1 : nums.length - maxLength;\n    }\n\n    // Minimum Window Subsequence\n    public String minWindow(String s1, String s2) {\n        int i = 0, j = 0;\n        int start = -1, minLength = Integer.MAX_VALUE;\n\n        while (i < s1.length()) {\n            if (s1.charAt(i) == s2.charAt(j)) {\n                j++;\n\n                if (j == s2.length()) {\n                    // Found complete subsequence, try to minimize\n                    int end = i;\n                    j--; // Move back to last character of s2\n\n                    while (j >= 0) {\n                        if (s1.charAt(i) == s2.charAt(j)) {\n                            j--;\n                        }\n                        i--;\n                    }\n\n                    // Update minimum window\n                    if (end - i < minLength) {\n                        minLength = end - i;\n                        start = i + 1;\n                    }\n\n                    j = 0; // Reset for next search\n                }\n            }\n            i++;\n        }\n\n        return start == -1 ? "" : s1.substring(start, start + minLength);\n    }\n\n    // Max Consecutive Ones III\n    public int longestOnes(int[] nums, int k) {\n        int left = 0, maxLength = 0, zeroCount = 0;\n\n        for (int right = 0; right < nums.length; right++) {\n            if (nums[right] == 0) {\n                zeroCount++;\n            }\n\n            while (zeroCount > k) {\n                if (nums[left] == 0) {\n                    zeroCount--;\n                }\n                left++;\n            }\n\n            maxLength = Math.max(maxLength, right - left + 1);\n        }\n\n        return maxLength;\n    }\n\n    // Subarrays with K Odd Numbers\n    public int numberOfSubarrays(int[] nums, int k) {\n        return atMostK(nums, k) - atMostK(nums, k - 1);\n    }\n\n    private int atMostK(int[] nums, int k) {\n        int left = 0, count = 0, result = 0;\n\n        for (int right = 0; right < nums.length; right++) {\n            if (nums[right] % 2 == 1) {\n                count++;\n            }\n\n            while (count > k) {\n                if (nums[left] % 2 == 1) {\n                    count--;\n                }\n                left++;\n            }\n\n            result += right - left + 1;\n        }\n\n        return result;\n    }\n\n    // Get Equal Substrings Within Budget\n    public int equalSubstring(String s, String t, int maxCost) {\n        int left = 0, currentCost = 0, maxLength = 0;\n\n        for (int right = 0; right < s.length(); right++) {\n            currentCost += Math.abs(s.charAt(right) - t.charAt(right));\n\n            while (currentCost > maxCost) {\n                currentCost -= Math.abs(s.charAt(left) - t.charAt(left));\n                left++;\n            }\n\n            maxLength = Math.max(maxLength, right - left + 1);\n        }\n\n        return maxLength;\n    }\n\n    // Replace the Substring for Balanced String\n    public int balancedString(String s) {\n        Map<Character, Integer> count = new HashMap<>();\n        for (char c : s.toCharArray()) {\n            count.put(c, count.getOrDefault(c, 0) + 1);\n        }\n\n        int n = s.length();\n        int target = n / 4;\n\n        // Check if already balanced\n        if (count.values().stream().allMatch(freq -> freq <= target)) {\n            return 0;\n        }\n\n        int left = 0, minLength = n;\n\n        for (int right = 0; right < n; right++) {\n            count.put(s.charAt(right), count.get(s.charAt(right)) - 1);\n\n            while (isValid(count, target)) {\n                minLength = Math.min(minLength, right - left + 1);\n                count.put(s.charAt(left), count.get(s.charAt(left)) + 1);\n                left++;\n            }\n        }\n\n        return minLength;\n    }\n\n    private boolean isValid(Map<Character, Integer> count, int target) {\n        return count.values().stream().allMatch(freq -> freq <= target);\n    }\n\n    // Number of Subsequences That Satisfy the Given Sum Condition\n    public int numSubseq(int[] nums, int target) {\n        Arrays.sort(nums);\n        int left = 0, right = nums.length - 1;\n        int count = 0;\n        int MOD = 1000000007;\n\n        // Precompute powers of 2\n        int[] pow = new int[nums.length];\n        pow[0] = 1;\n        for (int i = 1; i < nums.length; i++) {\n            pow[i] = (pow[i - 1] * 2) % MOD;\n        }\n\n        while (left <= right) {\n            if (nums[left] + nums[right] <= target) {\n                count = (count + pow[right - left]) % MOD;\n                left++;\n            } else {\n                right--;\n            }\n        }\n\n        return count;\n    }\n}\n'})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"pattern-10-matrix-and-2d-two-pointers",children:"Pattern 10: Matrix and 2D Two Pointers"}),"\n",(0,i.jsx)(t.h3,{id:"101-2d-array-problems",children:"10.1 2D Array Problems"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-java",children:'// Two pointers for 2D matrix problems\npublic class Matrix2DTwoPointers {\n\n    // Search in 2D Matrix\n    public boolean searchMatrix(int[][] matrix, int target) {\n        if (matrix.length == 0 || matrix[0].length == 0) return false;\n\n        int row = 0, col = matrix[0].length - 1;\n\n        while (row < matrix.length && col >= 0) {\n            if (matrix[row][col] == target) {\n                return true;\n            } else if (matrix[row][col] > target) {\n                col--;\n            } else {\n                row++;\n            }\n        }\n\n        return false;\n    }\n\n    // Search in 2D Matrix II\n    public boolean searchMatrixII(int[][] matrix, int target) {\n        if (matrix.length == 0 || matrix[0].length == 0) return false;\n\n        int row = 0, col = matrix[0].length - 1;\n\n        while (row < matrix.length && col >= 0) {\n            int current = matrix[row][col];\n\n            if (current == target) {\n                return true;\n            } else if (current > target) {\n                col--; // Move left\n            } else {\n                row++; // Move down\n            }\n        }\n\n        return false;\n    }\n\n    // Set Matrix Zeroes\n    public void setZeroes(int[][] matrix) {\n        int m = matrix.length, n = matrix[0].length;\n        boolean firstRowZero = false, firstColZero = false;\n\n        // Check if first row should be zero\n        for (int j = 0; j < n; j++) {\n            if (matrix[0][j] == 0) {\n                firstRowZero = true;\n                break;\n            }\n        }\n\n        // Check if first column should be zero\n        for (int i = 0; i < m; i++) {\n            if (matrix[i][0] == 0) {\n                firstColZero = true;\n                break;\n            }\n        }\n\n        // Use first row and column as markers\n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                if (matrix[i][j] == 0) {\n                    matrix[i][0] = 0;\n                    matrix[0][j] = 0;\n                }\n            }\n        }\n\n        // Set zeros based on markers\n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                if (matrix[i][0] == 0 || matrix[0][j] == 0) {\n                    matrix[i][j] = 0;\n                }\n            }\n        }\n\n        // Handle first row and column\n        if (firstRowZero) {\n            for (int j = 0; j < n; j++) {\n                matrix[0][j] = 0;\n            }\n        }\n\n        if (firstColZero) {\n            for (int i = 0; i < m; i++) {\n                matrix[i][0] = 0;\n            }\n        }\n    }\n\n    // Diagonal Traverse\n    public int[] findDiagonalOrder(int[][] mat) {\n        int m = mat.length, n = mat[0].length;\n        int[] result = new int[m * n];\n        int row = 0, col = 0;\n        boolean goingUp = true;\n\n        for (int i = 0; i < m * n; i++) {\n            result[i] = mat[row][col];\n\n            if (goingUp) {\n                if (col == n - 1) {\n                    row++;\n                    goingUp = false;\n                } else if (row == 0) {\n                    col++;\n                    goingUp = false;\n                } else {\n                    row--;\n                    col++;\n                }\n            } else {\n                if (row == m - 1) {\n                    col++;\n                    goingUp = true;\n                } else if (col == 0) {\n                    row++;\n                    goingUp = true;\n                } else {\n                    row++;\n                    col--;\n                }\n            }\n        }\n\n        return result;\n    }\n\n    // Spiral Matrix\n    public List<Integer> spiralOrder(int[][] matrix) {\n        List<Integer> result = new ArrayList<>();\n        if (matrix.length == 0) return result;\n\n        int top = 0, bottom = matrix.length - 1;\n        int left = 0, right = matrix[0].length - 1;\n\n        while (top <= bottom && left <= right) {\n            // Go right\n            for (int col = left; col <= right; col++) {\n                result.add(matrix[top][col]);\n            }\n            top++;\n\n            // Go down\n            for (int row = top; row <= bottom; row++) {\n                result.add(matrix[row][right]);\n            }\n            right--;\n\n            // Go left (if still have rows)\n            if (top <= bottom) {\n                for (int col = right; col >= left; col--) {\n                    result.add(matrix[bottom][col]);\n                }\n                bottom--;\n            }\n\n            // Go up (if still have columns)\n            if (left <= right) {\n                for (int row = bottom; row >= top; row--) {\n                    result.add(matrix[row][left]);\n                }\n                left++;\n            }\n        }\n\n        return result;\n    }\n\n    // Rotate Image\n    public void rotate(int[][] matrix) {\n        int n = matrix.length;\n\n        // Transpose matrix\n        for (int i = 0; i < n; i++) {\n            for (int j = i; j < n; j++) {\n                int temp = matrix[i][j];\n                matrix[i][j] = matrix[j][i];\n                matrix[j][i] = temp;\n            }\n        }\n\n        // Reverse each row\n        for (int i = 0; i < n; i++) {\n            int left = 0, right = n - 1;\n            while (left < right) {\n                int temp = matrix[i][left];\n                matrix[i][left] = matrix[i][right];\n                matrix[i][right] = temp;\n                left++;\n                right--;\n            }\n        }\n    }\n\n    // Valid Sudoku\n    public boolean isValidSudoku(char[][] board) {\n        Set<String> seen = new HashSet<>();\n\n        for (int i = 0; i < 9; i++) {\n            for (int j = 0; j < 9; j++) {\n                char value = board[i][j];\n                if (value != \'.\') {\n                    if (!seen.add(value + " in row " + i) ||\n                        !seen.add(value + " in column " + j) ||\n                        !seen.add(value + " in block " + i/3 + "-" + j/3)) {\n                        return false;\n                    }\n                }\n            }\n        }\n\n        return true;\n    }\n}\n'})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"pattern-11-optimization-techniques",children:"Pattern 11: Optimization Techniques"}),"\n",(0,i.jsx)(t.h3,{id:"111-performance-and-memory-optimizations",children:"11.1 Performance and Memory Optimizations"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-java",children:"// Optimization techniques for two pointers problems\npublic class TwoPointersOptimization {\n\n    // Space-optimized longest palindromic substring\n    public String longestPalindromeOptimized(String s) {\n        if (s == null || s.length() < 2) return s;\n\n        int start = 0, maxLength = 1;\n\n        for (int i = 0; i < s.length(); i++) {\n            // Check odd length palindromes\n            int len1 = expandAroundCenter(s, i, i);\n            // Check even length palindromes\n            int len2 = expandAroundCenter(s, i, i + 1);\n\n            int len = Math.max(len1, len2);\n            if (len > maxLength) {\n                maxLength = len;\n                start = i - (len - 1) / 2;\n            }\n        }\n\n        return s.substring(start, start + maxLength);\n    }\n\n    private int expandAroundCenter(String s, int left, int right) {\n        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\n            left--;\n            right++;\n        }\n        return right - left - 1;\n    }\n\n    // Optimized remove duplicates with minimal operations\n    public int removeDuplicatesOptimal(int[] nums) {\n        if (nums.length == 0) return 0;\n\n        int writeIndex = 1;\n\n        for (int readIndex = 1; readIndex < nums.length; readIndex++) {\n            if (nums[readIndex] != nums[readIndex - 1]) {\n                nums[writeIndex] = nums[readIndex];\n                writeIndex++;\n            }\n        }\n\n        return writeIndex;\n    }\n\n    // Cache-friendly two pointers implementation\n    public boolean twoSumCacheFriendly(int[] nums, int target) {\n        // Sort first for better cache locality\n        Arrays.sort(nums);\n\n        int left = 0, right = nums.length - 1;\n\n        while (left < right) {\n            int sum = nums[left] + nums[right];\n\n            if (sum == target) {\n                return true;\n            } else if (sum < target) {\n                // Prefetch next elements\n                if (left + 1 < nums.length) {\n                    int nextLeft = nums[left + 1]; // Hint to cache\n                }\n                left++;\n            } else {\n                // Prefetch next elements\n                if (right - 1 >= 0) {\n                    int nextRight = nums[right - 1]; // Hint to cache\n                }\n                right--;\n            }\n        }\n\n        return false;\n    }\n\n    // Memory-efficient string reversal\n    public void reverseStringInPlace(char[] s) {\n        int left = 0, right = s.length - 1;\n\n        while (left < right) {\n            // XOR swap to avoid temporary variable\n            s[left] ^= s[right];\n            s[right] ^= s[left];\n            s[left] ^= s[right];\n\n            left++;\n            right--;\n        }\n    }\n\n    // Optimized palindrome check with early termination\n    public boolean isPalindromeOptimized(String s) {\n        if (s == null || s.length() <= 1) return true;\n\n        int left = 0, right = s.length() - 1;\n\n        while (left < right) {\n            // Skip non-alphanumeric characters\n            char leftChar = s.charAt(left);\n            char rightChar = s.charAt(right);\n\n            if (!Character.isLetterOrDigit(leftChar)) {\n                left++;\n                continue;\n            }\n\n            if (!Character.isLetterOrDigit(rightChar)) {\n                right--;\n                continue;\n            }\n\n            // Early termination for obvious mismatches\n            if (Character.toLowerCase(leftChar) != Character.toLowerCase(rightChar)) {\n                return false;\n            }\n\n            left++;\n            right--;\n        }\n\n        return true;\n    }\n\n    // Batch processing for large arrays\n    public int[] twoSumBatch(int[] nums, int target, int batchSize) {\n        // Process in batches for better memory management\n        for (int batch = 0; batch < nums.length; batch += batchSize) {\n            int end = Math.min(batch + batchSize, nums.length);\n\n            // Process current batch\n            for (int i = batch; i < end; i++) {\n                for (int j = i + 1; j < nums.length; j++) {\n                    if (nums[i] + nums[j] == target) {\n                        return new int[]{i, j};\n                    }\n                }\n            }\n        }\n\n        return new int[]{-1, -1};\n    }\n\n    // Parallel two pointers for large datasets\n    public boolean containsDuplicateParallel(int[] nums) {\n        if (nums.length < 1000) {\n            // Use regular approach for small arrays\n            return containsDuplicateRegular(nums);\n        }\n\n        // Split array and process in parallel\n        int mid = nums.length / 2;\n\n        CompletableFuture<Boolean> leftHalf = CompletableFuture.supplyAsync(() ->\n            containsDuplicateRegular(Arrays.copyOfRange(nums, 0, mid)));\n\n        CompletableFuture<Boolean> rightHalf = CompletableFuture.supplyAsync(() ->\n            containsDuplicateRegular(Arrays.copyOfRange(nums, mid, nums.length)));\n\n        // Check for duplicates across halves\n        Set<Integer> leftSet = new HashSet<>();\n        for (int i = 0; i < mid; i++) {\n            leftSet.add(nums[i]);\n        }\n\n        for (int i = mid; i < nums.length; i++) {\n            if (leftSet.contains(nums[i])) {\n                return true;\n            }\n        }\n\n        try {\n            return leftHalf.get() || rightHalf.get();\n        } catch (Exception e) {\n            return containsDuplicateRegular(nums);\n        }\n    }\n\n    private boolean containsDuplicateRegular(int[] nums) {\n        Set<Integer> seen = new HashSet<>();\n        for (int num : nums) {\n            if (seen.contains(num)) {\n                return true;\n            }\n            seen.add(num);\n        }\n        return false;\n    }\n\n    // Adaptive algorithm selection based on input characteristics\n    public int[] twoSumAdaptive(int[] nums, int target) {\n        // Choose algorithm based on array characteristics\n        if (nums.length < 100) {\n            return twoSumBruteForce(nums, target);\n        } else if (isSorted(nums)) {\n            return twoSumTwoPointers(nums, target);\n        } else {\n            return twoSumHashMap(nums, target);\n        }\n    }\n\n    private boolean isSorted(int[] nums) {\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i] < nums[i - 1]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private int[] twoSumBruteForce(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[i] + nums[j] == target) {\n                    return new int[]{i, j};\n                }\n            }\n        }\n        return new int[]{-1, -1};\n    }\n\n    private int[] twoSumTwoPointers(int[] nums, int target) {\n        int left = 0, right = nums.length - 1;\n\n        while (left < right) {\n            int sum = nums[left] + nums[right];\n            if (sum == target) {\n                return new int[]{left, right};\n            } else if (sum < target) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n\n        return new int[]{-1, -1};\n    }\n\n    private int[] twoSumHashMap(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[]{map.get(complement), i};\n            }\n            map.put(nums[i], i);\n        }\n\n        return new int[]{-1, -1};\n    }\n}\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"summary-and-conclusion",children:"Summary and Conclusion"}),"\n",(0,i.jsx)(t.h3,{id:"two-pointers-pattern-recognition",children:"Two Pointers Pattern Recognition"}),"\n",(0,i.jsx)(t.h2,{id:"time--space-complexity-reference",children:"Time & Space Complexity Reference"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Pattern Type"}),(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Time Complexity"}),(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Space Complexity"}),(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Key Characteristics"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Opposite Direction"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"O(n)"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"O(1)"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Sorted arrays, palindromes, pairs"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Same Direction"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"O(n)"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"O(1)"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Array modifications, duplicates"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Fast & Slow"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"O(n)"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"O(1)"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Cycle detection, middle finding"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Sorting Problems"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"O(n)"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"O(1)"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"In-place partitioning"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"HashMap Combination"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"O(n)"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"O(n)"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Frequency tracking"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Multiple Arrays"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"O(n+m)"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"O(1)"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Merging operations"})]})]})]}),"\n",(0,i.jsx)(t.p,{children:"The two pointers technique is a fundamental algorithmic approach that optimizes solutions for array, string, and linked list problems. Here's a comprehensive summary:"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"When to Use Two Pointers:"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Sorted arrays for pair/triplet finding"}),"\n",(0,i.jsx)(t.li,{children:"String palindrome problems"}),"\n",(0,i.jsx)(t.li,{children:"Array partitioning and modification"}),"\n",(0,i.jsx)(t.li,{children:"Linked list cycle detection and manipulation"}),"\n",(0,i.jsx)(t.li,{children:"Merging operations"}),"\n",(0,i.jsx)(t.li,{children:"In-place array rearrangement"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Key Benefits:"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Reduces time complexity from O(n\xb2) to O(n) in most cases"}),"\n",(0,i.jsx)(t.li,{children:"Constant space complexity O(1) for many problems"}),"\n",(0,i.jsx)(t.li,{children:"Natural fit for sorted data structures"}),"\n",(0,i.jsx)(t.li,{children:"Elegant solutions for complex problems"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Implementation Guidelines:"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Opposite Direction"}),": Start from both ends, move toward center"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Same Direction"}),": Use slow/fast pointers moving in same direction"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Fast & Slow"}),": Different speeds for cycle detection"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Multiple Arrays"}),": Coordinate pointers across different arrays"]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Common Patterns:"})}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Two Sum problems"}),": Sorted array, opposite direction"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Array modification"}),": Same direction, in-place operations"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Cycle detection"}),": Fast and slow pointers"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"String processing"}),": Expand around center, palindrome validation"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Merging"}),": Multiple pointers across different data structures"]}),"\n"]})]})}function d(n={}){const{wrapper:t}={...(0,r.R)(),...n.components};return t?(0,i.jsx)(t,{...n,children:(0,i.jsx)(h,{...n})}):h(n)}}}]);