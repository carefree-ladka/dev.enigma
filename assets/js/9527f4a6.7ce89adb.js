"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[9219],{2037:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>o,contentTitle:()=>s,default:()=>p,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var a=t(74848),r=t(28453);const i={},s="Java Wrapper Classes, Lambda, Regex & Annotations",l={id:"Java/JavaWrapperClassesLambdaRegex&Annotations",title:"Java Wrapper Classes, Lambda, Regex & Annotations",description:"Table of Contents",source:"@site/docs/Java/JavaWrapperClassesLambdaRegex&Annotations.mdx",sourceDirName:"Java",slug:"/Java/JavaWrapperClassesLambdaRegex&Annotations",permalink:"/js.enigma/docs/Java/JavaWrapperClassesLambdaRegex&Annotations",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/Java/JavaWrapperClassesLambdaRegex&Annotations.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Java Data Structures and Algorithms",permalink:"/js.enigma/docs/Java/JavaWithDSA"},next:{title:"Jenkins for Beginners - Spring Boot Development Guide",permalink:"/js.enigma/docs/Java/Jenkins for Beginners - Spring Boot Development Guide"}},o={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Part 1: Wrapper Classes",id:"part-1-wrapper-classes",level:3},{value:"Part 2: Lambda Expressions",id:"part-2-lambda-expressions",level:3},{value:"Part 3: Regular Expressions",id:"part-3-regular-expressions",level:3},{value:"Part 4: Annotations",id:"part-4-annotations",level:3},{value:"What are Wrapper Classes?",id:"what-are-wrapper-classes",level:2},{value:"Why Wrapper Classes?",id:"why-wrapper-classes",level:3},{value:"Primitive to Wrapper Mapping",id:"primitive-to-wrapper-mapping",level:2},{value:"Autoboxing and Unboxing",id:"autoboxing-and-unboxing",level:2},{value:"Autoboxing (Primitive to Wrapper)",id:"autoboxing-primitive-to-wrapper",level:3},{value:"Unboxing (Wrapper to Primitive)",id:"unboxing-wrapper-to-primitive",level:3},{value:"Null Pointer Exception Risk",id:"null-pointer-exception-risk",level:3},{value:"Wrapper Class Methods",id:"wrapper-class-methods",level:2},{value:"Value Extraction Methods",id:"value-extraction-methods",level:3},{value:"String Conversion Methods",id:"string-conversion-methods",level:3},{value:"Parsing Methods",id:"parsing-methods",level:3},{value:"Comparison Methods",id:"comparison-methods",level:3},{value:"Practical Usage",id:"practical-usage",level:2},{value:"Working with Collections",id:"working-with-collections",level:3},{value:"Utility Methods Example",id:"utility-methods-example",level:3},{value:"Introduction to Lambda",id:"introduction-to-lambda",level:2},{value:"Benefits of Lambda Expressions:",id:"benefits-of-lambda-expressions",level:3},{value:"Lambda Syntax",id:"lambda-syntax",level:2},{value:"Basic Syntax Forms",id:"basic-syntax-forms",level:3},{value:"Lambda Expression Examples",id:"lambda-expression-examples",level:3},{value:"Functional Interfaces",id:"functional-interfaces",level:2},{value:"What is a Functional Interface?",id:"what-is-a-functional-interface",level:3},{value:"@FunctionalInterface Annotation",id:"functionalinterface-annotation",level:3},{value:"Custom Functional Interface Example",id:"custom-functional-interface-example",level:3},{value:"Built-in Functional Interfaces",id:"built-in-functional-interfaces",level:2},{value:"Core Functional Interfaces",id:"core-functional-interfaces",level:3},{value:"Consumer Examples",id:"consumer-examples",level:3},{value:"Supplier Examples",id:"supplier-examples",level:3},{value:"Function Examples",id:"function-examples",level:3},{value:"Predicate Examples",id:"predicate-examples",level:3},{value:"Method References",id:"method-references",level:2},{value:"Types of Method References",id:"types-of-method-references",level:3},{value:"Method Reference Examples",id:"method-reference-examples",level:3},{value:"Advanced Method Reference Usage",id:"advanced-method-reference-usage",level:3},{value:"Regex Fundamentals",id:"regex-fundamentals",level:2},{value:"Java Regex Classes",id:"java-regex-classes",level:3},{value:"Pattern and Matcher Classes",id:"pattern-and-matcher-classes",level:2},{value:"Basic Usage",id:"basic-usage",level:3},{value:"Pattern Flags",id:"pattern-flags",level:3},{value:"Matcher Methods",id:"matcher-methods",level:3},{value:"Common Regex Patterns",id:"common-regex-patterns",level:2},{value:"Character Classes and Metacharacters",id:"character-classes-and-metacharacters",level:3},{value:"Quantifiers",id:"quantifiers",level:3},{value:"Groups and Capturing",id:"groups-and-capturing",level:3},{value:"Practical Regex Examples",id:"practical-regex-examples",level:2},{value:"Email Validation",id:"email-validation",level:3},{value:"Phone Number Extraction and Formatting",id:"phone-number-extraction-and-formatting",level:3},{value:"Log File Parsing",id:"log-file-parsing",level:3},{value:"Text Processing and Cleaning",id:"text-processing-and-cleaning",level:3},{value:"Understanding Annotations",id:"understanding-annotations",level:2},{value:"Benefits of Annotations:",id:"benefits-of-annotations",level:3},{value:"Built-in Annotations",id:"built-in-annotations",level:2},{value:"@Override Annotation",id:"override-annotation",level:3},{value:"@Deprecated Annotation",id:"deprecated-annotation",level:3},{value:"@SuppressWarnings Annotation",id:"suppresswarnings-annotation",level:3},{value:"Other Built-in Annotations",id:"other-built-in-annotations",level:3},{value:"Custom Annotations",id:"custom-annotations",level:2},{value:"Creating Custom Annotations",id:"creating-custom-annotations",level:3},{value:"Annotation Processing",id:"annotation-processing",level:2},{value:"Runtime Annotation Processing",id:"runtime-annotation-processing",level:3},{value:"Meta-Annotations",id:"meta-annotations",level:3},{value:"Summary",id:"summary",level:2},{value:"Wrapper Classes Key Points",id:"wrapper-classes-key-points",level:3},{value:"Lambda Expressions Key Points",id:"lambda-expressions-key-points",level:3},{value:"Regular Expressions Key Points",id:"regular-expressions-key-points",level:3},{value:"Table of Contents",id:"table-of-contents-1",level:2},{value:"Part 1: Wrapper Classes",id:"part-1-wrapper-classes-2",level:3},{value:"Part 2: Lambda Expressions",id:"part-2-lambda-expressions-2",level:3},{value:"Part 3: Regular Expressions",id:"part-3-regular-expressions-2",level:3},{value:"Part 4: Annotations",id:"part-4-annotations-2",level:3},{value:"What are Wrapper Classes?",id:"what-are-wrapper-classes-1",level:2},{value:"Why Wrapper Classes?",id:"why-wrapper-classes-1",level:3},{value:"Primitive to Wrapper Mapping",id:"primitive-to-wrapper-mapping-1",level:2},{value:"Autoboxing and Unboxing",id:"autoboxing-and-unboxing-1",level:2},{value:"Autoboxing (Primitive to Wrapper)",id:"autoboxing-primitive-to-wrapper-1",level:3},{value:"Unboxing (Wrapper to Primitive)",id:"unboxing-wrapper-to-primitive-1",level:3},{value:"Null Pointer Exception Risk",id:"null-pointer-exception-risk-1",level:3},{value:"Wrapper Class Methods",id:"wrapper-class-methods-1",level:2},{value:"Value Extraction Methods",id:"value-extraction-methods-1",level:3},{value:"String Conversion Methods",id:"string-conversion-methods-1",level:3},{value:"Parsing Methods",id:"parsing-methods-1",level:3},{value:"Comparison Methods",id:"comparison-methods-1",level:3},{value:"Practical Usage",id:"practical-usage-1",level:2},{value:"Working with Collections",id:"working-with-collections-1",level:3},{value:"Utility Methods Example",id:"utility-methods-example-1",level:3},{value:"Introduction to Lambda",id:"introduction-to-lambda-1",level:2},{value:"Benefits of Lambda Expressions:",id:"benefits-of-lambda-expressions-1",level:3},{value:"Lambda Syntax",id:"lambda-syntax-1",level:2},{value:"Basic Syntax Forms",id:"basic-syntax-forms-1",level:3},{value:"Lambda Expression Examples",id:"lambda-expression-examples-1",level:3},{value:"Functional Interfaces",id:"functional-interfaces-1",level:2},{value:"What is a Functional Interface?",id:"what-is-a-functional-interface-1",level:3},{value:"@FunctionalInterface Annotation",id:"functionalinterface-annotation-1",level:3},{value:"Custom Functional Interface Example",id:"custom-functional-interface-example-1",level:3},{value:"Built-in Functional Interfaces",id:"built-in-functional-interfaces-1",level:2},{value:"Core Functional Interfaces",id:"core-functional-interfaces-1",level:3},{value:"Consumer Examples",id:"consumer-examples-1",level:3},{value:"Supplier Examples",id:"supplier-examples-1",level:3},{value:"Function Examples",id:"function-examples-1",level:3},{value:"Predicate Examples",id:"predicate-examples-1",level:3},{value:"Method References",id:"method-references-1",level:2},{value:"Types of Method References",id:"types-of-method-references-1",level:3},{value:"Method Reference Examples",id:"method-reference-examples-1",level:3},{value:"Advanced Method Reference Usage",id:"advanced-method-reference-usage-1",level:3},{value:"Regex Fundamentals",id:"regex-fundamentals-1",level:2},{value:"Java Regex Classes",id:"java-regex-classes-1",level:3},{value:"Pattern and Matcher Classes",id:"pattern-and-matcher-classes-1",level:2},{value:"Basic Usage",id:"basic-usage-1",level:3},{value:"Pattern Flags",id:"pattern-flags-1",level:3},{value:"Matcher Methods",id:"matcher-methods-1",level:3},{value:"Common Regex Patterns",id:"common-regex-patterns-1",level:2},{value:"Character Classes and Metacharacters",id:"character-classes-and-metacharacters-1",level:3},{value:"Quantifiers",id:"quantifiers-1",level:3},{value:"Groups and Capturing",id:"groups-and-capturing-1",level:3},{value:"Practical Regex Examples",id:"practical-regex-examples-1",level:2},{value:"Email Validation",id:"email-validation-1",level:3},{value:"Phone Number Extraction and Formatting",id:"phone-number-extraction-and-formatting-1",level:3},{value:"Log File Parsing",id:"log-file-parsing-1",level:3},{value:"Text Processing and Cleaning",id:"text-processing-and-cleaning-1",level:3},{value:"Understanding Annotations",id:"understanding-annotations-1",level:2},{value:"Benefits of Annotations:",id:"benefits-of-annotations-1",level:3},{value:"Built-in Annotations",id:"built-in-annotations-1",level:2},{value:"@Override Annotation",id:"override-annotation-1",level:3},{value:"@Deprecated Annotation",id:"deprecated-annotation-1",level:3},{value:"@SuppressWarnings Annotation",id:"suppresswarnings-annotation-1",level:3},{value:"Other Built-in Annotations",id:"other-built-in-annotations-1",level:3},{value:"Custom Annotations",id:"custom-annotations-1",level:2},{value:"Creating Custom Annotations",id:"creating-custom-annotations-1",level:3},{value:"Annotation Processing",id:"annotation-processing-1",level:2},{value:"Runtime Annotation Processing",id:"runtime-annotation-processing-1",level:3},{value:"Meta-Annotations",id:"meta-annotations-1",level:3},{value:"Annotations Key Points",id:"annotations-key-points",level:3},{value:"Comprehensive Example",id:"comprehensive-example",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"java-wrapper-classes-lambda-regex--annotations",children:"Java Wrapper Classes, Lambda, Regex & Annotations"})}),"\n",(0,a.jsx)(e.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,a.jsx)(e.h3,{id:"part-1-wrapper-classes",children:"Part 1: Wrapper Classes"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#what-are-wrapper-classes",children:"What are Wrapper Classes?"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#primitive-to-wrapper-mapping",children:"Primitive to Wrapper Mapping"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#autoboxing-and-unboxing",children:"Autoboxing and Unboxing"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#wrapper-class-methods",children:"Wrapper Class Methods"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#practical-usage",children:"Practical Usage"})}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"part-2-lambda-expressions",children:"Part 2: Lambda Expressions"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#introduction-to-lambda",children:"Introduction to Lambda"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#lambda-syntax",children:"Lambda Syntax"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#functional-interfaces",children:"Functional Interfaces"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#built-in-functional-interfaces",children:"Built-in Functional Interfaces"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#method-references",children:"Method References"})}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"part-3-regular-expressions",children:"Part 3: Regular Expressions"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#regex-fundamentals",children:"Regex Fundamentals"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#pattern-and-matcher-classes",children:"Pattern and Matcher Classes"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#common-regex-patterns",children:"Common Regex Patterns"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#practical-regex-examples",children:"Practical Regex Examples"})}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"part-4-annotations",children:"Part 4: Annotations"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#understanding-annotations",children:"Understanding Annotations"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#built-in-annotations",children:"Built-in Annotations"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#custom-annotations",children:"Custom Annotations"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#annotation-processing",children:"Annotation Processing"})}),"\n"]}),"\n",(0,a.jsx)(e.hr,{}),"\n",(0,a.jsx)(e.h1,{id:"part-1-wrapper-classes-1",children:"Part 1: Wrapper Classes"}),"\n",(0,a.jsx)(e.h2,{id:"what-are-wrapper-classes",children:"What are Wrapper Classes?"}),"\n",(0,a.jsx)(e.p,{children:"Wrapper classes provide a way to use primitive data types (int, boolean, etc..) as objects."}),"\n",(0,a.jsx)(e.h3,{id:"why-wrapper-classes",children:"Why Wrapper Classes?"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Collections Requirement"}),": Collections like ArrayList can only store objects, not primitives"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Method Availability"}),": Wrapper classes provide useful methods for data conversion"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Null Support"}),": Wrapper classes can hold null values, primitives cannot"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Generic Type Parameters"}),": Required for generics (e.g., ",(0,a.jsx)(e.code,{children:"List<Integer>"}),")"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"primitive-to-wrapper-mapping",children:"Primitive to Wrapper Mapping"}),"\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"Primitive Type"}),(0,a.jsx)(e.th,{children:"Wrapper Class"}),(0,a.jsx)(e.th,{children:"Size (bytes)"}),(0,a.jsx)(e.th,{children:"Range"})]})}),(0,a.jsxs)(e.tbody,{children:[(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"byte"})}),(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"Byte"})}),(0,a.jsx)(e.td,{children:"1"}),(0,a.jsx)(e.td,{children:"-128 to 127"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"short"})}),(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"Short"})}),(0,a.jsx)(e.td,{children:"2"}),(0,a.jsx)(e.td,{children:"-32,768 to 32,767"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"int"})}),(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"Integer"})}),(0,a.jsx)(e.td,{children:"4"}),(0,a.jsx)(e.td,{children:"-2\xb3\xb9 to 2\xb3\xb9-1"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"long"})}),(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"Long"})}),(0,a.jsx)(e.td,{children:"8"}),(0,a.jsx)(e.td,{children:"-2\u2076\xb3 to 2\u2076\xb3-1"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"float"})}),(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"Float"})}),(0,a.jsx)(e.td,{children:"4"}),(0,a.jsx)(e.td,{children:"\xb13.4E\xb138 (7 digits)"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"double"})}),(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"Double"})}),(0,a.jsx)(e.td,{children:"8"}),(0,a.jsx)(e.td,{children:"\xb11.7E\xb1308 (15 digits)"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"boolean"})}),(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"Boolean"})}),(0,a.jsx)(e.td,{children:"1 bit"}),(0,a.jsx)(e.td,{children:"true/false"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"char"})}),(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"Character"})}),(0,a.jsx)(e.td,{children:"2"}),(0,a.jsx)(e.td,{children:"0 to 65,535 (Unicode)"})]})]})]}),"\n",(0,a.jsx)(e.h2,{id:"autoboxing-and-unboxing",children:"Autoboxing and Unboxing"}),"\n",(0,a.jsx)(e.h3,{id:"autoboxing-primitive-to-wrapper",children:"Autoboxing (Primitive to Wrapper)"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:"public class AutoboxingExample {\n    public static void main(String[] args) {\n        // Automatic conversion from primitive to wrapper\n        Integer myInt = 5;           // int -> Integer\n        Double myDouble = 5.99;      // double -> Double\n        Boolean myBoolean = true;    // boolean -> Boolean\n        Character myChar = 'A';      // char -> Character\n\n        System.out.println(myInt);     // Output: 5\n        System.out.println(myDouble);  // Output: 5.99\n        System.out.println(myBoolean); // Output: true\n        System.out.println(myChar);    // Output: A\n\n        // Collections with autoboxing\n        ArrayList<Integer> numbers = new ArrayList<>();\n        numbers.add(10);    // Automatically boxes int to Integer\n        numbers.add(20);\n        numbers.add(30);\n    }\n}\n"})}),"\n",(0,a.jsx)(e.h3,{id:"unboxing-wrapper-to-primitive",children:"Unboxing (Wrapper to Primitive)"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'public class UnboxingExample {\n    public static void main(String[] args) {\n        Integer wrapperInt = 100;\n        Double wrapperDouble = 25.5;\n\n        // Automatic conversion from wrapper to primitive\n        int primitiveInt = wrapperInt;        // Integer -> int\n        double primitiveDouble = wrapperDouble; // Double -> double\n\n        // Arithmetic operations trigger unboxing\n        Integer a = 10;\n        Integer b = 20;\n        int sum = a + b;  // Both Integer objects are unboxed to int\n\n        System.out.println("Sum: " + sum); // Output: Sum: 30\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"null-pointer-exception-risk",children:"Null Pointer Exception Risk"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'public class NPEExample {\n    public static void main(String[] args) {\n        Integer nullInteger = null;\n\n        try {\n            int value = nullInteger; // NullPointerException!\n        } catch (NullPointerException e) {\n            System.out.println("Cannot unbox null wrapper: " + e.getMessage());\n        }\n\n        // Safe approach\n        if (nullInteger != null) {\n            int safeValue = nullInteger;\n            System.out.println("Safe value: " + safeValue);\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h2,{id:"wrapper-class-methods",children:"Wrapper Class Methods"}),"\n",(0,a.jsx)(e.h3,{id:"value-extraction-methods",children:"Value Extraction Methods"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'public class ValueExtractionExample {\n    public static void main(String[] args) {\n        Integer intWrapper = 42;\n        Double doubleWrapper = 3.14159;\n        Character charWrapper = \'Z\';\n        Boolean boolWrapper = true;\n\n        // Extract primitive values\n        int intValue = intWrapper.intValue();\n        byte byteValue = intWrapper.byteValue();\n        double doubleValue = intWrapper.doubleValue();\n\n        double doubleVal = doubleWrapper.doubleValue();\n        float floatVal = doubleWrapper.floatValue();\n        int truncatedInt = doubleWrapper.intValue(); // Truncates decimal\n\n        char charValue = charWrapper.charValue();\n        boolean boolValue = boolWrapper.booleanValue();\n\n        System.out.println("Integer as int: " + intValue);        // 42\n        System.out.println("Integer as byte: " + byteValue);      // 42\n        System.out.println("Integer as double: " + doubleValue); // 42.0\n        System.out.println("Double truncated: " + truncatedInt); // 3\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"string-conversion-methods",children:"String Conversion Methods"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'public class StringConversionExample {\n    public static void main(String[] args) {\n        Integer number = 12345;\n        Double decimal = 98.76;\n        Boolean flag = true;\n\n        // Convert to string\n        String numberStr = number.toString();\n        String decimalStr = decimal.toString();\n        String flagStr = flag.toString();\n\n        System.out.println("Number as string: " + numberStr);   // "12345"\n        System.out.println("String length: " + numberStr.length()); // 5\n\n        // Static toString methods\n        String binaryStr = Integer.toString(number, 2);  // Binary\n        String hexStr = Integer.toString(number, 16);    // Hexadecimal\n        String octalStr = Integer.toString(number, 8);   // Octal\n\n        System.out.println("Binary: " + binaryStr);   // "11000000111001"\n        System.out.println("Hex: " + hexStr);         // "3039"\n        System.out.println("Octal: " + octalStr);     // "30071"\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"parsing-methods",children:"Parsing Methods"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'public class ParsingExample {\n    public static void main(String[] args) {\n        // String to primitive/wrapper conversion\n        String intStr = "123";\n        String doubleStr = "45.67";\n        String boolStr = "true";\n\n        // Parse to primitives\n        int parsedInt = Integer.parseInt(intStr);\n        double parsedDouble = Double.parseDouble(doubleStr);\n        boolean parsedBool = Boolean.parseBoolean(boolStr);\n\n        // Parse to wrapper objects\n        Integer wrapperInt = Integer.valueOf(intStr);\n        Double wrapperDouble = Double.valueOf(doubleStr);\n        Boolean wrapperBool = Boolean.valueOf(boolStr);\n\n        System.out.println("Parsed int: " + parsedInt);\n        System.out.println("Wrapper int: " + wrapperInt);\n\n        // Parse with different radix\n        String binaryStr = "1010";\n        String hexStr = "FF";\n        int fromBinary = Integer.parseInt(binaryStr, 2);  // Binary to int\n        int fromHex = Integer.parseInt(hexStr, 16);       // Hex to int\n\n        System.out.println("Binary 1010 as int: " + fromBinary); // 10\n        System.out.println("Hex FF as int: " + fromHex);         // 255\n\n        // Error handling\n        try {\n            int invalid = Integer.parseInt("not a number");\n        } catch (NumberFormatException e) {\n            System.out.println("Invalid number format: " + e.getMessage());\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"comparison-methods",children:"Comparison Methods"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'public class ComparisonExample {\n    public static void main(String[] args) {\n        Integer a = 100;\n        Integer b = 200;\n        Integer c = 100;\n\n        // Compare wrapper objects\n        System.out.println("a.equals(c): " + a.equals(c));           // true\n        System.out.println("a == c: " + (a == c));                  // true (cached)\n\n        Integer x = 128;\n        Integer y = 128;\n        System.out.println("x.equals(y): " + x.equals(y));          // true\n        System.out.println("x == y: " + (x == y));                  // false (not cached)\n\n        // Compare values\n        int comparison = a.compareTo(b);\n        System.out.println("a compared to b: " + comparison);       // -1 (a < b)\n\n        // Static compare methods\n        int staticComp = Integer.compare(a, b);\n        System.out.println("Static compare: " + staticComp);        // -1\n\n        // Max and min values\n        System.out.println("Integer MAX: " + Integer.MAX_VALUE);\n        System.out.println("Integer MIN: " + Integer.MIN_VALUE);\n        System.out.println("Double MAX: " + Double.MAX_VALUE);\n        System.out.println("Double MIN: " + Double.MIN_VALUE);\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h2,{id:"practical-usage",children:"Practical Usage"}),"\n",(0,a.jsx)(e.h3,{id:"working-with-collections",children:"Working with Collections"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'import java.util.*;\n\npublic class CollectionUsage {\n    public static void main(String[] args) {\n        // List of integers\n        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);\n\n        // Sum using wrapper methods\n        int sum = numbers.stream()\n                        .mapToInt(Integer::intValue)\n                        .sum();\n        System.out.println("Sum: " + sum);\n\n        // Map with wrapper keys and values\n        Map<Integer, String> numberNames = new HashMap<>();\n        numberNames.put(1, "One");\n        numberNames.put(2, "Two");\n        numberNames.put(3, "Three");\n\n        // Process map entries\n        numberNames.forEach((key, value) ->\n            System.out.println(key.toString() + " -> " + value));\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"utility-methods-example",children:"Utility Methods Example"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'public class UtilityMethodsExample {\n    public static void main(String[] args) {\n        // Integer utility methods\n        System.out.println("Bit count of 7: " + Integer.bitCount(7));      // 3\n        System.out.println("Leading zeros: " + Integer.numberOfLeadingZeros(8)); // 28\n        System.out.println("Reverse bits: " + Integer.reverse(1));         // -2147483648\n\n        // Character utility methods\n        System.out.println("Is digit: " + Character.isDigit(\'5\'));         // true\n        System.out.println("Is letter: " + Character.isLetter(\'A\'));       // true\n        System.out.println("To uppercase: " + Character.toUpperCase(\'a\')); // A\n        System.out.println("To lowercase: " + Character.toLowerCase(\'Z\')); // z\n\n        // Boolean utility methods\n        System.out.println("Logical AND: " + Boolean.logicalAnd(true, false)); // false\n        System.out.println("Logical OR: " + Boolean.logicalOr(true, false));   // true\n        System.out.println("Logical XOR: " + Boolean.logicalXor(true, false)); // true\n    }\n}\n'})}),"\n",(0,a.jsx)(e.hr,{}),"\n",(0,a.jsx)(e.h1,{id:"part-2-lambda-expressions-1",children:"Part 2: Lambda Expressions"}),"\n",(0,a.jsx)(e.h2,{id:"introduction-to-lambda",children:"Introduction to Lambda"}),"\n",(0,a.jsx)(e.p,{children:"Lambda Expressions were added in Java 8. A lambda expression is a short block of code which takes in parameters and returns a value. Lambda expressions are similar to methods, but they do not need a name and they can be implemented right in the body of a method."}),"\n",(0,a.jsx)(e.h3,{id:"benefits-of-lambda-expressions",children:"Benefits of Lambda Expressions:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Concise Code"}),": Reduce boilerplate code"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Functional Programming"}),": Enable functional programming paradigms"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Better Collections"}),": Work seamlessly with Streams API"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Parallel Processing"}),": Easier parallel operations"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"lambda-syntax",children:"Lambda Syntax"}),"\n",(0,a.jsx)(e.h3,{id:"basic-syntax-forms",children:"Basic Syntax Forms"}),"\n",(0,a.jsx)(e.p,{children:"The simplest lambda expression contains a single parameter and an expression:\nparameter -> expression"}),"\n",(0,a.jsx)(e.p,{children:"To use more than one parameter, wrap them in parentheses:\n(parameter1, parameter2) -> expression"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'// Single parameter (parentheses optional)\nx -> x * 2\nn -> System.out.println(n)\n\n// Multiple parameters (parentheses required)\n(a, b) -> a + b\n(x, y) -> Math.max(x, y)\n\n// No parameters\n() -> System.out.println("Hello")\n() -> Math.random()\n\n// Code block with return statement\n(a, b) -> {\n    int sum = a + b;\n    return sum * 2;\n}\n\n// Code block without return (void)\nn -> {\n    System.out.println("Processing: " + n);\n    // Some complex logic here\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"lambda-expression-examples",children:"Lambda Expression Examples"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'import java.util.*;\nimport java.util.function.*;\n\npublic class LambdaSyntaxExamples {\n    public static void main(String[] args) {\n        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);\n\n        // Traditional approach with anonymous class\n        numbers.forEach(new Consumer<Integer>() {\n            @Override\n            public void accept(Integer n) {\n                System.out.println(n);\n            }\n        });\n\n        // Lambda expression - single line\n        numbers.forEach(n -> System.out.println(n));\n\n        // Lambda expression - method reference\n        numbers.forEach(System.out::println);\n\n        // Lambda with filtering\n        numbers.stream()\n               .filter(n -> n % 2 == 0)\n               .forEach(System.out::println);\n\n        // Lambda with transformation\n        List<String> strings = numbers.stream()\n                                     .map(n -> "Number: " + n)\n                                     .collect(Collectors.toList());\n        System.out.println(strings);\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h2,{id:"functional-interfaces",children:"Functional Interfaces"}),"\n",(0,a.jsx)(e.h3,{id:"what-is-a-functional-interface",children:"What is a Functional Interface?"}),"\n",(0,a.jsx)(e.p,{children:"A functional interface has exactly one abstract method (Single Abstract Method - SAM). Lambda expressions can be used wherever a functional interface is expected."}),"\n",(0,a.jsx)(e.h3,{id:"functionalinterface-annotation",children:"@FunctionalInterface Annotation"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'@FunctionalInterface\ninterface MathOperation {\n    int operate(int a, int b);\n\n    // Default methods are allowed\n    default void printResult(int result) {\n        System.out.println("Result: " + result);\n    }\n\n    // Static methods are allowed\n    static void printInfo() {\n        System.out.println("This is a math operation interface");\n    }\n}\n\npublic class FunctionalInterfaceExample {\n    public static void main(String[] args) {\n        // Lambda expressions implementing the interface\n        MathOperation addition = (a, b) -> a + b;\n        MathOperation subtraction = (a, b) -> a - b;\n        MathOperation multiplication = (a, b) -> a * b;\n        MathOperation division = (a, b) -> a / b;\n\n        // Using the lambda expressions\n        System.out.println("10 + 5 = " + addition.operate(10, 5));\n        System.out.println("10 - 5 = " + subtraction.operate(10, 5));\n        System.out.println("10 * 5 = " + multiplication.operate(10, 5));\n        System.out.println("10 / 5 = " + division.operate(10, 5));\n\n        // Using default method\n        addition.printResult(addition.operate(10, 5));\n\n        // Using static method\n        MathOperation.printInfo();\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"custom-functional-interface-example",children:"Custom Functional Interface Example"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'@FunctionalInterface\ninterface StringProcessor {\n    String process(String input);\n}\n\npublic class CustomFunctionalInterface {\n    public static void main(String[] args) {\n        // Various lambda implementations\n        StringProcessor uppercase = s -> s.toUpperCase();\n        StringProcessor lowercase = s -> s.toLowerCase();\n        StringProcessor reverse = s -> new StringBuilder(s).reverse().toString();\n        StringProcessor addExclamation = s -> s + "!";\n\n        String text = "Hello World";\n\n        System.out.println("Original: " + text);\n        System.out.println("Uppercase: " + processString(text, uppercase));\n        System.out.println("Lowercase: " + processString(text, lowercase));\n        System.out.println("Reversed: " + processString(text, reverse));\n        System.out.println("With exclamation: " + processString(text, addExclamation));\n    }\n\n    public static String processString(String input, StringProcessor processor) {\n        return processor.process(input);\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h2,{id:"built-in-functional-interfaces",children:"Built-in Functional Interfaces"}),"\n",(0,a.jsxs)(e.p,{children:["Java provides many built-in functional interfaces in the ",(0,a.jsx)(e.code,{children:"java.util.function"})," package:"]}),"\n",(0,a.jsx)(e.h3,{id:"core-functional-interfaces",children:"Core Functional Interfaces"}),"\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"Interface"}),(0,a.jsx)(e.th,{children:"Method"}),(0,a.jsx)(e.th,{children:"Description"}),(0,a.jsx)(e.th,{children:"Example"})]})}),(0,a.jsxs)(e.tbody,{children:[(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"Consumer<T>"})}),(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"void accept(T t)"})}),(0,a.jsx)(e.td,{children:"Consumes an input, returns nothing"}),(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"s -> System.out.println(s)"})})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"Supplier<T>"})}),(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"T get()"})}),(0,a.jsx)(e.td,{children:"Supplies a value, takes no input"}),(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"() -> Math.random()"})})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"Function<T,R>"})}),(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"R apply(T t)"})}),(0,a.jsx)(e.td,{children:"Takes input T, returns output R"}),(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"s -> s.length()"})})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"Predicate<T>"})}),(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"boolean test(T t)"})}),(0,a.jsx)(e.td,{children:"Tests a condition, returns boolean"}),(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"n -> n > 0"})})]})]})]}),"\n",(0,a.jsx)(e.h3,{id:"consumer-examples",children:"Consumer Examples"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'import java.util.function.Consumer;\nimport java.util.function.BiConsumer;\n\npublic class ConsumerExamples {\n    public static void main(String[] args) {\n        List<String> names = Arrays.asList("Alice", "Bob", "Charlie");\n\n        // Consumer - single parameter\n        Consumer<String> printer = name -> System.out.println("Hello, " + name);\n        names.forEach(printer);\n\n        // BiConsumer - two parameters\n        BiConsumer<String, Integer> indexedPrinter =\n            (name, index) -> System.out.println(index + ": " + name);\n\n        for (int i = 0; i < names.size(); i++) {\n            indexedPrinter.accept(names.get(i), i + 1);\n        }\n\n        // Consumer chaining\n        Consumer<String> upperCase = s -> System.out.println(s.toUpperCase());\n        Consumer<String> lowerCase = s -> System.out.println(s.toLowerCase());\n        Consumer<String> combined = upperCase.andThen(lowerCase);\n\n        combined.accept("Hello World");\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"supplier-examples",children:"Supplier Examples"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'import java.util.function.Supplier;\nimport java.util.Random;\n\npublic class SupplierExamples {\n    public static void main(String[] args) {\n        // Simple suppliers\n        Supplier<String> messageSupplier = () -> "Hello from supplier!";\n        Supplier<Double> randomSupplier = () -> Math.random();\n        Supplier<Integer> diceRoll = () -> new Random().nextInt(6) + 1;\n\n        System.out.println(messageSupplier.get());\n        System.out.println("Random: " + randomSupplier.get());\n        System.out.println("Dice roll: " + diceRoll.get());\n\n        // Supplier with complex logic\n        Supplier<List<String>> listSupplier = () -> {\n            List<String> list = new ArrayList<>();\n            list.add("Item 1");\n            list.add("Item 2");\n            list.add("Item 3");\n            return list;\n        };\n\n        List<String> items = listSupplier.get();\n        System.out.println("Generated list: " + items);\n\n        // Lazy evaluation example\n        System.out.println("Getting value lazily: " + getValue(randomSupplier));\n    }\n\n    public static String getValue(Supplier<Double> supplier) {\n        // Value is only generated when needed\n        double value = supplier.get();\n        return value > 0.5 ? "High: " + value : "Low: " + value;\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"function-examples",children:"Function Examples"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'import java.util.function.Function;\nimport java.util.function.BiFunction;\n\npublic class FunctionExamples {\n    public static void main(String[] args) {\n        List<String> words = Arrays.asList("hello", "world", "java", "lambda");\n\n        // Function - transform string to its length\n        Function<String, Integer> lengthFunction = s -> s.length();\n\n        List<Integer> lengths = words.stream()\n                                   .map(lengthFunction)\n                                   .collect(Collectors.toList());\n        System.out.println("Lengths: " + lengths);\n\n        // Function chaining\n        Function<String, String> upperCase = s -> s.toUpperCase();\n        Function<String, String> addExclamation = s -> s + "!";\n        Function<String, String> combined = upperCase.andThen(addExclamation);\n\n        System.out.println(combined.apply("hello")); // "HELLO!"\n\n        // BiFunction - two parameters\n        BiFunction<Integer, Integer, Integer> multiply = (a, b) -> a * b;\n        BiFunction<String, String, String> concat = (s1, s2) -> s1 + " " + s2;\n\n        System.out.println("3 * 4 = " + multiply.apply(3, 4));\n        System.out.println("Concatenated: " + concat.apply("Hello", "World"));\n\n        // Function composition\n        Function<Integer, Integer> doubleValue = x -> x * 2;\n        Function<Integer, Integer> addTen = x -> x + 10;\n\n        // compose: first apply addTen, then doubleValue\n        Function<Integer, Integer> composed1 = doubleValue.compose(addTen);\n        System.out.println("Compose (5+10)*2 = " + composed1.apply(5)); // 30\n\n        // andThen: first apply doubleValue, then addTen\n        Function<Integer, Integer> composed2 = doubleValue.andThen(addTen);\n        System.out.println("AndThen (5*2)+10 = " + composed2.apply(5)); // 20\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"predicate-examples",children:"Predicate Examples"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'import java.util.function.Predicate;\n\npublic class PredicateExamples {\n    public static void main(String[] args) {\n        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n\n        // Simple predicates\n        Predicate<Integer> isEven = n -> n % 2 == 0;\n        Predicate<Integer> isPositive = n -> n > 0;\n        Predicate<Integer> isGreaterThanFive = n -> n > 5;\n\n        // Filter using predicates\n        List<Integer> evenNumbers = numbers.stream()\n                                          .filter(isEven)\n                                          .collect(Collectors.toList());\n        System.out.println("Even numbers: " + evenNumbers);\n\n        // Predicate combination\n        Predicate<Integer> evenAndGreaterThanFive = isEven.and(isGreaterThanFive);\n        Predicate<Integer> evenOrGreaterThanFive = isEven.or(isGreaterThanFive);\n        Predicate<Integer> notEven = isEven.negate();\n\n        System.out.println("Even and > 5: " +\n            numbers.stream().filter(evenAndGreaterThanFive).collect(Collectors.toList()));\n        System.out.println("Even or > 5: " +\n            numbers.stream().filter(evenOrGreaterThanFive).collect(Collectors.toList()));\n        System.out.println("Odd numbers: " +\n            numbers.stream().filter(notEven).collect(Collectors.toList()));\n\n        // String predicates\n        List<String> words = Arrays.asList("apple", "banana", "cherry", "date", "elderberry");\n\n        Predicate<String> startsWithA = s -> s.startsWith("a");\n        Predicate<String> longerThanFive = s -> s.length() > 5;\n        Predicate<String> containsE = s -> s.contains("e");\n\n        System.out.println("Starts with \'a\': " +\n            words.stream().filter(startsWithA).collect(Collectors.toList()));\n        System.out.println("Longer than 5 chars: " +\n            words.stream().filter(longerThanFive).collect(Collectors.toList()));\n        System.out.println("Contains \'e\': " +\n            words.stream().filter(containsE).collect(Collectors.toList()));\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h2,{id:"method-references",children:"Method References"}),"\n",(0,a.jsx)(e.p,{children:"Method references provide a shorthand syntax for lambda expressions that call a single method."}),"\n",(0,a.jsx)(e.h3,{id:"types-of-method-references",children:"Types of Method References"}),"\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"Type"}),(0,a.jsx)(e.th,{children:"Syntax"}),(0,a.jsx)(e.th,{children:"Example"})]})}),(0,a.jsxs)(e.tbody,{children:[(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"Static method"}),(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"ClassName::staticMethod"})}),(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"Integer::parseInt"})})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"Instance method of particular object"}),(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"object::instanceMethod"})}),(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"myObj::toString"})})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"Instance method of arbitrary object"}),(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"ClassName::instanceMethod"})}),(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"String::length"})})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"Constructor"}),(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"ClassName::new"})}),(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"ArrayList::new"})})]})]})]}),"\n",(0,a.jsx)(e.h3,{id:"method-reference-examples",children:"Method Reference Examples"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'import java.util.function.*;\nimport java.util.stream.Collectors;\n\npublic class MethodReferenceExamples {\n    public static void main(String[] args) {\n        List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "Diana");\n        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);\n\n        // 1. Static method reference\n        // Lambda: s -> Integer.parseInt(s)\n        Function<String, Integer> parseInt = Integer::parseInt;\n        List<String> numberStrings = Arrays.asList("1", "2", "3", "4", "5");\n        List<Integer> parsed = numberStrings.stream()\n                                          .map(parseInt)\n                                          .collect(Collectors.toList());\n        System.out.println("Parsed numbers: " + parsed);\n\n        // 2. Instance method of particular object\n        PrintStream out = System.out;\n        Consumer<String> printer = out::println;  // Same as s -> System.out.println(s)\n        names.forEach(printer);\n\n        // 3. Instance method of arbitrary object of particular type\n        // Lambda: s -> s.length()\n        Function<String, Integer> lengthFunc = String::length;\n        List<Integer> lengths = names.stream()\n                                   .map(lengthFunc)\n                                   .collect(Collectors.toList());\n        System.out.println("Name lengths: " + lengths);\n\n        // Lambda: s -> s.toUpperCase()\n        Function<String, String> upperCaseFunc = String::toUpperCase;\n        List<String> upperCaseNames = names.stream()\n                                         .map(upperCaseFunc)\n                                         .collect(Collectors.toList());\n        System.out.println("Uppercase names: " + upperCaseNames);\n\n        // 4. Constructor reference\n        // Lambda: () -> new ArrayList<>()\n        Supplier<List<String>> listSupplier = ArrayList::new;\n        List<String> newList = listSupplier.get();\n        newList.add("Created with constructor reference");\n        System.out.println(newList);\n\n        // Constructor with parameter\n        // Lambda: capacity -> new ArrayList<>(capacity)\n        Function<Integer, List<String>> listWithCapacity = ArrayList::new;\n        List<String> capacityList = listWithCapacity.apply(10);\n\n        // Comparison: Lambda vs Method Reference\n        System.out.println("\\n--- Lambda vs Method Reference Comparison ---");\n\n        // Using lambda\n        numbers.stream().map(n -> n.toString()).forEach(s -> System.out.println(s));\n\n        // Using method references\n        numbers.stream().map(Object::toString).forEach(System.out::println);\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"advanced-method-reference-usage",children:"Advanced Method Reference Usage"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'public class Person {\n    private String name;\n    private int age;\n\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() { return name; }\n    public int getAge() { return age; }\n\n    public static int compareByAge(Person p1, Person p2) {\n        return Integer.compare(p1.age, p2.age);\n    }\n\n    public int compareByName(Person other) {\n        return this.name.compareTo(other.name);\n    }\n\n    @Override\n    public String toString() {\n        return name + "(" + age + ")";\n    }\n}\n\npublic class AdvancedMethodReferences {\n    public static void main(String[] args) {\n        List<Person> people = Arrays.asList(\n            new Person("Alice", 30),\n            new Person("Bob", 25),\n            new Person("Charlie", 35),\n            new Person("Diana", 28)\n        );\n\n        System.out.println("Original: " + people);\n\n        // Static method reference for comparison\n        List<Person> sortedByAge = people.stream()\n                                        .sorted(Person::compareByAge)\n                                        .collect(Collectors.toList());\n        System.out.println("Sorted by age: " + sortedByAge);\n\n        // Instance method reference\n        List<String> names = people.stream()\n                                  .map(Person::getName)\n                                  .collect(Collectors.toList());\n        System.out.println("Names: " + names);\n\n        // Constructor reference with custom object\n        Function<String, Person> personFactory = name -> new Person(name, 0);\n        // This could be written as a constructor reference if Person had appropriate constructor\n\n        List<Person> newPeople = Arrays.asList("Eve", "Frank", "Grace")\n                                      .stream()\n                                      .map(personFactory)\n                                      .collect(Collectors.toList());\n        System.out.println("New people: " + newPeople);\n    }\n}\n'})}),"\n",(0,a.jsx)(e.hr,{}),"\n",(0,a.jsx)(e.h1,{id:"part-3-regular-expressions-1",children:"Part 3: Regular Expressions"}),"\n",(0,a.jsx)(e.h2,{id:"regex-fundamentals",children:"Regex Fundamentals"}),"\n",(0,a.jsx)(e.p,{children:"A regular expression (regex) is a sequence of characters that forms a search pattern. When you search for data in a text, you can use this search pattern to describe what you are searching for."}),"\n",(0,a.jsx)(e.h3,{id:"java-regex-classes",children:"Java Regex Classes"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:(0,a.jsx)(e.code,{children:"Pattern"})})," - Defines a pattern (to be used in a search)"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:(0,a.jsx)(e.code,{children:"Matcher"})})," - Used to search for the pattern"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:(0,a.jsx)(e.code,{children:"PatternSyntaxException"})})," - Indicates syntax error in a regular expression pattern"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"pattern-and-matcher-classes",children:"Pattern and Matcher Classes"}),"\n",(0,a.jsx)(e.h3,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'import java.util.regex.Pattern;\nimport java.util.regex.Matcher;\n\npublic class BasicRegexExample {\n    public static void main(String[] args) {\n        String text = "Visit W3Schools for Java tutorials!";\n        String pattern = "w3schools";\n\n        // Case-sensitive search\n        Pattern compiledPattern = Pattern.compile(pattern);\n        Matcher matcher = compiledPattern.matcher(text);\n\n        if (matcher.find()) {\n            System.out.println("Match found at position: " + matcher.start());\n            System.out.println("Matched text: " + matcher.group());\n        } else {\n            System.out.println("No match found");\n        }\n\n        // Case-insensitive search\n        Pattern caseInsensitive = Pattern.compile(pattern, Pattern.CASE_INSENSITIVE);\n        Matcher caseInsensitiveMatcher = caseInsensitive.matcher(text);\n\n        if (caseInsensitiveMatcher.find()) {\n            System.out.println("Case-insensitive match found!");\n            System.out.println("Match: " + caseInsensitiveMatcher.group());\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"pattern-flags",children:"Pattern Flags"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'public class PatternFlagsExample {\n    public static void main(String[] args) {\n        String text = "Hello WORLD\\nThis is a\\nmultiline text";\n\n        // CASE_INSENSITIVE flag\n        Pattern pattern1 = Pattern.compile("hello", Pattern.CASE_INSENSITIVE);\n        System.out.println("Case insensitive match: " + pattern1.matcher(text).find());\n\n        // MULTILINE flag - ^ and $ match line boundaries\n        Pattern pattern2 = Pattern.compile("^This", Pattern.MULTILINE);\n        System.out.println("Multiline match: " + pattern2.matcher(text).find());\n\n        // DOTALL flag - . matches any character including newlines\n        Pattern pattern3 = Pattern.compile("Hello.*text", Pattern.DOTALL);\n        System.out.println("Dot all match: " + pattern3.matcher(text).find());\n\n        // Combining flags\n        Pattern combined = Pattern.compile("hello.*world",\n                                         Pattern.CASE_INSENSITIVE | Pattern.DOTALL);\n        System.out.println("Combined flags match: " + combined.matcher(text).find());\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"matcher-methods",children:"Matcher Methods"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'public class MatcherMethodsExample {\n    public static void main(String[] args) {\n        String text = "The quick brown fox jumps over the lazy dog";\n        Pattern pattern = Pattern.compile("\\\\b\\\\w{4}\\\\b"); // 4-letter words\n\n        Matcher matcher = pattern.matcher(text);\n\n        System.out.println("Finding all 4-letter words:");\n        while (matcher.find()) {\n            System.out.println("Found: \'" + matcher.group() +\n                             "\' at position " + matcher.start() +\n                             "-" + matcher.end());\n        }\n\n        // Reset matcher for new operations\n        matcher.reset();\n\n        // Count matches\n        long count = matcher.results().count();\n        System.out.println("Total 4-letter words: " + count);\n\n        // Replace operations\n        String replaced = matcher.replaceAll("WORD");\n        System.out.println("After replacement: " + replaced);\n\n        matcher.reset();\n        String replacedFirst = matcher.replaceFirst("FIRST");\n        System.out.println("After replacing first: " + replacedFirst);\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h2,{id:"common-regex-patterns",children:"Common Regex Patterns"}),"\n",(0,a.jsx)(e.h3,{id:"character-classes-and-metacharacters",children:"Character Classes and Metacharacters"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'public class RegexPatternsExample {\n    public static void main(String[] args) {\n        String[] testStrings = {\n            "Hello123",\n            "test@email.com",\n            "Phone: 123-456-7890",\n            "Price: $29.99",\n            "Date: 2024-01-15"\n        };\n\n        // Test various patterns\n        testPattern("\\\\d+", testStrings, "Digits");\n        testPattern("\\\\w+", testStrings, "Word characters");\n        testPattern("\\\\s+", testStrings, "Whitespace");\n        testPattern("[A-Z]+", testStrings, "Uppercase letters");\n        testPattern("[a-z]+", testStrings, "Lowercase letters");\n        testPattern("\\\\$\\\\d+\\\\.\\\\d{2}", testStrings, "Price format");\n        testPattern("\\\\d{4}-\\\\d{2}-\\\\d{2}", testStrings, "Date format YYYY-MM-DD");\n        testPattern("\\\\w+@\\\\w+\\\\.\\\\w+", testStrings, "Simple email pattern");\n    }\n\n    private static void testPattern(String regex, String[] texts, String description) {\n        System.out.println("\\n--- Testing: " + description + " (" + regex + ") ---");\n        Pattern pattern = Pattern.compile(regex);\n\n        for (String text : texts) {\n            Matcher matcher = pattern.matcher(text);\n            System.out.print("\\"" + text + "\\" -> ");\n\n            if (matcher.find()) {\n                System.out.print("Found: ");\n                matcher.reset();\n                while (matcher.find()) {\n                    System.out.print("\'" + matcher.group() + "\' ");\n                }\n                System.out.println();\n            } else {\n                System.out.println("No match");\n            }\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"quantifiers",children:"Quantifiers"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'public class QuantifiersExample {\n    public static void main(String[] args) {\n        String text = "aaa bb cccc d eeeeee";\n\n        // + : one or more\n        testQuantifier("a+", text, "One or more \'a\'");\n\n        // * : zero or more\n        testQuantifier("b*", text, "Zero or more \'b\'");\n\n        // ? : zero or one\n        testQuantifier("d?", text, "Zero or one \'d\'");\n\n        // {n} : exactly n\n        testQuantifier("c{4}", text, "Exactly 4 \'c\'");\n\n        // {n,m} : between n and m\n        testQuantifier("e{2,4}", text, "Between 2 and 4 \'e\'");\n\n        // {n,} : n or more\n        testQuantifier("e{3,}", text, "3 or more \'e\'");\n\n        // Greedy vs non-greedy\n        String html = "<div>content</div><span>more</span>";\n        System.out.println("\\nGreedy vs Non-greedy:");\n        testQuantifier("<.+>", html, "Greedy: any character between < and >");\n        testQuantifier("<.+?>", html, "Non-greedy: any character between < and >");\n    }\n\n    private static void testQuantifier(String regex, String text, String description) {\n        System.out.println(description + " (" + regex + "):");\n        Pattern pattern = Pattern.compile(regex);\n        Matcher matcher = pattern.matcher(text);\n\n        while (matcher.find()) {\n            System.out.println("  Found: \'" + matcher.group() +\n                             "\' at " + matcher.start() + "-" + matcher.end());\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"groups-and-capturing",children:"Groups and Capturing"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'public class GroupsExample {\n    public static void main(String[] args) {\n        String text = "Contact: John Doe (john.doe@email.com) Phone: 123-456-7890";\n\n        // Named groups for email extraction\n        String emailPattern = "(\\\\w+)\\\\.(\\\\w+)@(\\\\w+)\\\\.(\\\\w+)";\n        Pattern pattern = Pattern.compile(emailPattern);\n        Matcher matcher = pattern.matcher(text);\n\n        if (matcher.find()) {\n            System.out.println("Full match: " + matcher.group(0));\n            System.out.println("First name: " + matcher.group(1));\n            System.out.println("Last name: " + matcher.group(2));\n            System.out.println("Domain: " + matcher.group(3));\n            System.out.println("TLD: " + matcher.group(4));\n        }\n\n        // Phone number pattern with groups\n        String phonePattern = "(\\\\d{3})-(\\\\d{3})-(\\\\d{4})";\n        Pattern phonePatternCompiled = Pattern.compile(phonePattern);\n        Matcher phoneMatcher = phonePatternCompiled.matcher(text);\n\n        if (phoneMatcher.find()) {\n            System.out.println("\\nPhone number breakdown:");\n            System.out.println("Full number: " + phoneMatcher.group(0));\n            System.out.println("Area code: " + phoneMatcher.group(1));\n            System.out.println("Exchange: " + phoneMatcher.group(2));\n            System.out.println("Number: " + phoneMatcher.group(3));\n        }\n\n        // Non-capturing groups (?:...)\n        String nonCapturingPattern = "(?:Mr|Ms|Dr)\\\\. (\\\\w+ \\\\w+)";\n        Pattern nonCapturing = Pattern.compile(nonCapturingPattern);\n        String titleText = "Dr. Jane Smith and Mr. John Doe";\n        Matcher titleMatcher = nonCapturing.matcher(titleText);\n\n        System.out.println("\\nNon-capturing groups (titles ignored):");\n        while (titleMatcher.find()) {\n            System.out.println("Name only: " + titleMatcher.group(1));\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h2,{id:"practical-regex-examples",children:"Practical Regex Examples"}),"\n",(0,a.jsx)(e.h3,{id:"email-validation",children:"Email Validation"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'public class EmailValidationExample {\n    private static final String EMAIL_PATTERN =\n        "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}$";\n\n    private static final Pattern pattern = Pattern.compile(EMAIL_PATTERN);\n\n    public static boolean isValidEmail(String email) {\n        return pattern.matcher(email).matches();\n    }\n\n    public static void main(String[] args) {\n        String[] emails = {\n            "user@example.com",           // Valid\n            "test.email@domain.co.uk",    // Valid\n            "user+tag@example.com",       // Valid\n            "invalid-email",              // Invalid\n            "@example.com",               // Invalid\n            "user@",                      // Invalid\n            "user@domain",                // Invalid\n            "user name@domain.com"        // Invalid (space)\n        };\n\n        System.out.println("Email Validation Results:");\n        for (String email : emails) {\n            System.out.printf("%-25s -> %s%n",\n                email, isValidEmail(email) ? "VALID" : "INVALID");\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"phone-number-extraction-and-formatting",children:"Phone Number Extraction and Formatting"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'public class PhoneNumberExample {\n    public static void main(String[] args) {\n        String text = "Call me at 123-456-7890 or (555) 123-4567 or 555.987.6543";\n\n        // Different phone number patterns\n        String[] phonePatterns = {\n            "\\\\d{3}-\\\\d{3}-\\\\d{4}",           // 123-456-7890\n            "\\\\(\\\\d{3}\\\\) \\\\d{3}-\\\\d{4}",     // (555) 123-4567\n            "\\\\d{3}\\\\.\\\\d{3}\\\\.\\\\d{4}"        // 555.987.6543\n        };\n\n        System.out.println("Original text: " + text);\n        System.out.println("\\nFound phone numbers:");\n\n        for (String patternStr : phonePatterns) {\n            Pattern pattern = Pattern.compile(patternStr);\n            Matcher matcher = pattern.matcher(text);\n\n            while (matcher.find()) {\n                System.out.println("Pattern: " + patternStr + " -> " + matcher.group());\n            }\n        }\n\n        // Universal phone pattern and formatting\n        String universalPattern = "(?:\\\\(?(\\\\d{3})\\\\)?[-.\\\\s]?(\\\\d{3})[-.\\\\s]?(\\\\d{4}))";\n        Pattern universal = Pattern.compile(universalPattern);\n        Matcher universalMatcher = universal.matcher(text);\n\n        System.out.println("\\nFormatted phone numbers:");\n        while (universalMatcher.find()) {\n            String formatted = String.format("(%s) %s-%s",\n                universalMatcher.group(1),\n                universalMatcher.group(2),\n                universalMatcher.group(3));\n            System.out.println("Original: " + universalMatcher.group() +\n                             " -> Formatted: " + formatted);\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"log-file-parsing",children:"Log File Parsing"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'public class LogParsingExample {\n    public static void main(String[] args) {\n        String[] logLines = {\n            "2024-01-15 10:30:45 [INFO] User login successful - user: john_doe",\n            "2024-01-15 10:31:02 [ERROR] Database connection failed - timeout after 30s",\n            "2024-01-15 10:31:15 [WARN] Memory usage at 85% - threshold exceeded",\n            "2024-01-15 10:32:00 [INFO] File upload completed - size: 2.5MB"\n        };\n\n        // Log pattern: timestamp [level] message\n        String logPattern = "(\\\\d{4}-\\\\d{2}-\\\\d{2} \\\\d{2}:\\\\d{2}:\\\\d{2}) \\\\[(\\\\w+)\\\\] (.+)";\n        Pattern pattern = Pattern.compile(logPattern);\n\n        System.out.println("Parsed log entries:");\n        for (String logLine : logLines) {\n            Matcher matcher = pattern.matcher(logLine);\n\n            if (matcher.find()) {\n                String timestamp = matcher.group(1);\n                String level = matcher.group(2);\n                String message = matcher.group(3);\n\n                System.out.printf("Timestamp: %s | Level: %-5s | Message: %s%n",\n                    timestamp, level, message);\n            }\n        }\n\n        // Filter by log level\n        System.out.println("\\nERROR level logs only:");\n        Pattern errorPattern = Pattern.compile(".*\\\\[ERROR\\\\].*");\n        for (String logLine : logLines) {\n            if (errorPattern.matcher(logLine).matches()) {\n                System.out.println(logLine);\n            }\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"text-processing-and-cleaning",children:"Text Processing and Cleaning"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'public class TextProcessingExample {\n    public static void main(String[] args) {\n        String messyText = "  Hello,    world!!!   How   are you???  \\n\\n  Fine, thanks!  ";\n\n        System.out.println("Original text: \'" + messyText + "\'");\n\n        // Remove extra whitespace\n        String cleanWhitespace = messyText.replaceAll("\\\\s+", " ").trim();\n        System.out.println("Clean whitespace: \'" + cleanWhitespace + "\'");\n\n        // Remove multiple punctuation marks\n        String cleanPunctuation = cleanWhitespace.replaceAll("[!?]{2,}", "!");\n        System.out.println("Clean punctuation: \'" + cleanPunctuation + "\'");\n\n        // Extract words only (remove punctuation)\n        String wordsOnly = cleanPunctuation.replaceAll("[^a-zA-Z\\\\s]", "");\n        System.out.println("Words only: \'" + wordsOnly + "\'");\n\n        // Split into words\n        String[] words = wordsOnly.split("\\\\s+");\n        System.out.println("Word count: " + words.length);\n        System.out.println("Words: " + Arrays.toString(words));\n\n        // Find and replace with pattern\n        String htmlText = "<p>This is a <strong>bold</strong> text with <em>emphasis</em></p>";\n        String cleanHtml = htmlText.replaceAll("<[^>]+>", "");\n        System.out.println("\\nHTML text: " + htmlText);\n        System.out.println("Clean text: " + cleanHtml);\n    }\n}\n'})}),"\n",(0,a.jsx)(e.hr,{}),"\n",(0,a.jsx)(e.h1,{id:"part-4-annotations-1",children:"Part 4: Annotations"}),"\n",(0,a.jsx)(e.h2,{id:"understanding-annotations",children:"Understanding Annotations"}),"\n",(0,a.jsxs)(e.p,{children:["Annotations are special notes you add to your Java code. They start with the ",(0,a.jsx)(e.code,{children:"@"})," symbol. They don't change how your program runs, but they give extra information to the compiler, development tools, or frameworks."]}),"\n",(0,a.jsx)(e.h3,{id:"benefits-of-annotations",children:"Benefits of Annotations:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Compile-time checking"}),": Help catch errors during compilation"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Code generation"}),": Tools can generate code based on annotations"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Runtime processing"}),": Can be processed at runtime for frameworks"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Documentation"}),": Provide metadata about code elements"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"built-in-annotations",children:"Built-in Annotations"}),"\n",(0,a.jsx)(e.h3,{id:"override-annotation",children:"@Override Annotation"}),"\n",(0,a.jsxs)(e.p,{children:["The ",(0,a.jsx)(e.code,{children:"@Override"})," annotation indicates that a method overrides a method in a superclass."]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'class Animal {\n    void makeSound() {\n        System.out.println("Animal sound");\n    }\n\n    void move() {\n        System.out.println("Animal moves");\n    }\n}\n\nclass Dog extends Animal {\n    @Override\n    void makeSound() {\n        System.out.println("Woof!");\n    }\n\n    @Override\n    void move() {\n        System.out.println("Dog runs");\n    }\n\n    // This will cause a compile error if uncommented\n    // @Override\n    // void makesound() { // Typo in method name\n    //     System.out.println("Woof!");\n    // }\n}\n\npublic class OverrideExample {\n    public static void main(String[] args) {\n        Animal myDog = new Dog();\n        myDog.makeSound(); // Output: Woof!\n        myDog.move();      // Output: Dog runs\n\n        // Demonstrating polymorphism\n        Animal[] animals = {new Animal(), new Dog()};\n        for (Animal animal : animals) {\n            animal.makeSound();\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"deprecated-annotation",children:"@Deprecated Annotation"}),"\n",(0,a.jsxs)(e.p,{children:["The ",(0,a.jsx)(e.code,{children:"@Deprecated"})," annotation marks methods, classes, or fields as outdated."]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'public class DeprecatedExample {\n\n    @Deprecated\n    public static void oldMethod() {\n        System.out.println("This is an old method");\n    }\n\n    @Deprecated(since = "2.0", forRemoval = true)\n    public static void veryOldMethod() {\n        System.out.println("This method will be removed");\n    }\n\n    public static void newMethod() {\n        System.out.println("Use this new method instead");\n    }\n\n    public static void main(String[] args) {\n        // These calls will show deprecation warnings\n        oldMethod();        // Warning: deprecated\n        veryOldMethod();    // Warning: deprecated and marked for removal\n\n        // This is the recommended approach\n        newMethod();        // No warning\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"suppresswarnings-annotation",children:"@SuppressWarnings Annotation"}),"\n",(0,a.jsxs)(e.p,{children:["The ",(0,a.jsx)(e.code,{children:"@SuppressWarnings"})," annotation tells the compiler to ignore specific warnings."]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'import java.util.*;\n\npublic class SuppressWarningsExample {\n\n    @SuppressWarnings("unchecked")\n    public static void uncheckedExample() {\n        // Raw type usage (normally causes warning)\n        List rawList = new ArrayList();\n        rawList.add("String");\n        rawList.add(42);\n\n        System.out.println("Raw list: " + rawList);\n    }\n\n    @SuppressWarnings("deprecation")\n    public static void deprecationExample() {\n        // Using deprecated method (normally causes warning)\n        DeprecatedExample.oldMethod();\n    }\n\n    @SuppressWarnings({"unchecked", "rawtypes"})\n    public static void multipleWarnings() {\n        Map rawMap = new HashMap();\n        rawMap.put("key", "value");\n        System.out.println("Raw map: " + rawMap);\n    }\n\n    @SuppressWarnings("unused")\n    public static void unusedVariableExample() {\n        int unusedVariable = 42; // This would normally cause a warning\n        // Variable is not used, but warning is suppressed\n    }\n\n    public static void main(String[] args) {\n        uncheckedExample();\n        deprecationExample();\n        multipleWarnings();\n        unusedVariableExample();\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"other-built-in-annotations",children:"Other Built-in Annotations"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'public class OtherAnnotationsExample {\n\n    // @SafeVarargs - suppresses warnings about varargs\n    @SafeVarargs\n    public static <T> void printAll(T... items) {\n        for (T item : items) {\n            System.out.println(item);\n        }\n    }\n\n    // @FunctionalInterface - ensures interface has only one abstract method\n    @FunctionalInterface\n    interface Calculator {\n        int calculate(int a, int b);\n\n        // Default methods are allowed\n        default void printResult(int result) {\n            System.out.println("Result: " + result);\n        }\n\n        // Static methods are allowed\n        static void info() {\n            System.out.println("This is a calculator interface");\n        }\n    }\n\n    public static void main(String[] args) {\n        // Using @SafeVarargs method\n        printAll("Hello", "World", "Java");\n        printAll(1, 2, 3, 4, 5);\n\n        // Using @FunctionalInterface\n        Calculator add = (a, b) -> a + b;\n        Calculator multiply = (a, b) -> a * b;\n\n        int sum = add.calculate(5, 3);\n        int product = multiply.calculate(5, 3);\n\n        add.printResult(sum);      // Result: 8\n        multiply.printResult(product); // Result: 15\n\n        Calculator.info(); // This is a calculator interface\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h2,{id:"custom-annotations",children:"Custom Annotations"}),"\n",(0,a.jsx)(e.h3,{id:"creating-custom-annotations",children:"Creating Custom Annotations"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'import java.lang.annotation.*;\n\n// Custom annotation for marking methods as test methods\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\n@interface Test {\n    String description() default "";\n    int priority() default 1;\n    boolean enabled() default true;\n}\n\n// Custom annotation for class-level information\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@interface Author {\n    String name();\n    String email() default "";\n    String version() default "1.0";\n}\n\n// Custom annotation for field validation\n@Target(ElementType.FIELD)\n@Retention(RetentionPolicy.RUNTIME)\n@interface Required {\n    String message() default "Field is required";\n}\n\n@Author(name = "John Doe", email = "john@example.com", version = "2.0")\npublic class CustomAnnotationExample {\n\n    @Required(message = "Name cannot be empty")\n    private String name;\n\n    @Required\n    private String email;\n\n    private int age; // Not required\n\n    public CustomAnnotationExample(String name, String email, int age) {\n        this.name = name;\n        this.email = email;\n        this.age = age;\n    }\n\n    @Test(description = "Test basic functionality", priority = 1)\n    public void testBasicFunction() {\n        System.out.println("Running basic test");\n    }\n\n    @Test(description = "Test advanced functionality", priority = 2, enabled = false)\n    public void testAdvancedFunction() {\n        System.out.println("Running advanced test");\n    }\n\n    @Test(description = "Test error handling", priority = 3)\n    public void testErrorHandling() {\n        System.out.println("Running error handling test");\n    }\n\n    // Method without annotation\n    public void regularMethod() {\n        System.out.println("Regular method - not a test");\n    }\n\n    // Getters and setters\n    public String getName() { return name; }\n    public void setName(String name) { this.name = name; }\n    public String getEmail() { return email; }\n    public void setEmail(String email) { this.email = email; }\n    public int getAge() { return age; }\n    public void setAge(int age) { this.age = age; }\n}\n'})}),"\n",(0,a.jsx)(e.h2,{id:"annotation-processing",children:"Annotation Processing"}),"\n",(0,a.jsx)(e.h3,{id:"runtime-annotation-processing",children:"Runtime Annotation Processing"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'import java.lang.reflect.*;\n\npublic class AnnotationProcessor {\n\n    public static void runTests(Object testInstance) {\n        Class<?> clazz = testInstance.getClass();\n\n        // Process class-level annotations\n        if (clazz.isAnnotationPresent(Author.class)) {\n            Author author = clazz.getAnnotation(Author.class);\n            System.out.println("Author: " + author.name());\n            System.out.println("Email: " + author.email());\n            System.out.println("Version: " + author.version());\n            System.out.println();\n        }\n\n        // Find and run test methods\n        Method[] methods = clazz.getDeclaredMethods();\n\n        for (Method method : methods) {\n            if (method.isAnnotationPresent(Test.class)) {\n                Test testAnnotation = method.getAnnotation(Test.class);\n\n                if (testAnnotation.enabled()) {\n                    System.out.println("Running test: " + method.getName());\n                    System.out.println("Description: " + testAnnotation.description());\n                    System.out.println("Priority: " + testAnnotation.priority());\n\n                    try {\n                        method.invoke(testInstance);\n                        System.out.println("\u2713 Test passed\\n");\n                    } catch (Exception e) {\n                        System.out.println("\u2717 Test failed: " + e.getMessage() + "\\n");\n                    }\n                } else {\n                    System.out.println("\u26a0 Test skipped (disabled): " + method.getName() + "\\n");\n                }\n            }\n        }\n    }\n\n    public static void validateRequiredFields(Object obj) {\n        Class<?> clazz = obj.getClass();\n        Field[] fields = clazz.getDeclaredFields();\n\n        System.out.println("Validating required fields for: " + clazz.getSimpleName());\n\n        for (Field field : fields) {\n            if (field.isAnnotationPresent(Required.class)) {\n                Required required = field.getAnnotation(Required.class);\n                field.setAccessible(true);\n\n                try {\n                    Object value = field.get(obj);\n                    if (value == null || (value instanceof String && ((String) value).isEmpty())) {\n                        System.out.println("\u2717 Validation failed for field \'" + field.getName() +\n                                         "\': " + required.message());\n                    } else {\n                        System.out.println("\u2713 Field \'" + field.getName() + "\' is valid");\n                    }\n                } catch (IllegalAccessException e) {\n                    System.out.println("\u2717 Cannot access field: " + field.getName());\n                }\n            }\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        // Create test instances\n        CustomAnnotationExample validExample =\n            new CustomAnnotationExample("John Doe", "john@example.com", 30);\n\n        CustomAnnotationExample invalidExample =\n            new CustomAnnotationExample("", null, 25);\n\n        // Validate required fields\n        validateRequiredFields(validExample);\n        validateRequiredFields(invalidExample);\n\n        // Run tests\n        System.out.println("=== Running Tests ===");\n        runTests(validExample);\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"meta-annotations",children:"Meta-Annotations"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'import java.lang.annotation.*;\n\n// Meta-annotations example\n@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@interface Performance {\n    String value() default "";\n    long maxExecutionTime() default 1000; // milliseconds\n}\n\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\n@Repeatable(Benchmarks.class) // Java 8 feature\n@interface Benchmark {\n    String name();\n    int iterations() default 1;\n}\n\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\n@interface Benchmarks {\n    Benchmark[] value();\n}\n\n@Performance("High performance class")\npublic class MetaAnnotationExample {\n\n    @Performance(maxExecutionTime = 500)\n    @Benchmark(name = "QuickSort", iterations = 100)\n    @Benchmark(name = "MergeSort", iterations = 50)\n    public void sortingAlgorithmTest() {\n        // Simulate some processing\n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n        System.out.println("Sorting algorithm test completed");\n    }\n\n    @Performance(maxExecutionTime = 2000)\n    public void databaseOperationTest() {\n        System.out.println("Database operation test completed");\n    }\n\n    public static void main(String[] args) {\n        MetaAnnotationExample example = new MetaAnnotationExample();\n        Class<?> clazz = example.getClass();\n\n        // Process class-level annotation\n        if (clazz.isAnnotationPresent(Performance.class)) {\n            Performance perf = clazz.getAnnotation(Performance.class);\n            System.out.println("Class performance info: " + perf.value());\n        }\n\n        // Process method-level annotations\n        Method[] methods = clazz.getDeclaredMethods();\n        for (Method method : methods) {\n            if (method.isAnnotationPresent(Performance.class)) {\n                Performance perf = method.getAnnotation(Performance.class);\n                System.out.println("Method: " + method.getName());\n                System.out.println("Max execution time: " + perf.maxExecutionTime() + "ms");\n            }\n\n            // Process repeatable annotations\n            Benchmark[] benchmarks = method.getAnnotationsByType(Benchmark.class);\n            for (Benchmark benchmark : benchmarks) {\n                System.out.println("Benchmark: " + benchmark.name() +\n                                 " (iterations: " + benchmark.iterations() + ")");\n            }\n            System.out.println();\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,a.jsx)(e.h3,{id:"wrapper-classes-key-points",children:"Wrapper Classes Key Points"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Purpose"}),": Convert primitives to objects for use with collections and generics"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Autoboxing/Unboxing"}),": Automatic conversion between primitives and wrappers"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Null Safety"}),": Be careful with null wrapper objects to avoid NullPointerException"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Caching"}),": Integer values -128 to 127 are cached (use ",(0,a.jsx)(e.code,{children:".equals()"})," for comparison)"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Utility Methods"}),": Rich set of parsing, conversion, and comparison methods"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"lambda-expressions-key-points",children:"Lambda Expressions Key Points"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Syntax"}),": ",(0,a.jsx)(e.code,{children:"(parameters) -> expression"})," or ",(0,a.jsx)(e.code,{children:"(parameters) -> { code block }"})]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Functional Interfaces"}),": Must have exactly one abstract method (SAM)"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Built-in Interfaces"}),": Consumer, Supplier, Function, Predicate are most common"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Method References"}),": Shorthand syntax for lambdas (",(0,a.jsx)(e.code,{children:"ClassName::method"}),")"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Benefits"}),": More concise code, better support for functional programming"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"regular-expressions-key-points",children:"Regular Expressions Key Points"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Pattern & Matcher"}),": Core classes for regex operations in Java"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Metacharacters"}),": ",(0,a.jsx)(e.code,{children:"\\d"}),", ",(0,a.jsx)(e.code,{children:"\\w"}),", ",(0,a.jsx)(e.code,{children:"\\s"}),", ",(0,a.jsx)(e.code,{children:"."}),", ",(0,a.jsx)(e.code,{children:"^"}),", `# Java Wrapper Classes, Lambda, Regex & Annotations - Comprehensive Notes"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"table-of-contents-1",children:"Table of Contents"}),"\n",(0,a.jsx)(e.h3,{id:"part-1-wrapper-classes-2",children:"Part 1: Wrapper Classes"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#what-are-wrapper-classes",children:"What are Wrapper Classes?"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#primitive-to-wrapper-mapping",children:"Primitive to Wrapper Mapping"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#autoboxing-and-unboxing",children:"Autoboxing and Unboxing"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#wrapper-class-methods",children:"Wrapper Class Methods"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#practical-usage",children:"Practical Usage"})}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"part-2-lambda-expressions-2",children:"Part 2: Lambda Expressions"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#introduction-to-lambda",children:"Introduction to Lambda"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#lambda-syntax",children:"Lambda Syntax"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#functional-interfaces",children:"Functional Interfaces"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#built-in-functional-interfaces",children:"Built-in Functional Interfaces"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#method-references",children:"Method References"})}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"part-3-regular-expressions-2",children:"Part 3: Regular Expressions"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#regex-fundamentals",children:"Regex Fundamentals"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#pattern-and-matcher-classes",children:"Pattern and Matcher Classes"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#common-regex-patterns",children:"Common Regex Patterns"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#practical-regex-examples",children:"Practical Regex Examples"})}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"part-4-annotations-2",children:"Part 4: Annotations"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#understanding-annotations",children:"Understanding Annotations"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#built-in-annotations",children:"Built-in Annotations"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#custom-annotations",children:"Custom Annotations"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#annotation-processing",children:"Annotation Processing"})}),"\n"]}),"\n",(0,a.jsx)(e.hr,{}),"\n",(0,a.jsx)(e.h1,{id:"part-1-wrapper-classes-3",children:"Part 1: Wrapper Classes"}),"\n",(0,a.jsx)(e.h2,{id:"what-are-wrapper-classes-1",children:"What are Wrapper Classes?"}),"\n",(0,a.jsx)(e.p,{children:"Wrapper classes provide a way to use primitive data types (int, boolean, etc..) as objects."}),"\n",(0,a.jsx)(e.h3,{id:"why-wrapper-classes-1",children:"Why Wrapper Classes?"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Collections Requirement"}),": Collections like ArrayList can only store objects, not primitives"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Method Availability"}),": Wrapper classes provide useful methods for data conversion"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Null Support"}),": Wrapper classes can hold null values, primitives cannot"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Generic Type Parameters"}),": Required for generics (e.g., ",(0,a.jsx)(e.code,{children:"List<Integer>"}),")"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"primitive-to-wrapper-mapping-1",children:"Primitive to Wrapper Mapping"}),"\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"Primitive Type"}),(0,a.jsx)(e.th,{children:"Wrapper Class"}),(0,a.jsx)(e.th,{children:"Size (bytes)"}),(0,a.jsx)(e.th,{children:"Range"})]})}),(0,a.jsxs)(e.tbody,{children:[(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"byte"})}),(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"Byte"})}),(0,a.jsx)(e.td,{children:"1"}),(0,a.jsx)(e.td,{children:"-128 to 127"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"short"})}),(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"Short"})}),(0,a.jsx)(e.td,{children:"2"}),(0,a.jsx)(e.td,{children:"-32,768 to 32,767"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"int"})}),(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"Integer"})}),(0,a.jsx)(e.td,{children:"4"}),(0,a.jsx)(e.td,{children:"-2\xb3\xb9 to 2\xb3\xb9-1"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"long"})}),(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"Long"})}),(0,a.jsx)(e.td,{children:"8"}),(0,a.jsx)(e.td,{children:"-2\u2076\xb3 to 2\u2076\xb3-1"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"float"})}),(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"Float"})}),(0,a.jsx)(e.td,{children:"4"}),(0,a.jsx)(e.td,{children:"\xb13.4E\xb138 (7 digits)"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"double"})}),(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"Double"})}),(0,a.jsx)(e.td,{children:"8"}),(0,a.jsx)(e.td,{children:"\xb11.7E\xb1308 (15 digits)"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"boolean"})}),(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"Boolean"})}),(0,a.jsx)(e.td,{children:"1 bit"}),(0,a.jsx)(e.td,{children:"true/false"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"char"})}),(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"Character"})}),(0,a.jsx)(e.td,{children:"2"}),(0,a.jsx)(e.td,{children:"0 to 65,535 (Unicode)"})]})]})]}),"\n",(0,a.jsx)(e.h2,{id:"autoboxing-and-unboxing-1",children:"Autoboxing and Unboxing"}),"\n",(0,a.jsx)(e.h3,{id:"autoboxing-primitive-to-wrapper-1",children:"Autoboxing (Primitive to Wrapper)"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:"public class AutoboxingExample {\n    public static void main(String[] args) {\n        // Automatic conversion from primitive to wrapper\n        Integer myInt = 5;           // int -> Integer\n        Double myDouble = 5.99;      // double -> Double\n        Boolean myBoolean = true;    // boolean -> Boolean\n        Character myChar = 'A';      // char -> Character\n\n        System.out.println(myInt);     // Output: 5\n        System.out.println(myDouble);  // Output: 5.99\n        System.out.println(myBoolean); // Output: true\n        System.out.println(myChar);    // Output: A\n\n        // Collections with autoboxing\n        ArrayList<Integer> numbers = new ArrayList<>();\n        numbers.add(10);    // Automatically boxes int to Integer\n        numbers.add(20);\n        numbers.add(30);\n    }\n}\n"})}),"\n",(0,a.jsx)(e.h3,{id:"unboxing-wrapper-to-primitive-1",children:"Unboxing (Wrapper to Primitive)"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'public class UnboxingExample {\n    public static void main(String[] args) {\n        Integer wrapperInt = 100;\n        Double wrapperDouble = 25.5;\n\n        // Automatic conversion from wrapper to primitive\n        int primitiveInt = wrapperInt;        // Integer -> int\n        double primitiveDouble = wrapperDouble; // Double -> double\n\n        // Arithmetic operations trigger unboxing\n        Integer a = 10;\n        Integer b = 20;\n        int sum = a + b;  // Both Integer objects are unboxed to int\n\n        System.out.println("Sum: " + sum); // Output: Sum: 30\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"null-pointer-exception-risk-1",children:"Null Pointer Exception Risk"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'public class NPEExample {\n    public static void main(String[] args) {\n        Integer nullInteger = null;\n\n        try {\n            int value = nullInteger; // NullPointerException!\n        } catch (NullPointerException e) {\n            System.out.println("Cannot unbox null wrapper: " + e.getMessage());\n        }\n\n        // Safe approach\n        if (nullInteger != null) {\n            int safeValue = nullInteger;\n            System.out.println("Safe value: " + safeValue);\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h2,{id:"wrapper-class-methods-1",children:"Wrapper Class Methods"}),"\n",(0,a.jsx)(e.h3,{id:"value-extraction-methods-1",children:"Value Extraction Methods"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'public class ValueExtractionExample {\n    public static void main(String[] args) {\n        Integer intWrapper = 42;\n        Double doubleWrapper = 3.14159;\n        Character charWrapper = \'Z\';\n        Boolean boolWrapper = true;\n\n        // Extract primitive values\n        int intValue = intWrapper.intValue();\n        byte byteValue = intWrapper.byteValue();\n        double doubleValue = intWrapper.doubleValue();\n\n        double doubleVal = doubleWrapper.doubleValue();\n        float floatVal = doubleWrapper.floatValue();\n        int truncatedInt = doubleWrapper.intValue(); // Truncates decimal\n\n        char charValue = charWrapper.charValue();\n        boolean boolValue = boolWrapper.booleanValue();\n\n        System.out.println("Integer as int: " + intValue);        // 42\n        System.out.println("Integer as byte: " + byteValue);      // 42\n        System.out.println("Integer as double: " + doubleValue); // 42.0\n        System.out.println("Double truncated: " + truncatedInt); // 3\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"string-conversion-methods-1",children:"String Conversion Methods"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'public class StringConversionExample {\n    public static void main(String[] args) {\n        Integer number = 12345;\n        Double decimal = 98.76;\n        Boolean flag = true;\n\n        // Convert to string\n        String numberStr = number.toString();\n        String decimalStr = decimal.toString();\n        String flagStr = flag.toString();\n\n        System.out.println("Number as string: " + numberStr);   // "12345"\n        System.out.println("String length: " + numberStr.length()); // 5\n\n        // Static toString methods\n        String binaryStr = Integer.toString(number, 2);  // Binary\n        String hexStr = Integer.toString(number, 16);    // Hexadecimal\n        String octalStr = Integer.toString(number, 8);   // Octal\n\n        System.out.println("Binary: " + binaryStr);   // "11000000111001"\n        System.out.println("Hex: " + hexStr);         // "3039"\n        System.out.println("Octal: " + octalStr);     // "30071"\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"parsing-methods-1",children:"Parsing Methods"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'public class ParsingExample {\n    public static void main(String[] args) {\n        // String to primitive/wrapper conversion\n        String intStr = "123";\n        String doubleStr = "45.67";\n        String boolStr = "true";\n\n        // Parse to primitives\n        int parsedInt = Integer.parseInt(intStr);\n        double parsedDouble = Double.parseDouble(doubleStr);\n        boolean parsedBool = Boolean.parseBoolean(boolStr);\n\n        // Parse to wrapper objects\n        Integer wrapperInt = Integer.valueOf(intStr);\n        Double wrapperDouble = Double.valueOf(doubleStr);\n        Boolean wrapperBool = Boolean.valueOf(boolStr);\n\n        System.out.println("Parsed int: " + parsedInt);\n        System.out.println("Wrapper int: " + wrapperInt);\n\n        // Parse with different radix\n        String binaryStr = "1010";\n        String hexStr = "FF";\n        int fromBinary = Integer.parseInt(binaryStr, 2);  // Binary to int\n        int fromHex = Integer.parseInt(hexStr, 16);       // Hex to int\n\n        System.out.println("Binary 1010 as int: " + fromBinary); // 10\n        System.out.println("Hex FF as int: " + fromHex);         // 255\n\n        // Error handling\n        try {\n            int invalid = Integer.parseInt("not a number");\n        } catch (NumberFormatException e) {\n            System.out.println("Invalid number format: " + e.getMessage());\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"comparison-methods-1",children:"Comparison Methods"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'public class ComparisonExample {\n    public static void main(String[] args) {\n        Integer a = 100;\n        Integer b = 200;\n        Integer c = 100;\n\n        // Compare wrapper objects\n        System.out.println("a.equals(c): " + a.equals(c));           // true\n        System.out.println("a == c: " + (a == c));                  // true (cached)\n\n        Integer x = 128;\n        Integer y = 128;\n        System.out.println("x.equals(y): " + x.equals(y));          // true\n        System.out.println("x == y: " + (x == y));                  // false (not cached)\n\n        // Compare values\n        int comparison = a.compareTo(b);\n        System.out.println("a compared to b: " + comparison);       // -1 (a < b)\n\n        // Static compare methods\n        int staticComp = Integer.compare(a, b);\n        System.out.println("Static compare: " + staticComp);        // -1\n\n        // Max and min values\n        System.out.println("Integer MAX: " + Integer.MAX_VALUE);\n        System.out.println("Integer MIN: " + Integer.MIN_VALUE);\n        System.out.println("Double MAX: " + Double.MAX_VALUE);\n        System.out.println("Double MIN: " + Double.MIN_VALUE);\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h2,{id:"practical-usage-1",children:"Practical Usage"}),"\n",(0,a.jsx)(e.h3,{id:"working-with-collections-1",children:"Working with Collections"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'import java.util.*;\n\npublic class CollectionUsage {\n    public static void main(String[] args) {\n        // List of integers\n        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);\n\n        // Sum using wrapper methods\n        int sum = numbers.stream()\n                        .mapToInt(Integer::intValue)\n                        .sum();\n        System.out.println("Sum: " + sum);\n\n        // Map with wrapper keys and values\n        Map<Integer, String> numberNames = new HashMap<>();\n        numberNames.put(1, "One");\n        numberNames.put(2, "Two");\n        numberNames.put(3, "Three");\n\n        // Process map entries\n        numberNames.forEach((key, value) ->\n            System.out.println(key.toString() + " -> " + value));\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"utility-methods-example-1",children:"Utility Methods Example"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'public class UtilityMethodsExample {\n    public static void main(String[] args) {\n        // Integer utility methods\n        System.out.println("Bit count of 7: " + Integer.bitCount(7));      // 3\n        System.out.println("Leading zeros: " + Integer.numberOfLeadingZeros(8)); // 28\n        System.out.println("Reverse bits: " + Integer.reverse(1));         // -2147483648\n\n        // Character utility methods\n        System.out.println("Is digit: " + Character.isDigit(\'5\'));         // true\n        System.out.println("Is letter: " + Character.isLetter(\'A\'));       // true\n        System.out.println("To uppercase: " + Character.toUpperCase(\'a\')); // A\n        System.out.println("To lowercase: " + Character.toLowerCase(\'Z\')); // z\n\n        // Boolean utility methods\n        System.out.println("Logical AND: " + Boolean.logicalAnd(true, false)); // false\n        System.out.println("Logical OR: " + Boolean.logicalOr(true, false));   // true\n        System.out.println("Logical XOR: " + Boolean.logicalXor(true, false)); // true\n    }\n}\n'})}),"\n",(0,a.jsx)(e.hr,{}),"\n",(0,a.jsx)(e.h1,{id:"part-2-lambda-expressions-3",children:"Part 2: Lambda Expressions"}),"\n",(0,a.jsx)(e.h2,{id:"introduction-to-lambda-1",children:"Introduction to Lambda"}),"\n",(0,a.jsx)(e.p,{children:"Lambda Expressions were added in Java 8. A lambda expression is a short block of code which takes in parameters and returns a value. Lambda expressions are similar to methods, but they do not need a name and they can be implemented right in the body of a method."}),"\n",(0,a.jsx)(e.h3,{id:"benefits-of-lambda-expressions-1",children:"Benefits of Lambda Expressions:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Concise Code"}),": Reduce boilerplate code"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Functional Programming"}),": Enable functional programming paradigms"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Better Collections"}),": Work seamlessly with Streams API"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Parallel Processing"}),": Easier parallel operations"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"lambda-syntax-1",children:"Lambda Syntax"}),"\n",(0,a.jsx)(e.h3,{id:"basic-syntax-forms-1",children:"Basic Syntax Forms"}),"\n",(0,a.jsx)(e.p,{children:"The simplest lambda expression contains a single parameter and an expression:\nparameter -> expression"}),"\n",(0,a.jsx)(e.p,{children:"To use more than one parameter, wrap them in parentheses:\n(parameter1, parameter2) -> expression"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'// Single parameter (parentheses optional)\nx -> x * 2\nn -> System.out.println(n)\n\n// Multiple parameters (parentheses required)\n(a, b) -> a + b\n(x, y) -> Math.max(x, y)\n\n// No parameters\n() -> System.out.println("Hello")\n() -> Math.random()\n\n// Code block with return statement\n(a, b) -> {\n    int sum = a + b;\n    return sum * 2;\n}\n\n// Code block without return (void)\nn -> {\n    System.out.println("Processing: " + n);\n    // Some complex logic here\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"lambda-expression-examples-1",children:"Lambda Expression Examples"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'import java.util.*;\nimport java.util.function.*;\n\npublic class LambdaSyntaxExamples {\n    public static void main(String[] args) {\n        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);\n\n        // Traditional approach with anonymous class\n        numbers.forEach(new Consumer<Integer>() {\n            @Override\n            public void accept(Integer n) {\n                System.out.println(n);\n            }\n        });\n\n        // Lambda expression - single line\n        numbers.forEach(n -> System.out.println(n));\n\n        // Lambda expression - method reference\n        numbers.forEach(System.out::println);\n\n        // Lambda with filtering\n        numbers.stream()\n               .filter(n -> n % 2 == 0)\n               .forEach(System.out::println);\n\n        // Lambda with transformation\n        List<String> strings = numbers.stream()\n                                     .map(n -> "Number: " + n)\n                                     .collect(Collectors.toList());\n        System.out.println(strings);\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h2,{id:"functional-interfaces-1",children:"Functional Interfaces"}),"\n",(0,a.jsx)(e.h3,{id:"what-is-a-functional-interface-1",children:"What is a Functional Interface?"}),"\n",(0,a.jsx)(e.p,{children:"A functional interface has exactly one abstract method (Single Abstract Method - SAM). Lambda expressions can be used wherever a functional interface is expected."}),"\n",(0,a.jsx)(e.h3,{id:"functionalinterface-annotation-1",children:"@FunctionalInterface Annotation"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'@FunctionalInterface\ninterface MathOperation {\n    int operate(int a, int b);\n\n    // Default methods are allowed\n    default void printResult(int result) {\n        System.out.println("Result: " + result);\n    }\n\n    // Static methods are allowed\n    static void printInfo() {\n        System.out.println("This is a math operation interface");\n    }\n}\n\npublic class FunctionalInterfaceExample {\n    public static void main(String[] args) {\n        // Lambda expressions implementing the interface\n        MathOperation addition = (a, b) -> a + b;\n        MathOperation subtraction = (a, b) -> a - b;\n        MathOperation multiplication = (a, b) -> a * b;\n        MathOperation division = (a, b) -> a / b;\n\n        // Using the lambda expressions\n        System.out.println("10 + 5 = " + addition.operate(10, 5));\n        System.out.println("10 - 5 = " + subtraction.operate(10, 5));\n        System.out.println("10 * 5 = " + multiplication.operate(10, 5));\n        System.out.println("10 / 5 = " + division.operate(10, 5));\n\n        // Using default method\n        addition.printResult(addition.operate(10, 5));\n\n        // Using static method\n        MathOperation.printInfo();\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"custom-functional-interface-example-1",children:"Custom Functional Interface Example"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'@FunctionalInterface\ninterface StringProcessor {\n    String process(String input);\n}\n\npublic class CustomFunctionalInterface {\n    public static void main(String[] args) {\n        // Various lambda implementations\n        StringProcessor uppercase = s -> s.toUpperCase();\n        StringProcessor lowercase = s -> s.toLowerCase();\n        StringProcessor reverse = s -> new StringBuilder(s).reverse().toString();\n        StringProcessor addExclamation = s -> s + "!";\n\n        String text = "Hello World";\n\n        System.out.println("Original: " + text);\n        System.out.println("Uppercase: " + processString(text, uppercase));\n        System.out.println("Lowercase: " + processString(text, lowercase));\n        System.out.println("Reversed: " + processString(text, reverse));\n        System.out.println("With exclamation: " + processString(text, addExclamation));\n    }\n\n    public static String processString(String input, StringProcessor processor) {\n        return processor.process(input);\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h2,{id:"built-in-functional-interfaces-1",children:"Built-in Functional Interfaces"}),"\n",(0,a.jsxs)(e.p,{children:["Java provides many built-in functional interfaces in the ",(0,a.jsx)(e.code,{children:"java.util.function"})," package:"]}),"\n",(0,a.jsx)(e.h3,{id:"core-functional-interfaces-1",children:"Core Functional Interfaces"}),"\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"Interface"}),(0,a.jsx)(e.th,{children:"Method"}),(0,a.jsx)(e.th,{children:"Description"}),(0,a.jsx)(e.th,{children:"Example"})]})}),(0,a.jsxs)(e.tbody,{children:[(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"Consumer<T>"})}),(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"void accept(T t)"})}),(0,a.jsx)(e.td,{children:"Consumes an input, returns nothing"}),(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"s -> System.out.println(s)"})})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"Supplier<T>"})}),(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"T get()"})}),(0,a.jsx)(e.td,{children:"Supplies a value, takes no input"}),(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"() -> Math.random()"})})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"Function<T,R>"})}),(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"R apply(T t)"})}),(0,a.jsx)(e.td,{children:"Takes input T, returns output R"}),(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"s -> s.length()"})})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"Predicate<T>"})}),(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"boolean test(T t)"})}),(0,a.jsx)(e.td,{children:"Tests a condition, returns boolean"}),(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"n -> n > 0"})})]})]})]}),"\n",(0,a.jsx)(e.h3,{id:"consumer-examples-1",children:"Consumer Examples"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'import java.util.function.Consumer;\nimport java.util.function.BiConsumer;\n\npublic class ConsumerExamples {\n    public static void main(String[] args) {\n        List<String> names = Arrays.asList("Alice", "Bob", "Charlie");\n\n        // Consumer - single parameter\n        Consumer<String> printer = name -> System.out.println("Hello, " + name);\n        names.forEach(printer);\n\n        // BiConsumer - two parameters\n        BiConsumer<String, Integer> indexedPrinter =\n            (name, index) -> System.out.println(index + ": " + name);\n\n        for (int i = 0; i < names.size(); i++) {\n            indexedPrinter.accept(names.get(i), i + 1);\n        }\n\n        // Consumer chaining\n        Consumer<String> upperCase = s -> System.out.println(s.toUpperCase());\n        Consumer<String> lowerCase = s -> System.out.println(s.toLowerCase());\n        Consumer<String> combined = upperCase.andThen(lowerCase);\n\n        combined.accept("Hello World");\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"supplier-examples-1",children:"Supplier Examples"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'import java.util.function.Supplier;\nimport java.util.Random;\n\npublic class SupplierExamples {\n    public static void main(String[] args) {\n        // Simple suppliers\n        Supplier<String> messageSupplier = () -> "Hello from supplier!";\n        Supplier<Double> randomSupplier = () -> Math.random();\n        Supplier<Integer> diceRoll = () -> new Random().nextInt(6) + 1;\n\n        System.out.println(messageSupplier.get());\n        System.out.println("Random: " + randomSupplier.get());\n        System.out.println("Dice roll: " + diceRoll.get());\n\n        // Supplier with complex logic\n        Supplier<List<String>> listSupplier = () -> {\n            List<String> list = new ArrayList<>();\n            list.add("Item 1");\n            list.add("Item 2");\n            list.add("Item 3");\n            return list;\n        };\n\n        List<String> items = listSupplier.get();\n        System.out.println("Generated list: " + items);\n\n        // Lazy evaluation example\n        System.out.println("Getting value lazily: " + getValue(randomSupplier));\n    }\n\n    public static String getValue(Supplier<Double> supplier) {\n        // Value is only generated when needed\n        double value = supplier.get();\n        return value > 0.5 ? "High: " + value : "Low: " + value;\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"function-examples-1",children:"Function Examples"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'import java.util.function.Function;\nimport java.util.function.BiFunction;\n\npublic class FunctionExamples {\n    public static void main(String[] args) {\n        List<String> words = Arrays.asList("hello", "world", "java", "lambda");\n\n        // Function - transform string to its length\n        Function<String, Integer> lengthFunction = s -> s.length();\n\n        List<Integer> lengths = words.stream()\n                                   .map(lengthFunction)\n                                   .collect(Collectors.toList());\n        System.out.println("Lengths: " + lengths);\n\n        // Function chaining\n        Function<String, String> upperCase = s -> s.toUpperCase();\n        Function<String, String> addExclamation = s -> s + "!";\n        Function<String, String> combined = upperCase.andThen(addExclamation);\n\n        System.out.println(combined.apply("hello")); // "HELLO!"\n\n        // BiFunction - two parameters\n        BiFunction<Integer, Integer, Integer> multiply = (a, b) -> a * b;\n        BiFunction<String, String, String> concat = (s1, s2) -> s1 + " " + s2;\n\n        System.out.println("3 * 4 = " + multiply.apply(3, 4));\n        System.out.println("Concatenated: " + concat.apply("Hello", "World"));\n\n        // Function composition\n        Function<Integer, Integer> doubleValue = x -> x * 2;\n        Function<Integer, Integer> addTen = x -> x + 10;\n\n        // compose: first apply addTen, then doubleValue\n        Function<Integer, Integer> composed1 = doubleValue.compose(addTen);\n        System.out.println("Compose (5+10)*2 = " + composed1.apply(5)); // 30\n\n        // andThen: first apply doubleValue, then addTen\n        Function<Integer, Integer> composed2 = doubleValue.andThen(addTen);\n        System.out.println("AndThen (5*2)+10 = " + composed2.apply(5)); // 20\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"predicate-examples-1",children:"Predicate Examples"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'import java.util.function.Predicate;\n\npublic class PredicateExamples {\n    public static void main(String[] args) {\n        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n\n        // Simple predicates\n        Predicate<Integer> isEven = n -> n % 2 == 0;\n        Predicate<Integer> isPositive = n -> n > 0;\n        Predicate<Integer> isGreaterThanFive = n -> n > 5;\n\n        // Filter using predicates\n        List<Integer> evenNumbers = numbers.stream()\n                                          .filter(isEven)\n                                          .collect(Collectors.toList());\n        System.out.println("Even numbers: " + evenNumbers);\n\n        // Predicate combination\n        Predicate<Integer> evenAndGreaterThanFive = isEven.and(isGreaterThanFive);\n        Predicate<Integer> evenOrGreaterThanFive = isEven.or(isGreaterThanFive);\n        Predicate<Integer> notEven = isEven.negate();\n\n        System.out.println("Even and > 5: " +\n            numbers.stream().filter(evenAndGreaterThanFive).collect(Collectors.toList()));\n        System.out.println("Even or > 5: " +\n            numbers.stream().filter(evenOrGreaterThanFive).collect(Collectors.toList()));\n        System.out.println("Odd numbers: " +\n            numbers.stream().filter(notEven).collect(Collectors.toList()));\n\n        // String predicates\n        List<String> words = Arrays.asList("apple", "banana", "cherry", "date", "elderberry");\n\n        Predicate<String> startsWithA = s -> s.startsWith("a");\n        Predicate<String> longerThanFive = s -> s.length() > 5;\n        Predicate<String> containsE = s -> s.contains("e");\n\n        System.out.println("Starts with \'a\': " +\n            words.stream().filter(startsWithA).collect(Collectors.toList()));\n        System.out.println("Longer than 5 chars: " +\n            words.stream().filter(longerThanFive).collect(Collectors.toList()));\n        System.out.println("Contains \'e\': " +\n            words.stream().filter(containsE).collect(Collectors.toList()));\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h2,{id:"method-references-1",children:"Method References"}),"\n",(0,a.jsx)(e.p,{children:"Method references provide a shorthand syntax for lambda expressions that call a single method."}),"\n",(0,a.jsx)(e.h3,{id:"types-of-method-references-1",children:"Types of Method References"}),"\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"Type"}),(0,a.jsx)(e.th,{children:"Syntax"}),(0,a.jsx)(e.th,{children:"Example"})]})}),(0,a.jsxs)(e.tbody,{children:[(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"Static method"}),(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"ClassName::staticMethod"})}),(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"Integer::parseInt"})})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"Instance method of particular object"}),(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"object::instanceMethod"})}),(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"myObj::toString"})})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"Instance method of arbitrary object"}),(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"ClassName::instanceMethod"})}),(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"String::length"})})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"Constructor"}),(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"ClassName::new"})}),(0,a.jsx)(e.td,{children:(0,a.jsx)(e.code,{children:"ArrayList::new"})})]})]})]}),"\n",(0,a.jsx)(e.h3,{id:"method-reference-examples-1",children:"Method Reference Examples"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'import java.util.function.*;\nimport java.util.stream.Collectors;\n\npublic class MethodReferenceExamples {\n    public static void main(String[] args) {\n        List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "Diana");\n        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);\n\n        // 1. Static method reference\n        // Lambda: s -> Integer.parseInt(s)\n        Function<String, Integer> parseInt = Integer::parseInt;\n        List<String> numberStrings = Arrays.asList("1", "2", "3", "4", "5");\n        List<Integer> parsed = numberStrings.stream()\n                                          .map(parseInt)\n                                          .collect(Collectors.toList());\n        System.out.println("Parsed numbers: " + parsed);\n\n        // 2. Instance method of particular object\n        PrintStream out = System.out;\n        Consumer<String> printer = out::println;  // Same as s -> System.out.println(s)\n        names.forEach(printer);\n\n        // 3. Instance method of arbitrary object of particular type\n        // Lambda: s -> s.length()\n        Function<String, Integer> lengthFunc = String::length;\n        List<Integer> lengths = names.stream()\n                                   .map(lengthFunc)\n                                   .collect(Collectors.toList());\n        System.out.println("Name lengths: " + lengths);\n\n        // Lambda: s -> s.toUpperCase()\n        Function<String, String> upperCaseFunc = String::toUpperCase;\n        List<String> upperCaseNames = names.stream()\n                                         .map(upperCaseFunc)\n                                         .collect(Collectors.toList());\n        System.out.println("Uppercase names: " + upperCaseNames);\n\n        // 4. Constructor reference\n        // Lambda: () -> new ArrayList<>()\n        Supplier<List<String>> listSupplier = ArrayList::new;\n        List<String> newList = listSupplier.get();\n        newList.add("Created with constructor reference");\n        System.out.println(newList);\n\n        // Constructor with parameter\n        // Lambda: capacity -> new ArrayList<>(capacity)\n        Function<Integer, List<String>> listWithCapacity = ArrayList::new;\n        List<String> capacityList = listWithCapacity.apply(10);\n\n        // Comparison: Lambda vs Method Reference\n        System.out.println("\\n--- Lambda vs Method Reference Comparison ---");\n\n        // Using lambda\n        numbers.stream().map(n -> n.toString()).forEach(s -> System.out.println(s));\n\n        // Using method references\n        numbers.stream().map(Object::toString).forEach(System.out::println);\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"advanced-method-reference-usage-1",children:"Advanced Method Reference Usage"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'public class Person {\n    private String name;\n    private int age;\n\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() { return name; }\n    public int getAge() { return age; }\n\n    public static int compareByAge(Person p1, Person p2) {\n        return Integer.compare(p1.age, p2.age);\n    }\n\n    public int compareByName(Person other) {\n        return this.name.compareTo(other.name);\n    }\n\n    @Override\n    public String toString() {\n        return name + "(" + age + ")";\n    }\n}\n\npublic class AdvancedMethodReferences {\n    public static void main(String[] args) {\n        List<Person> people = Arrays.asList(\n            new Person("Alice", 30),\n            new Person("Bob", 25),\n            new Person("Charlie", 35),\n            new Person("Diana", 28)\n        );\n\n        System.out.println("Original: " + people);\n\n        // Static method reference for comparison\n        List<Person> sortedByAge = people.stream()\n                                        .sorted(Person::compareByAge)\n                                        .collect(Collectors.toList());\n        System.out.println("Sorted by age: " + sortedByAge);\n\n        // Instance method reference\n        List<String> names = people.stream()\n                                  .map(Person::getName)\n                                  .collect(Collectors.toList());\n        System.out.println("Names: " + names);\n\n        // Constructor reference with custom object\n        Function<String, Person> personFactory = name -> new Person(name, 0);\n        // This could be written as a constructor reference if Person had appropriate constructor\n\n        List<Person> newPeople = Arrays.asList("Eve", "Frank", "Grace")\n                                      .stream()\n                                      .map(personFactory)\n                                      .collect(Collectors.toList());\n        System.out.println("New people: " + newPeople);\n    }\n}\n'})}),"\n",(0,a.jsx)(e.hr,{}),"\n",(0,a.jsx)(e.h1,{id:"part-3-regular-expressions-3",children:"Part 3: Regular Expressions"}),"\n",(0,a.jsx)(e.h2,{id:"regex-fundamentals-1",children:"Regex Fundamentals"}),"\n",(0,a.jsx)(e.p,{children:"A regular expression (regex) is a sequence of characters that forms a search pattern. When you search for data in a text, you can use this search pattern to describe what you are searching for."}),"\n",(0,a.jsx)(e.h3,{id:"java-regex-classes-1",children:"Java Regex Classes"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:(0,a.jsx)(e.code,{children:"Pattern"})})," - Defines a pattern (to be used in a search)"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:(0,a.jsx)(e.code,{children:"Matcher"})})," - Used to search for the pattern"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:(0,a.jsx)(e.code,{children:"PatternSyntaxException"})})," - Indicates syntax error in a regular expression pattern"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"pattern-and-matcher-classes-1",children:"Pattern and Matcher Classes"}),"\n",(0,a.jsx)(e.h3,{id:"basic-usage-1",children:"Basic Usage"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'import java.util.regex.Pattern;\nimport java.util.regex.Matcher;\n\npublic class BasicRegexExample {\n    public static void main(String[] args) {\n        String text = "Visit W3Schools for Java tutorials!";\n        String pattern = "w3schools";\n\n        // Case-sensitive search\n        Pattern compiledPattern = Pattern.compile(pattern);\n        Matcher matcher = compiledPattern.matcher(text);\n\n        if (matcher.find()) {\n            System.out.println("Match found at position: " + matcher.start());\n            System.out.println("Matched text: " + matcher.group());\n        } else {\n            System.out.println("No match found");\n        }\n\n        // Case-insensitive search\n        Pattern caseInsensitive = Pattern.compile(pattern, Pattern.CASE_INSENSITIVE);\n        Matcher caseInsensitiveMatcher = caseInsensitive.matcher(text);\n\n        if (caseInsensitiveMatcher.find()) {\n            System.out.println("Case-insensitive match found!");\n            System.out.println("Match: " + caseInsensitiveMatcher.group());\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"pattern-flags-1",children:"Pattern Flags"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'public class PatternFlagsExample {\n    public static void main(String[] args) {\n        String text = "Hello WORLD\\nThis is a\\nmultiline text";\n\n        // CASE_INSENSITIVE flag\n        Pattern pattern1 = Pattern.compile("hello", Pattern.CASE_INSENSITIVE);\n        System.out.println("Case insensitive match: " + pattern1.matcher(text).find());\n\n        // MULTILINE flag - ^ and $ match line boundaries\n        Pattern pattern2 = Pattern.compile("^This", Pattern.MULTILINE);\n        System.out.println("Multiline match: " + pattern2.matcher(text).find());\n\n        // DOTALL flag - . matches any character including newlines\n        Pattern pattern3 = Pattern.compile("Hello.*text", Pattern.DOTALL);\n        System.out.println("Dot all match: " + pattern3.matcher(text).find());\n\n        // Combining flags\n        Pattern combined = Pattern.compile("hello.*world",\n                                         Pattern.CASE_INSENSITIVE | Pattern.DOTALL);\n        System.out.println("Combined flags match: " + combined.matcher(text).find());\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"matcher-methods-1",children:"Matcher Methods"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'public class MatcherMethodsExample {\n    public static void main(String[] args) {\n        String text = "The quick brown fox jumps over the lazy dog";\n        Pattern pattern = Pattern.compile("\\\\b\\\\w{4}\\\\b"); // 4-letter words\n\n        Matcher matcher = pattern.matcher(text);\n\n        System.out.println("Finding all 4-letter words:");\n        while (matcher.find()) {\n            System.out.println("Found: \'" + matcher.group() +\n                             "\' at position " + matcher.start() +\n                             "-" + matcher.end());\n        }\n\n        // Reset matcher for new operations\n        matcher.reset();\n\n        // Count matches\n        long count = matcher.results().count();\n        System.out.println("Total 4-letter words: " + count);\n\n        // Replace operations\n        String replaced = matcher.replaceAll("WORD");\n        System.out.println("After replacement: " + replaced);\n\n        matcher.reset();\n        String replacedFirst = matcher.replaceFirst("FIRST");\n        System.out.println("After replacing first: " + replacedFirst);\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h2,{id:"common-regex-patterns-1",children:"Common Regex Patterns"}),"\n",(0,a.jsx)(e.h3,{id:"character-classes-and-metacharacters-1",children:"Character Classes and Metacharacters"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'public class RegexPatternsExample {\n    public static void main(String[] args) {\n        String[] testStrings = {\n            "Hello123",\n            "test@email.com",\n            "Phone: 123-456-7890",\n            "Price: $29.99",\n            "Date: 2024-01-15"\n        };\n\n        // Test various patterns\n        testPattern("\\\\d+", testStrings, "Digits");\n        testPattern("\\\\w+", testStrings, "Word characters");\n        testPattern("\\\\s+", testStrings, "Whitespace");\n        testPattern("[A-Z]+", testStrings, "Uppercase letters");\n        testPattern("[a-z]+", testStrings, "Lowercase letters");\n        testPattern("\\\\$\\\\d+\\\\.\\\\d{2}", testStrings, "Price format");\n        testPattern("\\\\d{4}-\\\\d{2}-\\\\d{2}", testStrings, "Date format YYYY-MM-DD");\n        testPattern("\\\\w+@\\\\w+\\\\.\\\\w+", testStrings, "Simple email pattern");\n    }\n\n    private static void testPattern(String regex, String[] texts, String description) {\n        System.out.println("\\n--- Testing: " + description + " (" + regex + ") ---");\n        Pattern pattern = Pattern.compile(regex);\n\n        for (String text : texts) {\n            Matcher matcher = pattern.matcher(text);\n            System.out.print("\\"" + text + "\\" -> ");\n\n            if (matcher.find()) {\n                System.out.print("Found: ");\n                matcher.reset();\n                while (matcher.find()) {\n                    System.out.print("\'" + matcher.group() + "\' ");\n                }\n                System.out.println();\n            } else {\n                System.out.println("No match");\n            }\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"quantifiers-1",children:"Quantifiers"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'public class QuantifiersExample {\n    public static void main(String[] args) {\n        String text = "aaa bb cccc d eeeeee";\n\n        // + : one or more\n        testQuantifier("a+", text, "One or more \'a\'");\n\n        // * : zero or more\n        testQuantifier("b*", text, "Zero or more \'b\'");\n\n        // ? : zero or one\n        testQuantifier("d?", text, "Zero or one \'d\'");\n\n        // {n} : exactly n\n        testQuantifier("c{4}", text, "Exactly 4 \'c\'");\n\n        // {n,m} : between n and m\n        testQuantifier("e{2,4}", text, "Between 2 and 4 \'e\'");\n\n        // {n,} : n or more\n        testQuantifier("e{3,}", text, "3 or more \'e\'");\n\n        // Greedy vs non-greedy\n        String html = "<div>content</div><span>more</span>";\n        System.out.println("\\nGreedy vs Non-greedy:");\n        testQuantifier("<.+>", html, "Greedy: any character between < and >");\n        testQuantifier("<.+?>", html, "Non-greedy: any character between < and >");\n    }\n\n    private static void testQuantifier(String regex, String text, String description) {\n        System.out.println(description + " (" + regex + "):");\n        Pattern pattern = Pattern.compile(regex);\n        Matcher matcher = pattern.matcher(text);\n\n        while (matcher.find()) {\n            System.out.println("  Found: \'" + matcher.group() +\n                             "\' at " + matcher.start() + "-" + matcher.end());\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"groups-and-capturing-1",children:"Groups and Capturing"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'public class GroupsExample {\n    public static void main(String[] args) {\n        String text = "Contact: John Doe (john.doe@email.com) Phone: 123-456-7890";\n\n        // Named groups for email extraction\n        String emailPattern = "(\\\\w+)\\\\.(\\\\w+)@(\\\\w+)\\\\.(\\\\w+)";\n        Pattern pattern = Pattern.compile(emailPattern);\n        Matcher matcher = pattern.matcher(text);\n\n        if (matcher.find()) {\n            System.out.println("Full match: " + matcher.group(0));\n            System.out.println("First name: " + matcher.group(1));\n            System.out.println("Last name: " + matcher.group(2));\n            System.out.println("Domain: " + matcher.group(3));\n            System.out.println("TLD: " + matcher.group(4));\n        }\n\n        // Phone number pattern with groups\n        String phonePattern = "(\\\\d{3})-(\\\\d{3})-(\\\\d{4})";\n        Pattern phonePatternCompiled = Pattern.compile(phonePattern);\n        Matcher phoneMatcher = phonePatternCompiled.matcher(text);\n\n        if (phoneMatcher.find()) {\n            System.out.println("\\nPhone number breakdown:");\n            System.out.println("Full number: " + phoneMatcher.group(0));\n            System.out.println("Area code: " + phoneMatcher.group(1));\n            System.out.println("Exchange: " + phoneMatcher.group(2));\n            System.out.println("Number: " + phoneMatcher.group(3));\n        }\n\n        // Non-capturing groups (?:...)\n        String nonCapturingPattern = "(?:Mr|Ms|Dr)\\\\. (\\\\w+ \\\\w+)";\n        Pattern nonCapturing = Pattern.compile(nonCapturingPattern);\n        String titleText = "Dr. Jane Smith and Mr. John Doe";\n        Matcher titleMatcher = nonCapturing.matcher(titleText);\n\n        System.out.println("\\nNon-capturing groups (titles ignored):");\n        while (titleMatcher.find()) {\n            System.out.println("Name only: " + titleMatcher.group(1));\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h2,{id:"practical-regex-examples-1",children:"Practical Regex Examples"}),"\n",(0,a.jsx)(e.h3,{id:"email-validation-1",children:"Email Validation"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'public class EmailValidationExample {\n    private static final String EMAIL_PATTERN =\n        "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}$";\n\n    private static final Pattern pattern = Pattern.compile(EMAIL_PATTERN);\n\n    public static boolean isValidEmail(String email) {\n        return pattern.matcher(email).matches();\n    }\n\n    public static void main(String[] args) {\n        String[] emails = {\n            "user@example.com",           // Valid\n            "test.email@domain.co.uk",    // Valid\n            "user+tag@example.com",       // Valid\n            "invalid-email",              // Invalid\n            "@example.com",               // Invalid\n            "user@",                      // Invalid\n            "user@domain",                // Invalid\n            "user name@domain.com"        // Invalid (space)\n        };\n\n        System.out.println("Email Validation Results:");\n        for (String email : emails) {\n            System.out.printf("%-25s -> %s%n",\n                email, isValidEmail(email) ? "VALID" : "INVALID");\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"phone-number-extraction-and-formatting-1",children:"Phone Number Extraction and Formatting"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'public class PhoneNumberExample {\n    public static void main(String[] args) {\n        String text = "Call me at 123-456-7890 or (555) 123-4567 or 555.987.6543";\n\n        // Different phone number patterns\n        String[] phonePatterns = {\n            "\\\\d{3}-\\\\d{3}-\\\\d{4}",           // 123-456-7890\n            "\\\\(\\\\d{3}\\\\) \\\\d{3}-\\\\d{4}",     // (555) 123-4567\n            "\\\\d{3}\\\\.\\\\d{3}\\\\.\\\\d{4}"        // 555.987.6543\n        };\n\n        System.out.println("Original text: " + text);\n        System.out.println("\\nFound phone numbers:");\n\n        for (String patternStr : phonePatterns) {\n            Pattern pattern = Pattern.compile(patternStr);\n            Matcher matcher = pattern.matcher(text);\n\n            while (matcher.find()) {\n                System.out.println("Pattern: " + patternStr + " -> " + matcher.group());\n            }\n        }\n\n        // Universal phone pattern and formatting\n        String universalPattern = "(?:\\\\(?(\\\\d{3})\\\\)?[-.\\\\s]?(\\\\d{3})[-.\\\\s]?(\\\\d{4}))";\n        Pattern universal = Pattern.compile(universalPattern);\n        Matcher universalMatcher = universal.matcher(text);\n\n        System.out.println("\\nFormatted phone numbers:");\n        while (universalMatcher.find()) {\n            String formatted = String.format("(%s) %s-%s",\n                universalMatcher.group(1),\n                universalMatcher.group(2),\n                universalMatcher.group(3));\n            System.out.println("Original: " + universalMatcher.group() +\n                             " -> Formatted: " + formatted);\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"log-file-parsing-1",children:"Log File Parsing"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'public class LogParsingExample {\n    public static void main(String[] args) {\n        String[] logLines = {\n            "2024-01-15 10:30:45 [INFO] User login successful - user: john_doe",\n            "2024-01-15 10:31:02 [ERROR] Database connection failed - timeout after 30s",\n            "2024-01-15 10:31:15 [WARN] Memory usage at 85% - threshold exceeded",\n            "2024-01-15 10:32:00 [INFO] File upload completed - size: 2.5MB"\n        };\n\n        // Log pattern: timestamp [level] message\n        String logPattern = "(\\\\d{4}-\\\\d{2}-\\\\d{2} \\\\d{2}:\\\\d{2}:\\\\d{2}) \\\\[(\\\\w+)\\\\] (.+)";\n        Pattern pattern = Pattern.compile(logPattern);\n\n        System.out.println("Parsed log entries:");\n        for (String logLine : logLines) {\n            Matcher matcher = pattern.matcher(logLine);\n\n            if (matcher.find()) {\n                String timestamp = matcher.group(1);\n                String level = matcher.group(2);\n                String message = matcher.group(3);\n\n                System.out.printf("Timestamp: %s | Level: %-5s | Message: %s%n",\n                    timestamp, level, message);\n            }\n        }\n\n        // Filter by log level\n        System.out.println("\\nERROR level logs only:");\n        Pattern errorPattern = Pattern.compile(".*\\\\[ERROR\\\\].*");\n        for (String logLine : logLines) {\n            if (errorPattern.matcher(logLine).matches()) {\n                System.out.println(logLine);\n            }\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"text-processing-and-cleaning-1",children:"Text Processing and Cleaning"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'public class TextProcessingExample {\n    public static void main(String[] args) {\n        String messyText = "  Hello,    world!!!   How   are you???  \\n\\n  Fine, thanks!  ";\n\n        System.out.println("Original text: \'" + messyText + "\'");\n\n        // Remove extra whitespace\n        String cleanWhitespace = messyText.replaceAll("\\\\s+", " ").trim();\n        System.out.println("Clean whitespace: \'" + cleanWhitespace + "\'");\n\n        // Remove multiple punctuation marks\n        String cleanPunctuation = cleanWhitespace.replaceAll("[!?]{2,}", "!");\n        System.out.println("Clean punctuation: \'" + cleanPunctuation + "\'");\n\n        // Extract words only (remove punctuation)\n        String wordsOnly = cleanPunctuation.replaceAll("[^a-zA-Z\\\\s]", "");\n        System.out.println("Words only: \'" + wordsOnly + "\'");\n\n        // Split into words\n        String[] words = wordsOnly.split("\\\\s+");\n        System.out.println("Word count: " + words.length);\n        System.out.println("Words: " + Arrays.toString(words));\n\n        // Find and replace with pattern\n        String htmlText = "<p>This is a <strong>bold</strong> text with <em>emphasis</em></p>";\n        String cleanHtml = htmlText.replaceAll("<[^>]+>", "");\n        System.out.println("\\nHTML text: " + htmlText);\n        System.out.println("Clean text: " + cleanHtml);\n    }\n}\n'})}),"\n",(0,a.jsx)(e.hr,{}),"\n",(0,a.jsx)(e.h1,{id:"part-4-annotations-3",children:"Part 4: Annotations"}),"\n",(0,a.jsx)(e.h2,{id:"understanding-annotations-1",children:"Understanding Annotations"}),"\n",(0,a.jsxs)(e.p,{children:["Annotations are special notes you add to your Java code. They start with the ",(0,a.jsx)(e.code,{children:"@"})," symbol. They don't change how your program runs, but they give extra information to the compiler, development tools, or frameworks."]}),"\n",(0,a.jsx)(e.h3,{id:"benefits-of-annotations-1",children:"Benefits of Annotations:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Compile-time checking"}),": Help catch errors during compilation"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Code generation"}),": Tools can generate code based on annotations"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Runtime processing"}),": Can be processed at runtime for frameworks"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Documentation"}),": Provide metadata about code elements"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"built-in-annotations-1",children:"Built-in Annotations"}),"\n",(0,a.jsx)(e.h3,{id:"override-annotation-1",children:"@Override Annotation"}),"\n",(0,a.jsxs)(e.p,{children:["The ",(0,a.jsx)(e.code,{children:"@Override"})," annotation indicates that a method overrides a method in a superclass."]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'class Animal {\n    void makeSound() {\n        System.out.println("Animal sound");\n    }\n\n    void move() {\n        System.out.println("Animal moves");\n    }\n}\n\nclass Dog extends Animal {\n    @Override\n    void makeSound() {\n        System.out.println("Woof!");\n    }\n\n    @Override\n    void move() {\n        System.out.println("Dog runs");\n    }\n\n    // This will cause a compile error if uncommented\n    // @Override\n    // void makesound() { // Typo in method name\n    //     System.out.println("Woof!");\n    // }\n}\n\npublic class OverrideExample {\n    public static void main(String[] args) {\n        Animal myDog = new Dog();\n        myDog.makeSound(); // Output: Woof!\n        myDog.move();      // Output: Dog runs\n\n        // Demonstrating polymorphism\n        Animal[] animals = {new Animal(), new Dog()};\n        for (Animal animal : animals) {\n            animal.makeSound();\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"deprecated-annotation-1",children:"@Deprecated Annotation"}),"\n",(0,a.jsxs)(e.p,{children:["The ",(0,a.jsx)(e.code,{children:"@Deprecated"})," annotation marks methods, classes, or fields as outdated."]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'public class DeprecatedExample {\n\n    @Deprecated\n    public static void oldMethod() {\n        System.out.println("This is an old method");\n    }\n\n    @Deprecated(since = "2.0", forRemoval = true)\n    public static void veryOldMethod() {\n        System.out.println("This method will be removed");\n    }\n\n    public static void newMethod() {\n        System.out.println("Use this new method instead");\n    }\n\n    public static void main(String[] args) {\n        // These calls will show deprecation warnings\n        oldMethod();        // Warning: deprecated\n        veryOldMethod();    // Warning: deprecated and marked for removal\n\n        // This is the recommended approach\n        newMethod();        // No warning\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"suppresswarnings-annotation-1",children:"@SuppressWarnings Annotation"}),"\n",(0,a.jsxs)(e.p,{children:["The ",(0,a.jsx)(e.code,{children:"@SuppressWarnings"})," annotation tells the compiler to ignore specific warnings."]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'import java.util.*;\n\npublic class SuppressWarningsExample {\n\n    @SuppressWarnings("unchecked")\n    public static void uncheckedExample() {\n        // Raw type usage (normally causes warning)\n        List rawList = new ArrayList();\n        rawList.add("String");\n        rawList.add(42);\n\n        System.out.println("Raw list: " + rawList);\n    }\n\n    @SuppressWarnings("deprecation")\n    public static void deprecationExample() {\n        // Using deprecated method (normally causes warning)\n        DeprecatedExample.oldMethod();\n    }\n\n    @SuppressWarnings({"unchecked", "rawtypes"})\n    public static void multipleWarnings() {\n        Map rawMap = new HashMap();\n        rawMap.put("key", "value");\n        System.out.println("Raw map: " + rawMap);\n    }\n\n    @SuppressWarnings("unused")\n    public static void unusedVariableExample() {\n        int unusedVariable = 42; // This would normally cause a warning\n        // Variable is not used, but warning is suppressed\n    }\n\n    public static void main(String[] args) {\n        uncheckedExample();\n        deprecationExample();\n        multipleWarnings();\n        unusedVariableExample();\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"other-built-in-annotations-1",children:"Other Built-in Annotations"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'public class OtherAnnotationsExample {\n\n    // @SafeVarargs - suppresses warnings about varargs\n    @SafeVarargs\n    public static <T> void printAll(T... items) {\n        for (T item : items) {\n            System.out.println(item);\n        }\n    }\n\n    // @FunctionalInterface - ensures interface has only one abstract method\n    @FunctionalInterface\n    interface Calculator {\n        int calculate(int a, int b);\n\n        // Default methods are allowed\n        default void printResult(int result) {\n            System.out.println("Result: " + result);\n        }\n\n        // Static methods are allowed\n        static void info() {\n            System.out.println("This is a calculator interface");\n        }\n    }\n\n    public static void main(String[] args) {\n        // Using @SafeVarargs method\n        printAll("Hello", "World", "Java");\n        printAll(1, 2, 3, 4, 5);\n\n        // Using @FunctionalInterface\n        Calculator add = (a, b) -> a + b;\n        Calculator multiply = (a, b) -> a * b;\n\n        int sum = add.calculate(5, 3);\n        int product = multiply.calculate(5, 3);\n\n        add.printResult(sum);      // Result: 8\n        multiply.printResult(product); // Result: 15\n\n        Calculator.info(); // This is a calculator interface\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h2,{id:"custom-annotations-1",children:"Custom Annotations"}),"\n",(0,a.jsx)(e.h3,{id:"creating-custom-annotations-1",children:"Creating Custom Annotations"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'import java.lang.annotation.*;\n\n// Custom annotation for marking methods as test methods\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\n@interface Test {\n    String description() default "";\n    int priority() default 1;\n    boolean enabled() default true;\n}\n\n// Custom annotation for class-level information\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@interface Author {\n    String name();\n    String email() default "";\n    String version() default "1.0";\n}\n\n// Custom annotation for field validation\n@Target(ElementType.FIELD)\n@Retention(RetentionPolicy.RUNTIME)\n@interface Required {\n    String message() default "Field is required";\n}\n\n@Author(name = "John Doe", email = "john@example.com", version = "2.0")\npublic class CustomAnnotationExample {\n\n    @Required(message = "Name cannot be empty")\n    private String name;\n\n    @Required\n    private String email;\n\n    private int age; // Not required\n\n    public CustomAnnotationExample(String name, String email, int age) {\n        this.name = name;\n        this.email = email;\n        this.age = age;\n    }\n\n    @Test(description = "Test basic functionality", priority = 1)\n    public void testBasicFunction() {\n        System.out.println("Running basic test");\n    }\n\n    @Test(description = "Test advanced functionality", priority = 2, enabled = false)\n    public void testAdvancedFunction() {\n        System.out.println("Running advanced test");\n    }\n\n    @Test(description = "Test error handling", priority = 3)\n    public void testErrorHandling() {\n        System.out.println("Running error handling test");\n    }\n\n    // Method without annotation\n    public void regularMethod() {\n        System.out.println("Regular method - not a test");\n    }\n\n    // Getters and setters\n    public String getName() { return name; }\n    public void setName(String name) { this.name = name; }\n    public String getEmail() { return email; }\n    public void setEmail(String email) { this.email = email; }\n    public int getAge() { return age; }\n    public void setAge(int age) { this.age = age; }\n}\n'})}),"\n",(0,a.jsx)(e.h2,{id:"annotation-processing-1",children:"Annotation Processing"}),"\n",(0,a.jsx)(e.h3,{id:"runtime-annotation-processing-1",children:"Runtime Annotation Processing"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'import java.lang.reflect.*;\n\npublic class AnnotationProcessor {\n\n    public static void runTests(Object testInstance) {\n        Class<?> clazz = testInstance.getClass();\n\n        // Process class-level annotations\n        if (clazz.isAnnotationPresent(Author.class)) {\n            Author author = clazz.getAnnotation(Author.class);\n            System.out.println("Author: " + author.name());\n            System.out.println("Email: " + author.email());\n            System.out.println("Version: " + author.version());\n            System.out.println();\n        }\n\n        // Find and run test methods\n        Method[] methods = clazz.getDeclaredMethods();\n\n        for (Method method : methods) {\n            if (method.isAnnotationPresent(Test.class)) {\n                Test testAnnotation = method.getAnnotation(Test.class);\n\n                if (testAnnotation.enabled()) {\n                    System.out.println("Running test: " + method.getName());\n                    System.out.println("Description: " + testAnnotation.description());\n                    System.out.println("Priority: " + testAnnotation.priority());\n\n                    try {\n                        method.invoke(testInstance);\n                        System.out.println("\u2713 Test passed\\n");\n                    } catch (Exception e) {\n                        System.out.println("\u2717 Test failed: " + e.getMessage() + "\\n");\n                    }\n                } else {\n                    System.out.println("\u26a0 Test skipped (disabled): " + method.getName() + "\\n");\n                }\n            }\n        }\n    }\n\n    public static void validateRequiredFields(Object obj) {\n        Class<?> clazz = obj.getClass();\n        Field[] fields = clazz.getDeclaredFields();\n\n        System.out.println("Validating required fields for: " + clazz.getSimpleName());\n\n        for (Field field : fields) {\n            if (field.isAnnotationPresent(Required.class)) {\n                Required required = field.getAnnotation(Required.class);\n                field.setAccessible(true);\n\n                try {\n                    Object value = field.get(obj);\n                    if (value == null || (value instanceof String && ((String) value).isEmpty())) {\n                        System.out.println("\u2717 Validation failed for field \'" + field.getName() +\n                                         "\': " + required.message());\n                    } else {\n                        System.out.println("\u2713 Field \'" + field.getName() + "\' is valid");\n                    }\n                } catch (IllegalAccessException e) {\n                    System.out.println("\u2717 Cannot access field: " + field.getName());\n                }\n            }\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        // Create test instances\n        CustomAnnotationExample validExample =\n            new CustomAnnotationExample("John Doe", "john@example.com", 30);\n\n        CustomAnnotationExample invalidExample =\n            new CustomAnnotationExample("", null, 25);\n\n        // Validate required fields\n        validateRequiredFields(validExample);\n        validateRequiredFields(invalidExample);\n\n        // Run tests\n        System.out.println("=== Running Tests ===");\n        runTests(validExample);\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"meta-annotations-1",children:"Meta-Annotations"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'import java.lang.annotation.*;\n\n// Meta-annotations example\n@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@interface Performance {\n    String value() default "";\n    long maxExecutionTime() default 1000; // milliseconds\n}\n\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\n@Repeatable(Benchmarks.class) // Java 8 feature\n@interface Benchmark {\n    String name();\n    int iterations() default 1;\n}\n\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\n@interface Benchmarks {\n    Benchmark[] value();\n}\n\n@Performance("High performance class")\npublic class MetaAnnotationExample {\n\n    @Performance(maxExecutionTime = 500)\n    @Benchmark(name = "QuickSort", iterations = 100)\n    @Benchmark(name = "MergeSort", iterations = 50)\n    public void sortingAlgorithmTest() {\n        // Simulate some processing\n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n        System.out.println("Sorting algorithm test completed");\n    }\n\n    @Performance(maxExecutionTime = 2000)\n    public void databaseOperationTest() {\n        System.out.println("Database operation test completed");\n    }\n\n    public static void main(String[] args) {\n        MetaAnnotationExample example = new MetaAnnotationExample();\n        Class<?> clazz = example.getClass();\n\n        // Process class-level annotation\n        if (clazz.isAnnotationPresent(Performance.class)) {\n            Performance perf = clazz.getAnnotation(Performance.class);\n            System.out.println("Class performance info: " + perf.value());\n        }\n\n        // Process method-level annotations\n        Method[] methods = clazz.getDeclaredMethods();\n        for (Method method : methods) {\n            if (method.isAnnotationPresent(Performance.class)) {\n                Performance perf = method.getAnnotation(Performance.class);\n                System.out.println("Method: " + method.getName());\n                System.out.println("Max execution time: " + perf.maxExecutionTime() + "ms");\n            }\n\n            // Process repeatable annotations\n            Benchmark[] benchmarks = method.getAnnotationsByType(Benchmark.class);\n            for (Benchmark benchmark : benchmarks) {\n                System.out.println("Benchmark: " + benchmark.name() +\n                                 " (iterations: " + benchmark.iterations() + ")");\n            }\n            System.out.println();\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(e.p,{children:"for common patterns"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Quantifiers"}),": ",(0,a.jsx)(e.code,{children:"+"}),", ",(0,a.jsx)(e.code,{children:"*"}),", ",(0,a.jsx)(e.code,{children:"?"}),", ",(0,a.jsx)(e.code,{children:"{n}"}),", ",(0,a.jsx)(e.code,{children:"{n,m}"})," for repetition"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Groups"}),": Parentheses for capturing parts of matches"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Flags"}),": Case-insensitive, multiline, and other pattern modifiers"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"annotations-key-points",children:"Annotations Key Points"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Built-in"}),": ",(0,a.jsx)(e.code,{children:"@Override"}),", ",(0,a.jsx)(e.code,{children:"@Deprecated"}),", ",(0,a.jsx)(e.code,{children:"@SuppressWarnings"})," for compiler assistance"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Custom Annotations"}),": Define with ",(0,a.jsx)(e.code,{children:"@interface"})," and meta-annotations"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Retention Policy"}),": SOURCE, CLASS, or RUNTIME for different processing needs"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Target"}),": Specify where annotations can be applied (methods, fields, classes, etc.)"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Processing"}),": Use reflection to read and act on annotations at runtime"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"comprehensive-example",children:"Comprehensive Example"}),"\n",(0,a.jsx)(e.p,{children:"Here's an example that combines all four concepts:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-java",children:'import java.util.*;\nimport java.util.function.*;\nimport java.util.regex.*;\nimport java.lang.annotation.*;\nimport java.lang.reflect.*;\n\n// Custom annotation for data validation\n@Target(ElementType.FIELD)\n@Retention(RetentionPolicy.RUNTIME)\n@interface Validate {\n    String pattern() default "";\n    String message() default "Validation failed";\n    boolean required() default true;\n}\n\n// Custom annotation for method performance tracking\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\n@interface Timed {\n    String description() default "";\n}\n\npublic class ComprehensiveExample {\n\n    @Validate(pattern = "^[a-zA-Z\\\\s]{2,50}$", message = "Name must be 2-50 characters, letters and spaces only")\n    private String name;\n\n    @Validate(pattern = "^[\\\\w._%+-]+@[\\\\w.-]+\\\\.[A-Z]{2,}$", message = "Invalid email format")\n    private String email;\n\n    @Validate(pattern = "^\\\\d{10}$", message = "Phone must be 10 digits")\n    private String phone;\n\n    // Wrapper classes for handling null values safely\n    private Integer age;\n    private Double salary;\n\n    public ComprehensiveExample(String name, String email, String phone, Integer age, Double salary) {\n        this.name = name;\n        this.email = email;\n        this.phone = phone;\n        this.age = age;\n        this.salary = salary;\n    }\n\n    // Lambda expressions with functional interfaces\n    @Timed(description = "Data processing with lambdas")\n    public void processData() {\n        List<String> data = Arrays.asList("apple", "banana", "cherry", "date", "elderberry");\n\n        // Using Consumer\n        Consumer<String> printer = item -> System.out.println("Processing: " + item);\n\n        // Using Predicate\n        Predicate<String> longNames = item -> item.length() > 5;\n\n        // Using Function\n        Function<String, Integer> lengthMapper = String::length;\n\n        // Using Supplier\n        Supplier<String> timestampSupplier = () -> "Processed at: " + System.currentTimeMillis();\n\n        System.out.println("=== Processing Data with Lambdas ===");\n        data.stream()\n            .filter(longNames)                    // Predicate\n            .map(lengthMapper)                    // Function\n            .forEach(length -> System.out.println("Length: " + length)); // Consumer\n\n        System.out.println(timestampSupplier.get()); // Supplier\n    }\n\n    // Method using wrapper classes and their utility methods\n    @Timed(description = "Number processing with wrapper classes")\n    public void processNumbers() {\n        List<String> numberStrings = Arrays.asList("123", "456", "789", "invalid", "012");\n        List<Integer> validNumbers = new ArrayList<>();\n\n        System.out.println("\\n=== Processing Numbers with Wrapper Classes ===");\n\n        for (String numStr : numberStrings) {\n            try {\n                // Using wrapper class parsing method\n                Integer number = Integer.valueOf(numStr);\n                validNumbers.add(number);\n\n                // Using wrapper class utility methods\n                System.out.printf("Number: %d, Binary: %s, Hex: %s%n",\n                    number, Integer.toBinaryString(number), Integer.toHexString(number));\n\n            } catch (NumberFormatException e) {\n                System.out.println("Invalid number: " + numStr);\n            }\n        }\n\n        // Statistical operations using wrapper methods\n        OptionalDouble average = validNumbers.stream()\n                                           .mapToDouble(Integer::doubleValue)\n                                           .average();\n\n        if (average.isPresent()) {\n            System.out.printf("Average: %.2f%n", average.getAsDouble());\n        }\n    }\n\n    // Method demonstrating regex usage\n    @Timed(description = "Text processing with regex")\n    public void processText() {\n        String text = "Contact John Doe at john.doe@email.com or call (555) 123-4567. " +\n                     "Also reach Jane Smith at jane@company.org or (555) 987-6543.";\n\n        System.out.println("\\n=== Processing Text with Regex ===");\n        System.out.println("Original text: " + text);\n\n        // Email extraction pattern\n        String emailPattern = "([\\\\w._%+-]+)@([\\\\w.-]+\\\\.[A-Z]{2,})";\n        Pattern emailRegex = Pattern.compile(emailPattern, Pattern.CASE_INSENSITIVE);\n        Matcher emailMatcher = emailRegex.matcher(text);\n\n        System.out.println("\\nFound emails:");\n        while (emailMatcher.find()) {\n            System.out.println("- " + emailMatcher.group() +\n                             " (user: " + emailMatcher.group(1) +\n                             ", domain: " + emailMatcher.group(2) + ")");\n        }\n\n        // Phone number extraction\n        String phonePattern = "\\\\(?([0-9]{3})\\\\)?[-.\\\\s]?([0-9]{3})[-.\\\\s]?([0-9]{4})";\n        Pattern phoneRegex = Pattern.compile(phonePattern);\n        Matcher phoneMatcher = phoneRegex.matcher(text);\n\n        System.out.println("\\nFound phone numbers:");\n        while (phoneMatcher.find()) {\n            String formatted = String.format("(%s) %s-%s",\n                phoneMatcher.group(1), phoneMatcher.group(2), phoneMatcher.group(3));\n            System.out.println("- " + phoneMatcher.group() + " -> " + formatted);\n        }\n    }\n\n    // Annotation-based validation using reflection\n    public boolean validateFields() {\n        System.out.println("\\n=== Field Validation with Annotations ===");\n        Class<?> clazz = this.getClass();\n        Field[] fields = clazz.getDeclaredFields();\n        boolean allValid = true;\n\n        for (Field field : fields) {\n            if (field.isAnnotationPresent(Validate.class)) {\n                Validate validation = field.getAnnotation(Validate.class);\n                field.setAccessible(true);\n\n                try {\n                    Object value = field.get(this);\n                    String stringValue = value != null ? value.toString() : "";\n\n                    if (validation.required() && (value == null || stringValue.isEmpty())) {\n                        System.out.println("\u2717 " + field.getName() + ": Field is required");\n                        allValid = false;\n                    } else if (!validation.pattern().isEmpty() && !stringValue.isEmpty()) {\n                        Pattern pattern = Pattern.compile(validation.pattern(), Pattern.CASE_INSENSITIVE);\n                        if (!pattern.matcher(stringValue).matches()) {\n                            System.out.println("\u2717 " + field.getName() + ": " + validation.message());\n                            allValid = false;\n                        } else {\n                            System.out.println("\u2713 " + field.getName() + ": Valid");\n                        }\n                    }\n\n                } catch (IllegalAccessException e) {\n                    System.out.println("\u2717 Cannot access field: " + field.getName());\n                    allValid = false;\n                }\n            }\n        }\n\n        return allValid;\n    }\n\n    // Performance timing using annotations\n    public static void executeWithTiming(Object instance) {\n        Class<?> clazz = instance.getClass();\n        Method[] methods = clazz.getDeclaredMethods();\n\n        for (Method method : methods) {\n            if (method.isAnnotationPresent(Timed.class)) {\n                Timed timed = method.getAnnotation(Timed.class);\n\n                try {\n                    System.out.println("\\n" + "=".repeat(50));\n                    System.out.println("Executing: " + method.getName());\n                    System.out.println("Description: " + timed.description());\n\n                    long startTime = System.nanoTime();\n                    method.invoke(instance);\n                    long endTime = System.nanoTime();\n\n                    double executionTime = (endTime - startTime) / 1_000_000.0;\n                    System.out.printf("Execution time: %.2f ms%n", executionTime);\n\n                } catch (Exception e) {\n                    System.out.println("Error executing method: " + e.getMessage());\n                }\n            }\n        }\n    }\n\n    // Getters for field access\n    public String getName() { return name; }\n    public String getEmail() { return email; }\n    public String getPhone() { return phone; }\n    public Integer getAge() { return age; }\n    public Double getSalary() { return salary; }\n\n    public static void main(String[] args) {\n        // Create instances with valid and invalid data\n        System.out.println("Creating example with valid data:");\n        ComprehensiveExample validExample = new ComprehensiveExample(\n            "John Doe",\n            "john.doe@email.com",\n            "1234567890",\n            30,\n            75000.50\n        );\n\n        // Validate fields\n        boolean isValid = validExample.validateFields();\n        System.out.println("Overall validation result: " + (isValid ? "\u2713 VALID" : "\u2717 INVALID"));\n\n        // Execute timed methods\n        executeWithTiming(validExample);\n\n        System.out.println("\\n" + "=".repeat(70));\n        System.out.println("Creating example with invalid data:");\n\n        ComprehensiveExample invalidExample = new ComprehensiveExample(\n            "J",\n            "invalid-email",\n            "123",\n            null,\n            null\n        );\n\n        boolean isValidInvalid = invalidExample.validateFields();\n        System.out.println("Overall validation result: " + (isValidInvalid ? "\u2713 VALID" : "\u2717 INVALID"));\n    }\n}\n'})}),"\n",(0,a.jsx)(e.p,{children:"This comprehensive example demonstrates:"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Wrapper Classes"}),": Used for ",(0,a.jsx)(e.code,{children:"Integer"})," and ",(0,a.jsx)(e.code,{children:"Double"})," fields that can be null, with parsing and utility methods"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Lambda Expressions"}),": Multiple functional interfaces (Consumer, Predicate, Function, Supplier) for data processing"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Regular Expressions"}),": Email and phone number extraction and formatting with groups and patterns"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Annotations"}),": Custom validation annotations with reflection-based processing and method timing"]}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:"The example shows how these Java features work together in real-world scenarios, combining type safety, functional programming, pattern matching, and metadata-driven programming."})]})}function p(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(d,{...n})}):d(n)}},28453:(n,e,t)=>{t.d(e,{R:()=>s,x:()=>l});var a=t(96540);const r={},i=a.createContext(r);function s(n){const e=a.useContext(i);return a.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:s(n.components),a.createElement(i.Provider,{value:e},n.children)}}}]);