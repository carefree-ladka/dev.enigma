"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[58291],{28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>i});var r=t(96540);const s={},a=r.createContext(s);function o(e){const n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(a.Provider,{value:n},e.children)}},65667:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>c});var r=t(74848),s=t(28453);const a={},o="Modern React Design Patterns",i={id:"Frontend/Frameworks-Libraries/React/Modern React Design Patterns",title:"Modern React Design Patterns",description:"A comprehensive guide to contemporary React patterns and best practices for building maintainable, scalable applications.",source:"@site/docs/01-Frontend/Frameworks-Libraries/React/Modern React Design Patterns.mdx",sourceDirName:"01-Frontend/Frameworks-Libraries/React",slug:"/Frontend/Frameworks-Libraries/React/Modern React Design Patterns",permalink:"/docs/Frontend/Frameworks-Libraries/React/Modern React Design Patterns",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/01-Frontend/Frameworks-Libraries/React/Modern React Design Patterns.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"React Lifecycle Methods",permalink:"/docs/Frontend/Frameworks-Libraries/React/LifeCycleMethods"},next:{title:"PropTypes Validation",permalink:"/docs/Frontend/Frameworks-Libraries/React/PropTyped"}},l={},c=[{value:"1. Component Composition Patterns",id:"1-component-composition-patterns",level:2},{value:"Compound Components",id:"compound-components",level:3},{value:"Children as a Function (Render Props)",id:"children-as-a-function-render-props",level:3},{value:"2. Custom Hooks Patterns",id:"2-custom-hooks-patterns",level:2},{value:"Encapsulate Reusable Logic",id:"encapsulate-reusable-logic",level:3},{value:"Fetching with useQuery Pattern",id:"fetching-with-usequery-pattern",level:3},{value:"3. State Management Patterns",id:"3-state-management-patterns",level:2},{value:"Context with useReducer",id:"context-with-usereducer",level:3},{value:"Zustand-style Store Pattern",id:"zustand-style-store-pattern",level:3},{value:"4. Performance Optimization Patterns",id:"4-performance-optimization-patterns",level:2},{value:"Memoization Strategy",id:"memoization-strategy",level:3},{value:"Virtual Lists for Large Datasets",id:"virtual-lists-for-large-datasets",level:3},{value:"5. Error Handling Patterns",id:"5-error-handling-patterns",level:2},{value:"Error Boundaries",id:"error-boundaries",level:3},{value:"Async Error Handling Hook",id:"async-error-handling-hook",level:3},{value:"6. Form Management Patterns",id:"6-form-management-patterns",level:2},{value:"Controlled Components with Validation",id:"controlled-components-with-validation",level:3},{value:"7. Code Splitting Patterns",id:"7-code-splitting-patterns",level:2},{value:"Route-based Lazy Loading",id:"route-based-lazy-loading",level:3},{value:"Component-level Lazy Loading",id:"component-level-lazy-loading",level:3},{value:"8. Server Components Patterns (React 18+)",id:"8-server-components-patterns-react-18",level:2},{value:"Mixing Server and Client Components",id:"mixing-server-and-client-components",level:3},{value:"9. Testing Patterns",id:"9-testing-patterns",level:2},{value:"Custom Render Function",id:"custom-render-function",level:3},{value:"10. TypeScript Patterns",id:"10-typescript-patterns",level:2},{value:"Generic Component Props",id:"generic-component-props",level:3},{value:"Best Practices Summary",id:"best-practices-summary",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"modern-react-design-patterns",children:"Modern React Design Patterns"})}),"\n",(0,r.jsx)(n.p,{children:"A comprehensive guide to contemporary React patterns and best practices for building maintainable, scalable applications."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"1-component-composition-patterns",children:"1. Component Composition Patterns"}),"\n",(0,r.jsx)(n.h3,{id:"compound-components",children:"Compound Components"}),"\n",(0,r.jsx)(n.p,{children:"Create components that work together seamlessly while maintaining a flexible API."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:'const Card = ({ children }) => <div className="card">{children}</div>;\nCard.Header = ({ children }) => <div className="card-header">{children}</div>;\nCard.Body = ({ children }) => <div className="card-body">{children}</div>;\nCard.Footer = ({ children }) => <div className="card-footer">{children}</div>;\n\n// Usage\n<Card>\n  <Card.Header>Title</Card.Header>\n  <Card.Body>Content</Card.Body>\n  <Card.Footer>Actions</Card.Footer>\n</Card>\n'})}),"\n",(0,r.jsx)(n.h3,{id:"children-as-a-function-render-props",children:"Children as a Function (Render Props)"}),"\n",(0,r.jsx)(n.p,{children:"Pass rendering logic to child components for maximum flexibility."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:'const DataFetcher = ({ url, children }) => {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    fetch(url)\n      .then(res => res.json())\n      .then(data => {\n        setData(data);\n        setLoading(false);\n      });\n  }, [url]);\n\n  return children({ data, loading });\n};\n\n// Usage\n<DataFetcher url="/api/users">\n  {({ data, loading }) =>\n    loading ? <Spinner /> : <UserList users={data} />\n  }\n</DataFetcher>\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"2-custom-hooks-patterns",children:"2. Custom Hooks Patterns"}),"\n",(0,r.jsx)(n.h3,{id:"encapsulate-reusable-logic",children:"Encapsulate Reusable Logic"}),"\n",(0,r.jsx)(n.p,{children:"Extract common stateful logic into custom hooks."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"const useToggle = (initialValue = false) => {\n  const [value, setValue] = useState(initialValue);\n\n  const toggle = useCallback(() => setValue(v => !v), []);\n  const setTrue = useCallback(() => setValue(true), []);\n  const setFalse = useCallback(() => setValue(false), []);\n\n  return [value, { toggle, setTrue, setFalse }];\n};\n\n// Usage\nconst Modal = () => {\n  const [isOpen, { toggle, setFalse }] = useToggle();\n\n  return (\n    <>\n      <button onClick={toggle}>Open Modal</button>\n      {isOpen && <ModalContent onClose={setFalse} />}\n    </>\n  );\n};\n"})}),"\n",(0,r.jsx)(n.h3,{id:"fetching-with-usequery-pattern",children:"Fetching with useQuery Pattern"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"const useQuery = (url, options = {}) => {\n  const [state, setState] = useState({\n    data: null,\n    loading: true,\n    error: null\n  });\n\n  useEffect(() => {\n    let cancelled = false;\n\n    const fetchData = async () => {\n      try {\n        const response = await fetch(url, options);\n        const json = await response.json();\n\n        if (!cancelled) {\n          setState({ data: json, loading: false, error: null });\n        }\n      } catch (error) {\n        if (!cancelled) {\n          setState({ data: null, loading: false, error });\n        }\n      }\n    };\n\n    fetchData();\n    return () => { cancelled = true; };\n  }, [url]);\n\n  return state;\n};\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"3-state-management-patterns",children:"3. State Management Patterns"}),"\n",(0,r.jsx)(n.h3,{id:"context-with-usereducer",children:"Context with useReducer"}),"\n",(0,r.jsx)(n.p,{children:"Manage complex state logic with predictable updates."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"const AuthContext = createContext();\n\nconst authReducer = (state, action) => {\n  switch (action.type) {\n    case 'LOGIN':\n      return { ...state, user: action.payload, isAuthenticated: true };\n    case 'LOGOUT':\n      return { ...state, user: null, isAuthenticated: false };\n    case 'UPDATE_PROFILE':\n      return { ...state, user: { ...state.user, ...action.payload } };\n    default:\n      return state;\n  }\n};\n\nexport const AuthProvider = ({ children }) => {\n  const [state, dispatch] = useReducer(authReducer, {\n    user: null,\n    isAuthenticated: false\n  });\n\n  const login = useCallback((user) => {\n    dispatch({ type: 'LOGIN', payload: user });\n  }, []);\n\n  const logout = useCallback(() => {\n    dispatch({ type: 'LOGOUT' });\n  }, []);\n\n  return (\n    <AuthContext.Provider value={{ ...state, login, logout }}>\n      {children}\n    </AuthContext.Provider>\n  );\n};\n\nexport const useAuth = () => useContext(AuthContext);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"zustand-style-store-pattern",children:"Zustand-style Store Pattern"}),"\n",(0,r.jsx)(n.p,{children:"Create lightweight stores without Context API overhead."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"const createStore = (initialState) => {\n  let state = initialState;\n  const listeners = new Set();\n\n  const getState = () => state;\n\n  const setState = (partial) => {\n    state = typeof partial === 'function' ? partial(state) : { ...state, ...partial };\n    listeners.forEach(listener => listener(state));\n  };\n\n  const subscribe = (listener) => {\n    listeners.add(listener);\n    return () => listeners.delete(listener);\n  };\n\n  return { getState, setState, subscribe };\n};\n\nconst useStore = (store, selector = s => s) => {\n  const [state, setState] = useState(() => selector(store.getState()));\n\n  useEffect(() => {\n    return store.subscribe((newState) => {\n      setState(selector(newState));\n    });\n  }, [store, selector]);\n\n  return state;\n};\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"4-performance-optimization-patterns",children:"4. Performance Optimization Patterns"}),"\n",(0,r.jsx)(n.h3,{id:"memoization-strategy",children:"Memoization Strategy"}),"\n",(0,r.jsx)(n.p,{children:"Use memoization judiciously to prevent unnecessary re-renders."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"const ExpensiveComponent = memo(({ data, onAction }) => {\n  const processedData = useMemo(() => {\n    return data.map(item => heavyComputation(item));\n  }, [data]);\n\n  const handleAction = useCallback((id) => {\n    onAction(id);\n  }, [onAction]);\n\n  return (\n    <div>\n      {processedData.map(item => (\n        <Item key={item.id} {...item} onClick={handleAction} />\n      ))}\n    </div>\n  );\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"virtual-lists-for-large-datasets",children:"Virtual Lists for Large Datasets"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"const VirtualList = ({ items, itemHeight, containerHeight }) => {\n  const [scrollTop, setScrollTop] = useState(0);\n\n  const visibleStart = Math.floor(scrollTop / itemHeight);\n  const visibleEnd = Math.ceil((scrollTop + containerHeight) / itemHeight);\n  const visibleItems = items.slice(visibleStart, visibleEnd);\n\n  return (\n    <div\n      style={{ height: containerHeight, overflow: 'auto' }}\n      onScroll={(e) => setScrollTop(e.target.scrollTop)}\n    >\n      <div style={{ height: items.length * itemHeight, position: 'relative' }}>\n        {visibleItems.map((item, index) => (\n          <div\n            key={item.id}\n            style={{\n              position: 'absolute',\n              top: (visibleStart + index) * itemHeight,\n              height: itemHeight\n            }}\n          >\n            {item.content}\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n};\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"5-error-handling-patterns",children:"5. Error Handling Patterns"}),"\n",(0,r.jsx)(n.h3,{id:"error-boundaries",children:"Error Boundaries"}),"\n",(0,r.jsx)(n.p,{children:"Catch and handle errors gracefully in component trees."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"class ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false, error: null };\n  }\n\n  static getDerivedStateFromError(error) {\n    return { hasError: true, error };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    console.error('Error caught:', error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return this.props.fallback || <ErrorFallback error={this.state.error} />;\n    }\n    return this.props.children;\n  }\n}\n\n// Usage\n<ErrorBoundary fallback={<ErrorMessage />}>\n  <MyComponent />\n</ErrorBoundary>\n"})}),"\n",(0,r.jsx)(n.h3,{id:"async-error-handling-hook",children:"Async Error Handling Hook"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"const useAsyncError = () => {\n  const [, setError] = useState();\n\n  return useCallback((error) => {\n    setError(() => { throw error; });\n  }, []);\n};\n\n// Usage in async operations\nconst MyComponent = () => {\n  const throwError = useAsyncError();\n\n  const fetchData = async () => {\n    try {\n      await fetch('/api/data');\n    } catch (error) {\n      throwError(error); // Will be caught by Error Boundary\n    }\n  };\n};\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"6-form-management-patterns",children:"6. Form Management Patterns"}),"\n",(0,r.jsx)(n.h3,{id:"controlled-components-with-validation",children:"Controlled Components with Validation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"const useForm = (initialValues, validate) => {\n  const [values, setValues] = useState(initialValues);\n  const [errors, setErrors] = useState({});\n  const [touched, setTouched] = useState({});\n\n  const handleChange = (e) => {\n    const { name, value } = e.target;\n    setValues(prev => ({ ...prev, [name]: value }));\n  };\n\n  const handleBlur = (e) => {\n    const { name } = e.target;\n    setTouched(prev => ({ ...prev, [name]: true }));\n\n    if (validate) {\n      const fieldErrors = validate(values);\n      setErrors(fieldErrors);\n    }\n  };\n\n  const handleSubmit = (onSubmit) => (e) => {\n    e.preventDefault();\n    const validationErrors = validate ? validate(values) : {};\n    setErrors(validationErrors);\n\n    if (Object.keys(validationErrors).length === 0) {\n      onSubmit(values);\n    }\n  };\n\n  return {\n    values,\n    errors,\n    touched,\n    handleChange,\n    handleBlur,\n    handleSubmit\n  };\n};\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"7-code-splitting-patterns",children:"7. Code Splitting Patterns"}),"\n",(0,r.jsx)(n.h3,{id:"route-based-lazy-loading",children:"Route-based Lazy Loading"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"const Home = lazy(() => import('./pages/Home'));\nconst Dashboard = lazy(() => import('./pages/Dashboard'));\nconst Profile = lazy(() => import('./pages/Profile'));\n\nconst App = () => (\n  <Router>\n    <Suspense fallback={<LoadingSpinner />}>\n      <Routes>\n        <Route path=\"/\" element={<Home />} />\n        <Route path=\"/dashboard\" element={<Dashboard />} />\n        <Route path=\"/profile\" element={<Profile />} />\n      </Routes>\n    </Suspense>\n  </Router>\n);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"component-level-lazy-loading",children:"Component-level Lazy Loading"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"const LazyComponent = ({ shouldLoad, loader, fallback }) => {\n  const [Component, setComponent] = useState(null);\n\n  useEffect(() => {\n    if (shouldLoad && !Component) {\n      loader().then(module => setComponent(() => module.default));\n    }\n  }, [shouldLoad, loader, Component]);\n\n  if (!Component) return fallback || null;\n  return <Component />;\n};\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"8-server-components-patterns-react-18",children:"8. Server Components Patterns (React 18+)"}),"\n",(0,r.jsx)(n.h3,{id:"mixing-server-and-client-components",children:"Mixing Server and Client Components"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"// ServerComponent.server.jsx\nasync function ServerComponent() {\n  const data = await fetchFromDatabase();\n\n  return (\n    <div>\n      <h1>Server Rendered Data</h1>\n      <ClientComponent data={data} />\n    </div>\n  );\n}\n\n// ClientComponent.client.jsx\n'use client';\n\nfunction ClientComponent({ data }) {\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <p>Client state: {count}</p>\n      <button onClick={() => setCount(c => c + 1)}>Increment</button>\n      <DataDisplay data={data} />\n    </div>\n  );\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"9-testing-patterns",children:"9. Testing Patterns"}),"\n",(0,r.jsx)(n.h3,{id:"custom-render-function",children:"Custom Render Function"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"const customRender = (ui, { initialState, ...options } = {}) => {\n  const Wrapper = ({ children }) => (\n    <Provider store={createStore(initialState)}>\n      <Router>\n        {children}\n      </Router>\n    </Provider>\n  );\n\n  return render(ui, { wrapper: Wrapper, ...options });\n};\n\n// Usage\ntest('component works', () => {\n  customRender(<MyComponent />, {\n    initialState: { user: mockUser }\n  });\n\n  expect(screen.getByText(/welcome/i)).toBeInTheDocument();\n});\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"10-typescript-patterns",children:"10. TypeScript Patterns"}),"\n",(0,r.jsx)(n.h3,{id:"generic-component-props",children:"Generic Component Props"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface ListProps<T> {\n  items: T[];\n  renderItem: (item: T) => ReactNode;\n  keyExtractor: (item: T) => string | number;\n}\n\nfunction List<T>({ items, renderItem, keyExtractor }: ListProps<T>) {\n  return (\n    <div>\n      {items.map(item => (\n        <div key={keyExtractor(item)}>\n          {renderItem(item)}\n        </div>\n      ))}\n    </div>\n  );\n}\n\n// Usage with type inference\n<List\n  items={users}\n  renderItem={(user) => <UserCard user={user} />}\n  keyExtractor={(user) => user.id}\n/>\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"best-practices-summary",children:"Best Practices Summary"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Composition over Configuration"}),": Build flexible components through composition"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Custom Hooks"}),": Extract reusable logic into well-named hooks"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Memoization"}),": Use strategically, not by default"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Error Boundaries"}),": Wrap critical sections of your app"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Code Splitting"}),": Load code progressively based on routes or user actions"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type Safety"}),": Leverage TypeScript for better developer experience"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Testing"}),": Write tests that resemble how users interact with your app"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Separation of Concerns"}),": Keep server logic separate from client interactivity"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Remember"}),": Patterns are tools, not rules. Choose patterns that solve your specific problems and align with your team's expertise."]})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);