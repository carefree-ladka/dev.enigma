"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[8905],{9453:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>c,frontMatter:()=>l,metadata:()=>a,toc:()=>h});var t=r(4848),i=r(8453);const l={},o="AVL Tree",a={id:"DSA/AVLTree",title:"AVL Tree",description:"The implementation maintains the AVL tree properties:",source:"@site/docs/DSA/AVLTree.mdx",sourceDirName:"DSA",slug:"/DSA/AVLTree",permalink:"/js.enigma/docs/DSA/AVLTree",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/AVLTree.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"2D Matrix Graph Algorithms",permalink:"/js.enigma/docs/DSA/2DGraphAlgorithms"},next:{title:"Advanced Algorithm Techniques",permalink:"/js.enigma/docs/DSA/AdvancedTechniques"}},s={},h=[{value:"Key features and optimizations:",id:"key-features-and-optimizations",level:2},{value:"Implementation",id:"implementation",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"avl-tree",children:"AVL Tree"})}),"\n",(0,t.jsx)(n.p,{children:"The implementation maintains the AVL tree properties:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Balance factor of every node is -1, 0, or 1"}),"\n",(0,t.jsx)(n.li,{children:"For each node, the heights of its left and right subtrees differ by at most 1"}),"\n",(0,t.jsx)(n.li,{children:"All BST properties are maintained"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"key-features-and-optimizations",children:"Key features and optimizations:"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"1. Self-Balancing:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Maintains height balance property (difference in heights \u2264 1)"}),"\n",(0,t.jsx)(n.li,{children:"Four types of rotations: Left-Left, Right-Right, Left-Right, Right-Left"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"2. Performance:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Insert: O(log n)"}),"\n",(0,t.jsx)(n.li,{children:"Delete: O(log n)"}),"\n",(0,t.jsx)(n.li,{children:"Search: O(log n)"}),"\n",(0,t.jsx)(n.li,{children:"Space: O(n)"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"3. Balanced Operations:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Automatic rebalancing after insertions and deletions"}),"\n",(0,t.jsx)(n.li,{children:"Height tracking for efficient balance factor calculation"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"4. Memory Efficient:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Minimal node structure with just value, height, and child pointers"}),"\n",(0,t.jsx)(n.li,{children:"Size tracking for quick size queries"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"5. Complete API:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Insert, delete, search operations"}),"\n",(0,t.jsx)(n.li,{children:"Traversal methods"}),"\n",(0,t.jsx)(n.li,{children:"Size and emptiness checks"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"implementation",children:"Implementation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-JavaScript",children:"class Node {\r\n  constructor(value) {\r\n    this.value = value;\r\n    this.left = null;\r\n    this.right = null;\r\n    this.height = 1;  // Height of the node (used for balancing)\r\n  }\r\n}\r\n\r\nclass AVLTree {\r\n  constructor() {\r\n    this.root = null;\r\n    this.size = 0;\r\n  }\r\n\r\n  // Get height of a node\r\n  getHeight(node) {\r\n    return node ? node.height : 0;\r\n  }\r\n\r\n  // Get balance factor of a node\r\n  getBalanceFactor(node) {\r\n    return node ? this.getHeight(node.left) - this.getHeight(node.right) : 0;\r\n  }\r\n\r\n  // Update height of a node\r\n  updateHeight(node) {\r\n    if (node) {\r\n      node.height = 1 + Math.max(\r\n        this.getHeight(node.left),\r\n        this.getHeight(node.right)\r\n      );\r\n    }\r\n  }\r\n\r\n  // Right rotation\r\n  rightRotate(y) {\r\n    const x = y.left;\r\n    const T2 = x.right;\r\n\r\n    x.right = y;\r\n    y.left = T2;\r\n\r\n    // Update heights\r\n    this.updateHeight(y);\r\n    this.updateHeight(x);\r\n\r\n    return x;\r\n  }\r\n\r\n  // Left rotation\r\n  leftRotate(x) {\r\n    const y = x.right;\r\n    const T2 = y.left;\r\n\r\n    y.left = x;\r\n    x.right = T2;\r\n\r\n    // Update heights\r\n    this.updateHeight(x);\r\n    this.updateHeight(y);\r\n\r\n    return y;\r\n  }\r\n\r\n  // Insert a value into the tree\r\n  insert(value) {\r\n    this.root = this.#insert(this.root, value);\r\n    this.size++;\r\n  }\r\n\r\n  #insert(node, value) {\r\n    // Normal BST insertion\r\n    if (!node) {\r\n      return new Node(value);\r\n    }\r\n\r\n    if (value < node.value) {\r\n      node.left = this.#insert(node.left, value);\r\n    } else if (value > node.value) {\r\n      node.right = this.#insert(node.right, value);\r\n    } else {\r\n      return node; // Duplicate values not allowed\r\n    }\r\n\r\n    // Update height\r\n    this.updateHeight(node);\r\n\r\n    // Get balance factor\r\n    const balance = this.getBalanceFactor(node);\r\n\r\n    // Left Left Case\r\n    if (balance > 1 && value < node.left.value) {\r\n      return this.rightRotate(node);\r\n    }\r\n\r\n    // Right Right Case\r\n    if (balance < -1 && value > node.right.value) {\r\n      return this.leftRotate(node);\r\n    }\r\n\r\n    // Left Right Case\r\n    if (balance > 1 && value > node.left.value) {\r\n      node.left = this.leftRotate(node.left);\r\n      return this.rightRotate(node);\r\n    }\r\n\r\n    // Right Left Case\r\n    if (balance < -1 && value < node.right.value) {\r\n      node.right = this.rightRotate(node.right);\r\n      return this.leftRotate(node);\r\n    }\r\n\r\n    return node;\r\n  }\r\n\r\n  // Delete a value from the tree\r\n  delete(value) {\r\n    this.root = this.#delete(this.root, value);\r\n  }\r\n\r\n  #delete(node, value) {\r\n    if (!node) {\r\n      return null;\r\n    }\r\n\r\n    if (value < node.value) {\r\n      node.left = this.#delete(node.left, value);\r\n    } else if (value > node.value) {\r\n      node.right = this.#delete(node.right, value);\r\n    } else {\r\n      // Node with only one child or no child\r\n      if (!node.left || !node.right) {\r\n        const temp = node.left || node.right;\r\n        if (!temp) {\r\n          // No child case\r\n          node = null;\r\n        } else {\r\n          // One child case\r\n          node = temp;\r\n        }\r\n        this.size--;\r\n      } else {\r\n        // Node with two children\r\n        const temp = this.getMinNode(node.right);\r\n        node.value = temp.value;\r\n        node.right = this.#delete(node.right, temp.value);\r\n      }\r\n    }\r\n\r\n    if (!node) {\r\n      return null;\r\n    }\r\n\r\n    // Update height\r\n    this.updateHeight(node);\r\n\r\n    // Get balance factor\r\n    const balance = this.getBalanceFactor(node);\r\n\r\n    // Left Left Case\r\n    if (balance > 1 && this.getBalanceFactor(node.left) >= 0) {\r\n      return this.rightRotate(node);\r\n    }\r\n\r\n    // Left Right Case\r\n    if (balance > 1 && this.getBalanceFactor(node.left) < 0) {\r\n      node.left = this.leftRotate(node.left);\r\n      return this.rightRotate(node);\r\n    }\r\n\r\n    // Right Right Case\r\n    if (balance < -1 && this.getBalanceFactor(node.right) <= 0) {\r\n      return this.leftRotate(node);\r\n    }\r\n\r\n    // Right Left Case\r\n    if (balance < -1 && this.getBalanceFactor(node.right) > 0) {\r\n      node.right = this.rightRotate(node.right);\r\n      return this.leftRotate(node);\r\n    }\r\n\r\n    return node;\r\n  }\r\n\r\n  // Find minimum value node in the tree\r\n  getMinNode(node) {\r\n    let current = node;\r\n    while (current.left) {\r\n      current = current.left;\r\n    }\r\n    return current;\r\n  }\r\n\r\n  // Search for a value\r\n  search(value) {\r\n    return this.#search(this.root, value);\r\n  }\r\n\r\n  #search(node, value) {\r\n    if (!node || node.value === value) {\r\n      return node;\r\n    }\r\n\r\n    if (value < node.value) {\r\n      return this.#search(node.left, value);\r\n    }\r\n    return this.#search(node.right, value);\r\n  }\r\n\r\n  // Traversal methods\r\n  inorder() {\r\n    const result = [];\r\n    this.#inorder(this.root, result);\r\n    return result;\r\n  }\r\n\r\n  #inorder(node, result) {\r\n    if (node) {\r\n      this.#inorder(node.left, result);\r\n      result.push(node.value);\r\n      this.#inorder(node.right, result);\r\n    }\r\n  }\r\n\r\n  // Get tree size\r\n  getSize() {\r\n    return this.size;\r\n  }\r\n\r\n  // Check if tree is empty\r\n  isEmpty() {\r\n    return this.size === 0;\r\n  }\r\n}\r\n\r\n// Create AVL Tree\r\nconst avl = new AVLTree();\r\n\r\n// Insert values\r\navl.insert(10);\r\navl.insert(20);\r\navl.insert(30);\r\navl.insert(40);\r\navl.insert(50);\r\navl.insert(25);\r\n\r\n// Search\r\nconsole.log(avl.search(30));  // Node { value: 30, ... }\r\nconsole.log(avl.search(100)); // null\r\n\r\n// Delete\r\navl.delete(30);\r\n\r\n// Get sorted array\r\nconsole.log(avl.inorder()); // [10, 20, 25, 40, 50]\n"})})]})}function c(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>a});var t=r(6540);const i={},l=t.createContext(i);function o(e){const n=t.useContext(l);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(l.Provider,{value:n},e.children)}}}]);