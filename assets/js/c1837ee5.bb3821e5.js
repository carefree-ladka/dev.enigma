"use strict";(self.webpackChunkdev_enigma=self.webpackChunkdev_enigma||[]).push([[13914],{28453:(n,e,i)=>{i.d(e,{R:()=>l,x:()=>a});var t=i(96540);const s={},r=t.createContext(s);function l(n){const e=t.useContext(r);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:l(n.components),t.createElement(r.Provider,{value:e},n.children)}},88877:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>o,contentTitle:()=>l,default:()=>d,frontMatter:()=>r,metadata:()=>a,toc:()=>c});var t=i(74848),s=i(28453);const r={},l="Cantor's Diagonalization and Knuth's Algorithms Guide",a={id:"DSA/DSA with JavaScript/Cantor",title:"Cantor's Diagonalization and Knuth's Algorithms Guide",description:"Cantor's Diagonalization",source:"@site/docs/DSA/DSA with JavaScript/Cantor.mdx",sourceDirName:"DSA/DSA with JavaScript",slug:"/DSA/DSA with JavaScript/Cantor",permalink:"/docs/DSA/DSA with JavaScript/Cantor",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with JavaScript/Cantor.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Bucket Sort",permalink:"/docs/DSA/DSA with JavaScript/BucketSort"},next:{title:"Circular Buffer",permalink:"/docs/DSA/DSA with JavaScript/CircularBuffer"}},o={},c=[{value:"Cantor&#39;s Diagonalization",id:"cantors-diagonalization",level:2},{value:"Theory",id:"theory",level:3},{value:"Implementation (Basic Concept)",id:"implementation-basic-concept",level:3},{value:"Applications",id:"applications",level:3},{value:"Knuth&#39;s Essential Algorithms",id:"knuths-essential-algorithms",level:2},{value:"1. Dancing Links (Algorithm X)",id:"1-dancing-links-algorithm-x",level:3},{value:"2. Knuth-Morris-Pratt (String Matching)",id:"2-knuth-morris-pratt-string-matching",level:3},{value:"3. MMIX Assembly Language",id:"3-mmix-assembly-language",level:3},{value:"4. Combinatorial Algorithms",id:"4-combinatorial-algorithms",level:3},{value:"Time Complexity Analysis",id:"time-complexity-analysis",level:3},{value:"Common Applications",id:"common-applications",level:3},{value:"Implementation Tips",id:"implementation-tips",level:3}];function h(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"cantors-diagonalization-and-knuths-algorithms-guide",children:"Cantor's Diagonalization and Knuth's Algorithms Guide"})}),"\n",(0,t.jsx)(e.h2,{id:"cantors-diagonalization",children:"Cantor's Diagonalization"}),"\n",(0,t.jsx)(e.h3,{id:"theory",children:"Theory"}),"\n",(0,t.jsx)(e.p,{children:'Cantor\'s Diagonalization is a mathematical technique used to prove that some infinite sets are "bigger" than others. Most famously used to prove that real numbers are uncountable.'}),"\n",(0,t.jsx)(e.h3,{id:"implementation-basic-concept",children:"Implementation (Basic Concept)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function cantorDiagonalization(sequences, n) {\n  // Create a new sequence different from all given sequences\n  let newSequence = '';\n\n  for (let i = 0; i < n; i++) {\n    // Get the i-th digit of the i-th sequence\n    const digit = sequences[i][i];\n\n    // Make this digit different\n    newSequence += digit === '0' ? '1' : '0';\n  }\n\n  return newSequence;\n}\n\n// Example usage\nconst sequences = ['01010101', '11111111', '00000000', '10101010'];\n\nconsole.log(cantorDiagonalization(sequences, 4));\n"})}),"\n",(0,t.jsx)(e.h3,{id:"applications",children:"Applications"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Proving uncountability of real numbers"}),"\n",(0,t.jsx)(e.li,{children:"Halting problem proof"}),"\n",(0,t.jsx)(e.li,{children:"Set theory arguments"}),"\n",(0,t.jsx)(e.li,{children:"Computational complexity theory"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"knuths-essential-algorithms",children:"Knuth's Essential Algorithms"}),"\n",(0,t.jsx)(e.h3,{id:"1-dancing-links-algorithm-x",children:"1. Dancing Links (Algorithm X)"}),"\n",(0,t.jsx)(e.p,{children:"Used for exact cover problems, particularly in solving Sudoku and pentomino puzzles."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"class DLX {\n  constructor() {\n    this.header = new Node('header');\n    this.solution = [];\n  }\n\n  addColumn(name) {\n    const node = new Node(name);\n    node.right = this.header.right;\n    node.left = this.header;\n    this.header.right.left = node;\n    this.header.right = node;\n    return node;\n  }\n\n  search(k) {\n    if (this.header.right === this.header) {\n      return this.solution;\n    }\n\n    // Choose column with minimum size\n    let column = this.chooseColumn();\n    this.cover(column);\n\n    // Try each row\n    let row = column.down;\n    while (row !== column) {\n      this.solution[k] = row;\n\n      // Cover columns\n      let j = row.right;\n      while (j !== row) {\n        this.cover(j.column);\n        j = j.right;\n      }\n\n      this.search(k + 1);\n\n      // Uncover columns\n      j = row.left;\n      while (j !== row) {\n        this.uncover(j.column);\n        j = j.left;\n      }\n\n      row = row.down;\n    }\n\n    this.uncover(column);\n    return null;\n  }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-knuth-morris-pratt-string-matching",children:"2. Knuth-Morris-Pratt (String Matching)"}),"\n",(0,t.jsx)(e.p,{children:"Efficient pattern matching algorithm."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function computeLPS(pattern) {\n  const lps = new Array(pattern.length).fill(0);\n  let len = 0;\n  let i = 1;\n\n  while (i < pattern.length) {\n    if (pattern[i] === pattern[len]) {\n      len++;\n      lps[i] = len;\n      i++;\n    } else {\n      if (len !== 0) {\n        len = lps[len - 1];\n      } else {\n        lps[i] = 0;\n        i++;\n      }\n    }\n  }\n\n  return lps;\n}\n\nfunction KMP(text, pattern) {\n  const lps = computeLPS(pattern);\n  const matches = [];\n  let i = 0; // text index\n  let j = 0; // pattern index\n\n  while (i < text.length) {\n    if (pattern[j] === text[i]) {\n      i++;\n      j++;\n    }\n\n    if (j === pattern.length) {\n      matches.push(i - j);\n      j = lps[j - 1];\n    } else if (i < text.length && pattern[j] !== text[i]) {\n      if (j !== 0) {\n        j = lps[j - 1];\n      } else {\n        i++;\n      }\n    }\n  }\n\n  return matches;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-mmix-assembly-language",children:"3. MMIX Assembly Language"}),"\n",(0,t.jsx)(e.p,{children:"Knuth's ideal computer architecture. Key concepts:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"Registers:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"256 general-purpose registers"}),"\n",(0,t.jsx)(e.li,{children:"Special registers (rA, rB, rC, rD, rE, rF, rG, rH)"}),"\n",(0,t.jsx)(e.li,{children:"Local registers (l0-l7)"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"Basic Operations:"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// MMIX simulator (basic operations)\nclass MMIX {\n  constructor() {\n    this.registers = new Array(256).fill(0n);\n    this.memory = new Map();\n  }\n\n  ADD(x, y, z) {\n    this.registers[x] =\n      (this.registers[y] + this.registers[z]) & ((1n << 64n) - 1n);\n  }\n\n  MUL(x, y, z) {\n    this.registers[x] =\n      (this.registers[y] * this.registers[z]) & ((1n << 64n) - 1n);\n  }\n\n  LOAD(x, y, z) {\n    const address = Number(this.registers[y] + this.registers[z]);\n    this.registers[x] = this.memory.get(address) || 0n;\n  }\n\n  STORE(x, y, z) {\n    const address = Number(this.registers[y] + this.registers[z]);\n    this.memory.set(address, this.registers[x]);\n  }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"4-combinatorial-algorithms",children:"4. Combinatorial Algorithms"}),"\n",(0,t.jsx)(e.p,{children:"Key techniques from TAOCP Volume 4:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"// Algorithm L: Lexicographic Combinations\nfunction nextCombination(arr, n) {\n  const j = arr.length - 1;\n  if (arr[j] < n) {\n    arr[j]++;\n    return true;\n  }\n\n  let i = j - 1;\n  while (i >= 0 && arr[i] + 1 === arr[i + 1]) {\n    i--;\n  }\n\n  if (i < 0) return false;\n\n  arr[i]++;\n  for (let k = i + 1; k <= j; k++) {\n    arr[k] = arr[i] + (k - i);\n  }\n  return true;\n}\n\n// Algorithm P: Plain Changes (Gray Code)\nfunction grayCode(n) {\n  const codes = [];\n  const size = 1 << n;\n\n  for (let i = 0; i < size; i++) {\n    codes.push(i ^ (i >> 1));\n  }\n\n  return codes;\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"time-complexity-analysis",children:"Time Complexity Analysis"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"Dancing Links"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Time: O(branches^depth)"}),"\n",(0,t.jsx)(e.li,{children:"Space: O(n^2)"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"KMP Algorithm"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Preprocessing: O(m)"}),"\n",(0,t.jsx)(e.li,{children:"Search: O(n)"}),"\n",(0,t.jsx)(e.li,{children:"Space: O(m)"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"Combinatorial Algorithms"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Next Combination: O(n)"}),"\n",(0,t.jsx)(e.li,{children:"Gray Code: O(2^n)"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"common-applications",children:"Common Applications"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"Dancing Links"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Sudoku solving"}),"\n",(0,t.jsx)(e.li,{children:"Exact cover problems"}),"\n",(0,t.jsx)(e.li,{children:"Pentomino puzzles"}),"\n",(0,t.jsx)(e.li,{children:"N-Queens problem"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"KMP"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Text processing"}),"\n",(0,t.jsx)(e.li,{children:"Pattern matching"}),"\n",(0,t.jsx)(e.li,{children:"DNA sequence matching"}),"\n",(0,t.jsx)(e.li,{children:"Log file analysis"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"Combinatorial Algorithms"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Permutation generation"}),"\n",(0,t.jsx)(e.li,{children:"Combination enumeration"}),"\n",(0,t.jsx)(e.li,{children:"Gray code generation"}),"\n",(0,t.jsx)(e.li,{children:"Backtracking problems"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"implementation-tips",children:"Implementation Tips"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"Dancing Links"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Use circular doubly-linked lists"}),"\n",(0,t.jsx)(e.li,{children:"Implement column headers with size counters"}),"\n",(0,t.jsx)(e.li,{children:"Consider sparse matrix representation"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"KMP"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Preprocess pattern first"}),"\n",(0,t.jsx)(e.li,{children:"Handle pattern length > text length"}),"\n",(0,t.jsx)(e.li,{children:"Consider multiple pattern matching"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"MMIX"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Use BigInt for 64-bit operations"}),"\n",(0,t.jsx)(e.li,{children:"Implement proper overflow handling"}),"\n",(0,t.jsx)(e.li,{children:"Consider pipeline effects"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"Combinatorial Algorithms"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Use iterative over recursive when possible"}),"\n",(0,t.jsx)(e.li,{children:"Implement efficient bit operations"}),"\n",(0,t.jsx)(e.li,{children:"Consider memory usage for large sets"}),"\n"]}),"\n"]}),"\n"]})]})}function d(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(h,{...n})}):h(n)}}}]);