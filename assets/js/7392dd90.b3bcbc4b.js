"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[1451],{28453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>a});var r=t(96540);const i={},s=r.createContext(i);function l(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),r.createElement(s.Provider,{value:n},e.children)}},69703:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>c});var r=t(74848),i=t(28453);const s={},l="Interval Problems",a={id:"DSA/DSA with JavaScript/DSA Cheatsheets/Interval Problems",title:"Interval Problems",description:"Table of Contents",source:"@site/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Interval Problems.mdx",sourceDirName:"DSA/DSA with JavaScript/DSA Cheatsheets",slug:"/DSA/DSA with JavaScript/DSA Cheatsheets/Interval Problems",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Interval Problems",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Interval Problems.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Heap",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Heap"},next:{title:"Knapsack Problems",permalink:"/js.enigma/docs/DSA/DSA with JavaScript/DSA Cheatsheets/Knapsack Problems"}},o={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Core Concepts",id:"core-concepts",level:2},{value:"Basic Interval Representation",id:"basic-interval-representation",level:3},{value:"Key Properties &amp; Relationships",id:"key-properties--relationships",level:3},{value:"Sorting-Based Patterns",id:"sorting-based-patterns",level:2},{value:"Template Pattern",id:"template-pattern",level:3},{value:"Merge Intervals Pattern",id:"merge-intervals-pattern",level:2},{value:"Classic Merge Intervals",id:"classic-merge-intervals",level:3},{value:"Merge with Custom Logic",id:"merge-with-custom-logic",level:3},{value:"Insert Interval Pattern",id:"insert-interval-pattern",level:2},{value:"Insert Interval Implementation",id:"insert-interval-implementation",level:3},{value:"Insert Multiple Intervals",id:"insert-multiple-intervals",level:3},{value:"Meeting Rooms Pattern",id:"meeting-rooms-pattern",level:2},{value:"Meeting Rooms I (Can Attend All)",id:"meeting-rooms-i-can-attend-all",level:3},{value:"Meeting Rooms II (Minimum Rooms)",id:"meeting-rooms-ii-minimum-rooms",level:3},{value:"Meeting Rooms with Priority Queue",id:"meeting-rooms-with-priority-queue",level:3},{value:"Sweep Line Algorithm",id:"sweep-line-algorithm",level:2},{value:"Event-Based Processing",id:"event-based-processing",level:3},{value:"Sweep Line for Range Sum Queries",id:"sweep-line-for-range-sum-queries",level:3},{value:"Interval Tree &amp; Advanced Structures",id:"interval-tree--advanced-structures",level:2},{value:"Simple Interval Tree Node",id:"simple-interval-tree-node",level:3},{value:"Two Pointers on Intervals",id:"two-pointers-on-intervals",level:2},{value:"Intersection of Two Interval Lists",id:"intersection-of-two-interval-lists",level:3},{value:"Merge Two Sorted Interval Lists",id:"merge-two-sorted-interval-lists",level:3},{value:"Priority Queue Patterns",id:"priority-queue-patterns",level:2},{value:"Interval Scheduling with Weights",id:"interval-scheduling-with-weights",level:3},{value:"CPU Scheduling Simulation",id:"cpu-scheduling-simulation",level:3},{value:"Common Problem Types",id:"common-problem-types",level:2},{value:"1. Non-Overlapping Intervals (Greedy)",id:"1-non-overlapping-intervals-greedy",level:3},{value:"2. Minimum Arrows to Burst Balloons",id:"2-minimum-arrows-to-burst-balloons",level:3},{value:"3. Activity Selection Problem",id:"3-activity-selection-problem",level:3},{value:"4. Calendar Scheduling",id:"4-calendar-scheduling",level:3},{value:"Complexity Analysis &amp; Tips",id:"complexity-analysis--tips",level:2},{value:"Time Complexities:",id:"time-complexities",level:3},{value:"Space Complexities:",id:"space-complexities",level:3},{value:"Key Optimization Strategies:",id:"key-optimization-strategies",level:3},{value:"Common Pitfalls:",id:"common-pitfalls",level:3},{value:"Summary",id:"summary",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"interval-problems",children:"Interval Problems"})}),"\n",(0,r.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#core-concepts",children:"Core Concepts"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#sorting-based-patterns",children:"Sorting-Based Patterns"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#merge-intervals-pattern",children:"Merge Intervals Pattern"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#insert-interval-pattern",children:"Insert Interval Pattern"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#meeting-rooms-pattern",children:"Meeting Rooms Pattern"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#sweep-line-algorithm",children:"Sweep Line Algorithm"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#interval-tree--advanced-structures",children:"Interval Tree & Advanced Structures"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#two-pointers-on-intervals",children:"Two Pointers on Intervals"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#priority-queue-patterns",children:"Priority Queue Patterns"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#common-problem-types",children:"Common Problem Types"})}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,r.jsx)(n.h3,{id:"basic-interval-representation",children:"Basic Interval Representation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// Simple interval structure\nclass Interval {\n    constructor(start, end) {\n        this.start = start;\n        this.end = end;\n    }\n}\n\n// Array representation: [start, end]\nconst intervals = [[1, 3], [2, 6], [8, 10], [15, 18]];\n\n// Object representation\nconst meetings = [\n    { start: 1, end: 3 },\n    { start: 2, end: 6 },\n    { start: 8, end: 10 }\n];\n"})}),"\n",(0,r.jsx)(n.h3,{id:"key-properties--relationships",children:"Key Properties & Relationships"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// Interval relationships\nfunction getRelationship(interval1, interval2) {\n    const [a1, a2] = interval1;\n    const [b1, b2] = interval2;\n\n    // No overlap\n    if (a2 < b1 || b2 < a1) return 'separate';\n\n    // Touch at endpoints\n    if (a2 === b1 || b2 === a1) return 'adjacent';\n\n    // Overlap cases\n    if (a1 === b1 && a2 === b2) return 'identical';\n    if (a1 >= b1 && a2 <= b2) return 'a_inside_b';\n    if (b1 >= a1 && b2 <= a2) return 'b_inside_a';\n\n    return 'partial_overlap';\n}\n\n// Check if intervals overlap\nfunction overlaps(interval1, interval2) {\n    return Math.max(interval1[0], interval2[0]) < Math.min(interval1[1], interval2[1]);\n}\n\n// Merge two overlapping intervals\nfunction merge(interval1, interval2) {\n    return [\n        Math.min(interval1[0], interval2[0]),\n        Math.max(interval1[1], interval2[1])\n    ];\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"sorting-based-patterns",children:"Sorting-Based Patterns"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Core Idea"}),": Sort intervals by start time, then process sequentially."]}),"\n",(0,r.jsx)(n.h3,{id:"template-pattern",children:"Template Pattern"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function processIntervals(intervals) {\n    if (intervals.length <= 1) return intervals;\n\n    // Sort by start time\n    intervals.sort((a, b) => a[0] - b[0]);\n\n    const result = [];\n    let current = intervals[0];\n\n    for (let i = 1; i < intervals.length; i++) {\n        const next = intervals[i];\n\n        if (shouldCombine(current, next)) {\n            current = combine(current, next);\n        } else {\n            result.push(current);\n            current = next;\n        }\n    }\n\n    result.push(current);\n    return result;\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"merge-intervals-pattern",children:"Merge Intervals Pattern"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use Case"}),": Combine overlapping intervals into non-overlapping ones."]}),"\n",(0,r.jsx)(n.h3,{id:"classic-merge-intervals",children:"Classic Merge Intervals"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function merge(intervals) {\n    if (intervals.length <= 1) return intervals;\n\n    // Sort by start time\n    intervals.sort((a, b) => a[0] - b[0]);\n\n    const merged = [intervals[0]];\n\n    for (let i = 1; i < intervals.length; i++) {\n        const current = intervals[i];\n        const lastMerged = merged[merged.length - 1];\n\n        // If current interval overlaps with last merged interval\n        if (current[0] <= lastMerged[1]) {\n            // Merge them by extending the end time\n            lastMerged[1] = Math.max(lastMerged[1], current[1]);\n        } else {\n            // No overlap, add current interval\n            merged.push(current);\n        }\n    }\n\n    return merged;\n}\n\n// Example usage\nconsole.log(merge([[1,3],[2,6],[8,10],[15,18]]));\n// Output: [[1,6],[8,10],[15,18]]\n"})}),"\n",(0,r.jsx)(n.h3,{id:"merge-with-custom-logic",children:"Merge with Custom Logic"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// Merge intervals with minimum gap\nfunction mergeWithGap(intervals, gap) {\n    if (intervals.length <= 1) return intervals;\n\n    intervals.sort((a, b) => a[0] - b[0]);\n    const merged = [intervals[0]];\n\n    for (let i = 1; i < intervals.length; i++) {\n        const current = intervals[i];\n        const lastMerged = merged[merged.length - 1];\n\n        // Merge if overlap or gap is within threshold\n        if (current[0] - lastMerged[1] <= gap) {\n            lastMerged[1] = Math.max(lastMerged[1], current[1]);\n        } else {\n            merged.push(current);\n        }\n    }\n\n    return merged;\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"insert-interval-pattern",children:"Insert Interval Pattern"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use Case"}),": Insert a new interval into a sorted list of non-overlapping intervals."]}),"\n",(0,r.jsx)(n.h3,{id:"insert-interval-implementation",children:"Insert Interval Implementation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function insert(intervals, newInterval) {\n    const result = [];\n    let i = 0;\n\n    // Add all intervals that end before new interval starts\n    while (i < intervals.length && intervals[i][1] < newInterval[0]) {\n        result.push(intervals[i]);\n        i++;\n    }\n\n    // Merge all overlapping intervals with new interval\n    while (i < intervals.length && intervals[i][0] <= newInterval[1]) {\n        newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\n        newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\n        i++;\n    }\n    result.push(newInterval);\n\n    // Add remaining intervals\n    while (i < intervals.length) {\n        result.push(intervals[i]);\n        i++;\n    }\n\n    return result;\n}\n\n// Example usage\nconsole.log(insert([[1,3],[6,9]], [2,5]));\n// Output: [[1,5],[6,9]]\n"})}),"\n",(0,r.jsx)(n.h3,{id:"insert-multiple-intervals",children:"Insert Multiple Intervals"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function insertMultiple(intervals, newIntervals) {\n    // Sort new intervals by start time\n    newIntervals.sort((a, b) => a[0] - b[0]);\n\n    let result = intervals;\n\n    for (const newInterval of newIntervals) {\n        result = insert(result, newInterval);\n    }\n\n    return result;\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"meeting-rooms-pattern",children:"Meeting Rooms Pattern"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use Case"}),": Determine if meetings can be scheduled or find minimum rooms needed."]}),"\n",(0,r.jsx)(n.h3,{id:"meeting-rooms-i-can-attend-all",children:"Meeting Rooms I (Can Attend All)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function canAttendMeetings(intervals) {\n    if (intervals.length <= 1) return true;\n\n    intervals.sort((a, b) => a[0] - b[0]);\n\n    for (let i = 1; i < intervals.length; i++) {\n        // If current meeting starts before previous ends\n        if (intervals[i][0] < intervals[i-1][1]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"meeting-rooms-ii-minimum-rooms",children:"Meeting Rooms II (Minimum Rooms)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function minMeetingRooms(intervals) {\n    if (intervals.length === 0) return 0;\n\n    const starts = intervals.map(interval => interval[0]).sort((a, b) => a - b);\n    const ends = intervals.map(interval => interval[1]).sort((a, b) => a - b);\n\n    let rooms = 0;\n    let maxRooms = 0;\n    let startPtr = 0;\n    let endPtr = 0;\n\n    while (startPtr < intervals.length) {\n        // A meeting starts\n        if (starts[startPtr] < ends[endPtr]) {\n            rooms++;\n            maxRooms = Math.max(maxRooms, rooms);\n            startPtr++;\n        } else {\n            // A meeting ends\n            rooms--;\n            endPtr++;\n        }\n    }\n\n    return maxRooms;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"meeting-rooms-with-priority-queue",children:"Meeting Rooms with Priority Queue"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class MinHeap {\n    constructor() {\n        this.heap = [];\n    }\n\n    push(val) {\n        this.heap.push(val);\n        this._heapifyUp();\n    }\n\n    pop() {\n        if (this.heap.length === 0) return null;\n        if (this.heap.length === 1) return this.heap.pop();\n\n        const min = this.heap[0];\n        this.heap[0] = this.heap.pop();\n        this._heapifyDown();\n        return min;\n    }\n\n    peek() {\n        return this.heap.length > 0 ? this.heap[0] : null;\n    }\n\n    size() {\n        return this.heap.length;\n    }\n\n    _heapifyUp() {\n        let idx = this.heap.length - 1;\n        while (idx > 0) {\n            const parentIdx = Math.floor((idx - 1) / 2);\n            if (this.heap[parentIdx] <= this.heap[idx]) break;\n            [this.heap[parentIdx], this.heap[idx]] = [this.heap[idx], this.heap[parentIdx]];\n            idx = parentIdx;\n        }\n    }\n\n    _heapifyDown() {\n        let idx = 0;\n        while (2 * idx + 1 < this.heap.length) {\n            let minChildIdx = 2 * idx + 1;\n            if (2 * idx + 2 < this.heap.length && this.heap[2 * idx + 2] < this.heap[minChildIdx]) {\n                minChildIdx = 2 * idx + 2;\n            }\n            if (this.heap[idx] <= this.heap[minChildIdx]) break;\n            [this.heap[idx], this.heap[minChildIdx]] = [this.heap[minChildIdx], this.heap[idx]];\n            idx = minChildIdx;\n        }\n    }\n}\n\nfunction minMeetingRoomsHeap(intervals) {\n    if (intervals.length === 0) return 0;\n\n    intervals.sort((a, b) => a[0] - b[0]);\n    const endTimes = new MinHeap();\n\n    for (const interval of intervals) {\n        // If earliest ending meeting has ended, reuse that room\n        if (endTimes.size() > 0 && endTimes.peek() <= interval[0]) {\n            endTimes.pop();\n        }\n        endTimes.push(interval[1]);\n    }\n\n    return endTimes.size();\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"sweep-line-algorithm",children:"Sweep Line Algorithm"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use Case"}),": Process events in chronological order to track active intervals."]}),"\n",(0,r.jsx)(n.h3,{id:"event-based-processing",children:"Event-Based Processing"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function sweepLine(intervals) {\n    const events = [];\n\n    // Create events for interval starts and ends\n    for (const [start, end] of intervals) {\n        events.push([start, 'start']);\n        events.push([end, 'end']);\n    }\n\n    // Sort events by time, with 'end' events before 'start' events at same time\n    events.sort((a, b) => {\n        if (a[0] !== b[0]) return a[0] - b[0];\n        return a[1] === 'end' ? -1 : 1;\n    });\n\n    let activeIntervals = 0;\n    let maxActive = 0;\n\n    for (const [time, type] of events) {\n        if (type === 'start') {\n            activeIntervals++;\n            maxActive = Math.max(maxActive, activeIntervals);\n        } else {\n            activeIntervals--;\n        }\n    }\n\n    return maxActive;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"sweep-line-for-range-sum-queries",children:"Sweep Line for Range Sum Queries"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function rangeSum(intervals, queries) {\n    const events = [];\n\n    // Create events for intervals\n    for (let i = 0; i < intervals.length; i++) {\n        const [start, end] = intervals[i];\n        events.push([start, 'start', i]);\n        events.push([end, 'end', i]);\n    }\n\n    // Create events for queries\n    for (let i = 0; i < queries.length; i++) {\n        const [point] = queries[i];\n        events.push([point, 'query', i]);\n    }\n\n    events.sort((a, b) => a[0] - b[0]);\n\n    const activeIntervals = new Set();\n    const results = new Array(queries.length);\n\n    for (const [time, type, idx] of events) {\n        if (type === 'start') {\n            activeIntervals.add(idx);\n        } else if (type === 'end') {\n            activeIntervals.delete(idx);\n        } else { // query\n            results[idx] = activeIntervals.size;\n        }\n    }\n\n    return results;\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"interval-tree--advanced-structures",children:"Interval Tree & Advanced Structures"}),"\n",(0,r.jsx)(n.h3,{id:"simple-interval-tree-node",children:"Simple Interval Tree Node"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class IntervalTreeNode {\n    constructor(interval) {\n        this.interval = interval;\n        this.max = interval[1];\n        this.left = null;\n        this.right = null;\n    }\n}\n\nclass IntervalTree {\n    constructor() {\n        this.root = null;\n    }\n\n    insert(interval) {\n        this.root = this._insert(this.root, interval);\n    }\n\n    _insert(node, interval) {\n        if (!node) return new IntervalTreeNode(interval);\n\n        // Update max value\n        node.max = Math.max(node.max, interval[1]);\n\n        // Insert based on start time\n        if (interval[0] < node.interval[0]) {\n            node.left = this._insert(node.left, interval);\n        } else {\n            node.right = this._insert(node.right, interval);\n        }\n\n        return node;\n    }\n\n    search(interval) {\n        return this._search(this.root, interval);\n    }\n\n    _search(node, interval) {\n        if (!node) return null;\n\n        // Check if current interval overlaps\n        if (this._overlaps(node.interval, interval)) {\n            return node.interval;\n        }\n\n        // If left subtree can contain overlapping interval\n        if (node.left && node.left.max >= interval[0]) {\n            return this._search(node.left, interval);\n        }\n\n        return this._search(node.right, interval);\n    }\n\n    _overlaps(a, b) {\n        return Math.max(a[0], b[0]) < Math.min(a[1], b[1]);\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"two-pointers-on-intervals",children:"Two Pointers on Intervals"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use Case"}),": Compare or merge two sorted lists of intervals."]}),"\n",(0,r.jsx)(n.h3,{id:"intersection-of-two-interval-lists",children:"Intersection of Two Interval Lists"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function intervalIntersection(firstList, secondList) {\n    const result = [];\n    let i = 0, j = 0;\n\n    while (i < firstList.length && j < secondList.length) {\n        const [start1, end1] = firstList[i];\n        const [start2, end2] = secondList[j];\n\n        // Find intersection\n        const start = Math.max(start1, start2);\n        const end = Math.min(end1, end2);\n\n        if (start < end) {\n            result.push([start, end]);\n        }\n\n        // Move pointer for interval that ends first\n        if (end1 < end2) {\n            i++;\n        } else {\n            j++;\n        }\n    }\n\n    return result;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"merge-two-sorted-interval-lists",children:"Merge Two Sorted Interval Lists"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function mergeTwoLists(list1, list2) {\n    const result = [];\n    let i = 0, j = 0;\n\n    while (i < list1.length && j < list2.length) {\n        if (list1[i][0] <= list2[j][0]) {\n            result.push(list1[i]);\n            i++;\n        } else {\n            result.push(list2[j]);\n            j++;\n        }\n    }\n\n    while (i < list1.length) {\n        result.push(list1[i]);\n        i++;\n    }\n\n    while (j < list2.length) {\n        result.push(list2[j]);\n        j++;\n    }\n\n    return merge(result); // Apply merge intervals pattern\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"priority-queue-patterns",children:"Priority Queue Patterns"}),"\n",(0,r.jsx)(n.h3,{id:"interval-scheduling-with-weights",children:"Interval Scheduling with Weights"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function maxWeight(intervals) {\n    // Add weight as third element: [start, end, weight]\n    intervals.sort((a, b) => a[1] - b[1]); // Sort by end time\n\n    const n = intervals.length;\n    const dp = new Array(n + 1).fill(0);\n\n    for (let i = 1; i <= n; i++) {\n        const [start, end, weight] = intervals[i - 1];\n\n        // Find latest non-overlapping interval\n        let j = i - 1;\n        while (j > 0 && intervals[j - 1][1] > start) {\n            j--;\n        }\n\n        // Take or skip current interval\n        dp[i] = Math.max(\n            dp[i - 1], // Skip\n            dp[j] + weight // Take\n        );\n    }\n\n    return dp[n];\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"cpu-scheduling-simulation",children:"CPU Scheduling Simulation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function scheduleCPU(processes) {\n    // Process: [arrivalTime, burstTime, priority]\n    const events = [];\n    const completed = [];\n    let currentTime = 0;\n    let runningProcess = null;\n\n    // Create arrival events\n    for (let i = 0; i < processes.length; i++) {\n        events.push([processes[i][0], 'arrival', i]);\n    }\n\n    events.sort((a, b) => a[0] - b[0]);\n    const readyQueue = new MinHeap(); // Priority-based\n\n    for (const [time, type, processId] of events) {\n        currentTime = Math.max(currentTime, time);\n\n        if (type === 'arrival') {\n            const process = { ...processes[processId], id: processId };\n            readyQueue.push(process);\n\n            // Preempt if higher priority process arrives\n            if (!runningProcess || process.priority < runningProcess.priority) {\n                if (runningProcess) {\n                    readyQueue.push(runningProcess);\n                }\n                runningProcess = readyQueue.pop();\n            }\n        }\n\n        // Process completion logic here...\n    }\n\n    return completed;\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"common-problem-types",children:"Common Problem Types"}),"\n",(0,r.jsx)(n.h3,{id:"1-non-overlapping-intervals-greedy",children:"1. Non-Overlapping Intervals (Greedy)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function eraseOverlapIntervals(intervals) {\n    if (intervals.length <= 1) return 0;\n\n    intervals.sort((a, b) => a[1] - b[1]); // Sort by end time\n\n    let count = 0;\n    let lastEnd = intervals[0][1];\n\n    for (let i = 1; i < intervals.length; i++) {\n        if (intervals[i][0] < lastEnd) {\n            count++; // Remove current interval\n        } else {\n            lastEnd = intervals[i][1];\n        }\n    }\n\n    return count;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-minimum-arrows-to-burst-balloons",children:"2. Minimum Arrows to Burst Balloons"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function findMinArrowShots(points) {\n    if (points.length === 0) return 0;\n\n    points.sort((a, b) => a[1] - b[1]); // Sort by end position\n\n    let arrows = 1;\n    let arrowPos = points[0][1];\n\n    for (let i = 1; i < points.length; i++) {\n        if (points[i][0] > arrowPos) {\n            arrows++;\n            arrowPos = points[i][1];\n        }\n    }\n\n    return arrows;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"3-activity-selection-problem",children:"3. Activity Selection Problem"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function activitySelection(activities) {\n    // Activity: [start, end]\n    activities.sort((a, b) => a[1] - b[1]);\n\n    const selected = [activities[0]];\n    let lastEnd = activities[0][1];\n\n    for (let i = 1; i < activities.length; i++) {\n        if (activities[i][0] >= lastEnd) {\n            selected.push(activities[i]);\n            lastEnd = activities[i][1];\n        }\n    }\n\n    return selected;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"4-calendar-scheduling",children:"4. Calendar Scheduling"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class MyCalendar {\n    constructor() {\n        this.bookings = [];\n    }\n\n    book(start, end) {\n        // Check for conflicts\n        for (const [s, e] of this.bookings) {\n            if (Math.max(start, s) < Math.min(end, e)) {\n                return false; // Conflict found\n            }\n        }\n\n        this.bookings.push([start, end]);\n        this.bookings.sort((a, b) => a[0] - b[0]);\n        return true;\n    }\n}\n\nclass MyCalendarTwo {\n    constructor() {\n        this.bookings = [];\n        this.overlaps = [];\n    }\n\n    book(start, end) {\n        // Check for triple booking\n        for (const [s, e] of this.overlaps) {\n            if (Math.max(start, s) < Math.min(end, e)) {\n                return false;\n            }\n        }\n\n        // Add to overlaps if it conflicts with existing booking\n        for (const [s, e] of this.bookings) {\n            if (Math.max(start, s) < Math.min(end, e)) {\n                this.overlaps.push([Math.max(start, s), Math.min(end, e)]);\n            }\n        }\n\n        this.bookings.push([start, end]);\n        return true;\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"complexity-analysis--tips",children:"Complexity Analysis & Tips"}),"\n",(0,r.jsx)(n.h3,{id:"time-complexities",children:"Time Complexities:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sorting"}),": O(n log n)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Merge intervals"}),": O(n log n)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Meeting rooms"}),": O(n log n)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sweep line"}),": O(n log n)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Interval tree search"}),": O(log n)"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"space-complexities",children:"Space Complexities:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Basic operations"}),": O(1) to O(n)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Priority queue"}),": O(n)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Interval tree"}),": O(n)"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"key-optimization-strategies",children:"Key Optimization Strategies:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sort First"}),": Most interval problems benefit from sorting"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Greedy Approach"}),": Often optimal for scheduling problems"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Two Pointers"}),": Efficient for merging sorted interval lists"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Event Processing"}),": Sweep line for complex overlapping scenarios"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Data Structures"}),": Use appropriate structures (heaps, trees) for dynamic scenarios"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"common-pitfalls",children:"Common Pitfalls:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// 1. Edge case handling\nif (intervals.length <= 1) return intervals;\n\n// 2. Boundary conditions\nif (start === end) continue; // Empty interval\n\n// 3. Sorting stability\nintervals.sort((a, b) => {\n    if (a[0] !== b[0]) return a[0] - b[0];\n    return a[1] - b[1]; // Secondary sort by end time\n});\n\n// 4. Inclusive vs exclusive intervals\nconst overlaps = start1 < end2 && start2 < end1; // Exclusive\nconst overlapsInclusive = start1 <= end2 && start2 <= end1; // Inclusive\n"})}),"\n",(0,r.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(n.p,{children:"Master these patterns to solve any interval problem:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sort by start/end time"})," as needed"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use greedy algorithms"})," for optimization problems"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Apply sweep line"})," for complex event processing"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Utilize data structures"})," (heaps, trees) for dynamic scenarios"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Handle edge cases"})," carefully (empty intervals, single interval, etc.)"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);