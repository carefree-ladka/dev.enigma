"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[420],{6539:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>c,frontMatter:()=>s,metadata:()=>o,toc:()=>a});var t=r(4848),i=r(8453);const s={},l="Advanced Algorithm Techniques",o={id:"DSA/AdvancedTechniques",title:"Advanced Algorithm Techniques",description:"Euler Tour Technique (ETT)",source:"@site/docs/DSA/AdvancedTechniques.mdx",sourceDirName:"DSA",slug:"/DSA/AdvancedTechniques",permalink:"/js.enigma/docs/DSA/AdvancedTechniques",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/DSA/AdvancedTechniques.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"AVL Tree",permalink:"/js.enigma/docs/DSA/AVLTree"},next:{title:"Breadth-First Search (BFS) for Trees",permalink:"/js.enigma/docs/DSA/BFSTree"}},d={},a=[{value:"Euler Tour Technique (ETT)",id:"euler-tour-technique-ett",level:2},{value:"Theory",id:"theory",level:3},{value:"Key Concepts",id:"key-concepts",level:3},{value:"Implementation",id:"implementation",level:3},{value:"LeetCode Problems",id:"leetcode-problems",level:3},{value:"Point Update Range Sum (Segment Tree)",id:"point-update-range-sum-segment-tree",level:2},{value:"Theory",id:"theory-1",level:3},{value:"Key Concepts",id:"key-concepts-1",level:3},{value:"Implementation",id:"implementation-1",level:3},{value:"LeetCode Problems",id:"leetcode-problems-1",level:3},{value:"Meet in the Middle",id:"meet-in-the-middle",level:2},{value:"Theory",id:"theory-2",level:3},{value:"Key Concepts",id:"key-concepts-2",level:3},{value:"Implementation Example (Subset Sum)",id:"implementation-example-subset-sum",level:3},{value:"LeetCode Problems",id:"leetcode-problems-2",level:3},{value:"Common Use Cases &amp; Tips",id:"common-use-cases--tips",level:2},{value:"Euler Tour Technique",id:"euler-tour-technique",level:3},{value:"Point Update Range Sum",id:"point-update-range-sum",level:3},{value:"Meet in the Middle",id:"meet-in-the-middle-1",level:3},{value:"Time Complexity Analysis",id:"time-complexity-analysis",level:2},{value:"Euler Tour",id:"euler-tour",level:3},{value:"Segment Tree",id:"segment-tree",level:3},{value:"Meet in the Middle",id:"meet-in-the-middle-2",level:3}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"advanced-algorithm-techniques",children:"Advanced Algorithm Techniques"})}),"\n",(0,t.jsx)(n.h2,{id:"euler-tour-technique-ett",children:"Euler Tour Technique (ETT)"}),"\n",(0,t.jsx)(n.h3,{id:"theory",children:"Theory"}),"\n",(0,t.jsx)(n.p,{children:"The Euler Tour Technique is a method for processing trees by converting them into a linear array representation. It involves performing a DFS traversal and recording each vertex both when entering and leaving it."}),"\n",(0,t.jsx)(n.h3,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Creates a linear representation of a tree"}),"\n",(0,t.jsx)(n.li,{children:"Each node appears twice: entry and exit times"}),"\n",(0,t.jsx)(n.li,{children:"Useful for solving subtree queries efficiently"}),"\n",(0,t.jsx)(n.li,{children:"Time complexity: O(n) for preprocessing, O(1) for queries"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"implementation",children:"Implementation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"class EulerTour {\r\n    constructor(n) {\r\n        this.adj = Array.from({ length: n }, () => []);\r\n        this.tour = [];\r\n        this.first = new Array(n).fill(-1);\r\n        this.last = new Array(n).fill(-1);\r\n    }\r\n\r\n    addEdge(u, v) {\r\n        this.adj[u].push(v);\r\n        this.adj[v].push(u);\r\n    }\r\n\r\n    dfs(node, parent) {\r\n        if (this.first[node] === -1) {\r\n            this.first[node] = this.tour.length;\r\n        }\r\n        this.tour.push(node);\r\n        \r\n        for (const child of this.adj[node]) {\r\n            if (child !== parent) {\r\n                this.dfs(child, node);\r\n                this.tour.push(node);\r\n            }\r\n        }\r\n        \r\n        this.last[node] = this.tour.length - 1;\r\n    }\r\n\r\n    buildTour(root = 0) {\r\n        this.dfs(root, -1);\r\n        return {\r\n            tour: this.tour,\r\n            first: this.first,\r\n            last: this.last\r\n        };\r\n    }\r\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"leetcode-problems",children:"LeetCode Problems"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://leetcode.com/problems/kth-ancestor-of-a-tree-node/",children:"1483. Kth Ancestor of a Tree Node"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://leetcode.com/problems/minimize-the-total-price-of-the-trips/",children:"2646. Minimize the Total Price of the Trips"})}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"point-update-range-sum-segment-tree",children:"Point Update Range Sum (Segment Tree)"}),"\n",(0,t.jsx)(n.h3,{id:"theory-1",children:"Theory"}),"\n",(0,t.jsx)(n.p,{children:"A Segment Tree is a data structure that allows both range queries and point updates efficiently. It's particularly useful when you need to perform multiple updates and range queries on an array."}),"\n",(0,t.jsx)(n.h3,{id:"key-concepts-1",children:"Key Concepts"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Binary tree structure"}),"\n",(0,t.jsx)(n.li,{children:"Each node represents a range"}),"\n",(0,t.jsx)(n.li,{children:"Supports point updates in O(log n)"}),"\n",(0,t.jsx)(n.li,{children:"Supports range queries in O(log n)"}),"\n",(0,t.jsx)(n.li,{children:"Space complexity: O(n)"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"implementation-1",children:"Implementation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"class SegmentTree {\r\n    constructor(arr) {\r\n        this.n = arr.length;\r\n        this.tree = new Array(4 * this.n).fill(0);\r\n        this.build(arr, 1, 0, this.n - 1);\r\n    }\r\n\r\n    build(arr, node, start, end) {\r\n        if (start === end) {\r\n            this.tree[node] = arr[start];\r\n            return;\r\n        }\r\n\r\n        const mid = Math.floor((start + end) / 2);\r\n        this.build(arr, 2 * node, start, mid);\r\n        this.build(arr, 2 * node + 1, mid + 1, end);\r\n        this.tree[node] = this.tree[2 * node] + this.tree[2 * node + 1];\r\n    }\r\n\r\n    update(index, val, node = 1, start = 0, end = this.n - 1) {\r\n        if (start === end) {\r\n            this.tree[node] = val;\r\n            return;\r\n        }\r\n\r\n        const mid = Math.floor((start + end) / 2);\r\n        if (index <= mid) {\r\n            this.update(index, val, 2 * node, start, mid);\r\n        } else {\r\n            this.update(index, val, 2 * node + 1, mid + 1, end);\r\n        }\r\n        this.tree[node] = this.tree[2 * node] + this.tree[2 * node + 1];\r\n    }\r\n\r\n    query(left, right, node = 1, start = 0, end = this.n - 1) {\r\n        if (right < start || left > end) return 0;\r\n        if (left <= start && end <= right) return this.tree[node];\r\n\r\n        const mid = Math.floor((start + end) / 2);\r\n        const leftSum = this.query(left, right, 2 * node, start, mid);\r\n        const rightSum = this.query(left, right, 2 * node + 1, mid + 1, end);\r\n        return leftSum + rightSum;\r\n    }\r\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"leetcode-problems-1",children:"LeetCode Problems"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://leetcode.com/problems/range-sum-query-mutable/",children:"307. Range Sum Query - Mutable"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://leetcode.com/problems/booking-concert-tickets-in-groups/",children:"2286. Booking Concert Tickets in Groups"})}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"meet-in-the-middle",children:"Meet in the Middle"}),"\n",(0,t.jsx)(n.h3,{id:"theory-2",children:"Theory"}),"\n",(0,t.jsx)(n.p,{children:"Meet in the Middle is a technique that splits the input into two roughly equal parts, processes them separately, and then combines the results. It's particularly useful when the brute force approach would be too slow."}),"\n",(0,t.jsx)(n.h3,{id:"key-concepts-2",children:"Key Concepts"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Divides the problem into two smaller subproblems"}),"\n",(0,t.jsx)(n.li,{children:"Processes each half independently"}),"\n",(0,t.jsx)(n.li,{children:"Combines results efficiently"}),"\n",(0,t.jsx)(n.li,{children:"Usually reduces time complexity from O(2^n) to O(2^(n/2))"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"implementation-example-subset-sum",children:"Implementation Example (Subset Sum)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function meetInMiddle(arr, target) {\r\n    const n = arr.length;\r\n    const mid = Math.floor(n / 2);\r\n    \r\n    // Generate all possible sums for first half\r\n    function generateSums(start, end) {\r\n        const sums = [];\r\n        const len = end - start;\r\n        \r\n        for (let mask = 0; mask < (1 << len); mask++) {\r\n            let sum = 0;\r\n            for (let i = 0; i < len; i++) {\r\n                if (mask & (1 << i)) {\r\n                    sum += arr[start + i];\r\n                }\r\n            }\r\n            sums.push(sum);\r\n        }\r\n        return sums.sort((a, b) => a - b);\r\n    }\r\n    \r\n    const leftSums = generateSums(0, mid);\r\n    const rightSums = generateSums(mid, n);\r\n    \r\n    // Binary search to find pairs that sum to target\r\n    let count = 0;\r\n    for (const leftSum of leftSums) {\r\n        const complement = target - leftSum;\r\n        const low = rightSums.findIndex(x => x >= complement);\r\n        const high = rightSums.findIndex(x => x > complement);\r\n        if (low !== -1 && high !== -1) {\r\n            count += high - low;\r\n        }\r\n    }\r\n    \r\n    return count;\r\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"leetcode-problems-2",children:"LeetCode Problems"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://leetcode.com/problems/closest-subsequence-sum/",children:"1755. Closest Subsequence Sum"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/",children:"2035. Partition Array Into Two Arrays to Minimize Sum Difference"})}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"common-use-cases--tips",children:"Common Use Cases & Tips"}),"\n",(0,t.jsx)(n.h3,{id:"euler-tour-technique",children:"Euler Tour Technique"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Tree path queries"}),"\n",(0,t.jsx)(n.li,{children:"Subtree problems"}),"\n",(0,t.jsx)(n.li,{children:"LCA (Lowest Common Ancestor) queries"}),"\n",(0,t.jsx)(n.li,{children:"Subtree modification queries"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"point-update-range-sum",children:"Point Update Range Sum"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Dynamic range queries"}),"\n",(0,t.jsx)(n.li,{children:"Interval problems"}),"\n",(0,t.jsx)(n.li,{children:"Cumulative statistics"}),"\n",(0,t.jsx)(n.li,{children:"Online query processing"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"meet-in-the-middle-1",children:"Meet in the Middle"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Subset sum problems"}),"\n",(0,t.jsx)(n.li,{children:"Problems with exponential complexity"}),"\n",(0,t.jsx)(n.li,{children:"Optimization problems with small constraints"}),"\n",(0,t.jsx)(n.li,{children:"When searching through all possibilities is required but too slow"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"time-complexity-analysis",children:"Time Complexity Analysis"}),"\n",(0,t.jsx)(n.h3,{id:"euler-tour",children:"Euler Tour"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Preprocessing: O(n)"}),"\n",(0,t.jsx)(n.li,{children:"Query: O(1) with additional data structures"}),"\n",(0,t.jsx)(n.li,{children:"Space: O(n)"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"segment-tree",children:"Segment Tree"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Build: O(n)"}),"\n",(0,t.jsx)(n.li,{children:"Update: O(log n)"}),"\n",(0,t.jsx)(n.li,{children:"Query: O(log n)"}),"\n",(0,t.jsx)(n.li,{children:"Space: O(n)"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"meet-in-the-middle-2",children:"Meet in the Middle"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Time: O(2^(n/2))"}),"\n",(0,t.jsx)(n.li,{children:"Space: O(2^(n/2))"}),"\n",(0,t.jsx)(n.li,{children:"Typically used when n \u2264 40"}),"\n"]})]})}function c(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>o});var t=r(6540);const i={},s=t.createContext(i);function l(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);