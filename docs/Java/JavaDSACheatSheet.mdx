# Java DSA Cheat Sheet

## Basic Syntax & Input/Output

### Main Method & Imports
```java
import java.util.*;
import java.io.*;

public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        // Your code here
        sc.close();
    }
}
```

### Input/Output
```java
// Scanner input
Scanner sc = new Scanner(System.in);
int n = sc.nextInt();
String s = sc.nextLine();
String word = sc.next();

// Fast I/O for competitive programming
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
String line = br.readLine();
int num = Integer.parseInt(br.readLine());
bw.write("Result: " + result + "\n");
bw.flush();

// Output
System.out.println("Hello");
System.out.print("No newline");
System.out.printf("%d %.2f %s\n", num, decimal, string);
```

## Data Types & Operations

### Primitive Types
```java
int i = 42;                    // 32-bit: -2^31 to 2^31-1
long l = 42L;                  // 64-bit: -2^63 to 2^63-1
double d = 3.14;               // 64-bit floating point
char c = 'A';                  // 16-bit Unicode
boolean b = true;              // true/false

// Constants
final int MAX_SIZE = 1000;
```

### String Operations
```java
String s = "hello";
int len = s.length();
char ch = s.charAt(0);
String sub = s.substring(1, 4);        // "ell"
String[] parts = s.split(" ");
String joined = String.join(",", parts);

// String comparison
s1.equals(s2);                         // Content equality
s1.compareTo(s2);                      // Lexicographic comparison

// StringBuilder (mutable)
StringBuilder sb = new StringBuilder();
sb.append("text");
sb.insert(0, "prefix");
sb.deleteCharAt(0);
String result = sb.toString();
```

### Math Operations
```java
Math.max(a, b);
Math.min(a, b);
Math.abs(x);
Math.pow(base, exp);
Math.sqrt(x);
Math.ceil(x);
Math.floor(x);
Math.log(x);                           // Natural log
Math.log10(x);                         // Base 10 log

// Integer operations
Integer.MAX_VALUE;                     // 2147483647
Integer.MIN_VALUE;                     // -2147483648
Integer.parseInt("123");
String.valueOf(123);
```

## Arrays

### 1D Arrays
```java
// Declaration and initialization
int[] arr = new int[5];
int[] arr = {1, 2, 3, 4, 5};
int[] arr = new int[]{1, 2, 3, 4, 5};

// Operations
int len = arr.length;
Arrays.fill(arr, -1);                  // Fill with value
Arrays.sort(arr);                      // Sort ascending
Arrays.sort(arr, Collections.reverseOrder()); // Sort descending (Integer[] needed)

// Binary search (array must be sorted)
int index = Arrays.binarySearch(arr, target);

// Copy array
int[] copy = Arrays.copyOf(arr, arr.length);
int[] copy = arr.clone();
```

### 2D Arrays
```java
// Declaration
int[][] matrix = new int[rows][cols];
int[][] matrix = {{1,2,3}, {4,5,6}};

// Jagged arrays
int[][] jagged = new int[3][];
jagged[0] = new int[2];
jagged[1] = new int[4];

// Iteration
for(int i = 0; i < matrix.length; i++) {
    for(int j = 0; j < matrix[i].length; j++) {
        // matrix[i][j]
    }
}

// Enhanced for loop
for(int[] row : matrix) {
    for(int val : row) {
        // val
    }
}
```

## Collections Framework

### ArrayList
```java
ArrayList<Integer> list = new ArrayList<>();
list.add(1);                           // Add element
list.add(0, 5);                        // Add at index
list.get(0);                           // Get element
list.set(0, 10);                       // Set element
list.remove(0);                        // Remove by index
list.remove(Integer.valueOf(5));       // Remove by value
list.size();                           // Size
list.isEmpty();                        // Check if empty
list.contains(5);                      // Check if contains

// Convert to array
Integer[] array = list.toArray(new Integer[0]);

// Sorting
Collections.sort(list);
Collections.sort(list, Collections.reverseOrder());
```

### LinkedList
```java
LinkedList<Integer> ll = new LinkedList<>();
ll.addFirst(1);
ll.addLast(2);
ll.removeFirst();
ll.removeLast();
ll.peekFirst();                        // Get first without removing
ll.peekLast();                         // Get last without removing
```

### Stack
```java
Stack<Integer> stack = new Stack<>();
stack.push(1);                         // Add to top
int top = stack.pop();                 // Remove and return top
int peek = stack.peek();               // Get top without removing
boolean empty = stack.isEmpty();

// Alternative: Use ArrayDeque
ArrayDeque<Integer> stack = new ArrayDeque<>();
stack.push(1);
stack.pop();
stack.peek();
```

### Queue
```java
Queue<Integer> queue = new LinkedList<>();
queue.offer(1);                        // Add to rear
int front = queue.poll();              // Remove and return front
int peek = queue.peek();               // Get front without removing
boolean empty = queue.isEmpty();

// Priority Queue (Min Heap by default)
PriorityQueue<Integer> pq = new PriorityQueue<>();
PriorityQueue<Integer> maxPq = new PriorityQueue<>(Collections.reverseOrder());

pq.offer(5);
pq.offer(1);
pq.offer(3);
int min = pq.poll();                   // Returns 1

// Custom comparator
PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);
```

### Deque (Double-ended Queue)
```java
ArrayDeque<Integer> deque = new ArrayDeque<>();
deque.addFirst(1);
deque.addLast(2);
deque.removeFirst();
deque.removeLast();
deque.peekFirst();
deque.peekLast();
```

### HashSet
```java
HashSet<Integer> set = new HashSet<>();
set.add(1);
set.remove(1);
boolean contains = set.contains(1);
int size = set.size();

// LinkedHashSet maintains insertion order
LinkedHashSet<Integer> linkedSet = new LinkedHashSet<>();

// TreeSet (sorted)
TreeSet<Integer> treeSet = new TreeSet<>();
int first = treeSet.first();
int last = treeSet.last();
```

### HashMap
```java
HashMap<String, Integer> map = new HashMap<>();
map.put("key", 1);                     // Add/update
int value = map.get("key");            // Get value
int value = map.getOrDefault("key", 0); // Get with default
boolean hasKey = map.containsKey("key");
boolean hasValue = map.containsValue(1);
map.remove("key");

// Iteration
for(String key : map.keySet()) {
    int val = map.get(key);
}

for(Map.Entry<String, Integer> entry : map.entrySet()) {
    String key = entry.getKey();
    int value = entry.getValue();
}

// TreeMap (sorted by keys)
TreeMap<String, Integer> treeMap = new TreeMap<>();
String firstKey = treeMap.firstKey();
String lastKey = treeMap.lastKey();
```

## Common DSA Patterns

### Two Pointers
```java
// Array two pointers
int left = 0, right = arr.length - 1;
while(left < right) {
    if(condition) {
        left++;
    } else {
        right--;
    }
}

// Fast and slow pointers (Floyd's algorithm)
int slow = 0, fast = 0;
while(fast < n && fast + 1 < n) {
    slow++;
    fast += 2;
}
```

### Sliding Window
```java
int left = 0;
for(int right = 0; right < arr.length; right++) {
    // Add arr[right] to window

    while(windowNotValid) {
        // Remove arr[left] from window
        left++;
    }

    // Process current window [left, right]
}
```

### Binary Search
```java
// Template for binary search
int left = 0, right = arr.length - 1;
while(left <= right) {
    int mid = left + (right - left) / 2;
    if(arr[mid] == target) {
        return mid;
    } else if(arr[mid] < target) {
        left = mid + 1;
    } else {
        right = mid - 1;
    }
}

// Find leftmost/rightmost position
int findFirst(int[] arr, int target) {
    int left = 0, right = arr.length - 1, result = -1;
    while(left <= right) {
        int mid = left + (right - left) / 2;
        if(arr[mid] == target) {
            result = mid;
            right = mid - 1;  // Continue searching left
        } else if(arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return result;
}
```

### DFS (Depth-First Search)
```java
// Recursive DFS
void dfs(int[][] grid, int row, int col, boolean[][] visited) {
    if(row < 0 || row >= grid.length || col < 0 || col >= grid[0].length ||
       visited[row][col]) {
        return;
    }

    visited[row][col] = true;

    // Process current cell

    // Visit neighbors
    dfs(grid, row + 1, col, visited);
    dfs(grid, row - 1, col, visited);
    dfs(grid, row, col + 1, visited);
    dfs(grid, row, col - 1, visited);
}

// Iterative DFS using stack
Stack<int[]> stack = new Stack<>();
stack.push(new int[]{startRow, startCol});

while(!stack.isEmpty()) {
    int[] current = stack.pop();
    int row = current[0], col = current[1];

    if(visited[row][col]) continue;
    visited[row][col] = true;

    // Add neighbors to stack
    // stack.push(new int[]{newRow, newCol});
}
```

### BFS (Breadth-First Search)
```java
Queue<int[]> queue = new LinkedList<>();
queue.offer(new int[]{startRow, startCol});
visited[startRow][startCol] = true;

int level = 0;
while(!queue.isEmpty()) {
    int size = queue.size();

    for(int i = 0; i < size; i++) {
        int[] current = queue.poll();
        int row = current[0], col = current[1];

        // Process current cell

        // Add unvisited neighbors
        int[][] directions = {{0,1}, {1,0}, {0,-1}, {-1,0}};
        for(int[] dir : directions) {
            int newRow = row + dir[0];
            int newCol = col + dir[1];

            if(isValid(newRow, newCol) && !visited[newRow][newCol]) {
                visited[newRow][newCol] = true;
                queue.offer(new int[]{newRow, newCol});
            }
        }
    }
    level++;
}
```

### Union-Find (Disjoint Set)
```java
class UnionFind {
    int[] parent, rank;

    public UnionFind(int n) {
        parent = new int[n];
        rank = new int[n];
        for(int i = 0; i < n; i++) {
            parent[i] = i;
            rank[i] = 1;
        }
    }

    public int find(int x) {
        if(parent[x] != x) {
            parent[x] = find(parent[x]); // Path compression
        }
        return parent[x];
    }

    public boolean union(int x, int y) {
        int rootX = find(x), rootY = find(y);
        if(rootX == rootY) return false;

        // Union by rank
        if(rank[rootX] < rank[rootY]) {
            parent[rootX] = rootY;
        } else if(rank[rootX] > rank[rootY]) {
            parent[rootY] = rootX;
        } else {
            parent[rootY] = rootX;
            rank[rootX]++;
        }
        return true;
    }
}
```

### Trie (Prefix Tree)
```java
class TrieNode {
    TrieNode[] children = new TrieNode[26];
    boolean isEnd = false;
}

class Trie {
    TrieNode root;

    public Trie() {
        root = new TrieNode();
    }

    public void insert(String word) {
        TrieNode curr = root;
        for(char c : word.toCharArray()) {
            int index = c - 'a';
            if(curr.children[index] == null) {
                curr.children[index] = new TrieNode();
            }
            curr = curr.children[index];
        }
        curr.isEnd = true;
    }

    public boolean search(String word) {
        TrieNode curr = root;
        for(char c : word.toCharArray()) {
            int index = c - 'a';
            if(curr.children[index] == null) return false;
            curr = curr.children[index];
        }
        return curr.isEnd;
    }
}
```

## Dynamic Programming

### Common DP Patterns
```java
// 1D DP
int[] dp = new int[n + 1];
dp[0] = base_case;
for(int i = 1; i <= n; i++) {
    dp[i] = // transition from previous states
}

// 2D DP
int[][] dp = new int[m + 1][n + 1];
for(int i = 0; i <= m; i++) {
    for(int j = 0; j <= n; j++) {
        if(i == 0 || j == 0) {
            dp[i][j] = base_case;
        } else {
            dp[i][j] = // transition
        }
    }
}

// Memoization (Top-down)
Map<String, Integer> memo = new HashMap<>();
int solve(int i, int j) {
    String key = i + "," + j;
    if(memo.containsKey(key)) return memo.get(key);

    // Base cases
    if(i == 0 || j == 0) return base_case;

    int result = // recursive calls
    memo.put(key, result);
    return result;
}
```

## Useful Utilities

### Comparators
```java
// Sort array of arrays by first element
Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));

// Sort in descending order
Arrays.sort(arr, (a, b) -> b - a);

// Multiple criteria sorting
Arrays.sort(people, (a, b) -> {
    if(a[0] == b[0]) return a[1] - b[1];  // Secondary sort
    return a[0] - b[0];                   // Primary sort
});

// Custom object sorting
Collections.sort(list, new Comparator<Person>() {
    public int compare(Person a, Person b) {
        return a.age - b.age;
    }
});
```

### Bit Manipulation
```java
// Common operations
int setBit = n | (1 << i);            // Set i-th bit
int clearBit = n & ~(1 << i);         // Clear i-th bit
int toggleBit = n ^ (1 << i);         // Toggle i-th bit
boolean isSet = (n & (1 << i)) != 0;  // Check if i-th bit is set

// Useful tricks
int rightmostSetBit = n & (-n);       // Get rightmost set bit
int clearRightmostSetBit = n & (n-1); // Clear rightmost set bit
boolean isPowerOfTwo = n > 0 && (n & (n-1)) == 0;
int countSetBits = Integer.bitCount(n);
```

### Common Edge Cases to Consider
- Empty arrays/strings
- Single element arrays
- Integer overflow (use `long` when needed)
- Null inputs
- Negative numbers
- Duplicate elements
- Array bounds checking
