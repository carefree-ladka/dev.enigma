# Frontend System Design Trade-offs: A Comprehensive Guide

## Table of Contents

1. [Introduction](#introduction)
2. [Rendering Strategies](#rendering-strategies)
   - [CSR vs SSR vs SSG vs ISR](#csr-vs-ssr-vs-ssg-vs-isr)
   - [Hydration Strategies](#hydration-strategies)
   - [Streaming SSR](#streaming-ssr)
3. [State Management](#state-management)
   - [Local vs Global State](#local-vs-global-state)
   - [Server State Management](#server-state-management)
   - [State Synchronization](#state-synchronization)
4. [Data Fetching](#data-fetching)
   - [API Architectural Patterns](#api-architectural-patterns)
   - [Caching Strategies](#caching-strategies)
   - [Real-time Data](#real-time-data)
5. [Performance Optimization](#performance-optimization)
   - [Bundle Optimization](#bundle-optimization)
   - [Runtime Performance](#runtime-performance)
   - [Network Performance](#network-performance)
   - [Rendering Performance](#rendering-performance)
6. [Component Architecture](#component-architecture)
   - [Component Patterns](#component-patterns)
   - [Composition vs Inheritance](#composition-vs-inheritance)
   - [Code Reusability](#code-reusability)
7. [Styling Approaches](#styling-approaches)
   - [CSS Methodologies](#css-methodologies)
   - [Runtime vs Build-time](#runtime-vs-build-time)
   - [Theming Systems](#theming-systems)
8. [Routing Architecture](#routing-architecture)
   - [Client vs Server Routing](#client-vs-server-routing)
   - [Route-based Code Splitting](#route-based-code-splitting)
   - [Deep Linking](#deep-linking)
9. [Micro-Frontend Architecture](#micro-frontend-architecture)
   - [Integration Approaches](#integration-approaches)
   - [Communication Patterns](#communication-patterns)
   - [Shared Dependencies](#shared-dependencies)
10. [Security Considerations](#security-considerations)
    - [Authentication Patterns](#authentication-patterns)
    - [Data Validation](#data-validation)
    - [XSS and CSRF Protection](#xss-and-csrf-protection)
11. [Accessibility](#accessibility)
    - [WCAG Compliance](#wcag-compliance)
    - [Performance vs Accessibility](#performance-vs-accessibility)
    - [Testing Strategies](#testing-strategies)
12. [Observability](#observability)
    - [Logging Strategies](#logging-strategies)
    - [Error Tracking](#error-tracking)
    - [Performance Monitoring](#performance-monitoring)
13. [Testing Strategy](#testing-strategy)
    - [Testing Pyramid](#testing-pyramid)
    - [Testing Types](#testing-types)
    - [Test Coverage vs Speed](#test-coverage-vs-speed)
14. [Deployment Strategies](#deployment-strategies)
    - [Feature Flags](#feature-flags)
    - [Progressive Rollouts](#progressive-rollouts)
    - [Rollback Mechanisms](#rollback-mechanisms)
15. [Mobile Considerations](#mobile-considerations)
    - [Responsive vs Adaptive](#responsive-vs-adaptive)
    - [Mobile-first vs Desktop-first](#mobile-first-vs-desktop-first)
    - [Progressive Web Apps](#progressive-web-apps)
16. [Interview Framework](#interview-framework)
    - [How to Approach Questions](#how-to-approach-questions)
    - [Common Pitfalls](#common-pitfalls)
    - [Sample Answers](#sample-answers)

---

## Introduction

This guide provides a comprehensive overview of frontend system design trade-offs for technical interviews at companies like Google, Amazon, Microsoft, and other tech giants. Each section explores real-world decisions, their implications, and when to apply them.

**Key Principle**: Every architectural decision is a trade-off. There are no universally "best" solutionsâ€”only appropriate choices for specific contexts.

---

## Rendering Strategies

### CSR vs SSR vs SSG vs ISR

| Approach | Pros | Cons | Best Use Cases | Example |
|----------|------|------|----------------|---------|
| **CSR** (Client-Side Rendering) | â€¢ Simple deployment<br/>â€¢ Low server costs<br/>â€¢ Rich interactivity<br/>â€¢ Easy state management | â€¢ Slow First Contentful Paint<br/>â€¢ Poor SEO (without workarounds)<br/>â€¢ Blank screen on slow networks<br/>â€¢ Higher client device load | â€¢ Admin dashboards<br/>â€¢ Internal tools<br/>â€¢ Apps behind auth<br/>â€¢ Highly interactive SPAs | Gmail, Notion |
| **SSR** (Server-Side Rendering) | â€¢ Fast First Contentful Paint<br/>â€¢ Excellent SEO<br/>â€¢ Works without JS<br/>â€¢ Fresh data on every request | â€¢ Higher server costs<br/>â€¢ TTFB dependency<br/>â€¢ More complex deployment<br/>â€¢ Hydration overhead | â€¢ E-commerce product pages<br/>â€¢ News sites<br/>â€¢ Social media feeds<br/>â€¢ Content-heavy apps | Amazon, Twitter |
| **SSG** (Static Site Generation) | â€¢ Fastest possible loads<br/>â€¢ CDN-friendly<br/>â€¢ Lowest hosting cost<br/>â€¢ Best SEO | â€¢ Build time scales poorly<br/>â€¢ Data can be stale<br/>â€¢ Not suitable for personalized content | â€¢ Blogs<br/>â€¢ Documentation<br/>â€¢ Marketing sites<br/>â€¢ Landing pages | Vercel docs, Gatsby sites |
| **ISR** (Incremental Static Regeneration) | â€¢ Balance of fresh + fast<br/>â€¢ On-demand regeneration<br/>â€¢ CDN benefits<br/>â€¢ Scales better than SSG | â€¢ More complex mental model<br/>â€¢ Stale-while-revalidate behavior<br/>â€¢ Platform-specific (Next.js) | â€¢ Product catalogs<br/>â€¢ SEO landing pages<br/>â€¢ News sites with updates | E-commerce listings |

**Decision Framework:**
```
Is data user-specific?
  â”œâ”€ Yes â†’ CSR or SSR
  â”‚   â””â”€ Need SEO?
  â”‚       â”œâ”€ Yes â†’ SSR
  â”‚       â””â”€ No â†’ CSR
  â””â”€ No â†’ SSG or ISR
      â””â”€ Updates frequently?
          â”œâ”€ Yes â†’ ISR
          â””â”€ No â†’ SSG
```

### Hydration Strategies

| Strategy | Description | Trade-off | Use When |
|----------|-------------|-----------|----------|
| **Full Hydration** | Hydrate entire page at once | Simple but slow on large pages | Small to medium apps |
| **Progressive Hydration** | Hydrate components as needed | Complex but faster TTI | Large apps with clear priority |
| **Partial Hydration** (Islands Architecture) | Only hydrate interactive parts | Best performance but requires careful planning | Mixed static/dynamic content |
| **Resumability** (Qwik) | Zero hydration, resume from HTML | Fastest but new paradigm | Performance-critical apps |

**Key Insight**: Hydration is pure overhead. The less you hydrate, the faster your app, but the more complex your architecture.

### Streaming SSR

**Pros:**
- Progressive rendering (faster perceived performance)
- Doesn't block on slow data fetching
- Better TTFB for complex pages

**Cons:**
- More complex error handling
- Requires React 18+ or similar framework support
- Can't set HTTP headers after streaming starts

**Use when:** You have pages with mixed fast/slow data sources (e.g., user profile with slow recommendation feed).

---

## State Management

### Local vs Global State

| Approach | Pros | Cons | Best For |
|----------|------|------|----------|
| **Local State** (useState, useReducer) | â€¢ Simple mental model<br/>â€¢ No external dependencies<br/>â€¢ Predictable performance<br/>â€¢ Easy to test | â€¢ Hard to share between distant components<br/>â€¢ Prop drilling<br/>â€¢ Duplication across components | â€¢ UI state (modals, forms)<br/>â€¢ Component-specific logic<br/>â€¢ Temporary data |
| **Context API** | â€¢ Built into React<br/>â€¢ No extra library<br/>â€¢ Good for theme/i18n | â€¢ Re-renders all consumers<br/>â€¢ Poor performance at scale<br/>â€¢ Not designed for frequent updates | â€¢ Global config<br/>â€¢ Theme/locale<br/>â€¢ User authentication status |
| **Redux** | â€¢ Predictable state changes<br/>â€¢ Time-travel debugging<br/>â€¢ Middleware ecosystem<br/>â€¢ DevTools | â€¢ Boilerplate heavy<br/>â€¢ Learning curve<br/>â€¢ Over-engineering for simple apps | â€¢ Complex business logic<br/>â€¢ Apps with many features<br/>â€¢ Need for undo/redo |
| **Zustand** | â€¢ Minimal boilerplate<br/>â€¢ Great DX<br/>â€¢ Flexible | â€¢ Less mature ecosystem<br/>â€¢ Fewer DevTools | â€¢ Medium apps<br/>â€¢ When Redux feels heavy |
| **Jotai/Recoil** | â€¢ Atomic state<br/>â€¢ Minimal re-renders<br/>â€¢ Derived state | â€¢ Different paradigm<br/>â€¢ Smaller community | â€¢ Performance-critical apps<br/>â€¢ Complex derived state |

### Server State Management

| Library | Pros | Cons | Use When |
|---------|------|------|----------|
| **React Query / TanStack Query** | â€¢ Caching built-in<br/>â€¢ Automatic refetching<br/>â€¢ Optimistic updates<br/>â€¢ DevTools | â€¢ Learning curve<br/>â€¢ Additional dependency | Default choice for server state |
| **SWR** | â€¢ Simpler API<br/>â€¢ Stale-while-revalidate<br/>â€¢ Smaller bundle | â€¢ Fewer features than React Query | Simpler apps, Vercel ecosystem |
| **Apollo Client** (GraphQL) | â€¢ GraphQL integration<br/>â€¢ Normalized cache<br/>â€¢ Real-time subscriptions | â€¢ Heavy bundle<br/>â€¢ GraphQL-only<br/>â€¢ Complex cache | GraphQL apps with complex data |
| **RTK Query** | â€¢ Redux integration<br/>â€¢ Code generation<br/>â€¢ Cache invalidation | â€¢ Redux required<br/>â€¢ More setup | Already using Redux |

**Golden Rule**:
- **UI state** â†’ Local state
- **Server state** â†’ React Query/SWR
- **Cross-feature business logic** â†’ Redux/Zustand

### State Synchronization

| Pattern | Description | Trade-off |
|---------|-------------|-----------|
| **Optimistic Updates** | Update UI before server confirms | Fast UX but requires rollback logic |
| **Pessimistic Updates** | Wait for server before updating UI | Slower UX but simpler logic |
| **Event Sourcing** | Store state changes as events | Complete history but complex |
| **CQRS** | Separate read/write models | Scales well but more infrastructure |

---

## Data Fetching

### API Architectural Patterns

| Pattern | Pros | Cons | Best For |
|---------|------|------|----------|
| **REST** | â€¢ Simple, well-understood<br/>â€¢ HTTP caching friendly<br/>â€¢ Stateless<br/>â€¢ Wide tooling support | â€¢ Over-fetching (get more data than needed)<br/>â€¢ Under-fetching (multiple requests needed)<br/>â€¢ Versioning challenges | â€¢ Public APIs<br/>â€¢ Simple CRUD operations<br/>â€¢ When HTTP caching is critical |
| **GraphQL** | â€¢ Request exactly what you need<br/>â€¢ Single endpoint<br/>â€¢ Strong typing<br/>â€¢ Real-time subscriptions | â€¢ Complex caching<br/>â€¢ Learning curve<br/>â€¢ Heavier client bundle<br/>â€¢ Potential N+1 queries | â€¢ Complex, nested data<br/>â€¢ Mobile apps (reduce requests)<br/>â€¢ Rapidly changing requirements |
| **tRPC** | â€¢ End-to-end type safety<br/>â€¢ No code generation<br/>â€¢ Simple setup | â€¢ Backend lock-in (TypeScript/Node)<br/>â€¢ Smaller ecosystem<br/>â€¢ Not suitable for public APIs | â€¢ Full-stack TypeScript apps<br/>â€¢ Internal tools<br/>â€¢ Monorepos |
| **gRPC** | â€¢ Extremely fast (binary)<br/>â€¢ Built-in streaming<br/>â€¢ Strong contracts | â€¢ Browser support requires proxy<br/>â€¢ Debugging harder<br/>â€¢ Overkill for simple apps | â€¢ Microservices<br/>â€¢ High-performance needs<br/>â€¢ Server-to-server |

**Interview Insight**: REST's advantage is HTTP caching infrastructure. GraphQL trades that for precision but requires custom caching solutions.

### Caching Strategies

| Layer | Strategy | Pros | Cons |
|-------|----------|------|------|
| **Browser Cache** | HTTP headers (Cache-Control, ETag) | â€¢ Free<br/>â€¢ Automatic<br/>â€¢ Reduces server load | â€¢ Hard to invalidate<br/>â€¢ User-specific data risks<br/>â€¢ Storage limits |
| **CDN Cache** | Edge caching (Cloudflare, Fastly) | â€¢ Massive scale<br/>â€¢ Geographic distribution<br/>â€¢ DDoS protection | â€¢ Stale data<br/>â€¢ Purge delays<br/>â€¢ Cost at scale |
| **In-Memory Cache** | React Query, SWR, Redux cache | â€¢ Instant access<br/>â€¢ Full control | â€¢ Memory leaks if not managed<br/>â€¢ Lost on refresh |
| **Service Worker** | Progressive Web App cache | â€¢ Offline support<br/>â€¢ Full control<br/>â€¢ Background sync | â€¢ Complexity<br/>â€¢ Debugging harder<br/>â€¢ Version management |
| **IndexedDB** | Client-side database | â€¢ Large storage<br/>â€¢ Structured queries | â€¢ Async API complexity<br/>â€¢ Browser differences |

**Cache Invalidation Strategies:**
- Time-based (TTL)
- Event-based (on mutation)
- Stale-while-revalidate
- Cache-aside pattern

### Real-time Data

| Technology | Pros | Cons | Use When |
|------------|------|------|----------|
| **WebSocket** | â€¢ True bidirectional<br/>â€¢ Low latency<br/>â€¢ Persistent connection | â€¢ More complex infrastructure<br/>â€¢ Scaling challenges<br/>â€¢ Connection management | â€¢ Chat apps<br/>â€¢ Live dashboards<br/>â€¢ Multiplayer games |
| **Server-Sent Events (SSE)** | â€¢ Simpler than WebSocket<br/>â€¢ Auto-reconnect<br/>â€¢ HTTP/2 friendly | â€¢ One-way only<br/>â€¢ Limited browser support | â€¢ Live feeds<br/>â€¢ Notifications<br/>â€¢ Stock tickers |
| **Long Polling** | â€¢ Works everywhere<br/>â€¢ Simple | â€¢ Inefficient<br/>â€¢ Higher latency | â€¢ Legacy browser support<br/>â€¢ Fallback option |
| **GraphQL Subscriptions** | â€¢ Integrated with queries<br/>â€¢ Type-safe | â€¢ Requires GraphQL<br/>â€¢ WebSocket dependency | â€¢ GraphQL apps needing real-time |

---

## Performance Optimization

### Bundle Optimization

| Technique | Impact | Trade-off | Implementation |
|-----------|--------|-----------|----------------|
| **Code Splitting** | Reduce initial bundle by 40-70% | More network requests, complexity | Dynamic imports, route-based splitting |
| **Tree Shaking** | Remove unused code (10-30% reduction) | Requires ES modules, build tool config | ESM exports, sideEffects: false |
| **Minification** | 30-50% size reduction | Build time increase | Terser, esbuild |
| **Compression** (Gzip/Brotli) | 60-80% size reduction | Server CPU usage | Nginx/CDN configuration |
| **Dynamic Imports** | Load code on demand | Waterfalls if not careful | React.lazy(), Next.js dynamic() |
| **Bundle Analysis** | Identify large dependencies | Time investment | webpack-bundle-analyzer |

**Bundle Budget Recommendations:**
- Initial JS: < 200KB (gzipped)
- Total page weight: < 1MB
- Time to Interactive: < 3.5s (3G)

### Runtime Performance

| Optimization | Benefit | Cost | When to Apply |
|--------------|---------|------|---------------|
| **Memoization** (useMemo, memo) | Prevent expensive recalculations | Memory overhead, mental complexity | Expensive computations only |
| **useCallback** | Prevent prop changes | Negligible | Passing callbacks to memoized components |
| **Virtualization** (react-window) | Render only visible items | Implementation complexity | Lists with 100+ items |
| **Debouncing/Throttling** | Reduce function calls | Delayed response | Search inputs, scroll handlers |
| **Web Workers** | Offload heavy computation | Communication overhead | Image processing, data parsing |
| **Concurrent Features** (React 18) | Non-blocking rendering | Requires React 18+ | Complex UIs with heavy updates |

**Performance Anti-patterns:**
- Premature optimization (optimize what matters)
- Over-memoization (everything wrapped in useMemo)
- Inline object/array creation in render
- Anonymous functions in JSX (when causing issues)

### Network Performance

| Strategy | Impact | Implementation |
|----------|--------|----------------|
| **Resource Hints** (prefetch, preload, dns-prefetch) | Reduce perceived latency | `<link rel="prefetch">` |
| **HTTP/2 & HTTP/3** | Multiplexing, reduced latency | Server/CDN configuration |
| **Image Optimization** (WebP, AVIF, lazy loading) | 50-80% size reduction | Picture element, loading="lazy" |
| **Request Batching** | Reduce waterfall | GraphQL, custom batch endpoint |
| **Service Worker Caching** | Offline support, instant loads | SW registration, cache strategies |

### Rendering Performance

**Critical Rendering Path Optimization:**

| Metric | Target | Strategy |
|--------|--------|----------|
| **FCP** (First Contentful Paint) | < 1.8s | Inline critical CSS, reduce blocking resources |
| **LCP** (Largest Contentful Paint) | < 2.5s | Optimize images, preload key resources |
| **TTI** (Time to Interactive) | < 3.8s | Code splitting, reduce JavaScript |
| **CLS** (Cumulative Layout Shift) | < 0.1 | Reserve space, avoid dynamic content |
| **FID** (First Input Delay) | < 100ms | Reduce long tasks, use web workers |
| **INP** (Interaction to Next Paint) | < 200ms | Optimize event handlers, debounce |

---

## Component Architecture

### Component Patterns

| Pattern | Description | Pros | Cons | Use Case |
|---------|-------------|------|------|----------|
| **Presentational Components** | Pure UI, no business logic | Reusable, testable | More files | UI libraries, design systems |
| **Container Components** | Handle data/logic, pass to presentational | Separation of concerns | Boilerplate | Feature components |
| **Compound Components** | Multiple components work together | Flexible API, control inversion | More complex | Tabs, Accordion, Select |
| **Render Props** | Share code via function prop | Flexible, composable | Callback hell risk | Auth, data fetching |
| **Higher-Order Components** | Enhance components with shared logic | Reusable logic | Props collision, wrapper hell | Legacy code, cross-cutting |
| **Hooks** | Share stateful logic | Composable, clean | Rules of Hooks | Modern React standard |
| **Controlled vs Uncontrolled** | Parent controls state vs local state | Controlled: full control; Uncontrolled: simpler | Controlled: more code | Forms (controlled), simple inputs (uncontrolled) |

### Composition vs Inheritance

**Composition (React's recommendation):**
```javascript
// Good: Composition
<Layout>
  <Sidebar />
  <Content />
</Layout>
```

**Why composition over inheritance:**
- More flexible
- Easier to understand
- Avoids tight coupling
- Better tree shaking

### Code Reusability

| Level | Strategy | When to Extract |
|-------|----------|-----------------|
| **Functions** | Utility functions | Used 3+ times |
| **Hooks** | Custom hooks | Shared stateful logic |
| **Components** | Reusable UI | Used 2+ times, stable API |
| **Libraries** | Published packages | Used across projects |

**YAGNI Principle**: Don't extract until you need it in multiple places.

---

## Styling Approaches

### CSS Methodologies

| Approach | Pros | Cons | Bundle Impact | Best For |
|----------|------|------|---------------|----------|
| **Plain CSS** | â€¢ Fast<br/>â€¢ Simple<br/>â€¢ No build step | â€¢ Global scope<br/>â€¢ Naming conflicts<br/>â€¢ Hard to delete | Smallest | Small projects |
| **CSS Modules** | â€¢ Scoped by default<br/>â€¢ Type-safe (with TS)<br/>â€¢ No runtime | â€¢ Tooling required<br/>â€¢ Dynamic styles harder | Small | Component libraries |
| **Styled-components / Emotion** | â€¢ Dynamic styling<br/>â€¢ Theming<br/>â€¢ Co-location | â€¢ Runtime cost<br/>â€¢ Larger bundle<br/>â€¢ SSR complexity | Medium-Large | Apps with complex theming |
| **Tailwind CSS** | â€¢ Fast development<br/>â€¢ Consistent design<br/>â€¢ Purge removes unused | â€¢ Large class names<br/>â€¢ HTML clutter<br/>â€¢ Learning curve | Small (with purge) | Rapid prototyping, design systems |
| **CSS-in-JS (Zero-runtime)** (Vanilla Extract, Linaria) | â€¢ Type-safe<br/>â€¢ No runtime cost<br/>â€¢ Scoped | â€¢ More setup<br/>â€¢ Less flexible | Small | Performance-critical apps |
| **Sass/Less** | â€¢ Variables, mixins<br/>â€¢ Mature ecosystem | â€¢ Extra build step<br/>â€¢ Can encourage complexity | Small | Traditional projects |

### Runtime vs Build-time

**Runtime CSS-in-JS** (Styled-components, Emotion):
- **Pros**: Maximum flexibility, dynamic theming
- **Cons**: ~10-30KB runtime cost, serialization overhead
- **Use when**: Heavy theming, runtime style changes

**Build-time CSS** (Tailwind, CSS Modules, Vanilla Extract):
- **Pros**: Zero runtime, smaller bundles
- **Cons**: Less dynamic, more build config
- **Use when**: Performance is critical

### Theming Systems

| Approach | Flexibility | Performance |
|----------|-------------|-------------|
| CSS Variables | High | Best |
| Context + CSS-in-JS | Very High | Moderate |
| Class swapping | Low | Best |
| Theme prop injection | High | Poor (re-renders) |

---

## Routing Architecture

### Client vs Server Routing

| Type | Pros | Cons | Best For |
|------|------|------|----------|
| **Client Routing** (React Router, Tanstack Router) | â€¢ Instant transitions<br/>â€¢ Preserved state<br/>â€¢ Smooth animations<br/>â€¢ No full page reload | â€¢ Initial SEO challenges<br/>â€¢ Deep linking requires setup<br/>â€¢ Larger initial bundle | â€¢ SPAs<br/>â€¢ Apps behind auth<br/>â€¢ Interactive dashboards |
| **Server Routing** (Traditional MPAs) | â€¢ SEO friendly<br/>â€¢ Simple mental model<br/>â€¢ Progressive enhancement<br/>â€¢ Smaller JS bundles | â€¢ Slower navigation<br/>â€¢ Lost state on navigation<br/>â€¢ No smooth transitions | â€¢ Content sites<br/>â€¢ Marketing pages<br/>â€¢ E-commerce |
| **Hybrid** (Next.js App Router, Remix) | â€¢ Best of both worlds<br/>â€¢ Fast navigation + SEO<br/>â€¢ Streaming | â€¢ Framework-specific<br/>â€¢ More complexity | â€¢ Modern web apps (default choice) |

### Route-based Code Splitting

**Automatic in Next.js/Remix, manual in React Router:**

```javascript
// Lazy load routes
const Dashboard = lazy(() => import('./Dashboard'));
```

**Benefits:**
- Smaller initial bundles
- Faster first load
- Load code as needed

**Trade-offs:**
- Route transition delay (can be mitigated with prefetch)
- More complex error handling

### Deep Linking

**Challenges:**
- Preserving app state in URLs
- Handling authentication redirects
- Shareable links

**Solutions:**
- Query parameters for filters
- Route parameters for resources
- Hash fragments for scroll position

---

## Micro-Frontend Architecture

### Integration Approaches

| Approach | Pros | Cons | Use When |
|----------|------|------|----------|
| **Build-time** (NPM packages) | â€¢ Simple<br/>â€¢ Type-safe<br/>â€¢ Optimized | â€¢ Coordinated releases<br/>â€¢ No independent deploy | Shared component library |
| **Runtime** (Module Federation) | â€¢ Independent deploy<br/>â€¢ Version flexibility | â€¢ Runtime overhead<br/>â€¢ Complex debugging | Large orgs, independent teams |
| **iFrame** | â€¢ Complete isolation<br/>â€¢ Tech-agnostic | â€¢ Communication overhead<br/>â€¢ UX challenges (navigation, styling) | Legacy integration |
| **Web Components** | â€¢ Standards-based<br/>â€¢ Framework-agnostic | â€¢ Browser support<br/>â€¢ Limited state sharing | Shared widgets |

### Communication Patterns

| Pattern | Use Case | Trade-off |
|---------|----------|-----------|
| **Props** | Parent to child | Simple but requires direct relationship |
| **Custom Events** | Cross-micro-frontend | Loose coupling but harder to debug |
| **Shared State** (Redux, Zustand) | Global coordination | Tight coupling |
| **URL State** | Deep linking, filters | Limited data types |

### Shared Dependencies

**Problem**: Each micro-frontend bundles React, lodash, etc., leading to duplication.

**Solutions:**
1. **Module Federation** (share at runtime)
2. **External dependencies** (load from CDN)
3. **Monorepo** (coordinate versions)

**Trade-off**: Sharing dependencies saves bandwidth but couples deployment.

---

## Security Considerations

### Authentication Patterns

| Pattern | Pros | Cons | Use When |
|---------|------|------|----------|
| **JWT in localStorage** | â€¢ Simple<br/>â€¢ Accessible from JS | â€¢ Vulnerable to XSS<br/>â€¢ No automatic expiry | Simple apps with low risk |
| **JWT in HttpOnly cookie** | â€¢ Immune to XSS<br/>â€¢ Automatic send | â€¢ Requires CSRF protection<br/>â€¢ Complex CORS | Production apps (recommended) |
| **Session cookie** | â€¢ Server-side control<br/>â€¢ Easy revocation | â€¢ Server state<br/>â€¢ Scaling challenges | Traditional server-rendered apps |
| **OAuth/OpenID Connect** | â€¢ Delegated auth<br/>â€¢ Standard protocol | â€¢ Complex setup<br/>â€¢ Third-party dependency | SSO, social login |

### Data Validation

| Layer | Purpose | Tools |
|-------|---------|-------|
| **Client-side** | UX feedback | Zod, Yup, HTML5 validation |
| **Server-side** | Security (ALWAYS required) | Zod, Joi, class-validator |
| **Type-level** | Development safety | TypeScript, JSDoc |

**Golden Rule**: Client validation for UX, server validation for security. Never trust client input.

### XSS and CSRF Protection

**XSS (Cross-Site Scripting):**
- Sanitize user input (DOMPurify)
- Use React (auto-escapes by default)
- Content Security Policy headers
- Avoid `dangerouslySetInnerHTML`

**CSRF (Cross-Site Request Forgery):**
- CSRF tokens
- SameSite cookies
- Double submit cookies
- Origin header validation

---

## Accessibility

### WCAG Compliance

| Level | Requirements | Use Case |
|-------|--------------|----------|
| **A** | Basic accessibility | Minimum legal requirement |
| **AA** | Reasonable accommodations | Standard target (most laws) |
| **AAA** | Highest accessibility | Specialized applications |

**Key Principles (POUR):**
- **Perceivable**: Alt text, captions, contrast
- **Operable**: Keyboard navigation, focus management
- **Understandable**: Clear language, consistent navigation
- **Robust**: Semantic HTML, ARIA when needed

### Performance vs Accessibility

**Common Tension:**
- Heavy focus trapping (performance) vs. simple navigation (a11y)
- Custom controls (design) vs. native controls (a11y)

**Solution**: Accessible patterns often improve performance:
- Semantic HTML is lighter than div soup
- Keyboard navigation reduces JS events
- Screen reader support improves SEO

### Testing Strategies

| Tool | What it Catches | Limitations |
|------|-----------------|-------------|
| **axe-core / Lighthouse** | 30-40% of issues | Automated only |
| **Keyboard testing** | Focus management, operability | Manual |
| **Screen reader testing** (NVDA, JAWS, VoiceOver) | Real user experience | Time-consuming |
| **jest-axe** | Unit-level a11y | Limited context |

---

## Observability

### Logging Strategies

| Type | Use Case | Cost | Retention |
|------|----------|------|-----------|
| **Console logs** | Development | Free | None |
| **Application logs** (Winston, Pino) | Errors, events | Low | 7-30 days |
| **Structured logs** (JSON) | Queryable logs | Low | 30-90 days |
| **APM logs** (Datadog, New Relic) | Production monitoring | High | 90+ days |

**Best Practices:**
- Log levels (error, warn, info, debug)
- Correlation IDs for request tracing
- Avoid logging PII
- Sample high-volume logs

### Error Tracking

| Service | Pros | Cons |
|---------|------|------|
| **Sentry** | â€¢ Great DX<br/>â€¢ Source maps<br/>â€¢ Breadcrumbs | â€¢ Can be expensive at scale |
| **Rollbar** | â€¢ Good alerting<br/>â€¢ Telemetry | â€¢ Less intuitive UI |
| **BugSnag** | â€¢ Mobile-friendly<br/>â€¢ Session tracking | â€¢ Smaller ecosystem |
| **LogRocket / FullStory** | â€¢ Session replay<br/>â€¢ User context | â€¢ Privacy concerns<br/>â€¢ Expensive |

**Error Boundaries** (React):
- Prevent entire app crashes
- Graceful degradation
- User-friendly error messages

### Performance Monitoring

**Real User Monitoring (RUM):**
- Actual user experience
- Geographic insights
- Device/browser breakdown

**Synthetic Monitoring:**
- Controlled tests
- Consistent benchmarks
- Early warning system

**Key Metrics to Track:**
- Core Web Vitals (LCP, FID/INP, CLS)
- Custom business metrics (time to checkout, etc.)
- Error rates
- API latency

---

## Testing Strategy

### Testing Pyramid

```
        /\
       /E2E\      Few (10%)
      /------\
     /  INT   \   Some (30%)
    /----------\
   /   UNIT     \ Many (60%)
  /--------------\
```

| Level | Quantity | Speed | Confidence | Cost to Maintain |
|-------|----------|-------|------------|------------------|
| **Unit** | Many | Fast (ms) | Low | Low |
| **Integration** | Some | Medium (seconds) | Medium | Medium |
| **E2E** | Few | Slow (minutes) | High | High |

### Testing Types

| Type | Tools | What to Test | What to Avoid |
|------|-------|--------------|---------------|
| **Unit Tests** | Jest, Vitest | â€¢ Pure functions<br/>â€¢ Utilities<br/>â€¢ Hooks logic | â€¢ Implementation details<br/>â€¢ UI styling |
| **Integration Tests** | React Testing Library | â€¢ User interactions<br/>â€¢ Component integration<br/>â€¢ Data flow | â€¢ Mocking everything |
| **E2E Tests** | Playwright, Cypress | â€¢ Critical user paths<br/>â€¢ Multi-page flows<br/>â€¢ Real backend | â€¢ Testing every feature |
| **Visual Regression** | Chromatic, Percy | â€¢ UI consistency<br/>â€¢ Responsive design | â€¢ Dynamic content |
| **Performance Tests** | Lighthouse CI, WebPageTest | â€¢ Load times<br/>â€¢ Bundle sizes<br/>â€¢ Core Web Vitals | â€¢ Micro-optimizations |

### Test Coverage vs Speed

**Trade-off:**
- High coverage (90%+) = slow CI, maintenance burden
- Low coverage (30-50%) = faster, but less confidence

**Balanced Approach:**
- 70-80% unit test coverage
- Test critical paths with integration/E2E
- Avoid testing third-party libraries
- Test behavior, not implementation

**Anti-patterns:**
- Testing implementation details (how) vs behavior (what)
- 100% coverage dogma
- Brittle selectors (test-ids preferred)

---

## Deployment Strategies

### Feature Flags

| Benefit | Implementation | Trade-off |
|---------|----------------|-----------|
| **Progressive rollout** | 1% â†’ 10% â†’ 50% â†’ 100% | Technical debt if not cleaned |
| **A/B testing** | Random user assignment | Complex analytics |
| **Kill switch** | Instant feature disable | Code complexity |
| **Beta features** | Opt-in for specific users | User segmentation logic |

**Popular Tools:**
- LaunchDarkly (enterprise)
- Flagsmith (open source)
- Unleash (self-hosted)
- Custom Redis-based solution

**Best Practices:**
- Clean up flags after full rollout
- Use typed flags (TypeScript)
- Default to safe fallback
- Monitor flag performance impact

### Progressive Rollouts

| Strategy | Description | Risk Level | Use Case |
|----------|-------------|------------|----------|
| **Canary Release** | Deploy to small % of servers first | Low | Backend changes, API updates |
| **Blue-Green Deployment** | Full environment switch | Medium | Major releases, database migrations |
| **Rolling Deployment** | Gradual server-by-server update | Low | Standard deploys |
| **Shadow Mode** | Run new version alongside old (no user impact) | Very Low | Testing in production |

**Monitoring During Rollouts:**
- Error rate spikes
- Performance degradation
- User complaints/support tickets
- Business metrics (conversion, engagement)

### Rollback Mechanisms

| Mechanism | Speed | Complexity | Data Concerns |
|-----------|-------|------------|---------------|
| **Feature flag toggle** | Instant | Low | None (code still deployed) |
| **Git revert + redeploy** | 5-15 min | Low | None (if stateless) |
| **Blue-green switch** | Instant | High | Database schema compatibility |
| **Database rollback** | Slow | Very High | Data loss risk |

**Golden Rule**: Design for forward compatibility. Never break old clients.

---

## Mobile Considerations

### Responsive vs Adaptive

| Approach | How It Works | Pros | Cons | Use Case |
|----------|--------------|------|------|----------|
| **Responsive Design** | Fluid grids, flexible images, CSS media queries | â€¢ One codebase<br/>â€¢ Future-proof<br/>â€¢ Easier maintenance | â€¢ Can be slow on mobile<br/>â€¢ Compromise on experience<br/>â€¢ Downloads unused assets | Most websites, content-heavy apps |
| **Adaptive Design** | Detect device, serve different layouts/bundles | â€¢ Optimized per device<br/>â€¢ Faster on mobile<br/>â€¢ Device-specific features | â€¢ Multiple codebases<br/>â€¢ More maintenance<br/>â€¢ Detection complexity | Apps with very different mobile UX |
| **Hybrid** (Responsive + Adaptive) | Responsive base + adaptive enhancements | â€¢ Best of both<br/>â€¢ Progressive enhancement | â€¢ Most complex | Large-scale applications |

**Decision Framework:**
```
Same UX across devices?
â”œâ”€ Yes â†’ Responsive
â””â”€ No â†’ Consider Adaptive
    â””â”€ Budget for maintenance?
        â”œâ”€ Yes â†’ Adaptive
        â””â”€ No â†’ Responsive with mobile-first
```

### Mobile-first vs Desktop-first

| Approach | Philosophy | Pros | Cons |
|----------|------------|------|------|
| **Mobile-first** | Design for mobile, enhance for desktop | â€¢ Forces prioritization<br/>â€¢ Better mobile performance<br/>â€¢ Progressive enhancement<br/>â€¢ Smaller base bundle | â€¢ Desktop might feel basic<br/>â€¢ More CSS media queries |
| **Desktop-first** | Design for desktop, simplify for mobile | â€¢ Richer desktop experience<br/>â€¢ Familiar workflow | â€¢ Mobile as afterthought<br/>â€¢ Performance issues<br/>â€¢ Harder to simplify than enhance |

**Modern Best Practice**: Mobile-first (60-70% of traffic is mobile for most consumer apps)

**Mobile-specific Optimizations:**

| Optimization | Impact | Implementation |
|--------------|--------|----------------|
| **Touch-friendly targets** | Better UX | Min 44x44px tap targets |
| **Reduced animations** | Battery, performance | `prefers-reduced-motion` media query |
| **Image compression** | Bandwidth savings | WebP/AVIF, responsive images |
| **Offline support** | PWA capability | Service Workers |
| **Reduce font sizes** | Performance | Font subsetting, system fonts |
| **Lazy load below fold** | Initial load time | Intersection Observer |

### Progressive Web Apps

**PWA Capabilities:**

| Feature | Benefit | Browser Support | Implementation Effort |
|---------|---------|-----------------|----------------------|
| **Add to Home Screen** | App-like icon | Excellent | Low (manifest.json) |
| **Offline Support** | Works without internet | Good | Medium (Service Worker) |
| **Push Notifications** | Re-engagement | Good (not iOS Safari) | Medium (Push API) |
| **Background Sync** | Reliable data sync | Limited | High |
| **Install Prompts** | Increase installs | Variable | Low |

**PWA vs Native App Trade-offs:**

| Aspect | PWA | Native App | Winner |
|--------|-----|------------|--------|
| **Development cost** | Lower (one codebase) | Higher (iOS + Android) | PWA |
| **Distribution** | No app store | App stores | PWA (easier) |
| **Device access** | Limited | Full | Native |
| **Performance** | Good | Excellent | Native |
| **Updates** | Instant | Store review delay | PWA |
| **Discoverability** | SEO | App store optimization | Depends |
| **Offline capability** | Good | Excellent | Native |

**When to Choose PWA:**
- Content-focused apps
- Limited budget
- Need SEO
- Frequent updates
- Cross-platform priority

**When to Choose Native:**
- Heavy device integration (camera, sensors, etc.)
- Performance-critical (games, AR/VR)
- Native UX is important
- App store presence needed

**Hybrid Approach** (PWA + Native shell):
- LinkedIn, Twitter use this
- PWA for web, native wrapper for app stores
- Shared web codebase

---

## Interview Framework

### How to Approach Questions

**Step-by-step Framework:**

#### 1. Clarify Requirements (5 min)
Ask questions to understand:
- **Scale**: How many users? Geographic distribution?
- **Features**: Core vs nice-to-have?
- **Constraints**: Timeline? Team size? Budget?
- **Users**: Technical level? Devices? Network conditions?
- **Performance**: What matters most? (SEO, TTI, offline, etc.)

**Example Questions:**
- "How many concurrent users do we expect?"
- "Is this a public-facing site or internal tool?"
- "What's more important: initial load time or runtime performance?"
- "Do we need to support offline functionality?"
- "What browsers/devices must we support?"

#### 2. Define High-level Architecture (10 min)

**Structure your answer:**
```
1. Rendering strategy (CSR/SSR/SSG)
2. State management approach
3. Data fetching pattern
4. Key infrastructure (CDN, caching)
5. Major trade-offs
```

**Visual representation helps:**
```
[User] â†’ [CDN] â†’ [Next.js SSR] â†’ [API Gateway] â†’ [Services]
                      â†“
                 [React Query Cache]
                      â†“
                 [Component Tree]
```

#### 3. Dive into Components (15 min)

Pick 2-3 interesting areas to detail:
- Performance bottlenecks
- Complex state management
- Real-time features
- Security concerns

**Show trade-off thinking:**
"I would start with X because [reason], but if we see Y problem, we could switch to Z."

#### 4. Discuss Trade-offs (5 min)

For every decision, mention:
- **Why this choice?** (requirements it satisfies)
- **What's the downside?** (what we're sacrificing)
- **When would we change?** (what would make us revisit)

#### 5. Scaling & Evolution (5 min)

Discuss how the system evolves:
- "At 10K users: Simple SSR works fine"
- "At 100K users: Add CDN caching, API rate limiting"
- "At 1M users: Consider ISR, edge functions, micro-frontends"

### Common Pitfalls

| Pitfall | Why It's Bad | Fix |
|---------|--------------|-----|
| **Jumping to solutions** | Miss requirements, wrong architecture | Always clarify first |
| **Over-engineering** | Adds complexity unnecessarily | Start simple, justify complexity |
| **Ignoring trade-offs** | Shows lack of depth | Every decision has pros AND cons |
| **Buzzword dropping** | Sounds hollow without context | Explain WHY you'd use a technology |
| **Not asking questions** | Seems overconfident or inexperienced | Show curiosity, clarify ambiguity |
| **Ignoring non-functional requirements** | Incomplete design | Consider security, a11y, i18n, monitoring |
| **One-size-fits-all** | Different problems need different solutions | Adapt to requirements |
| **Forgetting about users** | Too technical, not user-centric | Consider UX, accessibility, performance |

### Sample Answers

#### Example 1: Design Instagram Feed

**Clarification Questions:**
- How many users? Daily active users?
- Real-time updates required?
- Image upload/processing requirements?
- Offline support needed?

**High-level Design:**

```
Architecture:
â”œâ”€ Rendering: SSR for initial feed (SEO, fast FCP)
â”œâ”€ Client: React SPA after hydration
â”œâ”€ State:
â”‚  â”œâ”€ React Query for feed data
â”‚  â””â”€ Zustand for UI state (modals, selections)
â”œâ”€ Real-time: WebSocket for new posts notification
â””â”€ Media: CDN with progressive image loading
```

**Key Decisions:**

1. **Rendering: SSR â†’ CSR hybrid**
   - *Why*: Fast initial load + SEO, then rich client interactivity
   - *Trade-off*: More complex than pure CSR
   - *When to change*: If SEO isn't important, go CSR-only

2. **Infinite Scroll with Virtualization**
   - *Why*: Smooth UX for long feeds
   - *Implementation*: react-window + Intersection Observer
   - *Trade-off*: Complexity vs. memory efficiency

3. **Optimistic Updates**
   - *Why*: Instant feedback on likes/comments
   - *Trade-off*: Need rollback logic if server fails
   - *Implementation*: React Query mutations

4. **Image Strategy**
   - *Why*: Images dominate bandwidth
   - *Approach*:
     - Lazy load below fold
     - WebP with JPEG fallback
     - Responsive images (srcset)
     - Blur placeholder (LQIP)

5. **Caching Strategy**
   - CDN: Cache images (long TTL)
   - React Query: Cache feed data (5 min stale time)
   - Service Worker: Offline image viewing

**Scaling Considerations:**
- **10K users**: Single server SSR works
- **1M users**:
  - Edge SSR (Vercel, Cloudflare)
  - Separate API gateway
  - Image processing service
- **10M users**:
  - Feed sharding by user
  - Read replicas
  - Micro-frontends for features

#### Example 2: Design a Collaborative Document Editor (Google Docs-like)

**Clarification:**
- Real-time collaboration required? (Yes)
- Simultaneous editors expected? (Up to 50)
- Mobile support? (Yes)
- Offline editing? (Nice to have)

**High-level Design:**

```
Architecture:
â”œâ”€ Rendering: CSR (no SEO need, auth-gated)
â”œâ”€ Real-time: WebSocket with CRDT for conflict resolution
â”œâ”€ State:
â”‚  â”œâ”€ Local: Prosemirror/Quill editor state
â”‚  â””â”€ Sync: Yjs for distributed state
â”œâ”€ Persistence:
â”‚  â”œâ”€ Auto-save every 2s (debounced)
â”‚  â””â”€ Manual save option
â””â”€ Offline: IndexedDB + sync on reconnect
```

**Key Decisions:**

1. **CSR Only**
   - *Why*: Auth-gated, no SEO needed, heavy interactivity
   - *Trade-off*: Slower initial load OK for tool
   - *Alternative*: Could SSR shell for faster perceived load

2. **CRDT for Conflict Resolution**
   - *Why*: Automatic merge of concurrent edits
   - *Options*: Yjs (recommended), Automerge, operational transforms
   - *Trade-off*: Complexity vs. robust collaboration
   - *Alternative*: Last-write-wins (simpler but loses data)

3. **WebSocket over Polling**
   - *Why*: Low latency, bidirectional
   - *Trade-off*: Infrastructure complexity, connection management
   - *Fallback*: Long polling for old browsers

4. **Editor Choice: Prosemirror**
   - *Why*: Flexible, powerful, collaborative-ready
   - *Trade-off*: Steeper learning curve vs. Draft.js/Quill
   - *Alternative*: Quill (simpler, less flexible)

5. **Optimistic Updates + Rollback**
   - *Why*: Instant typing feedback
   - *Implementation*:
     - Apply change locally immediately
     - Send to server
     - Rollback if conflict/error

6. **Cursor Positioning**
   - Show other users' cursors with names/colors
   - Implementation: Relative positioning in CRDT
   - Challenge: Performance with 50 users (throttle updates)

**Performance Considerations:**
- **Document Size**:
  - Paginate very long docs (100+ pages)
  - Lazy load images/embeds
  - Virtual scrolling for large docs

- **Collaboration Scale**:
  - Up to 10 users: Direct WebSocket
  - 10-50 users: Throttle cursor updates (200ms)
  - 50+ users: Consider room-based splitting

- **Memory Management**:
  - Cleanup old history (keep 100 operations)
  - Garbage collect CRDT tombstones
  - Unload off-screen content

**Offline Strategy:**
- IndexedDB stores document + pending changes
- Service Worker caches app shell
- Sync queue when reconnecting
- Conflict resolution UI if diverged

#### Example 3: Design an E-commerce Product Listing Page

**Requirements:**
- 10K products, need filters/search
- SEO critical
- Fast perceived performance
- Mobile-first

**High-level Design:**

```
Architecture:
â”œâ”€ Rendering: ISR (Next.js)
â”‚  â”œâ”€ Static generation for popular products
â”‚  â””â”€ On-demand for long tail
â”œâ”€ Search: Algolia/Elasticsearch
â”œâ”€ Filters: URL state + React Query
â””â”€ Images: CDN + progressive loading
```

**Key Decisions:**

1. **ISR over SSR/SSG**
   - *Why*:
     - SEO (need server rendering)
     - Fresh inventory (revalidate every 5 min)
     - Scale (10K builds too slow for pure SSG)
   - *Trade-off*: Next.js lock-in
   - *Alternative*: SSR + aggressive CDN caching

2. **Search: Algolia (managed) vs Elasticsearch (self-hosted)**
   - *Algolia Pros*:
     - Fast setup
     - Great DX
     - Built-in typo tolerance
   - *Algolia Cons*:
     - Expensive at scale
     - Vendor lock-in
   - *When to switch*: Over 1M searches/month â†’ consider Elasticsearch

3. **Filter State in URL**
   - *Why*: Shareable links, back button works
   - *Implementation*: URLSearchParams + React Router
   - *Trade-off*: URL can get ugly with many filters

4. **Virtualization for Long Lists**
   - *Why*: 1000+ products per page possible
   - *Implementation*: react-window
   - *Alternative*: Pagination (simpler, SEO-friendly)
   - *Decision*: Use pagination with "Load More" for SEO

5. **Image Strategy**
   - Blur placeholder (LQIP)
   - Lazy load (Intersection Observer)
   - Responsive images
   - WebP with JPEG fallback
   - CDN with automatic optimization (Cloudinary)

**Performance Budget:**
- LCP < 2.5s (hero image)
- FID < 100ms
- CLS < 0.1 (reserve image space)

**Caching Strategy:**
- ISR: Revalidate every 5 min
- CDN: Cache static assets 1 year
- Browser: Cache product images 1 week
- API: React Query cache 5 min, stale-while-revalidate

**Mobile Optimizations:**
- Sticky filters button (mobile)
- Bottom sheet for filters (not sidebar)
- Touch-friendly product cards (min 44px)
- Reduce image quality on slow connections

---

## Key Takeaways

### Universal Principles

1. **No Silver Bullets**: Every decision trades one benefit for another.

2. **Start Simple**: Complexity should be justified by requirements, not resume building.

3. **Measure First**: Don't optimize what you can't measure.

4. **User-Centric**: Performance metrics exist to serve user experience.

5. **Evolutionary Architecture**: Design for change, not perfection.

### Interview Success Formula

```
Great Answer = Clear Communication
             + Trade-off Awareness
             + Justification
             + Adaptability
```

**Remember:**
- Interviewers want to see your **thinking process**, not just the answer
- There's rarely one "correct" solution
- Asking clarifying questions shows experience
- Acknowledging limitations shows maturity
- Discussing when you'd change approaches shows depth

### Red Flags to Avoid

âŒ "We should use microservices/GraphQL/etc." (without justification)
âŒ "This is the best way to do it" (no trade-off awareness)
âŒ Over-engineering for small scale
âŒ Ignoring non-functional requirements (security, a11y)
âŒ Not considering costs (infrastructure, maintenance, developer time)

### Green Flags to Show

âœ… Ask clarifying questions first
âœ… Start with simple solution, then iterate
âœ… Mention trade-offs for every decision
âœ… Consider different scales (10K vs 1M vs 10M users)
âœ… Think about maintenance and team velocity
âœ… Consider total cost of ownership
âœ… Show awareness of modern best practices
âœ… Be honest about what you don't know

---

## Quick Reference Cards

### When to Use What

**Rendering:**
- **CSR**: Dashboards, auth-gated tools
- **SSR**: E-commerce, social media, content
- **SSG**: Blogs, docs, marketing
- **ISR**: Product catalogs, news sites

**State Management:**
- **Local**: UI toggles, forms
- **Context**: Theme, i18n, auth status
- **React Query/SWR**: Server data
- **Redux/Zustand**: Complex business logic

**Data Fetching:**
- **REST**: Default choice, simple CRUD
- **GraphQL**: Complex nested data, mobile apps
- **tRPC**: Full-stack TypeScript monorepos

**Styling:**
- **Tailwind**: Fast development, consistency
- **CSS Modules**: Component libraries
- **CSS-in-JS**: Heavy theming needs
- **Plain CSS**: Simple sites, performance-critical

### Performance Quick Wins

1. **Images**: WebP, lazy load, responsive srcset
2. **Fonts**: System fonts or subset web fonts
3. **Code Splitting**: Route-based, dynamic imports
4. **Compression**: Enable Gzip/Brotli
5. **Caching**: HTTP headers, CDN, React Query
6. **Bundle**: Tree shaking, minification
7. **Critical CSS**: Inline above-fold styles
8. **Preload**: Critical resources

### Common Interview Questions

1. "Design a news feed (Twitter/Instagram/Facebook)"
2. "Design a real-time collaborative editor (Google Docs)"
3. "Design a video streaming platform (YouTube)"
4. "Design an e-commerce site (Amazon)"
5. "Design a chat application (WhatsApp/Slack)"
6. "Design a file storage system (Dropbox)"
7. "Design a dashboard with real-time data"
8. "Design a booking system (Airbnb)"

**For each, remember to discuss:**
- Rendering strategy
- State management
- Real-time needs (if any)
- Caching strategy
- Performance considerations
- Scaling approach

---

## Additional Resources

### Further Reading

- **Performance**: web.dev, WebPageTest
- **React Patterns**: patterns.dev
- **System Design**: Front-End Engineer (book)
- **Best Practices**: MDN, React docs

### Practice Platforms

- Frontend Mentor (UI challenges)
- GreatFrontEnd (system design questions)
- LeetCode (algorithmic problems)
- Pramp/Interviewing.io (mock interviews)

---

**Final Note**: This guide is a reference, not a script. Use it to develop intuition about trade-offs, then adapt to each unique situation. The best engineers don't memorize solutionsâ€”they understand principles and apply them contextually.

Good luck with your interviews! ðŸš€
