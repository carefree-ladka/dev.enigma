# Browser Hinting Techniques - Complete Guide

## Table of Contents

1. [What are Browser Hinting Techniques?](#what-are-browser-hinting-techniques)
2. [Categories of Browser Hints](#categories-of-browser-hints)
3. [DNS Prefetch](#dns-prefetch)
4. [Preconnect](#preconnect)
5. [Preload](#preload)
6. [Prefetch](#prefetch)
7. [Module Preload](#module-preload)
8. [Fetch Priority](#fetch-priority)
9. [Comparison Table](#comparison-table)
10. [Common Interview Scenarios](#common-interview-scenarios)
11. [DOs and DON'Ts](#dos-and-donts)
12. [Production Example](#production-example)
13. [Performance Impact Analysis](#performance-impact-analysis)
14. [Quick Reference Summary](#quick-reference-summary)

---

## What are Browser Hinting Techniques?

Browser hints are instructions sent by the server or defined in HTML that tell the browser **what to load, when, and how** ‚Äî before the browser discovers these resources naturally through parsing.

### Goal

Browser hinting techniques help:
- **Reduce blocking** - Eliminate render-blocking resources
- **Improve LCP / FCP** - Faster Largest Contentful Paint and First Contentful Paint
- **Optimize critical rendering path** - Prioritize above-the-fold content
- **Reduce latency** - Establish connections before they're needed
- **Improve perceived performance** - Make the page feel faster

### How It Works

```
Without hints:
HTML parse ‚Üí Discover CSS ‚Üí Parse CSS ‚Üí Discover font ‚Üí Download font ‚Üí Render
‚îî‚îÄ 400ms ‚îÄ‚îÄ‚î¥‚îÄ 200ms ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ 100ms ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ 300ms ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ 50ms ‚îÄ‚îÄ‚îò = 1050ms

With hints:
HTML parse (while downloading font in parallel) ‚Üí Render
‚îî‚îÄ 400ms ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ 50ms ‚îÄ‚îÄ‚îò = 450ms
```

---

## Categories of Browser Hints

Browser hints fall into three main categories:

### A. Resource Priority Hints

Control **which resources** to load and **when**:
- `preload` - Load critical resources immediately
- `prefetch` - Load resources for future navigation
- `modulepreload` - Load ES modules and their dependencies

### B. Connection Hints

Establish network connections **before** making requests:
- `dns-prefetch` - Resolve DNS early
- `preconnect` - Complete full connection (DNS + TCP + TLS)

### C. Fetch Priority Hint

Fine-tune **relative importance** of resources:
- `fetchpriority` - Manual priority control (high/low/auto)

---

## DNS Prefetch

DNS prefetch performs early DNS resolution for domains that will be used later in the page lifecycle.

### What It Does

Resolves the domain name to an IP address **before** the resource is actually requested.

**Syntax:**

```html
<link rel="dns-prefetch" href="//cdn.example.com">
<link rel="dns-prefetch" href="//fonts.googleapis.com">
<link rel="dns-prefetch" href="//www.google-analytics.com">
```

### Characteristics

| Aspect | Details |
|--------|---------|
| **Scope** | DNS lookup only |
| **Cost** | Very cheap (minimal overhead) |
| **Connection** | Does NOT open TCP or TLS connection |
| **Use cases** | 3rd-party domains, analytics, fonts, ads |

### When to Use

DNS prefetch is ideal for:
- **Analytics services** - Google Analytics, Mixpanel
- **Font providers** - Google Fonts, Adobe Fonts
- **Ad networks** - Any advertising domain
- **CDN resources** - Static asset domains
- **Social media widgets** - Facebook, Twitter embeds

### Performance Impact

```
Normal request:
DNS lookup (100ms) ‚Üí TCP (50ms) ‚Üí TLS (100ms) ‚Üí Request (50ms) = 300ms

With dns-prefetch:
DNS already resolved ‚Üí TCP (50ms) ‚Üí TLS (100ms) ‚Üí Request (50ms) = 200ms
Saved: 100ms
```

### Example Implementation

```html
<head>
  <!-- Third-party services -->
  <link rel="dns-prefetch" href="//www.google-analytics.com">
  <link rel="dns-prefetch" href="//connect.facebook.net">

  <!-- Font providers -->
  <link rel="dns-prefetch" href="//fonts.googleapis.com">
  <link rel="dns-prefetch" href="//fonts.gstatic.com">

  <!-- CDN -->
  <link rel="dns-prefetch" href="//cdn.example.com">
</head>
```

### Important Notes

- Use protocol-relative URLs (`//domain.com`) or full URLs
- Most effective when done early in `<head>`
- Browser may ignore if already connected to domain
- Low risk - safe to use liberally for known domains

---

## Preconnect

Preconnect completes the entire connection handshake (DNS + TCP + TLS) before sending the actual request.

### What It Does

Establishes a **full connection** to the origin:
1. DNS lookup
2. TCP handshake
3. TLS negotiation (for HTTPS)

**Syntax:**

```html
<link rel="preconnect" href="https://cdn.example.com">
<link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
```

### Characteristics

| Aspect | Details |
|--------|---------|
| **Scope** | Complete connection |
| **Cost** | Expensive (uses connection pool) |
| **Speed** | Much faster than dns-prefetch |
| **Risk** | Can waste connections if overused |

### When to Use

Preconnect is best for:
- **Critical 3rd-party origins** - CDNs serving hero images
- **Font providers** - When fonts are above the fold
- **API origins** - For immediate data fetching
- **Authentication servers** - OAuth, SSO providers

### Rule of Thumb

**Use preconnect for only 1-2 critical origins maximum.** Browsers have limited connection pools (typically 6 connections per origin), and unused preconnections waste resources.

### Performance Impact

```
Normal request:
DNS (100ms) ‚Üí TCP (50ms) ‚Üí TLS (100ms) ‚Üí Request (50ms) = 300ms

With preconnect:
Connection already established ‚Üí Request (50ms) = 50ms
Saved: 250ms
```

### Example Implementation

```html
<head>
  <!-- Critical CDN for hero image -->
  <link rel="preconnect" href="https://cdn.myapp.com" crossorigin>

  <!-- Critical font provider -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
</head>
```

### Crossorigin Attribute

Always include `crossorigin` for CORS requests (fonts, some CDN assets):

```html
<!-- Without crossorigin - creates two connections -->
<link rel="preconnect" href="https://fonts.gstatic.com">

<!-- With crossorigin - creates correct connection -->
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
```

### DNS Prefetch as Fallback

Use both for maximum browser support:

```html
<link rel="preconnect" href="https://cdn.example.com">
<link rel="dns-prefetch" href="//cdn.example.com">
```

Modern browsers use `preconnect`, older browsers fall back to `dns-prefetch`.

---

## Preload

Preload tells the browser to fetch a resource **immediately** with high priority, as if it's needed right now.

### What It Does

Downloads a resource **as soon as possible** with the priority of a render-blocking resource.

**Syntax:**

```html
<link rel="preload"
      href="/fonts/Inter-Bold.woff2"
      as="font"
      type="font/woff2"
      crossorigin>
```

### Characteristics

| Aspect | Details |
|--------|---------|
| **Priority** | Very high (same as render-blocking) |
| **Timing** | Fetches immediately |
| **Blocking** | Can block rendering if resource is critical |
| **Usage requirement** | Must be used on the page or browser warns |

### Required Attributes

1. **`as` attribute** - Tells browser what type of resource:
   - `font`, `image`, `style`, `script`, `fetch`, `document`, etc.

2. **`type` attribute** - MIME type (required for fonts):
   - `font/woff2`, `font/woff`, `image/webp`, etc.

3. **`crossorigin` attribute** - Required for CORS requests:
   - Always use for fonts (even same-origin)

### Common Use Cases

#### 1. Critical Fonts (LCP Text)

```html
<link rel="preload"
      href="/fonts/Inter-Regular.woff2"
      as="font"
      type="font/woff2"
      crossorigin>
```

**Why:** Fonts needed for LCP text block rendering path.

#### 2. Hero Images (LCP Image)

```html
<link rel="preload"
      href="/hero-large.webp"
      as="image"
      type="image/webp"
      imagesrcset="/hero-small.webp 640w, /hero-large.webp 1920w"
      imagesizes="100vw">
```

**Why:** Hero image is usually the LCP element.

#### 3. Critical CSS

```html
<link rel="preload"
      href="/critical.css"
      as="style">
```

**Why:** Prevents FOUC (Flash of Unstyled Content).

#### 4. Above-the-Fold JavaScript

```html
<link rel="preload"
      href="/app.js"
      as="script">
```

**Why:** JavaScript needed for initial interactivity.

### Performance Impact

```
Without preload:
HTML parse (200ms) ‚Üí Discover font in CSS (100ms) ‚Üí Download font (300ms) = 600ms

With preload:
HTML parse + Font download in parallel (200ms) ‚Üí Render = 200ms
Saved: 400ms (massive LCP improvement)
```

### Warning: Unused Preload

If you preload a resource but don't use it within 3 seconds, Chrome shows a warning:

```
The resource was preloaded but not used within a few seconds.
```

**Fix:** Only preload resources that are **definitely** used on the current page.

### Preload Examples by Resource Type

#### Images

```html
<!-- Simple image -->
<link rel="preload" href="/hero.jpg" as="image">

<!-- Responsive image with srcset -->
<link rel="preload"
      as="image"
      href="/hero-large.webp"
      imagesrcset="/hero-small.webp 640w, /hero-medium.webp 1280w, /hero-large.webp 1920w"
      imagesizes="(max-width: 640px) 100vw, (max-width: 1280px) 50vw, 33vw">
```

#### Fonts

```html
<link rel="preload"
      href="/fonts/Inter-Bold.woff2"
      as="font"
      type="font/woff2"
      crossorigin>
```

#### Stylesheets

```html
<link rel="preload" href="/critical.css" as="style">
<link rel="stylesheet" href="/critical.css">
```

#### Scripts

```html
<link rel="preload" href="/app.js" as="script">
<script src="/app.js" defer></script>
```

### Best Practices

1. **Limit preloads** - Maximum 2-3 per page
2. **Preload only critical resources** - Above the fold content
3. **Always specify `as` attribute** - Enables correct prioritization
4. **Use `crossorigin` for fonts** - Even for same-origin fonts
5. **Measure impact** - Use Lighthouse and Web Vitals

---

## Prefetch

Prefetch downloads resources with **low priority** for use in **future navigation**.

### What It Does

Fetches resources during **idle time** that will likely be needed on the **next page**.

**Syntax:**

```html
<link rel="prefetch" href="/next-page.js">
<link rel="prefetch" href="/about-page.css">
<link rel="prefetch" href="/product-data.json">
```

### Characteristics

| Aspect | Details |
|--------|---------|
| **Priority** | Very low (idle time only) |
| **Timing** | After current page is loaded |
| **Guarantee** | Not guaranteed on slow connections |
| **Cache** | Stored in HTTP cache |

### When to Use

Prefetch is ideal for:
- **Route-based code splitting** - Next page's JavaScript bundle
- **Likely navigation targets** - Product pages, documentation sections
- **Sequential content** - Next article, next image in gallery
- **Background data** - User profile for logged-in users

### How It Works

```
Page A (current):
Load critical resources ‚Üí Page interactive ‚Üí Idle time ‚Üí Prefetch Page B resources

User navigates to Page B:
Resources already cached ‚Üí Instant load
```

### Use Cases by Application Type

#### Single Page Applications (SPA)

```html
<!-- Prefetch route chunks -->
<link rel="prefetch" href="/static/js/about.chunk.js">
<link rel="prefetch" href="/static/js/products.chunk.js">
```

#### Multi-Page Applications

```html
<!-- Prefetch next page resources -->
<link rel="prefetch" href="/next-page.html">
<link rel="prefetch" href="/next-page.css">
```

#### E-commerce

```html
<!-- User viewing category page -->
<link rel="prefetch" href="/api/product/123">
<link rel="prefetch" href="/product/123">
```

### Performance Impact

```
Without prefetch:
Navigate ‚Üí Download JS (500ms) ‚Üí Parse (100ms) ‚Üí Interactive = 600ms

With prefetch:
Navigate ‚Üí JS already cached ‚Üí Parse (100ms) ‚Üí Interactive = 100ms
Saved: 500ms
```

### Framework Integration

#### Next.js (Automatic)

```jsx
// Next.js prefetches linked pages automatically on hover
<Link href="/about">About</Link>
```

#### React Router (Manual)

```jsx
import { useEffect } from 'react';

function Navigation() {
  useEffect(() => {
    // Prefetch on hover
    const link = document.createElement('link');
    link.rel = 'prefetch';
    link.href = '/about-page.js';
    document.head.appendChild(link);
  }, []);
}
```

### Important Notes

- Browser may **ignore prefetch** on:
  - Slow networks (2G, 3G)
  - Low battery (mobile devices)
  - Data saver mode enabled
- Prefetch does NOT block current page loading
- Resources go to HTTP cache, not memory cache

### Prefetch vs Preload

| Aspect | Preload | Prefetch |
|--------|---------|----------|
| **Priority** | High | Low |
| **Usage** | Current page | Future page |
| **Timing** | Immediate | Idle time |
| **Blocking** | Can block | Never blocks |

**Rule:** Never prefetch critical resources for the current page ‚Äî use preload instead.

---

## Module Preload

Module preload is specifically designed for **ES modules**, preloading the module **and** its entire dependency graph.

### What It Does

1. Downloads the ES module
2. Parses it to discover imports
3. Downloads all dependencies
4. Avoids waterfall loading

**Syntax:**

```html
<link rel="modulepreload" href="/main.js">
<link rel="modulepreload" href="/utils.js">
```

### Why It's Better Than Regular Preload

**Regular preload for modules:**
```html
<link rel="preload" href="/main.js" as="script">
```

Problem: Doesn't preload dependencies, leading to waterfalls:

```
main.js ‚Üí utils.js ‚Üí helpers.js ‚Üí constants.js
‚îî‚îÄ 100ms ‚îÄ‚î¥‚îÄ 100ms ‚îÄ‚îÄ‚î¥‚îÄ 100ms ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ 100ms ‚îÄ‚îÄ‚îò = 400ms
```

**Module preload:**
```html
<link rel="modulepreload" href="/main.js">
```

Solution: Preloads entire dependency tree in parallel:

```
main.js ‚îÄ‚îê
utils.js ‚îº‚îÄ All in parallel
helpers.js ‚î§
constants.js ‚îò
‚îî‚îÄ 100ms ‚îÄ‚îÄ‚îò = 100ms
```

### Use Cases

Module preload is essential for:
- **Vite applications** - ES module-based builds
- **Rollup bundles** - Native ES modules
- **Modern JavaScript** - `import` statements
- **Dynamic imports** - `import()` expressions

### Example: Vite Application

Vite automatically generates module preload hints:

```html
<head>
  <!-- Vite automatically adds these -->
  <link rel="modulepreload" href="/src/main.js">
  <link rel="modulepreload" href="/src/components/App.jsx">
  <link rel="modulepreload" href="/src/utils/api.js">
</head>
```

### Example: Manual Module Preload

```html
<link rel="modulepreload" href="/js/app.js">
<link rel="modulepreload" href="/js/router.js">
<link rel="modulepreload" href="/js/store.js">

<script type="module" src="/js/app.js"></script>
```

### Crossorigin Considerations

Always use `crossorigin` for CDN-hosted modules:

```html
<link rel="modulepreload"
      href="https://cdn.example.com/app.js"
      crossorigin>
```

### Browser Support

Module preload is supported in:
- ‚úÖ Chrome 66+
- ‚úÖ Edge 79+
- ‚úÖ Safari 14+
- ‚úÖ Firefox 115+

For older browsers, they'll simply ignore the hint and load modules normally (no harm done).

### Performance Impact

```
Without modulepreload:
Load main.js (100ms) ‚Üí Parse ‚Üí Load utils.js (100ms) ‚Üí Parse ‚Üí Load helpers.js (100ms) = 300ms

With modulepreload:
Load all modules in parallel (100ms) ‚Üí Parse = 100ms
Saved: 200ms
```

---

## Fetch Priority

Fetch priority allows fine-grained control over the **relative importance** of resources, telling the browser which resources to prioritize.

### What It Does

Hints the browser about how important a resource is compared to others, allowing manual priority tuning.

**Syntax:**

```html
<img src="/hero.jpg" fetchpriority="high" loading="eager">
<img src="/footer-logo.png" fetchpriority="low" loading="lazy">
<script src="/analytics.js" fetchpriority="low"></script>
```

### Values

| Value | Meaning | Use Case |
|-------|---------|----------|
| `high` | Load as soon as possible | LCP image, critical CSS |
| `low` | Defer until after critical resources | Analytics, below-fold images |
| `auto` | Browser default priority | Default behavior |

### Common Use Cases

#### 1. LCP Image Optimization

Problem: Hero image loads late, hurting LCP.

```html
<!-- Before -->
<img src="/hero.jpg" alt="Hero">

<!-- After -->
<img src="/hero.jpg"
     alt="Hero"
     fetchpriority="high"
     loading="eager">
```

**Impact:** Can improve LCP by 200-500ms.

#### 2. Defer Non-Critical Scripts

```html
<!-- Analytics should load last -->
<script src="https://www.google-analytics.com/analytics.js"
        fetchpriority="low"
        async>
</script>
```

#### 3. Prioritize Critical CSS

```html
<link rel="stylesheet"
      href="/critical.css"
      fetchpriority="high">
```

#### 4. De-prioritize Below-Fold Images

```html
<img src="/footer-image.jpg"
     fetchpriority="low"
     loading="lazy">
```

### How Browsers Use Fetch Priority

Browsers assign default priorities:

| Resource Type | Default Priority | Can Override |
|---------------|------------------|--------------|
| HTML | Highest | No |
| CSS (render-blocking) | Highest | Yes |
| Fonts | High | No |
| Scripts (early) | High | Yes |
| Images (above-fold) | High | Yes |
| Images (below-fold) | Low | Yes |
| Scripts (late) | Low | Yes |

`fetchpriority` lets you override these defaults.

### LCP Optimization Strategy

The most common and impactful use of `fetchpriority`:

```html
<!-- 1. Identify LCP element (usually hero image) -->
<img src="/hero-image.jpg"
     alt="Hero"
     fetchpriority="high"
     loading="eager"
     width="1200"
     height="600">

<!-- 2. Lower priority of competing resources -->
<script src="/social-widgets.js" fetchpriority="low" defer></script>
<img src="/sidebar-ad.jpg" fetchpriority="low" loading="lazy">
```

### Real-World Example: E-commerce Product Page

```html
<head>
  <!-- Critical CSS -->
  <link rel="stylesheet" href="/critical.css" fetchpriority="high">
</head>

<body>
  <!-- Product hero image (LCP element) -->
  <img src="/product-main.jpg"
       fetchpriority="high"
       loading="eager"
       alt="Product">

  <!-- Product thumbnails (below hero) -->
  <img src="/product-thumb-1.jpg" fetchpriority="low" loading="lazy">
  <img src="/product-thumb-2.jpg" fetchpriority="low" loading="lazy">

  <!-- Analytics -->
  <script src="/analytics.js" fetchpriority="low" async></script>

  <!-- Recommendations (below fold) -->
  <img src="/recommended-1.jpg" fetchpriority="low" loading="lazy">
</body>
```

### Browser Support

- ‚úÖ Chrome 101+
- ‚úÖ Edge 101+
- ‚ö†Ô∏è Safari - Partial support
- ‚ö†Ô∏è Firefox - In development

For unsupported browsers, the attribute is safely ignored.

### Best Practices

1. **Set `fetchpriority="high"` on LCP element** - Biggest impact
2. **Use sparingly** - Only 1-2 high priority resources
3. **Combine with `loading` attribute** - `eager` for high, `lazy` for low
4. **Measure impact** - Use Chrome DevTools Network panel
5. **Don't over-optimize** - Default priorities work well for most resources

---

## Comparison Table

Quick reference for choosing the right hint.

| Hint | Priority | Timing | Use Case | Cost | Risk |
|------|----------|--------|----------|------|------|
| **dns-prefetch** | Very low | Future domain | Analytics, fonts, ads | Very cheap | None |
| **preconnect** | High | Critical domain | CDN, fonts (above fold) | Expensive | Connection waste |
| **preload** | Very high | Needed now | LCP image, critical font | Moderate | Unused warning |
| **prefetch** | Very low | Needed later | Next page assets | Cheap | May be ignored |
| **modulepreload** | High | ES modules | Vite/Rollup apps | Moderate | None |
| **fetchpriority** | Manual | Relative tuning | LCP optimization | None | None |

### Decision Tree

```
Need to optimize current page?
‚îú‚îÄ Yes ‚Üí Need full connection?
‚îÇ   ‚îú‚îÄ Yes ‚Üí preconnect (max 2 origins)
‚îÇ   ‚îî‚îÄ No ‚Üí dns-prefetch (many origins OK)
‚îÇ
‚îú‚îÄ Critical resource for current page?
‚îÇ   ‚îú‚îÄ Traditional resource ‚Üí preload
‚îÇ   ‚îî‚îÄ ES module ‚Üí modulepreload
‚îÇ
‚îú‚îÄ Resource for future page?
‚îÇ   ‚îî‚îÄ prefetch
‚îÇ
‚îî‚îÄ Fine-tune priority?
    ‚îî‚îÄ fetchpriority
```

### Combining Hints

These hints work together. Common combinations:

```html
<!-- CDN with critical font -->
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="preload"
      href="https://fonts.gstatic.com/s/inter/v12/Inter-Bold.woff2"
      as="font"
      type="font/woff2"
      crossorigin>

<!-- Hero image optimization -->
<link rel="preload" href="/hero.jpg" as="image">
<img src="/hero.jpg" fetchpriority="high" loading="eager">

<!-- Prefetch next page while preloading current page -->
<link rel="preload" href="/current-page.css" as="style">
<link rel="prefetch" href="/next-page.js">
```

---

## Common Interview Scenarios

### ‚ùì How to optimize font loading?

**Problem:** Fonts block rendering, causing FOIT (Flash of Invisible Text).

**Solution:**

```html
<head>
  <!-- 1. Preconnect to font provider -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

  <!-- 2. Preload critical fonts -->
  <link rel="preload"
        href="/fonts/Inter-Regular.woff2"
        as="font"
        type="font/woff2"
        crossorigin>

  <!-- 3. Use font-display -->
  <style>
    @font-face {
      font-family: 'Inter';
      src: url('/fonts/Inter-Regular.woff2') format('woff2');
      font-display: swap; /* Shows fallback until font loads */
    }
  </style>
</head>
```

**Impact:** Reduces blocking time by 200-400ms, improves LCP.

---

### ‚ùì LCP image loads late. How to fix?

**Problem:** Hero image discovered late, hurting LCP score.

**Solution:**

```html
<!-- Step 1: Preload the image -->
<link rel="preload" href="/hero-large.webp" as="image">

<!-- Step 2: Add fetchpriority and loading -->
<img src="/hero-large.webp"
     srcset="/hero-small.webp 640w,
             /hero-medium.webp 1280w,
             /hero-large.webp 1920w"
     sizes="100vw"
     fetchpriority="high"
     loading="eager"
     alt="Hero image"
     width="1920"
     height="1080">
```

**Impact:** Can improve LCP by 300-700ms.

**Additional optimization:**

```html
<!-- Preconnect if image is on CDN -->
<link rel="preconnect" href="https://cdn.example.com">
<link rel="preload" href="https://cdn.example.com/hero.webp" as="image">
```

---

### ‚ùì How to improve navigation performance in SPA?

**Problem:** Navigating between routes feels slow due to code splitting.

**Solution: Intelligent Prefetching**

```javascript
// React Router example
import { useEffect } from 'react';
import { useLocation } from 'react-router-dom';

function Navigation() {
  const location = useLocation();

  useEffect(() => {
    // Prefetch likely next routes
    if (location.pathname === '/products') {
      prefetchRoute('/product/123');
    }
  }, [location]);

  function prefetchRoute(path) {
    const link = document.createElement('link');
    link.rel = 'prefetch';
    link.href = `${path}.chunk.js`;
    document.head.appendChild(link);
  }
}
```

**Next.js (Built-in):**

```jsx
// Next.js automatically prefetches on hover
<Link href="/about" prefetch={true}>
  About
</Link>
```

**Impact:** Near-instant navigation (50-100ms vs 500-1000ms).

---

### ‚ùì How to optimize third-party scripts?

**Problem:** Analytics and ads slow down page load.

**Solution: Defer and De-prioritize**

```html
<!-- Google Analytics - load late -->
<script src="https://www.google-analytics.com/analytics.js"
        fetchpriority="low"
        async>
</script>

<!-- Ads - load very late -->
<script src="https://ads.example.com/ads.js"
        fetchpriority="low"
        defer>
</script>

<!-- But preconnect to reduce latency when they do load -->
<link rel="dns-prefetch" href="//www.google-analytics.com">
<link rel="dns-prefetch" href="//ads.example.com">
```

**Impact:** Improves TTI by 200-500ms without breaking functionality.

---

### ‚ùì How to handle critical CSS?

**Problem:** External CSS blocks rendering.

**Solution: Inline Critical + Preload Full**

```html
<head>
  <!-- Inline critical CSS (above-the-fold) -->
  <style>
    /* Critical CSS for hero section */
    .hero { display: flex; height: 100vh; }
    .hero-title { font-size: 3rem; }
  </style>

  <!-- Preload full stylesheet -->
  <link rel="preload" href="/full-styles.css" as="style">
  <link rel="stylesheet" href="/full-styles.css">
</head>
```

**Alternative: LoadCSS Pattern**

```html
<link rel="preload"
      href="/styles.css"
      as="style"
      onload="this.onload=null;this.rel='stylesheet'">
<noscript>
  <link rel="stylesheet" href="/styles.css">
</noscript>
```

---

### ‚ùì When should I NOT use preload?

**Don't preload if:**

1. **Resource is not critical** - Below-the-fold content
2. **Resource may not be needed** - Conditional features
3. **Already in cache** - User has visited before
4. **Too many preloads** - More than 2-3 reduces effectiveness
5. **Dynamic content** - URLs change frequently

**Bad Example:**

```html
<!-- DON'T: Preloading everything -->
<link rel="preload" href="/image1.jpg" as="image">
<link rel="preload" href="/image2.jpg" as="image">
<link rel="preload" href="/image3.jpg" as="image">
<link rel="preload" href="/image4.jpg" as="image">
<!-- This overwhelms the browser and reduces benefits -->
```

**Good Example:**

```html
<!-- DO: Preload only LCP element -->
<link rel="preload" href="/hero.jpg" as="image">
```

---

## DOs and DON'Ts

### ‚úÖ DO

1. **Preload only critical resources**
   - LCP image
   - Above-the-fold fonts
   - Critical CSS (if external)

2. **Use preconnect sparingly**
   - Maximum 1-2 critical origins
   - Only for resources that WILL be used

3. **Measure impact with tools**
   - Chrome DevTools Network panel
   - Lighthouse performance audits
   - Web Vitals metrics (LCP, FCP, TTI)

4. **Combine hints strategically**
   ```html
   <link rel="preconnect" href="https://fonts.gstatic.com">
   <link rel="preload" href="https://fonts.gstatic.com/font.woff2" as="font">
   ```

5. **Use fetchpriority on LCP element**
   ```html
   <img src="/hero.jpg" fetchpriority="high">
   ```

6. **Specify `as` attribute for preload**
   ```html
   <link rel="preload" href="/font.woff2" as="font">
   ```

7. **Use crossorigin for fonts**
   ```html
   <link rel="preload" href="/font.woff2" as="font" crossorigin>
   ```

### ‚ùå DON'T

1. **Don't preload everything**
   - Defeats the purpose of prioritization
   - Can actually slow down critical resources
   - Browser warning for unused preloads

2. **Don't preconnect to many domains**
   ```html
   <!-- BAD: Too many preconnects -->
   <link rel="preconnect" href="https://cdn1.com">
   <link rel="preconnect" href="https://cdn2.com">
   <link rel="preconnect" href="https://cdn3.com">
   <link rel="preconnect" href="https://cdn4.com">
   ```

   Wastes connection pool (browsers have ~6 connections per origin).

3. **Don't prefetch critical resources**
   ```html
   <!-- WRONG: Hero image is critical, don't prefetch -->
   <link rel="prefetch" href="/hero.jpg">

   <!-- CORRECT: Preload instead -->
   <link rel="preload" href="/hero.jpg" as="image">
   ```

4. **Don't forget `as` attribute in preload**
   ```html
   <!-- WRONG: No 'as' attribute -->
   <link rel="preload" href="/style.css">

   <!-- CORRECT: Specify resource type -->
   <link rel="preload" href="/style.css" as="style">
   ```

5. **Don't use hints without measurement**
   - Always verify with Lighthouse
   - Check Network panel for priority
   - Measure LCP/FCP improvements

6. **Don't mix up preload and prefetch**
   - Preload = current page (high priority)
   - Prefetch = next page (low priority)

---

## Production Example

Ideal setup for a production web application.

### Complete HTML Head

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>My App</title>

  <!-- ============================================
       1. CONNECTION HINTS (Early)
       ============================================ -->

  <!-- Critical CDN for assets -->
  <link rel="preconnect" href="https://cdn.myapp.com" crossorigin>

  <!-- Font provider -->
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

  <!-- DNS prefetch for third-party services -->
  <link rel="dns-prefetch" href="//www.google-analytics.com">
  <link rel="dns-prefetch" href="//connect.facebook.net">


  <!-- ============================================
       2. CRITICAL RESOURCE HINTS
       ============================================ -->

  <!-- Critical fonts for LCP text -->
  <link rel="preload"
        href="https://fonts.gstatic.com/s/inter/v12/Inter-Regular.woff2"
        as="font"
        type="font/woff2"
        crossorigin>

  <!-- Hero image (LCP element) -->
  <link rel="preload"
        href="/images/hero-large.webp"
        as="image"
        type="image/webp">

  <!-- ES module and dependencies -->
  <link rel="modulepreload" href="/js/main.js">
  <link rel="modulepreload" href="/js/utils.js">


  <!-- ============================================
       3. STYLESHEETS
       ============================================ -->

  <!-- Critical CSS inline -->
  <style>
    /* Above-the-fold critical CSS */
    .hero { display: flex; height: 100vh; }
    body { margin: 0; font-family: Inter, sans-serif; }
  </style>

  <!-- Full stylesheet -->
  <link rel="stylesheet" href="/css/styles.css" fetchpriority="high">


  <!-- ============================================
       4. PREFETCH FOR NEXT PAGE
       ============================================ -->

  <link rel="prefetch" href="/about.html">
  <link rel="prefetch" href="/js/about.chunk.js">
</head>

<body>
  <!-- ============================================
       CRITICAL CONTENT
       ============================================ -->

  <!-- Hero section (LCP) -->
  <section class="hero">
    <img src="/images/hero-large.webp"
         srcset="/images/hero-small.webp 640w,
                 /images/hero-medium.webp 1280w,
                 /images/hero-large.webp 1920w"
         sizes="100vw"
         fetchpriority="high"
         loading="eager"
         alt="Hero image"
         width="1920"
         height="1080">
    <h1>Welcome to My App</h1>
  </section>


  <!-- ============================================
       BELOW-FOLD CONTENT
       ============================================ -->

  <section class="features">
    <img src="/images/feature-1.jpg"
         fetchpriority="low"
         loading="lazy"
         alt="Feature 1">
  </section>


  <!-- ============================================
       SCRIPTS (Bottom)
       ============================================ -->

  <!-- Main app -->
  <script type="module" src="/js/main.js"></script>

  <!-- Analytics (low priority) -->
  <script src="https://www.google-analytics.com/analytics.js"
          fetchpriority="low"
          async>
  </script>
</body>
</html>
```

### Key Principles in This Setup

1. **Connection hints first** - Establish connections early
2. **Preload critical resources** - Fonts and hero image
3. **Inline critical CSS** - Eliminate render-blocking
4. **Prefetch next page** - Improve navigation
5. **De-prioritize analytics** - Don't block main content
6. **Lazy load below-fold** - Save bandwidth

---

## Performance Impact Analysis

Real-world performance improvements from proper browser hinting.

### Case Study: E-commerce Product Page

**Before optimization:**

```
LCP: 3.2s
FCP: 1.8s
TTI: 4.1s
```

**After optimization with hints:**

```html
<link rel="preconnect" href="https://cdn.shop.com">
<link rel="preload" href="/fonts/Inter.woff2" as="font" crossorigin>
<link rel="preload" href="/product-hero.jpg" as="image">
<img src="/product-hero.jpg" fetchpriority="high">
```

**Results:**

```
LCP: 1.9s (-41%)
FCP: 1.1s (-39%)
TTI: 2.8s (-32%)
```

### Metric Improvements by Technique

| Technique | LCP Impact | FCP Impact | TTI Impact | Use Case |
|-----------|------------|------------|------------|----------|
| **Preconnect** | -200ms | -100ms | - | CDN/fonts |
| **Preload font** | -300ms | -300ms | - | Web fonts |
| **Preload image** | -500ms | - | - | Hero image |
| **Fetchpriority** | -200ms | - | - | LCP element |
| **Prefetch** | - | - | -400ms* | Next page |
| **Modulepreload** | - | - | -200ms | ES modules |

*Navigation time improvement

### Lighthouse Score Impact

Typical Lighthouse score improvements:

```
Before: 67/100 (Performance)
After:  91/100 (Performance)

Improvements:
- Largest Contentful Paint: Good (was Poor)
- First Contentful Paint: Good (was Needs Improvement)
- Speed Index: Good (was Needs Improvement)
```

---

## Quick Reference Summary

### One-Line Interview Answer

> "Browser hints let us guide the browser's loading priorities to shorten the critical rendering path and improve Web Vitals by telling it what to load, when, and how before it discovers resources naturally."

### Quick Decision Matrix

**Need to optimize current page load?**
- Critical resource ‚Üí `preload`
- ES module ‚Üí `modulepreload`
- Connection needed ‚Üí `preconnect`
- Third-party domain ‚Üí `dns-prefetch`
- Fine-tune priority ‚Üí `fetchpriority`

**Need to optimize future navigation?**
- Next page resources ‚Üí `prefetch`

### Most Important Techniques (Top 3)

1. **Preload LCP element** (biggest impact)
   ```html
   <link rel="preload" href="/hero.jpg" as="image">
   ```

2. **Fetchpriority on hero** (easy win)
   ```html
   <img src="/hero.jpg" fetchpriority="high">
   ```

3. **Preconnect critical origins** (reduce latency)
   ```html
   <link rel="preconnect" href="https://cdn.myapp.com">
   ```

### Common Mistakes to Avoid

1. ‚ùå Preloading everything
2. ‚ùå Too many preconnects (>2)
3. ‚ùå Prefetching current page resources
4. ‚ùå Forgetting `as` attribute
5. ‚ùå No `crossorigin` for fonts
6. ‚ùå Not measuring impact

### Validation Checklist

Before deploying browser hints:

- [ ] Verify preloaded resources are actually used
- [ ] Check no "unused preload" warnings in console
- [ ] Confirm LCP improvement in Lighthouse
- [ ] Test on slow 3G network
- [ ] Verify fetchpriority on correct element
- [ ] Ensure max 2 preconnects
- [ ] Confirm crossorigin on fonts

---

## Next Topics

Want to dive deeper? Explore:

- üî• **Real LCP Optimization Checklist** - Complete guide to improving LCP
- üî• **Next.js / React Browser Hinting** - Framework-specific optimizations
- üî• **When Browser Hints Backfire** - Over-hinting and performance pitfalls
- üî• **Resource Loading Timeline Analysis** - Chrome DevTools deep dive
- üî• **HTTP/2 Server Push vs Browser Hints** - Comparison and trade-offs

---

*Last Updated: December 2024*
