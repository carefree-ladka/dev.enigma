# TypeScript Cheatsheet

## Basic Types
```typescript
// Primitive types
let isDone: boolean = false;
let decimal: number = 6;
let color: string = "blue";
let list: number[] = [1, 2, 3];
let tuple: [string, number] = ["hello", 10];

// Special types
let notSure: any = 4;
let u: undefined = undefined;
let n: null = null;
let v: void = undefined;
let nv: never = (() => { throw new Error(); })();
```

## Interfaces
```typescript
// Basic interface
interface User {
  name: string;
  age: number;
  readonly id: number;
  email?: string;  // Optional property
}

// Interface extending another interface
interface Employee extends User {
  department: string;
  salary: number;
}

// Interface with method definition
interface Clickable {
  onClick(): void;
  onDoubleClick?(event: MouseEvent): void;
}
```

## Classes & OOP
```typescript
// Abstract class
abstract class Animal {
  protected name: string;
  
  constructor(name: string) {
    this.name = name;
  }
  
  abstract makeSound(): void;
  
  move(distance: number): void {
    console.log(`${this.name} moved ${distance}m.`);
  }
}

// Class implementation
class Dog extends Animal {
  constructor(name: string) {
    super(name);
  }
  
  makeSound(): void {
    console.log('Woof!');
  }
}

// Access modifiers
class Account {
  private balance: number;
  public readonly id: string;
  protected type: string;
  
  constructor(id: string) {
    this.id = id;
    this.balance = 0;
    this.type = 'standard';
  }
}
```

## Generics
```typescript
// Generic function
function identity<T>(arg: T): T {
  return arg;
}

// Generic interface
interface Collection<T> {
  add(item: T): void;
  remove(item: T): void;
  getItems(): T[];
}

// Generic class
class Queue<T> {
  private data: T[] = [];
  
  push(item: T): void {
    this.data.push(item);
  }
  
  pop(): T | undefined {
    return this.data.shift();
  }
}

// Generic constraints
interface Lengthwise {
  length: number;
}

function loggingIdentity<T extends Lengthwise>(arg: T): T {
  console.log(arg.length);
  return arg;
}
```

## Utility Types
```typescript
// Partial - Makes all properties optional
interface Todo {
  title: string;
  description: string;
}
type PartialTodo = Partial<Todo>;

// Required - Makes all properties required
type RequiredTodo = Required<Todo>;

// Pick - Creates type with subset of properties
type TodoTitle = Pick<Todo, 'title'>;

// Omit - Creates type without specified properties
type TodoWithoutDescription = Omit<Todo, 'description'>;

// Record - Creates type with specified keys and value type
type PageInfo = Record<string, { url: string }>;

// Readonly - Makes all properties readonly
type ReadonlyTodo = Readonly<Todo>;

// ReturnType - Extracts return type of function
type FunctionReturn = ReturnType<() => string>;
```

## Advanced Types
```typescript
// Union Types
type StringOrNumber = string | number;

// Intersection Types
type Employee = Person & Identifiable;

// Type Guards
function isString(value: any): value is string {
  return typeof value === 'string';
}

// Mapped Types
type Nullable<T> = { [P in keyof T]: T[P] | null };

// Conditional Types
type NonNullable<T> = T extends null | undefined ? never : T;
```

## Decorators
```typescript
// Class Decorator
function sealed(constructor: Function) {
  Object.seal(constructor);
  Object.seal(constructor.prototype);
}

@sealed
class Example {
  // ...
}

// Property Decorator
function required(target: Object, propertyKey: string) {
  let value: any;
  
  const getter = () => value;
  const setter = (newVal: any) => {
    if (newVal === undefined || newVal === null) {
      throw new Error('Value is required');
    }
    value = newVal;
  };
  
  Object.defineProperty(target, propertyKey, {
    get: getter,
    set: setter,
    enumerable: true,
    configurable: true,
  });
}
```

## Best Practices & Common Patterns
```typescript
// Type assertion
let someValue: any = "this is a string";
let strLength: number = (someValue as string).length;

// Type inference with 'as const'
const config = {
  endpoint: "api.example.com",
  port: 3000
} as const;

// Index signatures
interface StringMap {
  [key: string]: string;
}

// Discriminated unions
interface Square {
  kind: "square";
  size: number;
}

interface Rectangle {
  kind: "rectangle";
  width: number;
  height: number;
}

type Shape = Square | Rectangle;

// Type guards with discriminated unions
function getArea(shape: Shape): number {
  switch (shape.kind) {
    case "square":
      return shape.size * shape.size;
    case "rectangle":
      return shape.width * shape.height;
  }
}
```