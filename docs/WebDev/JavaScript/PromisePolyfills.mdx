# Promise Fundamentals

### What is a Promise?
A Promise represents the eventual completion (or failure) of an asynchronous operation and its resulting value. It exists in one of three states:
- **Pending**: Initial state, neither fulfilled nor rejected
- **Fulfilled**: Operation completed successfully
- **Rejected**: Operation failed

### Creating a Promise
```javascript
const myPromise = new Promise((resolve, reject) => {
  // Asynchronous operation
  if (/* operation successful */) {
    resolve(result);
  } else {
    reject(error);
  }
});
```

## Promise Methods

### Instance Methods

1. **`.then()`**: Handles successful Promise resolution
```javascript
myPromise
  .then((result) => {
    // Handle successful result
  })
  .catch((error) => {
    // Handle errors
  });
```

2. **`.catch()`**: Handles Promise rejection
```javascript
myPromise.catch((error) => {
  // Handle any errors
});
```

3. **`.finally()`**: Executes regardless of Promise state
```javascript
myPromise
  .then((result) => {/* success */})
  .catch((error) => {/* error */})
  .finally(() => {
    // Always runs, useful for cleanup
  });
```

### Static Methods

1. **`Promise.resolve()`**: Creates a resolved Promise
```javascript
const resolvedPromise = Promise.resolve(value);
```

2. **`Promise.reject()`**: Creates a rejected Promise
```javascript
const rejectedPromise = Promise.reject(error);
```

3. **`Promise.all()`**: Waits for all Promises to resolve
```javascript
Promise.all([promise1, promise2, promise3])
  .then((results) => {
    // All promises resolved
  })
  .catch((error) => {
    // If any promise is rejected
  });
```

4. **`Promise.race()`**: Resolves/rejects with first settled Promise
```javascript
Promise.race([promise1, promise2])
  .then((firstResult) => {
    // First promise to settle
  });
```

5. **`Promise.allSettled()`**: Waits for all Promises to settle
```javascript
Promise.allSettled([promise1, promise2])
  .then((results) => {
    // Array of settlement results
  });
```

6. **`Promise.any()`**: Resolves with first fulfilled Promise
```javascript
Promise.any([promise1, promise2])
  .then((firstFulfilledResult) => {
    // First promise fulfilled
  })
  .catch(AggregateError);
```

## Advanced Promise Patterns

### Chaining Promises
```javascript
fetchUser()
  .then(user => fetchUserPosts(user.id))
  .then(posts => processPosts(posts))
  .catch(handleError);
```

### Async/Await Syntax
```javascript
async function fetchData() {
  try {
    const user = await fetchUser();
    const posts = await fetchUserPosts(user.id);
    return processPosts(posts);
  } catch (error) {
    handleError(error);
  }
}
```

## Common Pitfalls

1. **Unhandled Rejections**: Always add `.catch()` or use try/catch
2. **Returning New Promises**: Each `.then()` can return a new Promise
3. **Error Propagation**: Errors automatically propagate through Promise chain

## Performance Considerations
- Avoid nested Promises
- Use `Promise.all()` for concurrent operations
- Prefer `async/await` for readability

## Best Practices
- Always handle potential errors
- Use meaningful error messages
- Keep Promise chains flat and readable
- Leverage `async/await` for complex asynchronous logic


## Promise Polyfill

```JavaScript
class MyPromise {
  #STATE = Object.freeze({
    PENDING: 'pending',
    SUCCESS: 'fulfilled',
    REJECTED: 'rejected'
  })

  #value = null
  #state = this.#STATE.PENDING
  #successCbs = []
  #failureCbs = []

  constructor(executor) {
    try {
      executor(
        (val) => this.#resolve(val),
        (val) => this.#reject(val)
      )
    } catch (e) {
      this.#reject(e)
    }
  }

  #resolve = (val) => {
    if (this.#state !== this.#STATE.PENDING) return

    // Handle promise resolution
    if (val instanceof MyPromise) {
      val.then(this.#resolve, this.#reject)
      return
    }

    this.#value = val
    this.#state = this.#STATE.SUCCESS
    this.#successCbs.forEach(cb => cb())
  }

  #reject = (error) => {
    if (this.#state !== this.#STATE.PENDING) return
    this.#value = error
    this.#state = this.#STATE.REJECTED
    this.#failureCbs.forEach(cb => cb())
  }

  then = (onFulfilled, onRejected) => {
    return new MyPromise((resolve, reject) => {
      const successCallback = () => {
        if (!onFulfilled) {
          resolve(this.#value)
          return
        }
        queueMicrotask(() => {
          try {
            const result = onFulfilled(this.#value)
            resolve(result)
          } catch (e) {
            reject(e)
          }
        })
      }

      const rejectCallback = () => {
        if (!onRejected) {
          reject(this.#value)
          return
        }
        queueMicrotask(() => {
          try {
            const result = onRejected(this.#value)
            resolve(result)
          } catch (e) {
            reject(e)
          }
        })
      }

      switch (this.#state) {
        case this.#STATE.PENDING:
          this.#successCbs.push(successCallback)
          this.#failureCbs.push(rejectCallback)
          break

        case this.#STATE.SUCCESS:
          successCallback()
          break

        case this.#STATE.REJECTED:
          rejectCallback()
          break

        default:
          throw new Error('Unknown state')
      }
    })
  }

  catch = (onRejected) => {
    return this.then(undefined, onRejected)
  }

  finally = (onFinally) => {
    return this.then(
      (val) => MyPromise.resolve(onFinally()).then(() => val),
      (reason) => MyPromise.resolve(onFinally()).then(() => { throw reason })
    )
  }

  static resolve = (value) => {
    return new MyPromise((resolve) => resolve(value))
  }

  static reject = (value) => {
    return new MyPromise((_, reject) => reject(value))
  }
}

const promise = new MyPromise((resolve, reject) => {
  setTimeout(() => resolve('Success!'), 1000)
})

promise
  .then(val => {
    console.log(val)  // After 1 second: 'Success!'
    return 'Hello'
  })
  .then(data => console.log(data))  // Immediately after: 'Hello'
  .catch(err => console.error(err))
  .finally(() => console.log('Done!'))  // Immediately after: 'Done!'
```

## Promise.all

```JavaScript
Promise.myAll = function (promises = []) {
  return new Promise((resolve, reject) => {
    if (!promises.length) resolve([])
    const result = []
    let count = 0
    promises.forEach((promise, index) => {
      Promise.resolve(promise).then((value) => {
        result[index] = value
        count++
        if (count === promises.length) {
          resolve(result)
        }
      }).catch((error) => reject(error))
    })
  })
}

// Example usage:
const p1 = Promise.reject(3);
const p2 = 42;
const p3 = new Promise((resolve, reject) => {
  setTimeout(resolve, 100, 'foo');
});

Promise.myAll([p1, p2, p3])
  .then((values) => {
    console.log(values); // [3, 42, "foo"]
  })
  .catch((error) => {
    console.error(error);
  });
```

## Promise.allSettled

```JavaScript
Promise.myAllSettled = function (promises = []) {
  return Promise.all(
    promises.map(promise => {
      return Promise.resolve(promise).then((value) => ({
        status: 'fulfilled', value
      })).catch((reason => ({
        status: 'rejected', reason
      })))
    })
  )
}

// Example usage:
const p1 = Promise.resolve(3);
const p2 = Promise.reject('An error occurred');
const p3 = new Promise((resolve, reject) => {
  setTimeout(resolve, 100, 'foo');
});

Promise.myAllSettled([p1, p2, p3])
  .then(results => {
    console.log(results);
    // [
    //   { status: 'fulfilled', value: 3 },
    //   { status: 'rejected', reason: 'An error occurred' },
    //   { status: 'fulfilled', value: 'foo' }
    // ]
  });
```

## Promise Any

```JavaScript
Promise.myAny = function (promises = []) {
  return new Promise((resolve, reject) => {
    let errors = [];
    let rejectedCount = 0;
    const totalPromises = promises.length;

    if (!totalPromises) {
      return reject(new AggregateError(errors, "All promises were rejected"));
    }

    promises.forEach((promise, index) => {
      Promise.resolve(promise)
        .then(value => {
          resolve(value);
        })
        .catch(error => {
          errors[index] = error;
          rejectedCount++;

          if (rejectedCount === totalPromises) {
            reject(new AggregateError(errors, "All promises were rejected"));
          }
        });
    });
  });
};

// Example usage:
const p1 = Promise.reject('Error 1');
const p2 = new Promise((resolve) => setTimeout(resolve, 100, 'Success 2'));
const p3 = new Promise((resolve) => setTimeout(resolve, 200, 'Success 3'));

Promise.myAny([p1, p2, p3])
  .then(value => {
    console.log('Resolved with value:', value); // "Resolved with value: Success 2"
  })
  .catch(error => {
    console.error('Rejected with error:', error);
  });
```


## Promise Race

```JavaScript
Promise.myRace = function (promises = []) {
  return new Promise((resolve, reject) => {
    promises.forEach(promise => {
      Promise.resolve(promise)
        .then(resolve)
        .catch(reject);
    });
  });
};

// Example usage:
const p1 = new Promise((resolve) => setTimeout(resolve, 500, 'Success 1'));
const p2 = new Promise((resolve, reject) => setTimeout(reject, 100, 'Error 2'));
const p3 = new Promise((resolve) => setTimeout(resolve, 200, 'Success 3'));

Promise.myRace([p1, p2, p3])
  .then(value => {
    console.log('Resolved with value:', value); // "Resolved with value: Success 2"
  })
  .catch(error => {
    console.error('Rejected with error:', error); // "Rejected with error: Error 2"
  });
```

## Fetch with Retry

```JavaScript
const fetchWithRetry = async (fetcher, maxRetry = 3, currentRetry = 0) => {
  try {
    const response = await fetcher()
    if (response.ok) {
      return await response.json()
    }
  }
  catch (err) {
    console.log('err', err);
    if (maxRetry > 0) {
      return fetchWithRetry(fetcher, maxRetry - 1, currentRetry + 1)
    }
  }
  throw new Error(`Failed to fetch after ${currentRetry} retries`)
}


//Usage 
const url = 'https://api.example.com'

const fetchData = async () => fetchWithRetry(() => fetch(url), 3)


fetchData()
  .then(res => res.json())
  .then(data => console.log(data))
  .catch(error => console.log('failed to fetch', error))
```

## Sleep

```JavaScript
const sleep = (wait) => new Promise(res => setTimeout(res, wait))

async function fix() {
  console.log('Start');
  await sleep(2000); // Sleep for 2 seconds
  console.log('End');
}

fix();
```

## Retry Callback

```JavaScript
function retry(fn, retries = 3, delay = 1000) {
    const attempt = (triesLeft, resolve, reject, args) => {
        fn(...args)
            .then(resolve)
            .catch(error => {
                if (triesLeft === 0) {
                    reject(`Failed after ${retries} attempts: ${error}`);
                } else {
                    console.log(`Retrying... Attempts left: ${triesLeft}`);
                    setTimeout(() => attempt(triesLeft - 1, resolve, reject, args), delay);
                }
            });
    };

    return (...args) => new Promise((resolve, reject) => attempt(retries, resolve, reject, args));
}
```

### Example Usage

```JavaScript
function unreliableFunction() {
    return new Promise((resolve, reject) => {
        const success = Math.random() > 0.7;  // 30% chance of success
        if (success) {
            resolve("Success!");
        } else {
            reject("Random failure");
        }
    });
}

const retryUnreliable = retry(unreliableFunction, 3, 1000);

retryUnreliable()
    .then(result => console.log(result))
    .catch(error => console.error(error));

/* 
Retrying... Attempts left: 3
Retrying... Attempts left: 2
Retrying... Attempts left: 1
Failed after 3 attempts: Random failure
*/
```