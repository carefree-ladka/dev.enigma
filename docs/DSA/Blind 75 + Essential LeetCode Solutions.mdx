# Blind 75 + Essential LeetCode Solutions

## Table of Contents

### Array
1. [Two Sum](#two-sum)
2. [Best Time to Buy and Sell Stock](#best-time-to-buy-and-sell-stock)
3. [Contains Duplicate](#contains-duplicate)
4. [Product of Array Except Self](#product-of-array-except-self)
5. [Maximum Subarray](#maximum-subarray)
6. [Maximum Product Subarray](#maximum-product-subarray)
7. [Find Minimum in Rotated Sorted Array](#find-minimum-in-rotated-sorted-array)
8. [Search in Rotated Sorted Array](#search-in-rotated-sorted-array)
9. [3Sum](#3sum)
10. [Container With Most Water](#container-with-most-water)
11. [Trapping Rain Water](#trapping-rain-water) ⭐
12. [Rotate Array](#rotate-array) ⭐

### Binary
13. [Sum of Two Integers](#sum-of-two-integers)
14. [Number of 1 Bits](#number-of-1-bits)
15. [Counting Bits](#counting-bits)
16. [Missing Number](#missing-number)
17. [Reverse Bits](#reverse-bits)

### Dynamic Programming
18. [Climbing Stairs](#climbing-stairs)
19. [Coin Change](#coin-change)
20. [Longest Increasing Subsequence](#longest-increasing-subsequence)
21. [Longest Common Subsequence](#longest-common-subsequence)
22. [Word Break](#word-break)
23. [Combination Sum](#combination-sum)
24. [House Robber](#house-robber)
25. [House Robber II](#house-robber-ii)
26. [Decode Ways](#decode-ways)
27. [Unique Paths](#unique-paths)
28. [Jump Game](#jump-game)
29. [Partition Equal Subset Sum](#partition-equal-subset-sum) ⭐
30. [Edit Distance](#edit-distance) ⭐

### Graph
31. [Clone Graph](#clone-graph)
32. [Course Schedule](#course-schedule)
33. [Pacific Atlantic Water Flow](#pacific-atlantic-water-flow)
34. [Number of Islands](#number-of-islands)
35. [Longest Consecutive Sequence](#longest-consecutive-sequence)
36. [Rotting Oranges](#rotting-oranges) ⭐
37. [Word Ladder](#word-ladder) ⭐

### Interval
38. [Insert Interval](#insert-interval)
39. [Merge Intervals](#merge-intervals)
40. [Non-overlapping Intervals](#non-overlapping-intervals)

### Linked List
41. [Reverse Linked List](#reverse-linked-list)
42. [Detect Cycle in Linked List](#detect-cycle-in-linked-list)
43. [Merge Two Sorted Lists](#merge-two-sorted-lists)
44. [Merge K Sorted Lists](#merge-k-sorted-lists)
45. [Remove Nth Node From End](#remove-nth-node-from-end)
46. [Reorder List](#reorder-list)
47. [Copy List with Random Pointer](#copy-list-with-random-pointer) ⭐

### Matrix
48. [Set Matrix Zeroes](#set-matrix-zeroes)
49. [Spiral Matrix](#spiral-matrix)
50. [Rotate Image](#rotate-image)
51. [Word Search](#word-search)

### String
52. [Longest Substring Without Repeating Characters](#longest-substring-without-repeating-characters)
53. [Longest Repeating Character Replacement](#longest-repeating-character-replacement)
54. [Minimum Window Substring](#minimum-window-substring)
55. [Valid Anagram](#valid-anagram)
56. [Group Anagrams](#group-anagrams)
57. [Valid Parentheses](#valid-parentheses)
58. [Valid Palindrome](#valid-palindrome)
59. [Longest Palindromic Substring](#longest-palindromic-substring)
60. [Palindromic Substrings](#palindromic-substrings)

### Tree
61. [Maximum Depth of Binary Tree](#maximum-depth-of-binary-tree)
62. [Same Tree](#same-tree)
63. [Invert Binary Tree](#invert-binary-tree)
64. [Binary Tree Maximum Path Sum](#binary-tree-maximum-path-sum)
65. [Binary Tree Level Order Traversal](#binary-tree-level-order-traversal)
66. [Serialize and Deserialize Binary Tree](#serialize-and-deserialize-binary-tree)
67. [Subtree of Another Tree](#subtree-of-another-tree)
68. [Construct Binary Tree from Preorder and Inorder](#construct-binary-tree-from-preorder-and-inorder)
69. [Validate Binary Search Tree](#validate-binary-search-tree)
70. [Kth Smallest Element in BST](#kth-smallest-element-in-bst)
71. [Lowest Common Ancestor of BST](#lowest-common-ancestor-of-bst)
72. [Implement Trie](#implement-trie)
73. [Add and Search Word](#add-and-search-word)
74. [Word Search II](#word-search-ii)
75. [Binary Tree Right Side View](#binary-tree-right-side-view) ⭐

### Heap
76. [Top K Frequent Elements](#top-k-frequent-elements)
77. [Find Median from Data Stream](#find-median-from-data-stream)
78. [Kth Largest Element in Array](#kth-largest-element-in-array) ⭐

### Backtracking
79. [Permutations](#permutations) ⭐
80. [Subsets](#subsets) ⭐
81. [Generate Parentheses](#generate-parentheses) ⭐

---

## Array

### Two Sum

**Brute Force - O(n²) time, O(1) space:**
```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        for (int i = 0; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                if (nums[j] == target - nums[i]) {
                    return new int[] { i, j };
                }
            }
        }
        // If no valid pair is found, return an empty array instead of null
        return new int[] {};
    }
}
```

**Optimal (Sliding Window) - O(n+m) time, O(m) space:**
```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();

        for (int i = 0; i < nums.length; i++) {
            int comp = target - nums[i];
            if (map.containsKey(comp)) {
                return new int[] { map.get(comp), i };
            }
            map.put(nums[i], i);

        }
        return new int[0];
    }
}
```

---

### Valid Anagram

**Brute Force (Sort) - O(n log n) time, O(n) space:**
```java
public boolean isAnagram(String s, String t) {
    if (s.length() != t.length()) return false;

    char[] sArr = s.toCharArray();
    char[] tArr = t.toCharArray();

    Arrays.sort(sArr);
    Arrays.sort(tArr);

    return Arrays.equals(sArr, tArr);
}
```

**Optimal (Frequency count) - O(n) time, O(1) space:**
```java
public boolean isAnagram(String s, String t) {
    if (s.length() != t.length()) return false;

    int[] count = new int[26];

    for (int i = 0; i < s.length(); i++) {
        count[s.charAt(i) - 'a']++;
        count[t.charAt(i) - 'a']--;
    }

    for (int c : count) {
        if (c != 0) return false;
    }

    return true;
}
```

---

### Group Anagrams

**Brute Force - O(n²*k) time, O(n*k) space:**
```java
public List<List<String>> groupAnagrams(String[] strs) {
    List<List<String>> result = new ArrayList<>();
    boolean[] used = new boolean[strs.length];

    for (int i = 0; i < strs.length; i++) {
        if (used[i]) continue;

        List<String> group = new ArrayList<>();
        group.add(strs[i]);
        used[i] = true;

        for (int j = i + 1; j < strs.length; j++) {
            if (!used[j] && isAnagram(strs[i], strs[j])) {
                group.add(strs[j]);
                used[j] = true;
            }
        }

        result.add(group);
    }

    return result;
}

private boolean isAnagram(String s, String t) {
    if (s.length() != t.length()) return false;
    int[] count = new int[26];
    for (int i = 0; i < s.length(); i++) {
        count[s.charAt(i) - 'a']++;
        count[t.charAt(i) - 'a']--;
    }
    for (int c : count) {
        if (c != 0) return false;
    }
    return true;
}
```

**Optimal (HashMap with sorted key) - O(n*k*log k) time, O(n*k) space:**
```java
public List<List<String>> groupAnagrams(String[] strs) {
    Map<String, List<String>> map = new HashMap<>();

    for (String str : strs) {
        char[] chars = str.toCharArray();
        Arrays.sort(chars);
        String key = new String(chars);

        map.computeIfAbsent(key, k -> new ArrayList<>()).add(str);
    }

    return new ArrayList<>(map.values());
}
```

---

### Valid Parentheses

**Brute Force (Replace pairs) - O(n²) time, O(n) space:**
```java
public boolean isValid(String s) {
    while (s.contains("()") || s.contains("[]") || s.contains("{}")) {
        s = s.replace("()", "");
        s = s.replace("[]", "");
        s = s.replace("{}", "");
    }
    return s.isEmpty();
}
```

**Optimal (Stack) - O(n) time, O(n) space:**
```java
public boolean isValid(String s) {
    Stack<Character> stack = new Stack<>();

    for (char c : s.toCharArray()) {
        if (c == '(' || c == '[' || c == '{') {
            stack.push(c);
        } else {
            if (stack.isEmpty()) return false;

            char top = stack.pop();
            if (c == ')' && top != '(') return false;
            if (c == ']' && top != '[') return false;
            if (c == '}' && top != '{') return false;
        }
    }

    return stack.isEmpty();
}
```

---

### Valid Palindrome

**Brute Force (Create filtered string) - O(n) time, O(n) space:**
```java
public boolean isPalindrome(String s) {
    StringBuilder sb = new StringBuilder();

    for (char c : s.toCharArray()) {
        if (Character.isLetterOrDigit(c)) {
            sb.append(Character.toLowerCase(c));
        }
    }

    String filtered = sb.toString();
    String reversed = sb.reverse().toString();

    return filtered.equals(reversed);
}
```

**Optimal (Two pointers) - O(n) time, O(1) space:**
```java
public boolean isPalindrome(String s) {
    int left = 0, right = s.length() - 1;

    while (left < right) {
        while (left < right && !Character.isLetterOrDigit(s.charAt(left))) {
            left++;
        }

        while (left < right && !Character.isLetterOrDigit(s.charAt(right))) {
            right--;
        }

        if (Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right))) {
            return false;
        }

        left++;
        right--;
    }

    return true;
}
```

---

### Longest Palindromic Substring

**Brute Force - O(n³) time, O(1) space:**
```java
public String longestPalindrome(String s) {
    String longest = "";

    for (int i = 0; i < s.length(); i++) {
        for (int j = i; j < s.length(); j++) {
            String sub = s.substring(i, j + 1);
            if (isPalindrome(sub) && sub.length() > longest.length()) {
                longest = sub;
            }
        }
    }

    return longest;
}

private boolean isPalindrome(String s) {
    int left = 0, right = s.length() - 1;
    while (left < right) {
        if (s.charAt(left++) != s.charAt(right--)) return false;
    }
    return true;
}
```

**Optimal (Expand around center) - O(n²) time, O(1) space:**
```java
public String longestPalindrome(String s) {
    if (s == null || s.length() < 1) return "";

    int start = 0, end = 0;

    for (int i = 0; i < s.length(); i++) {
        int len1 = expandAroundCenter(s, i, i);
        int len2 = expandAroundCenter(s, i, i + 1);
        int len = Math.max(len1, len2);

        if (len > end - start) {
            start = i - (len - 1) / 2;
            end = i + len / 2;
        }
    }

    return s.substring(start, end + 1);
}

private int expandAroundCenter(String s, int left, int right) {
    while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
        left--;
        right++;
    }
    return right - left - 1;
}
```

---

### Palindromic Substrings

**Brute Force - O(n³) time, O(1) space:**
```java
public int countSubstrings(String s) {
    int count = 0;

    for (int i = 0; i < s.length(); i++) {
        for (int j = i; j < s.length(); j++) {
            if (isPalindrome(s, i, j)) {
                count++;
            }
        }
    }

    return count;
}

private boolean isPalindrome(String s, int start, int end) {
    while (start < end) {
        if (s.charAt(start++) != s.charAt(end--)) return false;
    }
    return true;
}
```

**Optimal (Expand around center) - O(n²) time, O(1) space:**
```java
public int countSubstrings(String s) {
    int count = 0;

    for (int i = 0; i < s.length(); i++) {
        count += expandAroundCenter(s, i, i);
        count += expandAroundCenter(s, i, i + 1);
    }

    return count;
}

private int expandAroundCenter(String s, int left, int right) {
    int count = 0;

    while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
        count++;
        left--;
        right++;
    }

    return count;
}
```

---

## Tree

### Maximum Depth of Binary Tree

**Brute Force (DFS) - O(n) time, O(h) space:**
```java
public int maxDepth(TreeNode root) {
    if (root == null) return 0;
    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
}
```

**Optimal (BFS) - O(n) time, O(w) space:**
```java
public int maxDepth(TreeNode root) {
    if (root == null) return 0;

    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    int depth = 0;

    while (!queue.isEmpty()) {
        int size = queue.size();

        for (int i = 0; i < size; i++) {
            TreeNode node = queue.poll();
            if (node.left != null) queue.offer(node.left);
            if (node.right != null) queue.offer(node.right);
        }

        depth++;
    }

    return depth;
}
```

---

### Same Tree

**Brute Force (DFS) - O(n) time, O(h) space:**
```java
public boolean isSameTree(TreeNode p, TreeNode q) {
    if (p == null && q == null) return true;
    if (p == null || q == null) return false;
    if (p.val != q.val) return false;

    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
}
```

**Optimal (BFS) - O(n) time, O(w) space:**
```java
public boolean isSameTree(TreeNode p, TreeNode q) {
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(p);
    queue.offer(q);

    while (!queue.isEmpty()) {
        TreeNode node1 = queue.poll();
        TreeNode node2 = queue.poll();

        if (node1 == null && node2 == null) continue;
        if (node1 == null || node2 == null) return false;
        if (node1.val != node2.val) return false;

        queue.offer(node1.left);
        queue.offer(node2.left);
        queue.offer(node1.right);
        queue.offer(node2.right);
    }

    return true;
}
```

---

### Invert Binary Tree

**Brute Force (DFS) - O(n) time, O(h) space:**
```java
public TreeNode invertTree(TreeNode root) {
    if (root == null) return null;

    TreeNode left = invertTree(root.left);
    TreeNode right = invertTree(root.right);

    root.left = right;
    root.right = left;

    return root;
}
```

**Optimal (BFS) - O(n) time, O(w) space:**
```java
public TreeNode invertTree(TreeNode root) {
    if (root == null) return null;

    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);

    while (!queue.isEmpty()) {
        TreeNode node = queue.poll();

        TreeNode temp = node.left;
        node.left = node.right;
        node.right = temp;

        if (node.left != null) queue.offer(node.left);
        if (node.right != null) queue.offer(node.right);
    }

    return root;
}
```

---

### Binary Tree Maximum Path Sum

**Brute Force (Check all paths) - O(n²) time, O(h) space:**
```java
private int maxSum = Integer.MIN_VALUE;

public int maxPathSum(TreeNode root) {
    getAllPaths(root, 0);
    return maxSum;
}

private void getAllPaths(TreeNode node, int currentSum) {
    if (node == null) return;

    currentSum += node.val;
    maxSum = Math.max(maxSum, currentSum);

    getAllPaths(node.left, currentSum);
    getAllPaths(node.right, currentSum);
    getAllPaths(node.left, node.val);
    getAllPaths(node.right, node.val);
}
```

**Optimal (DFS with global max) - O(n) time, O(h) space:**
```java
private int maxSum = Integer.MIN_VALUE;

public int maxPathSum(TreeNode root) {
    maxPathSumHelper(root);
    return maxSum;
}

private int maxPathSumHelper(TreeNode node) {
    if (node == null) return 0;

    int left = Math.max(0, maxPathSumHelper(node.left));
    int right = Math.max(0, maxPathSumHelper(node.right));

    maxSum = Math.max(maxSum, left + right + node.val);

    return node.val + Math.max(left, right);
}
```

---

### Binary Tree Level Order Traversal

**Brute Force (DFS with level tracking) - O(n) time, O(n) space:**
```java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> result = new ArrayList<>();
    dfs(root, 0, result);
    return result;
}

private void dfs(TreeNode node, int level, List<List<Integer>> result) {
    if (node == null) return;

    if (result.size() == level) {
        result.add(new ArrayList<>());
    }

    result.get(level).add(node.val);
    dfs(node.left, level + 1, result);
    dfs(node.right, level + 1, result);
}
```

**Optimal (BFS) - O(n) time, O(w) space:**
```java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> result = new ArrayList<>();
    if (root == null) return result;

    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);

    while (!queue.isEmpty()) {
        int size = queue.size();
        List<Integer> level = new ArrayList<>();

        for (int i = 0; i < size; i++) {
            TreeNode node = queue.poll();
            level.add(node.val);

            if (node.left != null) queue.offer(node.left);
            if (node.right != null) queue.offer(node.right);
        }

        result.add(level);
    }

    return result;
}
```

---

### Serialize and Deserialize Binary Tree

**Brute Force (Level order with nulls) - O(n) time, O(n) space:**
```java
public String serialize(TreeNode root) {
    if (root == null) return "null";

    StringBuilder sb = new StringBuilder();
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);

    while (!queue.isEmpty()) {
        TreeNode node = queue.poll();

        if (node == null) {
            sb.append("null,");
        } else {
            sb.append(node.val).append(",");
            queue.offer(node.left);
            queue.offer(node.right);
        }
    }

    return sb.toString();
}

public TreeNode deserialize(String data) {
    if (data.equals("null")) return null;

    String[] values = data.split(",");
    TreeNode root = new TreeNode(Integer.parseInt(values[0]));
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);

    int i = 1;
    while (!queue.isEmpty() && i < values.length) {
        TreeNode node = queue.poll();

        if (!values[i].equals("null")) {
            node.left = new TreeNode(Integer.parseInt(values[i]));
            queue.offer(node.left);
        }
        i++;

        if (i < values.length && !values[i].equals("null")) {
            node.right = new TreeNode(Integer.parseInt(values[i]));
            queue.offer(node.right);
        }
        i++;
    }

    return root;
}
```

**Optimal (Preorder DFS) - O(n) time, O(n) space:**
```java
public String serialize(TreeNode root) {
    StringBuilder sb = new StringBuilder();
    serializeHelper(root, sb);
    return sb.toString();
}

private void serializeHelper(TreeNode node, StringBuilder sb) {
    if (node == null) {
        sb.append("null,");
        return;
    }

    sb.append(node.val).append(",");
    serializeHelper(node.left, sb);
    serializeHelper(node.right, sb);
}

public TreeNode deserialize(String data) {
    Queue<String> queue = new LinkedList<>(Arrays.asList(data.split(",")));
    return deserializeHelper(queue);
}

private TreeNode deserializeHelper(Queue<String> queue) {
    String val = queue.poll();

    if (val.equals("null")) return null;

    TreeNode node = new TreeNode(Integer.parseInt(val));
    node.left = deserializeHelper(queue);
    node.right = deserializeHelper(queue);

    return node;
}
```

---

### Subtree of Another Tree

**Brute Force - O(m*n) time, O(h) space:**
```java
public boolean isSubtree(TreeNode root, TreeNode subRoot) {
    if (root == null) return false;

    if (isSameTree(root, subRoot)) return true;

    return isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);
}

private boolean isSameTree(TreeNode p, TreeNode q) {
    if (p == null && q == null) return true;
    if (p == null || q == null) return false;
    if (p.val != q.val) return false;

    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
}
```

**Optimal (Serialize and compare) - O(m+n) time, O(m+n) space:**
```java
public boolean isSubtree(TreeNode root, TreeNode subRoot) {
    String tree1 = serialize(root);
    String tree2 = serialize(subRoot);

    return tree1.contains(tree2);
}

private String serialize(TreeNode node) {
    if (node == null) return "#";

    return "^" + node.val + " " + serialize(node.left) + " " + serialize(node.right);
}
```

---

### Construct Binary Tree from Preorder and Inorder

**Brute Force - O(n²) time, O(n) space:**
```java
public TreeNode buildTree(int[] preorder, int[] inorder) {
    if (preorder.length == 0) return null;

    int rootVal = preorder[0];
    TreeNode root = new TreeNode(rootVal);

    int rootIndex = 0;
    for (int i = 0; i < inorder.length; i++) {
        if (inorder[i] == rootVal) {
            rootIndex = i;
            break;
        }
    }

    root.left = buildTree(
        Arrays.copyOfRange(preorder, 1, rootIndex + 1),
        Arrays.copyOfRange(inorder, 0, rootIndex)
    );

    root.right = buildTree(
        Arrays.copyOfRange(preorder, rootIndex + 1, preorder.length),
        Arrays.copyOfRange(inorder, rootIndex + 1, inorder.length)
    );

    return root;
}
```

**Optimal (HashMap for indices) - O(n) time, O(n) space:**
```java
private int preIndex = 0;
private Map<Integer, Integer> inMap = new HashMap<>();

public TreeNode buildTree(int[] preorder, int[] inorder) {
    for (int i = 0; i < inorder.length; i++) {
        inMap.put(inorder[i], i);
    }

    return buildTreeHelper(preorder, 0, inorder.length - 1);
}

private TreeNode buildTreeHelper(int[] preorder, int inStart, int inEnd) {
    if (inStart > inEnd) return null;

    int rootVal = preorder[preIndex++];
    TreeNode root = new TreeNode(rootVal);

    int inIndex = inMap.get(rootVal);

    root.left = buildTreeHelper(preorder, inStart, inIndex - 1);
    root.right = buildTreeHelper(preorder, inIndex + 1, inEnd);

    return root;
}
```

---

### Validate Binary Search Tree

**Brute Force (Inorder traversal) - O(n) time, O(n) space:**
```java
public boolean isValidBST(TreeNode root) {
    List<Integer> inorder = new ArrayList<>();
    inorderTraversal(root, inorder);

    for (int i = 1; i < inorder.size(); i++) {
        if (inorder.get(i) <= inorder.get(i - 1)) {
            return false;
        }
    }

    return true;
}

private void inorderTraversal(TreeNode node, List<Integer> list) {
    if (node == null) return;

    inorderTraversal(node.left, list);
    list.add(node.val);
    inorderTraversal(node.right, list);
}
```

**Optimal (DFS with range) - O(n) time, O(h) space:**
```java
public boolean isValidBST(TreeNode root) {
    return validate(root, null, null);
}

private boolean validate(TreeNode node, Integer min, Integer max) {
    if (node == null) return true;

    if ((min != null && node.val <= min) || (max != null && node.val >= max)) {
        return false;
    }

    return validate(node.left, min, node.val) && validate(node.right, node.val, max);
}
```

---

### Kth Smallest Element in BST

**Brute Force (Inorder to list) - O(n) time, O(n) space:**
```java
public int kthSmallest(TreeNode root, int k) {
    List<Integer> inorder = new ArrayList<>();
    inorderTraversal(root, inorder);
    return inorder.get(k - 1);
}

private void inorderTraversal(TreeNode node, List<Integer> list) {
    if (node == null) return;

    inorderTraversal(node.left, list);
    list.add(node.val);
    inorderTraversal(node.right, list);
}
```

**Optimal (Inorder with early termination) - O(k) time, O(h) space:**
```java
private int count = 0;
private int result = 0;

public int kthSmallest(TreeNode root, int k) {
    inorder(root, k);
    return result;
}

private void inorder(TreeNode node, int k) {
    if (node == null) return;

    inorder(node.left, k);

    count++;
    if (count == k) {
        result = node.val;
        return;
    }

    inorder(node.right, k);
}
```

---

### Lowest Common Ancestor of BST

**Brute Force (Find paths) - O(n) time, O(n) space:**
```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    List<TreeNode> pathP = new ArrayList<>();
    List<TreeNode> pathQ = new ArrayList<>();

    findPath(root, p, pathP);
    findPath(root, q, pathQ);

    TreeNode lca = null;
    for (int i = 0; i < Math.min(pathP.size(), pathQ.size()); i++) {
        if (pathP.get(i) == pathQ.get(i)) {
            lca = pathP.get(i);
        } else {
            break;
        }
    }

    return lca;
}

private boolean findPath(TreeNode node, TreeNode target, List<TreeNode> path) {
    if (node == null) return false;

    path.add(node);

    if (node == target) return true;

    if (node.val > target.val) {
        return findPath(node.left, target, path);
    } else {
        return findPath(node.right, target, path);
    }
}
```

**Optimal (BST property) - O(h) time, O(1) space:**
```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    while (root != null) {
        if (p.val < root.val && q.val < root.val) {
            root = root.left;
        } else if (p.val > root.val && q.val > root.val) {
            root = root.right;
        } else {
            return root;
        }
    }

    return null;
}
```

---

### Implement Trie

**Implementation - O(m) time per operation, O(n*m) space:**
```java
class TrieNode {
    TrieNode[] children = new TrieNode[26];
    boolean isEnd = false;
}

class Trie {
    private TrieNode root;

    public Trie() {
        root = new TrieNode();
    }

    public void insert(String word) {
        TrieNode node = root;

        for (char c : word.toCharArray()) {
            int index = c - 'a';
            if (node.children[index] == null) {
                node.children[index] = new TrieNode();
            }
            node = node.children[index];
        }

        node.isEnd = true;
    }

    public boolean search(String word) {
        TrieNode node = findNode(word);
        return node != null && node.isEnd;
    }

    public boolean startsWith(String prefix) {
        return findNode(prefix) != null;
    }

    private TrieNode findNode(String str) {
        TrieNode node = root;

        for (char c : str.toCharArray()) {
            int index = c - 'a';
            if (node.children[index] == null) {
                return null;
            }
            node = node.children[index];
        }

        return node;
    }
}
```

---

### Add and Search Word

**Brute Force (Store all words) - O(n*m) time, O(n*m) space:**
```java
class WordDictionary {
    private Set<String> words;

    public WordDictionary() {
        words = new HashSet<>();
    }

    public void addWord(String word) {
        words.add(word);
    }

    public boolean search(String word) {
        for (String w : words) {
            if (match(w, word)) return true;
        }
        return false;
    }

    private boolean match(String word, String pattern) {
        if (word.length() != pattern.length()) return false;

        for (int i = 0; i < word.length(); i++) {
            if (pattern.charAt(i) != '.' && pattern.charAt(i) != word.charAt(i)) {
                return false;
            }
        }
        return true;
    }
}
```

**Optimal (Trie with DFS) - O(m) average, O(26^m) worst time, O(n*m) space:**
```java
class WordDictionary {
    class TrieNode {
        TrieNode[] children = new TrieNode[26];
        boolean isEnd = false;
    }

    private TrieNode root;

    public WordDictionary() {
        root = new TrieNode();
    }

    public void addWord(String word) {
        TrieNode node = root;

        for (char c : word.toCharArray()) {
            int index = c - 'a';
            if (node.children[index] == null) {
                node.children[index] = new TrieNode();
            }
            node = node.children[index];
        }

        node.isEnd = true;
    }

    public boolean search(String word) {
        return searchHelper(word, 0, root);
    }

    private boolean searchHelper(String word, int index, TrieNode node) {
        if (index == word.length()) {
            return node.isEnd;
        }

        char c = word.charAt(index);

        if (c == '.') {
            for (TrieNode child : node.children) {
                if (child != null && searchHelper(word, index + 1, child)) {
                    return true;
                }
            }
            return false;
        } else {
            int i = c - 'a';
            if (node.children[i] == null) return false;
            return searchHelper(word, index + 1, node.children[i]);
        }
    }
}
```

---

### Word Search II

**Brute Force (Word Search for each word) - O(m*n*4^L*k) time, O(L) space:**
```java
public List<String> findWords(char[][] board, String[] words) {
    List<String> result = new ArrayList<>();

    for (String word : words) {
        if (exist(board, word)) {
            result.add(word);
        }
    }

    return result;
}

private boolean exist(char[][] board, String word) {
    for (int i = 0; i < board.length; i++) {
        for (int j = 0; j < board[0].length; j++) {
            if (dfs(board, word, i, j, 0)) {
                return true;
            }
        }
    }
    return false;
}

private boolean dfs(char[][] board, String word, int i, int j, int index) {
    if (index == word.length()) return true;

    if (i < 0 || i >= board.length || j < 0 || j >= board[0].length ||
        board[i][j] != word.charAt(index)) {
        return false;
    }

    char temp = board[i][j];
    board[i][j] = '#';

    boolean found = dfs(board, word, i + 1, j, index + 1) ||
                    dfs(board, word, i - 1, j, index + 1) ||
                    dfs(board, word, i, j + 1, index + 1) ||
                    dfs(board, word, i, j - 1, index + 1);

    board[i][j] = temp;
    return found;
}
```

**Optimal (Trie + DFS) - O(m*n*4^L) time, O(k*L) space:**
```java
class TrieNode {
    TrieNode[] children = new TrieNode[26];
    String word = null;
}

public List<String> findWords(char[][] board, String[] words) {
    List<String> result = new ArrayList<>();
    TrieNode root = buildTrie(words);

    for (int i = 0; i < board.length; i++) {
        for (int j = 0; j < board[0].length; j++) {
            dfs(board, i, j, root, result);
        }
    }

    return result;
}

private TrieNode buildTrie(String[] words) {
    TrieNode root = new TrieNode();

    for (String word : words) {
        TrieNode node = root;
        for (char c : word.toCharArray()) {
            int index = c - 'a';
            if (node.children[index] == null) {
                node.children[index] = new TrieNode();
            }
            node = node.children[index];
        }
        node.word = word;
    }

    return root;
}

private void dfs(char[][] board, int i, int j, TrieNode node, List<String> result) {
    if (i < 0 || i >= board.length || j < 0 || j >= board[0].length) return;

    char c = board[i][j];
    if (c == '#' || node.children[c - 'a'] == null) return;

    node = node.children[c - 'a'];

    if (node.word != null) {
        result.add(node.word);
        node.word = null; // Avoid duplicates
    }

    board[i][j] = '#';
    dfs(board, i + 1, j, node, result);
    dfs(board, i - 1, j, node, result);
    dfs(board, i, j + 1, node, result);
    dfs(board, i, j - 1, node, result);
    board[i][j] = c;
}
```

---

### Binary Tree Right Side View

**Brute Force (DFS with level tracking) - O(n) time, O(h) space:**
```java
public List<Integer> rightSideView(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    dfs(root, 0, result);
    return result;
}

private void dfs(TreeNode node, int level, List<Integer> result) {
    if (node == null) return;

    if (level == result.size()) {
        result.add(node.val);
    }

    dfs(node.right, level + 1, result);
    dfs(node.left, level + 1, result);
}
```

**Optimal (BFS) - O(n) time, O(w) space:**
```java
public List<Integer> rightSideView(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    if (root == null) return result;

    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);

    while (!queue.isEmpty()) {
        int size = queue.size();

        for (int i = 0; i < size; i++) {
            TreeNode node = queue.poll();

            if (i == size - 1) {
                result.add(node.val);
            }

            if (node.left != null) queue.offer(node.left);
            if (node.right != null) queue.offer(node.right);
        }
    }

    return result;
}
```

---

## Heap

### Top K Frequent Elements

**Brute Force (Sort by frequency) - O(n log n) time, O(n) space:**
```java
public int[] topKFrequent(int[] nums, int k) {
    Map<Integer, Integer> count = new HashMap<>();

    for (int num : nums) {
        count.put(num, count.getOrDefault(num, 0) + 1);
    }

    List<Map.Entry<Integer, Integer>> entries = new ArrayList<>(count.entrySet());
    entries.sort((a, b) -> b.getValue() - a.getValue());

    int[] result = new int[k];
    for (int i = 0; i < k; i++) {
        result[i] = entries.get(i).getKey();
    }

    return result;
}
```

**Optimal (Min Heap) - O(n log k) time, O(n) space:**
```java
public int[] topKFrequent(int[] nums, int k) {
    Map<Integer, Integer> count = new HashMap<>();

    for (int num : nums) {
        count.put(num, count.getOrDefault(num, 0) + 1);
    }

    PriorityQueue<Map.Entry<Integer, Integer>> pq =
        new PriorityQueue<>((a, b) -> a.getValue() - b.getValue());

    for (Map.Entry<Integer, Integer> entry : count.entrySet()) {
        pq.offer(entry);
        if (pq.size() > k) {
            pq.poll();
        }
    }

    int[] result = new int[k];
    for (int i = 0; i < k; i++) {
        result[i] = pq.poll().getKey();
    }

    return result;
}
```

---

### Find Median from Data Stream

**Brute Force (Sort every time) - O(n log n) per find, O(n) space:**
```java
class MedianFinder {
    private List<Integer> nums;

    public MedianFinder() {
        nums = new ArrayList<>();
    }

    public void addNum(int num) {
        nums.add(num);
    }

    public double findMedian() {
        Collections.sort(nums);
        int n = nums.size();

        if (n % 2 == 0) {
            return (nums.get(n / 2 - 1) + nums.get(n / 2)) / 2.0;
        } else {
            return nums.get(n / 2);
        }
    }
}
```

**Optimal (Two Heaps) - O(log n) per operation, O(n) space:**
```java
class MedianFinder {
    private PriorityQueue<Integer> maxHeap; // Lower half
    private PriorityQueue<Integer> minHeap; // Upper half

    public MedianFinder() {
        maxHeap = new PriorityQueue<>((a, b) -> b - a);
        minHeap = new PriorityQueue<>();
    }

    public void addNum(int num) {
        maxHeap.offer(num);
        minHeap.offer(maxHeap.poll());

        if (maxHeap.size() < minHeap.size()) {
            maxHeap.offer(minHeap.poll());
        }
    }

    public double findMedian() {
        if (maxHeap.size() > minHeap.size()) {
            return maxHeap.peek();
        } else {
            return (maxHeap.peek() + minHeap.peek()) / 2.0;
        }
    }
}
```

---

### Kth Largest Element in Array

**Brute Force (Sort) - O(n log n) time, O(1) space:**
```java
public int findKthLargest(int[] nums, int k) {
    Arrays.sort(nums);
    return nums[nums.length - k];
}
```

**Optimal (Min Heap) - O(n log k) time, O(k) space:**
```java
public int findKthLargest(int[] nums, int k) {
    PriorityQueue<Integer> pq = new PriorityQueue<>();

    for (int num : nums) {
        pq.offer(num);
        if (pq.size() > k) {
            pq.poll();
        }
    }

    return pq.peek();
}
```

**Best (QuickSelect) - O(n) average time, O(1) space:**
```java
public int findKthLargest(int[] nums, int k) {
    return quickSelect(nums, 0, nums.length - 1, nums.length - k);
}

private int quickSelect(int[] nums, int left, int right, int k) {
    if (left == right) return nums[left];

    int pivotIndex = partition(nums, left, right);

    if (k == pivotIndex) {
        return nums[k];
    } else if (k < pivotIndex) {
        return quickSelect(nums, left, pivotIndex - 1, k);
    } else {
        return quickSelect(nums, pivotIndex + 1, right, k);
    }
}

private int partition(int[] nums, int left, int right) {
    int pivot = nums[right];
    int i = left;

    for (int j = left; j < right; j++) {
        if (nums[j] < pivot) {
            swap(nums, i, j);
            i++;
        }
    }

    swap(nums, i, right);
    return i;
}

private void swap(int[] nums, int i, int j) {
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}
```

---

## Backtracking

### Permutations

**Brute Force (Generate all and filter) - O(n! * n²) time, O(n!) space:**
```java
public List<List<Integer>> permute(int[] nums) {
    List<List<Integer>> result = new ArrayList<>();
    generatePermutations(nums, new ArrayList<>(), new boolean[nums.length], result);
    return result;
}

private void generatePermutations(int[] nums, List<Integer> current,
                                  boolean[] used, List<List<Integer>> result) {
    if (current.size() == nums.length) {
        result.add(new ArrayList<>(current));
        return;
    }

    for (int i = 0; i < nums.length; i++) {
        if (used[i]) continue;

        current.add(nums[i]);
        used[i] = true;
        generatePermutations(nums, current, used, result);
        current.remove(current.size() - 1);
        used[i] = false;
    }
}
```

**Optimal (Backtracking with swap) - O(n!) time, O(n) space:**
```java
public List<List<Integer>> permute(int[] nums) {
    List<List<Integer>> result = new ArrayList<>();
    backtrack(nums, 0, result);
    return result;
}

private void backtrack(int[] nums, int start, List<List<Integer>> result) {
    if (start == nums.length) {
        List<Integer> perm = new ArrayList<>();
        for (int num : nums) {
            perm.add(num);
        }
        result.add(perm);
        return;
    }

    for (int i = start; i < nums.length; i++) {
        swap(nums, start, i);
        backtrack(nums, start + 1, result);
        swap(nums, start, i);
    }
}

private void swap(int[] nums, int i, int j) {
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}
```

---

### Subsets

**Brute Force (Iterative) - O(n * 2^n) time, O(2^n) space:**
```java
public List<List<Integer>> subsets(int[] nums) {
    List<List<Integer>> result = new ArrayList<>();
    result.add(new ArrayList<>());

    for (int num : nums) {
        int size = result.size();
        for (int i = 0; i < size; i++) {
            List<Integer> subset = new ArrayList<>(result.get(i));
            subset.add(num);
            result.add(subset);
        }
    }

    return result;
}
```

**Optimal (Backtracking) - O(n * 2^n) time, O(n) space:**
```java
public List<List<Integer>> subsets(int[] nums) {
    List<List<Integer>> result = new ArrayList<>();
    backtrack(nums, 0, new ArrayList<>(), result);
    return result;
}

private void backtrack(int[] nums, int start, List<Integer> current,
                      List<List<Integer>> result) {
    result.add(new ArrayList<>(current));

    for (int i = start; i < nums.length; i++) {
        current.add(nums[i]);
        backtrack(nums, i + 1, current, result);
        current.remove(current.size() - 1);
    }
}
```

---

### Generate Parentheses

**Brute Force (Generate all and validate) - O(2^(2n) * n) time, O(2^(2n)) space:**
```java
public List<String> generateParenthesis(int n) {
    List<String> result = new ArrayList<>();
    generateAll(new char[2 * n], 0, result);
    return result;
}

private void generateAll(char[] current, int pos, List<String> result) {
    if (pos == current.length) {
        if (isValid(current)) {
            result.add(new String(current));
        }
        return;
    }

    current[pos] = '(';
    generateAll(current, pos + 1, result);
    current[pos] = ')';
    generateAll(current, pos + 1, result);
}

private boolean isValid(char[] current) {
    int balance = 0;
    for (char c : current) {
        if (c == '(') balance++;
        else balance--;
        if (balance < 0) return false;
    }
    return balance == 0;
}
```

**Optimal (Backtracking with constraints) - O(4^n / sqrt(n)) time, O(n) space:**
```java
public List<String> generateParenthesis(int n) {
    List<String> result = new ArrayList<>();
    backtrack(result, new StringBuilder(), 0, 0, n);
    return result;
}

private void backtrack(List<String> result, StringBuilder current,
                      int open, int close, int max) {
    if (current.length() == max * 2) {
        result.add(current.toString());
        return;
    }

    if (open < max) {
        current.append('(');
        backtrack(result, current, open + 1, close, max);
        current.deleteCharAt(current.length() - 1);
    }

    if (close < open) {
        current.append(')');
        backtrack(result, current, open, close + 1, max);
        current.deleteCharAt(current.length() - 1);
    }
}
```

---

## Complexity Summary

| Category | Problem | Brute Force | Optimal |
|----------|---------|-------------|---------|
| Array | Two Sum | O(n²) | O(n) |
| Array | Best Time to Buy/Sell | O(n²) | O(n) |
| Array | Maximum Subarray | O(n²) | O(n) |
| Binary | Sum of Two Integers | N/A | O(1) |
| DP | Climbing Stairs | O(2^n) | O(n) |
| DP | Coin Change | O(S^n) | O(n*amount) |
| DP | LIS | O(2^n) | O(n log n) |
| Graph | Clone Graph | O(V+E) | O(V+E) |
| Graph | Number of Islands | O(m*n) | O(m*n) |
| Linked List | Reverse List | O(n), O(n) space | O(n), O(1) space |
| Linked List | Merge K Lists | O(k²*n) | O(n*k*log k) |
| String | Longest Substring | O(n³) | O(n) |
| String | Min Window Substring | O(n²*m) | O(n+m) |
| Tree | Max Depth | O(n) | O(n) |
| Tree | Validate BST | O(n), O(n) space | O(n), O(h) space |
| Heap | Top K Frequent | O(n log n) | O(n log k) |
| Heap | Find Median | O(n log n) | O(log n) |

---

## Tips for Each Category

### Array
- Use two pointers for sorted array problems
- Kadane's algorithm for maximum subarray
- HashMap for O(1) lookup

### Binary
- XOR for finding missing/duplicate numbers
- Bit manipulation to avoid arithmetic operators
- Brian Kernighan's algorithm for counting bits

### Dynamic Programming
- Identify overlapping subproblems
- Build bottom-up to avoid recursion overhead
- Use space optimization (rolling array)

### Graph
- BFS for shortest path in unweighted graphs
- DFS for connectivity and cycle detection
- Use colors/states to detect cycles

### Linked List
- Use dummy node to handle edge cases
- Floyd's cycle detection (fast/slow pointers)
- Reverse in-place to save space

### String
- Sliding window for substring problems
- HashMap for character frequency
- Two pointers for palindrome checks

### Tree
- Recursion for most tree problems
- BFS for level-order traversal
- Validate BST with range constraints

### Heap
- Min heap for K largest elements
- Two heaps for median finding
- Use heap to maintain top K elements

### Backtracking
- Add constraints to prune search space
- Use visited set to avoid cycles
- Restore state after recursive calls
