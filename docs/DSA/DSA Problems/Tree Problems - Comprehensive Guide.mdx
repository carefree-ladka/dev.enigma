# Tree Problems - Comprehensive Guide
## Binary Tree | BST | N-ary Tree

## Table of Contents

1. [Tree Traversal](#1-tree-traversal)
2. [Tree Construction](#2-tree-construction)
3. [Tree Properties](#3-tree-properties)
4. [Path Problems](#4-path-problems)
5. [Tree Modification](#5-tree-modification)
6. [Binary Search Tree (BST)](#6-binary-search-tree-bst)
7. [Lowest Common Ancestor (LCA)](#7-lowest-common-ancestor-lca)
8. [Tree Depth & Height](#8-tree-depth--height)
9. [Tree Views](#9-tree-views)
10. [Serialize & Deserialize](#10-serialize--deserialize)
11. [N-ary Tree](#11-n-ary-tree)
12. [Trie (Prefix Tree)](#12-trie-prefix-tree)
13. [Segment Tree & Binary Indexed Tree](#13-segment-tree--binary-indexed-tree)
14. [Advanced Tree Problems](#14-advanced-tree-problems)

---

## 1. Tree Traversal

### Depth First Search (DFS)

1. **[Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/)** - Left â†’ Root â†’ Right (iterative & recursive)
2. **[Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/)** - Root â†’ Left â†’ Right
3. **[Binary Tree Postorder Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal/)** - Left â†’ Right â†’ Root
4. **[Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/)** - BFS level by level
5. **[Binary Tree Level Order Traversal II](https://leetcode.com/problems/binary-tree-level-order-traversal-ii/)** - Bottom-up level order
6. **[Binary Tree Zigzag Level Order Traversal](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/)** - Alternate left-right direction
7. **[Vertical Order Traversal of a Binary Tree](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/)** - Column-wise traversal
8. **[Binary Tree Right Side View](https://leetcode.com/problems/binary-tree-right-side-view/)** - Rightmost node at each level
9. **[Binary Tree Left Side View](https://practice.geeksforgeeks.org/problems/left-view-of-binary-tree/)** - Leftmost node at each level
10. **[Boundary Traversal of Binary Tree](https://leetcode.com/problems/boundary-of-binary-tree/)** - Left boundary + leaves + right boundary
11. **[Diagonal Traversal of Binary Tree](https://practice.geeksforgeeks.org/problems/diagonal-traversal-of-binary-tree/)** - Traverse diagonally
12. **[Morris Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/)** - O(1) space traversal

### Breadth First Search (BFS)

13. **[Average of Levels in Binary Tree](https://leetcode.com/problems/average-of-levels-in-binary-tree/)** - Average value at each level
14. **[N-ary Tree Level Order Traversal](https://leetcode.com/problems/n-ary-tree-level-order-traversal/)** - Level order for n-ary tree
15. **[Maximum Width of Binary Tree](https://leetcode.com/problems/maximum-width-of-binary-tree/)** - Max width at any level
16. **[Find Largest Value in Each Tree Row](https://leetcode.com/problems/find-largest-value-in-each-tree-row/)** - Max value per level

---

## 2. Tree Construction

1. **[Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)** - Build tree from traversals
2. **[Construct Binary Tree from Inorder and Postorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)** - Build from inorder + postorder
3. **[Construct Binary Tree from Preorder and Postorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)** - Build from preorder + postorder
4. **[Convert Sorted Array to Binary Search Tree](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/)** - Create balanced BST
5. **[Convert Sorted List to Binary Search Tree](https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/)** - Linked list to BST
6. **[Construct String from Binary Tree](https://leetcode.com/problems/construct-string-from-binary-tree/)** - Tree to string with parentheses
7. **[Maximum Binary Tree](https://leetcode.com/problems/maximum-binary-tree/)** - Construct from array with max as root
8. **[Recover Binary Search Tree](https://leetcode.com/problems/recover-binary-search-tree/)** - Fix two swapped nodes in BST
9. **[All Possible Full Binary Trees](https://leetcode.com/problems/all-possible-full-binary-trees/)** - Generate all full binary trees
10. **[Unique Binary Search Trees II](https://leetcode.com/problems/unique-binary-search-trees-ii/)** - Generate all unique BSTs

---

## 3. Tree Properties

1. **[Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/)** - Height of tree
2. **[Minimum Depth of Binary Tree](https://leetcode.com/problems/minimum-depth-of-binary-tree/)** - Shortest path to leaf
3. **[Balanced Binary Tree](https://leetcode.com/problems/balanced-binary-tree/)** - Check if height-balanced
4. **[Symmetric Tree](https://leetcode.com/problems/symmetric-tree/)** - Check if tree is mirror of itself
5. **[Same Tree](https://leetcode.com/problems/same-tree/)** - Check if two trees are identical
6. **[Subtree of Another Tree](https://leetcode.com/problems/subtree-of-another-tree/)** - Check if subtree exists
7. **[Invert Binary Tree](https://leetcode.com/problems/invert-binary-tree/)** - Mirror/flip the tree
8. **[Diameter of Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree/)** - Longest path between any two nodes
9. **[Count Complete Tree Nodes](https://leetcode.com/problems/count-complete-tree-nodes/)** - Count nodes in complete tree
10. **[Sum of Left Leaves](https://leetcode.com/problems/sum-of-left-leaves/)** - Sum all left leaf values
11. **[Find Bottom Left Tree Value](https://leetcode.com/problems/find-bottom-left-tree-value/)** - Leftmost value in last row
12. **[Check Completeness of a Binary Tree](https://leetcode.com/problems/check-completeness-of-a-binary-tree/)** - Verify complete binary tree
13. **[Univalued Binary Tree](https://leetcode.com/problems/univalued-binary-tree/)** - Check if all nodes have same value
14. **[Cousins in Binary Tree](https://leetcode.com/problems/cousins-in-binary-tree/)** - Check if nodes are cousins
15. **[Leaf-Similar Trees](https://leetcode.com/problems/leaf-similar-trees/)** - Compare leaf sequences

---

## 4. Path Problems

1. **[Binary Tree Paths](https://leetcode.com/problems/binary-tree-paths/)** - Find all root-to-leaf paths
2. **[Path Sum](https://leetcode.com/problems/path-sum/)** - Check if root-to-leaf path sums to target
3. **[Path Sum II](https://leetcode.com/problems/path-sum-ii/)** - Find all root-to-leaf paths with target sum
4. **[Path Sum III](https://leetcode.com/problems/path-sum-iii/)** - Count paths with target sum (any start/end)
5. **[Binary Tree Maximum Path Sum](https://leetcode.com/problems/binary-tree-maximum-path-sum/)** - Maximum path sum between any two nodes
6. **[Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/)** - Sum all root-to-leaf numbers
7. **[Smallest String Starting From Leaf](https://leetcode.com/problems/smallest-string-starting-from-leaf/)** - Find lexicographically smallest string
8. **[Longest Univalue Path](https://leetcode.com/problems/longest-univalue-path/)** - Longest path with same values
9. **[Most Frequent Subtree Sum](https://leetcode.com/problems/most-frequent-subtree-sum/)** - Find most common subtree sum
10. **[Maximum Difference Between Node and Ancestor](https://leetcode.com/problems/maximum-difference-between-node-and-ancestor/)** - Max |ancestor.val - node.val|
11. **[Step-By-Step Directions From a Binary Tree Node to Another](https://leetcode.com/problems/step-by-step-directions-from-a-binary-tree-node-to-another/)** - Find path between nodes

---

## 5. Tree Modification

1. **[Flatten Binary Tree to Linked List](https://leetcode.com/problems/flatten-binary-tree-to-linked-list/)** - Convert to right-skewed list
2. **[Populating Next Right Pointers in Each Node](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/)** - Connect nodes at same level
3. **[Populating Next Right Pointers in Each Node II](https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/)** - Connect level (not perfect tree)
4. **[Delete Node in a BST](https://leetcode.com/problems/delete-node-in-a-bst/)** - Remove node from BST
5. **[Trim a Binary Search Tree](https://leetcode.com/problems/trim-a-binary-search-tree/)** - Trim BST to range [low, high]
6. **[Add One Row to Tree](https://leetcode.com/problems/add-one-row-to-tree/)** - Insert row at depth
7. **[Merge Two Binary Trees](https://leetcode.com/problems/merge-two-binary-trees/)** - Merge by summing overlapping nodes
8. **[Increasing Order Search Tree](https://leetcode.com/problems/increasing-order-search-tree/)** - Rearrange to right-skewed tree
9. **[Binary Tree Pruning](https://leetcode.com/problems/binary-tree-pruning/)** - Remove subtrees with all zeros
10. **[Delete Leaves With a Given Value](https://leetcode.com/problems/delete-leaves-with-a-given-value/)** - Remove leaf nodes with target value
11. **[Convert BST to Greater Tree](https://leetcode.com/problems/convert-bst-to-greater-tree/)** - Add greater values to each node

---

## 6. Binary Search Tree (BST)

### Basic BST Operations

1. **[Search in a Binary Search Tree](https://leetcode.com/problems/search-in-a-binary-search-tree/)** - Find node in BST
2. **[Insert into a Binary Search Tree](https://leetcode.com/problems/insert-into-a-binary-search-tree/)** - Add node to BST
3. **[Delete Node in a BST](https://leetcode.com/problems/delete-node-in-a-bst/)** - Remove node from BST
4. **[Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/)** - Check if valid BST
5. **[Minimum Absolute Difference in BST](https://leetcode.com/problems/minimum-absolute-difference-in-bst/)** - Min diff between any two nodes
6. **[Range Sum of BST](https://leetcode.com/problems/range-sum-of-bst/)** - Sum of values in range [low, high]

### BST Properties

7. **[Kth Smallest Element in a BST](https://leetcode.com/problems/kth-smallest-element-in-a-bst/)** - Find kth smallest value
8. **[Two Sum IV - Input is a BST](https://leetcode.com/problems/two-sum-iv-input-is-a-bst/)** - Find two nodes that sum to target
9. **[Find Mode in Binary Search Tree](https://leetcode.com/problems/find-mode-in-binary-search-tree/)** - Find most frequent values
10. **[Closest Binary Search Tree Value](https://leetcode.com/problems/closest-binary-search-tree-value/)** - Find closest value to target
11. **[Inorder Successor in BST](https://leetcode.com/problems/inorder-successor-in-bst/)** - Find next node in inorder
12. **[Inorder Predecessor in BST](https://practice.geeksforgeeks.org/problems/predecessor-and-successor/)** - Find previous node in inorder

### BST Conversion & Construction

13. **[Convert Sorted Array to Binary Search Tree](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/)** - Array to balanced BST
14. **[Convert BST to Greater Tree](https://leetcode.com/problems/convert-bst-to-greater-tree/)** - Add greater values
15. **[Balance a Binary Search Tree](https://leetcode.com/problems/balance-a-binary-search-tree/)** - Convert to balanced BST
16. **[Recover Binary Search Tree](https://leetcode.com/problems/recover-binary-search-tree/)** - Fix two swapped nodes
17. **[Unique Binary Search Trees](https://leetcode.com/problems/unique-binary-search-trees/)** - Count structurally unique BSTs
18. **[Unique Binary Search Trees II](https://leetcode.com/problems/unique-binary-search-trees-ii/)** - Generate all unique BSTs
19. **[Binary Search Tree to Greater Sum Tree](https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/)** - Transform BST

### Advanced BST

20. **[Contains Duplicate III](https://leetcode.com/problems/contains-duplicate-iii/)** - Use BST for sliding window
21. **[Count of Smaller Numbers After Self](https://leetcode.com/problems/count-of-smaller-numbers-after-self/)** - BST-based solution
22. **[Maximum Sum BST in Binary Tree](https://leetcode.com/problems/maximum-sum-bst-in-binary-tree/)** - Find max sum BST subtree

---

## 7. Lowest Common Ancestor (LCA)

1. **[Lowest Common Ancestor of a Binary Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/)** - LCA in binary tree
2. **[Lowest Common Ancestor of a Binary Search Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)** - LCA in BST
3. **[Lowest Common Ancestor of Deepest Leaves](https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/)** - LCA of deepest nodes
4. **[Lowest Common Ancestor of a Binary Tree II](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-ii/)** - Nodes may not exist
5. **[Lowest Common Ancestor of a Binary Tree III](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iii/)** - With parent pointers
6. **[Lowest Common Ancestor of a Binary Tree IV](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iv/)** - LCA of multiple nodes

---

## 8. Tree Depth & Height

1. **[Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/)** - Tree height
2. **[Minimum Depth of Binary Tree](https://leetcode.com/problems/minimum-depth-of-binary-tree/)** - Shortest root-to-leaf path
3. **[Maximum Depth of N-ary Tree](https://leetcode.com/problems/maximum-depth-of-n-ary-tree/)** - N-ary tree height
4. **[Balanced Binary Tree](https://leetcode.com/problems/balanced-binary-tree/)** - Check balance using height
5. **[Diameter of Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree/)** - Longest path using heights
6. **[Binary Tree Tilt](https://leetcode.com/problems/binary-tree-tilt/)** - Sum of all tilts
7. **[All Nodes Distance K in Binary Tree](https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/)** - Nodes at distance K

---

## 9. Tree Views

1. **[Binary Tree Right Side View](https://leetcode.com/problems/binary-tree-right-side-view/)** - Right side view
2. **[Binary Tree Left Side View](https://practice.geeksforgeeks.org/problems/left-view-of-binary-tree/)** - Left side view
3. **[Binary Tree Top View](https://practice.geeksforgeeks.org/problems/top-view-of-binary-tree/)** - Top view
4. **[Binary Tree Bottom View](https://practice.geeksforgeeks.org/problems/bottom-view-of-binary-tree/)** - Bottom view
5. **[Vertical Order Traversal of a Binary Tree](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/)** - Vertical view
6. **[Boundary of Binary Tree](https://leetcode.com/problems/boundary-of-binary-tree/)** - Boundary traversal

---

## 10. Serialize & Deserialize

1. **[Serialize and Deserialize Binary Tree](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/)** - Encode/decode binary tree
2. **[Serialize and Deserialize BST](https://leetcode.com/problems/serialize-and-deserialize-bst/)** - Encode/decode BST
3. **[Serialize and Deserialize N-ary Tree](https://leetcode.com/problems/serialize-and-deserialize-n-ary-tree/)** - Encode/decode N-ary tree
4. **[Encode N-ary Tree to Binary Tree](https://leetcode.com/problems/encode-n-ary-tree-to-binary-tree/)** - Convert N-ary to binary
5. **[Find Duplicate Subtrees](https://leetcode.com/problems/find-duplicate-subtrees/)** - Find duplicate subtrees using serialization
6. **[Construct String from Binary Tree](https://leetcode.com/problems/construct-string-from-binary-tree/)** - Tree to string representation

---

## 11. N-ary Tree

1. **[N-ary Tree Preorder Traversal](https://leetcode.com/problems/n-ary-tree-preorder-traversal/)** - Preorder for N-ary
2. **[N-ary Tree Postorder Traversal](https://leetcode.com/problems/n-ary-tree-postorder-traversal/)** - Postorder for N-ary
3. **[N-ary Tree Level Order Traversal](https://leetcode.com/problems/n-ary-tree-level-order-traversal/)** - Level order for N-ary
4. **[Maximum Depth of N-ary Tree](https://leetcode.com/problems/maximum-depth-of-n-ary-tree/)** - Height of N-ary tree
5. **[Diameter of N-Ary Tree](https://leetcode.com/problems/diameter-of-n-ary-tree/)** - Longest path in N-ary tree
6. **[Clone N-ary Tree](https://leetcode.com/problems/clone-n-ary-tree/)** - Deep copy N-ary tree
7. **[Encode N-ary Tree to Binary Tree](https://leetcode.com/problems/encode-n-ary-tree-to-binary-tree/)** - Convert to binary tree
8. **[Serialize and Deserialize N-ary Tree](https://leetcode.com/problems/serialize-and-deserialize-n-ary-tree/)** - Encode/decode N-ary

---

## 12. Trie (Prefix Tree)

1. **[Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/)** - Basic trie implementation
2. **[Design Add and Search Words Data Structure](https://leetcode.com/problems/design-add-and-search-words-data-structure/)** - Trie with wildcard search
3. **[Word Search II](https://leetcode.com/problems/word-search-ii/)** - Find words in board using trie
4. **[Replace Words](https://leetcode.com/problems/replace-words/)** - Replace with shortest root
5. **[Longest Word in Dictionary](https://leetcode.com/problems/longest-word-in-dictionary/)** - Find longest word built one char at a time
6. **[Implement Magic Dictionary](https://leetcode.com/problems/implement-magic-dictionary/)** - Dictionary with one-char difference
7. **[Maximum XOR of Two Numbers in an Array](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/)** - Binary trie for XOR
8. **[Map Sum Pairs](https://leetcode.com/problems/map-sum-pairs/)** - Sum of values with prefix
9. **[Palindrome Pairs](https://leetcode.com/problems/palindrome-pairs/)** - Find palindrome pairs using trie
10. **[Stream of Characters](https://leetcode.com/problems/stream-of-characters/)** - Query stream with trie
11. **[Search Suggestions System](https://leetcode.com/problems/search-suggestions-system/)** - Autocomplete system
12. **[Word Break II](https://leetcode.com/problems/word-break-ii/)** - All word breaks using trie

---

## 13. Segment Tree & Binary Indexed Tree

### Segment Tree

1. **[Range Sum Query - Mutable](https://leetcode.com/problems/range-sum-query-mutable/)** - Segment tree for range sum
2. **[Count of Range Sum](https://leetcode.com/problems/count-of-range-sum/)** - Count ranges with sum in interval
3. **[Range Sum Query 2D - Mutable](https://leetcode.com/problems/range-sum-query-2d-mutable/)** - 2D segment tree
4. **[My Calendar I](https://leetcode.com/problems/my-calendar-i/)** - Interval scheduling
5. **[My Calendar II](https://leetcode.com/problems/my-calendar-ii/)** - Allow double booking
6. **[My Calendar III](https://leetcode.com/problems/my-calendar-iii/)** - Find max k-booking

### Binary Indexed Tree (Fenwick Tree)

7. **[Range Sum Query - Mutable](https://leetcode.com/problems/range-sum-query-mutable/)** - BIT for range sum
8. **[Count of Smaller Numbers After Self](https://leetcode.com/problems/count-of-smaller-numbers-after-self/)** - BIT solution
9. **[Reverse Pairs](https://leetcode.com/problems/reverse-pairs/)** - Count reverse pairs with BIT
10. **[Count of Range Sum](https://leetcode.com/problems/count-of-range-sum/)** - BIT-based solution

---

## 14. Advanced Tree Problems

1. **[Binary Tree Cameras](https://leetcode.com/problems/binary-tree-cameras/)** - Minimum cameras to monitor all nodes
2. **[House Robber III](https://leetcode.com/problems/house-robber-iii/)** - Rob houses in tree without adjacent
3. **[Distribute Coins in Binary Tree](https://leetcode.com/problems/distribute-coins-in-binary-tree/)** - Minimum moves to distribute coins
4. **[Vertical Order Traversal of a Binary Tree](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/)** - Complex sorting
5. **[All Nodes Distance K in Binary Tree](https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/)** - Find nodes at distance K
6. **[Sum of Distances in Tree](https://leetcode.com/problems/sum-of-distances-in-tree/)** - Sum distances from each node
7. **[Minimum Height Trees](https://leetcode.com/problems/minimum-height-trees/)** - Find tree centroids
8. **[Count Good Nodes in Binary Tree](https://leetcode.com/problems/count-good-nodes-in-binary-tree/)** - Count nodes with max on path
9. **[Linked List in Binary Tree](https://leetcode.com/problems/linked-list-in-binary-tree/)** - Check if linked list path exists
10. **[Delete Nodes And Return Forest](https://leetcode.com/problems/delete-nodes-and-return-forest/)** - Remove nodes and split tree
11. **[Maximum Difference Between Node and Ancestor](https://leetcode.com/problems/maximum-difference-between-node-and-ancestor/)** - Max |ancestor - node|
12. **[Insufficient Nodes in Root to Leaf Paths](https://leetcode.com/problems/insufficient-nodes-in-root-to-leaf-paths/)** - Remove paths below limit
13. **[Smallest Subtree with all the Deepest Nodes](https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/)** - Find smallest subtree
14. **[Maximum Level Sum of a Binary Tree](https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree/)** - Level with max sum
15. **[Time Needed to Inform All Employees](https://leetcode.com/problems/time-needed-to-inform-all-employees/)** - Tree propagation time

---

## Common Patterns & Techniques

### 1. **DFS Templates**

**Recursive DFS (Preorder)**
```python
def dfs(node):
    if not node:
        return
    # Process node
    dfs(node.left)
    dfs(node.right)
```

**Iterative DFS (Using Stack)**
```python
def dfs_iterative(root):
    if not root:
        return
    stack = [root]
    while stack:
        node = stack.pop()
        # Process node
        if node.right:
            stack.append(node.right)
        if node.left:
            stack.append(node.left)
```

### 2. **BFS Template**

```python
from collections import deque

def bfs(root):
    if not root:
        return
    queue = deque([root])
    while queue:
        level_size = len(queue)
        for _ in range(level_size):
            node = queue.popleft()
            # Process node
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
```

### 3. **BST Search Template**

```python
def search_bst(root, target):
    if not root or root.val == target:
        return root
    if target < root.val:
        return search_bst(root.left, target)
    return search_bst(root.right, target)
```

### 4. **Tree Height/Depth**

```python
def max_depth(root):
    if not root:
        return 0
    return 1 + max(max_depth(root.left), max_depth(root.right))
```

### 5. **Path Sum Pattern**

```python
def has_path_sum(root, target):
    if not root:
        return False
    if not root.left and not root.right:
        return root.val == target
    target -= root.val
    return has_path_sum(root.left, target) or has_path_sum(root.right, target)
```

### 6. **LCA Pattern**

```python
def lca(root, p, q):
    if not root or root == p or root == q:
        return root
    left = lca(root.left, p, q)
    right = lca(root.right, p, q)
    if left and right:
        return root
    return left or right
```

### 7. **Tree Construction Pattern**

```python
def build_tree(preorder, inorder):
    if not preorder:
        return None
    root = TreeNode(preorder[0])
    mid = inorder.index(root.val)
    root.left = build_tree(preorder[1:mid+1], inorder[:mid])
    root.right = build_tree(preorder[mid+1:], inorder[mid+1:])
    return root
```

---

## Practice Strategy

### **Phase 1: Fundamentals (Week 1-2)**
**Goal**: Master traversals and basic operations

**Topics**:
- All traversals (Inorder, Preorder, Postorder, Level Order)
- Basic properties (height, depth, symmetric, same tree)
- Simple path problems

**Key Problems**: 10-15 problems from sections 1, 3

---

### **Phase 2: BST Mastery (Week 3)**
**Goal**: Understand BST properties and operations

**Topics**:
- BST validation and search
- BST insertion and deletion
- Inorder successor/predecessor
- BST conversion

**Key Problems**: 15 problems from section 6

---

### **Phase 3: Intermediate Patterns (Week 4-5)**
**Goal**: Learn common patterns

**Topics**:
- Tree construction
- Path sum variants
- Tree modification
- LCA problems

**Key Problems**: 15-20 problems from sections 2, 4, 5, 7

---

### **Phase 4: Advanced Topics (Week 6-7)**
**Goal**: Handle complex scenarios

**Topics**:
- Serialize/Deserialize
- Tree views
- N-ary trees
- Complex manipulation

**Key Problems**: 15-20 problems from sections 9, 10, 11, 14

---

### **Phase 5: Specialized Trees (Week 8+)**
**Goal**: Master advanced data structures

**Topics**:
- Trie
- Segment Tree
- Binary Indexed Tree
- Advanced problems

**Key Problems**: 15-20 problems from sections 12, 13, 14

---

## Time & Space Complexity

### Common Operations

| Operation | Average | Worst | Space |
|-----------|---------|-------|-------|
| **Binary Tree** |
| Search | O(n) | O(n) | O(h) |
| Insertion | O(h) | O(n) | O(h) |
| Deletion | O(h) | O(n) | O(h) |
| Traversal | O(n) | O(n) | O(h) or O(n) |
| **BST** |
| Search | O(log n) | O(n) | O(h) |
| Insertion | O(log n) | O(n) | O(h) |
| Deletion | O(log n) | O(n) | O(h) |
| **Balanced BST (AVL/Red-Black)** |
| Search | O(log n) | O(log n) | O(h) |
| Insertion | O(log n) | O(log n) | O(h) |
| Deletion | O(log n) | O(log n) | O(h) |
| **Trie** |
| Search | O(m) | O(m) | O(alphabet_size * n * m) |
| Insert | O(m) | O(m) | O(alphabet_size * n * m) |
| Delete | O(m) | O(m) | O(alphabet_size * n * m) |
| **Segment Tree** |
| Build | O(n) | O(n) | O(n) |
| Query | O(log n) | O(log n) | O(log n) |
| Update | O(log n) | O(log n) | O(log n) |

*where h = height, n = number of nodes, m = length of key*

---

## Key Concepts & Tips

### Tree Traversal Summary

| Traversal | Order | Use Case |
|-----------|-------|----------|
| **Inorder** | Left â†’ Root â†’ Right | BST sorted order, expression trees |
| **Preorder** | Root â†’ Left â†’ Right | Create copy, prefix notation |
| **Postorder** | Left â†’ Right â†’ Root | Delete tree, postfix notation |
| **Level Order** | Level by level | BFS, shortest path, serialization |

### When to Use Which Traversal

- **Inorder**: BST operations, sorted output
- **Preorder**: Tree copy, serialization, prefix expressions
- **Postorder**: Tree deletion, calculating values, postfix
- **Level Order**: Level-wise operations, shortest path

### BST Properties to Remember

1. **Inorder traversal gives sorted sequence**
2. **Left subtree < Root < Right subtree** (for all nodes)
3. **No duplicate values** (in standard BST)
4. **Search/Insert/Delete in O(log n)** average case
5. **Can degenerate to linked list** in worst case

### Common Edge Cases

1. **Empty tree** (root = null)
2. **Single node tree**
3. **Skewed tree** (all left or all right)
4. **Complete binary tree**
5. **Perfect binary tree**
6. **Nodes with one child**
7. **Duplicate values** (depending on problem)
8. **Negative values**
9. **Very large values** (integer overflow)

### Tree Problem-Solving Checklist

- [ ] Identify if it's BST or general binary tree
- [ ] Choose appropriate traversal (DFS vs BFS)
- [ ] Consider recursive vs iterative approach
- [ ] Handle base cases (null, leaf nodes)
- [ ] Think about space complexity (call stack)
- [ ] Consider edge cases
- [ ] Optimize if needed (Morris traversal for O(1) space)

---

## Important Algorithms

### 1. **Morris Traversal (Threaded Binary Tree)**
- **Space Complexity**: O(1)
- **Use**: Inorder/Preorder without recursion or stack
- **Applications**: Space-optimized traversal

### 2. **Floyd's Cycle Detection** (Applied to Trees)
- **Use**: Detect cycles in graphs treated as trees
- **Problems**: Find duplicate number, happy number

### 3. **Tree Diameter Algorithm**
- **Approach**: For each node, calculate max path through it
- **Formula**: max(left_height + right_height + 1)

### 4. **LCA (Lowest Common Ancestor)**
- **Binary Tree**: Recursive approach with null checks
- **BST**: Use BST property (compare values)
- **With Parent Pointers**: Similar to linked list intersection

### 5. **Tree Serialization**
- **Preorder with null markers**: Easy reconstruction
- **Level order**: BFS-based serialization
- **BST specific**: Can use preorder only (no null markers)

### 6. **Vertical Order Traversal**
- **Use Hash Map**: Column â†’ nodes mapping
- **Track**: (row, col) coordinates
- **Sort**: By column, then row, then value

### 7. **Tree Construction Algorithms**
- **From Inorder + Preorder**: Root from preorder[0]
- **From Inorder + Postorder**: Root from postorder[-1]
- **Array to BST**: Use middle element as root

---

## Problem-Solving Strategies

### Strategy 1: Divide and Conquer
**When to use**: Problem can be broken into left and right subtrees

**Examples**:
- Maximum depth
- Balanced tree check
- Diameter calculation

**Pattern**:
```python
def solve(root):
    if not root:
        return base_case
    left_result = solve(root.left)
    right_result = solve(root.right)
    return combine(left_result, right_result, root.val)
```

### Strategy 2: Top-Down DFS (Preorder)
**When to use**: Need to pass information from parent to children

**Examples**:
- Path sum
- Root to leaf paths
- Maximum path from root

**Pattern**:
```python
def solve(root, current_state):
    if not root:
        return
    # Process with current state
    new_state = update(current_state, root.val)
    solve(root.left, new_state)
    solve(root.right, new_state)
```

### Strategy 3: Bottom-Up DFS (Postorder)
**When to use**: Need information from children to process parent

**Examples**:
- Tree height
- Subtree sums
- LCA

**Pattern**:
```python
def solve(root):
    if not root:
        return base_case
    left = solve(root.left)
    right = solve(root.right)
    # Process current node with children's results
    return process(left, right, root.val)
```

### Strategy 4: Level Order BFS
**When to use**: Need to process level by level

**Examples**:
- Level order traversal
- Right side view
- Zigzag traversal

**Pattern**:
```python
def solve(root):
    if not root:
        return []
    result = []
    queue = deque([root])
    while queue:
        level_size = len(queue)
        level = []
        for _ in range(level_size):
            node = queue.popleft()
            level.append(node.val)
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        result.append(level)
    return result
```

### Strategy 5: BST In-order for Sorted Processing
**When to use**: Need sorted order in BST

**Examples**:
- Kth smallest element
- Validate BST
- Convert to sorted list

**Pattern**:
```python
def inorder(root, result):
    if not root:
        return
    inorder(root.left, result)
    result.append(root.val)  # Process in sorted order
    inorder(root.right, result)
```

### Strategy 6: Parent Tracking
**When to use**: Need to traverse upward or find ancestors

**Examples**:
- All nodes at distance K
- LCA with parent pointers

**Pattern**:
```python
# Build parent map first
def build_parent_map(root):
    parent = {}
    queue = deque([root])
    while queue:
        node = queue.popleft()
        if node.left:
            parent[node.left] = node
            queue.append(node.left)
        if node.right:
            parent[node.right] = node
            queue.append(node.right)
    return parent
```

---

## Advanced Techniques

### 1. **Path Compression (Tree DP)**
Store results at each node to avoid recomputation

**Example**: House Robber III
```python
def rob(root):
    def dfs(node):
        if not node:
            return (0, 0)  # (rob, not_rob)
        left = dfs(node.left)
        right = dfs(node.right)
        rob = node.val + left[1] + right[1]
        not_rob = max(left) + max(right)
        return (rob, not_rob)
    return max(dfs(root))
```

### 2. **State Tracking**
Track state information during traversal

**Example**: Binary Tree Cameras
- Track if node is monitored, has camera, or needs monitoring

### 3. **Global Variables for Cross-Node Communication**
Use when comparing across different paths

**Example**: Maximum Path Sum
```python
max_sum = float('-inf')

def max_path_sum(root):
    def dfs(node):
        nonlocal max_sum
        if not node:
            return 0
        left = max(0, dfs(node.left))
        right = max(0, dfs(node.right))
        max_sum = max(max_sum, left + right + node.val)
        return max(left, right) + node.val
    dfs(root)
    return max_sum
```

### 4. **Coordinate System**
Assign coordinates for spatial problems

**Example**: Vertical Order Traversal
- Use (row, col) coordinates
- Hash map: col â†’ list of (row, val)

### 5. **Two-Pass Algorithms**
First pass collects info, second pass processes

**Example**: Sum of Distances in Tree
- First pass: Calculate subtree sizes and initial sums
- Second pass: Adjust sums based on parent's sum

---

## Interview Tips

### Before Coding

1. **Clarify Problem**
   - Is it binary tree or BST?
   - Can values be negative/duplicate?
   - Is tree balanced?
   - What about empty tree?

2. **Choose Approach**
   - DFS (recursive/iterative) or BFS?
   - Top-down or bottom-up?
   - Need extra space (hash map, parent tracking)?

3. **Discuss Trade-offs**
   - Time vs space complexity
   - Recursive (cleaner) vs iterative (no stack overflow)

### During Coding

1. **Start with Base Cases**
   ```python
   if not root:
       return None/0/[]/False
   ```

2. **Handle Edge Cases**
   - Single node
   - Leaf nodes
   - Skewed trees

3. **Use Helper Functions**
   - Separate traversal logic
   - Cleaner code structure

### After Coding

1. **Test with Examples**
   - Empty tree
   - Single node
   - Balanced tree
   - Skewed tree

2. **Analyze Complexity**
   - Time: Usually O(n) for traversal
   - Space: O(h) for recursion, O(n) for BFS

3. **Optimize if Needed**
   - Morris traversal for O(1) space
   - Iterative instead of recursive
   - Early termination

---

## Common Mistakes to Avoid

1. **Not handling null nodes** â†’ Always check `if not root`
2. **Confusing node and node.val** â†’ Be careful with references
3. **Wrong base case in recursion** â†’ Think about leaf nodes
4. **Stack overflow in deep trees** â†’ Consider iterative approach
5. **Incorrect BST property** â†’ Remember: left < root < right
6. **Modifying tree during traversal** â†’ Be careful with deletions
7. **Forgetting to return values** â†’ Check all paths return
8. **Off-by-one errors in level order** â†’ Use `len(queue)` correctly

---

## Resources & Next Steps

### Practice Platforms
- **LeetCode**: Best for tree problems, explore cards
- **GeeksforGeeks**: Good explanations and variety
- **HackerRank**: Interview preparation
- **Codeforces**: Competitive programming

### Study Plan

**Week 1-2**: Basic traversals + properties (30 problems)
**Week 3**: BST mastery (20 problems)
**Week 4-5**: Path problems + modifications (30 problems)
**Week 6**: Advanced topics (20 problems)
**Week 7-8**: Specialized trees (Trie, Segment Tree) (25 problems)

**Total**: ~125 problems over 8 weeks

### Advanced Topics to Explore

1. **AVL Trees** - Self-balancing BST
2. **Red-Black Trees** - Another balanced BST
3. **B-Trees** - Multi-way search trees
4. **Splay Trees** - Self-adjusting BST
5. **Treap** - Randomized BST
6. **Suffix Trees** - Pattern matching
7. **Interval Trees** - Interval queries
8. **K-D Trees** - Multi-dimensional search

---

## Quick Reference Card

### Must-Know Problems (Top 20)

1. Binary Tree Inorder Traversal
2. Maximum Depth of Binary Tree
3. Symmetric Tree
4. Path Sum
5. Invert Binary Tree
6. Lowest Common Ancestor of Binary Tree
7. Binary Tree Level Order Traversal
8. Validate Binary Search Tree
9. Kth Smallest Element in BST
10. Construct Binary Tree from Preorder and Inorder
11. Binary Tree Maximum Path Sum
12. Serialize and Deserialize Binary Tree
13. Implement Trie
14. Word Search II
15. Flatten Binary Tree to Linked List
16. Populating Next Right Pointers
17. Count Complete Tree Nodes
18. House Robber III
19. Binary Tree Cameras
20. All Nodes Distance K in Binary Tree

### Templates Cheat Sheet

**DFS Recursive**: Base case â†’ Process â†’ Recurse
**DFS Iterative**: Stack â†’ Pop â†’ Push children
**BFS**: Queue â†’ Pop level â†’ Add next level
**BST Search**: Compare â†’ Go left/right
**LCA**: Find in left and right â†’ Return appropriate node
**Path Tracking**: DFS with current path â†’ Backtrack

---

## Conclusion

Trees are fundamental to computer science and appear frequently in interviews. Master the basics first (traversals, properties), then move to patterns (BST operations, paths, modifications), and finally tackle advanced topics (specialized trees, complex algorithms).

**Key to Success**:
- Practice consistently (3-5 problems daily)
- Understand patterns, not just solutions
- Code without looking at solutions first
- Review and optimize after solving
- Teach others to solidify understanding

Happy coding! ðŸŒ³
