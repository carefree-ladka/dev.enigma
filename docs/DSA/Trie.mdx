---
title: Trie Data Structure
---

## Trie Data Structure

A Trie, also known as a prefix tree or digital tree, is a specialized tree used to store associative data structures. It is commonly used for storing strings or sequences where it can efficiently support operations like insertion, deletion, and prefix search.

### Key Concepts

- **Nodes**: Each node represents a character of the stored strings.
- **Edges**: The edges between nodes represent the transitions from one character to the next.
- **Root**: The root node represents the starting point of the Trie and does not store any character.

### Operations

1. **Insertion**: Add a new string to the Trie.
2. **Search**: Check if a string exists in the Trie.
3. **Prefix Search**: Find all strings that share a common prefix.
4. **Deletion**: Remove a string from the Trie.

### Code Implementation

Here's a basic implementation of a Trie in JavaScript:

```javascript
class TrieNode {
  constructor() {
    this.children = {};
    this.isEndOfWord = false;
    this.frequency = 0;    // Track word frequency
    this.lastAccessed = 0; // Track last access timestamp
  }
}

class Trie {
  constructor() {
    this.root = new TrieNode();
    this.wordCount = 0;    // Track total number of words
  }

  insert(word) {
    if (!word) return;
    let node = this.root;
    for (const char of word) {
      if (!node.children[char]) {
        node.children[char] = new TrieNode();
      }
      node = node.children[char];
    }
    if (!node.isEndOfWord) {
      this.wordCount++;
    }
    node.isEndOfWord = true;
    node.frequency++;
    node.lastAccessed = Date.now();
  }

  search(word) {
    let node = this.traverse(word);
    if (node && node.isEndOfWord) {
      node.lastAccessed = Date.now();
      return true;
    }
    return false;
  }

  startsWith(prefix) {
    return this.traverse(prefix) !== null;
  }

  // Helper method to traverse to a node
  traverse(str) {
    let node = this.root;
    for (const char of str) {
      if (!node.children[char]) {
        return null;
      }
      node = node.children[char];
    }
    return node;
  }

  // Delete a word from the trie
  delete(word) {
    return this.#deleteHelper(this.root, word, 0);
  }

  #deleteHelper(node, word, depth) {
    if (!node) return false;

    // If we've reached the end of the word
    if (depth === word.length) {
      if (!node.isEndOfWord) return false;
      
      node.isEndOfWord = false;
      node.frequency = 0;
      this.wordCount--;
      
      // Return true if node has no children
      return Object.keys(node.children).length === 0;
    }

    const char = word[depth];
    const shouldDeleteChild = this.#deleteHelper(node.children[char], word, depth + 1);

    // If child should be deleted, remove it
    if (shouldDeleteChild) {
      delete node.children[char];
      // Return true if this node should also be deleted
      return !node.isEndOfWord && Object.keys(node.children).length === 0;
    }

    return false;
  }

  // Get word frequency
  getFrequency(word) {
    const node = this.traverse(word);
    return node ? node.frequency : 0;
  }

  // Get all words in the trie
  getAllWords() {
    const words = [];
    this.#collectAllWords(this.root, '', words);
    return words;
  }

  // Get words sorted by frequency
  getWordsByFrequency() {
    const words = this.getAllWords();
    return words.sort((a, b) => {
      const nodeA = this.traverse(a);
      const nodeB = this.traverse(b);
      return nodeB.frequency - nodeA.frequency;
    });
  }

  // Get recently accessed words
  getRecentWords(limit = 10) {
    const words = this.getAllWords();
    return words.sort((a, b) => {
      const nodeA = this.traverse(a);
      const nodeB = this.traverse(b);
      return nodeB.lastAccessed - nodeA.lastAccessed;
    }).slice(0, limit);
  }

  // Get words with wildcard pattern (? for single char, * for multiple chars)
  searchWithWildcard(pattern) {
    const results = [];
    this.#searchWithWildcardHelper(this.root, '', pattern, 0, results);
    return results;
  }

  #searchWithWildcardHelper(node, current, pattern, index, results) {
    if (index === pattern.length) {
      if (node.isEndOfWord) {
        results.push(current);
      }
      return;
    }

    const char = pattern[index];
    if (char === '?') {
      // Match any single character
      for (const nextChar in node.children) {
        this.#searchWithWildcardHelper(
          node.children[nextChar],
          current + nextChar,
          pattern,
          index + 1,
          results
        );
      }
    } else if (char === '*') {
      // Match zero or more characters
      // Match zero characters
      this.#searchWithWildcardHelper(node, current, pattern, index + 1, results);
      // Match one or more characters
      for (const nextChar in node.children) {
        this.#searchWithWildcardHelper(
          node.children[nextChar],
          current + nextChar,
          pattern,
          index,
          results
        );
      }
    } else {
      // Match exact character
      if (node.children[char]) {
        this.#searchWithWildcardHelper(
          node.children[char],
          current + char,
          pattern,
          index + 1,
          results
        );
      }
    }
  }

  // Find longest word in trie
  getLongestWord() {
    return this.#findLongestWord(this.root, '');
  }

  #findLongestWord(node, current) {
    let longest = node.isEndOfWord ? current : '';

    for (const char in node.children) {
      const childResult = this.#findLongestWord(node.children[char], current + char);
      if (childResult.length > longest.length) {
        longest = childResult;
      }
    }

    return longest;
  }

  // Helper function for autocomplete and collecting words
  #collectAllWords(node, prefix, results) {
    if (node.isEndOfWord) {
      results.push(prefix);
    }
    for (let char in node.children) {
      this.#collectAllWords(node.children[char], prefix + char, results);
    }
  }

  // Get size statistics
  getStats() {
    return {
      totalWords: this.wordCount,
      totalNodes: this.#countNodes(this.root),
      maxDepth: this.#getMaxDepth(this.root),
      memoryUsage: this.#approximateMemoryUsage()
    };
  }

  #countNodes(node) {
    let count = 1;
    for (const child in node.children) {
      count += this.#countNodes(node.children[child]);
    }
    return count;
  }

  #getMaxDepth(node, depth = 0) {
    if (Object.keys(node.children).length === 0) {
      return depth;
    }
    let maxDepth = depth;
    for (const child in node.children) {
      maxDepth = Math.max(maxDepth, this.#getMaxDepth(node.children[child], depth + 1));
    }
    return maxDepth;
  }

  #approximateMemoryUsage() {
    // Rough approximation in bytes
    return this.#countNodes(this.root) * 
           (8 + // references to children object
            4 + // isEndOfWord boolean
            8 + // frequency number
            8); // lastAccessed timestamp
  }
}

// Example usage with new features
const trie = new Trie();

// Insert words with multiple occurrences
trie.insert("hello");
trie.insert("hello");  // inserted twice
trie.insert("world");
trie.insert("wonderful");
trie.insert("win");
trie.insert("wine");

// Test deletion
console.log(trie.search("hello"));  // true
trie.delete("hello");
console.log(trie.search("hello"));  // false

// Test wildcard search
console.log(trie.searchWithWildcard("w?n"));     // ["win"]
console.log(trie.searchWithWildcard("w*"));      // ["world", "wonderful", "win", "wine"]

// Test frequency and recent words
console.log(trie.getFrequency("hello"));     // 0 (deleted)
console.log(trie.getWordsByFrequency());     // Shows words sorted by frequency
console.log(trie.getRecentWords(3));         // Shows 3 most recently accessed words

// Get statistics
console.log(trie.getStats());                // Shows trie statistics

// Get longest word
console.log(trie.getLongestWord());          // "wonderful"
```

## XOR Trie

A XOR Trie is a data structure specifically designed for efficiently solving problems related to finding the maximum XOR of numbers in an array, subarray XOR queries, or other XOR-related tasks.

```JavaScript
class XORTrie {
  root = {};

  // Insert a number into the trie
  insert = (num) => {
    let node = this.root;
    for (let i = 31; i >= 0; i--) {
      const bit = (num >> i) & 1; // Extract the i-th bit
      if (!node[bit]) {
        node[bit] = {}; // Create a new branch if it doesn't exist
      }
      node = node[bit];
    }
  }

  // Find the maximum XOR of a given number with the trie
  findMaxXOR = (num) => {
    let node = this.root;
    let maxXOR = 0;
    for (let i = 31; i >= 0; i--) {
      const bit = (num >> i) & 1; // Extract the i-th bit
      const oppositeBit = 1 - bit; // XOR maximization prefers the opposite bit
      if (node[oppositeBit]) {
        maxXOR = (maxXOR << 1) | 1; // Add 1 to maxXOR (prefer opposite bit)
        node = node[oppositeBit];
      } else {
        maxXOR = maxXOR << 1; // Add 0 to maxXOR
        node = node[bit];
      }
    }
    return maxXOR;
  }
}

// Example usage
const nums = [3, 10, 5, 25, 2, 8];
const xorTrie = new XORTrie();

// Insert all numbers into the trie
nums.forEach(num => xorTrie.insert(num));

// Find the maximum XOR of any pair in the array
console.log(nums.reduce((maxXor, num) => Math.max(maxXor, xorTrie.findMaxXOR(num)), 0)); // Output: 28
```