# String

## Table of Contents

1. [String Fundamentals](#string-fundamentals)
2. [Pattern 1: Two Pointers for Strings](#pattern-1-two-pointers-for-strings)
3. [Pattern 2: Sliding Window for Strings](#pattern-2-sliding-window-for-strings)
4. [Pattern 3: String Matching Algorithms](#pattern-3-string-matching-algorithms)
5. [Pattern 4: Palindrome Problems](#pattern-4-palindrome-problems)
6. [Pattern 5: Anagram \& Permutation](#pattern-5-anagram--permutation)
7. [Pattern 6: Subsequence \& Substring](#pattern-6-subsequence--substring)
8. [Pattern 7: String Transformation](#pattern-7-string-transformation)
9. [Pattern 8: Parsing \& Validation](#pattern-8-parsing--validation)
10. [Pattern 9: Trie-based String Problems](#pattern-9-trie-based-string-problems)
11. [Pattern 10: String DP Problems](#pattern-10-string-dp-problems)
12. [Pattern 11: Advanced String Algorithms](#pattern-11-advanced-string-algorithms)
13. [Pattern 12: String Compression \& Encoding](#pattern-12-string-compression--encoding)

---

## String Fundamentals

### Core String Operations

```java
// String Basics and Common Operations
class StringFundamentals {

    // String Creation Methods
    public static void stringCreation() {
        // Literal (stored in string pool)
        String s1 = "Hello";
        String s2 = "Hello"; // s1 == s2 is true

        // Constructor (creates new object)
        String s3 = new String("Hello");
        String s4 = new String("Hello"); // s3 == s4 is false

        // From character array
        char[] chars = {'H', 'e', 'l', 'l', 'o'};
        String s5 = new String(chars);

        // From StringBuilder/StringBuffer
        StringBuilder sb = new StringBuilder("Hello");
        String s6 = sb.toString();
    }

    // Common String Methods
    public static void stringMethods() {
        String str = "Hello World";

        // Length and character access
        int length = str.length();
        char ch = str.charAt(0);

        // Comparison
        boolean equals = str.equals("hello world");       // false
        boolean equalsIgnoreCase = str.equalsIgnoreCase("hello world"); // true
        int comparison = str.compareTo("Hello World");    // 0

        // Searching
        int index = str.indexOf('o');           // 4
        int lastIndex = str.lastIndexOf('o');   // 7
        boolean contains = str.contains("World"); // true
        boolean startsWith = str.startsWith("Hello"); // true
        boolean endsWith = str.endsWith("World");     // true

        // Substrings
        String sub1 = str.substring(6);     // "World"
        String sub2 = str.substring(0, 5);  // "Hello"

        // Modification (returns new strings)
        String upper = str.toUpperCase();   // "HELLO WORLD"
        String lower = str.toLowerCase();   // "hello world"
        String trimmed = str.trim();        // removes leading/trailing whitespace
        String replaced = str.replace('l', 'L'); // "HeLLo WorLd"

        // Splitting
        String[] words = str.split(" ");    // ["Hello", "World"]
        String[] chars = str.split("");     // ["H", "e", "l", "l", "o", " ", "W", "o", "r", "l", "d"]
    }

    // StringBuilder vs StringBuffer
    public static void stringBuilders() {
        // StringBuilder (not thread-safe, faster)
        StringBuilder sb = new StringBuilder();
        sb.append("Hello");
        sb.append(" ");
        sb.append("World");
        sb.insert(5, ",");      // "Hello, World"
        sb.delete(5, 6);        // "Hello World"
        sb.reverse();           // "dlroW olleH"
        String result = sb.toString();

        // StringBuffer (thread-safe, slower)
        StringBuffer sbf = new StringBuffer("Hello");
        sbf.append(" World");
        String result2 = sbf.toString();
    }
}

// Custom String Utilities
class StringUtils {

    // Convert string to character frequency map
    public static Map<Character, Integer> getCharFrequency(String s) {
        Map<Character, Integer> freq = new HashMap<>();
        for (char c : s.toCharArray()) {
            freq.put(c, freq.getOrDefault(c, 0) + 1);
        }
        return freq;
    }

    // Convert character array to string
    public static String charArrayToString(char[] chars) {
        return new String(chars);
    }

    // Reverse string
    public static String reverse(String s) {
        return new StringBuilder(s).reverse().toString();
    }

    // Check if string is numeric
    public static boolean isNumeric(String s) {
        try {
            Double.parseDouble(s);
            return true;
        } catch (NumberFormatException e) {
            return false;
        }
    }

    // Remove all whitespaces
    public static String removeSpaces(String s) {
        return s.replaceAll("\\s+", "");
    }

    // Count words in string
    public static int countWords(String s) {
        if (s == null || s.trim().isEmpty()) return 0;
        return s.trim().split("\\s+").length;
    }
}
```

---

## Pattern 1: Two Pointers for Strings

### 1.1 Palindrome Validation[3]

```java
// Valid Palindrome
public boolean isPalindrome(String s) {
    int left = 0, right = s.length() - 1;

    while (left < right) {
        // Skip non-alphanumeric characters
        while (left < right && !Character.isLetterOrDigit(s.charAt(left))) {
            left++;
        }
        while (left < right && !Character.isLetterOrDigit(s.charAt(right))) {
            right--;
        }

        // Compare characters (case insensitive)
        if (Character.toLowerCase(s.charAt(left)) !=
            Character.toLowerCase(s.charAt(right))) {
            return false;
        }

        left++;
        right--;
    }

    return true;
}

// Valid Palindrome II (Remove at most one character)
public boolean validPalindrome(String s) {
    int left = 0, right = s.length() - 1;

    while (left < right) {
        if (s.charAt(left) != s.charAt(right)) {
            // Try removing left character or right character
            return isPalindromeRange(s, left + 1, right) ||
                   isPalindromeRange(s, left, right - 1);
        }
        left++;
        right--;
    }

    return true;
}

private boolean isPalindromeRange(String s, int left, int right) {
    while (left < right) {
        if (s.charAt(left) != s.charAt(right)) {
            return false;
        }
        left++;
        right--;
    }
    return true;
}

// Longest Palindromic Substring (Expand Around Centers)
public String longestPalindrome(String s) {
    if (s == null || s.length() < 1) return "";

    int start = 0, end = 0;

    for (int i = 0; i < s.length(); i++) {
        // Check for odd length palindromes (center at i)
        int len1 = expandAroundCenter(s, i, i);
        // Check for even length palindromes (center between i and i+1)
        int len2 = expandAroundCenter(s, i, i + 1);

        int maxLen = Math.max(len1, len2);
        if (maxLen > end - start) {
            start = i - (maxLen - 1) / 2;
            end = i + maxLen / 2;
        }
    }

    return s.substring(start, end + 1);
}

private int expandAroundCenter(String s, int left, int right) {
    while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
        left--;
        right++;
    }
    return right - left - 1;
}
```

### 1.2 String Comparison and Matching

```java
// Compare Version Numbers
public int compareVersion(String version1, String version2) {
    String[] v1Parts = version1.split("\\.");
    String[] v2Parts = version2.split("\\.");

    int i = 0, j = 0;
    while (i < v1Parts.length || j < v2Parts.length) {
        int num1 = i < v1Parts.length ? Integer.parseInt(v1Parts[i]) : 0;
        int num2 = j < v2Parts.length ? Integer.parseInt(v2Parts[j]) : 0;

        if (num1 < num2) return -1;
        if (num1 > num2) return 1;

        i++;
        j++;
    }

    return 0;
}

// Is Subsequence
public boolean isSubsequence(String s, String t) {
    int i = 0, j = 0;

    while (i < s.length() && j < t.length()) {
        if (s.charAt(i) == t.charAt(j)) {
            i++;
        }
        j++;
    }

    return i == s.length();
}

// Merge Strings Alternately
public String mergeAlternately(String word1, String word2) {
    StringBuilder result = new StringBuilder();
    int i = 0, j = 0;

    while (i < word1.length() && j < word2.length()) {
        result.append(word1.charAt(i++));
        result.append(word2.charAt(j++));
    }

    // Append remaining characters
    while (i < word1.length()) {
        result.append(word1.charAt(i++));
    }
    while (j < word2.length()) {
        result.append(word2.charAt(j++));
    }

    return result.toString();
}
```

---

## Pattern 2: Sliding Window for Strings

### 2.1 Variable Length Sliding Window

```java
// Longest Substring Without Repeating Characters
public int lengthOfLongestSubstring(String s) {
    Set<Character> window = new HashSet<>();
    int left = 0, maxLength = 0;

    for (int right = 0; right < s.length(); right++) {
        // Shrink window until no duplicates
        while (window.contains(s.charAt(right))) {
            window.remove(s.charAt(left));
            left++;
        }

        window.add(s.charAt(right));
        maxLength = Math.max(maxLength, right - left + 1);
    }

    return maxLength;
}

// Longest Substring with At Most K Distinct Characters
public int lengthOfLongestSubstringKDistinct(String s, int k) {
    if (k == 0) return 0;

    Map<Character, Integer> charCount = new HashMap<>();
    int left = 0, maxLength = 0;

    for (int right = 0; right < s.length(); right++) {
        char rightChar = s.charAt(right);
        charCount.put(rightChar, charCount.getOrDefault(rightChar, 0) + 1);

        // Shrink window if more than k distinct characters
        while (charCount.size() > k) {
            char leftChar = s.charAt(left);
            charCount.put(leftChar, charCount.get(leftChar) - 1);
            if (charCount.get(leftChar) == 0) {
                charCount.remove(leftChar);
            }
            left++;
        }

        maxLength = Math.max(maxLength, right - left + 1);
    }

    return maxLength;
}

// Minimum Window Substring
public String minWindow(String s, String t) {
    if (s.length() < t.length()) return "";

    Map<Character, Integer> targetCount = new HashMap<>();
    for (char c : t.toCharArray()) {
        targetCount.put(c, targetCount.getOrDefault(c, 0) + 1);
    }

    Map<Character, Integer> windowCount = new HashMap<>();
    int left = 0, formed = 0;
    int minLength = Integer.MAX_VALUE, minStart = 0;
    int required = targetCount.size();

    for (int right = 0; right < s.length(); right++) {
        char rightChar = s.charAt(right);
        windowCount.put(rightChar, windowCount.getOrDefault(rightChar, 0) + 1);

        if (targetCount.containsKey(rightChar) &&
            windowCount.get(rightChar).intValue() == targetCount.get(rightChar).intValue()) {
            formed++;
        }

        // Shrink window while it's valid
        while (left <= right && formed == required) {
            if (right - left + 1 < minLength) {
                minLength = right - left + 1;
                minStart = left;
            }

            char leftChar = s.charAt(left);
            windowCount.put(leftChar, windowCount.get(leftChar) - 1);
            if (targetCount.containsKey(leftChar) &&
                windowCount.get(leftChar) < targetCount.get(leftChar)) {
                formed--;
            }
            left++;
        }
    }

    return minLength == Integer.MAX_VALUE ? "" : s.substring(minStart, minStart + minLength);
}
```

### 2.2 Fixed Length Sliding Window

```java
// Find All Anagrams in a String
public List<Integer> findAnagrams(String s, String p) {
    List<Integer> result = new ArrayList<>();
    if (s.length() < p.length()) return result;

    Map<Character, Integer> pCount = new HashMap<>();
    Map<Character, Integer> windowCount = new HashMap<>();

    // Count characters in pattern
    for (char c : p.toCharArray()) {
        pCount.put(c, pCount.getOrDefault(c, 0) + 1);
    }

    int windowSize = p.length();

    // Process first window
    for (int i = 0; i < windowSize; i++) {
        char c = s.charAt(i);
        windowCount.put(c, windowCount.getOrDefault(c, 0) + 1);
    }

    if (windowCount.equals(pCount)) {
        result.add(0);
    }

    // Slide the window
    for (int i = windowSize; i < s.length(); i++) {
        // Add new character
        char newChar = s.charAt(i);
        windowCount.put(newChar, windowCount.getOrDefault(newChar, 0) + 1);

        // Remove old character
        char oldChar = s.charAt(i - windowSize);
        windowCount.put(oldChar, windowCount.get(oldChar) - 1);
        if (windowCount.get(oldChar) == 0) {
            windowCount.remove(oldChar);
        }

        // Check if current window is anagram
        if (windowCount.equals(pCount)) {
            result.add(i - windowSize + 1);
        }
    }

    return result;
}

// Permutation in String
public boolean checkInclusion(String s1, String s2) {
    if (s1.length() > s2.length()) return false;

    Map<Character, Integer> s1Count = new HashMap<>();
    Map<Character, Integer> windowCount = new HashMap<>();

    for (char c : s1.toCharArray()) {
        s1Count.put(c, s1Count.getOrDefault(c, 0) + 1);
    }

    int windowSize = s1.length();

    // Process first window
    for (int i = 0; i < windowSize; i++) {
        char c = s2.charAt(i);
        windowCount.put(c, windowCount.getOrDefault(c, 0) + 1);
    }

    if (windowCount.equals(s1Count)) return true;

    // Slide the window
    for (int i = windowSize; i < s2.length(); i++) {
        // Add new character
        char newChar = s2.charAt(i);
        windowCount.put(newChar, windowCount.getOrDefault(newChar, 0) + 1);

        // Remove old character
        char oldChar = s2.charAt(i - windowSize);
        windowCount.put(oldChar, windowCount.get(oldChar) - 1);
        if (windowCount.get(oldChar) == 0) {
            windowCount.remove(oldChar);
        }

        if (windowCount.equals(s1Count)) return true;
    }

    return false;
}
```

---

## Pattern 3: String Matching Algorithms

### 3.1 KMP Algorithm

```java
// KMP Pattern Matching Algorithm
public class KMPAlgorithm {

    // Find all occurrences of pattern in text
    public List<Integer> KMPSearch(String text, String pattern) {
        List<Integer> matches = new ArrayList<>();
        if (pattern.isEmpty()) return matches;

        int[] lps = computeLPSArray(pattern);
        int textIndex = 0, patternIndex = 0;

        while (textIndex < text.length()) {
            if (text.charAt(textIndex) == pattern.charAt(patternIndex)) {
                textIndex++;
                patternIndex++;
            }

            if (patternIndex == pattern.length()) {
                matches.add(textIndex - patternIndex);
                patternIndex = lps[patternIndex - 1];
            } else if (textIndex < text.length() &&
                      text.charAt(textIndex) != pattern.charAt(patternIndex)) {
                if (patternIndex != 0) {
                    patternIndex = lps[patternIndex - 1];
                } else {
                    textIndex++;
                }
            }
        }

        return matches;
    }

    // Compute Longest Prefix Suffix (LPS) array
    private int[] computeLPSArray(String pattern) {
        int[] lps = new int[pattern.length()];
        int length = 0; // Length of previous longest prefix suffix
        int i = 1;

        lps[0] = 0; // lps[0] is always 0

        while (i < pattern.length()) {
            if (pattern.charAt(i) == pattern.charAt(length)) {
                length++;
                lps[i] = length;
                i++;
            } else {
                if (length != 0) {
                    length = lps[length - 1];
                } else {
                    lps[i] = 0;
                    i++;
                }
            }
        }

        return lps;
    }

    // Check if string contains pattern
    public boolean contains(String text, String pattern) {
        return !KMPSearch(text, pattern).isEmpty();
    }

    // Find first occurrence of pattern in text
    public int indexOf(String text, String pattern) {
        List<Integer> matches = KMPSearch(text, pattern);
        return matches.isEmpty() ? -1 : matches.get(0);
    }
}
```

### 3.2 Rabin-Karp Algorithm

```java
// Rabin-Karp Pattern Matching Algorithm
public class RabinKarpAlgorithm {
    private static final int PRIME = 101;

    public List<Integer> search(String text, String pattern) {
        List<Integer> matches = new ArrayList<>();
        int patternLength = pattern.length();
        int textLength = text.length();

        if (patternLength > textLength) return matches;

        // Calculate hash values
        long patternHash = calculateHash(pattern, patternLength);
        long textHash = calculateHash(text, patternLength);

        // Slide the pattern over text
        for (int i = 0; i <= textLength - patternLength; i++) {
            // Check if hash values match
            if (patternHash == textHash) {
                // Hash values match, check actual characters
                if (text.substring(i, i + patternLength).equals(pattern)) {
                    matches.add(i);
                }
            }

            // Calculate hash for next window
            if (i < textLength - patternLength) {
                textHash = recalculateHash(text, i, i + patternLength, textHash, patternLength);
            }
        }

        return matches;
    }

    private long calculateHash(String str, int length) {
        long hash = 0;
        for (int i = 0; i < length; i++) {
            hash += str.charAt(i) * Math.pow(PRIME, i);
        }
        return hash;
    }

    private long recalculateHash(String str, int oldIndex, int newIndex,
                                long oldHash, int patternLength) {
        long newHash = oldHash - str.charAt(oldIndex);
        newHash = newHash / PRIME;
        newHash += str.charAt(newIndex) * Math.pow(PRIME, patternLength - 1);
        return newHash;
    }
}
```

### 3.3 String Matching Applications

```java
// Repeated Substring Pattern
public boolean repeatedSubstringPattern(String s) {
    String doubled = s + s;
    return doubled.substring(1, doubled.length() - 1).contains(s);
}

// Implement strStr() (indexOf)
public int strStr(String haystack, String needle) {
    if (needle.isEmpty()) return 0;
    if (haystack.length() < needle.length()) return -1;

    KMPAlgorithm kmp = new KMPAlgorithm();
    return kmp.indexOf(haystack, needle);
}

// Find All Occurrences of Pattern
public List<Integer> findAllOccurrences(String text, String pattern) {
    KMPAlgorithm kmp = new KMPAlgorithm();
    return kmp.KMPSearch(text, pattern);
}
```

---

## Pattern 4: Palindrome Problems

### 4.1 Palindrome Detection and Construction

```java
// Palindromic Substrings Count
public int countSubstrings(String s) {
    int count = 0;

    for (int i = 0; i < s.length(); i++) {
        // Odd length palindromes (center at i)
        count += expandAroundCenter(s, i, i);
        // Even length palindromes (center between i and i+1)
        count += expandAroundCenter(s, i, i + 1);
    }

    return count;
}

private int expandAroundCenter(String s, int left, int right) {
    int count = 0;
    while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
        count++;
        left--;
        right++;
    }
    return count;
}

// Shortest Palindrome (Add characters to front)
public String shortestPalindrome(String s) {
    String reversed = new StringBuilder(s).reverse().toString();

    // Find the longest prefix of s that is also suffix of reversed
    for (int i = 0; i < s.length(); i++) {
        if (s.startsWith(reversed.substring(i))) {
            return reversed.substring(0, i) + s;
        }
    }

    return reversed + s;
}

// Palindrome Partitioning
public List<List<String>> partition(String s) {
    List<List<String>> result = new ArrayList<>();
    List<String> currentPartition = new ArrayList<>();
    backtrackPartition(s, 0, currentPartition, result);
    return result;
}

private void backtrackPartition(String s, int start, List<String> currentPartition,
                               List<List<String>> result) {
    if (start >= s.length()) {
        result.add(new ArrayList<>(currentPartition));
        return;
    }

    for (int end = start; end < s.length(); end++) {
        if (isPalindrome(s, start, end)) {
            currentPartition.add(s.substring(start, end + 1));
            backtrackPartition(s, end + 1, currentPartition, result);
            currentPartition.remove(currentPartition.size() - 1);
        }
    }
}

private boolean isPalindrome(String s, int left, int right) {
    while (left < right) {
        if (s.charAt(left) != s.charAt(right)) {
            return false;
        }
        left++;
        right--;
    }
    return true;
}
```

### 4.2 Advanced Palindrome Problems

```java
// Minimum Cuts for Palindrome Partitioning
public int minCut(String s) {
    int n = s.length();
    boolean[][] isPalindrome = new boolean[n][n];
    int[] cuts = new int[n];

    // Precompute palindrome information
    for (int i = 0; i < n; i++) {
        int minCuts = i; // Maximum cuts needed

        for (int j = 0; j <= i; j++) {
            if (s.charAt(j) == s.charAt(i) && (i - j < 2 || isPalindrome[j + 1][i - 1])) {
                isPalindrome[j][i] = true;
                minCuts = (j == 0) ? 0 : Math.min(minCuts, cuts[j - 1] + 1);
            }
        }

        cuts[i] = minCuts;
    }

    return cuts[n - 1];
}

// Longest Palindromic Subsequence
public int longestPalindromeSubseq(String s) {
    int n = s.length();
    int[][] dp = new int[n][n];

    // Single characters are palindromes of length 1
    for (int i = 0; i < n; i++) {
        dp[i][i] = 1;
    }

    // Fill dp table
    for (int len = 2; len <= n; len++) {
        for (int i = 0; i <= n - len; i++) {
            int j = i + len - 1;

            if (s.charAt(i) == s.charAt(j)) {
                dp[i][j] = dp[i + 1][j - 1] + 2;
            } else {
                dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
            }
        }
    }

    return dp[0][n - 1];
}
```

---

## Pattern 5: Anagram \& Permutation

### 5.1 Anagram Detection

```java
// Valid Anagram
public boolean isAnagram(String s, String t) {
    if (s.length() != t.length()) return false;

    Map<Character, Integer> charCount = new HashMap<>();

    // Count characters in first string
    for (char c : s.toCharArray()) {
        charCount.put(c, charCount.getOrDefault(c, 0) + 1);
    }

    // Decrement count for second string
    for (char c : t.toCharArray()) {
        charCount.put(c, charCount.getOrDefault(c, 0) - 1);
        if (charCount.get(c) == 0) {
            charCount.remove(c);
        }
    }

    return charCount.isEmpty();
}

// Group Anagrams
public List<List<String>> groupAnagrams(String[] strs) {
    Map<String, List<String>> groups = new HashMap<>();

    for (String str : strs) {
        // Create signature by sorting characters
        char[] chars = str.toCharArray();
        Arrays.sort(chars);
        String signature = new String(chars);

        groups.computeIfAbsent(signature, k -> new ArrayList<>()).add(str);
    }

    return new ArrayList<>(groups.values());
}

// Group Anagrams (Alternative using character frequency)
public List<List<String>> groupAnagramsFrequency(String[] strs) {
    Map<String, List<String>> groups = new HashMap<>();

    for (String str : strs) {
        String signature = getFrequencySignature(str);
        groups.computeIfAbsent(signature, k -> new ArrayList<>()).add(str);
    }

    return new ArrayList<>(groups.values());
}

private String getFrequencySignature(String str) {
    int[] count = new int[26];
    for (char c : str.toCharArray()) {
        count[c - 'a']++;
    }

    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < 26; i++) {
        if (count[i] > 0) {
            sb.append((char) ('a' + i)).append(count[i]);
        }
    }

    return sb.toString();
}
```

### 5.2 String Permutations

```java
// Generate All Permutations
public List<String> generatePermutations(String s) {
    List<String> result = new ArrayList<>();
    char[] chars = s.toCharArray();
    Arrays.sort(chars); // Sort to handle duplicates
    boolean[] used = new boolean[chars.length];

    backtrackPermutations(chars, used, new StringBuilder(), result);
    return result;
}

private void backtrackPermutations(char[] chars, boolean[] used,
                                  StringBuilder current, List<String> result) {
    if (current.length() == chars.length) {
        result.add(current.toString());
        return;
    }

    for (int i = 0; i < chars.length; i++) {
        if (used[i]) continue;

        // Skip duplicates: if current char is same as previous and previous is not used
        if (i > 0 && chars[i] == chars[i - 1] && !used[i - 1]) continue;

        used[i] = true;
        current.append(chars[i]);
        backtrackPermutations(chars, used, current, result);
        current.deleteCharAt(current.length() - 1);
        used[i] = false;
    }
}

// Next Permutation for String
public String nextPermutation(String s) {
    char[] chars = s.toCharArray();
    int i = chars.length - 2;

    // Find first decreasing element from right
    while (i >= 0 && chars[i] >= chars[i + 1]) {
        i--;
    }

    if (i == -1) {
        // String is in descending order, return smallest permutation
        Arrays.sort(chars);
        return new String(chars);
    }

    // Find smallest character on right side of chars[i] that is greater than chars[i]
    int j = chars.length - 1;
    while (chars[j] <= chars[i]) {
        j--;
    }

    // Swap chars[i] and chars[j]
    swap(chars, i, j);

    // Reverse suffix starting at i + 1
    reverse(chars, i + 1, chars.length - 1);

    return new String(chars);
}

private void swap(char[] chars, int i, int j) {
    char temp = chars[i];
    chars[i] = chars[j];
    chars[j] = temp;
}

private void reverse(char[] chars, int start, int end) {
    while (start < end) {
        swap(chars, start++, end--);
    }
}
```

---

## Pattern 6: Subsequence \& Substring

### 6.1 Longest Common Subsequence Problems

```java
// Longest Common Subsequence
public int longestCommonSubsequence(String text1, String text2) {
    int m = text1.length(), n = text2.length();
    int[][] dp = new int[m + 1][n + 1];

    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }

    return dp[m][n];
}

// Longest Common Substring
public int longestCommonSubstring(String text1, String text2) {
    int m = text1.length(), n = text2.length();
    int[][] dp = new int[m + 1][n + 1];
    int maxLength = 0;

    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
                maxLength = Math.max(maxLength, dp[i][j]);
            } else {
                dp[i][j] = 0;
            }
        }
    }

    return maxLength;
}

// Longest Increasing Subsequence (String version)
public int lengthOfLIS(String s) {
    if (s.isEmpty()) return 0;

    List<Character> tails = new ArrayList<>();

    for (char c : s.toCharArray()) {
        int pos = Collections.binarySearch(tails, c);
        if (pos < 0) pos = -(pos + 1);

        if (pos == tails.size()) {
            tails.add(c);
        } else {
            tails.set(pos, c);
        }
    }

    return tails.size();
}
```

### 6.2 Distinct Subsequences

```java
// Distinct Subsequences
public int numDistinct(String s, String t) {
    int m = s.length(), n = t.length();
    int[][] dp = new int[m + 1][n + 1];

    // Empty string t can be formed in 1 way from any string s
    for (int i = 0; i <= m; i++) {
        dp[i][0] = 1;
    }

    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            // Don't use current character of s
            dp[i][j] = dp[i - 1][j];

            // Use current character of s if it matches
            if (s.charAt(i - 1) == t.charAt(j - 1)) {
                dp[i][j] += dp[i - 1][j - 1];
            }
        }
    }

    return dp[m][n];
}

// Number of Distinct Subsequences II
public int distinctSubseqII(String s) {
    int MOD = 1000000007;
    int[] dp = new int[26]; // dp[i] = number of distinct subsequences ending with character i

    for (char c : s.toCharArray()) {
        int index = c - 'a';
        int newCount = 1; // The character itself

        // Add all existing subsequences + this character
        for (int count : dp) {
            newCount = (newCount + count) % MOD;
        }

        dp[index] = newCount;
    }

    int result = 0;
    for (int count : dp) {
        result = (result + count) % MOD;
    }

    return result;
}
```

---

## Pattern 7: String Transformation

### 7.1 Edit Distance Problems

```java
// Edit Distance (Levenshtein Distance)
public int minDistance(String word1, String word2) {
    int m = word1.length(), n = word2.length();
    int[][] dp = new int[m + 1][n + 1];

    // Base cases
    for (int i = 0; i <= m; i++) dp[i][0] = i;
    for (int j = 0; j <= n; j++) dp[0][j] = j;

    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                dp[i][j] = 1 + Math.min(
                    Math.min(dp[i - 1][j],     // Delete
                            dp[i][j - 1]),     // Insert
                    dp[i - 1][j - 1]           // Replace
                );
            }
        }
    }

    return dp[m][n];
}

// One Edit Distance
public boolean isOneEditDistance(String s, String t) {
    int m = s.length(), n = t.length();

    // Ensure s is shorter than t
    if (m > n) {
        return isOneEditDistance(t, s);
    }

    if (n - m > 1) return false;

    for (int i = 0; i < m; i++) {
        if (s.charAt(i) != t.charAt(i)) {
            if (m == n) {
                // Replace: check if rest of strings are same
                return s.substring(i + 1).equals(t.substring(i + 1));
            } else {
                // Insert: check if s[i:] equals t[i+1:]
                return s.substring(i).equals(t.substring(i + 1));
            }
        }
    }

    // All characters match, check if we need one insertion
    return m + 1 == n;
}

// Delete Operation for Two Strings
public int minDeleteOperations(String word1, String word2) {
    int lcs = longestCommonSubsequence(word1, word2);
    return word1.length() + word2.length() - 2 * lcs;
}
```

### 7.2 String Rotation and Reversal

```java
// Rotate String
public boolean rotateString(String s, String goal) {
    return s.length() == goal.length() && (s + s).contains(goal);
}

// Reverse Words in String
public String reverseWords(String s) {
    String[] words = s.trim().split("\\s+");
    StringBuilder result = new StringBuilder();

    for (int i = words.length - 1; i >= 0; i--) {
        result.append(words[i]);
        if (i > 0) result.append(" ");
    }

    return result.toString();
}

// Reverse Words in String III
public String reverseWordsInPlace(String s) {
    char[] chars = s.toCharArray();
    int start = 0;

    for (int end = 0; end <= chars.length; end++) {
        if (end == chars.length || chars[end] == ' ') {
            reverse(chars, start, end - 1);
            start = end + 1;
        }
    }

    return new String(chars);
}

private void reverse(char[] chars, int start, int end) {
    while (start < end) {
        char temp = chars[start];
        chars[start] = chars[end];
        chars[end] = temp;
        start++;
        end--;
    }
}
```

---

## Pattern 8: Parsing \& Validation

### 8.1 Number Validation

```java
// Valid Number
public boolean isNumber(String s) {
    s = s.trim();
    boolean numberSeen = false;
    boolean pointSeen = false;
    boolean eSeen = false;
    boolean numberAfterE = true;

    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);

        if (Character.isDigit(c)) {
            numberSeen = true;
            numberAfterE = true;
        } else if (c == '.') {
            if (eSeen || pointSeen) return false;
            pointSeen = true;
        } else if (c == 'e' || c == 'E') {
            if (eSeen || !numberSeen) return false;
            numberAfterE = false;
            eSeen = true;
        } else if (c == '-' || c == '+') {
            if (i != 0 && s.charAt(i - 1) != 'e' && s.charAt(i - 1) != 'E') {
                return false;
            }
        } else {
            return false;
        }
    }

    return numberSeen && numberAfterE;
}

// String to Integer (atoi)
public int myAtoi(String s) {
    int i = 0, n = s.length();

    // Skip whitespaces
    while (i < n && s.charAt(i) == ' ') i++;

    if (i >= n) return 0;

    // Handle sign
    int sign = 1;
    if (s.charAt(i) == '-' || s.charAt(i) == '+') {
        sign = s.charAt(i) == '-' ? -1 : 1;
        i++;
    }

    // Read number
    int result = 0;
    while (i < n && Character.isDigit(s.charAt(i))) {
        int digit = s.charAt(i) - '0';

        // Check overflow
        if (result > Integer.MAX_VALUE / 10 ||
            (result == Integer.MAX_VALUE / 10 && digit > Integer.MAX_VALUE % 10)) {
            return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;
        }

        result = result * 10 + digit;
        i++;
    }

    return sign * result;
}
```

### 8.2 Expression Validation

```java
// Valid Parentheses
public boolean isValid(String s) {
    Stack<Character> stack = new Stack<>();

    for (char c : s.toCharArray()) {
        if (c == '(' || c == '[' || c == '{') {
            stack.push(c);
        } else {
            if (stack.isEmpty()) return false;

            char top = stack.pop();
            if ((c == ')' && top != '(') ||
                (c == ']' && top != '[') ||
                (c == '}' && top != '{')) {
                return false;
            }
        }
    }

    return stack.isEmpty();
}

// Remove Invalid Parentheses
public List<String> removeInvalidParentheses(String s) {
    Set<String> visited = new HashSet<>();
    Queue<String> queue = new LinkedList<>();
    List<String> result = new ArrayList<>();

    queue.offer(s);
    visited.add(s);
    boolean found = false;

    while (!queue.isEmpty()) {
        String current = queue.poll();

        if (isValidParentheses(current)) {
            result.add(current);
            found = true;
        }

        if (found) continue; // Only find minimum removals

        // Generate all possible strings by removing one parenthesis
        for (int i = 0; i < current.length(); i++) {
            if (current.charAt(i) != '(' && current.charAt(i) != ')') continue;

            String next = current.substring(0, i) + current.substring(i + 1);
            if (!visited.contains(next)) {
                visited.add(next);
                queue.offer(next);
            }
        }
    }

    return result;
}

private boolean isValidParentheses(String s) {
    int count = 0;
    for (char c : s.toCharArray()) {
        if (c == '(') count++;
        else if (c == ')') {
            count--;
            if (count < 0) return false;
        }
    }
    return count == 0;
}
```

---

## Pattern 9: Trie-based String Problems

### 9.1 Trie Implementation

```java
// Trie Data Structure
class Trie {
    private TrieNode root;

    class TrieNode {
        Map<Character, TrieNode> children;
        boolean isEndOfWord;

        TrieNode() {
            children = new HashMap<>();
            isEndOfWord = false;
        }
    }

    public Trie() {
        root = new TrieNode();
    }

    public void insert(String word) {
        TrieNode current = root;

        for (char c : word.toCharArray()) {
            current.children.putIfAbsent(c, new TrieNode());
            current = current.children.get(c);
        }

        current.isEndOfWord = true;
    }

    public boolean search(String word) {
        TrieNode current = root;

        for (char c : word.toCharArray()) {
            if (!current.children.containsKey(c)) {
                return false;
            }
            current = current.children.get(c);
        }

        return current.isEndOfWord;
    }

    public boolean startsWith(String prefix) {
        TrieNode current = root;

        for (char c : prefix.toCharArray()) {
            if (!current.children.containsKey(c)) {
                return false;
            }
            current = current.children.get(c);
        }

        return true;
    }

    // Get all words with given prefix
    public List<String> getWordsWithPrefix(String prefix) {
        List<String> result = new ArrayList<>();
        TrieNode prefixNode = root;

        // Navigate to prefix node
        for (char c : prefix.toCharArray()) {
            if (!prefixNode.children.containsKey(c)) {
                return result;
            }
            prefixNode = prefixNode.children.get(c);
        }

        // DFS to find all words
        dfsCollectWords(prefixNode, prefix, result);
        return result;
    }

    private void dfsCollectWords(TrieNode node, String prefix, List<String> result) {
        if (node.isEndOfWord) {
            result.add(prefix);
        }

        for (Map.Entry<Character, TrieNode> entry : node.children.entrySet()) {
            dfsCollectWords(entry.getValue(), prefix + entry.getKey(), result);
        }
    }
}
```

### 9.2 Trie Applications

```java
// Word Search II
public List<String> findWords(char[][] board, String[] words) {
    Trie trie = new Trie();
    for (String word : words) {
        trie.insert(word);
    }

    Set<String> result = new HashSet<>();
    int m = board.length, n = board[0].length;
    boolean[][] visited = new boolean[m][n];

    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            dfs(board, i, j, trie.root, "", visited, result);
        }
    }

    return new ArrayList<>(result);
}

private void dfs(char[][] board, int i, int j, Trie.TrieNode node,
                String word, boolean[][] visited, Set<String> result) {
    if (i < 0 || i >= board.length || j < 0 || j >= board[0].length ||
        visited[i][j] || !node.children.containsKey(board[i][j])) {
        return;
    }

    visited[i][j] = true;
    char c = board[i][j];
    Trie.TrieNode child = node.children.get(c);
    String newWord = word + c;

    if (child.isEndOfWord) {
        result.add(newWord);
    }

    // Explore all directions
    int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    for (int[] dir : directions) {
        dfs(board, i + dir[0], j + dir[1], child, newWord, visited, result);
    }

    visited[i][j] = false; // Backtrack
}

// Replace Words
public String replaceWords(List<String> dictionary, String sentence) {
    Trie trie = new Trie();
    for (String root : dictionary) {
        trie.insert(root);
    }

    String[] words = sentence.split(" ");
    StringBuilder result = new StringBuilder();

    for (int i = 0; i < words.length; i++) {
        if (i > 0) result.append(" ");

        String replacement = findRoot(trie, words[i]);
        result.append(replacement != null ? replacement : words[i]);
    }

    return result.toString();
}

private String findRoot(Trie trie, String word) {
    Trie.TrieNode current = trie.root;
    StringBuilder root = new StringBuilder();

    for (char c : word.toCharArray()) {
        if (!current.children.containsKey(c)) {
            return null;
        }

        root.append(c);
        current = current.children.get(c);

        if (current.isEndOfWord) {
            return root.toString();
        }
    }

    return null;
}
```

---

## Pattern 10: String DP Problems

### 10.1 Advanced DP on Strings

```java
// Interleaving String
public boolean isInterleave(String s1, String s2, String s3) {
    if (s1.length() + s2.length() != s3.length()) return false;

    int m = s1.length(), n = s2.length();
    boolean[][] dp = new boolean[m + 1][n + 1];

    dp[0][0] = true;

    // Fill first row (only s2 characters)
    for (int j = 1; j <= n; j++) {
        dp[0][j] = dp[0][j - 1] && s2.charAt(j - 1) == s3.charAt(j - 1);
    }

    // Fill first column (only s1 characters)
    for (int i = 1; i <= m; i++) {
        dp[i][0] = dp[i - 1][0] && s1.charAt(i - 1) == s3.charAt(i - 1);
    }

    // Fill rest of table
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            dp[i][j] = (dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i + j - 1)) ||
                       (dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1));
        }
    }

    return dp[m][n];
}

// Scramble String
public boolean isScramble(String s1, String s2) {
    if (s1.length() != s2.length()) return false;
    if (s1.equals(s2)) return true;

    // Check if both strings have same characters
    int[] count = new int[26];
    for (int i = 0; i < s1.length(); i++) {
        count[s1.charAt(i) - 'a']++;
        count[s2.charAt(i) - 'a']--;
    }

    for (int c : count) {
        if (c != 0) return false;
    }

    // Try all possible splits
    for (int i = 1; i < s1.length(); i++) {
        // Case 1: No swap
        if (isScramble(s1.substring(0, i), s2.substring(0, i)) &&
            isScramble(s1.substring(i), s2.substring(i))) {
            return true;
        }

        // Case 2: Swap
        if (isScramble(s1.substring(0, i), s2.substring(s2.length() - i)) &&
            isScramble(s1.substring(i), s2.substring(0, s2.length() - i))) {
            return true;
        }
    }

    return false;
}
```

---

## Pattern 11: Advanced String Algorithms

### 11.1 Suffix Array and LCP

```java
// Longest Repeated Substring
public String longestRepeatedSubstring(String s) {
    int n = s.length();
    String longest = "";

    // Generate all suffixes and sort them
    String[] suffixes = new String[n];
    for (int i = 0; i < n; i++) {
        suffixes[i] = s.substring(i);
    }
    Arrays.sort(suffixes);

    // Find longest common prefix between adjacent suffixes
    for (int i = 0; i < n - 1; i++) {
        String lcp = longestCommonPrefix(suffixes[i], suffixes[i + 1]);
        if (lcp.length() > longest.length()) {
            longest = lcp;
        }
    }

    return longest;
}

private String longestCommonPrefix(String s1, String s2) {
    int minLen = Math.min(s1.length(), s2.length());
    for (int i = 0; i < minLen; i++) {
        if (s1.charAt(i) != s2.charAt(i)) {
            return s1.substring(0, i);
        }
    }
    return s1.substring(0, minLen);
}
```

### 11.2 Rolling Hash Applications

```java
// Longest Duplicate Substring (Rolling Hash)
public String longestDupSubstring(String s) {
    int n = s.length();
    String result = "";

    // Binary search on length
    int left = 1, right = n - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;
        String duplicate = searchDuplicate(s, mid);

        if (duplicate != null) {
            result = duplicate;
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return result;
}

private String searchDuplicate(String s, int len) {
    if (len == 0) return "";

    long base = 26;
    long mod = (long) Math.pow(2, 32);

    // Calculate hash for first window
    long hash = 0;
    long pow = 1;

    for (int i = 0; i < len; i++) {
        hash = (hash * base + (s.charAt(i) - 'a')) % mod;
        if (i < len - 1) pow = (pow * base) % mod;
    }

    Set<Long> seen = new HashSet<>();
    seen.add(hash);

    // Rolling hash
    for (int i = len; i < s.length(); i++) {
        hash = (hash - (s.charAt(i - len) - 'a') * pow % mod + mod) % mod;
        hash = (hash * base + (s.charAt(i) - 'a')) % mod;

        if (seen.contains(hash)) {
            return s.substring(i - len + 1, i + 1);
        }
        seen.add(hash);
    }

    return null;
}
```

---

## Pattern 12: String Compression \& Encoding

### 12.1 String Compression

```java
// String Compression
public int compress(char[] chars) {
    int write = 0, anchor = 0;

    for (int read = 0; read <= chars.length; read++) {
        if (read == chars.length || chars[read] != chars[anchor]) {
            chars[write++] = chars[anchor];

            if (read - anchor > 1) {
                String count = String.valueOf(read - anchor);
                for (char c : count.toCharArray()) {
                    chars[write++] = c;
                }
            }

            anchor = read;
        }
    }

    return write;
}

// Run Length Encoding
public String encode(String s) {
    StringBuilder encoded = new StringBuilder();
    int i = 0;

    while (i < s.length()) {
        char current = s.charAt(i);
        int count = 1;

        while (i + count < s.length() && s.charAt(i + count) == current) {
            count++;
        }

        encoded.append(current);
        if (count > 1) {
            encoded.append(count);
        }

        i += count;
    }

    return encoded.toString();
}

// Run Length Decoding
public String decode(String s) {
    StringBuilder decoded = new StringBuilder();
    int i = 0;

    while (i < s.length()) {
        char c = s.charAt(i++);
        int count = 1;

        // Check if next characters form a number
        if (i < s.length() && Character.isDigit(s.charAt(i))) {
            count = 0;
            while (i < s.length() && Character.isDigit(s.charAt(i))) {
                count = count * 10 + (s.charAt(i) - '0');
                i++;
            }
        }

        for (int j = 0; j < count; j++) {
            decoded.append(c);
        }
    }

    return decoded.toString();
}
```

### 12.2 String Encoding Problems

```java
// Encode and Decode Strings
public class Codec {

    // Encodes a list of strings to a single string
    public String encode(List<String> strs) {
        StringBuilder encoded = new StringBuilder();

        for (String str : strs) {
            encoded.append(str.length()).append("#").append(str);
        }

        return encoded.toString();
    }

    // Decodes a single string to a list of strings
    public List<String> decode(String s) {
        List<String> decoded = new ArrayList<>();
        int i = 0;

        while (i < s.length()) {
            // Find the delimiter
            int delimiterPos = s.indexOf('#', i);
            int length = Integer.parseInt(s.substring(i, delimiterPos));

            // Extract the string
            String str = s.substring(delimiterPos + 1, delimiterPos + 1 + length);
            decoded.add(str);

            i = delimiterPos + 1 + length;
        }

        return decoded;
    }
}

// Count and Say
public String countAndSay(int n) {
    String current = "1";

    for (int i = 2; i <= n; i++) {
        current = getNextSequence(current);
    }

    return current;
}

private String getNextSequence(String s) {
    StringBuilder next = new StringBuilder();
    int i = 0;

    while (i < s.length()) {
        char digit = s.charAt(i);
        int count = 1;

        while (i + count < s.length() && s.charAt(i + count) == digit) {
            count++;
        }

        next.append(count).append(digit);
        i += count;
    }

    return next.toString();
}
```

---

## Time \& Space Complexity Reference

| Pattern             | Time Complexity | Space Complexity         | Key Characteristics                          |
| :------------------ | :-------------- | :----------------------- | :------------------------------------------- |
| Two Pointers        | O(n)            | O(1)                     | Linear scan with constant space              |
| Sliding Window      | O(n)            | O(k)                     | Single pass with window state                |
| KMP Algorithm       | O(m + n)        | O(m)                     | Preprocessing pattern for efficient matching |
| Palindrome (Expand) | O(n²)           | O(1)                     | Check all possible centers                   |
| Anagram Detection   | O(n)            | O(1)                     | Character frequency comparison               |
| Edit Distance       | O(m × n)        | O(m × n)                 | Dynamic programming approach                 |
| Trie Operations     | O(m)            | O(ALPHABET_SIZE × N × M) | m = word length, N = number of words         |
| String DP           | O(n²) to O(n³)  | O(n²)                    | Depends on problem complexity                |
| Rolling Hash        | O(n)            | O(1)                     | Polynomial hash for pattern matching         |
| String Compression  | O(n)            | O(1)                     | Single pass compression                      |

---

## Best Practices \& Optimization Tips

### String Algorithm Guidelines

```java
// 1. Choose appropriate string representation
StringBuilder sb = new StringBuilder(); // For multiple concatenations
StringBuffer sbf = new StringBuffer();  // For thread-safe operations
String str = "constant";                // For immutable strings

// 2. Use character arrays for in-place modifications
public void processString(String s) {
    char[] chars = s.toCharArray();
    // Modify chars array
    String result = new String(chars);
}

// 3. Optimize character frequency counting
public Map<Character, Integer> optimizedFrequency(String s) {
    // For ASCII characters only
    int[] freq = new int[128];
    for (char c : s.toCharArray()) {
        freq[c]++;
    }

    // Convert back to map if needed
    Map<Character, Integer> map = new HashMap<>();
    for (int i = 0; i < freq.length; i++) {
        if (freq[i] > 0) {
            map.put((char) i, freq[i]);
        }
    }
    return map;
}

// 4. Use appropriate algorithms for string matching
public boolean containsPattern(String text, String pattern) {
    // For single search: built-in indexOf is optimized
    return text.contains(pattern);

    // For multiple searches: use KMP or build suffix array
    // For approximate matching: use edit distance
}
```

### Common Pitfalls to Avoid

1. **String immutability**: Remember strings are immutable in Java
2. **Character encoding**: Be careful with Unicode vs ASCII
3. **Null checks**: Always validate input strings
4. **Case sensitivity**: Use appropriate comparison methods
5. **Memory usage**: Avoid creating unnecessary string objects

### Interview Tips[8][3]

- **Identify the pattern** early: palindrome, anagram, subsequence, etc.
- **Consider edge cases**: empty strings, single characters, special characters
- **Choose optimal algorithms**: KMP for pattern matching, sliding window for substrings
- **Think about space optimization**: in-place vs extra space trade-offs
- **Practice string manipulation**: StringBuilder usage, character arrays
