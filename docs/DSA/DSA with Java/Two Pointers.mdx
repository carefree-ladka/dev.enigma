# Two Pointers

## Table of Contents

1. [Two Pointers Fundamentals](#two-pointers-fundamentals)
2. [Pattern 1: Opposite Direction Pointers](#pattern-1-opposite-direction-pointers)
3. [Pattern 2: Same Direction Pointers](#pattern-2-same-direction-pointers)
4. [Pattern 3: Fast and Slow Pointers](#pattern-3-fast-and-slow-pointers)
5. [Pattern 4: Two Pointers for Sorting](#pattern-4-two-pointers-for-sorting)
6. [Pattern 5: Two Pointers with HashMap](#pattern-5-two-pointers-with-hashmap)
7. [Pattern 6: Multiple Arrays Two Pointers](#pattern-6-multiple-arrays-two-pointers)
8. [Pattern 7: Linked List Two Pointers](#pattern-7-linked-list-two-pointers)
9. [Pattern 8: String Manipulation with Two Pointers](#pattern-8-string-manipulation-with-two-pointers)
10. [Pattern 9: Advanced Two Pointers Techniques](#pattern-9-advanced-two-pointers-techniques)
11. [Pattern 10: Matrix and 2D Two Pointers](#pattern-10-matrix-and-2d-two-pointers)
12. [Pattern 11: Optimization Techniques](#pattern-11-optimization-techniques)

***

## Two Pointers Fundamentals

### Core Concepts and Implementation

```java
// Basic Two Pointers Implementation Templates
public class TwoPointersFundamentals {

    // Template 1: Opposite Direction Pointers (Meet in the middle)
    public static class OppositeDirectionTemplate {

        // Generic template for opposite direction pointers
        public boolean oppositeDirectionTemplate(int[] nums, int target) {
            int left = 0;
            int right = nums.length - 1;

            while (left < right) {
                int sum = nums[left] + nums[right];

                if (sum == target) {
                    return true;
                } else if (sum < target) {
                    left++; // Need larger sum
                } else {
                    right--; // Need smaller sum
                }
            }

            return false;
        }

        // Two Sum in sorted array
        public int[] twoSum(int[] nums, int target) {
            int left = 0, right = nums.length - 1;

            while (left < right) {
                int sum = nums[left] + nums[right];

                if (sum == target) {
                    return new int[]{left, right};
                } else if (sum < target) {
                    left++;
                } else {
                    right--;
                }
            }

            return new int[]{-1, -1};
        }

        // Valid Palindrome
        public boolean isPalindrome(String s) {
            int left = 0, right = s.length() - 1;

            while (left < right) {
                // Skip non-alphanumeric characters
                while (left < right && !Character.isAlphaNumeric(s.charAt(left))) {
                    left++;
                }
                while (left < right && !Character.isAlphaNumeric(s.charAt(right))) {
                    right--;
                }

                if (Character.toLowerCase(s.charAt(left)) !=
                    Character.toLowerCase(s.charAt(right))) {
                    return false;
                }

                left++;
                right--;
            }

            return true;
        }
    }

    // Template 2: Same Direction Pointers
    public static class SameDirectionTemplate {

        // Generic template for same direction pointers
        public int sameDirectionTemplate(int[] nums, int condition) {
            int slow = 0; // Slow pointer for valid elements

            for (int fast = 0; fast < nums.length; fast++) {
                if (nums[fast] != condition) { // or any other condition
                    nums[slow] = nums[fast];
                    slow++;
                }
            }

            return slow; // New length or count
        }

        // Remove Element
        public int removeElement(int[] nums, int val) {
            int slow = 0;

            for (int fast = 0; fast < nums.length; fast++) {
                if (nums[fast] != val) {
                    nums[slow] = nums[fast];
                    slow++;
                }
            }

            return slow;
        }

        // Remove Duplicates from Sorted Array
        public int removeDuplicates(int[] nums) {
            if (nums.length == 0) return 0;

            int slow = 1; // Start from second position

            for (int fast = 1; fast < nums.length; fast++) {
                if (nums[fast] != nums[fast - 1]) {
                    nums[slow] = nums[fast];
                    slow++;
                }
            }

            return slow;
        }
    }

    // Template 3: Fast and Slow Pointers (Floyd's Algorithm)
    public static class FastSlowTemplate {

        // Generic cycle detection template
        public boolean hasCycle(ListNode head) {
            if (head == null || head.next == null) return false;

            ListNode slow = head;
            ListNode fast = head;

            while (fast != null && fast.next != null) {
                slow = slow.next;        // Move slow pointer one step
                fast = fast.next.next;   // Move fast pointer two steps

                if (slow == fast) {
                    return true; // Cycle detected
                }
            }

            return false;
        }

        // Find middle of linked list
        public ListNode findMiddle(ListNode head) {
            if (head == null) return null;

            ListNode slow = head;
            ListNode fast = head;

            while (fast != null && fast.next != null) {
                slow = slow.next;
                fast = fast.next.next;
            }

            return slow; // Middle node
        }
    }

    // Utility class for common two pointers operations
    public static class TwoPointersUtils {

        // Check if two pointers technique is applicable
        public static boolean isApplicable(String problemDescription) {
            String[] keywords = {
                "two sum", "pair", "sorted array", "palindrome",
                "remove", "duplicate", "cycle", "middle",
                "merge", "intersection", "triplet"
            };

            String lowerDesc = problemDescription.toLowerCase();
            return Arrays.stream(keywords).anyMatch(lowerDesc::contains);
        }

        // Determine appropriate two pointers technique
        public static String determineTechnique(boolean isSorted, boolean sameDirNeeded,
                                               boolean cycleDetection) {
            if (cycleDetection) {
                return "Fast and Slow Pointers";
            } else if (isSorted) {
                return "Opposite Direction Pointers";
            } else if (sameDirNeeded) {
                return "Same Direction Pointers";
            } else {
                return "Custom Two Pointers Approach";
            }
        }

        // Debug helper for two pointers
        public static void debugPointers(int[] nums, int left, int right, String operation) {
            System.out.printf("%s: left=%d (val=%d), right=%d (val=%d)%n",
                            operation, left,
                            left < nums.length ? nums[left] : -1,
                            right,
                            right < nums.length ? nums[right] : -1);
        }
    }
}
```


***

## Pattern 1: Opposite Direction Pointers

### 1.1 Two Sum Problems

```java
// Opposite direction pointers for sorted arrays
public class OppositeDirectionPointers {

    // Two Sum in sorted array
    public int[] twoSum(int[] numbers, int target) {
        int left = 0, right = numbers.length - 1;

        while (left < right) {
            int sum = numbers[left] + numbers[right];

            if (sum == target) {
                return new int[]{left + 1, right + 1}; // 1-indexed
            } else if (sum < target) {
                left++;
            } else {
                right--;
            }
        }

        return new int[]{-1, -1}; // No solution found
    }

    // Three Sum
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> result = new ArrayList<>();

        for (int i = 0; i < nums.length - 2; i++) {
            // Skip duplicates for first element
            if (i > 0 && nums[i] == nums[i - 1]) continue;

            int left = i + 1, right = nums.length - 1;
            int target = -nums[i];

            while (left < right) {
                int sum = nums[left] + nums[right];

                if (sum == target) {
                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));

                    // Skip duplicates
                    while (left < right && nums[left] == nums[left + 1]) left++;
                    while (left < right && nums[right] == nums[right - 1]) right--;

                    left++;
                    right--;
                } else if (sum < target) {
                    left++;
                } else {
                    right--;
                }
            }
        }

        return result;
    }

    // Three Sum Closest
    public int threeSumClosest(int[] nums, int target) {
        Arrays.sort(nums);
        int closestSum = nums[^20_0] + nums[^20_1] + nums[^20_2];

        for (int i = 0; i < nums.length - 2; i++) {
            int left = i + 1, right = nums.length - 1;

            while (left < right) {
                int currentSum = nums[i] + nums[left] + nums[right];

                if (Math.abs(currentSum - target) < Math.abs(closestSum - target)) {
                    closestSum = currentSum;
                }

                if (currentSum < target) {
                    left++;
                } else if (currentSum > target) {
                    right--;
                } else {
                    return currentSum; // Exact match
                }
            }
        }

        return closestSum;
    }

    // Four Sum
    public List<List<Integer>> fourSum(int[] nums, int target) {
        Arrays.sort(nums);
        List<List<Integer>> result = new ArrayList<>();

        for (int i = 0; i < nums.length - 3; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) continue;

            for (int j = i + 1; j < nums.length - 2; j++) {
                if (j > i + 1 && nums[j] == nums[j - 1]) continue;

                int left = j + 1, right = nums.length - 1;
                long remaining = (long) target - nums[i] - nums[j];

                while (left < right) {
                    long sum = nums[left] + nums[right];

                    if (sum == remaining) {
                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));

                        while (left < right && nums[left] == nums[left + 1]) left++;
                        while (left < right && nums[right] == nums[right - 1]) right--;

                        left++;
                        right--;
                    } else if (sum < remaining) {
                        left++;
                    } else {
                        right--;
                    }
                }
            }
        }

        return result;
    }

    // Container With Most Water
    public int maxArea(int[] height) {
        int left = 0, right = height.length - 1;
        int maxWater = 0;

        while (left < right) {
            int width = right - left;
            int currentWater = Math.min(height[left], height[right]) * width;
            maxWater = Math.max(maxWater, currentWater);

            // Move pointer with smaller height
            if (height[left] < height[right]) {
                left++;
            } else {
                right--;
            }
        }

        return maxWater;
    }

    // Trapping Rain Water
    public int trap(int[] height) {
        if (height.length < 3) return 0;

        int left = 0, right = height.length - 1;
        int leftMax = 0, rightMax = 0;
        int water = 0;

        while (left < right) {
            if (height[left] < height[right]) {
                if (height[left] >= leftMax) {
                    leftMax = height[left];
                } else {
                    water += leftMax - height[left];
                }
                left++;
            } else {
                if (height[right] >= rightMax) {
                    rightMax = height[right];
                } else {
                    water += rightMax - height[right];
                }
                right--;
            }
        }

        return water;
    }

    // Valid Palindrome
    public boolean isPalindrome(String s) {
        int left = 0, right = s.length() - 1;

        while (left < right) {
            while (left < right && !Character.isAlphabetic(s.charAt(left)) &&
                   !Character.isDigit(s.charAt(left))) {
                left++;
            }

            while (left < right && !Character.isAlphabetic(s.charAt(right)) &&
                   !Character.isDigit(s.charAt(right))) {
                right--;
            }

            if (Character.toLowerCase(s.charAt(left)) !=
                Character.toLowerCase(s.charAt(right))) {
                return false;
            }

            left++;
            right--;
        }

        return true;
    }

    // Reverse String
    public void reverseString(char[] s) {
        int left = 0, right = s.length - 1;

        while (left < right) {
            char temp = s[left];
            s[left] = s[right];
            s[right] = temp;

            left++;
            right--;
        }
    }
}
```


### 1.2 Advanced Opposite Direction Problems

```java
// Advanced opposite direction pointer problems
public class AdvancedOppositeDirection {

    // Squares of a Sorted Array
    public int[] sortedSquares(int[] nums) {
        int[] result = new int[nums.length];
        int left = 0, right = nums.length - 1;
        int index = nums.length - 1; // Fill from the end

        while (left <= right) {
            int leftSquare = nums[left] * nums[left];
            int rightSquare = nums[right] * nums[right];

            if (leftSquare > rightSquare) {
                result[index] = leftSquare;
                left++;
            } else {
                result[index] = rightSquare;
                right--;
            }
            index--;
        }

        return result;
    }

    // Sort Colors (Dutch National Flag)
    public void sortColors(int[] nums) {
        int low = 0, mid = 0, high = nums.length - 1;

        while (mid <= high) {
            if (nums[mid] == 0) {
                swap(nums, low, mid);
                low++;
                mid++;
            } else if (nums[mid] == 1) {
                mid++;
            } else { // nums[mid] == 2
                swap(nums, mid, high);
                high--;
                // Don't increment mid as we need to check swapped element
            }
        }
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }

    // Next Permutation
    public void nextPermutation(int[] nums) {
        int i = nums.length - 2;

        // Find first decreasing element from right
        while (i >= 0 && nums[i] >= nums[i + 1]) {
            i--;
        }

        if (i >= 0) {
            int j = nums.length - 1;
            // Find element just larger than nums[i]
            while (nums[j] <= nums[i]) {
                j--;
            }
            swap(nums, i, j);
        }

        // Reverse the suffix
        reverse(nums, i + 1, nums.length - 1);
    }

    private void reverse(int[] nums, int start, int end) {
        while (start < end) {
            swap(nums, start, end);
            start++;
            end--;
        }
    }

    // Minimum Window Substring
    public String minWindow(String s, String t) {
        Map<Character, Integer> targetCount = new HashMap<>();
        for (char c : t.toCharArray()) {
            targetCount.put(c, targetCount.getOrDefault(c, 0) + 1);
        }

        Map<Character, Integer> windowCount = new HashMap<>();
        int left = 0, minLength = Integer.MAX_VALUE, minStart = 0;
        int formed = 0, required = targetCount.size();

        for (int right = 0; right < s.length(); right++) {
            char c = s.charAt(right);
            windowCount.put(c, windowCount.getOrDefault(c, 0) + 1);

            if (targetCount.containsKey(c) &&
                windowCount.get(c).intValue() == targetCount.get(c).intValue()) {
                formed++;
            }

            // Shrink window while valid
            while (left <= right && formed == required) {
                if (right - left + 1 < minLength) {
                    minLength = right - left + 1;
                    minStart = left;
                }

                char leftChar = s.charAt(left);
                windowCount.put(leftChar, windowCount.get(leftChar) - 1);
                if (targetCount.containsKey(leftChar) &&
                    windowCount.get(leftChar) < targetCount.get(leftChar)) {
                    formed--;
                }
                left++;
            }
        }

        return minLength == Integer.MAX_VALUE ? "" : s.substring(minStart, minStart + minLength);
    }

    // 3Sum Smaller
    public int threeSumSmaller(int[] nums, int target) {
        Arrays.sort(nums);
        int count = 0;

        for (int i = 0; i < nums.length - 2; i++) {
            int left = i + 1, right = nums.length - 1;

            while (left < right) {
                int sum = nums[i] + nums[left] + nums[right];

                if (sum < target) {
                    // All pairs between left and right are valid
                    count += right - left;
                    left++;
                } else {
                    right--;
                }
            }
        }

        return count;
    }

    // Boats to Save People
    public int numRescueBoats(int[] people, int limit) {
        Arrays.sort(people);
        int left = 0, right = people.length - 1;
        int boats = 0;

        while (left <= right) {
            if (left == right) {
                boats++;
                break;
            }

            if (people[left] + people[right] <= limit) {
                left++; // Both people can go
            }
            right--; // Heavier person always goes
            boats++;
        }

        return boats;
    }

    // Partition Labels
    public List<Integer> partitionLabels(String s) {
        Map<Character, Integer> lastIndex = new HashMap<>();

        // Record last occurrence of each character
        for (int i = 0; i < s.length(); i++) {
            lastIndex.put(s.charAt(i), i);
        }

        List<Integer> result = new ArrayList<>();
        int start = 0, end = 0;

        for (int i = 0; i < s.length(); i++) {
            end = Math.max(end, lastIndex.get(s.charAt(i)));

            if (i == end) {
                result.add(end - start + 1);
                start = end + 1;
            }
        }

        return result;
    }
}
```


***

## Pattern 2: Same Direction Pointers

### 2.1 Array Modification Problems

```java
// Same direction pointers for in-place array modifications
public class SameDirectionPointers {

    // Remove Element
    public int removeElement(int[] nums, int val) {
        int slow = 0; // Position for next valid element

        for (int fast = 0; fast < nums.length; fast++) {
            if (nums[fast] != val) {
                nums[slow] = nums[fast];
                slow++;
            }
        }

        return slow;
    }

    // Remove Duplicates from Sorted Array
    public int removeDuplicates(int[] nums) {
        if (nums.length == 0) return 0;

        int slow = 1; // Start from second position

        for (int fast = 1; fast < nums.length; fast++) {
            if (nums[fast] != nums[fast - 1]) {
                nums[slow] = nums[fast];
                slow++;
            }
        }

        return slow;
    }

    // Remove Duplicates II (allow at most 2 duplicates)
    public int removeDuplicates2(int[] nums) {
        if (nums.length <= 2) return nums.length;

        int slow = 2; // Start from third position

        for (int fast = 2; fast < nums.length; fast++) {
            if (nums[fast] != nums[slow - 2]) {
                nums[slow] = nums[fast];
                slow++;
            }
        }

        return slow;
    }

    // Move Zeroes
    public void moveZeroes(int[] nums) {
        int slow = 0; // Position for next non-zero element

        // Move all non-zero elements to front
        for (int fast = 0; fast < nums.length; fast++) {
            if (nums[fast] != 0) {
                nums[slow] = nums[fast];
                slow++;
            }
        }

        // Fill remaining positions with zeros
        while (slow < nums.length) {
            nums[slow] = 0;
            slow++;
        }
    }

    // Move Zeroes (optimized with swapping)
    public void moveZeroesOptimized(int[] nums) {
        int slow = 0;

        for (int fast = 0; fast < nums.length; fast++) {
            if (nums[fast] != 0) {
                if (slow != fast) { // Avoid unnecessary swaps
                    int temp = nums[slow];
                    nums[slow] = nums[fast];
                    nums[fast] = temp;
                }
                slow++;
            }
        }
    }

    // Sort Array by Parity
    public int[] sortArrayByParity(int[] nums) {
        int slow = 0; // Position for next even number

        for (int fast = 0; fast < nums.length; fast++) {
            if (nums[fast] % 2 == 0) { // Even number
                int temp = nums[slow];
                nums[slow] = nums[fast];
                nums[fast] = temp;
                slow++;
            }
        }

        return nums;
    }

    // Sort Array by Parity II
    public int[] sortArrayByParityII(int[] nums) {
        int evenIndex = 0, oddIndex = 1;
        int[] result = new int[nums.length];

        for (int num : nums) {
            if (num % 2 == 0) {
                result[evenIndex] = num;
                evenIndex += 2;
            } else {
                result[oddIndex] = num;
                oddIndex += 2;
            }
        }

        return result;
    }

    // Backspace String Compare
    public boolean backspaceCompare(String s, String t) {
        return processString(s).equals(processString(t));
    }

    private String processString(String str) {
        StringBuilder sb = new StringBuilder();

        for (char c : str.toCharArray()) {
            if (c == '#') {
                if (sb.length() > 0) {
                    sb.deleteCharAt(sb.length() - 1);
                }
            } else {
                sb.append(c);
            }
        }

        return sb.toString();
    }

    // Backspace String Compare (optimized with two pointers)
    public boolean backspaceCompareOptimized(String s, String t) {
        int i = s.length() - 1;
        int j = t.length() - 1;

        while (i >= 0 || j >= 0) {
            i = getNextValidIndex(s, i);
            j = getNextValidIndex(t, j);

            if (i < 0 && j < 0) return true;
            if (i < 0 || j < 0) return false;
            if (s.charAt(i) != t.charAt(j)) return false;

            i--;
            j--;
        }

        return true;
    }

    private int getNextValidIndex(String str, int index) {
        int skip = 0;

        while (index >= 0) {
            if (str.charAt(index) == '#') {
                skip++;
            } else if (skip > 0) {
                skip--;
            } else {
                break;
            }
            index--;
        }

        return index;
    }
}
```


### 2.2 Advanced Same Direction Problems

```java
// Advanced same direction pointer problems
public class AdvancedSameDirection {

    // Shortest Unsorted Continuous Subarray
    public int findUnsortedSubarray(int[] nums) {
        int n = nums.length;
        int left = -1, right = -1;
        int max = Integer.MIN_VALUE, min = Integer.MAX_VALUE;

        // Find rightmost element that's out of place
        for (int i = 0; i < n; i++) {
            if (nums[i] >= max) {
                max = nums[i];
            } else {
                right = i;
            }
        }

        // Find leftmost element that's out of place
        for (int i = n - 1; i >= 0; i--) {
            if (nums[i] <= min) {
                min = nums[i];
            } else {
                left = i;
            }
        }

        return left == -1 ? 0 : right - left + 1;
    }

    // Merge Sorted Array
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int i = m - 1, j = n - 1, k = m + n - 1;

        // Merge from the end to avoid overwriting
        while (i >= 0 && j >= 0) {
            if (nums1[i] > nums2[j]) {
                nums1[k] = nums1[i];
                i--;
            } else {
                nums1[k] = nums2[j];
                j--;
            }
            k--;
        }

        // Copy remaining elements from nums2
        while (j >= 0) {
            nums1[k] = nums2[j];
            j--;
            k--;
        }
    }

    // Find All Duplicates in Array
    public List<Integer> findDuplicates(int[] nums) {
        List<Integer> result = new ArrayList<>();

        // Use array indices as hash keys
        for (int i = 0; i < nums.length; i++) {
            int index = Math.abs(nums[i]) - 1;

            if (nums[index] < 0) {
                result.add(Math.abs(nums[i])); // Duplicate found
            } else {
                nums[index] = -nums[index]; // Mark as seen
            }
        }

        return result;
    }

    // First Missing Positive
    public int firstMissingPositive(int[] nums) {
        int n = nums.length;

        // Replace negative numbers and zeros with n+1
        for (int i = 0; i < n; i++) {
            if (nums[i] <= 0) {
                nums[i] = n + 1;
            }
        }

        // Mark presence of numbers
        for (int i = 0; i < n; i++) {
            int num = Math.abs(nums[i]);
            if (num <= n) {
                nums[num - 1] = -Math.abs(nums[num - 1]);
            }
        }

        // Find first positive number
        for (int i = 0; i < n; i++) {
            if (nums[i] > 0) {
                return i + 1;
            }
        }

        return n + 1;
    }

    // Array Partition I
    public int arrayPairSum(int[] nums) {
        Arrays.sort(nums);
        int sum = 0;

        // Take every alternate element starting from first
        for (int i = 0; i < nums.length; i += 2) {
            sum += nums[i];
        }

        return sum;
    }

    // Max Consecutive Ones
    public int findMaxConsecutiveOnes(int[] nums) {
        int maxCount = 0, currentCount = 0;

        for (int num : nums) {
            if (num == 1) {
                currentCount++;
                maxCount = Math.max(maxCount, currentCount);
            } else {
                currentCount = 0;
            }
        }

        return maxCount;
    }

    // Max Consecutive Ones II (with at most one flip)
    public int findMaxConsecutiveOnesII(int[] nums) {
        int maxLength = 0, zeroCount = 0;
        int left = 0;

        for (int right = 0; right < nums.length; right++) {
            if (nums[right] == 0) {
                zeroCount++;
            }

            // Shrink window if more than one zero
            while (zeroCount > 1) {
                if (nums[left] == 0) {
                    zeroCount--;
                }
                left++;
            }

            maxLength = Math.max(maxLength, right - left + 1);
        }

        return maxLength;
    }

    // Minimum Size Subarray Sum
    public int minSubArrayLen(int target, int[] nums) {
        int left = 0, sum = 0;
        int minLength = Integer.MAX_VALUE;

        for (int right = 0; right < nums.length; right++) {
            sum += nums[right];

            while (sum >= target) {
                minLength = Math.min(minLength, right - left + 1);
                sum -= nums[left];
                left++;
            }
        }

        return minLength == Integer.MAX_VALUE ? 0 : minLength;
    }
}
```


***

## Pattern 3: Fast and Slow Pointers

### 3.1 Linked List Cycle Detection

```java
// Fast and slow pointers for linked list problems
public class FastSlowPointers {

    static class ListNode {
        int val;
        ListNode next;

        ListNode() {}
        ListNode(int val) { this.val = val; }
        ListNode(int val, ListNode next) { this.val = val; this.next = next; }
    }

    // Linked List Cycle
    public boolean hasCycle(ListNode head) {
        if (head == null || head.next == null) return false;

        ListNode slow = head;
        ListNode fast = head;

        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;

            if (slow == fast) {
                return true;
            }
        }

        return false;
    }

    // Linked List Cycle II (find start of cycle)
    public ListNode detectCycle(ListNode head) {
        if (head == null || head.next == null) return null;

        ListNode slow = head;
        ListNode fast = head;

        // Find meeting point
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;

            if (slow == fast) {
                break;
            }
        }

        if (fast == null || fast.next == null) return null; // No cycle

        // Find start of cycle
        slow = head;
        while (slow != fast) {
            slow = slow.next;
            fast = fast.next;
        }

        return slow;
    }

    // Middle of Linked List
    public ListNode middleNode(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;

        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }

        return slow;
    }

    // Palindrome Linked List
    public boolean isPalindrome(ListNode head) {
        if (head == null || head.next == null) return true;

        // Find middle
        ListNode slow = head;
        ListNode fast = head;

        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }

        // Reverse second half
        ListNode secondHalf = reverseList(slow.next);

        // Compare both halves
        ListNode firstHalf = head;
        while (secondHalf != null) {
            if (firstHalf.val != secondHalf.val) {
                return false;
            }
            firstHalf = firstHalf.next;
            secondHalf = secondHalf.next;
        }

        return true;
    }

    private ListNode reverseList(ListNode head) {
        ListNode prev = null;
        ListNode current = head;

        while (current != null) {
            ListNode next = current.next;
            current.next = prev;
            prev = current;
            current = next;
        }

        return prev;
    }

    // Remove Nth Node From End
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;

        ListNode slow = dummy;
        ListNode fast = dummy;

        // Move fast pointer n+1 steps ahead
        for (int i = 0; i <= n; i++) {
            fast = fast.next;
        }

        // Move both pointers until fast reaches end
        while (fast != null) {
            slow = slow.next;
            fast = fast.next;
        }

        // Remove nth node
        slow.next = slow.next.next;

        return dummy.next;
    }

    // Reorder List
    public void reorderList(ListNode head) {
        if (head == null || head.next == null) return;

        // Find middle
        ListNode slow = head;
        ListNode fast = head;

        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }

        // Split and reverse second half
        ListNode secondHalf = reverseList(slow.next);
        slow.next = null;

        // Merge two halves
        ListNode first = head;
        while (secondHalf != null) {
            ListNode temp1 = first.next;
            ListNode temp2 = secondHalf.next;

            first.next = secondHalf;
            secondHalf.next = temp1;

            first = temp1;
            secondHalf = temp2;
        }
    }

    // Intersection of Two Linked Lists
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if (headA == null || headB == null) return null;

        ListNode ptrA = headA;
        ListNode ptrB = headB;

        // When one pointer reaches end, redirect to other list's head
        while (ptrA != ptrB) {
            ptrA = (ptrA == null) ? headB : ptrA.next;
            ptrB = (ptrB == null) ? headA : ptrB.next;
        }

        return ptrA; // Either intersection point or null
    }

    // Happy Number (cycle detection in numbers)
    public boolean isHappy(int n) {
        int slow = n;
        int fast = n;

        do {
            slow = getNext(slow);
            fast = getNext(getNext(fast));
        } while (slow != fast);

        return slow == 1;
    }

    private int getNext(int n) {
        int totalSum = 0;
        while (n > 0) {
            int digit = n % 10;
            totalSum += digit * digit;
            n /= 10;
        }
        return totalSum;
    }

    // Find Duplicate Number (Floyd's Algorithm)
    public int findDuplicate(int[] nums) {
        // Phase 1: Find intersection point
        int slow = nums[^20_0];
        int fast = nums[^20_0];

        do {
            slow = nums[slow];
            fast = nums[nums[fast]];
        } while (slow != fast);

        // Phase 2: Find entrance to cycle
        slow = nums[^20_0];
        while (slow != fast) {
            slow = nums[slow];
            fast = nums[fast];
        }

        return slow;
    }
}
```


### 3.2 Advanced Fast and Slow Pointer Problems

```java
// Advanced fast and slow pointer applications
public class AdvancedFastSlowPointers {

    // Circular Array Loop
    public boolean circularArrayLoop(int[] nums) {
        int n = nums.length;

        for (int i = 0; i < n; i++) {
            if (nums[i] == 0) continue;

            int slow = i, fast = i;
            boolean isForward = nums[i] > 0;

            // Check for cycle using Floyd's algorithm
            do {
                slow = getNextIndex(nums, slow, isForward);
                if (slow == -1) break;

                fast = getNextIndex(nums, fast, isForward);
                if (fast == -1) break;

                fast = getNextIndex(nums, fast, isForward);
                if (fast == -1) break;

            } while (slow != fast);

            if (slow != -1 && slow == fast) {
                return true;
            }

            // Mark visited elements as 0
            int curr = i;
            while (nums[curr] != 0 && ((nums[curr] > 0) == isForward)) {
                int next = getNextIndex(nums, curr, isForward);
                nums[curr] = 0;
                curr = next;
            }
        }

        return false;
    }

    private int getNextIndex(int[] nums, int curr, boolean isForward) {
        boolean direction = nums[curr] > 0;

        if (direction != isForward) return -1; // Direction change

        int next = (curr + nums[curr]) % nums.length;
        if (next < 0) next += nums.length;

        if (next == curr) return -1; // Single element loop

        return next;
    }

    // Rotate Array
    public void rotate(int[] nums, int k) {
        k = k % nums.length;
        if (k == 0) return;

        // Use cycle detection approach
        int count = 0;

        for (int start = 0; count < nums.length; start++) {
            int current = start;
            int prev = nums[start];

            do {
                int next = (current + k) % nums.length;
                int temp = nums[next];
                nums[next] = prev;
                prev = temp;
                current = next;
                count++;
            } while (start != current);
        }
    }

    // Split Linked List in Parts
    public ListNode[] splitListToParts(ListNode head, int k) {
        // Count total length
        int length = 0;
        ListNode curr = head;
        while (curr != null) {
            length++;
            curr = curr.next;
        }

        int partSize = length / k;
        int extraParts = length % k;

        ListNode[] result = new ListNode[k];
        curr = head;

        for (int i = 0; i < k && curr != null; i++) {
            result[i] = curr;
            int currentPartSize = partSize + (i < extraParts ? 1 : 0);

            for (int j = 1; j < currentPartSize; j++) {
                curr = curr.next;
            }

            ListNode next = curr.next;
            curr.next = null;
            curr = next;
        }

        return result;
    }

    // Swap Nodes in Pairs
    public ListNode swapPairs(ListNode head) {
        if (head == null || head.next == null) return head;

        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode prev = dummy;

        while (prev.next != null && prev.next.next != null) {
            ListNode first = prev.next;
            ListNode second = prev.next.next;

            // Swap
            prev.next = second;
            first.next = second.next;
            second.next = first;

            prev = first;
        }

        return dummy.next;
    }

    // Odd Even Linked List
    public ListNode oddEvenList(ListNode head) {
        if (head == null || head.next == null) return head;

        ListNode odd = head;
        ListNode even = head.next;
        ListNode evenHead = even;

        while (even != null && even.next != null) {
            odd.next = even.next;
            odd = odd.next;
            even.next = odd.next;
            even = even.next;
        }

        odd.next = evenHead;
        return head;
    }

    // Design Linked List
    public static class MyLinkedList {
        private ListNode head;
        private int size;

        public MyLinkedList() {
            head = null;
            size = 0;
        }

        public int get(int index) {
            if (index < 0 || index >= size) return -1;

            ListNode curr = head;
            for (int i = 0; i < index; i++) {
                curr = curr.next;
            }
            return curr.val;
        }

        public void addAtHead(int val) {
            ListNode newNode = new ListNode(val);
            newNode.next = head;
            head = newNode;
            size++;
        }

        public void addAtTail(int val) {
            if (head == null) {
                addAtHead(val);
                return;
            }

            ListNode curr = head;
            while (curr.next != null) {
                curr = curr.next;
            }
            curr.next = new ListNode(val);
            size++;
        }

        public void addAtIndex(int index, int val) {
            if (index < 0 || index > size) return;

            if (index == 0) {
                addAtHead(val);
                return;
            }

            ListNode curr = head;
            for (int i = 0; i < index - 1; i++) {
                curr = curr.next;
            }

            ListNode newNode = new ListNode(val);
            newNode.next = curr.next;
            curr.next = newNode;
            size++;
        }

        public void deleteAtIndex(int index) {
            if (index < 0 || index >= size) return;

            if (index == 0) {
                head = head.next;
                size--;
                return;
            }

            ListNode curr = head;
            for (int i = 0; i < index - 1; i++) {
                curr = curr.next;
            }

            curr.next = curr.next.next;
            size--;
        }
    }
}
```

### Two Pointers Guidelines

```java
// 1. Problem identification
public class TwoPointersBestPractices {

    // Identify when to use two pointers
    public boolean shouldUseTwoPointers(String problem) {
        String[] indicators = {
            "sorted array", "palindrome", "pair", "triplet",
            "remove duplicates", "cycle", "middle",
            "merge", "partition", "in-place"
        };

        String lowerProblem = problem.toLowerCase();
        return Arrays.stream(indicators).anyMatch(lowerProblem::contains);
    }

    // Choose the right approach
    public String selectApproach(boolean sorted, boolean inPlace,
                               boolean cycleDetection, boolean merging) {
        if (cycleDetection) return "Fast and Slow Pointers";
        if (sorted && !inPlace) return "Opposite Direction";
        if (inPlace) return "Same Direction";
        if (merging) return "Multiple Arrays Two Pointers";
        return "Custom Approach";
    }

    // Common edge cases to handle
    public void handleEdgeCases() {
        // 1. Empty arrays or null inputs
        // 2. Single element arrays
        // 3. All elements identical
        // 4. Already sorted/processed arrays
        // 5. Integer overflow for sum problems
        // 6. Pointer boundary conditions
    }

    // Debug helper
    public void debugTwoPointers(int[] arr, int left, int right, String step) {
        System.out.printf("%s: left=%d, right=%d, values=[%d, %d]%n",
                         step, left, right,
                         left < arr.length ? arr[left] : -1,
                         right < arr.length ? arr[right] : -1);
    }
}
```

## Pattern 4: Two Pointers for Sorting

### 4.1 Partitioning and Sorting Problems

```java
// Two pointers for sorting and partitioning problems
public class TwoPointersSorting {

    // Quick Sort Partition
    public int partition(int[] nums, int low, int high) {
        int pivot = nums[high];
        int i = low - 1; // Pointer for smaller elements

        for (int j = low; j < high; j++) {
            if (nums[j] <= pivot) {
                i++;
                swap(nums, i, j);
            }
        }

        swap(nums, i + 1, high);
        return i + 1;
    }

    // Dutch National Flag (3-way partitioning)
    public void sortColors(int[] nums) {
        int low = 0, mid = 0, high = nums.length - 1;

        while (mid <= high) {
            if (nums[mid] == 0) {
                swap(nums, low, mid);
                low++;
                mid++;
            } else if (nums[mid] == 1) {
                mid++;
            } else { // nums[mid] == 2
                swap(nums, mid, high);
                high--;
                // Don't increment mid as we need to check swapped element
            }
        }
    }

    // Wiggle Sort
    public void wiggleSort(int[] nums) {
        for (int i = 1; i < nums.length; i++) {
            if ((i % 2 == 1 && nums[i] < nums[i - 1]) ||
                (i % 2 == 0 && nums[i] > nums[i - 1])) {
                swap(nums, i, i - 1);
            }
        }
    }

    // Pancake Sorting
    public List<Integer> pancakeSort(int[] arr) {
        List<Integer> result = new ArrayList<>();

        for (int targetSize = arr.length; targetSize > 1; targetSize--) {
            // Find index of maximum element in first targetSize elements
            int maxIndex = 0;
            for (int i = 1; i < targetSize; i++) {
                if (arr[i] > arr[maxIndex]) {
                    maxIndex = i;
                }
            }

            if (maxIndex != targetSize - 1) {
                // Flip to bring max to front (if not already there)
                if (maxIndex != 0) {
                    flip(arr, maxIndex);
                    result.add(maxIndex + 1);
                }

                // Flip to bring max to its correct position
                flip(arr, targetSize - 1);
                result.add(targetSize);
            }
        }

        return result;
    }

    private void flip(int[] arr, int k) {
        int left = 0, right = k;
        while (left < right) {
            swap(arr, left, right);
            left++;
            right--;
        }
    }

    // Sort Array by Parity
    public int[] sortArrayByParity(int[] nums) {
        int left = 0, right = nums.length - 1;

        while (left < right) {
            if (nums[left] % 2 == 0) {
                left++;
            } else if (nums[right] % 2 == 1) {
                right--;
            } else {
                swap(nums, left, right);
                left++;
                right--;
            }
        }

        return nums;
    }

    // Kth Largest Element (Quick Select)
    public int findKthLargest(int[] nums, int k) {
        return quickSelect(nums, 0, nums.length - 1, nums.length - k);
    }

    private int quickSelect(int[] nums, int left, int right, int k) {
        if (left == right) return nums[left];

        int pivotIndex = partition(nums, left, right);

        if (pivotIndex == k) {
            return nums[pivotIndex];
        } else if (pivotIndex < k) {
            return quickSelect(nums, pivotIndex + 1, right, k);
        } else {
            return quickSelect(nums, left, pivotIndex - 1, k);
        }
    }

    // Top K Frequent Elements
    public int[] topKFrequent(int[] nums, int k) {
        Map<Integer, Integer> count = new HashMap<>();
        for (int num : nums) {
            count.put(num, count.getOrDefault(num, 0) + 1);
        }

        int[] unique = new int[count.size()];
        int i = 0;
        for (int num : count.keySet()) {
            unique[i++] = num;
        }

        quickSelectByFreq(unique, 0, unique.length - 1, unique.length - k, count);

        return Arrays.copyOfRange(unique, unique.length - k, unique.length);
    }

    private void quickSelectByFreq(int[] nums, int left, int right, int k,
                                   Map<Integer, Integer> count) {
        if (left >= right) return;

        int pivotIndex = partitionByFreq(nums, left, right, count);

        if (pivotIndex == k) {
            return;
        } else if (pivotIndex < k) {
            quickSelectByFreq(nums, pivotIndex + 1, right, k, count);
        } else {
            quickSelectByFreq(nums, left, pivotIndex - 1, k, count);
        }
    }

    private int partitionByFreq(int[] nums, int left, int right, Map<Integer, Integer> count) {
        int pivot = count.get(nums[right]);
        int i = left;

        for (int j = left; j < right; j++) {
            if (count.get(nums[j]) <= pivot) {
                swap(nums, i, j);
                i++;
            }
        }

        swap(nums, i, right);
        return i;
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```


### 4.2 Advanced Sorting Applications

```java
// Advanced sorting applications with two pointers
public class AdvancedSortingTwoPointers {

    // Meeting Rooms II
    public int minMeetingRooms(int[][] intervals) {
        if (intervals.length == 0) return 0;

        int[] starts = new int[intervals.length];
        int[] ends = new int[intervals.length];

        for (int i = 0; i < intervals.length; i++) {
            starts[i] = intervals[i][0];
            ends[i] = intervals[i][1];
        }

        Arrays.sort(starts);
        Arrays.sort(ends);

        int rooms = 0, endPtr = 0;

        for (int start : starts) {
            if (start >= ends[endPtr]) {
                endPtr++;
            } else {
                rooms++;
            }
        }

        return rooms;
    }

    // Minimum Number of Arrows to Burst Balloons
    public int findMinArrowShots(int[][] points) {
        if (points.length == 0) return 0;

        // Sort by end point
        Arrays.sort(points, (a, b) -> Integer.compare(a[1], b[1]));

        int arrows = 1;
        int end = points[0][1];

        for (int i = 1; i < points.length; i++) {
            if (points[i][0] > end) {
                arrows++;
                end = points[i][1];
            }
        }

        return arrows;
    }

    // Non-overlapping Intervals
    public int eraseOverlapIntervals(int[][] intervals) {
        if (intervals.length == 0) return 0;

        Arrays.sort(intervals, (a, b) -> Integer.compare(a[1], b[1]));

        int count = 1;
        int end = intervals[0][1];

        for (int i = 1; i < intervals.length; i++) {
            if (intervals[i][0] >= end) {
                count++;
                end = intervals[i][1];
            }
        }

        return intervals.length - count;
    }

    // Insert Interval
    public int[][] insert(int[][] intervals, int[] newInterval) {
        List<int[]> result = new ArrayList<>();
        int i = 0;

        // Add all intervals before newInterval
        while (i < intervals.length && intervals[i][1] < newInterval[0]) {
            result.add(intervals[i]);
            i++;
        }

        // Merge overlapping intervals
        while (i < intervals.length && intervals[i][0] <= newInterval[1]) {
            newInterval[0] = Math.min(newInterval[0], intervals[i][0]);
            newInterval[1] = Math.max(newInterval[1], intervals[i][1]);
            i++;
        }
        result.add(newInterval);

        // Add remaining intervals
        while (i < intervals.length) {
            result.add(intervals[i]);
            i++;
        }

        return result.toArray(new int[result.size()][]);
    }

    // Merge Intervals
    public int[][] merge(int[][] intervals) {
        if (intervals.length <= 1) return intervals;

        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));

        List<int[]> result = new ArrayList<>();
        int[] current = intervals[0];

        for (int i = 1; i < intervals.length; i++) {
            if (current[1] >= intervals[i][0]) {
                // Merge intervals
                current[1] = Math.max(current[1], intervals[i][1]);
            } else {
                result.add(current);
                current = intervals[i];
            }
        }

        result.add(current);
        return result.toArray(new int[result.size()][]);
    }

    // Car Pooling
    public boolean carPooling(int[][] trips, int capacity) {
        // Create events for passenger changes
        List<int[]> events = new ArrayList<>();

        for (int[] trip : trips) {
            events.add(new int[]{trip[1], trip[0]}); // start, +passengers
            events.add(new int[]{trip[2], -trip[0]}); // end, -passengers
        }

        // Sort by location
        events.sort((a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);

        int passengers = 0;
        for (int[] event : events) {
            passengers += event[1];
            if (passengers > capacity) {
                return false;
            }
        }

        return true;
    }

    // Advantage Shuffle (Greedy Two Pointers)
    public int[] advantageCount(int[] nums1, int[] nums2) {
        int n = nums1.length;
        Integer[] idx = new Integer[n];
        for (int i = 0; i < n; i++) idx[i] = i;

        Arrays.sort(nums1);
        Arrays.sort(idx, (i, j) -> nums2[i] - nums2[j]);

        int[] result = new int[n];
        int left = 0, right = n - 1;

        for (int num : nums1) {
            if (num > nums2[idx[left]]) {
                result[idx[left++]] = num;
            } else {
                result[idx[right--]] = num;
            }
        }

        return result;
    }
}
```


***

## Pattern 5: Two Pointers with HashMap

### 5.1 Frequency and Counting Problems

```java
// Two pointers combined with HashMap for frequency tracking
public class TwoPointersHashMap {

    // Longest Substring Without Repeating Characters
    public int lengthOfLongestSubstring(String s) {
        Map<Character, Integer> charIndex = new HashMap<>();
        int left = 0, maxLength = 0;

        for (int right = 0; right < s.length(); right++) {
            char c = s.charAt(right);

            if (charIndex.containsKey(c) && charIndex.get(c) >= left) {
                left = charIndex.get(c) + 1;
            }

            charIndex.put(c, right);
            maxLength = Math.max(maxLength, right - left + 1);
        }

        return maxLength;
    }

    // Longest Substring with At Most K Distinct Characters
    public int lengthOfLongestSubstringKDistinct(String s, int k) {
        if (k == 0) return 0;

        Map<Character, Integer> charCount = new HashMap<>();
        int left = 0, maxLength = 0;

        for (int right = 0; right < s.length(); right++) {
            char c = s.charAt(right);
            charCount.put(c, charCount.getOrDefault(c, 0) + 1);

            while (charCount.size() > k) {
                char leftChar = s.charAt(left);
                charCount.put(leftChar, charCount.get(leftChar) - 1);
                if (charCount.get(leftChar) == 0) {
                    charCount.remove(leftChar);
                }
                left++;
            }

            maxLength = Math.max(maxLength, right - left + 1);
        }

        return maxLength;
    }

    // Subarrays with K Different Integers
    public int subarraysWithKDistinct(int[] nums, int k) {
        return atMostK(nums, k) - atMostK(nums, k - 1);
    }

    private int atMostK(int[] nums, int k) {
        Map<Integer, Integer> count = new HashMap<>();
        int left = 0, result = 0;

        for (int right = 0; right < nums.length; right++) {
            count.put(nums[right], count.getOrDefault(nums[right], 0) + 1);

            while (count.size() > k) {
                count.put(nums[left], count.get(nums[left]) - 1);
                if (count.get(nums[left]) == 0) {
                    count.remove(nums[left]);
                }
                left++;
            }

            result += right - left + 1;
        }

        return result;
    }

    // Find All Anagrams in a String
    public List<Integer> findAnagrams(String s, String p) {
        List<Integer> result = new ArrayList<>();
        if (s.length() < p.length()) return result;

        Map<Character, Integer> pCount = new HashMap<>();
        for (char c : p.toCharArray()) {
            pCount.put(c, pCount.getOrDefault(c, 0) + 1);
        }

        Map<Character, Integer> windowCount = new HashMap<>();
        int windowSize = p.length();

        // Process first window
        for (int i = 0; i < windowSize; i++) {
            char c = s.charAt(i);
            windowCount.put(c, windowCount.getOrDefault(c, 0) + 1);
        }

        if (windowCount.equals(pCount)) {
            result.add(0);
        }

        // Slide the window
        for (int i = windowSize; i < s.length(); i++) {
            // Add new character
            char newChar = s.charAt(i);
            windowCount.put(newChar, windowCount.getOrDefault(newChar, 0) + 1);

            // Remove old character
            char oldChar = s.charAt(i - windowSize);
            windowCount.put(oldChar, windowCount.get(oldChar) - 1);
            if (windowCount.get(oldChar) == 0) {
                windowCount.remove(oldChar);
            }

            if (windowCount.equals(pCount)) {
                result.add(i - windowSize + 1);
            }
        }

        return result;
    }

    // Permutation in String
    public boolean checkInclusion(String s1, String s2) {
        if (s1.length() > s2.length()) return false;

        Map<Character, Integer> s1Count = new HashMap<>();
        for (char c : s1.toCharArray()) {
            s1Count.put(c, s1Count.getOrDefault(c, 0) + 1);
        }

        Map<Character, Integer> windowCount = new HashMap<>();
        int windowSize = s1.length();

        // Process first window
        for (int i = 0; i < windowSize; i++) {
            char c = s2.charAt(i);
            windowCount.put(c, windowCount.getOrDefault(c, 0) + 1);
        }

        if (windowCount.equals(s1Count)) return true;

        // Slide the window
        for (int i = windowSize; i < s2.length(); i++) {
            // Add new character
            char newChar = s2.charAt(i);
            windowCount.put(newChar, windowCount.getOrDefault(newChar, 0) + 1);

            // Remove old character
            char oldChar = s2.charAt(i - windowSize);
            windowCount.put(oldChar, windowCount.get(oldChar) - 1);
            if (windowCount.get(oldChar) == 0) {
                windowCount.remove(oldChar);
            }

            if (windowCount.equals(s1Count)) return true;
        }

        return false;
    }

    // Minimum Window Substring
    public String minWindow(String s, String t) {
        Map<Character, Integer> targetCount = new HashMap<>();
        for (char c : t.toCharArray()) {
            targetCount.put(c, targetCount.getOrDefault(c, 0) + 1);
        }

        Map<Character, Integer> windowCount = new HashMap<>();
        int left = 0, minLength = Integer.MAX_VALUE, minStart = 0;
        int formed = 0, required = targetCount.size();

        for (int right = 0; right < s.length(); right++) {
            char c = s.charAt(right);
            windowCount.put(c, windowCount.getOrDefault(c, 0) + 1);

            if (targetCount.containsKey(c) &&
                windowCount.get(c).intValue() == targetCount.get(c).intValue()) {
                formed++;
            }

            while (left <= right && formed == required) {
                if (right - left + 1 < minLength) {
                    minLength = right - left + 1;
                    minStart = left;
                }

                char leftChar = s.charAt(left);
                windowCount.put(leftChar, windowCount.get(leftChar) - 1);
                if (targetCount.containsKey(leftChar) &&
                    windowCount.get(leftChar) < targetCount.get(leftChar)) {
                    formed--;
                }
                left++;
            }
        }

        return minLength == Integer.MAX_VALUE ? "" : s.substring(minStart, minStart + minLength);
    }

    // Fruit Into Baskets (At Most 2 Types)
    public int totalFruit(int[] fruits) {
        Map<Integer, Integer> fruitCount = new HashMap<>();
        int left = 0, maxFruits = 0;

        for (int right = 0; right < fruits.length; right++) {
            fruitCount.put(fruits[right], fruitCount.getOrDefault(fruits[right], 0) + 1);

            while (fruitCount.size() > 2) {
                int leftFruit = fruits[left];
                fruitCount.put(leftFruit, fruitCount.get(leftFruit) - 1);
                if (fruitCount.get(leftFruit) == 0) {
                    fruitCount.remove(leftFruit);
                }
                left++;
            }

            maxFruits = Math.max(maxFruits, right - left + 1);
        }

        return maxFruits;
    }
}
```


***

## Pattern 6: Multiple Arrays Two Pointers

### 6.1 Merging and Intersection Problems

```java
// Two pointers for multiple arrays operations
public class MultipleArraysTwoPointers {

    // Merge Two Sorted Arrays
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int i = m - 1, j = n - 1, k = m + n - 1;

        while (i >= 0 && j >= 0) {
            if (nums1[i] > nums2[j]) {
                nums1[k--] = nums1[i--];
            } else {
                nums1[k--] = nums2[j--];
            }
        }

        while (j >= 0) {
            nums1[k--] = nums2[j--];
        }
    }

    // Intersection of Two Arrays
    public int[] intersection(int[] nums1, int[] nums2) {
        Arrays.sort(nums1);
        Arrays.sort(nums2);

        Set<Integer> result = new HashSet<>();
        int i = 0, j = 0;

        while (i < nums1.length && j < nums2.length) {
            if (nums1[i] == nums2[j]) {
                result.add(nums1[i]);
                i++;
                j++;
            } else if (nums1[i] < nums2[j]) {
                i++;
            } else {
                j++;
            }
        }

        return result.stream().mapToInt(Integer::intValue).toArray();
    }

    // Intersection of Two Arrays II
    public int[] intersect(int[] nums1, int[] nums2) {
        Arrays.sort(nums1);
        Arrays.sort(nums2);

        List<Integer> result = new ArrayList<>();
        int i = 0, j = 0;

        while (i < nums1.length && j < nums2.length) {
            if (nums1[i] == nums2[j]) {
                result.add(nums1[i]);
                i++;
                j++;
            } else if (nums1[i] < nums2[j]) {
                i++;
            } else {
                j++;
            }
        }

        return result.stream().mapToInt(Integer::intValue).toArray();
    }

    // Merge k Sorted Arrays
    public int[] mergeKSortedArrays(int[][] arrays) {
        PriorityQueue<ArrayElement> pq = new PriorityQueue<>((a, b) -> a.value - b.value);

        // Initialize with first element from each array
        for (int i = 0; i < arrays.length; i++) {
            if (arrays[i].length > 0) {
                pq.offer(new ArrayElement(arrays[i][0], i, 0));
            }
        }

        List<Integer> result = new ArrayList<>();

        while (!pq.isEmpty()) {
            ArrayElement current = pq.poll();
            result.add(current.value);

            // Add next element from the same array
            if (current.index + 1 < arrays[current.arrayId].length) {
                pq.offer(new ArrayElement(
                    arrays[current.arrayId][current.index + 1],
                    current.arrayId,
                    current.index + 1
                ));
            }
        }

        return result.stream().mapToInt(Integer::intValue).toArray();
    }

    static class ArrayElement {
        int value;
        int arrayId;
        int index;

        ArrayElement(int value, int arrayId, int index) {
            this.value = value;
            this.arrayId = arrayId;
            this.index = index;
        }
    }

    // Find Median of Two Sorted Arrays
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        if (nums1.length > nums2.length) {
            return findMedianSortedArrays(nums2, nums1);
        }

        int m = nums1.length, n = nums2.length;
        int left = 0, right = m;

        while (left <= right) {
            int partition1 = (left + right) / 2;
            int partition2 = (m + n + 1) / 2 - partition1;

            int maxLeft1 = (partition1 == 0) ? Integer.MIN_VALUE : nums1[partition1 - 1];
            int maxLeft2 = (partition2 == 0) ? Integer.MIN_VALUE : nums2[partition2 - 1];

            int minRight1 = (partition1 == m) ? Integer.MAX_VALUE : nums1[partition1];
            int minRight2 = (partition2 == n) ? Integer.MAX_VALUE : nums2[partition2];

            if (maxLeft1 <= minRight2 && maxLeft2 <= minRight1) {
                if ((m + n) % 2 == 0) {
                    return (Math.max(maxLeft1, maxLeft2) + Math.min(minRight1, minRight2)) / 2.0;
                } else {
                    return Math.max(maxLeft1, maxLeft2);
                }
            } else if (maxLeft1 > minRight2) {
                right = partition1 - 1;
            } else {
                left = partition1 + 1;
            }
        }

        throw new IllegalArgumentException("Arrays are not sorted");
    }

    // Next Greater Element I
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        Map<Integer, Integer> nextGreater = new HashMap<>();
        Stack<Integer> stack = new Stack<>();

        // Build next greater map for nums2
        for (int num : nums2) {
            while (!stack.isEmpty() && stack.peek() < num) {
                nextGreater.put(stack.pop(), num);
            }
            stack.push(num);
        }

        // Find results for nums1
        int[] result = new int[nums1.length];
        for (int i = 0; i < nums1.length; i++) {
            result[i] = nextGreater.getOrDefault(nums1[i], -1);
        }

        return result;
    }

    // Smallest Range Covering Elements from K Lists
    public int[] smallestRange(List<List<Integer>> nums) {
        PriorityQueue<Element> pq = new PriorityQueue<>((a, b) -> a.val - b.val);
        int max = Integer.MIN_VALUE;

        // Initialize with first element from each list
        for (int i = 0; i < nums.size(); i++) {
            if (nums.get(i).size() > 0) {
                int val = nums.get(i).get(0);
                pq.offer(new Element(val, i, 0));
                max = Math.max(max, val);
            }
        }

        int rangeStart = 0, rangeEnd = Integer.MAX_VALUE;

        while (pq.size() == nums.size()) {
            Element current = pq.poll();

            if (max - current.val < rangeEnd - rangeStart) {
                rangeStart = current.val;
                rangeEnd = max;
            }

            if (current.idx + 1 < nums.get(current.row).size()) {
                int nextVal = nums.get(current.row).get(current.idx + 1);
                pq.offer(new Element(nextVal, current.row, current.idx + 1));
                max = Math.max(max, nextVal);
            }
        }

        return new int[]{rangeStart, rangeEnd};
    }

    static class Element {
        int val;
        int row;
        int idx;

        Element(int val, int row, int idx) {
            this.val = val;
            this.row = row;
            this.idx = idx;
        }
    }
}
```


***

## Pattern 7: Linked List Two Pointers

### 7.1 Advanced Linked List Operations

```java
// Advanced linked list operations using two pointers
public class LinkedListTwoPointers {

    static class ListNode {
        int val;
        ListNode next;
        ListNode() {}
        ListNode(int val) { this.val = val; }
        ListNode(int val, ListNode next) { this.val = val; this.next = next; }
    }

    // Merge Two Sorted Lists
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode dummy = new ListNode(0);
        ListNode current = dummy;

        while (list1 != null && list2 != null) {
            if (list1.val <= list2.val) {
                current.next = list1;
                list1 = list1.next;
            } else {
                current.next = list2;
                list2 = list2.next;
            }
            current = current.next;
        }

        // Attach remaining nodes
        current.next = (list1 != null) ? list1 : list2;

        return dummy.next;
    }

    // Merge k Sorted Lists
    public ListNode mergeKLists(ListNode[] lists) {
        if (lists == null || lists.length == 0) return null;

        while (lists.length > 1) {
            List<ListNode> mergedLists = new ArrayList<>();

            for (int i = 0; i < lists.length; i += 2) {
                ListNode l1 = lists[i];
                ListNode l2 = (i + 1 < lists.length) ? lists[i + 1] : null;
                mergedLists.add(mergeTwoLists(l1, l2));
            }

            lists = mergedLists.toArray(new ListNode[0]);
        }

        return lists[0];
    }

    // Add Two Numbers
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(0);
        ListNode current = dummy;
        int carry = 0;

        while (l1 != null || l2 != null || carry != 0) {
            int sum = carry;

            if (l1 != null) {
                sum += l1.val;
                l1 = l1.next;
            }

            if (l2 != null) {
                sum += l2.val;
                l2 = l2.next;
            }

            carry = sum / 10;
            current.next = new ListNode(sum % 10);
            current = current.next;
        }

        return dummy.next;
    }

    // Remove Duplicates from Sorted List II
    public ListNode deleteDuplicates(ListNode head) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode prev = dummy;

        while (head != null) {
            if (head.next != null && head.val == head.next.val) {
                // Skip all nodes with same value
                while (head.next != null && head.val == head.next.val) {
                    head = head.next;
                }
                prev.next = head.next;
            } else {
                prev = prev.next;
            }
            head = head.next;
        }

        return dummy.next;
    }

    // Partition List
    public ListNode partition(ListNode head, int x) {
        ListNode beforeHead = new ListNode(0);
        ListNode afterHead = new ListNode(0);
        ListNode before = beforeHead;
        ListNode after = afterHead;

        while (head != null) {
            if (head.val < x) {
                before.next = head;
                before = before.next;
            } else {
                after.next = head;
                after = after.next;
            }
            head = head.next;
        }

        after.next = null;
        before.next = afterHead.next;

        return beforeHead.next;
    }

    // Rotate List
    public ListNode rotateRight(ListNode head, int k) {
        if (head == null || head.next == null || k == 0) return head;

        // Find length and connect to form cycle
        int length = 1;
        ListNode tail = head;
        while (tail.next != null) {
            tail = tail.next;
            length++;
        }
        tail.next = head;

        // Find new tail (length - k % length - 1 steps from head)
        k = k % length;
        int stepsToNewTail = length - k;

        ListNode newTail = head;
        for (int i = 1; i < stepsToNewTail; i++) {
            newTail = newTail.next;
        }

        ListNode newHead = newTail.next;
        newTail.next = null;

        return newHead;
    }

    // Copy List with Random Pointer
    static class Node {
        int val;
        Node next;
        Node random;

        public Node(int val) {
            this.val = val;
            this.next = null;
            this.random = null;
        }
    }

    public Node copyRandomList(Node head) {
        if (head == null) return null;

        Map<Node, Node> map = new HashMap<>();

        // First pass: create all nodes
        Node curr = head;
        while (curr != null) {
            map.put(curr, new Node(curr.val));
            curr = curr.next;
        }

        // Second pass: link next and random pointers
        curr = head;
        while (curr != null) {
            map.get(curr).next = map.get(curr.next);
            map.get(curr).random = map.get(curr.random);
            curr = curr.next;
        }

        return map.get(head);
    }

    // Reverse Nodes in k-Group
    public ListNode reverseKGroup(ListNode head, int k) {
        // Check if there are at least k nodes
        ListNode curr = head;
        int count = 0;
        while (curr != null && count < k) {
            curr = curr.next;
            count++;
        }

        if (count == k) {
            // Reverse first k nodes
            curr = reverseKGroup(curr, k);

            while (count > 0) {
                ListNode next = head.next;
                head.next = curr;
                curr = head;
                head = next;
                count--;
            }
            head = curr;
        }

        return head;
    }
}
```


***

## Pattern 8: String Manipulation with Two Pointers

### 8.1 String Processing and Validation

```java
// String manipulation using two pointers
public class StringTwoPointers {

    // Valid Palindrome II (at most one deletion)
    public boolean validPalindrome(String s) {
        int left = 0, right = s.length() - 1;

        while (left < right) {
            if (s.charAt(left) != s.charAt(right)) {
                // Try deleting left character or right character
                return isPalindrome(s, left + 1, right) || isPalindrome(s, left, right - 1);
            }
            left++;
            right--;
        }

        return true;
    }

    private boolean isPalindrome(String s, int left, int right) {
        while (left < right) {
            if (s.charAt(left) != s.charAt(right)) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }

    // Reverse Words in a String III
    public String reverseWords(String s) {
        char[] chars = s.toCharArray();
        int left = 0;

        for (int right = 0; right <= chars.length; right++) {
            if (right == chars.length || chars[right] == ' ') {
                reverse(chars, left, right - 1);
                left = right + 1;
            }
        }

        return new String(chars);
    }

    private void reverse(char[] chars, int left, int right) {
        while (left < right) {
            char temp = chars[left];
            chars[left] = chars[right];
            chars[right] = temp;
            left++;
            right--;
        }
    }

    // Longest Palindromic Substring
    public String longestPalindrome(String s) {
        if (s == null || s.length() < 2) return s;

        int start = 0, maxLength = 1;

        for (int i = 0; i < s.length(); i++) {
            // Check for odd length palindromes
            int len1 = expandAroundCenter(s, i, i);
            // Check for even length palindromes
            int len2 = expandAroundCenter(s, i, i + 1);

            int len = Math.max(len1, len2);
            if (len > maxLength) {
                maxLength = len;
                start = i - (len - 1) / 2;
            }
        }

        return s.substring(start, start + maxLength);
    }

    private int expandAroundCenter(String s, int left, int right) {
        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
            left--;
            right++;
        }
        return right - left - 1;
    }

    // String Compression
    public int compress(char[] chars) {
        int write = 0, anchor = 0;

        for (int read = 0; read <= chars.length; read++) {
            if (read == chars.length || chars[read] != chars[anchor]) {
                chars[write++] = chars[anchor];

                if (read - anchor > 1) {
                    for (char c : String.valueOf(read - anchor).toCharArray()) {
                        chars[write++] = c;
                    }
                }
                anchor = read;
            }
        }

        return write;
    }

    // Remove Duplicate Letters
    public String removeDuplicateLetters(String s) {
        Map<Character, Integer> lastIndex = new HashMap<>();
        Set<Character> inStack = new HashSet<>();
        Stack<Character> stack = new Stack<>();

        // Record last occurrence of each character
        for (int i = 0; i < s.length(); i++) {
            lastIndex.put(s.charAt(i), i);
        }

        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);

            if (inStack.contains(c)) continue;

            // Remove characters that are greater than current and appear later
            while (!stack.isEmpty() && stack.peek() > c && lastIndex.get(stack.peek()) > i) {
                inStack.remove(stack.pop());
            }

            stack.push(c);
            inStack.add(c);
        }

        StringBuilder sb = new StringBuilder();
        for (char c : stack) {
            sb.append(c);
        }

        return sb.toString();
    }

    // Compare Version Numbers
    public int compareVersion(String version1, String version2) {
        int i = 0, j = 0;

        while (i < version1.length() || j < version2.length()) {
            int num1 = 0, num2 = 0;

            // Extract next number from version1
            while (i < version1.length() && version1.charAt(i) != '.') {
                num1 = num1 * 10 + (version1.charAt(i) - '0');
                i++;
            }

            // Extract next number from version2
            while (j < version2.length() && version2.charAt(j) != '.') {
                num2 = num2 * 10 + (version2.charAt(j) - '0');
                j++;
            }

            if (num1 < num2) return -1;
            if (num1 > num2) return 1;

            i++; // Skip dot
            j++; // Skip dot
        }

        return 0;
    }

    // One Edit Distance
    public boolean isOneEditDistance(String s, String t) {
        if (Math.abs(s.length() - t.length()) > 1) return false;
        if (s.equals(t)) return false;

        if (s.length() > t.length()) {
            return isOneEditDistance(t, s);
        }

        // s.length() <= t.length()
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) != t.charAt(i)) {
                if (s.length() == t.length()) {
                    // Replace operation
                    return s.substring(i + 1).equals(t.substring(i + 1));
                } else {
                    // Insert operation
                    return s.substring(i).equals(t.substring(i + 1));
                }
            }
        }

        // All characters match, check if exactly one insertion needed
        return t.length() - s.length() == 1;
    }

    // Shortest Way to Form String
    public int shortestWay(String source, String target) {
        Set<Character> sourceChars = new HashSet<>();
        for (char c : source.toCharArray()) {
            sourceChars.add(c);
        }

        int sourcePtr = 0, targetPtr = 0, count = 0;

        while (targetPtr < target.length()) {
            if (!sourceChars.contains(target.charAt(targetPtr))) {
                return -1; // Impossible to form target
            }

            int oldTargetPtr = targetPtr;

            while (sourcePtr < source.length() && targetPtr < target.length()) {
                if (source.charAt(sourcePtr) == target.charAt(targetPtr)) {
                    targetPtr++;
                }
                sourcePtr++;
            }

            if (oldTargetPtr == targetPtr) {
                return -1; // No progress made
            }

            count++;
            sourcePtr = 0; // Reset source pointer
        }

        return count;
    }
}
```


***

## Pattern 9: Advanced Two Pointers Techniques

### 9.1 Complex Algorithm Applications

```java
// Advanced two pointers techniques for complex problems
public class AdvancedTwoPointersTechniques {

    // Longest Mountain in Array
    public int longestMountain(int[] arr) {
        if (arr.length < 3) return 0;

        int maxLength = 0;

        for (int i = 1; i < arr.length - 1; i++) {
            // Check if current position can be a peak
            if (arr[i - 1] < arr[i] && arr[i] > arr[i + 1]) {
                int left = i - 1, right = i + 1;

                // Expand left
                while (left > 0 && arr[left - 1] < arr[left]) {
                    left--;
                }

                // Expand right
                while (right < arr.length - 1 && arr[right] > arr[right + 1]) {
                    right++;
                }

                maxLength = Math.max(maxLength, right - left + 1);
            }
        }

        return maxLength;
    }

    // Minimum Operations to Reduce X to Zero
    public int minOperations(int[] nums, int x) {
        int target = Arrays.stream(nums).sum() - x;
        if (target < 0) return -1;
        if (target == 0) return nums.length;

        // Find longest subarray with sum = target
        Map<Integer, Integer> prefixSumIndex = new HashMap<>();
        prefixSumIndex.put(0, -1);

        int sum = 0, maxLength = -1;

        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];

            if (prefixSumIndex.containsKey(sum - target)) {
                maxLength = Math.max(maxLength, i - prefixSumIndex.get(sum - target));
            }

            prefixSumIndex.put(sum, i);
        }

        return maxLength == -1 ? -1 : nums.length - maxLength;
    }

    // Minimum Window Subsequence
    public String minWindow(String s1, String s2) {
        int i = 0, j = 0;
        int start = -1, minLength = Integer.MAX_VALUE;

        while (i < s1.length()) {
            if (s1.charAt(i) == s2.charAt(j)) {
                j++;

                if (j == s2.length()) {
                    // Found complete subsequence, try to minimize
                    int end = i;
                    j--; // Move back to last character of s2

                    while (j >= 0) {
                        if (s1.charAt(i) == s2.charAt(j)) {
                            j--;
                        }
                        i--;
                    }

                    // Update minimum window
                    if (end - i < minLength) {
                        minLength = end - i;
                        start = i + 1;
                    }

                    j = 0; // Reset for next search
                }
            }
            i++;
        }

        return start == -1 ? "" : s1.substring(start, start + minLength);
    }

    // Max Consecutive Ones III
    public int longestOnes(int[] nums, int k) {
        int left = 0, maxLength = 0, zeroCount = 0;

        for (int right = 0; right < nums.length; right++) {
            if (nums[right] == 0) {
                zeroCount++;
            }

            while (zeroCount > k) {
                if (nums[left] == 0) {
                    zeroCount--;
                }
                left++;
            }

            maxLength = Math.max(maxLength, right - left + 1);
        }

        return maxLength;
    }

    // Subarrays with K Odd Numbers
    public int numberOfSubarrays(int[] nums, int k) {
        return atMostK(nums, k) - atMostK(nums, k - 1);
    }

    private int atMostK(int[] nums, int k) {
        int left = 0, count = 0, result = 0;

        for (int right = 0; right < nums.length; right++) {
            if (nums[right] % 2 == 1) {
                count++;
            }

            while (count > k) {
                if (nums[left] % 2 == 1) {
                    count--;
                }
                left++;
            }

            result += right - left + 1;
        }

        return result;
    }

    // Get Equal Substrings Within Budget
    public int equalSubstring(String s, String t, int maxCost) {
        int left = 0, currentCost = 0, maxLength = 0;

        for (int right = 0; right < s.length(); right++) {
            currentCost += Math.abs(s.charAt(right) - t.charAt(right));

            while (currentCost > maxCost) {
                currentCost -= Math.abs(s.charAt(left) - t.charAt(left));
                left++;
            }

            maxLength = Math.max(maxLength, right - left + 1);
        }

        return maxLength;
    }

    // Replace the Substring for Balanced String
    public int balancedString(String s) {
        Map<Character, Integer> count = new HashMap<>();
        for (char c : s.toCharArray()) {
            count.put(c, count.getOrDefault(c, 0) + 1);
        }

        int n = s.length();
        int target = n / 4;

        // Check if already balanced
        if (count.values().stream().allMatch(freq -> freq <= target)) {
            return 0;
        }

        int left = 0, minLength = n;

        for (int right = 0; right < n; right++) {
            count.put(s.charAt(right), count.get(s.charAt(right)) - 1);

            while (isValid(count, target)) {
                minLength = Math.min(minLength, right - left + 1);
                count.put(s.charAt(left), count.get(s.charAt(left)) + 1);
                left++;
            }
        }

        return minLength;
    }

    private boolean isValid(Map<Character, Integer> count, int target) {
        return count.values().stream().allMatch(freq -> freq <= target);
    }

    // Number of Subsequences That Satisfy the Given Sum Condition
    public int numSubseq(int[] nums, int target) {
        Arrays.sort(nums);
        int left = 0, right = nums.length - 1;
        int count = 0;
        int MOD = 1000000007;

        // Precompute powers of 2
        int[] pow = new int[nums.length];
        pow[0] = 1;
        for (int i = 1; i < nums.length; i++) {
            pow[i] = (pow[i - 1] * 2) % MOD;
        }

        while (left <= right) {
            if (nums[left] + nums[right] <= target) {
                count = (count + pow[right - left]) % MOD;
                left++;
            } else {
                right--;
            }
        }

        return count;
    }
}
```


***

## Pattern 10: Matrix and 2D Two Pointers

### 10.1 2D Array Problems

```java
// Two pointers for 2D matrix problems
public class Matrix2DTwoPointers {

    // Search in 2D Matrix
    public boolean searchMatrix(int[][] matrix, int target) {
        if (matrix.length == 0 || matrix[0].length == 0) return false;

        int row = 0, col = matrix[0].length - 1;

        while (row < matrix.length && col >= 0) {
            if (matrix[row][col] == target) {
                return true;
            } else if (matrix[row][col] > target) {
                col--;
            } else {
                row++;
            }
        }

        return false;
    }

    // Search in 2D Matrix II
    public boolean searchMatrixII(int[][] matrix, int target) {
        if (matrix.length == 0 || matrix[0].length == 0) return false;

        int row = 0, col = matrix[0].length - 1;

        while (row < matrix.length && col >= 0) {
            int current = matrix[row][col];

            if (current == target) {
                return true;
            } else if (current > target) {
                col--; // Move left
            } else {
                row++; // Move down
            }
        }

        return false;
    }

    // Set Matrix Zeroes
    public void setZeroes(int[][] matrix) {
        int m = matrix.length, n = matrix[0].length;
        boolean firstRowZero = false, firstColZero = false;

        // Check if first row should be zero
        for (int j = 0; j < n; j++) {
            if (matrix[0][j] == 0) {
                firstRowZero = true;
                break;
            }
        }

        // Check if first column should be zero
        for (int i = 0; i < m; i++) {
            if (matrix[i][0] == 0) {
                firstColZero = true;
                break;
            }
        }

        // Use first row and column as markers
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (matrix[i][j] == 0) {
                    matrix[i][0] = 0;
                    matrix[0][j] = 0;
                }
            }
        }

        // Set zeros based on markers
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (matrix[i][0] == 0 || matrix[0][j] == 0) {
                    matrix[i][j] = 0;
                }
            }
        }

        // Handle first row and column
        if (firstRowZero) {
            for (int j = 0; j < n; j++) {
                matrix[0][j] = 0;
            }
        }

        if (firstColZero) {
            for (int i = 0; i < m; i++) {
                matrix[i][0] = 0;
            }
        }
    }

    // Diagonal Traverse
    public int[] findDiagonalOrder(int[][] mat) {
        int m = mat.length, n = mat[0].length;
        int[] result = new int[m * n];
        int row = 0, col = 0;
        boolean goingUp = true;

        for (int i = 0; i < m * n; i++) {
            result[i] = mat[row][col];

            if (goingUp) {
                if (col == n - 1) {
                    row++;
                    goingUp = false;
                } else if (row == 0) {
                    col++;
                    goingUp = false;
                } else {
                    row--;
                    col++;
                }
            } else {
                if (row == m - 1) {
                    col++;
                    goingUp = true;
                } else if (col == 0) {
                    row++;
                    goingUp = true;
                } else {
                    row++;
                    col--;
                }
            }
        }

        return result;
    }

    // Spiral Matrix
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> result = new ArrayList<>();
        if (matrix.length == 0) return result;

        int top = 0, bottom = matrix.length - 1;
        int left = 0, right = matrix[0].length - 1;

        while (top <= bottom && left <= right) {
            // Go right
            for (int col = left; col <= right; col++) {
                result.add(matrix[top][col]);
            }
            top++;

            // Go down
            for (int row = top; row <= bottom; row++) {
                result.add(matrix[row][right]);
            }
            right--;

            // Go left (if still have rows)
            if (top <= bottom) {
                for (int col = right; col >= left; col--) {
                    result.add(matrix[bottom][col]);
                }
                bottom--;
            }

            // Go up (if still have columns)
            if (left <= right) {
                for (int row = bottom; row >= top; row--) {
                    result.add(matrix[row][left]);
                }
                left++;
            }
        }

        return result;
    }

    // Rotate Image
    public void rotate(int[][] matrix) {
        int n = matrix.length;

        // Transpose matrix
        for (int i = 0; i < n; i++) {
            for (int j = i; j < n; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }

        // Reverse each row
        for (int i = 0; i < n; i++) {
            int left = 0, right = n - 1;
            while (left < right) {
                int temp = matrix[i][left];
                matrix[i][left] = matrix[i][right];
                matrix[i][right] = temp;
                left++;
                right--;
            }
        }
    }

    // Valid Sudoku
    public boolean isValidSudoku(char[][] board) {
        Set<String> seen = new HashSet<>();

        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                char value = board[i][j];
                if (value != '.') {
                    if (!seen.add(value + " in row " + i) ||
                        !seen.add(value + " in column " + j) ||
                        !seen.add(value + " in block " + i/3 + "-" + j/3)) {
                        return false;
                    }
                }
            }
        }

        return true;
    }
}
```


***

## Pattern 11: Optimization Techniques

### 11.1 Performance and Memory Optimizations

```java
// Optimization techniques for two pointers problems
public class TwoPointersOptimization {

    // Space-optimized longest palindromic substring
    public String longestPalindromeOptimized(String s) {
        if (s == null || s.length() < 2) return s;

        int start = 0, maxLength = 1;

        for (int i = 0; i < s.length(); i++) {
            // Check odd length palindromes
            int len1 = expandAroundCenter(s, i, i);
            // Check even length palindromes
            int len2 = expandAroundCenter(s, i, i + 1);

            int len = Math.max(len1, len2);
            if (len > maxLength) {
                maxLength = len;
                start = i - (len - 1) / 2;
            }
        }

        return s.substring(start, start + maxLength);
    }

    private int expandAroundCenter(String s, int left, int right) {
        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
            left--;
            right++;
        }
        return right - left - 1;
    }

    // Optimized remove duplicates with minimal operations
    public int removeDuplicatesOptimal(int[] nums) {
        if (nums.length == 0) return 0;

        int writeIndex = 1;

        for (int readIndex = 1; readIndex < nums.length; readIndex++) {
            if (nums[readIndex] != nums[readIndex - 1]) {
                nums[writeIndex] = nums[readIndex];
                writeIndex++;
            }
        }

        return writeIndex;
    }

    // Cache-friendly two pointers implementation
    public boolean twoSumCacheFriendly(int[] nums, int target) {
        // Sort first for better cache locality
        Arrays.sort(nums);

        int left = 0, right = nums.length - 1;

        while (left < right) {
            int sum = nums[left] + nums[right];

            if (sum == target) {
                return true;
            } else if (sum < target) {
                // Prefetch next elements
                if (left + 1 < nums.length) {
                    int nextLeft = nums[left + 1]; // Hint to cache
                }
                left++;
            } else {
                // Prefetch next elements
                if (right - 1 >= 0) {
                    int nextRight = nums[right - 1]; // Hint to cache
                }
                right--;
            }
        }

        return false;
    }

    // Memory-efficient string reversal
    public void reverseStringInPlace(char[] s) {
        int left = 0, right = s.length - 1;

        while (left < right) {
            // XOR swap to avoid temporary variable
            s[left] ^= s[right];
            s[right] ^= s[left];
            s[left] ^= s[right];

            left++;
            right--;
        }
    }

    // Optimized palindrome check with early termination
    public boolean isPalindromeOptimized(String s) {
        if (s == null || s.length() <= 1) return true;

        int left = 0, right = s.length() - 1;

        while (left < right) {
            // Skip non-alphanumeric characters
            char leftChar = s.charAt(left);
            char rightChar = s.charAt(right);

            if (!Character.isLetterOrDigit(leftChar)) {
                left++;
                continue;
            }

            if (!Character.isLetterOrDigit(rightChar)) {
                right--;
                continue;
            }

            // Early termination for obvious mismatches
            if (Character.toLowerCase(leftChar) != Character.toLowerCase(rightChar)) {
                return false;
            }

            left++;
            right--;
        }

        return true;
    }

    // Batch processing for large arrays
    public int[] twoSumBatch(int[] nums, int target, int batchSize) {
        // Process in batches for better memory management
        for (int batch = 0; batch < nums.length; batch += batchSize) {
            int end = Math.min(batch + batchSize, nums.length);

            // Process current batch
            for (int i = batch; i < end; i++) {
                for (int j = i + 1; j < nums.length; j++) {
                    if (nums[i] + nums[j] == target) {
                        return new int[]{i, j};
                    }
                }
            }
        }

        return new int[]{-1, -1};
    }

    // Parallel two pointers for large datasets
    public boolean containsDuplicateParallel(int[] nums) {
        if (nums.length < 1000) {
            // Use regular approach for small arrays
            return containsDuplicateRegular(nums);
        }

        // Split array and process in parallel
        int mid = nums.length / 2;

        CompletableFuture<Boolean> leftHalf = CompletableFuture.supplyAsync(() ->
            containsDuplicateRegular(Arrays.copyOfRange(nums, 0, mid)));

        CompletableFuture<Boolean> rightHalf = CompletableFuture.supplyAsync(() ->
            containsDuplicateRegular(Arrays.copyOfRange(nums, mid, nums.length)));

        // Check for duplicates across halves
        Set<Integer> leftSet = new HashSet<>();
        for (int i = 0; i < mid; i++) {
            leftSet.add(nums[i]);
        }

        for (int i = mid; i < nums.length; i++) {
            if (leftSet.contains(nums[i])) {
                return true;
            }
        }

        try {
            return leftHalf.get() || rightHalf.get();
        } catch (Exception e) {
            return containsDuplicateRegular(nums);
        }
    }

    private boolean containsDuplicateRegular(int[] nums) {
        Set<Integer> seen = new HashSet<>();
        for (int num : nums) {
            if (seen.contains(num)) {
                return true;
            }
            seen.add(num);
        }
        return false;
    }

    // Adaptive algorithm selection based on input characteristics
    public int[] twoSumAdaptive(int[] nums, int target) {
        // Choose algorithm based on array characteristics
        if (nums.length < 100) {
            return twoSumBruteForce(nums, target);
        } else if (isSorted(nums)) {
            return twoSumTwoPointers(nums, target);
        } else {
            return twoSumHashMap(nums, target);
        }
    }

    private boolean isSorted(int[] nums) {
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] < nums[i - 1]) {
                return false;
            }
        }
        return true;
    }

    private int[] twoSumBruteForce(int[] nums, int target) {
        for (int i = 0; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                if (nums[i] + nums[j] == target) {
                    return new int[]{i, j};
                }
            }
        }
        return new int[]{-1, -1};
    }

    private int[] twoSumTwoPointers(int[] nums, int target) {
        int left = 0, right = nums.length - 1;

        while (left < right) {
            int sum = nums[left] + nums[right];
            if (sum == target) {
                return new int[]{left, right};
            } else if (sum < target) {
                left++;
            } else {
                right--;
            }
        }

        return new int[]{-1, -1};
    }

    private int[] twoSumHashMap(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();

        for (int i = 0; i < nums.length; i++) {
            int complement = target - nums[i];
            if (map.containsKey(complement)) {
                return new int[]{map.get(complement), i};
            }
            map.put(nums[i], i);
        }

        return new int[]{-1, -1};
    }
}
```


***

## Summary and Conclusion

### Two Pointers Pattern Recognition

## Time \& Space Complexity Reference

| Pattern Type | Time Complexity | Space Complexity | Key Characteristics |
| :-- | :-- | :-- | :-- |
| Opposite Direction | O(n) | O(1) | Sorted arrays, palindromes, pairs |
| Same Direction | O(n) | O(1) | Array modifications, duplicates |
| Fast \& Slow | O(n) | O(1) | Cycle detection, middle finding |
| Sorting Problems | O(n) | O(1) | In-place partitioning |
| HashMap Combination | O(n) | O(n) | Frequency tracking |
| Multiple Arrays | O(n+m) | O(1) | Merging operations |

The two pointers technique is a fundamental algorithmic approach that optimizes solutions for array, string, and linked list problems. Here's a comprehensive summary:

**When to Use Two Pointers:**

- Sorted arrays for pair/triplet finding
- String palindrome problems
- Array partitioning and modification
- Linked list cycle detection and manipulation
- Merging operations
- In-place array rearrangement

**Key Benefits:**

- Reduces time complexity from O(n) to O(n) in most cases
- Constant space complexity O(1) for many problems
- Natural fit for sorted data structures
- Elegant solutions for complex problems

**Implementation Guidelines:**

- **Opposite Direction**: Start from both ends, move toward center
- **Same Direction**: Use slow/fast pointers moving in same direction
- **Fast \& Slow**: Different speeds for cycle detection
- **Multiple Arrays**: Coordinate pointers across different arrays

**Common Patterns:**

1. **Two Sum problems**: Sorted array, opposite direction
2. **Array modification**: Same direction, in-place operations
3. **Cycle detection**: Fast and slow pointers
4. **String processing**: Expand around center, palindrome validation
5. **Merging**: Multiple pointers across different data structures
