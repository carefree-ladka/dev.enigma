# LinkedList

## Table of Contents

1. [Node Definition](#node-definition)
2. [Pattern 1: Two Pointer Technique](#pattern-1-two-pointer-technique)
3. [Pattern 2: Fast & Slow Pointer (Cycle Detection)](#pattern-2-fast--slow-pointer-cycle-detection)
4. [Pattern 3: Reversal Patterns](#pattern-3-reversal-patterns)
5. [Pattern 4: Merging Patterns](#pattern-4-merging-patterns)
6. [Pattern 5: Intersection & Union](#pattern-5-intersection--union)
7. [Pattern 6: Removal Patterns](#pattern-6-removal-patterns)
8. [Pattern 7: Partition & Splitting](#pattern-7-partition--splitting)
9. [Pattern 8: Addition & Arithmetic](#pattern-8-addition--arithmetic)
10. [Pattern 9: Deep Copy & Cloning](#pattern-9-deep-copy--cloning)
11. [Pattern 10: Rotation & Shifting](#pattern-10-rotation--shifting)
12. [Pattern 11: Palindrome Checking](#pattern-11-palindrome-checking)
13. [Pattern 12: Sorting Patterns](#pattern-12-sorting-patterns)
14. [Pattern 13: Advanced Problems](#pattern-13-advanced-problems)

---

## Node Definition

```java
class ListNode {
    int val;
    ListNode next;

    ListNode(int val) {
        this.val = val;
    }

    ListNode(int val, ListNode next) {
        this.val = val;
        this.next = next;
    }
}

// Node with random pointer
class Node {
    int val;
    Node next;
    Node random;

    Node(int val) {
        this.val = val;
    }
}

// Doubly LinkedList Node
class DNode {
    int val;
    DNode prev;
    DNode next;

    DNode(int val) {
        this.val = val;
    }
}
```

---

## Pattern 1: Two Pointer Technique

### 1.1 Find Middle of LinkedList

```java
ListNode findMiddle(ListNode head) {
    if (head == null) return null;

    ListNode slow = head;
    ListNode fast = head;

    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }

    return slow;
}

// Return first middle if even number of nodes
ListNode findMiddleFirst(ListNode head) {
    if (head == null) return null;

    ListNode slow = head;
    ListNode fast = head.next;

    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }

    return slow;
}
```

### 1.2 Nth Node from End

```java
ListNode nthFromEnd(ListNode head, int n) {
    ListNode first = head;
    ListNode second = head;

    // Move first pointer n steps ahead
    for (int i = 0; i < n; i++) {
        if (first == null) return null;
        first = first.next;
    }

    // Move both pointers until first reaches end
    while (first != null) {
        first = first.next;
        second = second.next;
    }

    return second;
}
```

### 1.3 Remove Nth Node from End

```java
ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode dummy = new ListNode(0);
    dummy.next = head;

    ListNode first = dummy;
    ListNode second = dummy;

    // Move first n+1 steps ahead
    for (int i = 0; i <= n; i++) {
        first = first.next;
    }

    // Move both until first reaches end
    while (first != null) {
        first = first.next;
        second = second.next;
    }

    // Remove nth node
    second.next = second.next.next;

    return dummy.next;
}
```

### 1.4 Find Length of LinkedList

```java
int length(ListNode head) {
    int count = 0;
    ListNode curr = head;

    while (curr != null) {
        count++;
        curr = curr.next;
    }

    return count;
}
```

### 1.5 Check if Length is Even or Odd

```java
boolean isLengthEven(ListNode head) {
    ListNode curr = head;

    while (curr != null && curr.next != null) {
        curr = curr.next.next;
    }

    return curr == null; // Even if null, odd if not null
}
```

---

## Pattern 2: Fast & Slow Pointer (Cycle Detection)

### 2.1 Detect Cycle (Floyd's Algorithm)

```java
boolean hasCycle(ListNode head) {
    if (head == null) return false;

    ListNode slow = head;
    ListNode fast = head;

    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;

        if (slow == fast) {
            return true;
        }
    }

    return false;
}
```

### 2.2 Find Start of Cycle

```java
ListNode detectCycle(ListNode head) {
    if (head == null) return null;

    ListNode slow = head;
    ListNode fast = head;

    // Find meeting point
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;

        if (slow == fast) {
            // Cycle detected, find start
            ListNode start = head;
            while (start != slow) {
                start = start.next;
                slow = slow.next;
            }
            return start;
        }
    }

    return null;
}
```

### 2.3 Find Length of Cycle

```java
int lengthOfCycle(ListNode head) {
    if (head == null) return 0;

    ListNode slow = head;
    ListNode fast = head;

    // Detect cycle
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;

        if (slow == fast) {
            // Count cycle length
            int count = 1;
            ListNode temp = slow.next;
            while (temp != slow) {
                count++;
                temp = temp.next;
            }
            return count;
        }
    }

    return 0;
}
```

### 2.4 Remove Cycle

```java
void removeCycle(ListNode head) {
    if (head == null) return;

    ListNode slow = head;
    ListNode fast = head;

    // Detect cycle
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;

        if (slow == fast) {
            // Find start of cycle
            ListNode start = head;
            ListNode prev = null;

            if (start == slow) {
                // Special case: cycle starts at head
                while (slow.next != start) {
                    slow = slow.next;
                }
                slow.next = null;
            } else {
                while (start != slow) {
                    prev = slow;
                    start = start.next;
                    slow = slow.next;
                }
                prev.next = null;
            }
            return;
        }
    }
}
```

### 2.5 Happy Number (Cycle Detection Application)

```java
boolean isHappy(int n) {
    int slow = n;
    int fast = n;

    do {
        slow = sumOfSquares(slow);
        fast = sumOfSquares(sumOfSquares(fast));
    } while (slow != fast);

    return slow == 1;
}

int sumOfSquares(int n) {
    int sum = 0;
    while (n > 0) {
        int digit = n % 10;
        sum += digit * digit;
        n /= 10;
    }
    return sum;
}
```

---

## Pattern 3: Reversal Patterns

### 3.1 Reverse Entire LinkedList

```java
// Iterative
ListNode reverseList(ListNode head) {
    ListNode prev = null;
    ListNode curr = head;

    while (curr != null) {
        ListNode next = curr.next;
        curr.next = prev;
        prev = curr;
        curr = next;
    }

    return prev;
}

// Recursive
ListNode reverseListRecursive(ListNode head) {
    if (head == null || head.next == null) {
        return head;
    }

    ListNode newHead = reverseListRecursive(head.next);
    head.next.next = head;
    head.next = null;

    return newHead;
}
```

### 3.2 Reverse in Groups of K

```java
ListNode reverseKGroup(ListNode head, int k) {
    ListNode curr = head;
    int count = 0;

    // Check if we have k nodes
    while (curr != null && count < k) {
        curr = curr.next;
        count++;
    }

    if (count == k) {
        // Reverse first k nodes
        curr = reverseK(head, k);

        // Recursively reverse remaining
        head.next = reverseKGroup(curr, k);
        return curr;
    }

    return head;
}

ListNode reverseK(ListNode head, int k) {
    ListNode prev = null;
    ListNode curr = head;

    while (k > 0) {
        ListNode next = curr.next;
        curr.next = prev;
        prev = curr;
        curr = next;
        k--;
    }

    return prev;
}
```

### 3.3 Reverse Between Left and Right

```java
ListNode reverseBetween(ListNode head, int left, int right) {
    if (head == null || left == right) return head;

    ListNode dummy = new ListNode(0);
    dummy.next = head;
    ListNode prev = dummy;

    // Move to position before left
    for (int i = 1; i < left; i++) {
        prev = prev.next;
    }

    // Reverse from left to right
    ListNode curr = prev.next;
    for (int i = 0; i < right - left; i++) {
        ListNode next = curr.next;
        curr.next = next.next;
        next.next = prev.next;
        prev.next = next;
    }

    return dummy.next;
}
```

### 3.4 Reverse Alternate K Nodes

```java
ListNode reverseAlternateK(ListNode head, int k) {
    if (head == null) return null;

    ListNode curr = head;
    ListNode prev = null;
    int count = 0;

    // Reverse first k nodes
    while (curr != null && count < k) {
        ListNode next = curr.next;
        curr.next = prev;
        prev = curr;
        curr = next;
        count++;
    }

    if (head != null) {
        // Skip next k nodes
        head.next = curr;
        count = 0;
        while (curr != null && count < k - 1) {
            curr = curr.next;
            count++;
        }

        // Recursively reverse remaining
        if (curr != null) {
            curr.next = reverseAlternateK(curr.next, k);
        }
    }

    return prev;
}
```

### 3.5 Reverse Nodes in Even Length Groups

```java
ListNode reverseEvenLengthGroups(ListNode head) {
    ListNode dummy = new ListNode(0, head);
    ListNode prev = dummy;
    int groupLen = 1;

    while (prev.next != null) {
        ListNode groupStart = prev.next;
        ListNode curr = groupStart;
        int actualLen = 0;

        // Count actual group length
        while (curr != null && actualLen < groupLen) {
            curr = curr.next;
            actualLen++;
        }

        // Reverse if even length
        if (actualLen % 2 == 0) {
            ListNode groupEnd = reverse(groupStart, actualLen);
            prev.next = groupEnd;
            prev = groupStart;
        } else {
            for (int i = 0; i < actualLen; i++) {
                prev = prev.next;
            }
        }

        groupLen++;
    }

    return dummy.next;
}

ListNode reverse(ListNode head, int k) {
    ListNode prev = null;
    ListNode curr = head;

    while (k > 0) {
        ListNode next = curr.next;
        curr.next = prev;
        prev = curr;
        curr = next;
        k--;
    }

    head.next = curr;
    return prev;
}
```

---

## Pattern 4: Merging Patterns

### 4.1 Merge Two Sorted Lists

```java
ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    ListNode dummy = new ListNode(0);
    ListNode curr = dummy;

    while (l1 != null && l2 != null) {
        if (l1.val <= l2.val) {
            curr.next = l1;
            l1 = l1.next;
        } else {
            curr.next = l2;
            l2 = l2.next;
        }
        curr = curr.next;
    }

    curr.next = (l1 != null) ? l1 : l2;

    return dummy.next;
}

// Recursive
ListNode mergeTwoListsRecursive(ListNode l1, ListNode l2) {
    if (l1 == null) return l2;
    if (l2 == null) return l1;

    if (l1.val <= l2.val) {
        l1.next = mergeTwoListsRecursive(l1.next, l2);
        return l1;
    } else {
        l2.next = mergeTwoListsRecursive(l1, l2.next);
        return l2;
    }
}
```

### 4.2 Merge K Sorted Lists

```java
// Using Min Heap
ListNode mergeKLists(ListNode[] lists) {
    if (lists == null || lists.length == 0) return null;

    PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);

    // Add first node of each list
    for (ListNode list : lists) {
        if (list != null) {
            pq.offer(list);
        }
    }

    ListNode dummy = new ListNode(0);
    ListNode curr = dummy;

    while (!pq.isEmpty()) {
        ListNode node = pq.poll();
        curr.next = node;
        curr = curr.next;

        if (node.next != null) {
            pq.offer(node.next);
        }
    }

    return dummy.next;
}

// Divide and Conquer
ListNode mergeKListsDivideConquer(ListNode[] lists) {
    if (lists == null || lists.length == 0) return null;
    return mergeHelper(lists, 0, lists.length - 1);
}

ListNode mergeHelper(ListNode[] lists, int left, int right) {
    if (left == right) return lists[left];

    int mid = left + (right - left) / 2;
    ListNode l1 = mergeHelper(lists, left, mid);
    ListNode l2 = mergeHelper(lists, mid + 1, right);

    return mergeTwoLists(l1, l2);
}
```

### 4.3 Merge In Between Linked Lists

```java
ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {
    ListNode curr = list1;

    // Move to node before position a
    for (int i = 0; i < a - 1; i++) {
        curr = curr.next;
    }

    ListNode nodeBeforeA = curr;

    // Move to node at position b
    for (int i = a - 1; i <= b; i++) {
        curr = curr.next;
    }

    ListNode nodeAfterB = curr;

    // Connect list2
    nodeBeforeA.next = list2;

    // Find end of list2
    while (list2.next != null) {
        list2 = list2.next;
    }

    list2.next = nodeAfterB;

    return list1;
}
```

### 4.4 Flatten Multilevel Doubly LinkedList

```java
class Node {
    int val;
    Node prev, next, child;
}

Node flatten(Node head) {
    if (head == null) return null;

    Node curr = head;

    while (curr != null) {
        if (curr.child != null) {
            Node next = curr.next;
            Node child = flatten(curr.child);

            curr.next = child;
            child.prev = curr;
            curr.child = null;

            // Find end of child list
            while (curr.next != null) {
                curr = curr.next;
            }

            if (next != null) {
                curr.next = next;
                next.prev = curr;
            }
        }
        curr = curr.next;
    }

    return head;
}
```

---

## Pattern 5: Intersection & Union

### 5.1 Intersection of Two Linked Lists

```java
ListNode getIntersectionNode(ListNode headA, ListNode headB) {
    if (headA == null || headB == null) return null;

    ListNode a = headA;
    ListNode b = headB;

    // When a reaches end, redirect to headB
    // When b reaches end, redirect to headA
    // They will meet at intersection or null
    while (a != b) {
        a = (a == null) ? headB : a.next;
        b = (b == null) ? headA : b.next;
    }

    return a;
}

// Using length difference
ListNode getIntersectionNode2(ListNode headA, ListNode headB) {
    int lenA = length(headA);
    int lenB = length(headB);

    // Move longer list's pointer ahead
    while (lenA > lenB) {
        headA = headA.next;
        lenA--;
    }

    while (lenB > lenA) {
        headB = headB.next;
        lenB--;
    }

    // Move both together
    while (headA != headB) {
        headA = headA.next;
        headB = headB.next;
    }

    return headA;
}

int length(ListNode head) {
    int count = 0;
    while (head != null) {
        count++;
        head = head.next;
    }
    return count;
}
```

### 5.2 Union of Two Linked Lists

```java
ListNode union(ListNode head1, ListNode head2) {
    HashSet<Integer> set = new HashSet<>();
    ListNode curr = head1;

    while (curr != null) {
        set.add(curr.val);
        curr = curr.next;
    }

    curr = head2;
    while (curr != null) {
        set.add(curr.val);
        curr = curr.next;
    }

    // Create result list
    ListNode dummy = new ListNode(0);
    curr = dummy;

    for (int val : set) {
        curr.next = new ListNode(val);
        curr = curr.next;
    }

    return dummy.next;
}
```

---

## Pattern 6: Removal Patterns

### 6.1 Remove Duplicates from Sorted List

```java
ListNode deleteDuplicates(ListNode head) {
    ListNode curr = head;

    while (curr != null && curr.next != null) {
        if (curr.val == curr.next.val) {
            curr.next = curr.next.next;
        } else {
            curr = curr.next;
        }
    }

    return head;
}
```

### 6.2 Remove All Duplicates from Sorted List

```java
ListNode deleteDuplicates(ListNode head) {
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    ListNode prev = dummy;

    while (head != null) {
        // Skip all duplicates
        if (head.next != null && head.val == head.next.val) {
            while (head.next != null && head.val == head.next.val) {
                head = head.next;
            }
            prev.next = head.next;
        } else {
            prev = prev.next;
        }
        head = head.next;
    }

    return dummy.next;
}
```

### 6.3 Remove Elements with Given Value

```java
ListNode removeElements(ListNode head, int val) {
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    ListNode curr = dummy;

    while (curr.next != null) {
        if (curr.next.val == val) {
            curr.next = curr.next.next;
        } else {
            curr = curr.next;
        }
    }

    return dummy.next;
}
```

### 6.4 Remove Nodes with Greater Value on Right

```java
ListNode removeNodes(ListNode head) {
    if (head == null) return null;

    // Reverse the list
    head = reverseList(head);

    ListNode curr = head;
    int max = head.val;

    while (curr.next != null) {
        if (curr.next.val < max) {
            curr.next = curr.next.next;
        } else {
            max = curr.next.val;
            curr = curr.next;
        }
    }

    // Reverse back
    return reverseList(head);
}
```

### 6.5 Delete Middle Node

```java
ListNode deleteMiddle(ListNode head) {
    if (head == null || head.next == null) return null;

    ListNode slow = head;
    ListNode fast = head;
    ListNode prev = null;

    while (fast != null && fast.next != null) {
        prev = slow;
        slow = slow.next;
        fast = fast.next.next;
    }

    prev.next = slow.next;
    return head;
}
```

### 6.6 Remove Zero Sum Consecutive Nodes

```java
ListNode removeZeroSumSublists(ListNode head) {
    ListNode dummy = new ListNode(0);
    dummy.next = head;

    HashMap<Integer, ListNode> map = new HashMap<>();
    int prefixSum = 0;

    for (ListNode curr = dummy; curr != null; curr = curr.next) {
        prefixSum += curr.val;
        map.put(prefixSum, curr);
    }

    prefixSum = 0;
    for (ListNode curr = dummy; curr != null; curr = curr.next) {
        prefixSum += curr.val;
        curr.next = map.get(prefixSum).next;
    }

    return dummy.next;
}
```

---

## Pattern 7: Partition & Splitting

### 7.1 Partition List

```java
ListNode partition(ListNode head, int x) {
    ListNode lessHead = new ListNode(0);
    ListNode greaterHead = new ListNode(0);

    ListNode less = lessHead;
    ListNode greater = greaterHead;

    while (head != null) {
        if (head.val < x) {
            less.next = head;
            less = less.next;
        } else {
            greater.next = head;
            greater = greater.next;
        }
        head = head.next;
    }

    greater.next = null;
    less.next = greaterHead.next;

    return lessHead.next;
}
```

### 7.2 Odd Even Linked List

```java
ListNode oddEvenList(ListNode head) {
    if (head == null) return null;

    ListNode odd = head;
    ListNode even = head.next;
    ListNode evenHead = even;

    while (even != null && even.next != null) {
        odd.next = even.next;
        odd = odd.next;
        even.next = odd.next;
        even = even.next;
    }

    odd.next = evenHead;
    return head;
}
```

### 7.3 Split List into Parts

```java
ListNode[] splitListToParts(ListNode head, int k) {
    int len = 0;
    ListNode curr = head;
    while (curr != null) {
        len++;
        curr = curr.next;
    }

    int partSize = len / k;
    int extra = len % k;

    ListNode[] result = new ListNode[k];
    curr = head;

    for (int i = 0; i < k; i++) {
        result[i] = curr;
        int currentPartSize = partSize + (extra > 0 ? 1 : 0);
        extra--;

        for (int j = 0; j < currentPartSize - 1 && curr != null; j++) {
            curr = curr.next;
        }

        if (curr != null) {
            ListNode next = curr.next;
            curr.next = null;
            curr = next;
        }
    }

    return result;
}
```

### 7.4 Separate Even and Odd Values

```java
ListNode[] separateEvenOdd(ListNode head) {
    ListNode evenHead = new ListNode(0);
    ListNode oddHead = new ListNode(0);

    ListNode even = evenHead;
    ListNode odd = oddHead;

    while (head != null) {
        if (head.val % 2 == 0) {
            even.next = head;
            even = even.next;
        } else {
            odd.next = head;
            odd = odd.next;
        }
        head = head.next;
    }

    even.next = null;
    odd.next = null;

    return new ListNode[]{evenHead.next, oddHead.next};
}
```

---

## Pattern 8: Addition & Arithmetic

### 8.1 Add Two Numbers

```java
ListNode addTwoNumbers(ListNode l1, ListNode l2) {
    ListNode dummy = new ListNode(0);
    ListNode curr = dummy;
    int carry = 0;

    while (l1 != null || l2 != null || carry != 0) {
        int sum = carry;

        if (l1 != null) {
            sum += l1.val;
            l1 = l1.next;
        }

        if (l2 != null) {
            sum += l2.val;
            l2 = l2.next;
        }

        carry = sum / 10;
        curr.next = new ListNode(sum % 10);
        curr = curr.next;
    }

    return dummy.next;
}
```

### 8.2 Add Two Numbers II (Most significant digit first)

```java
ListNode addTwoNumbers(ListNode l1, ListNode l2) {
    // Reverse both lists
    l1 = reverseList(l1);
    l2 = reverseList(l2);

    // Add reversed lists
    ListNode result = addTwoNumbers(l1, l2);

    // Reverse result
    return reverseList(result);
}

// Alternative: Using Stack
ListNode addTwoNumbersStack(ListNode l1, ListNode l2) {
    Deque<Integer> s1 = new ArrayDeque<>();
    Deque<Integer> s2 = new ArrayDeque<>();

    while (l1 != null) {
        s1.push(l1.val);
        l1 = l1.next;
    }

    while (l2 != null) {
        s2.push(l2.val);
        l2 = l2.next;
    }

    ListNode head = null;
    int carry = 0;

    while (!s1.isEmpty() || !s2.isEmpty() || carry != 0) {
        int sum = carry;

        if (!s1.isEmpty()) sum += s1.pop();
        if (!s2.isEmpty()) sum += s2.pop();

        ListNode node = new ListNode(sum % 10);
        node.next = head;
        head = node;

        carry = sum / 10;
    }

    return head;
}
```

### 8.3 Multiply Two Numbers Represented by LinkedLists

```java
long multiplyTwoLists(ListNode l1, ListNode l2) {
    long num1 = 0, num2 = 0;
    long MOD = 1000000007;

    while (l1 != null) {
        num1 = ((num1 * 10) + l1.val) % MOD;
        l1 = l1.next;
    }

    while (l2 != null) {
        num2 = ((num2 * 10) + l2.val) % MOD;
        l2 = l2.next;
    }

    return (num1 * num2) % MOD;
}
```

### 8.4 Subtract Two Numbers

```java
ListNode subtract(ListNode l1, ListNode l2) {
    // Reverse both lists
    l1 = reverseList(l1);
    l2 = reverseList(l2);

    ListNode dummy = new ListNode(0);
    ListNode curr = dummy;
    int borrow = 0;

    while (l1 != null) {
        int diff = l1.val - borrow;

        if (l2 != null) {
            diff -= l2.val;
            l2 = l2.next;
        }

        if (diff < 0) {
            diff += 10;
            borrow = 1;
        } else {
            borrow = 0;
        }

        curr.next = new ListNode(diff);
        curr = curr.next;
        l1 = l1.next;
    }

    // Reverse result and remove leading zeros
    ListNode result = reverseList(dummy.next);
    while (result != null && result.val == 0 && result.next != null) {
        result = result.next;
    }

    return result;
}
```

---

## Pattern 9: Deep Copy & Cloning

### 9.1 Copy List with Random Pointer

```java
Node copyRandomList(Node head) {
    if (head == null) return null;

    // Step 1: Create copy nodes interleaved with original
    Node curr = head;
    while (curr != null) {
        Node copy = new Node(curr.val);
        copy.next = curr.next;
        curr.next = copy;
        curr = copy.next;
    }

    // Step 2: Assign random pointers
    curr = head;
    while (curr != null) {
        if (curr.random != null) {
            curr.next.random = curr.random.next;
        }
        curr = curr.next.next;
    }

    // Step 3: Separate the lists
    curr = head;
    Node copyHead = head.next;
    Node copyCurr = copyHead;

    while (curr != null) {
        curr.next = curr.next.next;
        if (copyCurr.next != null) {
            copyCurr.next = copyCurr.next.next;
        }
        curr = curr.next;
        copyCurr = copyCurr.next;
    }

    return copyHead;
}

// Using HashMap
Node copyRandomListHashMap(Node head) {
    if (head == null) return null;

    HashMap<Node, Node> map = new HashMap<>();
    Node curr = head;

    // First pass: create all nodes
    while (curr != null) {
        map.put(curr, new Node(curr.val));
        curr = curr.next;
    }

    // Second pass: assign next and random
    curr = head;
    while (curr != null) {
        map.get(curr).next = map.get(curr.next);
        map.get(curr).random = map.get(curr.random);
        curr = curr.next;
    }

    return map.get(head);
}
```

### 9.2 Clone Linked List with Arbitrary Pointer

```java
Node cloneLinkedList(Node head) {
    if (head == null) return null;

    HashMap<Node, Node> map = new HashMap<>();
    Node curr = head;

    // Create all nodes
    while (curr != null) {
        map.put(curr, new Node(curr.val));
        curr = curr.next;
    }

    // Link all pointers
    curr = head;
    while (curr != null) {
        Node clone = map.get(curr);
        clone.next = map.get(curr.next);
        clone.random = map.get(curr.random);
        curr = curr.next;
    }

    return map.get(head);
}
```

---

## Pattern 10: Rotation & Shifting

### 10.1 Rotate List

```java
ListNode rotateRight(ListNode head, int k) {
    if (head == null || head.next == null || k == 0) return head;

    // Find length and connect to make circular
    int len = 1;
    ListNode tail = head;
    while (tail.next != null) {
        tail = tail.next;
        len++;
    }

    tail.next = head;

    // Find new tail position
    k = k % len;
    int stepsToNewTail = len - k;

    ListNode newTail = head;
    for (int i = 1; i < stepsToNewTail; i++) {
        newTail = newTail.next;
    }

    ListNode newHead = newTail.next;
    newTail.next = null;

    return newHead;
}
```

### 10.2 Rotate List to Left

```java
ListNode rotateLeft(ListNode head, int k) {
    if (head == null || head.next == null || k == 0) return head;

    int len = 1;
    ListNode tail = head;
    while (tail.next != null) {
        tail = tail.next;
        len++;
    }

    k = k % len;
    if (k == 0) return head;

    // Find new tail
    ListNode newTail = head;
    for (int i = 1; i < k; i++) {
        newTail = newTail.next;
    }

    ListNode newHead = newTail.next;
    newTail.next = null;
    tail.next = head;

    return newHead;
}
```

### 10.3 Swap Nodes in Pairs

```java
ListNode swapPairs(ListNode head) {
    if (head == null || head.next == null) return head;

    ListNode dummy = new ListNode(0);
    dummy.next = head;
    ListNode prev = dummy;

    while (head != null && head.next != null) {
        ListNode first = head;
        ListNode second = head.next;

        // Swap
        prev.next = second;
        first.next = second.next;
        second.next = first;

        // Move pointers
        prev = first;
        head = first.next;
    }

    return dummy.next;
}

// Recursive
ListNode swapPairsRecursive(ListNode head) {
    if (head == null || head.next == null) return head;

    ListNode newHead = head.next;
    head.next = swapPairsRecursive(newHead.next);
    newHead.next = head;

    return newHead;
}
```

### 10.4 Swap Kth Node from Beginning and End

```java
ListNode swapNodes(ListNode head, int k) {
    ListNode first = head;
    ListNode second = head;
    ListNode curr = head;

    // Move to kth node from beginning
    for (int i = 1; i < k; i++) {
        curr = curr.next;
    }
    first = curr;

    // Find kth from end
    while (curr.next != null) {
        curr = curr.next;
        second = second.next;
    }

    // Swap values
    int temp = first.val;
    first.val = second.val;
    second.val = temp;

    return head;
}
```

### 10.5 Reorder List (L0 → Ln → L1 → Ln-1...)

```java
void reorderList(ListNode head) {
    if (head == null || head.next == null) return;

    // Find middle
    ListNode slow = head;
    ListNode fast = head;
    while (fast.next != null && fast.next.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }

    // Reverse second half
    ListNode second = reverseList(slow.next);
    slow.next = null;

    // Merge two halves
    ListNode first = head;
    while (second != null) {
        ListNode temp1 = first.next;
        ListNode temp2 = second.next;

        first.next = second;
        second.next = temp1;

        first = temp1;
        second = temp2;
    }
}
```

---

## Pattern 11: Palindrome Checking

### 11.1 Palindrome Linked List

```java
boolean isPalindrome(ListNode head) {
    if (head == null || head.next == null) return true;

    // Find middle
    ListNode slow = head;
    ListNode fast = head;
    while (fast.next != null && fast.next.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }

    // Reverse second half
    ListNode secondHalf = reverseList(slow.next);

    // Compare
    ListNode p1 = head;
    ListNode p2 = secondHalf;

    while (p2 != null) {
        if (p1.val != p2.val) {
            return false;
        }
        p1 = p1.next;
        p2 = p2.next;
    }

    return true;
}

// Using Stack
boolean isPalindromeStack(ListNode head) {
    Deque<Integer> stack = new ArrayDeque<>();
    ListNode curr = head;

    while (curr != null) {
        stack.push(curr.val);
        curr = curr.next;
    }

    curr = head;
    while (curr != null) {
        if (curr.val != stack.pop()) {
            return false;
        }
        curr = curr.next;
    }

    return true;
}
```

### 11.2 Check if Palindrome after Removing One Node

```java
boolean isPalindromeAfterRemoval(ListNode head) {
    List<Integer> list = new ArrayList<>();
    ListNode curr = head;

    while (curr != null) {
        list.add(curr.val);
        curr = curr.next;
    }

    // Try removing each node
    for (int i = 0; i < list.size(); i++) {
        if (isPalindromeList(list, i)) {
            return true;
        }
    }

    return false;
}

boolean isPalindromeList(List<Integer> list, int skip) {
    int left = 0, right = list.size() - 1;

    while (left < right) {
        if (left == skip) left++;
        if (right == skip) right--;

        if (left < right && !list.get(left).equals(list.get(right))) {
            return false;
        }

        left++;
        right--;
    }

    return true;
}
```

---

## Pattern 12: Sorting Patterns

### 12.1 Insertion Sort List

```java
ListNode insertionSortList(ListNode head) {
    ListNode dummy = new ListNode(0);
    ListNode curr = head;

    while (curr != null) {
        ListNode prev = dummy;

        // Find position to insert
        while (prev.next != null && prev.next.val < curr.val) {
            prev = prev.next;
        }

        // Insert
        ListNode next = curr.next;
        curr.next = prev.next;
        prev.next = curr;
        curr = next;
    }

    return dummy.next;
}
```

### 12.2 Merge Sort List

```java
ListNode sortList(ListNode head) {
    if (head == null || head.next == null) return head;

    // Find middle
    ListNode slow = head;
    ListNode fast = head;
    ListNode prev = null;

    while (fast != null && fast.next != null) {
        prev = slow;
        slow = slow.next;
        fast = fast.next.next;
    }

    prev.next = null;

    // Sort both halves
    ListNode left = sortList(head);
    ListNode right = sortList(slow);

    // Merge
    return mergeTwoLists(left, right);
}
```

### 12.3 Quick Sort List

```java
ListNode quickSort(ListNode head) {
    if (head == null || head.next == null) return head;

    // Choose pivot (last node)
    ListNode pivot = getTail(head);

    // Partition
    ListNode[] partitions = partition(head, pivot);
    ListNode less = partitions[0];
    ListNode equal = partitions[1];
    ListNode greater = partitions[2];

    // Recursively sort
    less = quickSort(less);
    greater = quickSort(greater);

    // Combine
    return combine(less, equal, greater);
}

ListNode getTail(ListNode head) {
    while (head.next != null) {
        head = head.next;
    }
    return head;
}

ListNode[] partition(ListNode head, ListNode pivot) {
    ListNode lessHead = new ListNode(0);
    ListNode equalHead = new ListNode(0);
    ListNode greaterHead = new ListNode(0);

    ListNode less = lessHead;
    ListNode equal = equalHead;
    ListNode greater = greaterHead;

    while (head != null) {
        if (head.val < pivot.val) {
            less.next = head;
            less = less.next;
        } else if (head.val > pivot.val) {
            greater.next = head;
            greater = greater.next;
        } else {
            equal.next = head;
            equal = equal.next;
        }
        head = head.next;
    }

    less.next = null;
    equal.next = null;
    greater.next = null;

    return new ListNode[]{lessHead.next, equalHead.next, greaterHead.next};
}

ListNode combine(ListNode less, ListNode equal, ListNode greater) {
    ListNode dummy = new ListNode(0);
    ListNode curr = dummy;

    if (less != null) {
        curr.next = less;
        while (curr.next != null) curr = curr.next;
    }

    if (equal != null) {
        curr.next = equal;
        while (curr.next != null) curr = curr.next;
    }

    if (greater != null) {
        curr.next = greater;
    }

    return dummy.next;
}
```

### 12.4 Sort List with 0s, 1s, and 2s

```java
ListNode sortList012(ListNode head) {
    int[] count = new int[3];
    ListNode curr = head;

    // Count occurrences
    while (curr != null) {
        count[curr.val]++;
        curr = curr.next;
    }

    // Reconstruct list
    curr = head;
    int i = 0;
    while (curr != null) {
        if (count[i] == 0) {
            i++;
        } else {
            curr.val = i;
            count[i]--;
            curr = curr.next;
        }
    }

    return head;
}

// Without modifying data (rearranging pointers)
ListNode sortList012Pointers(ListNode head) {
    ListNode zeroHead = new ListNode(0);
    ListNode oneHead = new ListNode(0);
    ListNode twoHead = new ListNode(0);

    ListNode zero = zeroHead;
    ListNode one = oneHead;
    ListNode two = twoHead;

    while (head != null) {
        if (head.val == 0) {
            zero.next = head;
            zero = zero.next;
        } else if (head.val == 1) {
            one.next = head;
            one = one.next;
        } else {
            two.next = head;
            two = two.next;
        }
        head = head.next;
    }

    zero.next = oneHead.next != null ? oneHead.next : twoHead.next;
    one.next = twoHead.next;
    two.next = null;

    return zeroHead.next;
}
```

---

## Pattern 13: Advanced Problems

### 13.1 LRU Cache Implementation

```java
class LRUCache {
    class Node {
        int key, value;
        Node prev, next;

        Node(int key, int value) {
            this.key = key;
            this.value = value;
        }
    }

    private HashMap<Integer, Node> map;
    private Node head, tail;
    private int capacity;

    public LRUCache(int capacity) {
        this.capacity = capacity;
        map = new HashMap<>();
        head = new Node(0, 0);
        tail = new Node(0, 0);
        head.next = tail;
        tail.prev = head;
    }

    public int get(int key) {
        if (!map.containsKey(key)) return -1;

        Node node = map.get(key);
        remove(node);
        addToHead(node);

        return node.value;
    }

    public void put(int key, int value) {
        if (map.containsKey(key)) {
            Node node = map.get(key);
            node.value = value;
            remove(node);
            addToHead(node);
        } else {
            if (map.size() == capacity) {
                Node lru = tail.prev;
                remove(lru);
                map.remove(lru.key);
            }

            Node node = new Node(key, value);
            map.put(key, node);
            addToHead(node);
        }
    }

    private void remove(Node node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }

    private void addToHead(Node node) {
        node.next = head.next;
        node.prev = head;
        head.next.prev = node;
        head.next = node;
    }
}
```

### 13.2 Flatten a Binary Tree to Linked List

```java
void flatten(TreeNode root) {
    if (root == null) return;

    flatten(root.left);
    flatten(root.right);

    TreeNode right = root.right;
    root.right = root.left;
    root.left = null;

    TreeNode curr = root;
    while (curr.right != null) {
        curr = curr.right;
    }
    curr.right = right;
}
```

### 13.3 Convert Binary Tree to Doubly Linked List

```java
class TreeNode {
    int val;
    TreeNode left, right;
    TreeNode(int val) { this.val = val; }
}

TreeNode prev = null;

TreeNode treeToDoublyList(TreeNode root) {
    if (root == null) return null;

    TreeNode dummy = new TreeNode(0);
    prev = dummy;

    inorder(root);

    // Make circular
    prev.right = dummy.right;
    dummy.right.left = prev;

    return dummy.right;
}

void inorder(TreeNode node) {
    if (node == null) return;

    inorder(node.left);

    prev.right = node;
    node.left = prev;
    prev = node;

    inorder(node.right);
}
```

### 13.4 Design Browser History

```java
class BrowserHistory {
    class Node {
        String url;
        Node prev, next;

        Node(String url) {
            this.url = url;
        }
    }

    Node current;

    public BrowserHistory(String homepage) {
        current = new Node(homepage);
    }

    public void visit(String url) {
        Node newNode = new Node(url);
        current.next = newNode;
        newNode.prev = current;
        current = newNode;
    }

    public String back(int steps) {
        while (steps > 0 && current.prev != null) {
            current = current.prev;
            steps--;
        }
        return current.url;
    }

    public String forward(int steps) {
        while (steps > 0 && current.next != null) {
            current = current.next;
            steps--;
        }
        return current.url;
    }
}
```

### 13.5 Design Skiplist

```java
class Skiplist {
    class Node {
        int val;
        Node[] next;

        Node(int val, int level) {
            this.val = val;
            next = new Node[level + 1];
        }
    }

    private static final int MAX_LEVEL = 16;
    private Node head;
    private int level;

    public Skiplist() {
        head = new Node(-1, MAX_LEVEL);
        level = 0;
    }

    public boolean search(int target) {
        Node curr = head;

        for (int i = level; i >= 0; i--) {
            while (curr.next[i] != null && curr.next[i].val < target) {
                curr = curr.next[i];
            }
        }

        curr = curr.next[0];
        return curr != null && curr.val == target;
    }

    public void add(int num) {
        Node[] update = new Node[MAX_LEVEL + 1];
        Node curr = head;

        for (int i = level; i >= 0; i--) {
            while (curr.next[i] != null && curr.next[i].val < num) {
                curr = curr.next[i];
            }
            update[i] = curr;
        }

        int newLevel = randomLevel();
        if (newLevel > level) {
            for (int i = level + 1; i <= newLevel; i++) {
                update[i] = head;
            }
            level = newLevel;
        }

        Node newNode = new Node(num, newLevel);
        for (int i = 0; i <= newLevel; i++) {
            newNode.next[i] = update[i].next[i];
            update[i].next[i] = newNode;
        }
    }

    public boolean erase(int num) {
        Node[] update = new Node[MAX_LEVEL + 1];
        Node curr = head;

        for (int i = level; i >= 0; i--) {
            while (curr.next[i] != null && curr.next[i].val < num) {
                curr = curr.next[i];
            }
            update[i] = curr;
        }

        curr = curr.next[0];

        if (curr == null || curr.val != num) {
            return false;
        }

        for (int i = 0; i <= level; i++) {
            if (update[i].next[i] != curr) break;
            update[i].next[i] = curr.next[i];
        }

        while (level > 0 && head.next[level] == null) {
            level--;
        }

        return true;
    }

    private int randomLevel() {
        int lvl = 0;
        while (Math.random() < 0.5 && lvl < MAX_LEVEL) {
            lvl++;
        }
        return lvl;
    }
}
```

### 13.6 Reverse Nodes in k-Group (Hard)

```java
ListNode reverseKGroup(ListNode head, int k) {
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    ListNode prev = dummy;

    while (true) {
        ListNode kth = getKth(prev, k);
        if (kth == null) break;

        ListNode groupNext = kth.next;

        // Reverse group
        ListNode curr = prev.next;
        ListNode next = curr.next;

        while (next != groupNext) {
            curr.next = next.next;
            next.next = prev.next;
            prev.next = next;
            next = curr.next;
        }

        prev = curr;
    }

    return dummy.next;
}

ListNode getKth(ListNode curr, int k) {
    while (curr != null && k > 0) {
        curr = curr.next;
        k--;
    }
    return curr;
}
```

---

## Time Complexity Cheat Sheet

| Operation          | Time Complexity           |
| ------------------ | ------------------------- |
| Access nth node    | O(n)                      |
| Search             | O(n)                      |
| Insert at head     | O(1)                      |
| Insert at tail     | O(n) without tail pointer |
| Insert at position | O(n)                      |
| Delete at head     | O(1)                      |
| Delete at tail     | O(n)                      |
| Delete at position | O(n)                      |
| Reverse            | O(n)                      |
| Detect cycle       | O(n)                      |
| Merge two lists    | O(n + m)                  |
| Sort               | O(n log n)                |

---

## Common Tricks & Tips

1. **Dummy Node**: Use for easier edge case handling
2. **Two Pointers**: Fast & slow for finding middle, cycle detection
3. **Reversal**: Many problems solved by reversing part/all of list
4. **HashMap**: For cloning with random pointers, finding intersections
5. **Stack**: For palindrome checking, reversing without modifying
6. **Recursion**: For elegant reversal, merging solutions
7. **Length Calculation**: Often needed for nth from end problems
8. **Circular Connection**: Useful for rotation problems

---
