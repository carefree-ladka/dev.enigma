# Binary Search

## Table of Contents

1. [Pattern 1: Basic Binary Search](#pattern-1-basic-binary-search)
2. [Pattern 2: Find Bounds (Lower/Upper)](#pattern-2-find-bounds-lowerupper)
3. [Pattern 3: Search Insert Position](#pattern-3-search-insert-position)
4. [Pattern 4: First \& Last Occurrence](#pattern-4-first--last-occurrence)
5. [Pattern 5: Peak Element](#pattern-5-peak-element)
6. [Pattern 6: Rotated Array Search](#pattern-6-rotated-array-search)
7. [Pattern 7: Search in 2D Matrix](#pattern-7-search-in-2d-matrix)
8. [Pattern 8: Minimum in Rotated Array](#pattern-8-minimum-in-rotated-array)
9. [Pattern 9: Search Range Problems](#pattern-9-search-range-problems)
10. [Pattern 10: Answer Search (Binary Search on Answer)](#pattern-10-answer-search-binary-search-on-answer)
11. [Pattern 11: Kth Element](#pattern-11-kth-element)
12. [Pattern 12: Median Problems](#pattern-12-median-problems)
13. [Pattern 13: Advanced Binary Search](#pattern-13-advanced-binary-search)

***

## Pattern 1: Basic Binary Search

### 1.1 Classic Binary Search

```java
int binarySearch(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;

        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return -1;
}

// Recursive version
int binarySearchRecursive(int[] nums, int target, int left, int right) {
    if (left > right) return -1;

    int mid = left + (right - left) / 2;

    if (nums[mid] == target) {
        return mid;
    } else if (nums[mid] < target) {
        return binarySearchRecursive(nums, target, mid + 1, right);
    } else {
        return binarySearchRecursive(nums, target, left, mid - 1);
    }
}
```


### 1.2 Binary Search with Duplicates

```java
boolean search(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;

        if (nums[mid] == target) {
            return true;
        }

        // Handle duplicates
        if (nums[left] == nums[mid] && nums[mid] == nums[right]) {
            left++;
            right--;
        } else if (nums[left] <= nums[mid]) {
            if (nums[left] <= target && target < nums[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        } else {
            if (nums[mid] < target && target <= nums[right]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
    }

    return false;
}
```


### 1.3 Find Element in Infinite Array

```java
int searchInInfinite(int[] nums, int target) {
    // Find bounds first
    int left = 0, right = 1;

    while (nums[right] < target) {
        left = right;
        right *= 2;
    }

    // Standard binary search
    return binarySearch(nums, target, left, right);
}

int binarySearch(int[] nums, int target, int left, int right) {
    while (left <= right) {
        int mid = left + (right - left) / 2;

        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return -1;
}
```


***

## Pattern 2: Find Bounds (Lower/Upper)

### 2.1 Lower Bound (Leftmost Position)

```java
int lowerBound(int[] nums, int target) {
    int left = 0;
    int right = nums.length;

    while (left < right) {
        int mid = left + (right - left) / 2;

        if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }

    return left;
}

// Alternative implementation
int lowerBoundAlt(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;
    int result = nums.length;

    while (left <= right) {
        int mid = left + (right - left) / 2;

        if (nums[mid] >= target) {
            result = mid;
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }

    return result;
}
```


### 2.2 Upper Bound (Rightmost Position)

```java
int upperBound(int[] nums, int target) {
    int left = 0;
    int right = nums.length;

    while (left < right) {
        int mid = left + (right - left) / 2;

        if (nums[mid] <= target) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }

    return left;
}

// Alternative implementation
int upperBoundAlt(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;
    int result = nums.length;

    while (left <= right) {
        int mid = left + (right - left) / 2;

        if (nums[mid] > target) {
            result = mid;
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }

    return result;
}
```


### 2.3 Count Occurrences

```java
int countOccurrences(int[] nums, int target) {
    int lower = lowerBound(nums, target);
    int upper = upperBound(nums, target);

    if (lower == nums.length || nums[lower] != target) {
        return 0;
    }

    return upper - lower;
}
```


***

## Pattern 3: Search Insert Position

### 3.1 Search Insert Position

```java
int searchInsert(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;

        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return left;
}

// Using lower bound
int searchInsertLB(int[] nums, int target) {
    return lowerBound(nums, target);
}
```


### 3.2 Find Closest Elements

```java
int findClosestElement(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;

    while (left < right) {
        int mid = left + (right - left) / 2;

        if (Math.abs(nums[mid] - target) <= Math.abs(nums[mid + 1] - target)) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }

    return nums[left];
}
```


### 3.3 Find K Closest Elements

```java
List<Integer> findClosestElements(int[] arr, int k, int x) {
    int left = 0;
    int right = arr.length - k;

    while (left < right) {
        int mid = left + (right - left) / 2;

        if (x - arr[mid] > arr[mid + k] - x) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }

    List<Integer> result = new ArrayList<>();
    for (int i = left; i < left + k; i++) {
        result.add(arr[i]);
    }

    return result;
}
```


***

## Pattern 4: First \& Last Occurrence

### 4.1 Find First and Last Position

```java
int[] searchRange(int[] nums, int target) {
    int[] result = {-1, -1};

    result[^1_0] = findFirst(nums, target);
    result[^1_1] = findLast(nums, target);

    return result;
}

int findFirst(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;
    int first = -1;

    while (left <= right) {
        int mid = left + (right - left) / 2;

        if (nums[mid] == target) {
            first = mid;
            right = mid - 1; // Continue searching left
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return first;
}

int findLast(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;
    int last = -1;

    while (left <= right) {
        int mid = left + (right - left) / 2;

        if (nums[mid] == target) {
            last = mid;
            left = mid + 1; // Continue searching right
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return last;
}
```


### 4.2 First Bad Version

```java
int firstBadVersion(int n) {
    int left = 1;
    int right = n;

    while (left < right) {
        int mid = left + (right - left) / 2;

        if (isBadVersion(mid)) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }

    return left;
}
```


### 4.3 Find First Greater Element

```java
int findFirstGreater(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;
    int result = -1;

    while (left <= right) {
        int mid = left + (right - left) / 2;

        if (nums[mid] > target) {
            result = mid;
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }

    return result;
}
```


***

## Pattern 5: Peak Element

### 5.1 Find Peak Element

```java
int findPeakElement(int[] nums) {
    int left = 0;
    int right = nums.length - 1;

    while (left < right) {
        int mid = left + (right - left) / 2;

        if (nums[mid] > nums[mid + 1]) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }

    return left;
}
```


### 5.2 Peak Index in Mountain Array

```java
int peakIndexInMountainArray(int[] arr) {
    int left = 0;
    int right = arr.length - 1;

    while (left < right) {
        int mid = left + (right - left) / 2;

        if (arr[mid] < arr[mid + 1]) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }

    return left;
}
```


### 5.3 Find Peak Element II (2D)

```java
int[] findPeakGrid(int[][] mat) {
    int left = 0;
    int right = mat[^1_0].length - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;
        int maxRowIndex = 0;

        // Find max element in column mid
        for (int i = 0; i < mat.length; i++) {
            if (mat[i][mid] > mat[maxRowIndex][mid]) {
                maxRowIndex = i;
            }
        }

        int leftVal = (mid == 0) ? -1 : mat[maxRowIndex][mid - 1];
        int rightVal = (mid == mat[^1_0].length - 1) ? -1 : mat[maxRowIndex][mid + 1];

        if (mat[maxRowIndex][mid] > leftVal && mat[maxRowIndex][mid] > rightVal) {
            return new int[]{maxRowIndex, mid};
        } else if (mat[maxRowIndex][mid] < leftVal) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }

    return new int[]{-1, -1};
}
```


***

## Pattern 6: Rotated Array Search

### 6.1 Search in Rotated Sorted Array

```java
int search(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;

        if (nums[mid] == target) {
            return mid;
        }

        // Left half is sorted
        if (nums[left] <= nums[mid]) {
            if (nums[left] <= target && target < nums[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        // Right half is sorted
        else {
            if (nums[mid] < target && target <= nums[right]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
    }

    return -1;
}
```


### 6.2 Search in Rotated Sorted Array II (with duplicates)

```java
boolean search(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;

        if (nums[mid] == target) {
            return true;
        }

        // Handle duplicates
        if (nums[left] == nums[mid] && nums[mid] == nums[right]) {
            left++;
            right--;
        }
        // Left half is sorted
        else if (nums[left] <= nums[mid]) {
            if (nums[left] <= target && target < nums[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        // Right half is sorted
        else {
            if (nums[mid] < target && target <= nums[right]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
    }

    return false;
}
```


### 6.3 Find Rotation Count

```java
int findRotationCount(int[] nums) {
    int left = 0;
    int right = nums.length - 1;

    while (left < right) {
        int mid = left + (right - left) / 2;

        if (nums[mid] > nums[right]) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }

    return left;
}
```


***

## Pattern 7: Search in 2D Matrix

### 7.1 Search a 2D Matrix

```java
boolean searchMatrix(int[][] matrix, int target) {
    int rows = matrix.length;
    int cols = matrix[^1_0].length;
    int left = 0;
    int right = rows * cols - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;
        int midVal = matrix[mid / cols][mid % cols];

        if (midVal == target) {
            return true;
        } else if (midVal < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return false;
}
```


### 7.2 Search a 2D Matrix II

```java
boolean searchMatrix(int[][] matrix, int target) {
    int row = 0;
    int col = matrix[^1_0].length - 1;

    while (row < matrix.length && col >= 0) {
        if (matrix[row][col] == target) {
            return true;
        } else if (matrix[row][col] > target) {
            col--;
        } else {
            row++;
        }
    }

    return false;
}
```


### 7.3 Find Median in Row-wise Sorted Matrix

```java
int median(int[][] matrix) {
    int rows = matrix.length;
    int cols = matrix[^1_0].length;

    int min = matrix[^1_0][^1_0];
    int max = matrix[^1_0][cols - 1];

    // Find min and max elements
    for (int i = 0; i < rows; i++) {
        min = Math.min(min, matrix[i][^1_0]);
        max = Math.max(max, matrix[i][cols - 1]);
    }

    int desired = (rows * cols + 1) / 2;

    while (min < max) {
        int mid = min + (max - min) / 2;
        int count = 0;

        // Count elements <= mid
        for (int i = 0; i < rows; i++) {
            count += upperBound(matrix[i], mid);
        }

        if (count < desired) {
            min = mid + 1;
        } else {
            max = mid;
        }
    }

    return min;
}

int upperBound(int[] arr, int target) {
    int left = 0;
    int right = arr.length;

    while (left < right) {
        int mid = left + (right - left) / 2;

        if (arr[mid] <= target) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }

    return left;
}
```


***

## Pattern 8: Minimum in Rotated Array

### 8.1 Find Minimum in Rotated Sorted Array

```java
int findMin(int[] nums) {
    int left = 0;
    int right = nums.length - 1;

    while (left < right) {
        int mid = left + (right - left) / 2;

        if (nums[mid] > nums[right]) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }

    return nums[left];
}
```


### 8.2 Find Minimum in Rotated Sorted Array II

```java
int findMin(int[] nums) {
    int left = 0;
    int right = nums.length - 1;

    while (left < right) {
        int mid = left + (right - left) / 2;

        if (nums[mid] > nums[right]) {
            left = mid + 1;
        } else if (nums[mid] < nums[right]) {
            right = mid;
        } else {
            right--; // Handle duplicates
        }
    }

    return nums[left];
}
```


### 8.3 Find Maximum in Rotated Array

```java
int findMax(int[] nums) {
    int left = 0;
    int right = nums.length - 1;

    while (left < right) {
        int mid = left + (right - left) / 2;

        if (nums[mid] > nums[right]) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }

    // The minimum is at index left, so maximum is at left - 1
    return nums[(left - 1 + nums.length) % nums.length];
}
```


***

## Pattern 9: Search Range Problems

### 9.1 Find Range of Target

```java
int[] findRange(int[] nums, int target) {
    int[] result = {-1, -1};

    // Find first occurrence
    result[0] = findBound(nums, target, true);

    // Find last occurrence
    result[1] = findBound(nums, target, false);

    return result;
}

int findBound(int[] nums, int target, boolean findFirst) {
    int left = 0;
    int right = nums.length - 1;
    int bound = -1;

    while (left <= right) {
        int mid = left + (right - left) / 2;

        if (nums[mid] == target) {
            bound = mid;
            if (findFirst) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return bound;
}
```


### 9.2 Search for Range with Condition

```java
int[] searchRange(int[] nums, int minVal, int maxVal) {
    int left = lowerBound(nums, minVal);
    int right = upperBound(nums, maxVal) - 1;

    if (left <= right && left < nums.length && nums[left] >= minVal) {
        return new int[]{left, right};
    }

    return new int[]{-1, -1};
}
```


***

## Pattern 10: Answer Search (Binary Search on Answer)

### 10.1 Square Root

```java
int mySqrt(int x) {
    if (x < 2) return x;

    long left = 1;
    long right = x / 2;
    long result = 0;

    while (left <= right) {
        long mid = left + (right - left) / 2;
        long square = mid * mid;

        if (square == x) {
            return (int) mid;
        } else if (square < x) {
            result = mid;
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return (int) result;
}
```


### 10.2 Nth Root

```java
int nthRoot(int n, int m) {
    int left = 1;
    int right = m;

    while (left <= right) {
        int mid = left + (right - left) / 2;
        long power = power(mid, n, m);

        if (power == m) {
            return mid;
        } else if (power < m) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return -1;
}

long power(int base, int exp, int limit) {
    long result = 1;
    for (int i = 0; i < exp; i++) {
        result *= base;
        if (result > limit) return result;
    }
    return result;
}
```


### 10.3 Koko Eating Bananas

```java
int minEatingSpeed(int[] piles, int h) {
    int left = 1;
    int right = Arrays.stream(piles).max().getAsInt();

    while (left < right) {
        int mid = left + (right - left) / 2;

        if (canFinish(piles, mid, h)) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }

    return left;
}

boolean canFinish(int[] piles, int speed, int h) {
    int hours = 0;
    for (int pile : piles) {
        hours += (pile + speed - 1) / speed; // Ceiling division
    }
    return hours <= h;
}
```


### 10.4 Capacity to Ship Packages

```java
int shipWithinDays(int[] weights, int days) {
    int left = Arrays.stream(weights).max().getAsInt();
    int right = Arrays.stream(weights).sum();

    while (left < right) {
        int mid = left + (right - left) / 2;

        if (canShip(weights, mid, days)) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }

    return left;
}

boolean canShip(int[] weights, int capacity, int days) {
    int daysNeeded = 1;
    int currentWeight = 0;

    for (int weight : weights) {
        if (currentWeight + weight > capacity) {
            daysNeeded++;
            currentWeight = weight;
        } else {
            currentWeight += weight;
        }
    }

    return daysNeeded <= days;
}
```


### 10.5 Split Array Largest Sum

```java
int splitArray(int[] nums, int m) {
    int left = Arrays.stream(nums).max().getAsInt();
    int right = Arrays.stream(nums).sum();

    while (left < right) {
        int mid = left + (right - left) / 2;

        if (canSplit(nums, mid, m)) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }

    return left;
}

boolean canSplit(int[] nums, int maxSum, int m) {
    int subarrays = 1;
    int currentSum = 0;

    for (int num : nums) {
        if (currentSum + num > maxSum) {
            subarrays++;
            currentSum = num;
        } else {
            currentSum += num;
        }
    }

    return subarrays <= m;
}
```


### 10.6 Minimize Maximum Distance to Gas Station

```java
double minmaxGasDist(int[] stations, int k) {
    double left = 0;
    double right = 0;

    for (int i = 1; i < stations.length; i++) {
        right = Math.max(right, stations[i] - stations[i - 1]);
    }

    double epsilon = 1e-6;

    while (right - left > epsilon) {
        double mid = left + (right - left) / 2;

        if (canPlace(stations, k, mid)) {
            right = mid;
        } else {
            left = mid;
        }
    }

    return left;
}

boolean canPlace(int[] stations, int k, double distance) {
    int count = 0;

    for (int i = 1; i < stations.length; i++) {
        double gap = stations[i] - stations[i - 1];
        count += (int) (gap / distance);
    }

    return count <= k;
}
```


***

## Pattern 11: Kth Element

### 11.1 Kth Smallest Element in Sorted Matrix

```java
int kthSmallest(int[][] matrix, int k) {
    int n = matrix.length;
    int left = matrix[^1_0][^1_0];
    int right = matrix[n - 1][n - 1];

    while (left < right) {
        int mid = left + (right - left) / 2;
        int count = countLessEqual(matrix, mid);

        if (count < k) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }

    return left;
}

int countLessEqual(int[][] matrix, int target) {
    int count = 0;
    int row = matrix.length - 1;
    int col = 0;

    while (row >= 0 && col < matrix[^1_0].length) {
        if (matrix[row][col] <= target) {
            count += row + 1;
            col++;
        } else {
            row--;
        }
    }

    return count;
}
```


### 11.2 Kth Element of Two Sorted Arrays

```java
int kthElement(int[] arr1, int[] arr2, int k) {
    if (arr1.length > arr2.length) {
        return kthElement(arr2, arr1, k);
    }

    int n1 = arr1.length;
    int n2 = arr2.length;

    int left = Math.max(0, k - n2);
    int right = Math.min(k, n1);

    while (left <= right) {
        int cut1 = (left + right) / 2;
        int cut2 = k - cut1;

        int left1 = (cut1 == 0) ? Integer.MIN_VALUE : arr1[cut1 - 1];
        int left2 = (cut2 == 0) ? Integer.MIN_VALUE : arr2[cut2 - 1];

        int right1 = (cut1 == n1) ? Integer.MAX_VALUE : arr1[cut1];
        int right2 = (cut2 == n2) ? Integer.MAX_VALUE : arr2[cut2];

        if (left1 <= right2 && left2 <= right1) {
            return Math.max(left1, left2);
        } else if (left1 > right2) {
            right = cut1 - 1;
        } else {
            left = cut1 + 1;
        }
    }

    return -1;
}
```


### 11.3 Find Kth Positive Missing Number

```java
int findKthPositive(int[] arr, int k) {
    int left = 0;
    int right = arr.length - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;
        int missing = arr[mid] - (mid + 1);

        if (missing < k) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return left + k;
}
```


***

## Pattern 12: Median Problems

### 12.1 Median of Two Sorted Arrays

```java
double findMedianSortedArrays(int[] nums1, int[] nums2) {
    if (nums1.length > nums2.length) {
        return findMedianSortedArrays(nums2, nums1);
    }

    int n1 = nums1.length;
    int n2 = nums2.length;
    int left = 0;
    int right = n1;

    while (left <= right) {
        int cut1 = (left + right) / 2;
        int cut2 = (n1 + n2 + 1) / 2 - cut1;

        int left1 = (cut1 == 0) ? Integer.MIN_VALUE : nums1[cut1 - 1];
        int left2 = (cut2 == 0) ? Integer.MIN_VALUE : nums2[cut2 - 1];

        int right1 = (cut1 == n1) ? Integer.MAX_VALUE : nums1[cut1];
        int right2 = (cut2 == n2) ? Integer.MAX_VALUE : nums2[cut2];

        if (left1 <= right2 && left2 <= right1) {
            if ((n1 + n2) % 2 == 0) {
                return (Math.max(left1, left2) + Math.min(right1, right2)) / 2.0;
            } else {
                return Math.max(left1, left2);
            }
        } else if (left1 > right2) {
            right = cut1 - 1;
        } else {
            left = cut1 + 1;
        }
    }

    return 1.0;
}
```


### 12.2 Median of Row Wise Sorted Matrix

```java
int median(int[][] matrix) {
    int rows = matrix.length;
    int cols = matrix[^1_0].length;

    int min = matrix[^1_0][^1_0];
    int max = matrix[^1_0][cols - 1];

    for (int i = 0; i < rows; i++) {
        min = Math.min(min, matrix[i][^1_0]);
        max = Math.max(max, matrix[i][cols - 1]);
    }

    int desired = (rows * cols + 1) / 2;

    while (min < max) {
        int mid = min + (max - min) / 2;
        int count = 0;

        for (int i = 0; i < rows; i++) {
            count += upperBound(matrix[i], mid);
        }

        if (count < desired) {
            min = mid + 1;
        } else {
            max = mid;
        }
    }

    return min;
}
```


***

## Pattern 13: Advanced Binary Search

### 13.1 Aggressive Cows

```java
int aggressiveCows(int[] stalls, int cows) {
    Arrays.sort(stalls);

    int left = 1;
    int right = stalls[stalls.length - 1] - stalls[^1_0];
    int result = 0;

    while (left <= right) {
        int mid = left + (right - left) / 2;

        if (canPlaceCows(stalls, cows, mid)) {
            result = mid;
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return result;
}

boolean canPlaceCows(int[] stalls, int cows, int minDistance) {
    int count = 1;
    int lastPosition = stalls[^1_0];

    for (int i = 1; i < stalls.length; i++) {
        if (stalls[i] - lastPosition >= minDistance) {
            count++;
            lastPosition = stalls[i];
            if (count >= cows) return true;
        }
    }

    return false;
}
```


### 13.2 Book Allocation Problem

```java
int allocateBooks(int[] books, int students) {
    if (students > books.length) return -1;

    int left = Arrays.stream(books).max().getAsInt();
    int right = Arrays.stream(books).sum();

    while (left < right) {
        int mid = left + (right - left) / 2;

        if (canAllocate(books, students, mid)) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }

    return left;
}

boolean canAllocate(int[] books, int students, int maxPages) {
    int studentsUsed = 1;
    int currentPages = 0;

    for (int pages : books) {
        if (currentPages + pages > maxPages) {
            studentsUsed++;
            currentPages = pages;
            if (studentsUsed > students) return false;
        } else {
            currentPages += pages;
        }
    }

    return true;
}
```


### 13.3 Painters Partition Problem

```java
int paintersPartition(int[] boards, int painters) {
    int left = Arrays.stream(boards).max().getAsInt();
    int right = Arrays.stream(boards).sum();

    while (left < right) {
        int mid = left + (right - left) / 2;

        if (canPaint(boards, painters, mid)) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }

    return left;
}

boolean canPaint(int[] boards, int painters, int maxTime) {
    int paintersUsed = 1;
    int currentTime = 0;

    for (int board : boards) {
        if (currentTime + board > maxTime) {
            paintersUsed++;
            currentTime = board;
            if (paintersUsed > painters) return false;
        } else {
            currentTime += board;
        }
    }

    return true;
}
```


### 13.4 Median of Sliding Window (Using Binary Search)

```java
double[] medianSlidingWindow(int[] nums, int k) {
    double[] result = new double[nums.length - k + 1];
    List<Integer> window = new ArrayList<>();

    for (int i = 0; i < nums.length; i++) {
        // Add current element
        insertInSortedOrder(window, nums[i]);

        // Remove element going out of window
        if (i >= k) {
            window.remove(Integer.valueOf(nums[i - k]));
        }

        // Calculate median when window is of size k
        if (i >= k - 1) {
            result[i - k + 1] = getMedian(window);
        }
    }

    return result;
}

void insertInSortedOrder(List<Integer> list, int val) {
    int left = 0;
    int right = list.size();

    while (left < right) {
        int mid = left + (right - left) / 2;
        if (list.get(mid) < val) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }

    list.add(left, val);
}

double getMedian(List<Integer> list) {
    int n = list.size();
    if (n % 2 == 1) {
        return list.get(n / 2);
    } else {
        return ((long) list.get(n / 2 - 1) + (long) list.get(n / 2)) / 2.0;
    }
}
```


### 13.5 Find Duplicate Number

```java
int findDuplicate(int[] nums) {
    int left = 1;
    int right = nums.length - 1;

    while (left < right) {
        int mid = left + (right - left) / 2;
        int count = 0;

        // Count how many numbers <= mid
        for (int num : nums) {
            if (num <= mid) {
                count++;
            }
        }

        // If count > mid, duplicate is in [left, mid]
        if (count > mid) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }

    return left;
}
```


### 13.6 Find Missing Element in Sorted Array

```java
int missingElement(int[] nums, int k) {
    int left = 0;
    int right = nums.length - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;
        int missing = nums[mid] - nums[^1_0] - mid;

        if (missing < k) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return nums[^1_0] + right + k;
}
```


***

## Time Complexity Cheat Sheet

| Pattern | Time Complexity | Space Complexity |
| :-- | :-- | :-- |
| Basic Binary Search | O(log n) | O(1) |
| Find Bounds | O(log n) | O(1) |
| Search in Rotated Array | O(log n) | O(1) |
| Search in 2D Matrix | O(log(m*n)) | O(1) |
| Binary Search on Answer | O(log(max-min) * f(n)) | O(1) |
| Median of Two Arrays | O(log(min(m,n))) | O(1) |
| Kth Element | O(log(min(m,n))) | O(1) |


***

## Binary Search Templates

### Template 1: Standard Binary Search

```java
while (left <= right) {
    int mid = left + (right - left) / 2;
    if (nums[mid] == target) return mid;
    else if (nums[mid] < target) left = mid + 1;
    else right = mid - 1;
}
```


### Template 2: Find Leftmost/Rightmost

```java
// Leftmost
while (left < right) {
    int mid = left + (right - left) / 2;
    if (condition) right = mid;
    else left = mid + 1;
}

// Rightmost
while (left < right) {
    int mid = left + (right - left + 1) / 2;
    if (condition) left = mid;
    else right = mid - 1;
}
```


### Template 3: Binary Search on Answer

```java
while (left < right) {
    int mid = left + (right - left) / 2;
    if (isPossible(mid)) right = mid;
    else left = mid + 1;
}
```


***

## Common Tricks \& Tips

1. **Overflow Prevention**: Use `left + (right - left) / 2` instead of `(left + right) / 2`
2. **Template Selection**: Choose the right template based on the problem requirement
3. **Boundary Conditions**: Handle edge cases like empty arrays, single elements
4. **Monotonic Property**: Ensure the search space has monotonic property
5. **Answer Search**: When searching for a value in a range, binary search on the answer
6. **2D Matrix**: Convert 2D coordinates to 1D index: `row = mid / cols`, `col = mid % cols`
7. **Duplicates**: Handle duplicates by adjusting the search strategy
8. **Floating Point**: Use epsilon for floating-point comparisons
