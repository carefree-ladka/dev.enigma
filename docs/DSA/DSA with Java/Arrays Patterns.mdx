# Array

## Table of Contents

1. [Array Fundamentals](#array-fundamentals)
2. [Pattern 1: Two Pointers](#pattern-1-two-pointers)
3. [Pattern 2: Sliding Window](#pattern-2-sliding-window)
4. [Pattern 3: Prefix Sum \& Cumulative Arrays](#pattern-3-prefix-sum--cumulative-arrays)
5. [Pattern 4: Kadane's Algorithm (Maximum Subarray)](#pattern-4-kadanes-algorithm-maximum-subarray)
6. [Pattern 5: Fast \& Slow Pointers](#pattern-5-fast--slow-pointers)
7. [Pattern 6: Cyclic Sort](#pattern-6-cyclic-sort)
8. [Pattern 7: Merge Intervals](#pattern-7-merge-intervals)
9. [Pattern 8: Dutch National Flag](#pattern-8-dutch-national-flag)
10. [Pattern 9: Binary Search in Arrays](#pattern-9-binary-search-in-arrays)
11. [Pattern 10: Subarray Problems](#pattern-10-subarray-problems)
12. [Pattern 11: Matrix Traversal](#pattern-11-matrix-traversal)
13. [Pattern 12: Advanced Array Techniques](#pattern-12-advanced-array-techniques)

***

## Array Fundamentals

### Core Array Operations

```java
// Basic Array Operations
class ArrayOperations {

    // Array Creation and Initialization
    public static void arrayBasics() {
        // Different ways to create arrays
        int[] arr1 = new int[5];                    // Default values (0)
        int[] arr2 = {1, 2, 3, 4, 5};             // Direct initialization
        int[] arr3 = new int[]{1, 2, 3, 4, 5};    // Explicit initialization

        // 2D Array initialization
        int[][] matrix1 = new int[3][4];           // 3x4 matrix
        int[][] matrix2 = {{1, 2}, {3, 4}, {5, 6}}; // Direct initialization
    }

    // Array Traversal Patterns
    public static void traversalPatterns(int[] arr) {
        // Forward traversal
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }

        // Backward traversal
        for (int i = arr.length - 1; i >= 0; i--) {
            System.out.print(arr[i] + " ");
        }

        // Enhanced for loop
        for (int num : arr) {
            System.out.print(num + " ");
        }

        // Two pointers traversal
        int left = 0, right = arr.length - 1;
        while (left <= right) {
            System.out.println("Left: " + arr[left] + ", Right: " + arr[right]);
            left++;
            right--;
        }
    }

    // Common Array Utilities
    public static void arrayUtilities() {
        int[] arr = {3, 1, 4, 1, 5, 9, 2, 6};

        // Sorting
        Arrays.sort(arr);

        // Binary search (array must be sorted)
        int index = Arrays.binarySearch(arr, 5);

        // Copying arrays
        int[] copy1 = Arrays.copyOf(arr, arr.length);
        int[] copy2 = Arrays.copyOfRange(arr, 2, 6);

        // Filling array
        int[] filled = new int[10];
        Arrays.fill(filled, 42);

        // Converting to string
        System.out.println(Arrays.toString(arr));

        // Comparing arrays
        boolean equal = Arrays.equals(arr, copy1);
    }
}

// Dynamic Array Implementation (ArrayList alternative)
class DynamicArray<T> {
    private T[] array;
    private int size;
    private int capacity;

    @SuppressWarnings("unchecked")
    public DynamicArray() {
        capacity = 10;
        array = (T[]) new Object[capacity];
        size = 0;
    }

    public void add(T item) {
        if (size >= capacity) {
            resize();
        }
        array[size++] = item;
    }

    public T get(int index) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException();
        }
        return array[index];
    }

    public void set(int index, T item) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException();
        }
        array[index] = item;
    }

    public T remove(int index) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException();
        }

        T item = array[index];
        for (int i = index; i < size - 1; i++) {
            array[i] = array[i + 1];
        }
        size--;
        return item;
    }

    @SuppressWarnings("unchecked")
    private void resize() {
        capacity *= 2;
        T[] newArray = (T[]) new Object[capacity];
        System.arraycopy(array, 0, newArray, 0, size);
        array = newArray;
    }

    public int size() { return size; }
    public boolean isEmpty() { return size == 0; }
}
```


***

## Pattern 1: Two Pointers

### 1.1 Opposite Direction Two Pointers

```java
// Two Sum in Sorted Array
public int[] twoSum(int[] numbers, int target) {
    int left = 0, right = numbers.length - 1;

    while (left < right) {
        int sum = numbers[left] + numbers[right];

        if (sum == target) {
            return new int[]{left + 1, right + 1}; // 1-indexed
        } else if (sum < target) {
            left++;
        } else {
            right--;
        }
    }

    return new int[]{-1, -1}; // Not found
}

// Valid Palindrome
public boolean isPalindrome(String s) {
    int left = 0, right = s.length() - 1;

    while (left < right) {
        while (left < right && !Character.isLetterOrDigit(s.charAt(left))) {
            left++;
        }
        while (left < right && !Character.isLetterOrDigit(s.charAt(right))) {
            right--;
        }

        if (Character.toLowerCase(s.charAt(left)) !=
            Character.toLowerCase(s.charAt(right))) {
            return false;
        }

        left++;
        right--;
    }

    return true;
}

// Container With Most Water
public int maxArea(int[] height) {
    int left = 0, right = height.length - 1;
    int maxWater = 0;

    while (left < right) {
        int width = right - left;
        int currentArea = Math.min(height[left], height[right]) * width;
        maxWater = Math.max(maxWater, currentArea);

        // Move pointer with smaller height
        if (height[left] < height[right]) {
            left++;
        } else {
            right--;
        }
    }

    return maxWater;
}

// Remove Duplicates from Sorted Array
public int removeDuplicates(int[] nums) {
    if (nums.length == 0) return 0;

    int writeIndex = 1; // Position to write next unique element

    for (int readIndex = 1; readIndex < nums.length; readIndex++) {
        if (nums[readIndex] != nums[readIndex - 1]) {
            nums[writeIndex] = nums[readIndex];
            writeIndex++;
        }
    }

    return writeIndex;
}
```


### 1.2 Same Direction Two Pointers

```java
// Remove Element
public int removeElement(int[] nums, int val) {
    int writeIndex = 0;

    for (int readIndex = 0; readIndex < nums.length; readIndex++) {
        if (nums[readIndex] != val) {
            nums[writeIndex] = nums[readIndex];
            writeIndex++;
        }
    }

    return writeIndex;
}

// Move Zeros to End
public void moveZeroes(int[] nums) {
    int writeIndex = 0;

    // Move all non-zero elements to the front
    for (int readIndex = 0; readIndex < nums.length; readIndex++) {
        if (nums[readIndex] != 0) {
            nums[writeIndex] = nums[readIndex];
            writeIndex++;
        }
    }

    // Fill remaining positions with zeros
    while (writeIndex < nums.length) {
        nums[writeIndex] = 0;
        writeIndex++;
    }
}

// Partition Array (Quick Sort Partition)
public int partition(int[] arr, int low, int high) {
    int pivot = arr[high];
    int i = low - 1; // Index of smaller element

    for (int j = low; j < high; j++) {
        if (arr[j] <= pivot) {
            i++;
            swap(arr, i, j);
        }
    }

    swap(arr, i + 1, high);
    return i + 1;
}

private void swap(int[] arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
```


### 1.3 Three Sum and Four Sum Problems

```java
// Three Sum
public List<List<Integer>> threeSum(int[] nums) {
    List<List<Integer>> result = new ArrayList<>();
    Arrays.sort(nums);

    for (int i = 0; i < nums.length - 2; i++) {
        // Skip duplicates for first number
        if (i > 0 && nums[i] == nums[i - 1]) continue;

        int left = i + 1, right = nums.length - 1;
        int target = -nums[i];

        while (left < right) {
            int sum = nums[left] + nums[right];

            if (sum == target) {
                result.add(Arrays.asList(nums[i], nums[left], nums[right]));

                // Skip duplicates for second and third numbers
                while (left < right && nums[left] == nums[left + 1]) left++;
                while (left < right && nums[right] == nums[right - 1]) right--;

                left++;
                right--;
            } else if (sum < target) {
                left++;
            } else {
                right--;
            }
        }
    }

    return result;
}

// Four Sum
public List<List<Integer>> fourSum(int[] nums, int target) {
    List<List<Integer>> result = new ArrayList<>();
    Arrays.sort(nums);

    for (int i = 0; i < nums.length - 3; i++) {
        if (i > 0 && nums[i] == nums[i - 1]) continue;

        for (int j = i + 1; j < nums.length - 2; j++) {
            if (j > i + 1 && nums[j] == nums[j - 1]) continue;

            int left = j + 1, right = nums.length - 1;
            long remaining = (long) target - nums[i] - nums[j];

            while (left < right) {
                int sum = nums[left] + nums[right];

                if (sum == remaining) {
                    result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));

                    while (left < right && nums[left] == nums[left + 1]) left++;
                    while (left < right && nums[right] == nums[right - 1]) right--;

                    left++;
                    right--;
                } else if (sum < remaining) {
                    left++;
                } else {
                    right--;
                }
            }
        }
    }

    return result;
}

// Trapping Rain Water
public int trap(int[] height) {
    if (height.length == 0) return 0;

    int left = 0, right = height.length - 1;
    int leftMax = 0, rightMax = 0;
    int water = 0;

    while (left < right) {
        if (height[left] < height[right]) {
            if (height[left] >= leftMax) {
                leftMax = height[left];
            } else {
                water += leftMax - height[left];
            }
            left++;
        } else {
            if (height[right] >= rightMax) {
                rightMax = height[right];
            } else {
                water += rightMax - height[right];
            }
            right--;
        }
    }

    return water;
}
```


***

## Pattern 2: Sliding Window

### 2.1 Fixed Size Sliding Window

```java
// Maximum Sum Subarray of Size K
public int maxSumSubarray(int[] arr, int k) {
    if (arr.length < k) return -1;

    // Calculate sum of first window
    int windowSum = 0;
    for (int i = 0; i < k; i++) {
        windowSum += arr[i];
    }

    int maxSum = windowSum;

    // Slide the window
    for (int i = k; i < arr.length; i++) {
        windowSum = windowSum - arr[i - k] + arr[i];
        maxSum = Math.max(maxSum, windowSum);
    }

    return maxSum;
}

// Average of Subarrays of Size K
public double[] findAverages(int[] arr, int k) {
    double[] result = new double[arr.length - k + 1];
    double windowSum = 0;

    // Calculate sum of first window
    for (int i = 0; i < k; i++) {
        windowSum += arr[i];
    }
    result[0] = windowSum / k;

    // Slide the window
    for (int i = k; i < arr.length; i++) {
        windowSum = windowSum - arr[i - k] + arr[i];
        result[i - k + 1] = windowSum / k;
    }

    return result;
}

// First Negative Integer in Every Window of Size K
public int[] firstNegativeInWindow(int[] arr, int k) {
    int[] result = new int[arr.length - k + 1];
    Queue<Integer> negatives = new LinkedList<>(); // Store indices

    // Process first window
    for (int i = 0; i < k; i++) {
        if (arr[i] < 0) {
            negatives.offer(i);
        }
    }
    result[0] = negatives.isEmpty() ? 0 : arr[negatives.peek()];

    // Slide the window
    for (int i = k; i < arr.length; i++) {
        // Remove elements outside current window
        while (!negatives.isEmpty() && negatives.peek() <= i - k) {
            negatives.poll();
        }

        // Add current element if negative
        if (arr[i] < 0) {
            negatives.offer(i);
        }

        result[i - k + 1] = negatives.isEmpty() ? 0 : arr[negatives.peek()];
    }

    return result;
}
```


### 2.2 Variable Size Sliding Window

```java
// Longest Substring Without Repeating Characters
public int lengthOfLongestSubstring(String s) {
    Set<Character> window = new HashSet<>();
    int left = 0, maxLength = 0;

    for (int right = 0; right < s.length(); right++) {
        // Shrink window until no duplicates
        while (window.contains(s.charAt(right))) {
            window.remove(s.charAt(left));
            left++;
        }

        window.add(s.charAt(right));
        maxLength = Math.max(maxLength, right - left + 1);
    }

    return maxLength;
}

// Smallest Subarray with Sum >= K
public int minSubArrayLen(int target, int[] nums) {
    int left = 0, sum = 0, minLength = Integer.MAX_VALUE;

    for (int right = 0; right < nums.length; right++) {
        sum += nums[right];

        // Shrink window while sum >= target
        while (sum >= target) {
            minLength = Math.min(minLength, right - left + 1);
            sum -= nums[left];
            left++;
        }
    }

    return minLength == Integer.MAX_VALUE ? 0 : minLength;
}

// Longest Subarray with At Most K Distinct Characters
public int lengthOfLongestSubstringKDistinct(String s, int k) {
    if (k == 0) return 0;

    Map<Character, Integer> charCount = new HashMap<>();
    int left = 0, maxLength = 0;

    for (int right = 0; right < s.length(); right++) {
        char rightChar = s.charAt(right);
        charCount.put(rightChar, charCount.getOrDefault(rightChar, 0) + 1);

        // Shrink window if more than k distinct characters
        while (charCount.size() > k) {
            char leftChar = s.charAt(left);
            charCount.put(leftChar, charCount.get(leftChar) - 1);
            if (charCount.get(leftChar) == 0) {
                charCount.remove(leftChar);
            }
            left++;
        }

        maxLength = Math.max(maxLength, right - left + 1);
    }

    return maxLength;
}

// Minimum Window Substring
public String minWindow(String s, String t) {
    if (s.length() < t.length()) return "";

    Map<Character, Integer> targetCount = new HashMap<>();
    for (char c : t.toCharArray()) {
        targetCount.put(c, targetCount.getOrDefault(c, 0) + 1);
    }

    Map<Character, Integer> windowCount = new HashMap<>();
    int left = 0, formed = 0;
    int minLength = Integer.MAX_VALUE, minStart = 0;
    int required = targetCount.size();

    for (int right = 0; right < s.length(); right++) {
        char rightChar = s.charAt(right);
        windowCount.put(rightChar, windowCount.getOrDefault(rightChar, 0) + 1);

        if (targetCount.containsKey(rightChar) &&
            windowCount.get(rightChar).intValue() == targetCount.get(rightChar).intValue()) {
            formed++;
        }

        // Shrink window while it's valid
        while (left <= right && formed == required) {
            if (right - left + 1 < minLength) {
                minLength = right - left + 1;
                minStart = left;
            }

            char leftChar = s.charAt(left);
            windowCount.put(leftChar, windowCount.get(leftChar) - 1);
            if (targetCount.containsKey(leftChar) &&
                windowCount.get(leftChar) < targetCount.get(leftChar)) {
                formed--;
            }
            left++;
        }
    }

    return minLength == Integer.MAX_VALUE ? "" : s.substring(minStart, minStart + minLength);
}
```


### 2.3 Sliding Window Maximum/Minimum

```java
// Sliding Window Maximum (using Deque)
public int[] maxSlidingWindow(int[] nums, int k) {
    Deque<Integer> deque = new ArrayDeque<>(); // Store indices
    int[] result = new int[nums.length - k + 1];

    for (int i = 0; i < nums.length; i++) {
        // Remove indices outside current window
        while (!deque.isEmpty() && deque.peekFirst() < i - k + 1) {
            deque.pollFirst();
        }

        // Remove indices of smaller elements
        while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {
            deque.pollLast();
        }

        deque.offerLast(i);

        // Add to result when window is complete
        if (i >= k - 1) {
            result[i - k + 1] = nums[deque.peekFirst()];
        }
    }

    return result;
}
```


***

## Pattern 3: Prefix Sum \& Cumulative Arrays

### 3.1 Basic Prefix Sum

```java
// Range Sum Query - Immutable
class NumArray {
    private int[] prefixSum;

    public NumArray(int[] nums) {
        prefixSum = new int[nums.length + 1];
        for (int i = 0; i < nums.length; i++) {
            prefixSum[i + 1] = prefixSum[i] + nums[i];
        }
    }

    public int sumRange(int left, int right) {
        return prefixSum[right + 1] - prefixSum[left];
    }
}

// Subarray Sum Equals K
public int subarraySum(int[] nums, int k) {
    Map<Integer, Integer> prefixSumCount = new HashMap<>();
    prefixSumCount.put(0, 1); // Empty subarray

    int count = 0, prefixSum = 0;

    for (int num : nums) {
        prefixSum += num;

        // Check if (prefixSum - k) exists
        if (prefixSumCount.containsKey(prefixSum - k)) {
            count += prefixSumCount.get(prefixSum - k);
        }

        prefixSumCount.put(prefixSum, prefixSumCount.getOrDefault(prefixSum, 0) + 1);
    }

    return count;
}

// Continuous Subarray Sum (Multiple of K)
public boolean checkSubarraySum(int[] nums, int k) {
    Map<Integer, Integer> remainderIndex = new HashMap<>();
    remainderIndex.put(0, -1); // Handle edge case

    int prefixSum = 0;

    for (int i = 0; i < nums.length; i++) {
        prefixSum += nums[i];
        int remainder = prefixSum % k;

        if (remainderIndex.containsKey(remainder)) {
            if (i - remainderIndex.get(remainder) > 1) {
                return true;
            }
        } else {
            remainderIndex.put(remainder, i);
        }
    }

    return false;
}
```


### 3.2 2D Prefix Sum

```java
// Range Sum Query 2D - Immutable
class NumMatrix {
    private int[][] prefixSum;

    public NumMatrix(int[][] matrix) {
        int m = matrix.length, n = matrix[0].length;
        prefixSum = new int[m + 1][n + 1];

        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                prefixSum[i][j] = matrix[i - 1][j - 1] +
                                 prefixSum[i - 1][j] +
                                 prefixSum[i][j - 1] -
                                 prefixSum[i - 1][j - 1];
            }
        }
    }

    public int sumRegion(int row1, int col1, int row2, int col2) {
        return prefixSum[row2 + 1][col2 + 1] -
               prefixSum[row1][col2 + 1] -
               prefixSum[row2 + 1][col1] +
               prefixSum[row1][col1];
    }
}
```


### 3.3 Advanced Prefix Sum Problems

```java
// Maximum Size Subarray Sum Equals k
public int maxSubArrayLen(int[] nums, int k) {
    Map<Integer, Integer> prefixSumIndex = new HashMap<>();
    prefixSumIndex.put(0, -1); // Empty subarray

    int maxLength = 0, prefixSum = 0;

    for (int i = 0; i < nums.length; i++) {
        prefixSum += nums[i];

        if (prefixSumIndex.containsKey(prefixSum - k)) {
            maxLength = Math.max(maxLength, i - prefixSumIndex.get(prefixSum - k));
        }

        // Only store first occurrence for maximum length
        if (!prefixSumIndex.containsKey(prefixSum)) {
            prefixSumIndex.put(prefixSum, i);
        }
    }

    return maxLength;
}

// Product of Array Except Self
public int[] productExceptSelf(int[] nums) {
    int n = nums.length;
    int[] result = new int[n];

    // Left products
    result[0] = 1;
    for (int i = 1; i < n; i++) {
        result[i] = result[i - 1] * nums[i - 1];
    }

    // Right products
    int rightProduct = 1;
    for (int i = n - 1; i >= 0; i--) {
        result[i] *= rightProduct;
        rightProduct *= nums[i];
    }

    return result;
}
```


***

## Pattern 4: Kadane's Algorithm (Maximum Subarray)

### 4.1 Classic Maximum Subarray

```java
// Maximum Subarray Sum (Kadane's Algorithm)
public int maxSubArray(int[] nums) {
    int maxSoFar = nums[0];
    int maxEndingHere = nums[0];

    for (int i = 1; i < nums.length; i++) {
        maxEndingHere = Math.max(nums[i], maxEndingHere + nums[i]);
        maxSoFar = Math.max(maxSoFar, maxEndingHere);
    }

    return maxSoFar;
}

// Maximum Subarray with Indices
public int[] maxSubArrayWithIndices(int[] nums) {
    int maxSum = nums[0];
    int currentSum = nums[0];
    int start = 0, end = 0, tempStart = 0;

    for (int i = 1; i < nums.length; i++) {
        if (currentSum < 0) {
            currentSum = nums[i];
            tempStart = i;
        } else {
            currentSum += nums[i];
        }

        if (currentSum > maxSum) {
            maxSum = currentSum;
            start = tempStart;
            end = i;
        }
    }

    return new int[]{maxSum, start, end};
}

// Maximum Product Subarray
public int maxProduct(int[] nums) {
    int maxSoFar = nums[0];
    int minSoFar = nums[0]; // Track minimum for negative numbers
    int result = nums[0];

    for (int i = 1; i < nums.length; i++) {
        // If current number is negative, swap max and min
        if (nums[i] < 0) {
            int temp = maxSoFar;
            maxSoFar = minSoFar;
            minSoFar = temp;
        }

        maxSoFar = Math.max(nums[i], maxSoFar * nums[i]);
        minSoFar = Math.min(nums[i], minSoFar * nums[i]);

        result = Math.max(result, maxSoFar);
    }

    return result;
}
```


### 4.2 Kadane's Algorithm Variations

```java
// Maximum Circular Subarray Sum
public int maxSubarraySumCircular(int[] arr) {
    int maxKadane = kadaneMax(arr);
    int totalSum = Arrays.stream(arr).sum();

    // Invert all elements and find max (which is min of original)
    for (int i = 0; i < arr.length; i++) {
        arr[i] = -arr[i];
    }
    int minKadane = -kadaneMax(arr);

    // Restore original array
    for (int i = 0; i < arr.length; i++) {
        arr[i] = -arr[i];
    }

    // If all elements are negative, return maxKadane
    if (totalSum == minKadane) {
        return maxKadane;
    }

    return Math.max(maxKadane, totalSum - minKadane);
}

private int kadaneMax(int[] arr) {
    int maxSoFar = arr[0];
    int maxEndingHere = arr[0];

    for (int i = 1; i < arr.length; i++) {
        maxEndingHere = Math.max(arr[i], maxEndingHere + arr[i]);
        maxSoFar = Math.max(maxSoFar, maxEndingHere);
    }

    return maxSoFar;
}

// Maximum Sum of Non-Adjacent Elements
public int maxNonAdjacent(int[] nums) {
    if (nums.length == 0) return 0;
    if (nums.length == 1) return nums[0];

    int prevPrev = nums[0];
    int prev = Math.max(nums[0], nums[1]);

    for (int i = 2; i < nums.length; i++) {
        int current = Math.max(prev, prevPrev + nums[i]);
        prevPrev = prev;
        prev = current;
    }

    return prev;
}
```


***

## Pattern 5: Fast \& Slow Pointers

### 5.1 Cycle Detection in Arrays

```java
// Find Duplicate Number (Floyd's Algorithm)
public int findDuplicate(int[] nums) {
    // Phase 1: Find intersection point
    int slow = nums[0];
    int fast = nums[0];

    do {
        slow = nums[slow];
        fast = nums[nums[fast]];
    } while (slow != fast);

    // Phase 2: Find entrance to cycle
    slow = nums[0];
    while (slow != fast) {
        slow = nums[slow];
        fast = nums[fast];
    }

    return slow;
}

// Circular Array Loop
public boolean circularArrayLoop(int[] nums) {
    for (int i = 0; i < nums.length; i++) {
        if (nums[i] == 0) continue;

        int slow = i, fast = i;
        boolean forward = nums[i] > 0;

        // Check if we can form a valid loop
        while (true) {
            slow = getNext(nums, slow, forward);
            if (slow == -1) break;

            fast = getNext(nums, fast, forward);
            if (fast == -1) break;
            fast = getNext(nums, fast, forward);
            if (fast == -1) break;

            if (slow == fast) return true;
        }

        // Mark visited elements
        int curr = i;
        while (nums[curr] != 0 && ((nums[curr] > 0) == forward)) {
            int next = getNext(nums, curr, forward);
            nums[curr] = 0;
            curr = next;
        }
    }

    return false;
}

private int getNext(int[] nums, int index, boolean forward) {
    boolean direction = nums[index] > 0;
    if (direction != forward) return -1; // Direction changed

    int next = (index + nums[index]) % nums.length;
    if (next < 0) next += nums.length;

    if (next == index) return -1; // Single element loop

    return next;
}
```


***

## Pattern 6: Cyclic Sort

### 6.1 Missing and Duplicate Numbers

```java
// Cyclic Sort
public void cyclicSort(int[] nums) {
    int i = 0;
    while (i < nums.length) {
        int correctIndex = nums[i] - 1;
        if (nums[i] != nums[correctIndex]) {
            swap(nums, i, correctIndex);
        } else {
            i++;
        }
    }
}

// Find Missing Number
public int missingNumber(int[] nums) {
    int i = 0;
    while (i < nums.length) {
        if (nums[i] < nums.length && nums[i] != nums[nums[i]]) {
            swap(nums, i, nums[i]);
        } else {
            i++;
        }
    }

    // Find the missing number
    for (i = 0; i < nums.length; i++) {
        if (nums[i] != i) {
            return i;
        }
    }

    return nums.length;
}

// Find All Missing Numbers
public List<Integer> findDisappearedNumbers(int[] nums) {
    int i = 0;
    while (i < nums.length) {
        int correctIndex = nums[i] - 1;
        if (nums[i] != nums[correctIndex]) {
            swap(nums, i, correctIndex);
        } else {
            i++;
        }
    }

    List<Integer> missing = new ArrayList<>();
    for (i = 0; i < nums.length; i++) {
        if (nums[i] != i + 1) {
            missing.add(i + 1);
        }
    }

    return missing;
}

// Find Duplicate Numbers
public List<Integer> findDuplicates(int[] nums) {
    int i = 0;
    while (i < nums.length) {
        int correctIndex = nums[i] - 1;
        if (nums[i] != nums[correctIndex]) {
            swap(nums, i, correctIndex);
        } else {
            i++;
        }
    }

    List<Integer> duplicates = new ArrayList<>();
    for (i = 0; i < nums.length; i++) {
        if (nums[i] != i + 1) {
            duplicates.add(nums[i]);
        }
    }

    return duplicates;
}

private void swap(int[] nums, int i, int j) {
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}
```


***

## Pattern 7: Merge Intervals

### 7.1 Basic Interval Operations

```java
// Merge Intervals
public int[][] merge(int[][] intervals) {
    if (intervals.length <= 1) return intervals;

    Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));

    List<int[]> merged = new ArrayList<>();
    int[] currentInterval = intervals[0];

    for (int i = 1; i < intervals.length; i++) {
        if (currentInterval[1] >= intervals[i][0]) {
            // Overlapping intervals, merge them
            currentInterval[1] = Math.max(currentInterval[1], intervals[i][1]);
        } else {
            // Non-overlapping interval
            merged.add(currentInterval);
            currentInterval = intervals[i];
        }
    }

    merged.add(currentInterval);
    return merged.toArray(new int[merged.size()][]);
}

// Insert Interval
public int[][] insert(int[][] intervals, int[] newInterval) {
    List<int[]> result = new ArrayList<>();
    int i = 0;

    // Add all intervals before the new interval
    while (i < intervals.length && intervals[i][1] < newInterval[0]) {
        result.add(intervals[i]);
        i++;
    }

    // Merge overlapping intervals
    while (i < intervals.length && intervals[i][0] <= newInterval[1]) {
        newInterval[0] = Math.min(newInterval[0], intervals[i][0]);
        newInterval[1] = Math.max(newInterval[1], intervals[i][1]);
        i++;
    }
    result.add(newInterval);

    // Add remaining intervals
    while (i < intervals.length) {
        result.add(intervals[i]);
        i++;
    }

    return result.toArray(new int[result.size()][]);
}

// Non-overlapping Intervals (Minimum removals)
public int eraseOverlapIntervals(int[][] intervals) {
    if (intervals.length <= 1) return 0;

    Arrays.sort(intervals, (a, b) -> Integer.compare(a[1], b[1])); // Sort by end time

    int count = 0;
    int lastEnd = intervals[0][1];

    for (int i = 1; i < intervals.length; i++) {
        if (intervals[i][0] < lastEnd) {
            count++; // Remove current interval
        } else {
            lastEnd = intervals[i][1];
        }
    }

    return count;
}
```


### 7.2 Advanced Interval Problems

```java
// Meeting Rooms
public boolean canAttendMeetings(int[][] intervals) {
    Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));

    for (int i = 1; i < intervals.length; i++) {
        if (intervals[i][0] < intervals[i - 1][1]) {
            return false; // Overlap found
        }
    }

    return true;
}

// Meeting Rooms II (Minimum conference rooms)
public int minMeetingRooms(int[][] intervals) {
    Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));

    PriorityQueue<Integer> endTimes = new PriorityQueue<>();

    for (int[] interval : intervals) {
        if (!endTimes.isEmpty() && endTimes.peek() <= interval[0]) {
            endTimes.poll(); // Room becomes available
        }
        endTimes.offer(interval[1]);
    }

    return endTimes.size();
}

// Interval List Intersections
public int[][] intervalIntersection(int[][] firstList, int[][] secondList) {
    List<int[]> intersections = new ArrayList<>();
    int i = 0, j = 0;

    while (i < firstList.length && j < secondList.length) {
        int start = Math.max(firstList[i][0], secondList[j][0]);
        int end = Math.min(firstList[i][1], secondList[j][1]);

        if (start <= end) {
            intersections.add(new int[]{start, end});
        }

        // Move pointer of interval that ends first
        if (firstList[i][1] < secondList[j][1]) {
            i++;
        } else {
            j++;
        }
    }

    return intersections.toArray(new int[intersections.size()][]);
}
```


***

## Pattern 8: Dutch National Flag

### 8.1 Three-Way Partitioning

```java
// Sort Colors (Dutch National Flag)
public void sortColors(int[] nums) {
    int low = 0, mid = 0, high = nums.length - 1;

    while (mid <= high) {
        if (nums[mid] == 0) {
            swap(nums, low, mid);
            low++;
            mid++;
        } else if (nums[mid] == 1) {
            mid++;
        } else { // nums[mid] == 2
            swap(nums, mid, high);
            high--;
            // Don't increment mid as we need to check swapped element
        }
    }
}

// Three-Way Partitioning (Generic)
public void threeWayPartition(int[] arr, int a, int b) {
    int low = 0, mid = 0, high = arr.length - 1;

    while (mid <= high) {
        if (arr[mid] < a) {
            swap(arr, low, mid);
            low++;
            mid++;
        } else if (arr[mid] > b) {
            swap(arr, mid, high);
            high--;
        } else {
            mid++;
        }
    }
}

// Partition Array Around Pivot
public int[] partitionAroundPivot(int[] arr, int pivot) {
    int low = 0, mid = 0, high = arr.length - 1;

    while (mid <= high) {
        if (arr[mid] < pivot) {
            swap(arr, low, mid);
            low++;
            mid++;
        } else if (arr[mid] > pivot) {
            swap(arr, mid, high);
            high--;
        } else {
            mid++;
        }
    }

    return arr;
}

private void swap(int[] arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
```


***

## Pattern 9: Binary Search in Arrays

### 9.1 Basic Binary Search

```java
// Binary Search
public int binarySearch(int[] arr, int target) {
    int left = 0, right = arr.length - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;

        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return -1; // Not found
}

// Find First and Last Position
public int[] searchRange(int[] nums, int target) {
    int[] result = {-1, -1};

    // Find first position
    result[0] = findFirst(nums, target);
    if (result[0] == -1) return result;

    // Find last position
    result[1] = findLast(nums, target);

    return result;
}

private int findFirst(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    int result = -1;

    while (left <= right) {
        int mid = left + (right - left) / 2;

        if (nums[mid] == target) {
            result = mid;
            right = mid - 1; // Continue searching left
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return result;
}

private int findLast(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    int result = -1;

    while (left <= right) {
        int mid = left + (right - left) / 2;

        if (nums[mid] == target) {
            result = mid;
            left = mid + 1; // Continue searching right
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return result;
}
```


### 9.2 Advanced Binary Search

```java
// Search in Rotated Sorted Array
public int search(int[] nums, int target) {
    int left = 0, right = nums.length - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;

        if (nums[mid] == target) return mid;

        // Left half is sorted
        if (nums[left] <= nums[mid]) {
            if (target >= nums[left] && target < nums[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        // Right half is sorted
        else {
            if (target > nums[mid] && target <= nums[right]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
    }

    return -1;
}

// Find Peak Element
public int findPeakElement(int[] nums) {
    int left = 0, right = nums.length - 1;

    while (left < right) {
        int mid = left + (right - left) / 2;

        if (nums[mid] > nums[mid + 1]) {
            right = mid; // Peak is in left half (including mid)
        } else {
            left = mid + 1; // Peak is in right half
        }
    }

    return left;
}

// Search Insert Position
public int searchInsert(int[] nums, int target) {
    int left = 0, right = nums.length - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;

        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return left; // Insert position
}
```


***

## Pattern 10: Subarray Problems

### 10.1 Subarray Sum Problems

```java
// Maximum Length of Subarray with Equal 0s and 1s
public int findMaxLength(int[] nums) {
    Map<Integer, Integer> sumIndex = new HashMap<>();
    sumIndex.put(0, -1); // Handle edge case

    int maxLength = 0, sum = 0;

    for (int i = 0; i < nums.length; i++) {
        sum += (nums[i] == 1) ? 1 : -1;

        if (sumIndex.containsKey(sum)) {
            maxLength = Math.max(maxLength, i - sumIndex.get(sum));
        } else {
            sumIndex.put(sum, i);
        }
    }

    return maxLength;
}

// Shortest Subarray with Sum at Least K
public int shortestSubarray(int[] nums, int k) {
    int n = nums.length;
    long[] prefixSum = new long[n + 1];

    for (int i = 0; i < n; i++) {
        prefixSum[i + 1] = prefixSum[i] + nums[i];
    }

    Deque<Integer> deque = new ArrayDeque<>();
    int minLength = Integer.MAX_VALUE;

    for (int i = 0; i <= n; i++) {
        while (!deque.isEmpty() && prefixSum[i] - prefixSum[deque.peekFirst()] >= k) {
            minLength = Math.min(minLength, i - deque.pollFirst());
        }

        while (!deque.isEmpty() && prefixSum[deque.peekLast()] >= prefixSum[i]) {
            deque.pollLast();
        }

        deque.offerLast(i);
    }

    return minLength == Integer.MAX_VALUE ? -1 : minLength;
}
```


***

## Pattern 11: Matrix Traversal

### 11.1 Basic Matrix Operations

```java
// Rotate Image (90 degrees clockwise)
public void rotate(int[][] matrix) {
    int n = matrix.length;

    // Transpose matrix
    for (int i = 0; i < n; i++) {
        for (int j = i; j < n; j++) {
            int temp = matrix[i][j];
            matrix[i][j] = matrix[j][i];
            matrix[j][i] = temp;
        }
    }

    // Reverse each row
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n / 2; j++) {
            int temp = matrix[i][j];
            matrix[i][j] = matrix[i][n - 1 - j];
            matrix[i][n - 1 - j] = temp;
        }
    }
}

// Spiral Matrix
public List<Integer> spiralOrder(int[][] matrix) {
    List<Integer> result = new ArrayList<>();
    if (matrix.length == 0) return result;

    int top = 0, bottom = matrix.length - 1;
    int left = 0, right = matrix[0].length - 1;

    while (top <= bottom && left <= right) {
        // Traverse right
        for (int col = left; col <= right; col++) {
            result.add(matrix[top][col]);
        }
        top++;

        // Traverse down
        for (int row = top; row <= bottom; row++) {
            result.add(matrix[row][right]);
        }
        right--;

        if (top <= bottom) {
            // Traverse left
            for (int col = right; col >= left; col--) {
                result.add(matrix[bottom][col]);
            }
            bottom--;
        }

        if (left <= right) {
            // Traverse up
            for (int row = bottom; row >= top; row--) {
                result.add(matrix[row][left]);
            }
            left++;
        }
    }

    return result;
}

// Set Matrix Zeroes
public void setZeroes(int[][] matrix) {
    boolean firstRowZero = false, firstColZero = false;

    // Check if first row should be zero
    for (int j = 0; j < matrix[0].length; j++) {
        if (matrix[0][j] == 0) {
            firstRowZero = true;
            break;
        }
    }

    // Check if first column should be zero
    for (int i = 0; i < matrix.length; i++) {
        if (matrix[i][0] == 0) {
            firstColZero = true;
            break;
        }
    }

    // Use first row and column as markers
    for (int i = 1; i < matrix.length; i++) {
        for (int j = 1; j < matrix[0].length; j++) {
            if (matrix[i][j] == 0) {
                matrix[i][0] = 0;
                matrix[0][j] = 0;
            }
        }
    }

    // Set zeros based on markers
    for (int i = 1; i < matrix.length; i++) {
        for (int j = 1; j < matrix[0].length; j++) {
            if (matrix[i][0] == 0 || matrix[0][j] == 0) {
                matrix[i][j] = 0;
            }
        }
    }

    // Handle first row and column
    if (firstRowZero) {
        for (int j = 0; j < matrix[0].length; j++) {
            matrix[0][j] = 0;
        }
    }

    if (firstColZero) {
        for (int i = 0; i < matrix.length; i++) {
            matrix[i][0] = 0;
        }
    }
}
```


***

## Pattern 12: Advanced Array Techniques

### 12.1 Boyer-Moore Voting Algorithm

```java
// Majority Element
public int majorityElement(int[] nums) {
    int candidate = 0;
    int count = 0;

    // Phase 1: Find candidate
    for (int num : nums) {
        if (count == 0) {
            candidate = num;
        }
        count += (num == candidate) ? 1 : -1;
    }

    return candidate; // Guaranteed to exist
}

// Majority Element II (More than n/3)
public List<Integer> majorityElement(int[] nums) {
    int candidate1 = 0, candidate2 = 0;
    int count1 = 0, count2 = 0;

    // Phase 1: Find candidates
    for (int num : nums) {
        if (candidate1 == num) {
            count1++;
        } else if (candidate2 == num) {
            count2++;
        } else if (count1 == 0) {
            candidate1 = num;
            count1 = 1;
        } else if (count2 == 0) {
            candidate2 = num;
            count2 = 1;
        } else {
            count1--;
            count2--;
        }
    }

    // Phase 2: Verify candidates
    List<Integer> result = new ArrayList<>();
    count1 = count2 = 0;

    for (int num : nums) {
        if (num == candidate1) count1++;
        else if (num == candidate2) count2++;
    }

    if (count1 > nums.length / 3) result.add(candidate1);
    if (count2 > nums.length / 3) result.add(candidate2);

    return result;
}
```


### 12.2 Array Manipulation Techniques

```java
// Next Permutation
public void nextPermutation(int[] nums) {
    int i = nums.length - 2;

    // Find first decreasing element from right
    while (i >= 0 && nums[i] >= nums[i + 1]) {
        i--;
    }

    if (i >= 0) {
        int j = nums.length - 1;
        // Find element just larger than nums[i]
        while (nums[j] <= nums[i]) {
            j--;
        }
        swap(nums, i, j);
    }

    // Reverse suffix
    reverse(nums, i + 1);
}

private void reverse(int[] nums, int start) {
    int end = nums.length - 1;
    while (start < end) {
        swap(nums, start++, end--);
    }
}

// Gas Station
public int canCompleteCircuit(int[] gas, int[] cost) {
    int totalTank = 0, currentTank = 0, startStation = 0;

    for (int i = 0; i < gas.length; i++) {
        totalTank += gas[i] - cost[i];
        currentTank += gas[i] - cost[i];

        if (currentTank < 0) {
            startStation = i + 1;
            currentTank = 0;
        }
    }

    return totalTank >= 0 ? startStation : -1;
}
```


***

## Time \& Space Complexity Reference[1]

| Pattern | Time Complexity | Space Complexity | Key Characteristics |
| :-- | :-- | :-- | :-- |
| Two Pointers | O(n) | O(1) | Linear scan with constant space |
| Sliding Window | O(n) | O(1) to O(k) | Single pass with window state |
| Prefix Sum | O(n) | O(n) | Preprocessing for range queries |
| Kadane's Algorithm | O(n) | O(1) | Single pass maximum subarray |
| Fast \& Slow Pointers | O(n) | O(1) | Cycle detection patterns |
| Cyclic Sort | O(n) | O(1) | In-place sorting for specific ranges |
| Merge Intervals | O(n log n) | O(1) to O(n) | Sorting + linear merge |
| Dutch National Flag | O(n) | O(1) | Three-way partitioning |
| Binary Search | O(log n) | O(1) | Divide and conquer |
| Matrix Operations | O(m × n) | O(1) to O(m × n) | 2D array processing |


***

## Best Practices \& Optimization Tips

### Array Algorithm Guidelines

```java
// 1. Always check bounds
public void safeBoundsCheck(int[] arr, int index) {
    if (index < 0 || index >= arr.length) {
        throw new ArrayIndexOutOfBoundsException();
    }
    // Process arr[index]
}

// 2. Use appropriate data structures
Map<Integer, Integer> frequency = new HashMap<>(); // For counting
Set<Integer> seen = new HashSet<>(); // For uniqueness
Deque<Integer> window = new ArrayDeque<>(); // For sliding window

// 3. Consider edge cases
public int[] handleEdgeCases(int[] arr) {
    if (arr == null || arr.length == 0) {
        return new int[0]; // or throw exception
    }

    if (arr.length == 1) {
        return arr; // Handle single element
    }

    // Main logic
    return arr;
}

// 4. Optimize space when possible
public void inPlaceOperation(int[] arr) {
    // Modify array in-place instead of creating new array
    int writeIndex = 0;
    for (int readIndex = 0; readIndex < arr.length; readIndex++) {
        if (shouldKeep(arr[readIndex])) {
            arr[writeIndex++] = arr[readIndex];
        }
    }
}

boolean shouldKeep(int value) { return value != 0; }
```


### Common Pitfalls to Avoid

1. **Integer Overflow**: Use `long` for sum calculations
2. **Off-by-one errors**: Careful with array bounds
3. **Null pointer exceptions**: Always check for null arrays
4. **Modifying array while iterating**: Use separate read/write pointers
5. **Not handling empty arrays**: Check length before processing

### Interview Tips[10][11]

- **Identify the pattern** early: sorting, two pointers, sliding window, etc.
- **Draw examples** on paper to visualize the problem
- **Start with brute force** then optimize
- **Consider time vs space tradeoffs**
- **Test with edge cases**: empty arrays, single elements, duplicates
