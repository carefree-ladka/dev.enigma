# Java DSA Fundamentals

## Table of Contents

1. [Arrays](#arrays)
2. [Strings](#strings)
3. [ArrayList](#arraylist)
4. [LinkedList](#linkedlist)
5. [Stack (ArrayDeque)](#stack-arraydeque)
6. [Queue (ArrayDeque)](#queue-arraydeque)
7. [Deque (ArrayDeque)](#deque-arraydeque)
8. [PriorityQueue (Heap)](#priorityqueue-heap)
9. [HashMap](#hashmap)
10. [HashSet](#hashset)
11. [LinkedHashMap](#linkedhashmap)
12. [LinkedHashSet](#linkedhashset)
13. [TreeMap](#treemap)
14. [TreeSet](#treeset)
15. [Sorting Algorithms](#sorting-algorithms)
16. [Searching Algorithms](#searching-algorithms)
17. [Recursion](#recursion)
18. [Backtracking](#backtracking)
19. [Dynamic Programming](#dynamic-programming)
20. [Graph Algorithms](#graph-algorithms)
21. [Trees](#trees)
22. [Tries](#tries)
23. [Bit Manipulation](#bit-manipulation)
24. [Math & Number Theory](#math-number-theory)

---

## Arrays

### Declaration and Initialization

```java
// Declaration
int[] arr = new int[5];
int[] arr2 = {1, 2, 3, 4, 5};
int[][] matrix = new int[3][4];

// 2D Array
int[][] matrix2 = {
    {1, 2, 3},
    {4, 5, 6}
};
```

### Common Operations

```java
// Length
int len = arr.length;

// Copy array
int[] copy = Arrays.copyOf(arr, arr.length);
int[] rangeCopy = Arrays.copyOfRange(arr, 0, 3);

// Fill array
Arrays.fill(arr, 0);

// Sort
Arrays.sort(arr);
Arrays.sort(arr, Collections.reverseOrder()); // For Integer[]

// Binary Search (array must be sorted)
int index = Arrays.binarySearch(arr, 5);

// Compare arrays
boolean isEqual = Arrays.equals(arr1, arr2);

// Convert to String
String str = Arrays.toString(arr);
```

### Time Complexities

- Access: O(1)
- Search: O(n)
- Insert/Delete: O(n)

---

## Strings

### String Class (Immutable)

```java
String s = "hello";
String s2 = new String("world");

// Common methods
int len = s.length();
char ch = s.charAt(0);
String sub = s.substring(1, 3);
String concat = s.concat(" world");
String upper = s.toUpperCase();
String lower = s.toLowerCase();
boolean contains = s.contains("ell");
boolean starts = s.startsWith("he");
boolean ends = s.endsWith("lo");
int index = s.indexOf("l");
int lastIdx = s.lastIndexOf("l");
String replaced = s.replace('l', 'x');
String[] split = s.split(" ");
String trimmed = s.trim();
boolean empty = s.isEmpty();
char[] charArray = s.toCharArray();

// String comparison
boolean equal = s.equals(s2);
boolean equalIgnoreCase = s.equalsIgnoreCase(s2);
int compare = s.compareTo(s2);
```

### StringBuilder (Mutable)

```java
StringBuilder sb = new StringBuilder();
sb.append("hello");
sb.append(" world");
sb.insert(5, "!");
sb.delete(5, 6);
sb.deleteCharAt(5);
sb.reverse();
sb.setCharAt(0, 'H');
String result = sb.toString();
```

### Time Complexities

- String concatenation with +: O(nÂ²)
- StringBuilder append: O(1) amortized

---

## ArrayList

### Declaration and Operations

```java
import java.util.ArrayList;
import java.util.Collections;

ArrayList<Integer> list = new ArrayList<>();
ArrayList<Integer> list2 = new ArrayList<>(Arrays.asList(1, 2, 3));

// Add elements
list.add(10);
list.add(0, 5); // Add at index

// Access
int val = list.get(0);
list.set(0, 20); // Update

// Remove
list.remove(0); // Remove by index
list.remove(Integer.valueOf(20)); // Remove by value

// Size and checks
int size = list.size();
boolean isEmpty = list.isEmpty();
boolean contains = list.contains(10);
int index = list.indexOf(10);

// Clear
list.clear();

// Sorting
Collections.sort(list);
Collections.sort(list, Collections.reverseOrder());

// Convert to array
Integer[] arr = list.toArray(new Integer[0]);
```

### Time Complexities

- Access: O(1)
- Add (end): O(1) amortized
- Add (beginning): O(n)
- Remove (end): O(1)
- Remove (beginning): O(n)
- Search: O(n)

---

## LinkedList

### Declaration and Operations

```java
import java.util.LinkedList;

LinkedList<Integer> list = new LinkedList<>();

// Add elements
list.add(10);
list.addFirst(5);
list.addLast(15);
list.add(1, 7); // Add at index

// Access
int first = list.getFirst();
int last = list.getLast();
int val = list.get(1);

// Remove
int removedFirst = list.removeFirst();
int removedLast = list.removeLast();
list.remove(1); // Remove by index
list.remove(Integer.valueOf(10)); // Remove by value

// Size and checks
int size = list.size();
boolean isEmpty = list.isEmpty();
boolean contains = list.contains(10);
```

### Time Complexities

- Access: O(n)
- Add (beginning/end): O(1)
- Add (middle): O(n)
- Remove (beginning/end): O(1)
- Remove (middle): O(n)

---

## Stack (ArrayDeque)

### Why ArrayDeque over Stack?

ArrayDeque is faster than the legacy Stack class and should be preferred for stack operations. It's not thread-safe but more efficient.

### Declaration and Operations

```java
import java.util.ArrayDeque;
import java.util.Deque;

// Use ArrayDeque as Stack
Deque<Integer> stack = new ArrayDeque<>();

// Push elements (add to top)
stack.push(10);
stack.push(20);
stack.push(30);

// Peek (view top without removing)
int top = stack.peek();        // 30 (returns null if empty)
int top2 = stack.peekFirst();  // 30 (same as peek)

// Pop (remove and return top)
int popped = stack.pop();      // 30 (throws exception if empty)
int popped2 = stack.pollFirst(); // Returns null if empty

// Check if empty
boolean isEmpty = stack.isEmpty();

// Size
int size = stack.size();

// Search (returns distance from top, 1-indexed)
// Note: Not directly available in ArrayDeque
// Use contains() instead
boolean exists = stack.contains(20);

// Clear
stack.clear();

// Iterate (bottom to top)
for (Integer num : stack) {
    System.out.println(num);
}
```

### Stack Implementation Examples

```java
// Example 1: Balanced Parentheses
public boolean isValid(String s) {
    Deque<Character> stack = new ArrayDeque<>();
    for (char c : s.toCharArray()) {
        if (c == '(' || c == '{' || c == '[') {
            stack.push(c);
        } else {
            if (stack.isEmpty()) return false;
            char top = stack.pop();
            if (c == ')' && top != '(') return false;
            if (c == '}' && top != '{') return false;
            if (c == ']' && top != '[') return false;
        }
    }
    return stack.isEmpty();
}

// Example 2: Next Greater Element
public int[] nextGreaterElement(int[] nums) {
    int n = nums.length;
    int[] result = new int[n];
    Deque<Integer> stack = new ArrayDeque<>();

    for (int i = n - 1; i >= 0; i--) {
        while (!stack.isEmpty() && stack.peek() <= nums[i]) {
            stack.pop();
        }
        result[i] = stack.isEmpty() ? -1 : stack.peek();
        stack.push(nums[i]);
    }
    return result;
}

// Example 3: Evaluate Postfix Expression
public int evalRPN(String[] tokens) {
    Deque<Integer> stack = new ArrayDeque<>();
    for (String token : tokens) {
        if (token.equals("+") || token.equals("-") ||
            token.equals("*") || token.equals("/")) {
            int b = stack.pop();
            int a = stack.pop();
            if (token.equals("+")) stack.push(a + b);
            else if (token.equals("-")) stack.push(a - b);
            else if (token.equals("*")) stack.push(a * b);
            else stack.push(a / b);
        } else {
            stack.push(Integer.parseInt(token));
        }
    }
    return stack.pop();
}
```

### Time Complexities

- Push: O(1)
- Pop: O(1)
- Peek: O(1)
- Search: O(n)

---

## Queue (ArrayDeque)

### Why ArrayDeque over LinkedList?

ArrayDeque is generally faster than LinkedList for queue operations and has better cache locality.

### Declaration and Operations

```java
import java.util.ArrayDeque;
import java.util.Queue;

// Use ArrayDeque as Queue
Queue<Integer> queue = new ArrayDeque<>();

// Enqueue (add to rear)
queue.offer(10);    // Returns false if fails
queue.add(20);      // Throws exception if fails

// Peek (view front without removing)
int front = queue.peek();   // Returns null if empty
int front2 = queue.element(); // Throws exception if empty

// Dequeue (remove and return front)
int removed = queue.poll();   // Returns null if empty
int removed2 = queue.remove(); // Throws exception if empty

// Check if empty
boolean isEmpty = queue.isEmpty();

// Size
int size = queue.size();

// Check if contains
boolean exists = queue.contains(10);

// Clear
queue.clear();

// Iterate (front to rear)
for (Integer num : queue) {
    System.out.println(num);
}
```

### Queue Implementation Examples

```java
// Example 1: BFS in Binary Tree
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> result = new ArrayList<>();
    if (root == null) return result;

    Queue<TreeNode> queue = new ArrayDeque<>();
    queue.offer(root);

    while (!queue.isEmpty()) {
        int size = queue.size();
        List<Integer> level = new ArrayList<>();

        for (int i = 0; i < size; i++) {
            TreeNode node = queue.poll();
            level.add(node.val);

            if (node.left != null) queue.offer(node.left);
            if (node.right != null) queue.offer(node.right);
        }
        result.add(level);
    }
    return result;
}

// Example 2: Sliding Window Maximum
public int[] maxSlidingWindow(int[] nums, int k) {
    Deque<Integer> deque = new ArrayDeque<>();
    int[] result = new int[nums.length - k + 1];

    for (int i = 0; i < nums.length; i++) {
        // Remove elements outside window
        while (!deque.isEmpty() && deque.peekFirst() < i - k + 1) {
            deque.pollFirst();
        }

        // Remove smaller elements
        while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {
            deque.pollLast();
        }

        deque.offerLast(i);

        if (i >= k - 1) {
            result[i - k + 1] = nums[deque.peekFirst()];
        }
    }
    return result;
}

// Example 3: Implement Stack using Queues
class MyStack {
    Queue<Integer> q1;
    Queue<Integer> q2;

    public MyStack() {
        q1 = new ArrayDeque<>();
        q2 = new ArrayDeque<>();
    }

    public void push(int x) {
        q2.offer(x);
        while (!q1.isEmpty()) {
            q2.offer(q1.poll());
        }
        Queue<Integer> temp = q1;
        q1 = q2;
        q2 = temp;
    }

    public int pop() {
        return q1.poll();
    }

    public int top() {
        return q1.peek();
    }

    public boolean empty() {
        return q1.isEmpty();
    }
}
```

### Time Complexities

- Enqueue: O(1)
- Dequeue: O(1)
- Peek: O(1)
- Search: O(n)

---

## Deque (ArrayDeque)

### Full Deque Operations

ArrayDeque implements the Deque interface and provides double-ended queue functionality.

### Declaration and Operations

```java
import java.util.ArrayDeque;
import java.util.Deque;

Deque<Integer> deque = new ArrayDeque<>();

// Add to front
deque.addFirst(10);    // Throws exception if fails
deque.offerFirst(5);   // Returns false if fails

// Add to rear
deque.addLast(20);     // Throws exception if fails
deque.offerLast(25);   // Returns false if fails

// Peek front
int front = deque.peekFirst();   // Returns null if empty
int front2 = deque.getFirst();   // Throws exception if empty

// Peek rear
int rear = deque.peekLast();     // Returns null if empty
int rear2 = deque.getLast();     // Throws exception if empty

// Remove from front
int removed = deque.pollFirst();  // Returns null if empty
int removed2 = deque.removeFirst(); // Throws exception if empty

// Remove from rear
int removed3 = deque.pollLast();   // Returns null if empty
int removed4 = deque.removeLast(); // Throws exception if empty

// Size and checks
int size = deque.size();
boolean isEmpty = deque.isEmpty();
boolean contains = deque.contains(10);

// Remove specific element
deque.removeFirstOccurrence(10);
deque.removeLastOccurrence(20);

// Clear
deque.clear();

// Iterate forward
for (Integer num : deque) {
    System.out.println(num);
}

// Iterate backward
Iterator<Integer> it = deque.descendingIterator();
while (it.hasNext()) {
    System.out.println(it.next());
}
```

### Deque as Stack and Queue

```java
// As Stack (LIFO)
deque.push(10);      // Same as addFirst()
deque.pop();         // Same as removeFirst()
deque.peek();        // Same as peekFirst()

// As Queue (FIFO)
deque.offer(10);     // Same as offerLast()
deque.poll();        // Same as pollFirst()
deque.peek();        // Same as peekFirst()
```

### Deque Implementation Examples

```java
// Example 1: Sliding Window Maximum using Deque
public int[] maxSlidingWindow(int[] nums, int k) {
    Deque<Integer> deque = new ArrayDeque<>();
    int[] result = new int[nums.length - k + 1];

    for (int i = 0; i < nums.length; i++) {
        // Remove indices outside window
        while (!deque.isEmpty() && deque.peekFirst() < i - k + 1) {
            deque.pollFirst();
        }

        // Remove smaller elements from rear
        while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {
            deque.pollLast();
        }

        deque.offerLast(i);

        if (i >= k - 1) {
            result[i - k + 1] = nums[deque.peekFirst()];
        }
    }
    return result;
}

// Example 2: Max of all subarrays of size k
public ArrayList<Integer> maxOfSubarrays(int[] arr, int k) {
    ArrayList<Integer> result = new ArrayList<>();
    Deque<Integer> deque = new ArrayDeque<>();

    for (int i = 0; i < arr.length; i++) {
        // Remove elements outside window
        if (!deque.isEmpty() && deque.peekFirst() <= i - k) {
            deque.pollFirst();
        }

        // Remove smaller elements
        while (!deque.isEmpty() && arr[deque.peekLast()] <= arr[i]) {
            deque.pollLast();
        }

        deque.offerLast(i);

        if (i >= k - 1) {
            result.add(arr[deque.peekFirst()]);
        }
    }
    return result;
}

// Example 3: First negative in every window of size k
public long[] printFirstNegativeInteger(long[] arr, int k) {
    long[] result = new long[arr.length - k + 1];
    Deque<Integer> deque = new ArrayDeque<>();

    for (int i = 0; i < arr.length; i++) {
        // Add negative numbers to deque
        if (arr[i] < 0) {
            deque.offerLast(i);
        }

        // Remove elements outside window
        while (!deque.isEmpty() && deque.peekFirst() < i - k + 1) {
            deque.pollFirst();
        }

        if (i >= k - 1) {
            if (!deque.isEmpty()) {
                result[i - k + 1] = arr[deque.peekFirst()];
            } else {
                result[i - k + 1] = 0;
            }
        }
    }
    return result;
}
```

### Method Comparison Table

| Operation | First Element | Last Element | Throws Exception | Returns Special Value |
| --------- | ------------- | ------------ | ---------------- | --------------------- |
| Insert    | addFirst(e)   | addLast(e)   | offerFirst(e)    | offerLast(e)          |
| Remove    | removeFirst() | removeLast() | pollFirst()      | pollLast()            |
| Examine   | getFirst()    | getLast()    | peekFirst()      | peekLast()            |

### Time Complexities

- Add (both ends): O(1)
- Remove (both ends): O(1)
- Peek (both ends): O(1)
- Search: O(n)

---

## PriorityQueue (Heap)

### Declaration and Operations

```java
import java.util.PriorityQueue;
import java.util.Collections;

// Min Heap (default)
PriorityQueue<Integer> minHeap = new PriorityQueue<>();

// Max Heap
PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());

// Custom comparator
PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);

// Add elements
pq.offer(10);
pq.add(20);

// Peek (view top)
int top = pq.peek();

// Poll (remove and return top)
int removed = pq.poll();

// Size
int size = pq.size();
boolean isEmpty = pq.isEmpty();

// Contains
boolean exists = pq.contains(10);

// Remove specific element
pq.remove(10);

// Clear
pq.clear();
```

### Custom Objects in PriorityQueue

```java
class Student implements Comparable<Student> {
    String name;
    int marks;

    public Student(String name, int marks) {
        this.name = name;
        this.marks = marks;
    }

    @Override
    public int compareTo(Student other) {
        return this.marks - other.marks; // Min heap by marks
    }
}

PriorityQueue<Student> pq = new PriorityQueue<>();

// Or use comparator
PriorityQueue<Student> pq2 = new PriorityQueue<>((a, b) -> b.marks - a.marks);
```

### Time Complexities

- Insert: O(log n)
- Remove top: O(log n)
- Peek: O(1)
- Remove specific: O(n)

---

## HashMap

### Declaration and Operations

```java
import java.util.HashMap;
import java.util.Map;

HashMap<String, Integer> map = new HashMap<>();

// Put key-value pairs
map.put("apple", 5);
map.put("banana", 3);
map.putIfAbsent("apple", 10); // Only puts if key doesn't exist

// Get value
int val = map.get("apple");
int valOrDefault = map.getOrDefault("grape", 0);

// Check if key/value exists
boolean hasKey = map.containsKey("apple");
boolean hasValue = map.containsValue(5);

// Remove
int removed = map.remove("apple");

// Size
int size = map.size();
boolean isEmpty = map.isEmpty();

// Clear
map.clear();

// Iterate
for (Map.Entry<String, Integer> entry : map.entrySet()) {
    System.out.println(entry.getKey() + ": " + entry.getValue());
}

// Iterate keys
for (String key : map.keySet()) {
    System.out.println(key);
}

// Iterate values
for (Integer value : map.values()) {
    System.out.println(value);
}

// Update value
map.put("banana", map.get("banana") + 1);
map.merge("banana", 1, Integer::sum);
map.computeIfPresent("banana", (k, v) -> v + 1);
```

### Time Complexities

- Get: O(1) average, O(n) worst
- Put: O(1) average, O(n) worst
- Remove: O(1) average, O(n) worst
- ContainsKey: O(1) average, O(n) worst

---

## HashSet

### Declaration and Operations

```java
import java.util.HashSet;

HashSet<Integer> set = new HashSet<>();

// Add elements
set.add(10);
set.add(20);

// Remove
set.remove(10);

// Contains
boolean exists = set.contains(20);

// Size
int size = set.size();
boolean isEmpty = set.isEmpty();

// Clear
set.clear();

// Iterate
for (Integer num : set) {
    System.out.println(num);
}

// Convert to array
Integer[] arr = set.toArray(new Integer[0]);
```

### Time Complexities

- Add: O(1) average
- Remove: O(1) average
- Contains: O(1) average

---

## LinkedHashMap

Maintains insertion order.

```java
import java.util.LinkedHashMap;

LinkedHashMap<String, Integer> map = new LinkedHashMap<>();

// All HashMap operations apply
map.put("first", 1);
map.put("second", 2);
map.put("third", 3);

// Maintains insertion order during iteration
for (Map.Entry<String, Integer> entry : map.entrySet()) {
    System.out.println(entry.getKey() + ": " + entry.getValue());
}
// Output: first: 1, second: 2, third: 3
```

### Time Complexities

Same as HashMap.

---

## LinkedHashSet

Maintains insertion order.

```java
import java.util.LinkedHashSet;

LinkedHashSet<Integer> set = new LinkedHashSet<>();

// All HashSet operations apply
set.add(30);
set.add(10);
set.add(20);

// Maintains insertion order
for (Integer num : set) {
    System.out.println(num);
}
// Output: 30, 10, 20
```

### Time Complexities

Same as HashSet.

---

## TreeMap

Maintains keys in sorted order (Red-Black Tree).

```java
import java.util.TreeMap;

TreeMap<Integer, String> map = new TreeMap<>();

// Put
map.put(3, "three");
map.put(1, "one");
map.put(2, "two");

// Get
String val = map.get(1);

// First and last keys
int firstKey = map.firstKey();
int lastKey = map.lastKey();

// First and last entries
Map.Entry<Integer, String> firstEntry = map.firstEntry();
Map.Entry<Integer, String> lastEntry = map.lastEntry();

// Floor and ceiling
Integer floor = map.floorKey(2); // Largest key <= 2
Integer ceiling = map.ceilingKey(2); // Smallest key >= 2

// Lower and higher
Integer lower = map.lowerKey(2); // Largest key < 2
Integer higher = map.higherKey(2); // Smallest key > 2

// Submap
TreeMap<Integer, String> subMap = new TreeMap<>(map.subMap(1, 3));

// Remove first/last
map.pollFirstEntry();
map.pollLastEntry();
```

### Time Complexities

- Get: O(log n)
- Put: O(log n)
- Remove: O(log n)
- ContainsKey: O(log n)

---

## TreeSet

Maintains elements in sorted order (Red-Black Tree).

```java
import java.util.TreeSet;

TreeSet<Integer> set = new TreeSet<>();

// Add
set.add(30);
set.add(10);
set.add(20);

// First and last
int first = set.first();
int last = set.last();

// Floor and ceiling
Integer floor = set.floor(25); // Largest element <= 25
Integer ceiling = set.ceiling(25); // Smallest element >= 25

// Lower and higher
Integer lower = set.lower(20); // Largest element < 20
Integer higher = set.higher(20); // Smallest element > 20

// Subset
TreeSet<Integer> subset = new TreeSet<>(set.subSet(10, 30));

// Remove first/last
set.pollFirst();
set.pollLast();

// Descending set
TreeSet<Integer> descSet = new TreeSet<>(set.descendingSet());
```

### Time Complexities

- Add: O(log n)
- Remove: O(log n)
- Contains: O(log n)

---

## Sorting Algorithms

### Bubble Sort

```java
void bubbleSort(int[] arr) {
    int n = arr.length;
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
// Time: O(nÂ²), Space: O(1)
```

### Selection Sort

```java
void selectionSort(int[] arr) {
    int n = arr.length;
    for (int i = 0; i < n - 1; i++) {
        int minIdx = i;
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIdx]) {
                minIdx = j;
            }
        }
        int temp = arr[i];
        arr[i] = arr[minIdx];
        arr[minIdx] = temp;
    }
}
// Time: O(nÂ²), Space: O(1)
```

### Insertion Sort

```java
void insertionSort(int[] arr) {
    int n = arr.length;
    for (int i = 1; i < n; i++) {
        int key = arr[i];
        int j = i - 1;
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
}
// Time: O(nÂ²), Space: O(1)
```

### Merge Sort

```java
void mergeSort(int[] arr, int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2;
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);
        merge(arr, left, mid, right);
    }
}

void merge(int[] arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;

    int[] L = new int[n1];
    int[] R = new int[n2];

    for (int i = 0; i < n1; i++) L[i] = arr[left + i];
    for (int j = 0; j < n2; j++) R[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left;
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k++] = L[i++];
        } else {
            arr[k++] = R[j++];
        }
    }

    while (i < n1) arr[k++] = L[i++];
    while (j < n2) arr[k++] = R[j++];
}
// Time: O(n log n), Space: O(n)
```

### Quick Sort

```java
void quickSort(int[] arr, int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

int partition(int[] arr, int low, int high) {
    int pivot = arr[high];
    int i = low - 1;

    for (int j = low; j < high; j++) {
        if (arr[j] < pivot) {
            i++;
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }

    int temp = arr[i + 1];
    arr[i + 1] = arr[high];
    arr[high] = temp;

    return i + 1;
}
// Time: O(n log n) average, O(nÂ²) worst, Space: O(log n)
```

### Heap Sort

```java
void heapSort(int[] arr) {
    int n = arr.length;

    // Build heap
    for (int i = n / 2 - 1; i >= 0; i--) {
        heapify(arr, i, 0);
    }
}

void heapify(int[] arr, int n, int i) {
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;

    if (left < n && arr[left] > arr[largest]) {
        largest = left;
    }
    if (right < n && arr[right] > arr[largest]) {
        largest = right;
    }

    if (largest != i) {
        int temp = arr[i];
        arr[i] = arr[largest];
        arr[largest] = temp;
        heapify(arr, n, largest);
    }
}
// Time: O(n log n), Space: O(1)
```

### Counting Sort

```java
void countingSort(int[] arr) {
    int max = Arrays.stream(arr).max().getAsInt();
    int min = Arrays.stream(arr).min().getAsInt();
    int range = max - min + 1;

    int[] count = new int[range];
    int[] output = new int[arr.length];

    for (int num : arr) {
        count[num - min]++;
    }

    for (int i = 1; i < range; i++) {
        count[i] += count[i - 1];
    }

    for (int i = arr.length - 1; i >= 0; i--) {
        output[count[arr[i] - min] - 1] = arr[i];
        count[arr[i] - min]--;
    }

    System.arraycopy(output, 0, arr, 0, arr.length);
}
// Time: O(n + k), Space: O(n + k), where k is range
```

---

## Searching Algorithms

### Linear Search

```java
int linearSearch(int[] arr, int target) {
    for (int i = 0; i < arr.length; i++) {
        if (arr[i] == target) {
            return i;
        }
    }
    return -1;
}
// Time: O(n), Space: O(1)
```

### Binary Search

```java
int binarySearch(int[] arr, int target) {
    int left = 0, right = arr.length - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;

        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return -1;
}
// Time: O(log n), Space: O(1)

// Recursive
int binarySearchRecursive(int[] arr, int target, int left, int right) {
    if (left > right) return -1;

    int mid = left + (right - left) / 2;

    if (arr[mid] == target) return mid;
    else if (arr[mid] < target) return binarySearchRecursive(arr, target, mid + 1, right);
    else return binarySearchRecursive(arr, target, left, mid - 1);
}
```

### Binary Search Variations

```java
// Find first occurrence
int findFirst(int[] arr, int target) {
    int left = 0, right = arr.length - 1;
    int result = -1;

    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] == target) {
            result = mid;
            right = mid - 1; // Continue searching left
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return result;
}

// Find last occurrence
int findLast(int[] arr, int target) {
    int left = 0, right = arr.length - 1;
    int result = -1;

    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] == target) {
            result = mid;
            left = mid + 1; // Continue searching right
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return result;
}

// Find insertion position (lower_bound)
int lowerBound(int[] arr, int target) {
    int left = 0, right = arr.length;

    while (left < right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return left;
}

// Find upper bound
int upperBound(int[] arr, int target) {
    int left = 0, right = arr.length;

    while (left < right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] <= target) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return left;
}
```

---

## Recursion

### Basic Recursion

```java
// Factorial
int factorial(int n) {
    if (n <= 1) return 1;
    return n * factorial(n - 1);
}

// Fibonacci
int fibonacci(int n) {
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}

// Power
int power(int base, int exp) {
    if (exp == 0) return 1;
    return base * power(base, exp - 1);
}

// Sum of digits
int sumOfDigits(int n) {
    if (n == 0) return 0;
    return n % 10 + sumOfDigits(n / 10);
}

// Print 1 to N
void print1ToN(int n) {
    if (n == 0) return;
    print1ToN(n - 1);
    System.out.println(n);
}

// Print N to 1
void printNTo1(int n) {
    if (n == 0) return;
    System.out.println(n);
    printNTo1(n - 1);
}

// Array sum
int arraySum(int[] arr, int n) {
    if (n <= 0) return 0;
    return arr[n - 1] + arraySum(arr, n - 1);
}

// Check if array is sorted
boolean isSorted(int[] arr, int n) {
    if (n == 1) return true;
    return arr[n - 1] >= arr[n - 2] && isSorted(arr, n - 1);
}
```

### Advanced Recursion

```java
// Tower of Hanoi
void towerOfHanoi(int n, char from, char to, char aux) {
    if (n == 1) {
        System.out.println("Move disk 1 from " + from + " to " + to);
        return;
    }
    towerOfHanoi(n - 1, from, aux, to);
    System.out.println("Move disk " + n + " from " + from + " to " + to);
    towerOfHanoi(n - 1, aux, to, from);
}

// Generate all binary strings
void generateBinaryStrings(int n, String current) {
    if (current.length() == n) {
        System.out.println(current);
        return;
    }
    generateBinaryStrings(n, current + "0");
    generateBinaryStrings(n, current + "1");
}

// Josephus problem
int josephus(int n, int k) {
    if (n == 1) return 0;
    return (josephus(n - 1, k) + k) % n;
}
```

---

## Backtracking

### Permutations

```java
void permute(int[] arr, int start, List<List<Integer>> result) {
    if (start == arr.length) {
        List<Integer> list = new ArrayList<>();
        for (int num : arr) list.add(num);
        result.add(list);
        return;
    }

    for (int i = start; i < arr.length; i++) {
        swap(arr, start, i);
        permute(arr, start + 1, result);
        swap(arr, start, i); // Backtrack
    }
}

void swap(int[] arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
```

### Combinations

```java
void combine(int n, int k, int start, List<Integer> current, List<List<Integer>> result) {
    if (current.size() == k) {
        result.add(new ArrayList<>(current));
        return;
    }

    for (int i = start; i <= n; i++) {
        current.add(i);
        combine(n, k, i + 1, current, result);
        current.remove(current.size() - 1); // Backtrack
    }
}
```

### Subsets

```java
void subsets(int[] arr, int index, List<Integer> current, List<List<Integer>> result) {
    result.add(new ArrayList<>(current));

    for (int i = index; i < arr.length; i++) {
        current.add(arr[i]);
        subsets(arr, i + 1, current, result);
        current.remove(current.size() - 1); // Backtrack
    }
}
```

### N-Queens

```java
void solveNQueens(int n, int row, boolean[] cols, boolean[] diag1, boolean[] diag2,
                  List<Integer> board, List<List<String>> result) {
    if (row == n) {
        result.add(constructBoard(board, n));
        return;
    }

    for (int col = 0; col < n; col++) {
        int d1 = row - col + n - 1;
        int d2 = row + col;

        if (!cols[col] && !diag1[d1] && !diag2[d2]) {
            cols[col] = diag1[d1] = diag2[d2] = true;
            board.add(col);

            solveNQueens(n, row + 1, cols, diag1, diag2, board, result);

            board.remove(board.size() - 1);
            cols[col] = diag1[d1] = diag2[d2] = false;
        }
    }
}

List<String> constructBoard(List<Integer> board, int n) {
    List<String> result = new ArrayList<>();
    for (int col : board) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < n; i++) {
            sb.append(i == col ? 'Q' : '.');
        }
        result.add(sb.toString());
    }
    return result;
}
```

### Sudoku Solver

```java
boolean solveSudoku(char[][] board) {
    for (int row = 0; row < 9; row++) {
        for (int col = 0; col < 9; col++) {
            if (board[row][col] == '.') {
                for (char num = '1'; num <= '9'; num++) {
                    if (isValid(board, row, col, num)) {
                        board[row][col] = num;

                        if (solveSudoku(board)) return true;

                        board[row][col] = '.'; // Backtrack
                    }
                }
                return false;
            }
        }
    }
    return true;
}

boolean isValid(char[][] board, int row, int col, char num) {
    for (int i = 0; i < 9; i++) {
        if (board[row][i] == num) return false;
        if (board[i][col] == num) return false;
        if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == num) return false;
    }
    return true;
}
```

### Rat in a Maze

```java
boolean solveMaze(int[][] maze, int x, int y, int[][] sol) {
    int n = maze.length;

    if (x == n - 1 && y == n - 1 && maze[x][y] == 1) {
        sol[x][y] = 1;
        return true;
    }

    if (isSafe(maze, x, y, n)) {
        sol[x][y] = 1;

        if (solveMaze(maze, x + 1, y, sol)) return true;
        if (solveMaze(maze, x, y + 1, sol)) return true;

        sol[x][y] = 0; // Backtrack
    }

    return false;
}

boolean isSafe(int[][] maze, int x, int y, int n) {
    return x >= 0 && x < n && y >= 0 && y < n && maze[x][y] == 1;
}
```

---

## Dynamic Programming

### 1D DP

#### Fibonacci

```java
int fib(int n) {
    if (n <= 1) return n;
    int[] dp = new int[n + 1];
    dp[0] = 0;
    dp[1] = 1;

    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}
```

#### Climbing Stairs

```java
int climbStairs(int n) {
    if (n <= 2) return n;
    int[] dp = new int[n + 1];
    dp[1] = 1;
    dp[2] = 2;

    for (int i = 3; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}
```

#### House Robber

```java
int rob(int[] nums) {
    if (nums.length == 0) return 0;
    if (nums.length == 1) return nums[0];

    int[] dp = new int[nums.length];
    dp[0] = nums[0];
    dp[1] = Math.max(nums[0], nums[1]);

    for (int i = 2; i < nums.length; i++) {
        dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
    }
    return dp[nums.length - 1];
}
```

#### Coin Change

```java
int coinChange(int[] coins, int amount) {
    int[] dp = new int[amount + 1];
    Arrays.fill(dp, amount + 1);
    dp[0] = 0;

    for (int i = 1; i <= amount; i++) {
        for (int coin : coins) {
            if (i >= coin) {
                dp[i] = Math.min(dp[i], dp[i - coin] + 1);
            }
        }
    }
    return dp[amount] > amount ? -1 : dp[amount];
}
```

### 2D DP

#### Longest Common Subsequence

```java
int lcs(String s1, String s2) {
    int m = s1.length(), n = s2.length();
    int[][] dp = new int[m + 1][n + 1];

    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (s1.charAt(i - 1) == s2.charAt(j - 1)) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[m][n];
}
```

#### 0/1 Knapsack

```java
int knapsack(int[] weights, int[] values, int W) {
    int n = weights.length;
    int[][] dp = new int[n + 1][W + 1];

    for (int i = 1; i <= n; i++) {
        for (int w = 1; w <= W; w++) {
            if (weights[i - 1] <= w) {
                dp[i][w] = Math.max(dp[i - 1][w],
                                    dp[i - 1][w - weights[i - 1]] + values[i - 1]);
            } else {
                dp[i][w] = dp[i - 1][w];
            }
        }
    }
    return dp[n][W];
}
```

#### Edit Distance

```java
int editDistance(String s1, String s2) {
    int m = s1.length(), n = s2.length();
    int[][] dp = new int[m + 1][n + 1];

    for (int i = 0; i <= m; i++) dp[i][0] = i;
    for (int j = 0; j <= n; j++) dp[0][j] = j;

    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (s1.charAt(i - 1) == s2.charAt(j - 1)) {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                dp[i][j] = 1 + Math.min(dp[i - 1][j - 1],
                                        Math.min(dp[i - 1][j], dp[i][j - 1]));
            }
        }
    }
    return dp[m][n];
}
```

#### Longest Palindromic Subsequence

```java
int longestPalindromeSubseq(String s) {
    int n = s.length();
    int[][] dp = new int[n][n];

    for (int i = 0; i < n; i++) dp[i][i] = 1;

    for (int len = 2; len <= n; len++) {
        for (int i = 0; i < n - len + 1; i++) {
            int j = i + len - 1;
            if (s.charAt(i) == s.charAt(j)) {
                dp[i][j] = dp[i + 1][j - 1] + 2;
            } else {
                dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[0][n - 1];
}
```

#### Matrix Chain Multiplication

```java
int matrixChainOrder(int[] dims) {
    int n = dims.length - 1;
    int[][] dp = new int[n][n];

    for (int len = 2; len <= n; len++) {
        for (int i = 0; i < n - len + 1; i++) {
            int j = i + len - 1;
            dp[i][j] = Integer.MAX_VALUE;

            for (int k = i; k < j; k++) {
                int cost = dp[i][k] + dp[k + 1][j] +
                          dims[i] * dims[k + 1] * dims[j + 1];
                dp[i][j] = Math.min(dp[i][j], cost);
            }
        }
    }
    return dp[0][n - 1];
}
```

---

## Graph Algorithms

### Graph Representation

#### Adjacency List

```java
class Graph {
    int V;
    ArrayList<ArrayList<Integer>> adj;

    Graph(int v) {
        V = v;
        adj = new ArrayList<>();
        for (int i = 0; i < v; i++) {
            adj.add(new ArrayList<>());
        }
    }

    void addEdge(int u, int v) {
        adj.get(u).add(v);
        adj.get(v).add(u); // For undirected graph
    }
}
```

#### Adjacency Matrix

```java
class Graph {
    int[][] adj;
    int V;

    Graph(int v) {
        V = v;
        adj = new int[v][v];
    }

    void addEdge(int u, int v) {
        adj[u][v] = 1;
        adj[v][u] = 1; // For undirected graph
    }
}
```

### BFS (Breadth-First Search)

```java
void BFS(int start) {
    boolean[] visited = new boolean[V];
    Queue<Integer> queue = new ArrayDeque<>();

    visited[start] = true;
    queue.offer(start);

    while (!queue.isEmpty()) {
        int u = queue.poll();
        System.out.print(u + " ");

        for (int v : adj.get(u)) {
            if (!visited[v]) {
                visited[v] = true;
                queue.offer(v);
            }
        }
    }
}
```

### DFS (Depth-First Search)

```java
void DFS(int start) {
    boolean[] visited = new boolean[V];
    DFSUtil(start, visited);
}

void DFSUtil(int u, boolean[] visited) {
    visited[u] = true;
    System.out.print(u + " ");

    for (int v : adj.get(u)) {
        if (!visited[v]) {
            DFSUtil(v, visited);
        }
    }
}

// Iterative DFS
void DFSIterative(int start) {
    boolean[] visited = new boolean[V];
    Deque<Integer> stack = new ArrayDeque<>();

    stack.push(start);

    while (!stack.isEmpty()) {
        int u = stack.pop();

        if (!visited[u]) {
            visited[u] = true;
            System.out.print(u + " ");

            for (int v : adj.get(u)) {
                if (!visited[v]) {
                    stack.push(v);
                }
            }
        }
    }
}
```

### Dijkstra's Algorithm

```java
int[] dijkstra(int src) {
    int[] dist = new int[V];
    Arrays.fill(dist, Integer.MAX_VALUE);
    dist[src] = 0;

    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);
    pq.offer(new int[]{src, 0});

    while (!pq.isEmpty()) {
        int[] curr = pq.poll();
        int u = curr[0];

        for (int[] edge : adjWeighted.get(u)) {
            int v = edge[0];
            int weight = edge[1];

            if (dist[u] + weight < dist[v]) {
                dist[v] = dist[u] + weight;
                pq.offer(new int[]{v, dist[v]});
            }
        }
    }
    return dist;
}
```

### Bellman-Ford Algorithm

```java
int[] bellmanFord(int src, List<int[]> edges) {
    int[] dist = new int[V];
    Arrays.fill(dist, Integer.MAX_VALUE);
    dist[src] = 0;

    for (int i = 0; i < V - 1; i++) {
        for (int[] edge : edges) {
            int u = edge[0], v = edge[1], w = edge[2];
            if (dist[u] != Integer.MAX_VALUE && dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
            }
        }
    }

    // Check for negative cycle
    for (int[] edge : edges) {
        int u = edge[0], v = edge[1], w = edge[2];
        if (dist[u] != Integer.MAX_VALUE && dist[u] + w < dist[v]) {
            System.out.println("Negative cycle detected");
            return null;
        }
    }
    return dist;
}
```

### Floyd-Warshall Algorithm

```java
int[][] floydWarshall() {
    int[][] dist = new int[V][V];

    for (int i = 0; i < V; i++) {
        Arrays.fill(dist[i], Integer.MAX_VALUE);
        dist[i][i] = 0;
    }

    // Initialize with edge weights
    for (int u = 0; u < V; u++) {
        for (int[] edge : adjWeighted.get(u)) {
            int v = edge[0];
            int w = edge[1];
            dist[u][v] = w;
        }
    }

    for (int k = 0; k < V; k++) {
        for (int i = 0; i < V; i++) {
            for (int j = 0; j < V; j++) {
                if (dist[i][k] != Integer.MAX_VALUE &&
                    dist[k][j] != Integer.MAX_VALUE &&
                    dist[i][k] + dist[k][j] < dist[i][j]) {
                    dist[i][j] = dist[i][k] + dist[k][j];
                }
            }
        }
    }
    return dist;
}
```

### Topological Sort (DFS)

```java
void topologicalSort() {
    boolean[] visited = new boolean[V];
    Deque<Integer> stack = new ArrayDeque<>();

    for (int i = 0; i < V; i++) {
        if (!visited[i]) {
            topologicalSortUtil(i, visited, stack);
        }
    }

    while (!stack.isEmpty()) {
        System.out.print(stack.pop() + " ");
    }
}

void topologicalSortUtil(int u, boolean[] visited, Deque<Integer> stack) {
    visited[u] = true;

    for (int v : adj.get(u)) {
        if (!visited[v]) {
            topologicalSortUtil(v, visited, stack);
        }
    }

    stack.push(u);
}
```

### Topological Sort (Kahn's Algorithm - BFS)

```java
void topologicalSortBFS() {
    int[] indegree = new int[V];

    for (int u = 0; u < V; u++) {
        for (int v : adj.get(u)) {
            indegree[v]++;
        }
    }

    Queue<Integer> queue = new ArrayDeque<>();
    for (int i = 0; i < V; i++) {
        if (indegree[i] == 0) {
            queue.offer(i);
        }
    }

    while (!queue.isEmpty()) {
        int u = queue.poll();
        System.out.print(u + " ");

        for (int v : adj.get(u)) {
            indegree[v]--;
            if (indegree[v] == 0) {
                queue.offer(v);
            }
        }
    }
}
```

### Detect Cycle (Undirected Graph)

```java
boolean hasCycle() {
    boolean[] visited = new boolean[V];

    for (int i = 0; i < V; i++) {
        if (!visited[i]) {
            if (hasCycleUtil(i, visited, -1)) {
                return true;
            }
        }
    }
    return false;
}

boolean hasCycleUtil(int u, boolean[] visited, int parent) {
    visited[u] = true;

    for (int v : adj.get(u)) {
        if (!visited[v]) {
            if (hasCycleUtil(v, visited, u)) {
                return true;
            }
        } else if (v != parent) {
            return true;
        }
    }
    return false;
}
```

### Detect Cycle (Directed Graph)

```java
boolean hasCycleDirected() {
    boolean[] visited = new boolean[V];
    boolean[] recStack = new boolean[V];

    for (int i = 0; i < V; i++) {
        if (hasCycleDirectedUtil(i, visited, recStack)) {
            return true;
        }
    }
    return false;
}

boolean hasCycleDirectedUtil(int u, boolean[] visited, boolean[] recStack) {
    if (recStack[u]) return true;
    if (visited[u]) return false;

    visited[u] = true;
    recStack[u] = true;

    for (int v : adj.get(u)) {
        if (hasCycleDirectedUtil(v, visited, recStack)) {
            return true;
        }
    }

    recStack[u] = false;
    return false;
}
```

### Prim's MST

```java
int primMST() {
    boolean[] inMST = new boolean[V];
    int[] key = new int[V];
    Arrays.fill(key, Integer.MAX_VALUE);
    key[0] = 0;

    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);
    pq.offer(new int[]{0, 0});

    int mstWeight = 0;

    while (!pq.isEmpty()) {
        int[] curr = pq.poll();
        int u = curr[0];

        if (inMST[u]) continue;

        inMST[u] = true;
        mstWeight += curr[1];

        for (int[] edge : adjWeighted.get(u)) {
            int v = edge[0];
            int weight = edge[1];

            if (!inMST[v] && weight < key[v]) {
                key[v] = weight;
                pq.offer(new int[]{v, weight});
            }
        }
    }
    return mstWeight;
}
```

### Kruskal's MST

```java
class Edge implements Comparable<Edge> {
    int src, dest, weight;

    Edge(int s, int d, int w) {
        src = s;
        dest = d;
        weight = w;
    }

    public int compareTo(Edge other) {
        return this.weight - other.weight;
    }
}

int kruskalMST(List<Edge> edges) {
    Collections.sort(edges);

    int[] parent = new int[V];
    for (int i = 0; i < V; i++) parent[i] = i;

    int mstWeight = 0;
    int edgeCount = 0;

    for (Edge edge : edges) {
        int x = find(parent, edge.src);
        int y = find(parent, edge.dest);

        if (x != y) {
            mstWeight += edge.weight;
            union(parent, x, y);
            edgeCount++;

            if (edgeCount == V - 1) break;
        }
    }
    return mstWeight;
}

int find(int[] parent, int i) {
    if (parent[i] != i) {
        parent[i] = find(parent, parent[i]);
    }
    return parent[i];
}

void union(int[] parent, int x, int y) {
    parent[x] = y;
}
```

### Union-Find (Disjoint Set)

```java
class UnionFind {
    int[] parent;
    int[] rank;

    UnionFind(int n) {
        parent = new int[n];
        rank = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }

    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]); // Path compression
        }
        return parent[x];
    }

    void union(int x, int y) {
        int px = find(x);
        int py = find(y);

        if (px == py) return;

        // Union by rank
        if (rank[px] < rank[py]) {
            parent[px] = py;
        } else if (rank[px] > rank[py]) {
            parent[py] = px;
        } else {
            parent[py] = px;
            rank[px]++;
        }
    }

    boolean connected(int x, int y) {
        return find(x) == find(y);
    }
}
```

---

## Trees

### Binary Tree Node

```java
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode(int val) {
        this.val = val;
    }
}
```

### Binary Tree Traversals

#### Inorder (Left, Root, Right)

```java
void inorder(TreeNode root) {
    if (root == null) return;
    inorder(root.left);
    System.out.print(root.val + " ");
    inorder(root.right);
}

// Iterative
void inorderIterative(TreeNode root) {
    Deque<TreeNode> stack = new ArrayDeque<>();
    TreeNode curr = root;

    while (curr != null || !stack.isEmpty()) {
        while (curr != null) {
            stack.push(curr);
            curr = curr.left;
        }
        curr = stack.pop();
        System.out.print(curr.val + " ");
        curr = curr.right;
    }
}
```

#### Preorder (Root, Left, Right)

```java
void preorder(TreeNode root) {
    if (root == null) return;
    System.out.print(root.val + " ");
    preorder(root.left);
    preorder(root.right);
}

// Iterative
void preorderIterative(TreeNode root) {
    if (root == null) return;
    Deque<TreeNode> stack = new ArrayDeque<>();
    stack.push(root);

    while (!stack.isEmpty()) {
        TreeNode node = stack.pop();
        System.out.print(node.val + " ");

        if (node.right != null) stack.push(node.right);
        if (node.left != null) stack.push(node.left);
    }
}
```

#### Postorder (Left, Right, Root)

```java
void postorder(TreeNode root) {
    if (root == null) return;
    postorder(root.left);
    postorder(root.right);
    System.out.print(root.val + " ");
}

// Iterative (2 stacks)
void postorderIterative(TreeNode root) {
    if (root == null) return;
    Deque<TreeNode> stack1 = new ArrayDeque<>();
    Deque<TreeNode> stack2 = new ArrayDeque<>();

    stack1.push(root);

    while (!stack1.isEmpty()) {
        TreeNode node = stack1.pop();
        stack2.push(node);

        if (node.left != null) stack1.push(node.left);
        if (node.right != null) stack1.push(node.right);
    }

    while (!stack2.isEmpty()) {
        System.out.print(stack2.pop().val + " ");
    }
}
```

#### Level Order (BFS)

```java
void levelOrder(TreeNode root) {
    if (root == null) return;
    Queue<TreeNode> queue = new ArrayDeque<>();
    queue.offer(root);

    while (!queue.isEmpty()) {
        TreeNode node = queue.poll();
        System.out.print(node.val + " ");

        if (node.left != null) queue.offer(node.left);
        if (node.right != null) queue.offer(node.right);
    }
}
```

### Binary Tree Operations

#### Height of Tree

```java
int height(TreeNode root) {
    if (root == null) return 0;
    return 1 + Math.max(height(root.left), height(root.right));
}
```

#### Diameter of Tree

```java
int diameter(TreeNode root) {
    int[] dia = new int[1];
    diameterHelper(root, dia);
    return dia[0];
}

int diameterHelper(TreeNode root, int[] dia) {
    if (root == null) return 0;

    int left = diameterHelper(root.left, dia);
    int right = diameterHelper(root.right, dia);

    dia[0] = Math.max(dia[0], left + right);

    return 1 + Math.max(left, right);
}
```

#### Check if Balanced

```java
boolean isBalanced(TreeNode root) {
    return checkBalance(root) != -1;
}

int checkBalance(TreeNode root) {
    if (root == null) return 0;

    int left = checkBalance(root.left);
    if (left == -1) return -1;

    int right = checkBalance(root.right);
    if (right == -1) return -1;

    if (Math.abs(left - right) > 1) return -1;

    return 1 + Math.max(left, right);
}
```

#### Lowest Common Ancestor

```java
TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root == null || root == p || root == q) return root;

    TreeNode left = lowestCommonAncestor(root.left, p, q);
    TreeNode right = lowestCommonAncestor(root.right, p, q);

    if (left != null && right != null) return root;
    return left != null ? left : right;
}
```

#### Maximum Path Sum

```java
int maxPathSum(TreeNode root) {
    int[] max = new int[]{Integer.MIN_VALUE};
    maxPathSumHelper(root, max);
    return max[0];
}

int maxPathSumHelper(TreeNode root, int[] max) {
    if (root == null) return 0;

    int left = Math.max(0, maxPathSumHelper(root.left, max));
    int right = Math.max(0, maxPathSumHelper(root.right, max));

    max[0] = Math.max(max[0], left + right + root.val);

    return root.val + Math.max(left, right);
}
```

### Binary Search Tree (BST)

#### Search in BST

```java
TreeNode search(TreeNode root, int val) {
    if (root == null || root.val == val) return root;

    if (val < root.val) {
        return search(root.left, val);
    }
    return search(root.right, val);
}
```

#### Insert in BST

```java
TreeNode insert(TreeNode root, int val) {
    if (root == null) return new TreeNode(val);

    if (val < root.val) {
        root.left = insert(root.left, val);
    } else {
        root.right = insert(root.right, val);
    }
    return root;
}
```

#### Delete from BST

```java
TreeNode delete(TreeNode root, int val) {
    if (root == null) return null;

    if (val < root.val) {
        root.left = delete(root.left, val);
    } else if (val > root.val) {
        root.right = delete(root.right, val);
    } else {
        if (root.left == null) return root.right;
        if (root.right == null) return root.left;

        TreeNode minNode = findMin(root.right);
        root.val = minNode.val;
        root.right = delete(root.right, minNode.val);
    }
    return root;
}

TreeNode findMin(TreeNode root) {
    while (root.left != null) root = root.left;
    return root;
}
```

#### Validate BST

```java
boolean isValidBST(TreeNode root) {
    return validate(root, null, null);
}

boolean validate(TreeNode root, Integer min, Integer max) {
    if (root == null) return true;

    if ((min != null && root.val <= min) || (max != null && root.val >= max)) {
        return false;
    }

    return validate(root.left, min, root.val) && validate(root.right, root.val, max);
}
```

#### Kth Smallest in BST

```java
int kthSmallest(TreeNode root, int k) {
    Deque<TreeNode> stack = new ArrayDeque<>();
    TreeNode curr = root;

    while (curr != null || !stack.isEmpty()) {
        while (curr != null) {
            stack.push(curr);
            curr = curr.left;
        }
        curr = stack.pop();
        k--;
        if (k == 0) return curr.val;
        curr = curr.right;
    }
    return -1;
}
```

### Segment Tree

```java
class SegmentTree {
    int[] tree;
    int n;

    SegmentTree(int[] arr) {
        n = arr.length;
        tree = new int[4 * n];
        build(arr, 0, 0, n - 1);
    }

    void build(int[] arr, int node, int start, int end) {
        if (start == end) {
            tree[node] = arr[start];
            return;
        }

        int mid = (start + end) / 2;
        build(arr, 2 * node + 1, start, mid);
        build(arr, 2 * node + 2, mid + 1, end);
        tree[node] = tree[2 * node + 1] + tree[2 * node + 2];
    }

    int query(int l, int r) {
        return query(0, 0, n - 1, l, r);
    }

    int query(int node, int start, int end, int l, int r) {
        if (r < start || l > end) return 0;
        if (l <= start && end <= r) return tree[node];

        int mid = (start + end) / 2;
        return query(2 * node + 1, start, mid, l, r) +
               query(2 * node + 2, mid + 1, end, l, r);
    }

    void update(int idx, int val) {
        update(0, 0, n - 1, idx, val);
    }

    void update(int node, int start, int end, int idx, int val) {
        if (start == end) {
            tree[node] = val;
            return;
        }

        int mid = (start + end) / 2;
        if (idx <= mid) {
            update(2 * node + 1, start, mid, idx, val);
        } else {
            update(2 * node + 2, mid + 1, end, idx, val);
        }
        tree[node] = tree[2 * node + 1] + tree[2 * node + 2];
    }
}
```

---

## Tries

### Trie Implementation

```java
class TrieNode {
    TrieNode[] children;
    boolean isEndOfWord;

    TrieNode() {
        children = new TrieNode[26];
        isEndOfWord = false;
    }
}

class Trie {
    TrieNode root;

    Trie() {
        root = new TrieNode();
    }

    void insert(String word) {
        TrieNode node = root;

        for (char c : word.toCharArray()) {
            int idx = c - 'a';
            if (node.children[idx] == null) {
                node.children[idx] = new TrieNode();
            }
            node = node.children[idx];
        }
        node.isEndOfWord = true;
    }

    boolean search(String word) {
        TrieNode node = root;

        for (char c : word.toCharArray()) {
            int idx = c - 'a';
            if (node.children[idx] == null) {
                return false;
            }
            node = node.children[idx];
        }
        return node.isEndOfWord;
    }

    boolean startsWith(String prefix) {
        TrieNode node = root;

        for (char c : prefix.toCharArray()) {
            int idx = c - 'a';
            if (node.children[idx] == null) {
                return false;
            }
            node = node.children[idx];
        }
        return true;
    }

    void delete(String word) {
        delete(root, word, 0);
    }

    boolean delete(TrieNode node, String word, int idx) {
        if (idx == word.length()) {
            if (!node.isEndOfWord) return false;
            node.isEndOfWord = false;
            return isEmpty(node);
        }

        int charIdx = word.charAt(idx) - 'a';
        TrieNode child = node.children[charIdx];
        if (child == null) return false;

        boolean shouldDeleteChild = delete(child, word, idx + 1);

        if (shouldDeleteChild) {
            node.children[charIdx] = null;
            return !node.isEndOfWord && isEmpty(node);
        }
        return false;
    }

    boolean isEmpty(TrieNode node) {
        for (TrieNode child : node.children) {
            if (child != null) return false;
        }
        return true;
    }
}
```

---

## Bit Manipulation

### Basic Operations

```java
// Check if kth bit is set
boolean isSet(int n, int k) {
    return (n & (1 << k)) != 0;
}

// Set kth bit
int setBit(int n, int k) {
    return n | (1 << k);
}

// Clear kth bit
int clearBit(int n, int k) {
    return n & ~(1 << k);
}

// Toggle kth bit
int toggleBit(int n, int k) {
    return n ^ (1 << k);
}

// Count set bits
int countSetBits(int n) {
    int count = 0;
    while (n > 0) {
        count += n & 1;
        n >>= 1;
    }
    return count;
}

// Brian Kernighan's Algorithm (count set bits)
int countSetBitsFast(int n) {
    int count = 0;
    while (n > 0) {
        n &= (n - 1);
        count++;
    }
    return count;
}

// Check if power of 2
boolean isPowerOfTwo(int n) {
    return n > 0 && (n & (n - 1)) == 0;
}

// Find rightmost set bit
int rightmostSetBit(int n) {
    return n & -n;
}

// Turn off rightmost set bit
int turnOffRightmost(int n) {
    return n & (n - 1);
}

// XOR of numbers from 1 to n
int xorFrom1ToN(int n) {
    int mod = n % 4;
    if (mod == 0) return n;
    if (mod == 1) return 1;
    if (mod == 2) return n + 1;
    return 0;
}
```

### Advanced Bit Manipulation

```java
// Single number (all others appear twice)
int singleNumber(int[] nums) {
    int result = 0;
    for (int num : nums) {
        result ^= num;
    }
    return result;
}

// Two numbers appear once, rest twice
int[] singleNumberII(int[] nums) {
    int xor = 0;
    for (int num : nums) xor ^= num;

    int rightmostBit = xor & -xor;
    int num1 = 0, num2 = 0;

    for (int num : nums) {
        if ((num & rightmostBit) != 0) {
            num1 ^= num;
        } else {
            num2 ^= num;
        }
    }
    return new int[]{num1, num2};
}

// Generate all subsets using bits
void generateSubsets(int[] arr) {
    int n = arr.length;
    for (int i = 0; i < (1 << n); i++) {
        for (int j = 0; j < n; j++) {
            if ((i & (1 << j)) != 0) {
                System.out.print(arr[j] + " ");
            }
        }
        System.out.println();
    }
}

// Swap two numbers without temp
void swap(int a, int b) {
    a = a ^ b;
    b = a ^ b;
    a = a ^ b;
}
```

---

## Math & Number Theory

### GCD and LCM

```java
int gcd(int a, int b) {
    if (b == 0) return a;
    return gcd(b, a % b);
}

int lcm(int a, int b) {
    return (a * b) / gcd(a, b);
}
```

### Prime Numbers

#### Check Prime

```java
boolean isPrime(int n) {
    if (n <= 1) return false;
    if (n <= 3) return true;
    if (n % 2 == 0 || n % 3 == 0) return false;

    for (int i = 5; i * i <= n; i += 6) {
        if (n % i == 0 || n % (i + 2) == 0) {
            return false;
        }
    }
    return true;
}
```

#### Sieve of Eratosthenes

```java
boolean[] sieve(int n) {
    boolean[] isPrime = new boolean[n + 1];
    Arrays.fill(isPrime, true);
    isPrime[0] = isPrime[1] = false;

    for (int i = 2; i * i <= n; i++) {
        if (isPrime[i]) {
            for (int j = i * i; j <= n; j += i) {
                isPrime[j] = false;
            }
        }
    }
    return isPrime;
}
```

### Modular Arithmetic

```java
// Modular exponentiation
long modPow(long base, long exp, long mod) {
    long result = 1;
    base %= mod;

    while (exp > 0) {
        if (exp % 2 == 1) {
            result = (result * base) % mod;
        }
        base = (base * base) % mod;
        exp /= 2;
    }
    return result;
}

// Modular inverse (Fermat's theorem)
long modInverse(long a, long mod) {
    return modPow(a, mod - 2, mod);
}
```

### Combinatorics

```java
// Factorial
long factorial(int n) {
    long result = 1;
    for (int i = 2; i <= n; i++) {
        result *= i;
    }
    return result;
}

// nCr (Combinations)
long nCr(int n, int r) {
    if (r > n) return 0;
    if (r == 0 || r == n) return 1;

    long result = 1;
    for (int i = 0; i < r; i++) {
        result = result * (n - i) / (i + 1);
    }
    return result;
}

// Pascal's Triangle for nCr
int[][] pascalTriangle(int n) {
    int[][] triangle = new int[n][];

    for (int i = 0; i < n; i++) {
        triangle[i] = new int[i + 1];
        triangle[i][0] = triangle[i][i] = 1;

        for (int j = 1; j < i; j++) {
            triangle[i][j] = triangle[i - 1][j - 1] + triangle[i - 1][j];
        }
    }
    return triangle;
}
```

### Number Theory

#### Count Digits

```java
int countDigits(int n) {
    if (n == 0) return 1;
    int count = 0;
    while (n > 0) {
        count++;
        n /= 10;
    }
    return count;
}
```

#### Reverse Number

```java
int reverse(int n) {
    int result = 0;
    while (n > 0) {
        result = result * 10 + n % 10;
        n /= 10;
    }
    return result;
}
```

#### Check Palindrome Number

```java
boolean isPalindrome(int n) {
    int original = n;
    int reversed = 0;

    while (n > 0) {
        reversed = reversed * 10 + n % 10;
        n /= 10;
    }
    return original == reversed;
}
```

#### Armstrong Number

```java
boolean isArmstrong(int n) {
    int original = n;
    int sum = 0;
    int digits = String.valueOf(n).length();

    while (n > 0) {
        int digit = n % 10;
        sum += Math.pow(digit, digits);
        n /= 10;
    }
    return sum == original;
}
```

#### Sum of Divisors

```java
int sumOfDivisors(int n) {
    int sum = 0;
    for (int i = 1; i * i <= n; i++) {
        if (n % i == 0) {
            sum += i;
            if (i != n / i) {
                sum += n / i;
            }
        }
    }
    return sum;
}
```

---

## Time Complexity Quick Reference

| Data Structure | Access | Search   | Insert   | Delete   |
| -------------- | ------ | -------- | -------- | -------- |
| Array          | O(1)   | O(n)     | O(n)     | O(n)     |
| ArrayList      | O(1)   | O(n)     | O(1)\*   | O(n)     |
| LinkedList     | O(n)   | O(n)     | O(1)     | O(1)     |
| Stack          | O(n)   | O(n)     | O(1)     | O(1)     |
| Queue          | O(n)   | O(n)     | O(1)     | O(1)     |
| HashMap        | -      | O(1)\*   | O(1)\*   | O(1)\*   |
| TreeMap        | -      | O(log n) | O(log n) | O(log n) |
| HashSet        | -      | O(1)\*   | O(1)\*   | O(1)\*   |
| TreeSet        | -      | O(log n) | O(log n) | O(log n) |
| PriorityQueue  | -      | O(n)     | O(log n) | O(log n) |

\*Amortized time complexity

## Sorting Algorithm Comparison

| Algorithm      | Best       | Average    | Worst      | Space    |
| -------------- | ---------- | ---------- | ---------- | -------- |
| Bubble Sort    | O(n)       | O(nÂ²)      | O(nÂ²)      | O(1)     |
| Selection Sort | O(nÂ²)      | O(nÂ²)      | O(nÂ²)      | O(1)     |
| Insertion Sort | O(n)       | O(nÂ²)      | O(nÂ²)      | O(1)     |
| Merge Sort     | O(n log n) | O(n log n) | O(n log n) | O(n)     |
| Quick Sort     | O(n log n) | O(n log n) | O(nÂ²)      | O(log n) |
| Heap Sort      | O(n log n) | O(n log n) | O(n log n) | O(1)     |
| Counting Sort  | O(n+k)     | O(n+k)     | O(n+k)     | O(k)     |

---

## Important Tips

1. **Use ArrayDeque instead of Stack and LinkedList for stack/queue operations**
2. **HashMap/HashSet for O(1) lookups**
3. **TreeMap/TreeSet when you need sorted order**
4. **PriorityQueue for heap operations**
5. **StringBuilder for string concatenation in loops**
6. **Arrays.sort() uses Dual-Pivot Quicksort (O(n log n) average)**
7. **Collections.sort() uses TimSort (O(n log n))**
8. **Use binary search on sorted arrays**
9. **Two pointers technique for sorted arrays**
10. **Sliding window for subarray problems**
11. **Use bit manipulation for space optimization**
12. **Dynamic Programming for overlapping subproblems**
13. **Backtracking for generating all possibilities**
14. **BFS for shortest path in unweighted graphs**
15. **DFS for cycle detection and topological sort**

---
