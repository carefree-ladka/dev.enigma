# Sorting Algorithms Guide

A comprehensive guide to essential sorting algorithms for Data Structures and Algorithms interviews, implemented in Java.

## Table of Contents

- [Merge Sort](#merge-sort)
- [Quick Sort](#quick-sort)
- [Cyclic Sort](#cyclic-sort)
- [Counting Sort](#counting-sort)
- [Bucket Sort](#bucket-sort)
- [Problem Patterns \& Applications](#problem-patterns--applications)
- [Comparison \& When to Use](#comparison--when-to-use)
- [Advanced Problems](#advanced-problems)
- [Implementation Tips](#implementation-tips)

***

## Merge Sort

### Overview

Merge Sort is a stable, divide-and-conquer sorting algorithm that consistently performs in **O(n log n)** time. It recursively divides the array into smaller subarrays, sorts them, and merges them back together in sorted order.

### When to Use Merge Sort

✅ **Perfect for:**

- When stability is required (maintains relative order of equal elements)
- Large datasets where worst-case performance matters
- Linked lists (no random access needed)
- External sorting (data that doesn't fit in memory)
- Guaranteed O(n log n) performance requirement
- Parallel processing scenarios

❌ **Not suitable for:**

- Small arrays (overhead of recursion)
- Memory-constrained environments (requires O(n) extra space)
- When in-place sorting is mandatory


### Basic Implementation

```java
public class MergeSort {

    public static void mergeSort(int[] arr) {
        if (arr.length <= 1) return;

        int[] temp = new int[arr.length];
        mergeSortHelper(arr, temp, 0, arr.length - 1);
    }

    private static void mergeSortHelper(int[] arr, int[] temp, int left, int right) {
        if (left < right) {
            int mid = left + (right - left) / 2;

            // Recursively sort both halves
            mergeSortHelper(arr, temp, left, mid);
            mergeSortHelper(arr, temp, mid + 1, right);

            // Merge sorted halves
            merge(arr, temp, left, mid, right);
        }
    }

    private static void merge(int[] arr, int[] temp, int left, int mid, int right) {
        // Copy data to temp array
        for (int i = left; i <= right; i++) {
            temp[i] = arr[i];
        }

        int i = left;      // Left subarray index
        int j = mid + 1;   // Right subarray index
        int k = left;      // Merged array index

        // Merge the temp arrays back into arr[left..right]
        while (i <= mid && j <= right) {
            if (temp[i] <= temp[j]) {
                arr[k] = temp[i];
                i++;
            } else {
                arr[k] = temp[j];
                j++;
            }
            k++;
        }

        // Copy remaining elements
        while (i <= mid) {
            arr[k] = temp[i];
            i++;
            k++;
        }

        while (j <= right) {
            arr[k] = temp[j];
            j++;
            k++;
        }
    }
}
```

**Time Complexity:** O(n log n) - all cases | **Space Complexity:** O(n)

### Iterative Merge Sort (Bottom-Up)

```java
public static void mergeSortIterative(int[] arr) {
    int n = arr.length;
    int[] temp = new int[n];

    // Start with subarrays of size 1, then 2, 4, 8, ...
    for (int size = 1; size < n; size *= 2) {
        for (int start = 0; start < n - 1; start += 2 * size) {
            int mid = Math.min(start + size - 1, n - 1);
            int end = Math.min(start + 2 * size - 1, n - 1);

            if (mid < end) {
                merge(arr, temp, start, mid, end);
            }
        }
    }
}
```


### Merge Sort for Linked Lists

```java
class ListNode {
    int val;
    ListNode next;
    ListNode() {}
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}

public class LinkedListMergeSort {

    public ListNode sortList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }

        // Find middle and split
        ListNode middle = getMiddle(head);
        ListNode rightHalf = middle.next;
        middle.next = null;

        // Recursively sort both halves
        ListNode left = sortList(head);
        ListNode right = sortList(rightHalf);

        // Merge sorted halves
        return mergeTwoLists(left, right);
    }

    private ListNode getMiddle(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        ListNode prev = null;

        while (fast != null && fast.next != null) {
            prev = slow;
            slow = slow.next;
            fast = fast.next.next;
        }

        return prev;
    }

    private ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(0);
        ListNode current = dummy;

        while (l1 != null && l2 != null) {
            if (l1.val <= l2.val) {
                current.next = l1;
                l1 = l1.next;
            } else {
                current.next = l2;
                l2 = l2.next;
            }
            current = current.next;
        }

        current.next = (l1 != null) ? l1 : l2;
        return dummy.next;
    }
}
```


### Merge Sort Applications

#### 1. Count Inversions

```java
public class InversionCount {

    public static long countInversions(int[] arr) {
        int[] temp = new int[arr.length];
        return mergeSortAndCount(arr, temp, 0, arr.length - 1);
    }

    private static long mergeSortAndCount(int[] arr, int[] temp, int left, int right) {
        long invCount = 0;

        if (left < right) {
            int mid = left + (right - left) / 2;

            invCount += mergeSortAndCount(arr, temp, left, mid);
            invCount += mergeSortAndCount(arr, temp, mid + 1, right);
            invCount += mergeAndCount(arr, temp, left, mid, right);
        }

        return invCount;
    }

    private static long mergeAndCount(int[] arr, int[] temp, int left, int mid, int right) {
        // Copy data to temp array
        for (int i = left; i <= right; i++) {
            temp[i] = arr[i];
        }

        int i = left;
        int j = mid + 1;
        int k = left;
        long invCount = 0;

        while (i <= mid && j <= right) {
            if (temp[i] <= temp[j]) {
                arr[k++] = temp[i++];
            } else {
                arr[k++] = temp[j++];
                invCount += (mid - i + 1); // All elements from i to mid are greater than arr[j]
            }
        }

        while (i <= mid) arr[k++] = temp[i++];
        while (j <= right) arr[k++] = temp[j++];

        return invCount;
    }
}
```


#### 2. Merge K Sorted Arrays

```java
import java.util.*;

public class MergeKArrays {

    public static List<Integer> mergeKSortedArrays(List<List<Integer>> arrays) {
        if (arrays == null || arrays.isEmpty()) {
            return new ArrayList<>();
        }

        while (arrays.size() > 1) {
            List<List<Integer>> mergedArrays = new ArrayList<>();

            for (int i = 0; i < arrays.size(); i += 2) {
                List<Integer> arr1 = arrays.get(i);
                List<Integer> arr2 = (i + 1 < arrays.size()) ? arrays.get(i + 1) : new ArrayList<>();
                mergedArrays.add(mergeTwoArrays(arr1, arr2));
            }

            arrays = mergedArrays;
        }

        return arrays.get(0);
    }

    private static List<Integer> mergeTwoArrays(List<Integer> arr1, List<Integer> arr2) {
        List<Integer> result = new ArrayList<>();
        int i = 0, j = 0;

        while (i < arr1.size() && j < arr2.size()) {
            if (arr1.get(i) <= arr2.get(j)) {
                result.add(arr1.get(i));
                i++;
            } else {
                result.add(arr2.get(j));
                j++;
            }
        }

        while (i < arr1.size()) result.add(arr1.get(i++));
        while (j < arr2.size()) result.add(arr2.get(j++));

        return result;
    }
}
```


***

## Quick Sort

### Overview

Quick Sort is an efficient, in-place, divide-and-conquer sorting algorithm. It selects a 'pivot' element and partitions the array around the pivot, then recursively sorts the subarrays.

### When to Use Quick Sort

✅ **Perfect for:**

- General-purpose sorting (most common choice)
- In-place sorting (O(log n) space complexity)
- Average case performance matters more than worst case
- When randomized performance is acceptable
- Large datasets with good pivot selection
- Cache-efficient sorting

❌ **Not suitable for:**

- When stability is required
- When worst-case O(n²) is unacceptable
- Nearly sorted data (without randomization)
- When guaranteed performance is critical


### Basic Implementation (Lomuto Partition)

```java
public class QuickSort {

    public static void quickSort(int[] arr) {
        quickSort(arr, 0, arr.length - 1);
    }

    private static void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            // Partition the array and get pivot index
            int pivotIndex = partition(arr, low, high);

            // Recursively sort elements before and after partition
            quickSort(arr, low, pivotIndex - 1);
            quickSort(arr, pivotIndex + 1, high);
        }
    }

    private static int partition(int[] arr, int low, int high) {
        // Choose rightmost element as pivot
        int pivot = arr[high];
        int i = low - 1; // Index of smaller element

        for (int j = low; j < high; j++) {
            // If current element is smaller than or equal to pivot
            if (arr[j] <= pivot) {
                i++;
                swap(arr, i, j);
            }
        }

        // Place pivot in correct position
        swap(arr, i + 1, high);
        return i + 1;
    }

    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

**Time Complexity:**

- Average: O(n log n)
- Worst: O(n²)
- Best: O(n log n)

**Space Complexity:** O(log n) average, O(n) worst case

### Hoare Partition Scheme

```java
public static void quickSortHoare(int[] arr, int low, int high) {
    if (low < high) {
        int pivotIndex = hoarePartition(arr, low, high);

        quickSortHoare(arr, low, pivotIndex);
        quickSortHoare(arr, pivotIndex + 1, high);
    }
}

private static int hoarePartition(int[] arr, int low, int high) {
    int pivot = arr[low];
    int i = low - 1;
    int j = high + 1;

    while (true) {
        // Find element on left that should be on right
        do {
            i++;
        } while (arr[i] < pivot);

        // Find element on right that should be on left
        do {
            j--;
        } while (arr[j] > pivot);

        // If elements crossed, partitioning is done
        if (i >= j) {
            return j;
        }

        swap(arr, i, j);
    }
}
```


### Randomized Quick Sort

```java
import java.util.Random;

public static void randomizedQuickSort(int[] arr, int low, int high) {
    if (low < high) {
        // Randomly select pivot to avoid worst case
        Random rand = new Random();
        int randomPivot = low + rand.nextInt(high - low + 1);
        swap(arr, randomPivot, high);

        int pivotIndex = partition(arr, low, high);

        randomizedQuickSort(arr, low, pivotIndex - 1);
        randomizedQuickSort(arr, pivotIndex + 1, high);
    }
}
```


### 3-Way Quick Sort (Dutch National Flag)

Perfect for arrays with many duplicate elements:

```java
public static void quickSort3Way(int[] arr, int low, int high) {
    if (low < high) {
        int[] pivots = partition3Way(arr, low, high);
        int lt = pivots[0];
        int gt = pivots[1];

        quickSort3Way(arr, low, lt - 1);
        quickSort3Way(arr, gt + 1, high);
    }
}

private static int[] partition3Way(int[] arr, int low, int high) {
    int pivot = arr[low];
    int i = low;
    int lt = low;      // arr[low...lt-1] < pivot
    int gt = high + 1; // arr[gt...high] > pivot

    while (i < gt) {
        if (arr[i] < pivot) {
            swap(arr, lt, i);
            lt++;
            i++;
        } else if (arr[i] > pivot) {
            gt--;
            swap(arr, i, gt);
            // Don't increment i, as we need to examine the swapped element
        } else {
            i++; // arr[i] == pivot
        }
    }

    return new int[]{lt, gt};
}
```


### Iterative Quick Sort

```java
import java.util.Stack;

public static void quickSortIterative(int[] arr) {
    Stack<Integer> stack = new Stack<>();
    stack.push(0);
    stack.push(arr.length - 1);

    while (!stack.isEmpty()) {
        int high = stack.pop();
        int low = stack.pop();

        if (low < high) {
            int pivotIndex = partition(arr, low, high);

            // Push left and right subarrays to stack
            stack.push(low);
            stack.push(pivotIndex - 1);
            stack.push(pivotIndex + 1);
            stack.push(high);
        }
    }
}
```


### Quick Sort Applications

#### 1. Quick Select (Find Kth Smallest Element)

```java
public class QuickSelect {

    public static int quickSelect(int[] arr, int k) {
        // Convert to 0-indexed
        k = k - 1;
        return quickSelectHelper(arr, 0, arr.length - 1, k);
    }

    private static int quickSelectHelper(int[] arr, int low, int high, int k) {
        if (low == high) {
            return arr[low];
        }

        int pivotIndex = partition(arr, low, high);

        if (k == pivotIndex) {
            return arr[k];
        } else if (k < pivotIndex) {
            return quickSelectHelper(arr, low, pivotIndex - 1, k);
        } else {
            return quickSelectHelper(arr, pivotIndex + 1, high, k);
        }
    }

    private static int partition(int[] arr, int low, int high) {
        int pivot = arr[high];
        int i = low - 1;

        for (int j = low; j < high; j++) {
            if (arr[j] <= pivot) {
                i++;
                swap(arr, i, j);
            }
        }

        swap(arr, i + 1, high);
        return i + 1;
    }

    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}

// Example: Find 3rd smallest element
// System.out.println(QuickSelect.quickSelect(new int[]{7, 10, 4, 3, 20, 15}, 3)); // Output: 7
```

**Time Complexity:** O(n) average, O(n²) worst case

#### 2. Find Top K Elements

```java
public static int[] findTopKElements(int[] arr, int k) {
    int[] result = new int[k];
    quickSelectTopK(arr, 0, arr.length - 1, k);

    // Copy top k elements
    System.arraycopy(arr, 0, result, 0, k);
    return result;
}

private static void quickSelectTopK(int[] arr, int low, int high, int k) {
    if (low <= high) {
        int pivotIndex = partitionDescending(arr, low, high);

        if (pivotIndex == k - 1) {
            return;
        } else if (pivotIndex < k - 1) {
            quickSelectTopK(arr, pivotIndex + 1, high, k);
        } else {
            quickSelectTopK(arr, low, pivotIndex - 1, k);
        }
    }
}

private static int partitionDescending(int[] arr, int low, int high) {
    int pivot = arr[high];
    int i = low - 1;

    for (int j = low; j < high; j++) {
        if (arr[j] >= pivot) { // Note: >= for descending order
            i++;
            swap(arr, i, j);
        }
    }

    swap(arr, i + 1, high);
    return i + 1;
}
```


#### 3. Sort Colors (3-Way Partitioning)

```java
public static void sortColors(int[] nums) {
    int low = 0;      // Boundary for 0s
    int mid = 0;      // Current element
    int high = nums.length - 1; // Boundary for 2s

    while (mid <= high) {
        if (nums[mid] == 0) {
            swap(nums, low, mid);
            low++;
            mid++;
        } else if (nums[mid] == 1) {
            mid++;
        } else { // nums[mid] == 2
            swap(nums, mid, high);
            high--;
            // Don't increment mid, as we need to examine the swapped element
        }
    }
}
```


### Optimizations

#### 1. Hybrid Quick Sort (with Insertion Sort for small arrays)

```java
private static final int INSERTION_SORT_THRESHOLD = 10;

public static void hybridQuickSort(int[] arr, int low, int high) {
    if (low < high) {
        if (high - low + 1 < INSERTION_SORT_THRESHOLD) {
            insertionSort(arr, low, high);
        } else {
            int pivotIndex = partition(arr, low, high);
            hybridQuickSort(arr, low, pivotIndex - 1);
            hybridQuickSort(arr, pivotIndex + 1, high);
        }
    }
}

private static void insertionSort(int[] arr, int low, int high) {
    for (int i = low + 1; i <= high; i++) {
        int key = arr[i];
        int j = i - 1;

        while (j >= low && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }

        arr[j + 1] = key;
    }
}
```


#### 2. Median-of-Three Pivot Selection

```java
private static void medianOfThree(int[] arr, int low, int high) {
    int mid = low + (high - low) / 2;

    // Sort low, mid, high
    if (arr[mid] < arr[low]) {
        swap(arr, low, mid);
    }
    if (arr[high] < arr[low]) {
        swap(arr, low, high);
    }
    if (arr[high] < arr[mid]) {
        swap(arr, mid, high);
    }

    // Place median at end as pivot
    swap(arr, mid, high);
}

public static void quickSortMedianOfThree(int[] arr, int low, int high) {
    if (low < high) {
        medianOfThree(arr, low, high);
        int pivotIndex = partition(arr, low, high);

        quickSortMedianOfThree(arr, low, pivotIndex - 1);
        quickSortMedianOfThree(arr, pivotIndex + 1, high);
    }
}
```


***

## Cyclic Sort

### Overview

Cyclic Sort is an in-place sorting algorithm that works perfectly when dealing with arrays containing numbers in a given range (usually 1 to n or 0 to n-1). It places each number at its correct index directly.

### When to Use Cyclic Sort

✅ **Perfect for:**

- Arrays with numbers in range [1, n] or [0, n-1]
- Finding missing numbers
- Finding duplicate numbers
- Problems requiring O(1) space complexity
- When array elements represent indices

❌ **Not suitable for:**

- Arrays with arbitrary ranges
- Arrays with many duplicates outside the expected range
- When stability is required


### Core Algorithm

```java
public class CyclicSort {

    public static void cyclicSort(int[] nums) {
        int i = 0;

        while (i < nums.length) {
            int correctIndex = nums[i] - 1; // For 1-indexed numbers

            if (nums[i] != nums[correctIndex]) {
                // Swap current element to its correct position
                swap(nums, i, correctIndex);
            } else {
                i++;
            }
        }
    }

    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

**Time Complexity:** O(n) | **Space Complexity:** O(1)

### Cyclic Sort Variations

#### For 0-indexed arrays (numbers 0 to n-1)

```java
public static void cyclicSortZeroIndexed(int[] nums) {
    int i = 0;

    while (i < nums.length) {
        int correctIndex = nums[i]; // For 0-indexed numbers

        if (nums[i] != nums[correctIndex]) {
            swap(nums, i, correctIndex);
        } else {
            i++;
        }
    }
}
```


### Cyclic Sort Problems

#### 1. Find Missing Number

**Problem:** Given an array containing n distinct numbers taken from 0 to n, find the missing number.

```java
public class MissingNumber {

    public static int findMissingNumber(int[] nums) {
        int i = 0;
        int n = nums.length;

        // Cyclic sort for numbers 0 to n-1
        while (i < n) {
            if (nums[i] < n && nums[i] != nums[nums[i]]) {
                swap(nums, i, nums[i]);
            } else {
                i++;
            }
        }

        // Find the missing number
        for (i = 0; i < n; i++) {
            if (nums[i] != i) {
                return i;
            }
        }

        return n; // If all numbers 0 to n-1 are present
    }

    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}

// Example usage
// System.out.println(MissingNumber.findMissingNumber(new int[]{3, 0, 1})); // Output: 2
// System.out.println(MissingNumber.findMissingNumber(new int[]{0, 1})); // Output: 2
```

**Time Complexity:** O(n) | **Space Complexity:** O(1)

#### 2. Find All Missing Numbers

```java
import java.util.*;

public static List<Integer> findAllMissingNumbers(int[] nums) {
    List<Integer> missing = new ArrayList<>();
    int i = 0;

    // Cyclic sort
    while (i < nums.length) {
        int correctIndex = nums[i] - 1;
        if (nums[i] > 0 && nums[i] <= nums.length && nums[i] != nums[correctIndex]) {
            swap(nums, i, correctIndex);
        } else {
            i++;
        }
    }

    // Find all missing numbers
    for (i = 0; i < nums.length; i++) {
        if (nums[i] != i + 1) {
            missing.add(i + 1);
        }
    }

    return missing;
}

// Example usage
// System.out.println(findAllMissingNumbers(new int[]{4, 3, 2, 7, 8, 2, 3, 1})); // Output: [5, 6]
```


#### 3. Find Duplicate Number

```java
public static int findDuplicate(int[] nums) {
    int i = 0;

    while (i < nums.length) {
        int correctIndex = nums[i] - 1;
        if (nums[i] != nums[correctIndex]) {
            swap(nums, i, correctIndex);
        } else {
            i++;
        }
    }

    // Find the duplicate
    for (i = 0; i < nums.length; i++) {
        if (nums[i] != i + 1) {
            return nums[i];
        }
    }

    return -1;
}
```


#### 4. First Missing Positive

**Problem:** Find the smallest missing positive integer.

```java
public class FirstMissingPositive {

    public static int firstMissingPositive(int[] nums) {
        int n = nums.length;

        // Cyclic sort for positive numbers
        for (int i = 0; i < n; i++) {
            while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) {
                swap(nums, nums[i] - 1, i);
            }
        }

        // Find first missing positive
        for (int i = 0; i < n; i++) {
            if (nums[i] != i + 1) {
                return i + 1;
            }
        }

        return n + 1;
    }

    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}

// Example usage
// System.out.println(FirstMissingPositive.firstMissingPositive(new int[]{1, 2, 0})); // Output: 3
// System.out.println(FirstMissingPositive.firstMissingPositive(new int[]{3, 4, -1, 1})); // Output: 2
```


***

## Counting Sort

### Overview

Counting Sort is a non-comparison based sorting algorithm that works by counting the number of objects having distinct key values. It's particularly efficient when the range of potential items (k) is not significantly greater than the number of items (n).

### When to Use Counting Sort

✅ **Perfect for:**

- Small range of integers (k is small)
- When stability is required
- Frequency counting problems
- Character sorting (ASCII range)
- Age sorting, grade sorting

❌ **Not suitable for:**

- Large range of values (k >> n)
- Floating-point numbers
- Objects without integer keys
- Memory-constrained environments


### Basic Implementation

```java
public class CountingSort {

    public static int[] countingSort(int[] arr, int maxValue) {
        int[] count = new int[maxValue + 1];
        int[] output = new int[arr.length];

        // Count occurrences
        for (int i = 0; i < arr.length; i++) {
            count[arr[i]]++;
        }

        // Transform count array to actual positions
        for (int i = 1; i <= maxValue; i++) {
            count[i] += count[i - 1];
        }

        // Build output array (stable sorting)
        for (int i = arr.length - 1; i >= 0; i--) {
            output[count[arr[i]] - 1] = arr[i];
            count[arr[i]]--;
        }

        return output;
    }

    public static int[] countingSort(int[] arr) {
        int maxValue = Arrays.stream(arr).max().orElse(0);
        return countingSort(arr, maxValue);
    }
}

// Example usage
// int[] result = CountingSort.countingSort(new int[]{4, 2, 2, 8, 3, 3, 1}); // [1, 2, 2, 3, 3, 4, 8]
```

**Time Complexity:** O(n + k) | **Space Complexity:** O(k)
where k is the range of input values.

### Counting Sort for Negative Numbers

```java
public static int[] countingSortWithNegatives(int[] arr) {
    int min = Arrays.stream(arr).min().orElse(0);
    int max = Arrays.stream(arr).max().orElse(0);
    int range = max - min + 1;

    int[] count = new int[range];
    int[] output = new int[arr.length];

    // Count occurrences (shift by min)
    for (int i = 0; i < arr.length; i++) {
        count[arr[i] - min]++;
    }

    // Transform count array
    for (int i = 1; i < range; i++) {
        count[i] += count[i - 1];
    }

    // Build output array
    for (int i = arr.length - 1; i >= 0; i--) {
        output[count[arr[i] - min] - 1] = arr[i];
        count[arr[i] - min]--;
    }

    return output;
}
```


### Counting Sort Problems

#### 1. Sort Colors (Dutch National Flag)

```java
public static void sortColors(int[] nums) {
    int[] count = new int[3];

    // Count colors
    for (int num : nums) {
        count[num]++;
    }

    // Fill array
    int index = 0;
    for (int color = 0; color < 3; color++) {
        for (int i = 0; i < count[color]; i++) {
            nums[index++] = color;
        }
    }
}
```


#### 2. Character Frequency Sort

```java
import java.util.*;

public static String frequencySort(String s) {
    Map<Character, Integer> count = new HashMap<>();

    // Count characters
    for (char c : s.toCharArray()) {
        count.put(c, count.getOrDefault(c, 0) + 1);
    }

    // Sort by frequency
    List<Map.Entry<Character, Integer>> sorted = new ArrayList<>(count.entrySet());
    sorted.sort((a, b) -> b.getValue() - a.getValue());

    // Build result
    StringBuilder result = new StringBuilder();
    for (Map.Entry<Character, Integer> entry : sorted) {
        char c = entry.getKey();
        int freq = entry.getValue();
        for (int i = 0; i < freq; i++) {
            result.append(c);
        }
    }

    return result.toString();
}
```


***

## Bucket Sort

### Overview

Bucket Sort distributes elements into buckets, sorts each bucket individually, then concatenates the sorted buckets. It's most effective when input is uniformly distributed over a range.

### When to Use Bucket Sort

✅ **Perfect for:**

- Uniformly distributed data
- Floating-point numbers in range

❌ **Not suitable for:**

- Non-uniform data distribution
- Unknown data range
- Memory-constrained environments
- Small datasets


### Basic Implementation

```java
import java.util.*;

public class BucketSort {

    public static void bucketSort(double[] arr) {
        if (arr.length == 0) return;

        int bucketCount = arr.length;
        List<List<Double>> buckets = new ArrayList<>();

        // Create empty buckets
        for (int i = 0; i < bucketCount; i++) {
            buckets.add(new ArrayList<>());
        }

        // Distribute elements into buckets
        for (double num : arr) {
            int bucketIndex = (int) (num * bucketCount);
            if (bucketIndex == bucketCount) bucketIndex--; // Handle edge case
            buckets.get(bucketIndex).add(num);
        }

        // Sort individual buckets and concatenate
        int index = 0;
        for (List<Double> bucket : buckets) {
            Collections.sort(bucket);
            for (double num : bucket) {
                arr[index++] = num;
            }
        }
    }
}

// Example usage for floating point numbers in range [0, 1)
// double[] arr = {0.78, 0.17, 0.39, 0.26, 0.72, 0.94, 0.21, 0.12, 0.23, 0.68};
// BucketSort.bucketSort(arr);
```

**Time Complexity:**

- Average: O(n + k)
- Worst: O(n²)

**Space Complexity:** O(n + k)

### Bucket Sort for Integers

```java
public static void bucketSortIntegers(int[] arr, int bucketSize) {
    if (arr.length == 0) return;

    int min = Arrays.stream(arr).min().orElse(0);
    int max = Arrays.stream(arr).max().orElse(0);
    int bucketCount = (max - min) / bucketSize + 1;

    List<List<Integer>> buckets = new ArrayList<>();
    for (int i = 0; i < bucketCount; i++) {
        buckets.add(new ArrayList<>());
    }

    // Distribute elements
    for (int num : arr) {
        int bucketIndex = (num - min) / bucketSize;
        buckets.get(bucketIndex).add(num);
    }

    // Sort and concatenate
    int index = 0;
    for (List<Integer> bucket : buckets) {
        Collections.sort(bucket);
        for (int num : bucket) {
            arr[index++] = num;
        }
    }
}
```


### Bucket Sort Problems

#### 1. Top K Frequent Elements

```java
import java.util.*;

public static int[] topKFrequent(int[] nums, int k) {
    Map<Integer, Integer> count = new HashMap<>();

    // Count frequencies
    for (int num : nums) {
        count.put(num, count.getOrDefault(num, 0) + 1);
    }

    // Create buckets based on frequency
    List<List<Integer>> buckets = new ArrayList<>();
    for (int i = 0; i <= nums.length; i++) {
        buckets.add(new ArrayList<>());
    }

    for (Map.Entry<Integer, Integer> entry : count.entrySet()) {
        int num = entry.getKey();
        int freq = entry.getValue();
        buckets.get(freq).add(num);
    }

    // Collect top k elements
    List<Integer> result = new ArrayList<>();
    for (int i = buckets.size() - 1; i >= 0 && result.size() < k; i--) {
        result.addAll(buckets.get(i));
    }

    return result.stream().mapToInt(i -> i).toArray();
}
```


#### 2. Maximum Gap

```java
public static int maximumGap(int[] nums) {
    if (nums.length < 2) return 0;

    int min = Arrays.stream(nums).min().orElse(0);
    int max = Arrays.stream(nums).max().orElse(0);

    if (min == max) return 0;

    int n = nums.length;
    int bucketSize = Math.max(1, (max - min) / (n - 1));
    int bucketCount = (max - min) / bucketSize + 1;

    int[] bucketMin = new int[bucketCount];
    int[] bucketMax = new int[bucketCount];
    boolean[] hasNum = new boolean[bucketCount];

    Arrays.fill(bucketMin, Integer.MAX_VALUE);
    Arrays.fill(bucketMax, Integer.MIN_VALUE);

    // Fill buckets
    for (int num : nums) {
        int bucketIndex = (num - min) / bucketSize;
        hasNum[bucketIndex] = true;
        bucketMin[bucketIndex] = Math.min(bucketMin[bucketIndex], num);
        bucketMax[bucketIndex] = Math.max(bucketMax[bucketIndex], num);
    }

    // Find maximum gap
    int maxGap = 0;
    int prevMax = min;

    for (int i = 0; i < bucketCount; i++) {
        if (!hasNum[i]) continue;

        maxGap = Math.max(maxGap, bucketMin[i] - prevMax);
        prevMax = bucketMax[i];
    }

    return maxGap;
}
```


***

## Problem Patterns \& Applications

### Cyclic Sort Pattern Problems

```java
// Pattern: Array with numbers in range [1,n] or [0,n-1]
public class CyclicSortPatterns {

    // Template for cyclic sort problems
    public static void cyclicSortTemplate(int[] nums, boolean isOneIndexed) {
        int i = 0;

        while (i < nums.length) {
            int correctIndex = isOneIndexed ? nums[i] - 1 : nums[i];

            if (nums[i] != nums[correctIndex] &&
                nums[i] > 0 &&
                nums[i] <= nums.length) {
                swap(nums, i, correctIndex);
            } else {
                i++;
            }
        }
    }

    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}

/*
Common Cyclic Sort Problems:
- Find Missing Number
- Find All Missing Numbers
- Find Duplicate Number
- Find All Duplicates
- First Missing Positive
- Find Corrupt Pair
*/
```


### Counting Sort Pattern Problems

```java
import java.util.*;

public class CountingSortPatterns {

    // Template for counting sort problems
    public static int[] countingSortTemplate(int[] arr, Function<Integer, Integer> getKey, int maxKey) {
        int[] count = new int[maxKey + 1];

        // Count frequencies
        for (int item : arr) {
            count[getKey.apply(item)]++;
        }

        // Optional: convert to cumulative count for stable sorting
        for (int i = 1; i <= maxKey; i++) {
            count[i] += count[i - 1];
        }

        return count;
    }
}

/*
Common Counting Sort Problems:
- Sort Colors
- Relative Sort Array
- Sort Characters by Frequency
- Custom Sort String
- Rank Transform of Array
*/
```


### Bucket Sort Pattern Problems

```java
/*
Common Bucket Sort Problems:
- Top K Frequent Elements
- Sort Array by Increasing Frequency
- Maximum Gap
- Contains Duplicate III
- Group Anagrams
*/
```


***

## Comparison \& When to Use

| Algorithm | Time Complexity | Space Complexity | Best For |
| :-- | :-- | :-- | :-- |
| **Merge Sort** | O(n log n) - all cases | O(n) | Stability, large datasets, linked lists |
| **Quick Sort** | O(n log n) avg, O(n²) worst | O(log n) avg | General purpose, in-place sorting |
| **Cyclic Sort** | O(n) | O(1) | Numbers in range [1,n] |
| **Counting Sort** | O(n + k) | O(k) | Small range integers |
| **Bucket Sort** | O(n + k) avg, O(n²) worst | O(n + k) | Uniformly distributed data |

### Decision Framework

```java
public class SortingAlgorithmSelector {

    public static String chooseSortingAlgorithm(int[] data, Requirements requirements) {

        // Check for cyclic sort applicability
        if (isInRange(data, 1, data.length) || isInRange(data, 0, data.length - 1)) {
            return "Cyclic Sort";
        }

        // Check for counting sort applicability
        int min = Arrays.stream(data).min().orElse(0);
        int max = Arrays.stream(data).max().orElse(0);
        int range = max - min + 1;
        if (range <= data.length * 2) {
            return "Counting Sort";
        }

        // Check for bucket sort applicability
        if (isUniformlyDistributed(data) && !requirements.inPlaceRequired) {
            return "Bucket Sort";
        }

        // Choose between merge sort and quick sort
        if (requirements.stabilityRequired || requirements.guaranteedPerformance) {
            return requirements.memoryConstrained ? "Heap Sort" : "Merge Sort";
        }

        if (requirements.inPlaceRequired || !requirements.memoryConstrained) {
            return "Quick Sort";
        }

        return "Merge Sort"; // Default safe choice
    }

    private static boolean isInRange(int[] arr, int min, int max) {
        for (int num : arr) {
            if (num < min || num > max) return false;
        }
        return true;
    }

    private static boolean isUniformlyDistributed(int[] arr) {
        int min = Arrays.stream(arr).min().orElse(0);
        int max = Arrays.stream(arr).max().orElse(0);
        return (max - min) / (double) arr.length < 10;
    }

    static class Requirements {
        boolean stabilityRequired = false;
        boolean inPlaceRequired = false;
        boolean guaranteedPerformance = false;
        boolean memoryConstrained = false;
    }
}
```


***

## Advanced Problems

### 1. Find Corrupt Pair (Cyclic Sort)

```java
public static int[] findErrorNums(int[] nums) {
    int i = 0;

    // Cyclic sort
    while (i < nums.length) {
        int correctIndex = nums[i] - 1;
        if (nums[i] != nums[correctIndex]) {
            swap(nums, i, correctIndex);
        } else {
            i++;
        }
    }

    // Find duplicate and missing
    for (i = 0; i < nums.length; i++) {
        if (nums[i] != i + 1) {
            return new int[]{nums[i], i + 1}; // [duplicate, missing]
        }
    }

    return new int[]{};
}
```


### 2. Radix Sort (Using Counting Sort)

```java
public class RadixSort {

    public static void radixSort(int[] nums) {
        int max = Arrays.stream(nums).max().orElse(0);

        // Sort by each digit
        for (int exp = 1; max / exp > 0; exp *= 10) {
            countingSortByDigit(nums, exp);
        }
    }

    private static void countingSortByDigit(int[] nums, int exp) {
        int[] count = new int[10];
        int[] output = new int[nums.length];

        // Count occurrences of digits
        for (int i = 0; i < nums.length; i++) {
            int digit = (nums[i] / exp) % 10;
            count[digit]++;
        }

        // Transform to positions
        for (int i = 1; i < 10; i++) {
            count[i] += count[i - 1];
        }

        // Build output array
        for (int i = nums.length - 1; i >= 0; i--) {
            int digit = (nums[i] / exp) % 10;
            output[count[digit] - 1] = nums[i];
            count[digit]--;
        }

        // Copy back to original array
        System.arraycopy(output, 0, nums, 0, nums.length);
    }
}
```


### 3. Merge Intervals (Merge Sort Application)

```java
import java.util.*;

public static int[][] mergeIntervals(int[][] intervals) {
    if (intervals.length <= 1) return intervals;

    // Sort intervals by start time
    Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));

    List<int[]> merged = new ArrayList<>();
    merged.add(intervals[0]);

    for (int i = 1; i < intervals.length; i++) {
        int[] current = intervals[i];
        int[] lastMerged = merged.get(merged.size() - 1);

        if (current[0] <= lastMerged[1]) {
            // Overlapping intervals - merge them
            lastMerged[1] = Math.max(lastMerged[1], current[1]);
        } else {
            // Non-overlapping interval
            merged.add(current);
        }
    }

    return merged.toArray(new int[merged.size()][]);
}
```


### 4. Kth Largest Element in Array (Quick Select)

```java
public static int findKthLargest(int[] nums, int k) {
    // Convert to finding (n-k)th smallest (0-indexed)
    int targetIndex = nums.length - k;
    return quickSelect(nums, 0, nums.length - 1, targetIndex);
}

private static int quickSelect(int[] nums, int low, int high, int targetIndex) {
    int pivotIndex = partition(nums, low, high);

    if (pivotIndex == targetIndex) {
        return nums[pivotIndex];
    } else if (pivotIndex < targetIndex) {
        return quickSelect(nums, pivotIndex + 1, high, targetIndex);
    } else {
        return quickSelect(nums, low, pivotIndex - 1, targetIndex);
    }
}
```


### 5. Sort Array by Increasing Frequency (Bucket Sort)

```java
import java.util.*;

public static int[] frequencySort(int[] nums) {
    Map<Integer, Integer> count = new HashMap<>();

    // Count frequencies
    for (int num : nums) {
        count.put(num, count.getOrDefault(num, 0) + 1);
    }

    // Create frequency buckets
    int maxFreq = Collections.max(count.values());
    List<List<Integer>> buckets = new ArrayList<>();
    for (int i = 0; i <= maxFreq; i++) {
        buckets.add(new ArrayList<>());
    }

    // Group numbers by frequency
    for (Map.Entry<Integer, Integer> entry : count.entrySet()) {
        int num = entry.getKey();
        int freq = entry.getValue();
        buckets.get(freq).add(num);
    }

    // Sort numbers within each frequency bucket (descending for same frequency)
    for (List<Integer> bucket : buckets) {
        bucket.sort((a, b) -> b - a);
    }

    // Build result
    List<Integer> result = new ArrayList<>();
    for (int freq = 1; freq <= maxFreq; freq++) {
        for (int num : buckets.get(freq)) {
            for (int i = 0; i < freq; i++) {
                result.add(num);
            }
        }
    }

    return result.stream().mapToInt(i -> i).toArray();
}
```


***

## Implementation Tips

### Merge Sort Tips

1. **Base case handling**: Always check for arrays of size ≤ 1
2. **Merge optimization**: Use sentinel values to avoid boundary checks
3. **Memory optimization**: Reuse temporary arrays when possible
4. **Stability**: Ensure equal elements maintain relative order in merge step
```java
// Optimized merge with single temporary array
private static void mergeOptimized(int[] arr, int left, int mid, int right, int[] temp) {
    int i = left, j = mid + 1, k = left;

    // Copy to temp array
    for (int idx = left; idx <= right; idx++) {
        temp[idx] = arr[idx];
    }

    // Merge back to original array
    while (i <= mid && j <= right) {
        if (temp[i] <= temp[j]) {
            arr[k++] = temp[i++];
        } else {
            arr[k++] = temp[j++];
        }
    }

    while (i <= mid) arr[k++] = temp[i++];
    while (j <= right) arr[k++] = temp[j++];
}
```


### Quick Sort Tips

1. **Pivot selection**: Use median-of-three or randomization to avoid worst case
2. **Small arrays**: Switch to insertion sort for arrays < 10 elements
3. **Duplicate handling**: Use 3-way partitioning for arrays with many duplicates
4. **Tail recursion**: Optimize recursion for larger partition first
```java
// Tail recursion optimized quicksort
public static void quickSortTailRecursive(int[] arr, int low, int high) {
    while (low < high) {
        int pivotIndex = partition(arr, low, high);

        // Recur for smaller partition and iterate for larger
        if (pivotIndex - low < high - pivotIndex) {
            quickSortTailRecursive(arr, low, pivotIndex - 1);
            low = pivotIndex + 1;
        } else {
            quickSortTailRecursive(arr, pivotIndex + 1, high);
            high = pivotIndex - 1;
        }
    }
}
```


### Cyclic Sort Tips

1. **Always validate range**: Ensure numbers are in expected range before swapping
2. **Handle edge cases**: Empty arrays, single elements
3. **Use while loop**: More intuitive than for loop for this pattern
```java
// Safe cyclic sort template
public static void cyclicSortSafe(int[] nums) {
    int i = 0;

    while (i < nums.length) {
        int correctIndex = nums[i] - 1;

        // Validate before swapping
        if (nums[i] > 0 &&
            nums[i] <= nums.length &&
            nums[i] != nums[correctIndex]) {
            swap(nums, i, correctIndex);
        } else {
            i++;
        }
    }
}
```


### Counting Sort Tips

1. **Consider negative numbers**: Shift indices appropriately
2. **Memory optimization**: Use bit manipulation for boolean counting
3. **Stability matters**: Iterate backwards when building output

### Bucket Sort Tips

1. **Choose bucket size wisely**: Balance between memory and performance
2. **Handle empty buckets**: Check before processing
3. **Secondary sort**: Choose appropriate algorithm for individual buckets
