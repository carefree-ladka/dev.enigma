# Backend System Design Template

## Framework Overview

<img src="https://i.postimg.cc/02sYrPRn/system-design.png" alt="system design" />

<br />
<br />

The framework follows a structured approach with two primary goals:
1. **First Priority:** Satisfy Functional Requirements (deliver a working system)
2. **Second Priority:** Satisfy Non-Functional Requirements (optimize and scale)

**Flow:** Requirements â†’ Core Entities â†’ API Interface â†’ [Data Flow] â†’ High-Level Design â†’ Deep Dives

*Note: Data Flow (step 4) is optional and only needed for data processing systems*

---

## Table of Contents
- [Requirements (~5 minutes)](#requirements-5-minutes)
  - [Functional Requirements](#1-functional-requirements)
  - [Non-functional Requirements](#2-non-functional-requirements)
  - [Capacity Estimation](#3-capacity-estimation)
- [Core Entities (~2 minutes)](#core-entities-2-minutes)
- [API or System Interface (~5 minutes)](#api-or-system-interface-5-minutes)
- [Data Flow (~5 minutes) [Optional]](#data-flow-5-minutes-optional)
- [High Level Design (~10-15 minutes)](#high-level-design-10-15-minutes)
- [Deep Dives (~10 minutes)](#deep-dives-10-minutes)
- [Backend system design problems](#backend-system-design-problems)

---

## Requirements (~5 minutes)

### 1) Functional Requirements
*"Users/Clients should be able to..." statements - core features of your system*

**Key Questions to Ask:**
- Does the system need to do X?
- What would happen if Y?
- What are the top 3 most important features?

**Example Requirements:**
- [ ] Users should be able to [action]
- [ ] Users should be able to [action]
- [ ] Users should be able to [action]

> ğŸ’¡ **Tip:** Keep requirements targeted! Focus on top 3 features to avoid scope creep.

### 2) Non-functional Requirements
*"The system should be..." statements about system qualities*

**Checklist to Consider:**
- **CAP Theorem:** Consistency vs Availability preference?
- **Environment Constraints:** Mobile/battery/memory limitations?
- **Scalability:** Read vs write ratio? Bursty traffic patterns?
- **Latency:** Response time requirements (e.g., < 200ms)?
- **Durability:** Data loss tolerance?
- **Security:** Data protection and access control needs?
- **Fault Tolerance:** Failure handling requirements?
- **Compliance:** Legal/regulatory requirements?

**Example Requirements:**
- [ ] The system should prioritize [availability/consistency]
- [ ] The system should scale to support [X] users
- [ ] The system should have [feature] latency < [X]ms
- [ ] The system should [durability/security requirement]

### 3) Capacity Estimation
*Only perform calculations if they directly influence your design*

**When to Calculate:**
- Storage requirements affect partitioning strategy
- Traffic patterns influence caching decisions
- Data size impacts architectural choices

**Common Calculations:**
- Daily Active Users (DAU):
- Queries Per Second (QPS):
- Storage Requirements:
- Bandwidth:

---

## Core Entities (~2 minutes)
*List the core entities that your API will exchange and system will persist*

**Questions to Help Identify Entities:**
- What are the main "things" in this system?
- What data needs to be stored and retrieved?
- What objects do users interact with?

**Example Entities:**
- **Entity1:** Brief description
- **Entity2:** Brief description
- **Entity3:** Brief description

> ğŸ’¡ **Tip:** Choose good names! Start simple and evolve as you design.

---

## API or System Interface (~5 minutes)
*Define the contract between your system and its users*

### Protocol Choice
- **REST** (Default): HTTP verbs for CRUD operations
- **GraphQL**: When clients have diverse data needs
- **RPC/gRPC**: For internal APIs requiring high performance

### API Endpoints

**Authentication:**
- Always derive user context from auth token, not request body

**Example REST Endpoints:**
```java
POST /v1/[resource]
body: {
  "field": "value"
}

GET /v1/[resource]/{id} -> [Entity]

POST /v1/[resource]/{id}/[action]

GET /v1/[resource]?param=value -> [Entity][]
```

**Real-time Features:**
- WebSockets for bidirectional communication
- Server-Sent Events for server-to-client streaming

---

## Data Flow (~5 minutes) [Optional]
*High-level sequence of actions for data processing systems*

**When to Include:**
- Data processing systems
- Systems with complex workflows
- ETL/batch processing systems

**Example Flow:**
1. Step 1: Action/Process
2. Step 2: Action/Process
3. Step 3: Action/Process
4. Step 4: Action/Process
5. Step 5: Action/Process

---

## High Level Design (~10-15 minutes)
*Draw boxes and arrows representing system components and interactions*

### Design Approach
1. **Go endpoint by endpoint** - build up design sequentially
2. **Focus on functional requirements first**
3. **Note complexity areas** for later deep dives
4. **Talk through data flow** from request to response

### Key Components
- **Load Balancer:** Traffic distribution
- **Application Servers:** Business logic
- **Databases:** Data persistence
- **Caches:** Performance optimization
- **Message Queues:** Async processing
- **CDN:** Static content delivery

### Data Models
*Document relevant columns/fields next to database components*

**[Entity1] Table:**
- id: Primary key
- [relevant_field]: Description
- [relevant_field]: Description

**[Entity2] Table:**
- id: Primary key
- [relevant_field]: Description
- [relevant_field]: Description

> ğŸ’¡ **Tip:** Only document fields relevant to your design, not obvious ones like name/email.

### Architecture Diagram
```
[Client] -> [Load Balancer] -> [App Servers] -> [Database]
                            -> [Cache]
                            -> [Message Queue]
```

---

## Deep Dives (~10 minutes)
*Iterate on design to meet non-functional requirements and address bottlenecks*

### Areas to Address
1. **Non-functional Requirements:** Ensure all requirements are met
2. **Edge Cases:** Handle unusual scenarios
3. **Bottlenecks:** Identify and resolve performance issues
4. **Scalability:** Horizontal scaling, sharding, caching
5. **Reliability:** Fault tolerance, redundancy
6. **Security:** Authentication, authorization, data protection

### Common Deep Dive Topics

**Caching Strategy:**
- Cache levels (CDN, app-level, database)
- Cache invalidation policies
- Cache warming strategies

**Database Scaling:**
- Read replicas for read-heavy workloads
- Sharding strategies for write-heavy workloads
- Database partitioning approaches

**Performance Optimization:**
- Indexing strategies
- Query optimization
- Connection pooling

**Monitoring & Observability:**
- Logging strategy
- Metrics and alerting
- Distributed tracing

**Security Considerations:**
- Authentication mechanisms
- Rate limiting
- Input validation
- Data encryption

### Seniority Considerations
- **Junior:** Let interviewer guide deep dives
- **Senior:** Proactively identify areas for improvement
- **Staff+:** Lead comprehensive architectural discussions

> ğŸ’¡ **Tip:** Balance being proactive with giving interviewer space to ask questions.

---

**Interview Success Tips**

1. **Time Management:** Stick to recommended time allocations, use a timer if needed
2. **Stay Focused:** Resist urge to over-engineer early; build working system first
3. **Communicate Clearly:** Think out loud, explain trade-offs, ask clarifying questions
4. **Be Iterative:** Start with simple design, then enhance based on requirements
5. **Practice Tools:** Get familiar with whiteboarding software (Excalidraw, Lucidchart)
6. **Listen Actively:** Give interviewer space to guide discussion and ask questions
7. **Handle Ambiguity:** Ask targeted questions to clarify requirements early
8. **Show Trade-off Thinking:** Discuss pros/cons of different approaches
9. **Prepare Common Patterns:** Know standard solutions for caching, scaling, etc.
10. **Practice Drawing:** Be able to quickly sketch clean, understandable diagrams

**Common Pitfalls to Avoid:**

âŒ **Don't:** Dive into deep technical details too early
âœ… **Do:** Build complete system first, then optimize

âŒ **Don't:** Assume requirements without asking
âœ… **Do:** Clarify ambiguous requirements upfront

âŒ **Don't:** Design for maximum scale immediately
âœ… **Do:** Start simple and scale based on actual requirements

âŒ **Don't:** Ignore the interviewer and monologue
âœ… **Do:** Collaborate and respond to interviewer cues

âŒ **Don't:** Focus only on happy path scenarios
âœ… **Do:** Consider edge cases and failure modes

**Final Framework Reminder:**
> **Primary Goal:** Deliver a working system that satisfies functional requirements
> **Secondary Goal:** Optimize for non-functional requirements through deep dives

The key to success is following the structured approach while remaining flexible enough to adapt to your interviewer's style and the specific problem domain.

## Backend system design problems

## ğŸ”¹ Core Distributed System Problems
These test your knowledge of scalability, availability, and fault tolerance:

- **URL Shortener** (like TinyURL, Bitly) â€“ hashing, redirection, DB sharding.
- **Rate Limiter** (API gateway level) â€“ token bucket, sliding window, Redis.
- **Notification System** â€“ push/pull models, queues, retries, fan-out.
- **Logging & Metrics System** â€“ ingestion, aggregation, querying, storage.
- **Job Scheduler / Cron System** â€“ delayed jobs, retries, worker pools.

---

## ğŸ”¹ Social / Content Platforms
These test how you handle feeds, caching, and high-scale writes:

- **News Feed / Timeline** (Facebook, Twitter, Instagram) â€“ fan-out on write vs read.
- **Chat / Messaging System** (WhatsApp, Messenger, Slack) â€“ delivery guarantees, presence, scaling WebSockets.
- **Commenting System** (nested/threaded) â€“ pagination, consistency, moderation.
- **Video Streaming Platform** (YouTube, Netflix) â€“ CDN, transcoding, storage.
- **File/Photo Sharing Service** (Google Drive, Dropbox) â€“ chunking, sync, versioning.

---

## ğŸ”¹ Search / Query Intensive Systems
- **Autocomplete / Search Suggestions** â€“ Trie, prefix index, caching.
- **Full-text Search Engine** (like Elasticsearch) â€“ inverted index, relevance scoring.
- **Location-Based Service** (Uber, Yelp) â€“ geospatial indexes, proximity search.

---

## ğŸ”¹ E-commerce & Transactional Systems
- **E-commerce Backend** (Amazon, Flipkart) â€“ catalog, cart, orders, inventory.
- **Payment System** (Stripe, PayPal) â€“ transactions, idempotency, double spending.
- **Recommendation System** â€“ collaborative filtering, caching, precomputation.
- **Booking System** (Airbnb, TicketMaster) â€“ concurrency, seat locking, fairness.

---

## ğŸ”¹ Infrastructure / General Backend
- **Distributed Cache** (like Redis, Memcached) â€“ eviction policies, replication.
- **Load Balancer / Reverse Proxy** â€“ request routing, health checks.
- **Key-Value Store** (like DynamoDB, Cassandra) â€“ consistency vs availability.
- **Distributed Queue / Pub-Sub System** (Kafka, RabbitMQ) â€“ ordering, partitioning.
- **Configuration Management Service** (like Consul, ZooKeeper) â€“ leader election, consensus.

---

## ğŸ”¹ â€œClassicâ€ Big-Tech Style Questions
- **Design Instagram / Twitter** (feeds, hashtags, search, media storage).
- **Design WhatsApp** (real-time messaging, delivery guarantees).
- **Design Uber / Lyft** (geospatial, matching drivers & riders).
- **Design YouTube** (video storage, recommendations, CDN).
- **Design Google Docs** (collaborative editing â€“ CRDTs, OT).
- **Design Netflix** (video streaming, personalization).
- **Design Dropbox / Google Drive** (file sync & sharing).
- **Design Amazon / Flipkart** (e-commerce at scale).
- **Design a Ride-Hailing Service** (Uber/Lyft).
