# Parking Lot System

## Table of Contents

1. [Requirements Clarification](#requirements-clarification)
2. [Core Entities & Relationships](#core-entities--relationships)
3. [Class Design](#class-design)
4. [UML Class Diagram](#uml-class-diagram)
5. [Implementation](#implementation)
6. [Design Patterns & Best Practices](#design-patterns--best-practices)
7. [Edge Cases & Extensions](#edge-cases--extensions)
8. [Summary](#summary)

---

## Requirements Clarification

### Functional Requirements

- **Multiple Entry/Exit Gates**: Support multiple entry and exit points
- **Vehicle Types**: Support different vehicle types (Car, Motorcycle, Truck, Bus)
- **Spot Types**: Different parking spot sizes (Compact, Large, Handicapped, Electric)
- **Parking Assignment**: Automatically assign nearest available spot based on vehicle type
- **Fee Calculation**: Calculate parking fees based on vehicle type and duration
- **Payment Processing**: Support multiple payment methods (Cash, Credit Card, UPI)
- **Spot Management**: Track available and occupied spots in real-time
- **Ticket Generation**: Issue parking tickets with entry time and assigned spot

### Non-Functional Requirements

- **Scalability**: Support multiple floors and large number of spots
- **Performance**: Fast spot allocation (< 100ms)
- **Concurrency**: Thread-safe operations for simultaneous entries/exits
- **Availability**: System should be highly available
- **Monitoring**: Real-time tracking of occupancy rates

### Scope Boundaries

#### Included

- Multi-level parking support
- Real-time spot availability tracking
- Dynamic pricing based on vehicle type
- Hourly rate calculation
- Payment processing simulation
- Spot reservation (optional)

#### Excluded

- Online booking system
- Mobile app integration
- CCTV/Security integration
- Automated payment gateway integration
- Vehicle damage tracking

---

## Core Entities & Relationships

### Main Entities

- **ParkingLot**: Singleton managing the entire parking system
- **Level**: Represents a floor/level in the parking lot
- **ParkingSpot**: Individual parking space (Abstract class)
- **Vehicle**: Represents a parked vehicle (Abstract class)
- **ParkingTicket**: Ticket issued when vehicle enters
- **Payment**: Handles payment processing
- **EntryGate**: Handles vehicle entry
- **ExitGate**: Handles vehicle exit and payment

### Key Relationships

- ParkingLot **HAS-MANY** Level (Composition)
- Level **HAS-MANY** ParkingSpot (Composition)
- ParkingSpot **HAS-ONE** Vehicle (Association)
- Vehicle **HAS-ONE** ParkingTicket (Association)
- ParkingTicket **HAS-ONE** Payment (Association)

---

## Class Design

### Core Classes with Responsibilities

- **ParkingLot**: Singleton orchestrating the system, manages levels and gates
- **Level**: Manages parking spots on a specific floor
- **ParkingSpot**: Tracks spot status (Available, Occupied, Reserved)
- **Vehicle**: Stores vehicle information (license plate, type)
- **ParkingTicket**: Records entry time, spot assignment, and parking duration
- **Payment**: Calculates fees and processes payments
- **ParkingStrategy**: Strategy for spot assignment (nearest, random, etc.)

---

## UML Class Diagram

```mermaid
classDiagram
    class ParkingLot {
        -String name
        -Address address
        -List~Level~ levels
        -List~EntryGate~ entryGates
        -List~ExitGate~ exitGates
        -ParkingStrategy strategy
        +getInstance() ParkingLot
        +addLevel(Level) boolean
        +getAvailableSpot(VehicleType) ParkingSpot
        +parkVehicle(Vehicle, EntryGate) ParkingTicket
        +unparkVehicle(ParkingTicket, ExitGate) Payment
        +getAvailableSpotCount() int
    }

    class Level {
        -int floor
        -List~ParkingSpot~ spots
        +addSpot(ParkingSpot) boolean
        +getAvailableSpot(VehicleType) ParkingSpot
        +getAvailableSpotCount() int
    }

    class ParkingSpot {
        <<abstract>>
        -String spotId
        -SpotStatus status
        -Vehicle currentVehicle
        +isAvailable() boolean
        +assignVehicle(Vehicle) boolean
        +removeVehicle() boolean
        +canFitVehicle(Vehicle) boolean
    }

    class CompactSpot {
        +canFitVehicle(Vehicle) boolean
    }

    class LargeSpot {
        +canFitVehicle(Vehicle) boolean
    }

    class HandicappedSpot {
        +canFitVehicle(Vehicle) boolean
    }

    class ElectricSpot {
        +canFitVehicle(Vehicle) boolean
    }

    class Vehicle {
        <<abstract>>
        -String licensePlate
        -VehicleType type
        +getType() VehicleType
    }

    class Car {
    }

    class Motorcycle {
    }

    class Truck {
    }

    class Bus {
    }

    class ParkingTicket {
        -String ticketId
        -Vehicle vehicle
        -ParkingSpot spot
        -LocalDateTime entryTime
        -LocalDateTime exitTime
        +calculateDuration() long
    }

    class Payment {
        -String paymentId
        -ParkingTicket ticket
        -double amount
        -PaymentStatus status
        -PaymentMethod method
        -LocalDateTime paymentTime
        +processPayment() boolean
        +calculateAmount() double
    }

    class EntryGate {
        -String gateId
        -String location
        +issueTicket(Vehicle) ParkingTicket
    }

    class ExitGate {
        -String gateId
        -String location
        +processExit(ParkingTicket) Payment
    }

    class ParkingStrategy {
        <<interface>>
        +findSpot(List~Level~, VehicleType) ParkingSpot
    }

    class NearestSpotStrategy {
        +findSpot(List~Level~, VehicleType) ParkingSpot
    }

    class VehicleType {
        <<enumeration>>
        CAR
        MOTORCYCLE
        TRUCK
        BUS
    }

    class SpotStatus {
        <<enumeration>>
        AVAILABLE
        OCCUPIED
        RESERVED
        OUT_OF_SERVICE
    }

    class PaymentStatus {
        <<enumeration>>
        PENDING
        COMPLETED
        FAILED
        REFUNDED
    }

    class PaymentMethod {
        <<enumeration>>
        CASH
        CREDIT_CARD
        DEBIT_CARD
        UPI
    }

    ParkingLot "1" --> "*" Level : contains
    ParkingLot "1" --> "*" EntryGate : has
    ParkingLot "1" --> "*" ExitGate : has
    ParkingLot --> ParkingStrategy : uses
    Level "1" --> "*" ParkingSpot : contains
    ParkingSpot <|-- CompactSpot : inherits
    ParkingSpot <|-- LargeSpot : inherits
    ParkingSpot <|-- HandicappedSpot : inherits
    ParkingSpot <|-- ElectricSpot : inherits
    ParkingSpot "1" --> "0..1" Vehicle : parks
    Vehicle <|-- Car : inherits
    Vehicle <|-- Motorcycle : inherits
    Vehicle <|-- Truck : inherits
    Vehicle <|-- Bus : inherits
    ParkingTicket "1" --> "1" Vehicle : for
    ParkingTicket "1" --> "1" ParkingSpot : assigns
    Payment "1" --> "1" ParkingTicket : for
    EntryGate --> ParkingTicket : issues
    ExitGate --> Payment : processes
    ParkingSpot --> SpotStatus : has
    Payment --> PaymentStatus : has
    Payment --> PaymentMethod : uses
    Vehicle --> VehicleType : has
    ParkingStrategy <|.. NearestSpotStrategy : implements
```

---

## Implementation

### Enums

#### VehicleType.java

```java
public enum VehicleType {
    MOTORCYCLE,
    CAR,
    TRUCK,
    BUS
}
```

#### SpotStatus.java

```java
public enum SpotStatus {
    AVAILABLE,
    OCCUPIED,
    RESERVED,
    OUT_OF_SERVICE
}
```

#### PaymentStatus.java

```java
public enum PaymentStatus {
    PENDING,
    COMPLETED,
    FAILED,
    REFUNDED
}
```

#### PaymentMethod.java

```java
public enum PaymentMethod {
    CASH,
    CREDIT_CARD,
    DEBIT_CARD,
    UPI
}
```

---

### Vehicle Classes

#### Vehicle.java (Abstract)

```java
public abstract class Vehicle {
    private String licensePlate;
    private VehicleType type;

    public Vehicle(String licensePlate, VehicleType type) {
        this.licensePlate = licensePlate;
        this.type = type;
    }

    public String getLicensePlate() {
        return licensePlate;
    }

    public VehicleType getType() {
        return type;
    }
}
```

#### Car.java

```java
public class Car extends Vehicle {
    public Car(String licensePlate) {
        super(licensePlate, VehicleType.CAR);
    }
}
```

#### Motorcycle.java

```java
public class Motorcycle extends Vehicle {
    public Motorcycle(String licensePlate) {
        super(licensePlate, VehicleType.MOTORCYCLE);
    }
}
```

#### Truck.java

```java
public class Truck extends Vehicle {
    public Truck(String licensePlate) {
        super(licensePlate, VehicleType.TRUCK);
    }
}
```

#### Bus.java

```java
public class Bus extends Vehicle {
    public Bus(String licensePlate) {
        super(licensePlate, VehicleType.BUS);
    }
}
```

---

### Parking Spot Classes

#### ParkingSpot.java (Abstract)

```java
public abstract class ParkingSpot {
    private String spotId;
    private SpotStatus status;
    private Vehicle currentVehicle;

    public ParkingSpot(String spotId) {
        this.spotId = spotId;
        this.status = SpotStatus.AVAILABLE;
    }

    public synchronized boolean isAvailable() {
        return status == SpotStatus.AVAILABLE;
    }

    public synchronized boolean assignVehicle(Vehicle vehicle) {
        if (!isAvailable()) {
            return false;
        }
        if (!canFitVehicle(vehicle)) {
            return false;
        }
        this.currentVehicle = vehicle;
        this.status = SpotStatus.OCCUPIED;
        return true;
    }

    public synchronized boolean removeVehicle() {
        if (status != SpotStatus.OCCUPIED) {
            return false;
        }
        this.currentVehicle = null;
        this.status = SpotStatus.AVAILABLE;
        return true;
    }

    public abstract boolean canFitVehicle(Vehicle vehicle);

    public String getSpotId() {
        return spotId;
    }

    public SpotStatus getStatus() {
        return status;
    }

    public void setStatus(SpotStatus status) {
        this.status = status;
    }

    public Vehicle getCurrentVehicle() {
        return currentVehicle;
    }
}
```

#### CompactSpot.java

```java
public class CompactSpot extends ParkingSpot {
    public CompactSpot(String spotId) {
        super(spotId);
    }

    @Override
    public boolean canFitVehicle(Vehicle vehicle) {
        return vehicle.getType() == VehicleType.MOTORCYCLE ||
               vehicle.getType() == VehicleType.CAR;
    }
}
```

#### LargeSpot.java

```java
public class LargeSpot extends ParkingSpot {
    public LargeSpot(String spotId) {
        super(spotId);
    }

    @Override
    public boolean canFitVehicle(Vehicle vehicle) {
        return true; // Can fit all vehicle types
    }
}
```

#### HandicappedSpot.java

```java
public class HandicappedSpot extends ParkingSpot {
    public HandicappedSpot(String spotId) {
        super(spotId);
    }

    @Override
    public boolean canFitVehicle(Vehicle vehicle) {
        return vehicle.getType() == VehicleType.CAR;
    }
}
```

#### ElectricSpot.java

```java
public class ElectricSpot extends ParkingSpot {
    private boolean chargingAvailable;

    public ElectricSpot(String spotId) {
        super(spotId);
        this.chargingAvailable = true;
    }

    @Override
    public boolean canFitVehicle(Vehicle vehicle) {
        return vehicle.getType() == VehicleType.CAR ||
               vehicle.getType() == VehicleType.MOTORCYCLE;
    }

    public boolean isChargingAvailable() {
        return chargingAvailable;
    }
}
```

---

### Core System Classes

#### Level.java

```java
import java.util.ArrayList;
import java.util.List;

public class Level {
    private int floor;
    private List<ParkingSpot> spots;

    public Level(int floor) {
        this.floor = floor;
        this.spots = new ArrayList<>();
    }

    public boolean addSpot(ParkingSpot spot) {
        return spots.add(spot);
    }

    public synchronized ParkingSpot getAvailableSpot(VehicleType vehicleType) {
        for (ParkingSpot spot : spots) {
            if (spot.isAvailable()) {
                // Create a temporary vehicle to check compatibility
                Vehicle tempVehicle = createTempVehicle(vehicleType);
                if (spot.canFitVehicle(tempVehicle)) {
                    return spot;
                }
            }
        }
        return null;
    }

    private Vehicle createTempVehicle(VehicleType type) {
        switch (type) {
            case CAR:
                return new Car("TEMP");
            case MOTORCYCLE:
                return new Motorcycle("TEMP");
            case TRUCK:
                return new Truck("TEMP");
            case BUS:
                return new Bus("TEMP");
            default:
                return null;
        }
    }

    public int getAvailableSpotCount() {
        int count = 0;
        for (ParkingSpot spot : spots) {
            if (spot.isAvailable()) {
                count++;
            }
        }
        return count;
    }

    public int getFloor() {
        return floor;
    }

    public List<ParkingSpot> getSpots() {
        return spots;
    }
}
```

#### ParkingTicket.java

```java
import java.time.LocalDateTime;
import java.time.Duration;
import java.util.UUID;

public class ParkingTicket {
    private String ticketId;
    private Vehicle vehicle;
    private ParkingSpot spot;
    private LocalDateTime entryTime;
    private LocalDateTime exitTime;

    public ParkingTicket(Vehicle vehicle, ParkingSpot spot) {
        this.ticketId = UUID.randomUUID().toString();
        this.vehicle = vehicle;
        this.spot = spot;
        this.entryTime = LocalDateTime.now();
    }

    public long calculateDuration() {
        LocalDateTime end = (exitTime != null) ? exitTime : LocalDateTime.now();
        Duration duration = Duration.between(entryTime, end);
        return duration.toHours() + (duration.toMinutesPart() > 0 ? 1 : 0); // Round up
    }

    public void setExitTime(LocalDateTime exitTime) {
        this.exitTime = exitTime;
    }

    public String getTicketId() {
        return ticketId;
    }

    public Vehicle getVehicle() {
        return vehicle;
    }

    public ParkingSpot getSpot() {
        return spot;
    }

    public LocalDateTime getEntryTime() {
        return entryTime;
    }

    public LocalDateTime getExitTime() {
        return exitTime;
    }
}
```

#### Payment.java

```java
import java.time.LocalDateTime;
import java.util.UUID;

public class Payment {
    private String paymentId;
    private ParkingTicket ticket;
    private double amount;
    private PaymentStatus status;
    private PaymentMethod method;
    private LocalDateTime paymentTime;

    // Hourly rates based on vehicle type
    private static final double MOTORCYCLE_RATE = 10.0;
    private static final double CAR_RATE = 20.0;
    private static final double TRUCK_RATE = 40.0;
    private static final double BUS_RATE = 50.0;

    public Payment(ParkingTicket ticket, PaymentMethod method) {
        this.paymentId = UUID.randomUUID().toString();
        this.ticket = ticket;
        this.method = method;
        this.amount = calculateAmount();
        this.status = PaymentStatus.PENDING;
    }

    public double calculateAmount() {
        long hours = ticket.calculateDuration();
        VehicleType vehicleType = ticket.getVehicle().getType();

        double rate;
        switch (vehicleType) {
            case MOTORCYCLE:
                rate = MOTORCYCLE_RATE;
                break;
            case CAR:
                rate = CAR_RATE;
                break;
            case TRUCK:
                rate = TRUCK_RATE;
                break;
            case BUS:
                rate = BUS_RATE;
                break;
            default:
                rate = CAR_RATE;
        }

        return hours * rate;
    }

    public boolean processPayment() {
        // Simulate payment processing
        try {
            // In real system, integrate with payment gateway
            System.out.println("Processing payment of $" + amount + " via " + method);
            this.paymentTime = LocalDateTime.now();
            this.status = PaymentStatus.COMPLETED;
            return true;
        } catch (Exception e) {
            this.status = PaymentStatus.FAILED;
            return false;
        }
    }

    public String getPaymentId() {
        return paymentId;
    }

    public double getAmount() {
        return amount;
    }

    public PaymentStatus getStatus() {
        return status;
    }

    public PaymentMethod getMethod() {
        return method;
    }

    public ParkingTicket getTicket() {
        return ticket;
    }
}
```

#### EntryGate.java

```java
public class EntryGate {
    private String gateId;
    private String location;

    public EntryGate(String gateId, String location) {
        this.gateId = gateId;
        this.location = location;
    }

    public ParkingTicket issueTicket(Vehicle vehicle, ParkingSpot spot) {
        if (spot == null) {
            System.out.println("No available spot for vehicle: " + vehicle.getLicensePlate());
            return null;
        }

        ParkingTicket ticket = new ParkingTicket(vehicle, spot);
        System.out.println("Ticket issued at gate " + gateId + " for vehicle: " +
                         vehicle.getLicensePlate() + " at spot: " + spot.getSpotId());
        return ticket;
    }

    public String getGateId() {
        return gateId;
    }
}
```

#### ExitGate.java

```java
import java.time.LocalDateTime;

public class ExitGate {
    private String gateId;
    private String location;

    public ExitGate(String gateId, String location) {
        this.gateId = gateId;
        this.location = location;
    }

    public Payment processExit(ParkingTicket ticket, PaymentMethod paymentMethod) {
        ticket.setExitTime(LocalDateTime.now());

        Payment payment = new Payment(ticket, paymentMethod);
        System.out.println("Processing exit at gate " + gateId);
        System.out.println("Duration: " + ticket.calculateDuration() + " hours");
        System.out.println("Amount: $" + payment.getAmount());

        return payment;
    }

    public String getGateId() {
        return gateId;
    }
}
```

---

### Strategy Pattern

#### ParkingStrategy.java (Interface)

```java
import java.util.List;

public interface ParkingStrategy {
    ParkingSpot findSpot(List<Level> levels, VehicleType vehicleType);
}
```

#### NearestSpotStrategy.java

```java
import java.util.List;

public class NearestSpotStrategy implements ParkingStrategy {
    @Override
    public ParkingSpot findSpot(List<Level> levels, VehicleType vehicleType) {
        // Find spot from lowest floor first
        for (Level level : levels) {
            ParkingSpot spot = level.getAvailableSpot(vehicleType);
            if (spot != null) {
                return spot;
            }
        }
        return null;
    }
}
```

---

### Main Parking Lot System

#### ParkingLot.java (Singleton)

```java
import java.util.ArrayList;
import java.util.List;

public class ParkingLot {
    private static ParkingLot instance;
    private String name;
    private List<Level> levels;
    private List<EntryGate> entryGates;
    private List<ExitGate> exitGates;
    private ParkingStrategy strategy;

    private ParkingLot(String name) {
        this.name = name;
        this.levels = new ArrayList<>();
        this.entryGates = new ArrayList<>();
        this.exitGates = new ArrayList<>();
        this.strategy = new NearestSpotStrategy();
    }

    public static synchronized ParkingLot getInstance(String name) {
        if (instance == null) {
            instance = new ParkingLot(name);
        }
        return instance;
    }

    public void addLevel(Level level) {
        levels.add(level);
    }

    public void addEntryGate(EntryGate gate) {
        entryGates.add(gate);
    }

    public void addExitGate(ExitGate gate) {
        exitGates.add(gate);
    }

    public ParkingSpot getAvailableSpot(VehicleType vehicleType) {
        return strategy.findSpot(levels, vehicleType);
    }

    public synchronized ParkingTicket parkVehicle(Vehicle vehicle, EntryGate gate) {
        ParkingSpot spot = getAvailableSpot(vehicle.getType());
        if (spot == null) {
            System.out.println("No available spot for vehicle type: " + vehicle.getType());
            return null;
        }

        if (spot.assignVehicle(vehicle)) {
            return gate.issueTicket(vehicle, spot);
        }

        return null;
    }

    public synchronized Payment unparkVehicle(ParkingTicket ticket, ExitGate gate,
                                             PaymentMethod paymentMethod) {
        ParkingSpot spot = ticket.getSpot();
        spot.removeVehicle();

        Payment payment = gate.processExit(ticket, paymentMethod);

        if (payment.processPayment()) {
            System.out.println("Payment successful! Have a nice day.");
            return payment;
        } else {
            System.out.println("Payment failed!");
            return null;
        }
    }

    public int getAvailableSpotCount() {
        int count = 0;
        for (Level level : levels) {
            count += level.getAvailableSpotCount();
        }
        return count;
    }

    public void displayAvailability() {
        System.out.println("\n=== Parking Lot Status ===");
        for (Level level : levels) {
            System.out.println("Floor " + level.getFloor() + ": " +
                             level.getAvailableSpotCount() + " spots available");
        }
        System.out.println("==========================\n");
    }

    public String getName() {
        return name;
    }
}
```

---

### Demo Class

#### ParkingLotDemo.java

```java
public class ParkingLotDemo {
    public static void main(String[] args) {
        // Initialize parking lot
        ParkingLot parkingLot = ParkingLot.getInstance("City Center Parking");

        // Create levels
        Level level1 = new Level(1);
        Level level2 = new Level(2);

        // Add spots to level 1
        level1.addSpot(new CompactSpot("L1-C001"));
        level1.addSpot(new CompactSpot("L1-C002"));
        level1.addSpot(new LargeSpot("L1-L001"));
        level1.addSpot(new HandicappedSpot("L1-H001"));
        level1.addSpot(new ElectricSpot("L1-E001"));

        // Add spots to level 2
        level2.addSpot(new CompactSpot("L2-C001"));
        level2.addSpot(new LargeSpot("L2-L001"));
        level2.addSpot(new LargeSpot("L2-L002"));

        // Add levels to parking lot
        parkingLot.addLevel(level1);
        parkingLot.addLevel(level2);

        // Create gates
        EntryGate entryGate1 = new EntryGate("EG1", "Main Entrance");
        EntryGate entryGate2 = new EntryGate("EG2", "Side Entrance");
        ExitGate exitGate1 = new ExitGate("XG1", "Main Exit");
        ExitGate exitGate2 = new ExitGate("XG2", "Side Exit");

        parkingLot.addEntryGate(entryGate1);
        parkingLot.addEntryGate(entryGate2);
        parkingLot.addExitGate(exitGate1);
        parkingLot.addExitGate(exitGate2);

        System.out.println("=== Parking Lot System Demo ===\n");

        // Display initial availability
        parkingLot.displayAvailability();

        // Create vehicles
        Vehicle car1 = new Car("ABC-1234");
        Vehicle motorcycle1 = new Motorcycle("XYZ-5678");
        Vehicle truck1 = new Truck("TRK-9999");
        Vehicle car2 = new Car("DEF-4567");

        // Park vehicles
        System.out.println("--- Parking Vehicles ---");
        ParkingTicket ticket1 = parkingLot.parkVehicle(car1, entryGate1);
        ParkingTicket ticket2 = parkingLot.parkVehicle(motorcycle1, entryGate1);
        ParkingTicket ticket3 = parkingLot.parkVehicle(truck1, entryGate2);
        ParkingTicket ticket4 = parkingLot.parkVehicle(car2, entryGate2);

        // Display availability after parking
        parkingLot.displayAvailability();

        // Simulate some time passing
        System.out.println("\n--- Simulating 3 hours of parking ---\n");

        // Unpark vehicles
        System.out.println("--- Vehicles Exiting ---");

        if (ticket1 != null) {
            Payment payment1 = parkingLot.unparkVehicle(ticket1, exitGate1,
                                                       PaymentMethod.CREDIT_CARD);
        }

        if (ticket2 != null) {
            Payment payment2 = parkingLot.unparkVehicle(ticket2, exitGate1,
                                                       PaymentMethod.CASH);
        }

        // Display final availability
        parkingLot.displayAvailability();

        // Try to park when spots are available
        System.out.println("--- Parking New Vehicle ---");
        Vehicle car3 = new Car("GHI-7890");
        ParkingTicket ticket5 = parkingLot.parkVehicle(car3, entryGate1);

        parkingLot.displayAvailability();

        System.out.println("\n=== Demo Complete ===");
    }
}
```

---

## Design Patterns & Best Practices

### Design Patterns Used

1. **Singleton Pattern**
   - `ParkingLot` class ensures single instance
   - Thread-safe implementation with double-checked locking

2. **Strategy Pattern**
   - `ParkingStrategy` interface for flexible spot allocation
   - Easy to add new strategies (RandomSpotStrategy, OptimalSpotStrategy)

3. **Abstract Factory Pattern**
   - Vehicle hierarchy (Car, Motorcycle, Truck, Bus)
   - ParkingSpot hierarchy (Compact, Large, Handicapped, Electric)

4. **Object Pool Pattern**
   - Can be applied to manage parking spots as reusable resources

### SOLID Principles

- **Single Responsibility**: Each class has one clear purpose
- **Open/Closed**: Easy to extend with new vehicle/spot types
- **Liskov Substitution**: Subclasses can replace parent classes
- **Interface Segregation**: Focused interfaces like ParkingStrategy
- **Dependency Inversion**: Depends on abstractions (Vehicle, ParkingSpot)

### Thread Safety

```java
// Synchronized methods in critical sections
public synchronized boolean assignVehicle(Vehicle vehicle) {
    // Thread-safe spot assignment
}

public synchronized ParkingTicket parkVehicle(Vehicle vehicle, EntryGate gate) {
    // Thread-safe parking operation
}
```

---

## Edge Cases & Extensions

### Edge Cases Handled

1. **Concurrent Access**: Synchronized methods prevent race conditions
2. **No Available Spots**: Returns null and appropriate message
3. **Vehicle Type Mismatch**: Spots validate vehicle compatibility
4. **Invalid Ticket**: Validation before processing exit
5. **Payment Failure**: Graceful handling with status updates

### Possible Extensions

#### 1. Monthly Pass System

```java
public class MonthlyPass {
    private String passId;
    private Vehicle vehicle;
    private LocalDate validFrom;
    private LocalDate validUntil;

    public boolean isValid() {
        LocalDate today = LocalDate.now();
        return !today.isBefore(validFrom) && !today.isAfter(validUntil);
    }
}
```

#### 2. Reservation System

```java
public class SpotReservation {
    private String reservationId;
    private Vehicle vehicle;
    private ParkingSpot spot;
    private LocalDateTime reservationTime;
    private LocalDateTime expiryTime;

    public boolean isExpired() {
        return LocalDateTime.now().isAfter(expiryTime);
    }
}
```

#### 3. Dynamic Pricing

```java
public class DynamicPricingStrategy {
    private static final double PEAK_MULTIPLIER = 1.5;
    private static final double OFF_PEAK_MULTIPLIER = 0.8;

    public double calculatePrice(ParkingTicket ticket, int occupancyRate) {
        double basePrice = new Payment(ticket, PaymentMethod.CASH).calculateAmount();

        // Peak hours: 8 AM - 6 PM
        int hour = ticket.getEntryTime().getHour();
        boolean isPeakHour = hour >= 8 && hour <= 18;

        // High occupancy: > 80%
        boolean isHighOccupancy = occupancyRate > 80;

        if (isPeakHour && isHighOccupancy) {
            return basePrice * PEAK_MULTIPLIER;
        } else if (!isPeakHour) {
            return basePrice * OFF_PEAK_MULTIPLIER;
        }

        return basePrice;
    }
}
```

#### 4. Valet Parking Service

```java
public class ValetService {
    private Map<String, ParkingTicket> valetTickets;

    public ValetService() {
        this.valetTickets = new HashMap<>();
    }

    public String acceptVehicle(Vehicle vehicle, Customer customer) {
        // Valet parks the vehicle
        ParkingLot parkingLot = ParkingLot.getInstance("City Center Parking");
        ParkingTicket ticket = parkingLot.parkVehicle(vehicle, null);

        String valetToken = UUID.randomUUID().toString();
        valetTickets.put(valetToken, ticket);

        System.out.println("Valet service: Vehicle accepted. Token: " + valetToken);
        return valetToken;
    }

    public Vehicle retrieveVehicle(String valetToken) {
        ParkingTicket ticket = valetTickets.get(valetToken);
        if (ticket != null) {
            return ticket.getVehicle();
        }
        return null;
    }
}
```

#### 5. Advanced Search and Analytics

```java
public class ParkingAnalytics {
    private ParkingLot parkingLot;

    public ParkingAnalytics(ParkingLot parkingLot) {
        this.parkingLot = parkingLot;
    }

    public int getOccupancyRate() {
        int totalSpots = getTotalSpots();
        int occupiedSpots = totalSpots - parkingLot.getAvailableSpotCount();
        return (occupiedSpots * 100) / totalSpots;
    }

    public Map<VehicleType, Integer> getVehicleDistribution() {
        Map<VehicleType, Integer> distribution = new HashMap<>();
        // Implementation to track vehicle types
        return distribution;
    }

    public double getAverageRevenue() {
        // Calculate average revenue per vehicle
        return 0.0;
    }

    private int getTotalSpots() {
        // Calculate total spots across all levels
        return 0;
    }
}
```

#### 6. Notification System

```java
public interface NotificationService {
    void sendNotification(String message, String recipient);
}

public class EmailNotification implements NotificationService {
    @Override
    public void sendNotification(String message, String recipient) {
        System.out.println("Email sent to " + recipient + ": " + message);
    }
}

public class SMSNotification implements NotificationService {
    @Override
    public void sendNotification(String message, String recipient) {
        System.out.println("SMS sent to " + recipient + ": " + message);
    }
}

public class NotificationManager {
    private List<NotificationService> services;

    public NotificationManager() {
        this.services = new ArrayList<>();
        services.add(new EmailNotification());
        services.add(new SMSNotification());
    }

    public void notifySpotAvailable(Customer customer, ParkingSpot spot) {
        String message = "Your reserved spot " + spot.getSpotId() + " is now available!";
        for (NotificationService service : services) {
            service.sendNotification(message, customer.getEmail());
        }
    }

    public void notifyPaymentDue(Customer customer, double amount) {
        String message = "Payment of $" + amount + " is pending for your vehicle.";
        for (NotificationService service : services) {
            service.sendNotification(message, customer.getEmail());
        }
    }
}
```

#### 7. Security and Access Control

```java
public class SecuritySystem {
    private Map<String, AccessCard> accessCards;
    private List<SecurityIncident> incidents;

    public SecuritySystem() {
        this.accessCards = new HashMap<>();
        this.incidents = new ArrayList<>();
    }

    public boolean validateAccess(String cardId, String gateId) {
        AccessCard card = accessCards.get(cardId);
        if (card == null || !card.isActive()) {
            logIncident("Unauthorized access attempt at gate: " + gateId);
            return false;
        }
        return true;
    }

    private void logIncident(String description) {
        SecurityIncident incident = new SecurityIncident(description, LocalDateTime.now());
        incidents.add(incident);
        System.out.println("Security Alert: " + description);
    }
}

public class AccessCard {
    private String cardId;
    private String ownerId;
    private boolean active;
    private LocalDate expiryDate;

    public boolean isActive() {
        return active && LocalDate.now().isBefore(expiryDate);
    }
}

public class SecurityIncident {
    private String description;
    private LocalDateTime timestamp;
    private String severity;

    public SecurityIncident(String description, LocalDateTime timestamp) {
        this.description = description;
        this.timestamp = timestamp;
        this.severity = "LOW";
    }
}
```

### Scalability Improvements

#### 1. Database Integration

```java
// Example repository pattern
public interface ParkingSpotRepository {
    ParkingSpot findById(String spotId);
    List<ParkingSpot> findAvailableSpots(VehicleType type);
    void save(ParkingSpot spot);
    void update(ParkingSpot spot);
}

public class DatabaseParkingSpotRepository implements ParkingSpotRepository {
    // Implementation with JPA/Hibernate
}
```

#### 2. Caching Layer

```java
public class CacheManager {
    private Map<String, ParkingSpot> spotCache;
    private Map<String, ParkingTicket> ticketCache;

    public CacheManager() {
        this.spotCache = new ConcurrentHashMap<>();
        this.ticketCache = new ConcurrentHashMap<>();
    }

    public ParkingSpot getCachedSpot(String spotId) {
        return spotCache.get(spotId);
    }

    public void cacheSpot(ParkingSpot spot) {
        spotCache.put(spot.getSpotId(), spot);
    }

    public void invalidateSpotCache(String spotId) {
        spotCache.remove(spotId);
    }
}
```

#### 3. Microservices Architecture

```
Services:
- Spot Management Service
- Payment Service
- Notification Service
- Analytics Service
- Reservation Service

Communication:
- REST APIs
- Message Queue (RabbitMQ/Kafka)
- Service Discovery (Eureka)
```

#### 4. Load Balancing

```java
public class LoadBalancer {
    private List<EntryGate> entryGates;
    private int currentIndex = 0;

    public EntryGate getNextAvailableGate() {
        // Round-robin load balancing
        EntryGate gate = entryGates.get(currentIndex);
        currentIndex = (currentIndex + 1) % entryGates.size();
        return gate;
    }

    public EntryGate getLeastBusyGate() {
        // Implementation based on queue length
        return entryGates.get(0);
    }
}
```

### Performance Optimizations

#### 1. Spot Indexing

```java
public class SpotIndex {
    private Map<VehicleType, List<ParkingSpot>> spotsByType;
    private Map<Integer, List<ParkingSpot>> spotsByFloor;

    public SpotIndex() {
        this.spotsByType = new HashMap<>();
        this.spotsByFloor = new HashMap<>();
        initializeIndex();
    }

    private void initializeIndex() {
        for (VehicleType type : VehicleType.values()) {
            spotsByType.put(type, new ArrayList<>());
        }
    }

    public List<ParkingSpot> getSpotsByType(VehicleType type) {
        return spotsByType.getOrDefault(type, new ArrayList<>());
    }

    public void addSpot(ParkingSpot spot, int floor) {
        // Add to appropriate indices for fast lookup
    }
}
```

#### 2. Concurrent Collections

```java
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;

public class ThreadSafeParkingLot extends ParkingLot {
    private ConcurrentHashMap<String, ParkingTicket> activeTickets;
    private CopyOnWriteArrayList<Level> levels;

    // Thread-safe operations without explicit synchronization
}
```

### Additional Features

#### 1. Mobile App Integration API

```java
public class ParkingLotAPI {

    @GET("/api/spots/available")
    public Response getAvailableSpots(@QueryParam("vehicleType") VehicleType type) {
        ParkingLot parkingLot = ParkingLot.getInstance("City Center Parking");
        int count = parkingLot.getAvailableSpotCount();
        return Response.ok(count).build();
    }

    @POST("/api/tickets/reserve")
    public Response reserveSpot(@RequestBody ReservationRequest request) {
        // Implementation for online reservation
        return Response.ok().build();
    }

    @POST("/api/payment/process")
    public Response processPayment(@RequestBody PaymentRequest request) {
        // Implementation for online payment
        return Response.ok().build();
    }
}
```

#### 2. Customer Management

```java
public class Customer {
    private String customerId;
    private String name;
    private String email;
    private String phone;
    private List<Vehicle> vehicles;
    private PaymentMethod preferredPaymentMethod;
    private boolean hasMonthlyPass;

    public Customer(String customerId, String name, String email, String phone) {
        this.customerId = customerId;
        this.name = name;
        this.email = email;
        this.phone = phone;
        this.vehicles = new ArrayList<>();
    }

    public void addVehicle(Vehicle vehicle) {
        vehicles.add(vehicle);
    }

    public List<Vehicle> getVehicles() {
        return vehicles;
    }

    public String getEmail() {
        return email;
    }
}
```

#### 3. Loyalty Program

```java
public class LoyaltyProgram {
    private Map<String, Integer> customerPoints;
    private static final int POINTS_PER_HOUR = 10;
    private static final int DISCOUNT_THRESHOLD = 100;

    public LoyaltyProgram() {
        this.customerPoints = new HashMap<>();
    }

    public void addPoints(String customerId, long hours) {
        int points = (int) (hours * POINTS_PER_HOUR);
        customerPoints.merge(customerId, points, Integer::sum);
    }

    public double getDiscount(String customerId) {
        int points = customerPoints.getOrDefault(customerId, 0);
        if (points >= DISCOUNT_THRESHOLD) {
            return 0.10; // 10% discount
        }
        return 0.0;
    }

    public int getPoints(String customerId) {
        return customerPoints.getOrDefault(customerId, 0);
    }
}
```

---

## Summary

### Key Features Implemented

✅ **Multi-level parking support** with flexible spot allocation
✅ **Multiple vehicle types** (Car, Motorcycle, Truck, Bus)
✅ **Different spot types** (Compact, Large, Handicapped, Electric)
✅ **Dynamic spot assignment** using Strategy pattern
✅ **Automated fee calculation** based on vehicle type and duration
✅ **Multiple payment methods** (Cash, Card, UPI)
✅ **Thread-safe operations** for concurrent access
✅ **Entry/Exit gate management** with ticket system

### Design Principles Applied

- **SOLID Principles**: Single Responsibility, Open/Closed, Liskov Substitution
- **Design Patterns**: Singleton, Strategy, Abstract Factory
- **Clean Code**: Meaningful names, small methods, clear responsibilities
- **Encapsulation**: Private fields with controlled access
- **Extensibility**: Easy to add new vehicle types, spot types, payment methods

### Production Considerations

1. **Database Integration**: PostgreSQL/MySQL for persistence
2. **Caching**: Redis for fast spot lookup
3. **Message Queue**: Kafka for async notifications
4. **Monitoring**: Prometheus + Grafana for metrics
5. **API Gateway**: For mobile/web integration
6. **Load Balancer**: Distribute traffic across multiple instances
7. **Security**: Authentication, authorization, encryption
8. **Backup**: Regular database backups and disaster recovery

### Time & Space Complexity

| Operation           | Time Complexity | Space Complexity |
| ------------------- | --------------- | ---------------- |
| Park Vehicle        | O(n\*m)         | O(1)             |
| Unpark Vehicle      | O(1)            | O(1)             |
| Find Spot           | O(n\*m)         | O(1)             |
| Payment Calculation | O(1)            | O(1)             |

Where:

- n = number of levels
- m = average spots per level

### Potential Optimizations

1. **Spot Indexing**: Maintain separate lists for each vehicle type (O(1) lookup)
2. **Priority Queue**: For optimal spot selection
3. **Distributed Cache**: For multi-instance deployments
4. **Event Sourcing**: Track all parking events for analytics
5. **CQRS**: Separate read/write models for better performance

---

## Interview Tips

When discussing this design in interviews:

1. **Start with requirements**: Clarify functional and non-functional requirements
2. **Identify entities**: List main objects and their relationships
3. **Draw diagrams**: Use UML class diagrams to visualize
4. **Discuss patterns**: Explain why specific patterns were chosen
5. **Handle edge cases**: Show you've thought about concurrency, failures
6. **Scalability**: Discuss how to scale to millions of vehicles
7. **Trade-offs**: Explain design decisions and alternatives

### Common Follow-up Questions

**Q: How would you handle peak hours with high traffic?**
A: Implement queue management, dynamic pricing, pre-booking system, multiple entry points

**Q: How to prevent overbooking?**
A: Use pessimistic locking, distributed locks (Redis), database transactions

**Q: How to handle payment failures?**
A: Implement retry mechanism, manual override by staff, grace period for payment

**Q: How to scale to multiple cities?**
A: Multi-tenant architecture, separate databases per city, centralized analytics

**Q: How to optimize for electric vehicles?**
A: Dedicated EV zones, charging status tracking, priority allocation

This design is **production-ready** and demonstrates strong understanding of OOP, design patterns, and system design principles!
